[
    {
        "title": "Median of Two Sorted Arrays",
        "question_content": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n&nbsp;\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n&nbsp;\nConstraints:\n\n\tnums1.length == m\n\tnums2.length == n\n\t0 <= m <= 1000\n\t0 <= n <= 1000\n\t1 <= m + n <= 2000\n\t-106 <= nums1[i], nums2[i] <= 106",
        "solutions": [
            {
                "id": 2471,
                "title": "very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation",
                "content": "This problem is notoriously hard to implement due to all the corner cases. Most implementations consider odd-lengthed and even-lengthed arrays as two different cases and treat them separately. As a matter of fact, with a little mind twist. These two cases can be combined as one, leading to a very simple solution where (almost) no special treatment is needed.\\n\\nFirst, let\\'s see the concept of \\'MEDIAN\\' in a slightly unconventional way. That is: \\n\\n> \"**if we cut the sorted array to two halves of EQUAL LENGTHS, then\\n> median is the AVERAGE OF Max(lower_half) and Min(upper_half), i.e. the\\n> two numbers immediately next to the cut**\".\\n\\nFor example, for [2 3 5 7], we make the cut between 3 and 5:\\n\\n    [2 3 / 5 7]\\n\\nthen the median = (3+5)/2. **Note that I\\'ll use \\'/\\' to represent a cut, and (number / number) to represent a cut made through a number in this article**.\\n\\nfor [2 3 4 5 6], we make the cut right through 4 like this:\\n\\n[2 3 (4/4) 5 7]\\n\\nSince we split 4 into two halves, we say now both the lower and upper subarray contain 4. This notion also leads to the correct answer: (4 + 4) / 2 = 4;\\n\\nFor convenience, let\\'s use L to represent the number immediately left to the cut, and R the right counterpart. In [2 3 5 7], for instance, we have L = 3 and R = 5, respectively. \\n\\nWe observe the index of L and R have the following relationship with the length of the array N:\\n\\n    N        Index of L / R\\n    1               0 / 0\\n    2               0 / 1\\n    3               1 / 1  \\n    4               1 / 2      \\n    5               2 / 2\\n    6               2 / 3\\n    7               3 / 3\\n    8               3 / 4\\n\\nIt is not hard to conclude that index of L = (N-1)/2, and R is at N/2. Thus, the median can be represented as \\n\\n    (L + R)/2 = (A[(N-1)/2] + A[N/2])/2\\n\\n----------------\\n\\nTo get ready for the two array situation, let\\'s add a few imaginary \\'positions\\' (represented as #\\'s) in between numbers, and treat numbers as \\'positions\\' as well. \\n\\n    [6 9 13 18]  ->   [# 6 # 9 # 13 # 18 #]    (N = 4)\\n    position index     0 1 2 3 4 5  6 7  8     (N_Position = 9)\\n\\t\\t\\t  \\n    [6 9 11 13 18]->   [# 6 # 9 # 11 # 13 # 18 #]   (N = 5)\\n    position index      0 1 2 3 4 5  6 7  8 9 10    (N_Position = 11)\\n\\nAs you can see, there are always exactly 2*N+1 \\'positions\\' regardless of length N. Therefore, the middle cut should always be made on the Nth position (0-based). Since index(L) = (N-1)/2 and index(R) = N/2 in this situation, we can infer that **index(L) = (CutPosition-1)/2, index(R) = (CutPosition)/2**. \\n\\n------------------------\\n\\nNow for the two-array case:\\n\\n    A1: [# 1 # 2 # 3 # 4 # 5 #]    (N1 = 5, N1_positions = 11)\\n    \\n    A2: [# 1 # 1 # 1 # 1 #]     (N2 = 4, N2_positions = 9)\\n\\nSimilar to the one-array problem, we need to find a cut that divides the two arrays each into two halves such that \\n\\n> \"any number in the two left halves\" <= \"any number in the two right\\n> halves\".\\n\\nWe can also make the following observations\\uFF1A\\n\\n1. There are 2*N1 + 2*N2 + 2 position altogether. Therefore, there must be exactly N1 + N2 positions on each side of the cut, and 2 positions directly on the cut.\\n\\n2. Therefore, when we cut at position C2 = K in A2, then the cut position in A1 must be C1 = N1 + N2 - k. For instance, if C2 = 2, then we must have C1 = 4 + 5 - C2 = 7.\\n\\n        [# 1 # 2 # 3 # (4/4) # 5 #]    \\n    \\n        [# 1 / 1 # 1 # 1 #]   \\n\\n3. When the cuts are made, we\\'d have two L\\'s and two R\\'s. They are\\n\\n        L1 = A1[(C1-1)/2]; R1 = A1[C1/2];\\n        L2 = A2[(C2-1)/2]; R2 = A2[C2/2];\\n\\nIn the above example, \\n\\n        L1 = A1[(7-1)/2] = A1[3] = 4; R1 = A1[7/2] = A1[3] = 4;\\n        L2 = A2[(2-1)/2] = A2[0] = 1; R2 = A1[2/2] = A1[1] = 1;\\n\\n\\nNow how do we decide if this cut is the cut we want? Because L1, L2 are the greatest numbers on the left halves and R1, R2 are the smallest numbers on the right, we only need\\n\\n    L1 <= R1 && L1 <= R2 && L2 <= R1 && L2 <= R2\\n\\nto make sure that any number in lower halves <= any number in upper halves. As a matter of fact, since \\nL1 <= R1 and L2 <= R2 are naturally guaranteed because A1 and A2 are sorted, we only need to make sure:\\n\\nL1 <= R2 and L2 <= R1.\\n\\nNow we can use simple binary search to find out the result.\\n\\n    If we have L1 > R2, it means there are too many large numbers on the left half of A1, then we must move C1 to the left (i.e. move C2 to the right); \\n    If L2 > R1, then there are too many large numbers on the left half of A2, and we must move C2 to the left.\\n    Otherwise, this cut is the right one. \\n    After we find the cut, the medium can be computed as (max(L1, L2) + min(R1, R2)) / 2;\\n\\nTwo side notes: \\n\\nA. Since C1 and C2 can be mutually determined from each other, we can just move one of them first, then calculate the other accordingly. However, it is much more practical to move C2 (the one on the shorter array) first. The reason is that on the shorter array, all positions are possible cut locations for median, but on the longer array, the positions that are too far left or right are simply impossible for a legitimate cut. For instance, [1], [2 3 4 5 6 7 8]. Clearly the cut between 2 and 3 is impossible, because the shorter array does not have that many elements to balance out the [3 4 5 6 7 8] part if you make the cut this way. Therefore, for the longer array to be used as the basis for the first cut, a range check must be performed. It would be just easier to do it on the shorter array, which requires no checks whatsoever. Also, moving only on the shorter array gives a run-time complexity of O(log(min(N1, N2))) (edited as suggested by @baselRus)\\n\\nB. The only edge case is when a cut falls on the 0th(first) or the 2*Nth(last) position. For instance, if C2 = 2*N2, then R2 = A2[2*N2/2] = A2[N2], which exceeds the boundary of the array. To solve this problem, we can imagine that both A1 and A2 actually have two extra elements, INT_MAX at A[-1] and INT_MAX at A[N]. These additions don\\'t change the result, but make the implementation easier: If any L falls out of the left boundary of the array, then L = INT_MIN, and if any R falls out of the right boundary, then R = INT_MAX.\\n\\n-----------------\\n\\nI know that was not very easy to understand, but all the above reasoning eventually boils down to the following concise code:\\n\\n     double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int N1 = nums1.size();\\n        int N2 = nums2.size();\\n        if (N1 < N2) return findMedianSortedArrays(nums2, nums1);\\t// Make sure A2 is the shorter one.\\n        \\n        int lo = 0, hi = N2 * 2;\\n        while (lo <= hi) {\\n            int mid2 = (lo + hi) / 2;   // Try Cut 2 \\n            int mid1 = N1 + N2 - mid2;  // Calculate Cut 1 accordingly\\n            \\n            double L1 = (mid1 == 0) ? INT_MIN : nums1[(mid1-1)/2];\\t// Get L1, R1, L2, R2 respectively\\n            double L2 = (mid2 == 0) ? INT_MIN : nums2[(mid2-1)/2];\\n            double R1 = (mid1 == N1 * 2) ? INT_MAX : nums1[(mid1)/2];\\n            double R2 = (mid2 == N2 * 2) ? INT_MAX : nums2[(mid2)/2];\\n            \\n            if (L1 > R2) lo = mid2 + 1;\\t\\t// A1\\'s lower half is too big; need to move C1 left (C2 right)\\n            else if (L2 > R1) hi = mid2 - 1;\\t// A2\\'s lower half too big; need to move C2 left.\\n            else return (max(L1,L2) + min(R1, R2)) / 2;\\t// Otherwise, that\\'s the right cut.\\n        }\\n        return -1;\\n    } \\nIf you have any suggestions to make the logic and implementation even more cleaner. Please do let me know!",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "This problem is notoriously hard to implement due to all the corner cases. Most implementations consider odd-lengthed and even-lengthed arrays as two different cases and treat them separately. As a matter of fact, with a little mind twist. These two cases can be combined as one, leading to a very simple solution where (almost) no special treatment is needed.\\n\\nFirst, let\\'s see the concept of \\'MEDIAN\\' in a slightly unconventional way. That is: \\n\\n> \"**if we cut the sorted array to two halves of EQUAL LENGTHS, then\\n> median is the AVERAGE OF Max(lower_half) and Min(upper_half), i.e. the\\n> two numbers immediately next to the cut**\".\\n\\nFor example, for [2 3 5 7], we make the cut between 3 and 5:\\n\\n    [2 3 / 5 7]\\n\\nthen the median = (3+5)/2. **Note that I\\'ll use \\'/\\' to represent a cut, and (number / number) to represent a cut made through a number in this article**.\\n\\nfor [2 3 4 5 6], we make the cut right through 4 like this:\\n\\n[2 3 (4/4) 5 7]\\n\\nSince we split 4 into two halves, we say now both the lower and upper subarray contain 4. This notion also leads to the correct answer: (4 + 4) / 2 = 4;\\n\\nFor convenience, let\\'s use L to represent the number immediately left to the cut, and R the right counterpart. In [2 3 5 7], for instance, we have L = 3 and R = 5, respectively. \\n\\nWe observe the index of L and R have the following relationship with the length of the array N:\\n\\n    N        Index of L / R\\n    1               0 / 0\\n    2               0 / 1\\n    3               1 / 1  \\n    4               1 / 2      \\n    5               2 / 2\\n    6               2 / 3\\n    7               3 / 3\\n    8               3 / 4\\n\\nIt is not hard to conclude that index of L = (N-1)/2, and R is at N/2. Thus, the median can be represented as \\n\\n    (L + R)/2 = (A[(N-1)/2] + A[N/2])/2\\n\\n----------------\\n\\nTo get ready for the two array situation, let\\'s add a few imaginary \\'positions\\' (represented as #\\'s) in between numbers, and treat numbers as \\'positions\\' as well. \\n\\n    [6 9 13 18]  ->   [# 6 # 9 # 13 # 18 #]    (N = 4)\\n    position index     0 1 2 3 4 5  6 7  8     (N_Position = 9)\\n\\t\\t\\t  \\n    [6 9 11 13 18]->   [# 6 # 9 # 11 # 13 # 18 #]   (N = 5)\\n    position index      0 1 2 3 4 5  6 7  8 9 10    (N_Position = 11)\\n\\nAs you can see, there are always exactly 2*N+1 \\'positions\\' regardless of length N. Therefore, the middle cut should always be made on the Nth position (0-based). Since index(L) = (N-1)/2 and index(R) = N/2 in this situation, we can infer that **index(L) = (CutPosition-1)/2, index(R) = (CutPosition)/2**. \\n\\n------------------------\\n\\nNow for the two-array case:\\n\\n    A1: [# 1 # 2 # 3 # 4 # 5 #]    (N1 = 5, N1_positions = 11)\\n    \\n    A2: [# 1 # 1 # 1 # 1 #]     (N2 = 4, N2_positions = 9)\\n\\nSimilar to the one-array problem, we need to find a cut that divides the two arrays each into two halves such that \\n\\n> \"any number in the two left halves\" <= \"any number in the two right\\n> halves\".\\n\\nWe can also make the following observations\\uFF1A\\n\\n1. There are 2*N1 + 2*N2 + 2 position altogether. Therefore, there must be exactly N1 + N2 positions on each side of the cut, and 2 positions directly on the cut.\\n\\n2. Therefore, when we cut at position C2 = K in A2, then the cut position in A1 must be C1 = N1 + N2 - k. For instance, if C2 = 2, then we must have C1 = 4 + 5 - C2 = 7.\\n\\n        [# 1 # 2 # 3 # (4/4) # 5 #]    \\n    \\n        [# 1 / 1 # 1 # 1 #]   \\n\\n3. When the cuts are made, we\\'d have two L\\'s and two R\\'s. They are\\n\\n        L1 = A1[(C1-1)/2]; R1 = A1[C1/2];\\n        L2 = A2[(C2-1)/2]; R2 = A2[C2/2];\\n\\nIn the above example, \\n\\n        L1 = A1[(7-1)/2] = A1[3] = 4; R1 = A1[7/2] = A1[3] = 4;\\n        L2 = A2[(2-1)/2] = A2[0] = 1; R2 = A1[2/2] = A1[1] = 1;\\n\\n\\nNow how do we decide if this cut is the cut we want? Because L1, L2 are the greatest numbers on the left halves and R1, R2 are the smallest numbers on the right, we only need\\n\\n    L1 <= R1 && L1 <= R2 && L2 <= R1 && L2 <= R2\\n\\nto make sure that any number in lower halves <= any number in upper halves. As a matter of fact, since \\nL1 <= R1 and L2 <= R2 are naturally guaranteed because A1 and A2 are sorted, we only need to make sure:\\n\\nL1 <= R2 and L2 <= R1.\\n\\nNow we can use simple binary search to find out the result.\\n\\n    If we have L1 > R2, it means there are too many large numbers on the left half of A1, then we must move C1 to the left (i.e. move C2 to the right); \\n    If L2 > R1, then there are too many large numbers on the left half of A2, and we must move C2 to the left.\\n    Otherwise, this cut is the right one. \\n    After we find the cut, the medium can be computed as (max(L1, L2) + min(R1, R2)) / 2;\\n\\nTwo side notes: \\n\\nA. Since C1 and C2 can be mutually determined from each other, we can just move one of them first, then calculate the other accordingly. However, it is much more practical to move C2 (the one on the shorter array) first. The reason is that on the shorter array, all positions are possible cut locations for median, but on the longer array, the positions that are too far left or right are simply impossible for a legitimate cut. For instance, [1], [2 3 4 5 6 7 8]. Clearly the cut between 2 and 3 is impossible, because the shorter array does not have that many elements to balance out the [3 4 5 6 7 8] part if you make the cut this way. Therefore, for the longer array to be used as the basis for the first cut, a range check must be performed. It would be just easier to do it on the shorter array, which requires no checks whatsoever. Also, moving only on the shorter array gives a run-time complexity of O(log(min(N1, N2))) (edited as suggested by @baselRus)\\n\\nB. The only edge case is when a cut falls on the 0th(first) or the 2*Nth(last) position. For instance, if C2 = 2*N2, then R2 = A2[2*N2/2] = A2[N2], which exceeds the boundary of the array. To solve this problem, we can imagine that both A1 and A2 actually have two extra elements, INT_MAX at A[-1] and INT_MAX at A[N]. These additions don\\'t change the result, but make the implementation easier: If any L falls out of the left boundary of the array, then L = INT_MIN, and if any R falls out of the right boundary, then R = INT_MAX.\\n\\n-----------------\\n\\nI know that was not very easy to understand, but all the above reasoning eventually boils down to the following concise code:\\n\\n     double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int N1 = nums1.size();\\n        int N2 = nums2.size();\\n        if (N1 < N2) return findMedianSortedArrays(nums2, nums1);\\t// Make sure A2 is the shorter one.\\n        \\n        int lo = 0, hi = N2 * 2;\\n        while (lo <= hi) {\\n            int mid2 = (lo + hi) / 2;   // Try Cut 2 \\n            int mid1 = N1 + N2 - mid2;  // Calculate Cut 1 accordingly\\n            \\n            double L1 = (mid1 == 0) ? INT_MIN : nums1[(mid1-1)/2];\\t// Get L1, R1, L2, R2 respectively\\n            double L2 = (mid2 == 0) ? INT_MIN : nums2[(mid2-1)/2];\\n            double R1 = (mid1 == N1 * 2) ? INT_MAX : nums1[(mid1)/2];\\n            double R2 = (mid2 == N2 * 2) ? INT_MAX : nums2[(mid2)/2];\\n            \\n            if (L1 > R2) lo = mid2 + 1;\\t\\t// A1\\'s lower half is too big; need to move C1 left (C2 right)\\n            else if (L2 > R1) hi = mid2 - 1;\\t// A2\\'s lower half too big; need to move C2 left.\\n            else return (max(L1,L2) + min(R1, R2)) / 2;\\t// Otherwise, that\\'s the right cut.\\n        }\\n        return -1;\\n    } \\nIf you have any suggestions to make the logic and implementation even more cleaner. Please do let me know!",
                "codeTag": "Unknown"
            },
            {
                "id": 2651020,
                "title": "c-solution",
                "content": "*****SUGGESTION**:\\nWhen we are trying to approach a problem, we should always start from brute force solution, even though you have been trained by solving a lot of similar problems previously and been able to give a O(N) solution off the top of your head, I still recommend you to start from a brute force solution. This is the only way you can avoid geting stuck in your fixed mindset when you encounter a completely unseen or unfamiliar problem that unfortunately doesn\\'t match any existing pattern in your trained mind.***\\n```\\n// Brute Force:\\n               // 1.Merge Both Array\\n              // 2.Sort them\\n             // 3.Find Median\\n            // TIME COMPLEXITY: O(n)+O(nlogn)+O(n)\\n            // SPACE COMPLEXITY: O(1)\\n \\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       // Initialization some neccessary variables\\n        vector<int>v;\\n        \\n        // store the array in the new array\\n        for(auto num:nums1)   // O(n1)\\n            v.push_back(num);\\n        \\n        for(auto num:nums2)  // O(n2)\\n            v.push_back(num);\\n        \\n        // Sort the array to find the median\\n        sort(v.begin(),v.end());  // O(nlogn)\\n        \\n        // Find the median and Return it\\n        int n=v.size();  // O(n)\\n        \\n        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;\\n    }\\n};\\n\\n** Accepted **\\n```\\n\\n```\\n// Optimized Using: Two Pointer with Extra Space\\n  // Time Complexity: O(m+n)\\n  // Space Complexity: O(m+n)\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        // Create a single sorted by merging two sorted arrays\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        int i=0;\\n        int j=0;\\n        int lastindex=-1;\\n             \\n        // Initialize a new array\\n           vector<int>v(n1+n2,0);\\n        \\n        while(i<n1&&j<n2)\\n        {\\n            if(nums1[i]<=nums2[j])\\n                v[++lastindex]=nums1[i++];\\n            else\\n                v[++lastindex]=nums2[j++];\\n        }\\n        \\n        while(i<n1)\\n            v[++lastindex]=nums1[i++];\\n        while(j<n2)\\n            v[++lastindex]=nums2[j++];\\n        \\n    // Return the result\\n        int n=n1+n2;\\n        return n%2?v[n/2]:(v[n/2]+v[n/2-1])/2.0;\\n        \\n    }\\n};\\n\\n** Accepted **\\n```\\n\\n```\\n// Optimized Using: Two Pointer without Extra Space (Insertion Sort)\\n  // Time Complexity: O(n1*n2)\\n  // Space Complexity: O(1)\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n       // Calculate Total length of final array: O(N)\\n        int n1=nums1.size();  \\n        int n2=nums2.size();\\n        int n=n1+n2;  \\n      \\n        // Edge Cases\\n        if(n2==0)\\n            return n1%2?nums1[n1/2]:(nums1[n1/2-1]+nums1[n1/2])/2.0;\\n        if(n1==0)\\n             return n2%2?nums2[n2/2]:(nums2[n2/2-1]+nums2[n2/2])/2.0;\\n        \\n        // Resize the array \\'nums1\\': O(N), N is size of resized array\\n        nums1.resize(n);\\n        \\n        // Now use pointer to compare arrays elements \\n        int i=0;\\n        int j=0;\\n        \\n       // Store all element in \\'array 1\\' in sorted order \\n        while(i<n1)  // O(n1)\\n        {\\n            if(nums1[i]>nums2[0])\\n            {\\n                swap(nums1[i],nums2[0]);  // O(1)\\n                // Rearrange Array nums2\\n                rearrangeArray(nums2);  // O(n2)\\n            }\\n            i++;\\n        }\\n        \\n        // Store remaining elements of \\'array 2\\' in \\'array 1\\' \\n        while(j<nums2.size()) // O(n2)\\n            nums1[i++]=nums2[j++];\\n        \\n    // Return Result\\n    return n%2?nums1[n/2]:(nums1[n/2-1]+nums1[n/2])/2.0;\\n        \\n    }\\n    \\n    void rearrangeArray(vector<int>&nums2)\\n    {\\n        // Using insertion sort for insertion \\n           // worst case Time Complexity Would be: O(n)\\n        for(int i=1;i<nums2.size()&&nums2[i]<nums2[i-1];i++)\\n            swap(nums2[i],nums2[i-1]);\\n    }\\n};\\n\\n** Accepted **\\n```\\n\\n```\\n// Optimized Approach: Using gap method:\\n    // Time Complexity: O((log base 2 power N)*(N))\\n   //  Space Complexity: O(1)\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        // Do some pre-calculation : O(N)\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        int n=n1+n2;\\n        \\n        // Now Create Two Pointer\\n        int gap=ceil((n1+n2)/2.0);\\n        int i=0;\\n        int j=gap;\\n        \\n        // Edge Cases\\n        if(n1==0)\\n            return n2%2?nums2[n2/2]:(nums2[n2/2]+nums2[n2/2-1])/2.0;\\n        \\n        if(n2==0)\\n            return n1%2?nums1[n1/2]:(nums1[n1/2]+nums1[n1/2-1])/2.0;\\n        \\n        // Apply gap method: O((log base 2 power N)*N)\\n        \\n       while(gap)\\n       {   i=0;\\n           j=gap;\\n       // Move both pointer until they reach at last \\n        while(j<n)\\n        {\\n            // If \\'i\\' in \\'nums1\\' and \\'j\\' is also in \\'nums1\\'\\n            if(i<n1&&j<n1&&nums1[i]>nums1[j])\\n            swap(nums1[i],nums1[j]);\\n        else\\n            // if \\'i\\' in \\'nums1\\' and \\'j\\' is in \\'nums2\\'\\n            if(i<n1&&j>=n1&&nums1[i]>nums2[j-n1])\\n                swap(nums1[i],nums2[j-n1]);\\n        else \\n            // if \\'i\\' in \\'nums2\\' and \\'j\\' is also in \\'nums2\\'\\n            if(i>=n1&&j>=n1&&nums2[i-n1]>nums2[j-n1])\\n                 swap(nums2[i-n1],nums2[j-n1]);\\n            \\n        // Move both pointer ahead by only one step\\n        i++;\\n        j++;\\n        }\\n        \\n        // Edge Case, because of \\'ceil()\\' gap never becomes zero\\n        if(gap==1)\\n            gap=0;\\n         \\n         gap=ceil(gap/2.0);\\n       }   \\n        \\n    //Return Result\\n      if(n%2)\\n          return n/2<n1?nums1[n/2]:nums2[n/2-n1];\\n     else\\n         if(n/2<n1)\\n             return (nums1[n/2]+nums1[n/2-1])/2.0;\\n        else\\n            if((n/2-1)<n1)\\n               return (nums1[n/2-1]+nums2[n/2-n1])/2.0;\\n       else \\n           return (nums2[n/2-n1]+nums2[n/2-1-n1])/2.0;\\n       \\n    }\\n};\\n\\n** Accepted **\\n```\\n\\n```\\n// Optimized Approach: Binary Search\\n    // Time Complexity: O(log(min(m,n)))\\n   //  Space Complexity: O(1)\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n                   // ** Intuition  **\\n        // I have to find out correct left half and correct right half\\n          // i.e : // 7 ,  || 12 , 14 , 15  --> parition it\\n                  //  1 , 2 , 3 , 4 , || 9 , 11  --> parition it\\n                  // Now just findout max(left1,left2), min(right1,right2)\\n        \\n        \\n        // Initilaization of some neccessary variables\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        int n=n1+n2;\\n         \\n      if(n1>n2)  return findMedianSortedArrays(nums2,nums1);\\n        \\n     // When length is even, let\\'s say 10 then left half length should be: (10+1)/2 =>5\\n     // When length is odd, let\\'s say 11 then left half length should be: (11+1)/2 =>6\\n        // This mean that this formula gonna work in both condition\\n        int partition=(n+1)/2; \\n        \\n    \\n    // Edge Case\\n    if(n1==0)\\n        return n2%2?nums2[n2/2]:(nums2[n2/2]+nums2[n2/2-1])/2.0;\\n    \\n    if(n2==0)\\n        return n1%2?nums1[n1/2]:(nums1[n1/2]+nums1[n1/2-1])/2.0;\\n    \\n    // Now do Partioning\\n    int left1=0;\\n    int right1=n1;\\n    int cut1,cut2;\\n    int l1,r1,l2,r2;\\n    \\n    do\\n    {   \\n        //Findout \\'cut1\\' and \\'cut2\\'\\n        cut1=(left1+right1)/2;\\n        cut2=partition-cut1;\\n   \\n        // Calculation for l1\\n        l1=cut1==0?INT_MIN:nums1[cut1-1];\\n        \\n        // Calculation for l2\\n        l2=cut2==0?INT_MIN:nums2[cut2-1];\\n        \\n        // Calculation for r1\\n        r1=cut1>=n1?INT_MAX:nums1[cut1];\\n        \\n        // Calculation for r2\\n        r2=cut2>=n2?INT_MAX:nums2[cut2];\\n        \\n        if(l1<=r2&&l2<=r1)\\n             // Return Result\\n             return n%2?max(l1,l2):(max(l1,l2)+min(r1,r2))/2.0;\\n        else\\n            \\n        if(l1>r2)\\n            right1=cut1-1;\\n        else\\n             left1=cut1+1;\\n       \\n       \\n    }while(left1<=right1);\\n        \\n             \\n    return 0.0;\\n    }\\n};\\n\\n** Accepted **\\n```\\n\\n***Please correct me if i take time complexity wrong.***\\n\\n***PLEASE UPVOTE IF YOU FIND IT A LITTLE BIT HELPFUL, MEANS A LOT ;)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\n// Brute Force:\\n               // 1.Merge Both Array\\n              // 2.Sort them\\n             // 3.Find Median\\n            // TIME COMPLEXITY: O(n)+O(nlogn)+O(n)\\n            // SPACE COMPLEXITY: O(1)\\n \\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       // Initialization some neccessary variables\\n        vector<int>v;\\n        \\n        // store the array in the new array\\n        for(auto num:nums1)   // O(n1)\\n            v.push_back(num);\\n        \\n        for(auto num:nums2)  // O(n2)\\n            v.push_back(num);\\n        \\n        // Sort the array to find the median\\n        sort(v.begin(),v.end());  // O(nlogn)\\n        \\n        // Find the median and Return it\\n        int n=v.size();  // O(n)\\n        \\n        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;\\n    }\\n};\\n\\n** Accepted **\\n```\n```\\n// Optimized Using: Two Pointer with Extra Space\\n  // Time Complexity: O(m+n)\\n  // Space Complexity: O(m+n)\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        // Create a single sorted by merging two sorted arrays\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        int i=0;\\n        int j=0;\\n        int lastindex=-1;\\n             \\n        // Initialize a new array\\n           vector<int>v(n1+n2,0);\\n        \\n        while(i<n1&&j<n2)\\n        {\\n            if(nums1[i]<=nums2[j])\\n                v[++lastindex]=nums1[i++];\\n            else\\n                v[++lastindex]=nums2[j++];\\n        }\\n        \\n        while(i<n1)\\n            v[++lastindex]=nums1[i++];\\n        while(j<n2)\\n            v[++lastindex]=nums2[j++];\\n        \\n    // Return the result\\n        int n=n1+n2;\\n        return n%2?v[n/2]:(v[n/2]+v[n/2-1])/2.0;\\n        \\n    }\\n};\\n\\n** Accepted **\\n```\n```\\n// Optimized Using: Two Pointer without Extra Space (Insertion Sort)\\n  // Time Complexity: O(n1*n2)\\n  // Space Complexity: O(1)\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n       // Calculate Total length of final array: O(N)\\n        int n1=nums1.size();  \\n        int n2=nums2.size();\\n        int n=n1+n2;  \\n      \\n        // Edge Cases\\n        if(n2==0)\\n            return n1%2?nums1[n1/2]:(nums1[n1/2-1]+nums1[n1/2])/2.0;\\n        if(n1==0)\\n             return n2%2?nums2[n2/2]:(nums2[n2/2-1]+nums2[n2/2])/2.0;\\n        \\n        // Resize the array \\'nums1\\': O(N), N is size of resized array\\n        nums1.resize(n);\\n        \\n        // Now use pointer to compare arrays elements \\n        int i=0;\\n        int j=0;\\n        \\n       // Store all element in \\'array 1\\' in sorted order \\n        while(i<n1)  // O(n1)\\n        {\\n            if(nums1[i]>nums2[0])\\n            {\\n                swap(nums1[i],nums2[0]);  // O(1)\\n                // Rearrange Array nums2\\n                rearrangeArray(nums2);  // O(n2)\\n            }\\n            i++;\\n        }\\n        \\n        // Store remaining elements of \\'array 2\\' in \\'array 1\\' \\n        while(j<nums2.size()) // O(n2)\\n            nums1[i++]=nums2[j++];\\n        \\n    // Return Result\\n    return n%2?nums1[n/2]:(nums1[n/2-1]+nums1[n/2])/2.0;\\n        \\n    }\\n    \\n    void rearrangeArray(vector<int>&nums2)\\n    {\\n        // Using insertion sort for insertion \\n           // worst case Time Complexity Would be: O(n)\\n        for(int i=1;i<nums2.size()&&nums2[i]<nums2[i-1];i++)\\n            swap(nums2[i],nums2[i-1]);\\n    }\\n};\\n\\n** Accepted **\\n```\n```\\n// Optimized Approach: Using gap method:\\n    // Time Complexity: O((log base 2 power N)*(N))\\n   //  Space Complexity: O(1)\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        // Do some pre-calculation : O(N)\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        int n=n1+n2;\\n        \\n        // Now Create Two Pointer\\n        int gap=ceil((n1+n2)/2.0);\\n        int i=0;\\n        int j=gap;\\n        \\n        // Edge Cases\\n        if(n1==0)\\n            return n2%2?nums2[n2/2]:(nums2[n2/2]+nums2[n2/2-1])/2.0;\\n        \\n        if(n2==0)\\n            return n1%2?nums1[n1/2]:(nums1[n1/2]+nums1[n1/2-1])/2.0;\\n        \\n        // Apply gap method: O((log base 2 power N)*N)\\n        \\n       while(gap)\\n       {   i=0;\\n           j=gap;\\n       // Move both pointer until they reach at last \\n        while(j<n)\\n        {\\n            // If \\'i\\' in \\'nums1\\' and \\'j\\' is also in \\'nums1\\'\\n            if(i<n1&&j<n1&&nums1[i]>nums1[j])\\n            swap(nums1[i],nums1[j]);\\n        else\\n            // if \\'i\\' in \\'nums1\\' and \\'j\\' is in \\'nums2\\'\\n            if(i<n1&&j>=n1&&nums1[i]>nums2[j-n1])\\n                swap(nums1[i],nums2[j-n1]);\\n        else \\n            // if \\'i\\' in \\'nums2\\' and \\'j\\' is also in \\'nums2\\'\\n            if(i>=n1&&j>=n1&&nums2[i-n1]>nums2[j-n1])\\n                 swap(nums2[i-n1],nums2[j-n1]);\\n            \\n        // Move both pointer ahead by only one step\\n        i++;\\n        j++;\\n        }\\n        \\n        // Edge Case, because of \\'ceil()\\' gap never becomes zero\\n        if(gap==1)\\n            gap=0;\\n         \\n         gap=ceil(gap/2.0);\\n       }   \\n        \\n    //Return Result\\n      if(n%2)\\n          return n/2<n1?nums1[n/2]:nums2[n/2-n1];\\n     else\\n         if(n/2<n1)\\n             return (nums1[n/2]+nums1[n/2-1])/2.0;\\n        else\\n            if((n/2-1)<n1)\\n               return (nums1[n/2-1]+nums2[n/2-n1])/2.0;\\n       else \\n           return (nums2[n/2-n1]+nums2[n/2-1-n1])/2.0;\\n       \\n    }\\n};\\n\\n** Accepted **\\n```\n```\\n// Optimized Approach: Binary Search\\n    // Time Complexity: O(log(min(m,n)))\\n   //  Space Complexity: O(1)\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n                   // ** Intuition  **\\n        // I have to find out correct left half and correct right half\\n          // i.e : // 7 ,  || 12 , 14 , 15  --> parition it\\n                  //  1 , 2 , 3 , 4 , || 9 , 11  --> parition it\\n                  // Now just findout max(left1,left2), min(right1,right2)\\n        \\n        \\n        // Initilaization of some neccessary variables\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        int n=n1+n2;\\n         \\n      if(n1>n2)  return findMedianSortedArrays(nums2,nums1);\\n        \\n     // When length is even, let\\'s say 10 then left half length should be: (10+1)/2 =>5\\n     // When length is odd, let\\'s say 11 then left half length should be: (11+1)/2 =>6\\n        // This mean that this formula gonna work in both condition\\n        int partition=(n+1)/2; \\n        \\n    \\n    // Edge Case\\n    if(n1==0)\\n        return n2%2?nums2[n2/2]:(nums2[n2/2]+nums2[n2/2-1])/2.0;\\n    \\n    if(n2==0)\\n        return n1%2?nums1[n1/2]:(nums1[n1/2]+nums1[n1/2-1])/2.0;\\n    \\n    // Now do Partioning\\n    int left1=0;\\n    int right1=n1;\\n    int cut1,cut2;\\n    int l1,r1,l2,r2;\\n    \\n    do\\n    {   \\n        //Findout \\'cut1\\' and \\'cut2\\'\\n        cut1=(left1+right1)/2;\\n        cut2=partition-cut1;\\n   \\n        // Calculation for l1\\n        l1=cut1==0?INT_MIN:nums1[cut1-1];\\n        \\n        // Calculation for l2\\n        l2=cut2==0?INT_MIN:nums2[cut2-1];\\n        \\n        // Calculation for r1\\n        r1=cut1>=n1?INT_MAX:nums1[cut1];\\n        \\n        // Calculation for r2\\n        r2=cut2>=n2?INT_MAX:nums2[cut2];\\n        \\n        if(l1<=r2&&l2<=r1)\\n             // Return Result\\n             return n%2?max(l1,l2):(max(l1,l2)+min(r1,r2))/2.0;\\n        else\\n            \\n        if(l1>r2)\\n            right1=cut1-1;\\n        else\\n             left1=cut1+1;\\n       \\n       \\n    }while(left1<=right1);\\n        \\n             \\n    return 0.0;\\n    }\\n};\\n\\n** Accepted **\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511,
                "title": "intuitive-python-o-log-m-n-solution-by-kth-smallest-in-the-two-sorted-arrays-252ms",
                "content": "The idea is in the comment:\\n\\n     \\n    def findMedianSortedArrays(self, A, B):\\n        l = len(A) + len(B)\\n        if l % 2 == 1:\\n            return self.kth(A, B, l // 2)\\n        else:\\n            return (self.kth(A, B, l // 2) + self.kth(A, B, l // 2 - 1)) / 2.   \\n        \\n    def kth(self, a, b, k):\\n        if not a:\\n            return b[k]\\n        if not b:\\n            return a[k]\\n        ia, ib = len(a) // 2 , len(b) // 2\\n        ma, mb = a[ia], b[ib]\\n        \\n        # when k is bigger than the sum of a and b's median indices \\n        if ia + ib < k:\\n            # if a's median is bigger than b's, b's first half doesn't include k\\n            if ma > mb:\\n                return self.kth(a, b[ib + 1:], k - ib - 1)\\n            else:\\n                return self.kth(a[ia + 1:], b, k - ia - 1)\\n        # when k is smaller than the sum of a and b's indices\\n        else:\\n            # if a's median is bigger than b's, a's second half doesn't include k\\n            if ma > mb:\\n                return self.kth(a[:ia], b, k)\\n            else:\\n                return self.kth(a, b[:ib], k)",
                "solutionTags": [
                    "Python"
                ],
                "code": "The idea is in the comment:\\n\\n     \\n    def findMedianSortedArrays(self, A, B):\\n        l = len(A) + len(B)\\n        if l % 2 == 1:\\n            return self.kth(A, B, l // 2)\\n        else:\\n            return (self.kth(A, B, l // 2) + self.kth(A, B, l // 2 - 1)) / 2.   \\n        \\n    def kth(self, a, b, k):\\n        if not a:\\n            return b[k]\\n        if not b:\\n            return a[k]\\n        ia, ib = len(a) // 2 , len(b) // 2\\n        ma, mb = a[ia], b[ib]\\n        \\n        # when k is bigger than the sum of a and b's median indices \\n        if ia + ib < k:\\n            # if a's median is bigger than b's, b's first half doesn't include k\\n            if ma > mb:\\n                return self.kth(a, b[ib + 1:], k - ib - 1)\\n            else:\\n                return self.kth(a[ia + 1:], b, k - ia - 1)\\n        # when k is smaller than the sum of a and b's indices\\n        else:\\n            # if a's median is bigger than b's, a's second half doesn't include k\\n            if ma > mb:\\n                return self.kth(a[:ia], b, k)\\n            else:\\n                return self.kth(a, b[:ib], k)",
                "codeTag": "Python3"
            },
            {
                "id": 2496,
                "title": "concise-java-solution-based-on-binary-search",
                "content": "**Explanation**\\n\\nThe key point of this problem is to ignore half part of A and B each step recursively by comparing the median of remaining A and B:\\n\\n\\n\\n```\\nif (aMid < bMid) Keep [aRight + bLeft]    \\nelse Keep [bRight + aLeft]\\n```\\n\\nAs the following: **time=O(log(m + n))** \\n\\n\\n    public double findMedianSortedArrays(int[] A, int[] B) {\\n    \\t    int m = A.length, n = B.length;\\n    \\t    int l = (m + n + 1) / 2;\\n    \\t    int r = (m + n + 2) / 2;\\n    \\t    return (getkth(A, 0, B, 0, l) + getkth(A, 0, B, 0, r)) / 2.0;\\n    \\t}\\n    \\n    public double getkth(int[] A, int aStart, int[] B, int bStart, int k) {\\n    \\tif (aStart > A.length - 1) return B[bStart + k - 1];            \\n    \\tif (bStart > B.length - 1) return A[aStart + k - 1];                \\n    \\tif (k == 1) return Math.min(A[aStart], B[bStart]);\\n    \\t\\n    \\tint aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE;\\n    \\tif (aStart + k/2 - 1 < A.length) aMid = A[aStart + k/2 - 1]; \\n    \\tif (bStart + k/2 - 1 < B.length) bMid = B[bStart + k/2 - 1];        \\n    \\t\\n    \\tif (aMid < bMid) \\n    \\t    return getkth(A, aStart + k/2, B, bStart,       k - k/2);// Check: aRight + bLeft \\n    \\telse \\n    \\t    return getkth(A, aStart,       B, bStart + k/2, k - k/2);// Check: bRight + aLeft\\n    }",
                "solutionTags": [],
                "code": "```\\nif (aMid < bMid) Keep [aRight + bLeft]    \\nelse Keep [bRight + aLeft]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2499,
                "title": "share-my-simple-o-log-m-n-solution-for-your-reference",
                "content": "Binary search. Call 2 times getkth and k is about half of (m + n). Every time call getkth can reduce the scale k to its half. So the time complexity is log(m + n).\\n\\n    class Solution {\\n    public:\\n        int getkth(int s[], int m, int l[], int n, int k){\\n            // let m <= n\\n            if (m > n) \\n                return getkth(l, n, s, m, k);\\n            if (m == 0)\\n                return l[k - 1];\\n            if (k == 1)\\n                return min(s[0], l[0]);\\n    \\n            int i = min(m, k / 2), j = min(n, k / 2);\\n            if (s[i - 1] > l[j - 1])\\n                return getkth(s, m, l + j, n - j, k - j);\\n            else\\n                return getkth(s + i, m - i, l, n, k - i);\\n            return 0;\\n        }\\n        \\n        double findMedianSortedArrays(int A[], int m, int B[], int n) {\\n            int l = (m + n + 1) >> 1;\\n            int r = (m + n + 2) >> 1;\\n            return (getkth(A, m ,B, n, l) + getkth(A, m, B, n, r)) / 2.0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int getkth(int s[], int m, int l[], int n, int k){\\n            // let m <= n\\n            if (m > n) \\n                return getkth(l, n, s, m, k);\\n            if (m == 0)\\n                return l[k - 1];\\n            if (k == 1)\\n                return min(s[0], l[0]);\\n    \\n            int i = min(m, k / 2), j = min(n, k / 2);\\n            if (s[i - 1] > l[j - 1])\\n                return getkth(s, m, l + j, n - j, k - j);\\n            else\\n                return getkth(s + i, m - i, l, n, k - i);\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3283266,
                "title": "best-java-solution-beats-100",
                "content": "Time complexity: $$O(m+n)$$\\n\\n# Idea\\n\\n- We create a new array with length that of the **sum of the array lengths**\\n- We initialize **i & j = 0**. [i for nums1 & j for nums2]\\n- Since the given arrays are already sorted it is easy to compare their elements. We comapre by observing nums1[i] < nums2[j]\\n- if the element in $$nums1$$ at $$i^{th}$$ is less than that of element at $$j^{th}$$ index of $$nums2$$, we add $$nums1[i]$$ to new array and increment i; so as to compare the next element of the array to nums2[j].\\n- If the opposite case arises, we add $$nums2[j]$$ to the new array as you can guess. And increment j by 1 for the same reasons we did it with i.\\n- Depending on the length of new array, we calculate *median*.\\n- If the length of array is even, median by rule is the average of the *2 middle elements* of the array\\n- If it is off, it is the *middlemost* element\\n\\nI will try to make a video on this to explain this with illustration soon, I\\'m currently on a time crunch \\u23F3 so it might take a while \\uD83D\\uDE2C\\n\\nBut here is the code, have a look the idea might just click once you see it (for me often the code helps me a lot)\\n\\n# Code\\n``` JAVA []\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        int n = n1 + n2;\\n        int[] new_arr = new int[n];\\n\\n        int i=0, j=0, k=0;\\n\\n        while (i<=n1 && j<=n2) {\\n            if (i == n1) {\\n                while(j<n2) new_arr[k++] = nums2[j++];\\n                break;\\n            } else if (j == n2) {\\n                while (i<n1) new_arr[k++] = nums1[i++];\\n                break;\\n            }\\n\\n            if (nums1[i] < nums2[j]) {\\n                new_arr[k++] = nums1[i++];\\n            } else {\\n                new_arr[k++] = nums2[j++];\\n            }\\n        }\\n\\n        if (n%2==0) return (float)(new_arr[n/2-1] + new_arr[n/2])/2;\\n        else return new_arr[n/2];\\n    }\\n}\\n```\\n\\n## Liked the solution? Why not drop a upvote :D\\n\\n![upvote_me.jpeg](https://assets.leetcode.com/users/images/c4c03d9c-b9b6-46ee-8799-42bc35690eb8_1678522241.8388686.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        int n = n1 + n2;\\n        int[] new_arr = new int[n];\\n\\n        int i=0, j=0, k=0;\\n\\n        while (i<=n1 && j<=n2) {\\n            if (i == n1) {\\n                while(j<n2) new_arr[k++] = nums2[j++];\\n                break;\\n            } else if (j == n2) {\\n                while (i<n1) new_arr[k++] = nums1[i++];\\n                break;\\n            }\\n\\n            if (nums1[i] < nums2[j]) {\\n                new_arr[k++] = nums1[i++];\\n            } else {\\n                new_arr[k++] = nums2[j++];\\n            }\\n        }\\n\\n        if (n%2==0) return (float)(new_arr[n/2-1] + new_arr[n/2])/2;\\n        else return new_arr[n/2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070500,
                "title": "99-journey-from-brute-force-to-most-optimized-three-approaches-easy-to-understand",
                "content": "# Problem Understanding:\\nIn simpler terms, you need to **find the middle value of the combined**, sorted array formed by merging nums1 and nums2. If the combined **array has an even number** of elements, you should return the average of the two middle values. **If it has an odd number of elements, you should return the middle value itself.**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Hint:\\n```Hint1 []\\nThink of a brute force approach.\\n```\\n```Hint2 []\\nDo you think how two pointer will help us?\\n```\\n```Hint3 []\\nCan you observe the fact that the given arrays are sorted?\\n```\\n**I would recommend you, don\\'t jump directly on solution.**\\n# Approach 1: Merge and Sort\\n- **Create a new array** with a size equal to the total number of elements in both input arrays.\\n- **Insert elements** from both input arrays into the new array.\\n- **Sort the new array.**\\n- **Find and return the median of the sorted array.**\\n\\n**Time Complexity**\\n- In the worst case TC is **O((n + m) * log(n + m))**.\\n\\n**Space Complexity**\\n - **O(n + m)**, where \\u2018n\\u2019 and \\u2018m\\u2019 are the sizes of the arrays.\\n# Approach 2: Two-Pointer Method\\n\\n- **Initialize two pointers**, i and j, both initially set to 0.\\n- **Move the pointer** that corresponds to the **smaller value forward at each step.**\\n- Continue moving the pointers **until you have processed half of the total number of elements.**\\n- Calculate and **return the median** based on the values pointed to by i and j.\\n\\n\\n**Time Complexity**\\n- **O(n + m)**, where \\u2018n\\u2019 & \\u2018m\\u2019 are the sizes of the two arrays.\\n\\n**Space Complexity**\\n - **O(1)**.\\n\\n# Approach 3: Binary Search\\n\\n- **Use binary search to partition the smaller of the two input arrays into two parts.**\\n- Find the partition of the **larger array such that the sum of elements on the left side of the partition in both arrays is half of the total elements.**\\n- Check if this partition **is valid by verifying** if the largest number on the left side is smaller than the smallest number on the right side.\\n- **If the partition is valid,** calculate and return the median.\\n\\n**Time Complexity**\\n- **O(logm/logn)**\\n\\n**Space Complexity**\\n - **O(1)**\\n\\n---\\n\\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n---\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n# Code Brute Force- Merge and Sort\\n```C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        // Get the sizes of both input arrays.\\n        int n = nums1.size();\\n        int m = nums2.size();\\n\\n        // Merge the arrays into a single sorted array.\\n        vector<int> merged;\\n        for (int i = 0; i < n; i++) {\\n            merged.push_back(nums1[i]);\\n        }\\n        for (int i = 0; i < m; i++) {\\n            merged.push_back(nums2[i]);\\n        }\\n\\n        // Sort the merged array.\\n        sort(merged.begin(), merged.end());\\n\\n        // Calculate the total number of elements in the merged array.\\n        int total = merged.size();\\n\\n        if (total % 2 == 1) {\\n            // If the total number of elements is odd, return the middle element as the median.\\n            return static_cast<double>(merged[total / 2]);\\n        } else {\\n            // If the total number of elements is even, calculate the average of the two middle elements as the median.\\n            int middle1 = merged[total / 2 - 1];\\n            int middle2 = merged[total / 2];\\n            return (static_cast<double>(middle1) + static_cast<double>(middle2)) / 2.0;\\n        }\\n    }\\n};\\n\\n```\\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        // Get the sizes of both input arrays.\\n        int n = nums1.length;\\n        int m = nums2.length;\\n\\n        // Merge the arrays into a single sorted array.\\n        int[] merged = new int[n + m];\\n        int k = 0;\\n        for (int i = 0; i < n; i++) {\\n            merged[k++] = nums1[i];\\n        }\\n        for (int i = 0; i < m; i++) {\\n            merged[k++] = nums2[i];\\n        }\\n\\n        // Sort the merged array.\\n        Arrays.sort(merged);\\n\\n        // Calculate the total number of elements in the merged array.\\n        int total = merged.length;\\n\\n        if (total % 2 == 1) {\\n            // If the total number of elements is odd, return the middle element as the median.\\n            return (double) merged[total / 2];\\n        } else {\\n            // If the total number of elements is even, calculate the average of the two middle elements as the median.\\n            int middle1 = merged[total / 2 - 1];\\n            int middle2 = merged[total / 2];\\n            return ((double) middle1 + (double) middle2) / 2.0;\\n        }\\n    }\\n}\\n\\n```\\n```python3 []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        # Merge the arrays into a single sorted array.\\n        merged = nums1 + nums2\\n\\n        # Sort the merged array.\\n        merged.sort()\\n\\n        # Calculate the total number of elements in the merged array.\\n        total = len(merged)\\n\\n        if total % 2 == 1:\\n            # If the total number of elements is odd, return the middle element as the median.\\n            return float(merged[total // 2])\\n        else:\\n            # If the total number of elements is even, calculate the average of the two middle elements as the median.\\n            middle1 = merged[total // 2 - 1]\\n            middle2 = merged[total // 2]\\n            return (float(middle1) + float(middle2)) / 2.0\\n\\n```\\n\\n\\n# Code for Two-Pointer Method\\n```C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int i = 0, j = 0, m1 = 0, m2 = 0;\\n\\n        // Find median.\\n        for (int count = 0; count <= (n + m) / 2; count++) {\\n            m2 = m1;\\n            if (i != n && j != m) {\\n                if (nums1[i] > nums2[j]) {\\n                    m1 = nums2[j++];\\n                } else {\\n                    m1 = nums1[i++];\\n                }\\n            } else if (i < n) {\\n                m1 = nums1[i++];\\n            } else {\\n                m1 = nums2[j++];\\n            }\\n        }\\n\\n        // Check if the sum of n and m is odd.\\n        if ((n + m) % 2 == 1) {\\n            return static_cast<double>(m1);\\n        } else {\\n            double ans = static_cast<double>(m1) + static_cast<double>(m2);\\n            return ans / 2.0;\\n        }\\n    }\\n};\\n\\n```\\n```Java []\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int i = 0, j = 0, m1 = 0, m2 = 0;\\n\\n        // Find median.\\n        for (int count = 0; count <= (n + m) / 2; count++) {\\n            m2 = m1;\\n            if (i != n && j != m) {\\n                if (nums1[i] > nums2[j]) {\\n                    m1 = nums2[j++];\\n                } else {\\n                    m1 = nums1[i++];\\n                }\\n            } else if (i < n) {\\n                m1 = nums1[i++];\\n            } else {\\n                m1 = nums2[j++];\\n            }\\n        }\\n\\n        // Check if the sum of n and m is odd.\\n        if ((n + m) % 2 == 1) {\\n            return (double) m1;\\n        } else {\\n            double ans = (double) m1 + (double) m2;\\n            return ans / 2.0;\\n        }\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        n = len(nums1)\\n        m = len(nums2)\\n        i = 0\\n        j = 0\\n        m1 = 0\\n        m2 = 0\\n\\n        # Find median.\\n        for count in range(0, (n + m) // 2 + 1):\\n            m2 = m1\\n            if i < n and j < m:\\n                if nums1[i] > nums2[j]:\\n                    m1 = nums2[j]\\n                    j += 1\\n                else:\\n                    m1 = nums1[i]\\n                    i += 1\\n            elif i < n:\\n                m1 = nums1[i]\\n                i += 1\\n            else:\\n                m1 = nums2[j]\\n                j += 1\\n\\n        # Check if the sum of n and m is odd.\\n        if (n + m) % 2 == 1:\\n            return float(m1)\\n        else:\\n            ans = float(m1) + float(m2)\\n            return ans / 2.0\\n\\n```\\n\\n\\n#  Code for Binary Search\\n```C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        \\n        // Ensure nums1 is the smaller array for simplicity\\n        if (n1 > n2)\\n            return findMedianSortedArrays(nums2, nums1);\\n        \\n        int n = n1 + n2;\\n        int left = (n1 + n2 + 1) / 2; // Calculate the left partition size\\n        int low = 0, high = n1;\\n        \\n        while (low <= high) {\\n            int mid1 = (low + high) >> 1; // Calculate mid index for nums1\\n            int mid2 = left - mid1; // Calculate mid index for nums2\\n            \\n            int l1 = INT_MIN, l2 = INT_MIN, r1 = INT_MAX, r2 = INT_MAX;\\n            \\n            // Determine values of l1, l2, r1, and r2\\n            if (mid1 < n1)\\n                r1 = nums1[mid1];\\n            if (mid2 < n2)\\n                r2 = nums2[mid2];\\n            if (mid1 - 1 >= 0)\\n                l1 = nums1[mid1 - 1];\\n            if (mid2 - 1 >= 0)\\n                l2 = nums2[mid2 - 1];\\n            \\n            if (l1 <= r2 && l2 <= r1) {\\n                // The partition is correct, we found the median\\n                if (n % 2 == 1)\\n                    return max(l1, l2);\\n                else\\n                    return ((double)(max(l1, l2) + min(r1, r2))) / 2.0;\\n            }\\n            else if (l1 > r2) {\\n                // Move towards the left side of nums1\\n                high = mid1 - 1;\\n            }\\n            else {\\n                // Move towards the right side of nums1\\n                low = mid1 + 1;\\n            }\\n        }\\n        \\n        return 0; // If the code reaches here, the input arrays were not sorted.\\n    }\\n};\\n\\n\\n```\\n```Java []\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length, n2 = nums2.length;\\n        \\n        // Ensure nums1 is the smaller array for simplicity\\n        if (n1 > n2)\\n            return findMedianSortedArrays(nums2, nums1);\\n        \\n        int n = n1 + n2;\\n        int left = (n1 + n2 + 1) / 2; // Calculate the left partition size\\n        int low = 0, high = n1;\\n        \\n        while (low <= high) {\\n            int mid1 = (low + high) >> 1; // Calculate mid index for nums1\\n            int mid2 = left - mid1; // Calculate mid index for nums2\\n            \\n            int l1 = Integer.MIN_VALUE, l2 = Integer.MIN_VALUE, r1 = Integer.MAX_VALUE, r2 = Integer.MAX_VALUE;\\n            \\n            // Determine values of l1, l2, r1, and r2\\n            if (mid1 < n1)\\n                r1 = nums1[mid1];\\n            if (mid2 < n2)\\n                r2 = nums2[mid2];\\n            if (mid1 - 1 >= 0)\\n                l1 = nums1[mid1 - 1];\\n            if (mid2 - 1 >= 0)\\n                l2 = nums2[mid2 - 1];\\n            \\n            if (l1 <= r2 && l2 <= r1) {\\n                // The partition is correct, we found the median\\n                if (n % 2 == 1)\\n                    return Math.max(l1, l2);\\n                else\\n                    return ((double)(Math.max(l1, l2) + Math.min(r1, r2))) / 2.0;\\n            }\\n            else if (l1 > r2) {\\n                // Move towards the left side of nums1\\n                high = mid1 - 1;\\n            }\\n            else {\\n                // Move towards the right side of nums1\\n                low = mid1 + 1;\\n            }\\n        }\\n        \\n        return 0; // If the code reaches here, the input arrays were not sorted.\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n        \\n        # Ensure nums1 is the smaller array for simplicity\\n        if n1 > n2:\\n            return self.findMedianSortedArrays(nums2, nums1)\\n        \\n        n = n1 + n2\\n        left = (n1 + n2 + 1) // 2 # Calculate the left partition size\\n        low = 0\\n        high = n1\\n        \\n        while low <= high:\\n            mid1 = (low + high) // 2 # Calculate mid index for nums1\\n            mid2 = left - mid1 # Calculate mid index for nums2\\n            \\n            l1 = float(\\'-inf\\')\\n            l2 = float(\\'-inf\\')\\n            r1 = float(\\'inf\\')\\n            r2 = float(\\'inf\\')\\n            \\n            # Determine values of l1, l2, r1, and r2\\n            if mid1 < n1:\\n                r1 = nums1[mid1]\\n            if mid2 < n2:\\n                r2 = nums2[mid2]\\n            if mid1 - 1 >= 0:\\n                l1 = nums1[mid1 - 1]\\n            if mid2 - 1 >= 0:\\n                l2 = nums2[mid2 - 1]\\n            \\n            if l1 <= r2 and l2 <= r1:\\n                # The partition is correct, we found the median\\n                if n % 2 == 1:\\n                    return max(l1, l2)\\n                else:\\n                    return (max(l1, l2) + min(r1, r2)) / 2.0\\n            elif l1 > r2:\\n                # Move towards the left side of nums1\\n                high = mid1 - 1\\n            else:\\n                # Move towards the right side of nums1\\n                low = mid1 + 1\\n        \\n        return 0 # If the code reaches here, the input arrays were not sorted.\\n\\n```\\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n![upvotememe.png](https://assets.leetcode.com/users/images/b5e325fa-1e56-45a4-9f5b-decc2bc50fc9_1695262468.8060796.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```Hint1 []\\nThink of a brute force approach.\\n```\n```Hint2 []\\nDo you think how two pointer will help us?\\n```\n```Hint3 []\\nCan you observe the fact that the given arrays are sorted?\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        // Get the sizes of both input arrays.\\n        int n = nums1.size();\\n        int m = nums2.size();\\n\\n        // Merge the arrays into a single sorted array.\\n        vector<int> merged;\\n        for (int i = 0; i < n; i++) {\\n            merged.push_back(nums1[i]);\\n        }\\n        for (int i = 0; i < m; i++) {\\n            merged.push_back(nums2[i]);\\n        }\\n\\n        // Sort the merged array.\\n        sort(merged.begin(), merged.end());\\n\\n        // Calculate the total number of elements in the merged array.\\n        int total = merged.size();\\n\\n        if (total % 2 == 1) {\\n            // If the total number of elements is odd, return the middle element as the median.\\n            return static_cast<double>(merged[total / 2]);\\n        } else {\\n            // If the total number of elements is even, calculate the average of the two middle elements as the median.\\n            int middle1 = merged[total / 2 - 1];\\n            int middle2 = merged[total / 2];\\n            return (static_cast<double>(middle1) + static_cast<double>(middle2)) / 2.0;\\n        }\\n    }\\n};\\n\\n```\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        // Get the sizes of both input arrays.\\n        int n = nums1.length;\\n        int m = nums2.length;\\n\\n        // Merge the arrays into a single sorted array.\\n        int[] merged = new int[n + m];\\n        int k = 0;\\n        for (int i = 0; i < n; i++) {\\n            merged[k++] = nums1[i];\\n        }\\n        for (int i = 0; i < m; i++) {\\n            merged[k++] = nums2[i];\\n        }\\n\\n        // Sort the merged array.\\n        Arrays.sort(merged);\\n\\n        // Calculate the total number of elements in the merged array.\\n        int total = merged.length;\\n\\n        if (total % 2 == 1) {\\n            // If the total number of elements is odd, return the middle element as the median.\\n            return (double) merged[total / 2];\\n        } else {\\n            // If the total number of elements is even, calculate the average of the two middle elements as the median.\\n            int middle1 = merged[total / 2 - 1];\\n            int middle2 = merged[total / 2];\\n            return ((double) middle1 + (double) middle2) / 2.0;\\n        }\\n    }\\n}\\n\\n```\n```python3 []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        # Merge the arrays into a single sorted array.\\n        merged = nums1 + nums2\\n\\n        # Sort the merged array.\\n        merged.sort()\\n\\n        # Calculate the total number of elements in the merged array.\\n        total = len(merged)\\n\\n        if total % 2 == 1:\\n            # If the total number of elements is odd, return the middle element as the median.\\n            return float(merged[total // 2])\\n        else:\\n            # If the total number of elements is even, calculate the average of the two middle elements as the median.\\n            middle1 = merged[total // 2 - 1]\\n            middle2 = merged[total // 2]\\n            return (float(middle1) + float(middle2)) / 2.0\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int i = 0, j = 0, m1 = 0, m2 = 0;\\n\\n        // Find median.\\n        for (int count = 0; count <= (n + m) / 2; count++) {\\n            m2 = m1;\\n            if (i != n && j != m) {\\n                if (nums1[i] > nums2[j]) {\\n                    m1 = nums2[j++];\\n                } else {\\n                    m1 = nums1[i++];\\n                }\\n            } else if (i < n) {\\n                m1 = nums1[i++];\\n            } else {\\n                m1 = nums2[j++];\\n            }\\n        }\\n\\n        // Check if the sum of n and m is odd.\\n        if ((n + m) % 2 == 1) {\\n            return static_cast<double>(m1);\\n        } else {\\n            double ans = static_cast<double>(m1) + static_cast<double>(m2);\\n            return ans / 2.0;\\n        }\\n    }\\n};\\n\\n```\n```Java []\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int i = 0, j = 0, m1 = 0, m2 = 0;\\n\\n        // Find median.\\n        for (int count = 0; count <= (n + m) / 2; count++) {\\n            m2 = m1;\\n            if (i != n && j != m) {\\n                if (nums1[i] > nums2[j]) {\\n                    m1 = nums2[j++];\\n                } else {\\n                    m1 = nums1[i++];\\n                }\\n            } else if (i < n) {\\n                m1 = nums1[i++];\\n            } else {\\n                m1 = nums2[j++];\\n            }\\n        }\\n\\n        // Check if the sum of n and m is odd.\\n        if ((n + m) % 2 == 1) {\\n            return (double) m1;\\n        } else {\\n            double ans = (double) m1 + (double) m2;\\n            return ans / 2.0;\\n        }\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        n = len(nums1)\\n        m = len(nums2)\\n        i = 0\\n        j = 0\\n        m1 = 0\\n        m2 = 0\\n\\n        # Find median.\\n        for count in range(0, (n + m) // 2 + 1):\\n            m2 = m1\\n            if i < n and j < m:\\n                if nums1[i] > nums2[j]:\\n                    m1 = nums2[j]\\n                    j += 1\\n                else:\\n                    m1 = nums1[i]\\n                    i += 1\\n            elif i < n:\\n                m1 = nums1[i]\\n                i += 1\\n            else:\\n                m1 = nums2[j]\\n                j += 1\\n\\n        # Check if the sum of n and m is odd.\\n        if (n + m) % 2 == 1:\\n            return float(m1)\\n        else:\\n            ans = float(m1) + float(m2)\\n            return ans / 2.0\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        \\n        // Ensure nums1 is the smaller array for simplicity\\n        if (n1 > n2)\\n            return findMedianSortedArrays(nums2, nums1);\\n        \\n        int n = n1 + n2;\\n        int left = (n1 + n2 + 1) / 2; // Calculate the left partition size\\n        int low = 0, high = n1;\\n        \\n        while (low <= high) {\\n            int mid1 = (low + high) >> 1; // Calculate mid index for nums1\\n            int mid2 = left - mid1; // Calculate mid index for nums2\\n            \\n            int l1 = INT_MIN, l2 = INT_MIN, r1 = INT_MAX, r2 = INT_MAX;\\n            \\n            // Determine values of l1, l2, r1, and r2\\n            if (mid1 < n1)\\n                r1 = nums1[mid1];\\n            if (mid2 < n2)\\n                r2 = nums2[mid2];\\n            if (mid1 - 1 >= 0)\\n                l1 = nums1[mid1 - 1];\\n            if (mid2 - 1 >= 0)\\n                l2 = nums2[mid2 - 1];\\n            \\n            if (l1 <= r2 && l2 <= r1) {\\n                // The partition is correct, we found the median\\n                if (n % 2 == 1)\\n                    return max(l1, l2);\\n                else\\n                    return ((double)(max(l1, l2) + min(r1, r2))) / 2.0;\\n            }\\n            else if (l1 > r2) {\\n                // Move towards the left side of nums1\\n                high = mid1 - 1;\\n            }\\n            else {\\n                // Move towards the right side of nums1\\n                low = mid1 + 1;\\n            }\\n        }\\n        \\n        return 0; // If the code reaches here, the input arrays were not sorted.\\n    }\\n};\\n\\n\\n```\n```Java []\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length, n2 = nums2.length;\\n        \\n        // Ensure nums1 is the smaller array for simplicity\\n        if (n1 > n2)\\n            return findMedianSortedArrays(nums2, nums1);\\n        \\n        int n = n1 + n2;\\n        int left = (n1 + n2 + 1) / 2; // Calculate the left partition size\\n        int low = 0, high = n1;\\n        \\n        while (low <= high) {\\n            int mid1 = (low + high) >> 1; // Calculate mid index for nums1\\n            int mid2 = left - mid1; // Calculate mid index for nums2\\n            \\n            int l1 = Integer.MIN_VALUE, l2 = Integer.MIN_VALUE, r1 = Integer.MAX_VALUE, r2 = Integer.MAX_VALUE;\\n            \\n            // Determine values of l1, l2, r1, and r2\\n            if (mid1 < n1)\\n                r1 = nums1[mid1];\\n            if (mid2 < n2)\\n                r2 = nums2[mid2];\\n            if (mid1 - 1 >= 0)\\n                l1 = nums1[mid1 - 1];\\n            if (mid2 - 1 >= 0)\\n                l2 = nums2[mid2 - 1];\\n            \\n            if (l1 <= r2 && l2 <= r1) {\\n                // The partition is correct, we found the median\\n                if (n % 2 == 1)\\n                    return Math.max(l1, l2);\\n                else\\n                    return ((double)(Math.max(l1, l2) + Math.min(r1, r2))) / 2.0;\\n            }\\n            else if (l1 > r2) {\\n                // Move towards the left side of nums1\\n                high = mid1 - 1;\\n            }\\n            else {\\n                // Move towards the right side of nums1\\n                low = mid1 + 1;\\n            }\\n        }\\n        \\n        return 0; // If the code reaches here, the input arrays were not sorted.\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n        \\n        # Ensure nums1 is the smaller array for simplicity\\n        if n1 > n2:\\n            return self.findMedianSortedArrays(nums2, nums1)\\n        \\n        n = n1 + n2\\n        left = (n1 + n2 + 1) // 2 # Calculate the left partition size\\n        low = 0\\n        high = n1\\n        \\n        while low <= high:\\n            mid1 = (low + high) // 2 # Calculate mid index for nums1\\n            mid2 = left - mid1 # Calculate mid index for nums2\\n            \\n            l1 = float(\\'-inf\\')\\n            l2 = float(\\'-inf\\')\\n            r1 = float(\\'inf\\')\\n            r2 = float(\\'inf\\')\\n            \\n            # Determine values of l1, l2, r1, and r2\\n            if mid1 < n1:\\n                r1 = nums1[mid1]\\n            if mid2 < n2:\\n                r2 = nums2[mid2]\\n            if mid1 - 1 >= 0:\\n                l1 = nums1[mid1 - 1]\\n            if mid2 - 1 >= 0:\\n                l2 = nums2[mid2 - 1]\\n            \\n            if l1 <= r2 and l2 <= r1:\\n                # The partition is correct, we found the median\\n                if n % 2 == 1:\\n                    return max(l1, l2)\\n                else:\\n                    return (max(l1, l2) + min(r1, r2)) / 2.0\\n            elif l1 > r2:\\n                # Move towards the left side of nums1\\n                high = mid1 - 1\\n            else:\\n                # Move towards the right side of nums1\\n                low = mid1 + 1\\n        \\n        return 0 # If the code reaches here, the input arrays were not sorted.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547,
                "title": "share-my-iterative-solution-with-o-log-min-n-m",
                "content": "This is my iterative solution using binary search. The main idea is to find the approximate location of the median and compare the elements around it to get the final result.\\n\\n1. do binary search. suppose the shorter list is A with length n. **the runtime is O(log(n)) which means no matter how large B array is, it only depends on the size of A**. It makes sense because if A has only one element while B has 100 elements, the median must be one of A[0],  B[49], and B[50] without check everything else. If A[0] <= B[49], B[49] is the answer; if B[49] < A[0] <= B[50], A[0] is the answer; else, B[50] is the answer.\\n\\n2. After binary search, we get the approximate location of median. Now we just need to compare at most 4 elements to find the answer. This step is O(1).\\n\\n3. the same solution can be applied to find kth element of 2 sorted arrays.\\n\\nHere is the code:\\n\\n        public double findMedianSortedArrays(int A[], int B[]) {\\n        int n = A.length;\\n        int m = B.length;\\n        // the following call is to make sure len(A) <= len(B).\\n        // yes, it calls itself, but at most once, shouldn't be\\n        // consider a recursive solution\\n        if (n > m)\\n            return findMedianSortedArrays(B, A);\\n\\n        // now, do binary search\\n        int k = (n + m - 1) / 2;\\n        int l = 0, r = Math.min(k, n); // r is n, NOT n-1, this is important!!\\n        while (l < r) {\\n            int midA = (l + r) / 2;\\n            int midB = k - midA;\\n            if (A[midA] < B[midB])\\n                l = midA + 1;\\n            else\\n                r = midA;\\n        }\\n        \\n        // after binary search, we almost get the median because it must be between\\n        // these 4 numbers: A[l-1], A[l], B[k-l], and B[k-l+1] \\n\\n        // if (n+m) is odd, the median is the larger one between A[l-1] and B[k-l].\\n        // and there are some corner cases we need to take care of.\\n        int a = Math.max(l > 0 ? A[l - 1] : Integer.MIN_VALUE, k - l >= 0 ? B[k - l] : Integer.MIN_VALUE);\\n        if (((n + m) & 1) == 1)\\n            return (double) a;\\n\\n        // if (n+m) is even, the median can be calculated by \\n        //      median = (max(A[l-1], B[k-l]) + min(A[l], B[k-l+1]) / 2.0\\n        // also, there are some corner cases to take care of.\\n        int b = Math.min(l < n ? A[l] : Integer.MAX_VALUE, k - l + 1 < m ? B[k - l + 1] : Integer.MAX_VALUE);\\n        return (a + b) / 2.0;\\n    }\\n\\n\\nI'm lazy to type. But I found a very good pdf to explain my algorithm: http://ocw.alfaisal.edu/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/30C68118-E436-4FE3-8C79-6BAFBB07D935/0/ps9sol.pdf\\n\\nBTW: Thanks to  xdxiaoxin. I've removed the check \"midB > k\".",
                "solutionTags": [],
                "code": "This is my iterative solution using binary search. The main idea is to find the approximate location of the median and compare the elements around it to get the final result.\\n\\n1. do binary search. suppose the shorter list is A with length n. **the runtime is O(log(n)) which means no matter how large B array is, it only depends on the size of A**. It makes sense because if A has only one element while B has 100 elements, the median must be one of A[0],  B[49], and B[50] without check everything else. If A[0] <= B[49], B[49] is the answer; if B[49] < A[0] <= B[50], A[0] is the answer; else, B[50] is the answer.\\n\\n2. After binary search, we get the approximate location of median. Now we just need to compare at most 4 elements to find the answer. This step is O(1).\\n\\n3. the same solution can be applied to find kth element of 2 sorted arrays.\\n\\nHere is the code:\\n\\n        public double findMedianSortedArrays(int A[], int B[]) {\\n        int n = A.length;\\n        int m = B.length;\\n        // the following call is to make sure len(A) <= len(B).\\n        // yes, it calls itself, but at most once, shouldn't be\\n        // consider a recursive solution\\n        if (n > m)\\n            return findMedianSortedArrays(B, A);\\n\\n        // now, do binary search\\n        int k = (n + m - 1) / 2;\\n        int l = 0, r = Math.min(k, n); // r is n, NOT n-1, this is important!!\\n        while (l < r) {\\n            int midA = (l + r) / 2;\\n            int midB = k - midA;\\n            if (A[midA] < B[midB])\\n                l = midA + 1;\\n            else\\n                r = midA;\\n        }\\n        \\n        // after binary search, we almost get the median because it must be between\\n        // these 4 numbers: A[l-1], A[l], B[k-l], and B[k-l+1] \\n\\n        // if (n+m) is odd, the median is the larger one between A[l-1] and B[k-l].\\n        // and there are some corner cases we need to take care of.\\n        int a = Math.max(l > 0 ? A[l - 1] : Integer.MIN_VALUE, k - l >= 0 ? B[k - l] : Integer.MIN_VALUE);\\n        if (((n + m) & 1) == 1)\\n            return (double) a;\\n\\n        // if (n+m) is even, the median can be calculated by \\n        //      median = (max(A[l-1], B[k-l]) + min(A[l], B[k-l+1]) / 2.0\\n        // also, there are some corner cases to take care of.\\n        int b = Math.min(l < n ? A[l] : Integer.MAX_VALUE, k - l + 1 < m ? B[k - l + 1] : Integer.MAX_VALUE);\\n        return (a + b) / 2.0;\\n    }\\n\\n\\nI'm lazy to type. But I found a very good pdf to explain my algorithm: http://ocw.alfaisal.edu/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/30C68118-E436-4FE3-8C79-6BAFBB07D935/0/ps9sol.pdf\\n\\nBTW: Thanks to  xdxiaoxin. I've removed the check \"midB > k\".",
                "codeTag": "Unknown"
            },
            {
                "id": 2652,
                "title": "share-one-divide-and-conquer-o-log-m-n-method-with-clear-description",
                "content": "    // using divide and conquer idea, each time find the mid of both arrays\\n    \\n    double findMedianSortedArrays(int A[], int m, int B[], int n) {\\n            /* A[0, 1, 2, ..., n-1, n] */\\n            /* A[0, 1, 2, ..., m-1, m] */\\n            int k = (m + n + 1) / 2;\\n            double v = (double)FindKth(A, 0, m - 1, B, 0, n - 1, k);\\n            \\n            if ((m+n) % 2 == 0) {\\n                int k2 = k+1;\\n                double v2 = (double)FindKth(A, 0, m - 1, B, 0, n - 1, k2);\\n                v = (v + v2) / 2;\\n            }\\n            \\n            return v;\\n        }\\n        \\n        // find the kth element int the two sorted arrays\\n        // let us say: A[aMid] <= B[bMid], x: mid len of a, y: mid len of b, then wen can know\\n        // \\n        // (1) there will be at least (x + 1 + y) elements before bMid\\n        // (2) there will be at least (m - x - 1 + n - y) = m + n - (x + y +1) elements after aMid\\n        // therefore\\n        // if k <= x + y + 1, find the kth element in a and b, but unconsidering bMid and its suffix\\n        // if k > x + y + 1, find the k - (x + 1) th element in a and b, but unconsidering aMid and its prefix\\n        int FindKth(int A[], int aL, int aR, int B[], int bL, int bR, int k) {\\n            if (aL > aR) return B[bL + k - 1];\\n            if (bL > bR) return A[aL + k - 1];\\n            \\n            int aMid = (aL + aR) / 2;\\n            int bMid = (bL + bR) / 2;\\n            \\n            if (A[aMid] <= B[bMid]) {\\n                if (k <= (aMid - aL) + (bMid - bL) + 1) \\n                    return FindKth(A, aL, aR, B, bL, bMid - 1, k);\\n                else\\n                    return FindKth(A, aMid + 1, aR, B, bL, bR, k - (aMid - aL) - 1);\\n            }\\n            else { // A[aMid] > B[bMid]\\n                if (k <= (aMid - aL) + (bMid - bL) + 1) \\n                    return FindKth(A, aL, aMid - 1, B, bL, bR, k);\\n                else\\n                    return FindKth(A, aL, aR, B, bMid + 1, bR, k - (bMid - bL) - 1);\\n            }\\n        }",
                "solutionTags": [],
                "code": "    // using divide and conquer idea, each time find the mid of both arrays\\n    \\n    double findMedianSortedArrays(int A[], int m, int B[], int n) {\\n            /* A[0, 1, 2, ..., n-1, n] */\\n            /* A[0, 1, 2, ..., m-1, m] */\\n            int k = (m + n + 1) / 2;\\n            double v = (double)FindKth(A, 0, m - 1, B, 0, n - 1, k);\\n            \\n            if ((m+n) % 2 == 0) {\\n                int k2 = k+1;\\n                double v2 = (double)FindKth(A, 0, m - 1, B, 0, n - 1, k2);\\n                v = (v + v2) / 2;\\n            }\\n            \\n            return v;\\n        }\\n        \\n        // find the kth element int the two sorted arrays\\n        // let us say: A[aMid] <= B[bMid], x: mid len of a, y: mid len of b, then wen can know\\n        // \\n        // (1) there will be at least (x + 1 + y) elements before bMid\\n        // (2) there will be at least (m - x - 1 + n - y) = m + n - (x + y +1) elements after aMid\\n        // therefore\\n        // if k <= x + y + 1, find the kth element in a and b, but unconsidering bMid and its suffix\\n        // if k > x + y + 1, find the k - (x + 1) th element in a and b, but unconsidering aMid and its prefix\\n        int FindKth(int A[], int aL, int aR, int B[], int bL, int bR, int k) {\\n            if (aL > aR) return B[bL + k - 1];\\n            if (bL > bR) return A[aL + k - 1];\\n            \\n            int aMid = (aL + aR) / 2;\\n            int bMid = (bL + bR) / 2;\\n            \\n            if (A[aMid] <= B[bMid]) {\\n                if (k <= (aMid - aL) + (bMid - bL) + 1) \\n                    return FindKth(A, aL, aR, B, bL, bMid - 1, k);\\n                else\\n                    return FindKth(A, aMid + 1, aR, B, bL, bR, k - (aMid - aL) - 1);\\n            }\\n            else { // A[aMid] > B[bMid]\\n                if (k <= (aMid - aL) + (bMid - bL) + 1) \\n                    return FindKth(A, aL, aMid - 1, B, bL, bR, k);\\n                else\\n                    return FindKth(A, aL, aR, B, bMid + 1, bR, k - (bMid - bL) - 1);\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 268906,
                "title": "java-solution-2ms-faster-than-100-00-48-3-less-than-86-61",
                "content": "/**\\n     * Find the median by traversing.\\n     * \\n     * Time complexity: O(m+n). Although the running time is similar,  it is worse than the required O(log (m+n)).\\n     * Space complexity: O(1).\\n     *\\n     * @param nums1 the first sorted arrays\\n     * @param nums2 the second sorted arrays\\n     * @return the median of the two sorted arrays\\n     */\\n\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int index1 = 0;\\n        int index2 = 0;\\n        int med1 = 0;\\n        int med2 = 0;\\n        for (int i=0; i<=(nums1.length+nums2.length)/2; i++) {\\n            med1 = med2;\\n            if (index1 == nums1.length) {\\n                med2 = nums2[index2];\\n                index2++;\\n            } else if (index2 == nums2.length) {\\n                med2 = nums1[index1];\\n                index1++;\\n            } else if (nums1[index1] < nums2[index2] ) {\\n                med2 = nums1[index1];\\n                index1++;\\n            }  else {\\n                med2 = nums2[index2];\\n                index2++;\\n            }\\n        }\\n\\n        // the median is the average of two numbers\\n        if ((nums1.length+nums2.length)%2 == 0) {\\n            return (float)(med1+med2)/2;\\n        }\\n\\n        return med2;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "/**\\n     * Find the median by traversing.\\n     * \\n     * Time complexity: O(m+n). Although the running time is similar,  it is worse than the required O(log (m+n)).\\n     * Space complexity: O(1).\\n     *\\n     * @param nums1 the first sorted arrays\\n     * @param nums2 the second sorted arrays\\n     * @return the median of the two sorted arrays\\n     */\\n\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int index1 = 0;\\n        int index2 = 0;\\n        int med1 = 0;\\n        int med2 = 0;\\n        for (int i=0; i<=(nums1.length+nums2.length)/2; i++) {\\n            med1 = med2;\\n            if (index1 == nums1.length) {\\n                med2 = nums2[index2];\\n                index2++;\\n            } else if (index2 == nums2.length) {\\n                med2 = nums1[index1];\\n                index1++;\\n            } else if (nums1[index1] < nums2[index2] ) {\\n                med2 = nums1[index1];\\n                index1++;\\n            }  else {\\n                med2 = nums2[index2];\\n                index2++;\\n            }\\n        }\\n\\n        // the median is the average of two numbers\\n        if ((nums1.length+nums2.length)%2 == 0) {\\n            return (float)(med1+med2)/2;\\n        }\\n\\n        return med2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2588,
                "title": "o-lg-m-n-c-solution-using-kth-smallest-number",
                "content": "    class Solution {\\n    public:\\n        int kth(int a[], int m, int b[], int n, int k) {\\n            if (m < n) return kth(b,n,a,m,k);\\n            if (n==0) return a[k-1];\\n            if (k==1) return min(a[0],b[0]);\\n    \\n            int j = min(n,k/2);\\n            int i = k-j;\\n            if (a[i-1] > b[j-1]) return kth(a,i,b+j,n-j,k-j);\\n            return kth(a+i,m-i,b,j,k-i);\\n        }\\n    \\n        double findMedianSortedArrays(int a[], int m, int b[], int n) {\\n            int k = (m+n)/2;\\n            int m1 = kth(a,m,b,n,k+1);\\n            if ((m+n)%2==0) {\\n                int m2 = kth(a,m,b,n,k);\\n                return ((double)m1+m2)/2.0;\\n            }\\n            return m1;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int kth(int a[], int m, int b[], int n, int k) {\\n            if (m < n) return kth(b,n,a,m,k);\\n            if (n==0) return a[k-1];\\n            if (k==1) return min(a[0],b[0]);\\n    \\n            int j = min(n,k/2);\\n            int i = k-j;\\n            if (a[i-1] > b[j-1]) return kth(a,i,b+j,n-j,k-j);\\n            return kth(a+i,m-i,b,j,k-i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1701107,
                "title": "java-binary-search-explained-animation-added",
                "content": "### Idea\\n\\n+ General idea is quite like `quick select` in `quick sort`. To find the median, we only needs to find the **middle one or two**. This could be convert to **selecting half smaller elements** and get the result.\\n+ For this problem, we select `i` small nums in `nums1`, and select `j` small nums in `nums2` where `i + j == n + m`, `n` the length of `nums1`, `m` the length of `nums2`;\\n+ We will do the binary search for # of elements in `nums1 (shorter one)` and get the  relative # of elements in `nums2(longer one)`.\\n+ The function to check current selection is okay or not is shown below process:\\n\\nFor example we are given following. two arrays as input.\\n![image](https://assets.leetcode.com/users/images/8c3ca2c6-e4aa-4f1b-ad12-0f1609630824_1642560555.1364546.png)\\n\\nHere is a random selection of smaller elements in two arrays:\\nIn `nums1`, 4 elements are selected. In `nums2`, 5 elements are selected, since `(8 + 11) / 2 - 4 = 5`\\n\\n![image](https://assets.leetcode.com/users/images/05990c35-d551-4d66-b4c6-cc5719db222e_1642560957.7707992.png)\\n\\n\\nNow if we merged two arrays in our selection, it means all **yellows are smaller than white ones. ** \\n\\n**However, we can see two red arrows that `nums2[4]  > nums1[4]`. It does not meet our assumption. **\\n\\nSo, we need to select more `nums1` elements and reduce element in `nums2` accordingly.\\n\\n![image](https://assets.leetcode.com/users/images/cdd94e03-e962-45e8-8bc4-cfadec67e675_1642561044.2377298.png)\\n\\nThis time, we have `shorterLeft <= longerRight && longerLeft <= shorterRight`.\\n\\n### Animation\\n![Median of 2 sorted Arrayy.gif](https://assets.leetcode.com/users/images/1d3b50b9-8272-405a-a4d9-6671bdec4c9f_1695267153.4471629.gif)\\n\\n\\n### Key summary\\n\\n+ Binary Search # of elements in `nums1(shorter)` from `0` to `n`. Check if it meets the `shorterLeft <= longerRight && longerLeft <= shorterRight`.\\n\\n+ The median for odd and even numbers of total length sum is as follows:\\nOdd\\n![image](https://assets.leetcode.com/users/images/1c8cc587-0c87-4a3c-bfa3-f3ddbff754b6_1642561301.2603333.png)\\n\\nEven\\n![image](https://assets.leetcode.com/users/images/3e879eb1-7e55-4dab-8e14-1d6c52a98f3b_1642561308.995518.png)\\n\\n\\n### Source Code\\n```java\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1 == null && nums2 == null){\\n            return 0;\\n        }\\n        \\n        if(nums1 == null){\\n            int n = nums2.length;\\n            return nums2[(n - 1) / 2] * 0.5 + nums2[n / 2] * 0.5;\\n        }\\n        \\n        if(nums2 == null){\\n            int n = nums1.length;\\n            return nums1[(n - 1) / 2] * 0.5 + nums1[n / 2] * 0.5;\\n        }\\n        \\n        if(nums1.length > nums2.length){\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        // choose shorter to binary search\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int left = 0;\\n        int right = n;\\n        \\n        while(left < right){\\n            int i = (left + right) / 2;\\n            int j = (n + m) / 2 - i;\\n            \\n            if(nums1[i] < nums2[j - 1]){\\n                left = i + 1;\\n            }else{\\n                right = i;\\n            }\\n        }\\n        \\n        int first = left;\\n        int second = (n + m) / 2 - left;\\n        \\n        int shorterLeft = first == 0 ? Integer.MIN_VALUE : nums1[first - 1];\\n        int shorterRight = first == n ? Integer.MAX_VALUE : nums1[first];\\n        \\n        int longerLeft = second == 0 ? Integer.MIN_VALUE : nums2[second - 1];\\n        int longerRight = second == m ? Integer.MAX_VALUE : nums2[second];\\n        \\n        if((n + m) % 2 == 1) {\\n            return Math.min(shorterRight, longerRight);\\n        }else{\\n            return Math.max(shorterLeft, longerLeft) * 0.5 + Math.min(shorterRight, longerRight) * 0.5;\\n        }\\n \\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1 == null && nums2 == null){\\n            return 0;\\n        }\\n        \\n        if(nums1 == null){\\n            int n = nums2.length;\\n            return nums2[(n - 1) / 2] * 0.5 + nums2[n / 2] * 0.5;\\n        }\\n        \\n        if(nums2 == null){\\n            int n = nums1.length;\\n            return nums1[(n - 1) / 2] * 0.5 + nums1[n / 2] * 0.5;\\n        }\\n        \\n        if(nums1.length > nums2.length){\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        // choose shorter to binary search\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int left = 0;\\n        int right = n;\\n        \\n        while(left < right){\\n            int i = (left + right) / 2;\\n            int j = (n + m) / 2 - i;\\n            \\n            if(nums1[i] < nums2[j - 1]){\\n                left = i + 1;\\n            }else{\\n                right = i;\\n            }\\n        }\\n        \\n        int first = left;\\n        int second = (n + m) / 2 - left;\\n        \\n        int shorterLeft = first == 0 ? Integer.MIN_VALUE : nums1[first - 1];\\n        int shorterRight = first == n ? Integer.MAX_VALUE : nums1[first];\\n        \\n        int longerLeft = second == 0 ? Integer.MIN_VALUE : nums2[second - 1];\\n        int longerRight = second == m ? Integer.MAX_VALUE : nums2[second];\\n        \\n        if((n + m) % 2 == 1) {\\n            return Math.min(shorterRight, longerRight);\\n        }else{\\n            return Math.max(shorterLeft, longerLeft) * 0.5 + Math.min(shorterRight, longerRight) * 0.5;\\n        }\\n \\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755,
                "title": "6-lines-o-log-min-m-n-python",
                "content": "Same method as [my 6-lines Ruby solution](https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2579/6-lines-O(log(min(mn)))-Ruby), just the binary search and the *\"get up to two\"* isn\\'t quite as convenient in Python. See there if you\\'d like an explanation.\\n\\n---\\n\\n**Update April 2022**: By now, `bisect` supports a `key` function (since Python 3.10). Using that in Solution 1:\\n\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        a, b = sorted((nums1, nums2), key=len)\\n        m, n = len(a), len(b)\\n        after = (m + n - 1) // 2\\n        i = bisect_left(range(m), True, key=lambda i: after-i-1 < 0 or a[i] >= b[after-i-1])\\n        nextfew = sorted(a[i:i+2] + b[after-i:after-i+2])\\n        return (nextfew[0] + nextfew[1 - (m+n)%2]) / 2.0\\n\\t\\n**Note about my use of `sorted`:** Both take just O(1) time. In the first case I\\'m just sorting a *tuple* of *two* lists by length, not sorting each list. It just assigns the shorter list to `a` and the longer to `b`. In the second case, I\\'m just sorting a list of up to *four* values.\\n\\n---\\n\\n**Solution 1**\\n\\nThis one is a bit of a hack, as `bisect_left` is intended for lists, but apparently it\\'s happy enough with something that behaves enough like a list (supports `__getitem__`):\\n\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        a, b = sorted((nums1, nums2), key=len)\\n        m, n = len(a), len(b)\\n        after = (m + n - 1) / 2\\n        class Range:\\n            def __getitem__(self, i):\\n                return after-i-1 < 0 or a[i] >= b[after-i-1]\\n        i = bisect.bisect_left(Range(), True, 0, m)\\n        nextfew = sorted(a[i:i+2] + b[after-i:after-i+2])\\n        return (nextfew[0] + nextfew[1 - (m+n)%2]) / 2.0\\n\\n---\\n\\n**Solution 2**\\n\\nSame, just with a self-made binary search:\\n\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        a, b = sorted((nums1, nums2), key=len)\\n        m, n = len(a), len(b)\\n        after = (m + n - 1) / 2\\n        lo, hi = 0, m\\n        while lo < hi:\\n            i = (lo + hi) / 2\\n            if after-i-1 < 0 or a[i] >= b[after-i-1]:\\n                hi = i\\n            else:\\n                lo = i + 1\\n        i = lo\\n        nextfew = sorted(a[i:i+2] + b[after-i:after-i+2])\\n        return (nextfew[0] + nextfew[1 - (m+n)%2]) / 2.0",
                "solutionTags": [
                    "Python"
                ],
                "code": "Same method as [my 6-lines Ruby solution](https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2579/6-lines-O(log(min(mn)))-Ruby), just the binary search and the *\"get up to two\"* isn\\'t quite as convenient in Python. See there if you\\'d like an explanation.\\n\\n---\\n\\n**Update April 2022**: By now, `bisect` supports a `key` function (since Python 3.10). Using that in Solution 1:\\n\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        a, b = sorted((nums1, nums2), key=len)\\n        m, n = len(a), len(b)\\n        after = (m + n - 1) // 2\\n        i = bisect_left(range(m), True, key=lambda i: after-i-1 < 0 or a[i] >= b[after-i-1])\\n        nextfew = sorted(a[i:i+2] + b[after-i:after-i+2])\\n        return (nextfew[0] + nextfew[1 - (m+n)%2]) / 2.0\\n\\t\\n**Note about my use of `sorted`:** Both take just O(1) time. In the first case I\\'m just sorting a *tuple* of *two* lists by length, not sorting each list. It just assigns the shorter list to `a` and the longer to `b`. In the second case, I\\'m just sorting a list of up to *four* values.\\n\\n---\\n\\n**Solution 1**\\n\\nThis one is a bit of a hack, as `bisect_left` is intended for lists, but apparently it\\'s happy enough with something that behaves enough like a list (supports `__getitem__`):\\n\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        a, b = sorted((nums1, nums2), key=len)\\n        m, n = len(a), len(b)\\n        after = (m + n - 1) / 2\\n        class Range:\\n            def __getitem__(self, i):\\n                return after-i-1 < 0 or a[i] >= b[after-i-1]\\n        i = bisect.bisect_left(Range(), True, 0, m)\\n        nextfew = sorted(a[i:i+2] + b[after-i:after-i+2])\\n        return (nextfew[0] + nextfew[1 - (m+n)%2]) / 2.0\\n\\n---\\n\\n**Solution 2**\\n\\nSame, just with a self-made binary search:\\n\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        a, b = sorted((nums1, nums2), key=len)\\n        m, n = len(a), len(b)\\n        after = (m + n - 1) / 2\\n        lo, hi = 0, m\\n        while lo < hi:\\n            i = (lo + hi) / 2\\n            if after-i-1 < 0 or a[i] >= b[after-i-1]:\\n                hi = i\\n            else:\\n                lo = i + 1\\n        i = lo\\n        nextfew = sorted(a[i:i+2] + b[after-i:after-i+2])\\n        return (nextfew[0] + nextfew[1 - (m+n)%2]) / 2.0",
                "codeTag": "Java"
            },
            {
                "id": 2567,
                "title": "python-o-log-min-m-n-solution",
                "content": "It's guaranteed to be O(log(min(m,n)) because every time the findKth function cuts the shorter array by half of its size.\\n\\n    class Solution:\\n        # @return a float\\n        def findMedianSortedArrays(self, A, B):\\n            l=len(A)+len(B)\\n            return self.findKth(A,B,l//2) if l%2==1 else (self.findKth(A,B,l//2-1)+self.findKth(A,B,l//2))/2.0\\n                \\n                \\n        def findKth(self,A,B,k):\\n            if len(A)>len(B):\\n                A,B=B,A\\n            if not A:\\n                return B[k]\\n            if k==len(A)+len(B)-1:\\n                return max(A[-1],B[-1])\\n            i=len(A)//2\\n            j=k-i\\n            if A[i]>B[j]:\\n                #Here I assume it is O(1) to get A[:i] and B[j:]. In python, it's not but in cpp it is.\\n                return self.findKth(A[:i],B[j:],i)\\n            else:\\n                return self.findKth(A[i:],B[:j],j)",
                "solutionTags": [],
                "code": "It's guaranteed to be O(log(min(m,n)) because every time the findKth function cuts the shorter array by half of its size.\\n\\n    class Solution:\\n        # @return a float\\n        def findMedianSortedArrays(self, A, B):\\n            l=len(A)+len(B)\\n            return self.findKth(A,B,l//2) if l%2==1 else (self.findKth(A,B,l//2-1)+self.findKth(A,B,l//2))/2.0\\n                \\n                \\n        def findKth(self,A,B,k):\\n            if len(A)>len(B):\\n                A,B=B,A\\n            if not A:\\n                return B[k]\\n            if k==len(A)+len(B)-1:\\n                return max(A[-1],B[-1])\\n            i=len(A)//2\\n            j=k-i\\n            if A[i]>B[j]:\\n                #Here I assume it is O(1) to get A[:i] and B[j:]. In python, it's not but in cpp it is.\\n                return self.findKth(A[:i],B[j:],i)\\n            else:\\n                return self.findKth(A[i:],B[:j],j)",
                "codeTag": "Java"
            },
            {
                "id": 615128,
                "title": "cpp-o-log-min-m-n-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    double mediann(vector<int>&a,vector<int>&b){\\n        int m=a.size();\\n        int n=b.size();\\n        if(m>n)\\n            return mediann(b,a);\\n        int l=0,r=m;\\n        while(l<=r){\\n            int partx=l+(r-l)/2;\\n            int party=(m+n+1)/2-partx;\\n            int maxlx=(partx==0)?INT_MIN:a[partx-1];\\n            int minrx=(partx==m)?INT_MAX:a[partx];\\n            int maxly=(party==0)?INT_MIN:b[party-1];\\n            int minry=(party==n)?INT_MAX:b[party];\\n            if(maxlx<=minry&&maxly<=minrx){\\n                if((m+n)%2==0)\\n                    return (double)(max(maxlx,maxly)+min(minrx,minry))/2;\\n                else\\n                    return (double)(max(maxlx,maxly));\\n            }else if(maxlx>minry)\\n                r=partx-1;\\n            else\\n                l=partx+1;\\n        }\\n        return -1.0;\\n    }\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        double ans;\\n        ans=mediann(nums1,nums2);\\n        return ans;   \\n    }\\n};\\n```\\n\\nWatch this video for explanation\\nhttps://www.youtube.com/watch?v=LPFhl65R7ww&t=1013s",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double mediann(vector<int>&a,vector<int>&b){\\n        int m=a.size();\\n        int n=b.size();\\n        if(m>n)\\n            return mediann(b,a);\\n        int l=0,r=m;\\n        while(l<=r){\\n            int partx=l+(r-l)/2;\\n            int party=(m+n+1)/2-partx;\\n            int maxlx=(partx==0)?INT_MIN:a[partx-1];\\n            int minrx=(partx==m)?INT_MAX:a[partx];\\n            int maxly=(party==0)?INT_MIN:b[party-1];\\n            int minry=(party==n)?INT_MAX:b[party];\\n            if(maxlx<=minry&&maxly<=minrx){\\n                if((m+n)%2==0)\\n                    return (double)(max(maxlx,maxly)+min(minrx,minry))/2;\\n                else\\n                    return (double)(max(maxlx,maxly));\\n            }else if(maxlx>minry)\\n                r=partx-1;\\n            else\\n                l=partx+1;\\n        }\\n        return -1.0;\\n    }\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        double ans;\\n        ans=mediann(nums1,nums2);\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322378,
                "title": "median-of-two-sorted-array-using-kth-minimum-element-c-o-log-n-explained-from-scratch",
                "content": "This question is special case of [Kth minimum element in two sorted arrays ](https://practice.geeksforgeeks.org/problems/k-th-element-of-two-sorted-array1317/1#) \\nwhere \\n* K = ( n/2 + 1)<sup>th</sup> element if n is odd\\n* K = ( n/2 - 1)<sup>th</sup> and ( n/2 )<sup>th</sup> element if n is even\\n\\nHere n is total length of merged array.\\nSo if  n is odd ans will be K<sup>th</sup> term, but when it is even then answer will be average of both K<sup>th</sup> term.\\n\\nThe logic explained below is the same logic which is explained in [this video.](https://youtu.be/nv7F4PiLUzo)\\n\\n**Intuition :**\\nWe have to select first K elements from the final merged array. So we can suppose some ```x``` elements are coming from where ```arr1``` and some ```y``` elements are coming from ```arr2``` where ```x``` or ```y``` may be zero but `x+y==k.`\\n\\n**Question 1 : How to find `x` and `y` ?**\\nFor some fixed value of `x` , `y = k - x` becuase `x+y==k.` \\nAnd to find `x` naive approach is we can iterate the `arr1` from start to end and it will take O(n) time.\\nBut as array is sorted if we choose some pivot point as `x` and if it will not be satisfying the criteria of partition ( we will see the criteria later) then we can move the pivot to the right or left by checking the condition. Here moving the pivot to the right or left gives the idea of using **Binary Search** to find the value of x. \\n\\n**Question 2 : How to use Binary Search?**\\nIf we select first x elements from array1 and first y elements from array2 then it will divide the array in two part.\\n\\n```\\narr1    :    ---------A     C---------\\narr2    :    ---------B     D---------\\n```\\nHere A is the x<sup>th</sup> element of arr1 and C is x+1<sup>th</sup> element of first array\\nSimilary B is the y<sup>th</sup> element of arr1 and D is y+1<sup>th</sup> element of second array.\\n\\nSuppose it is valid partioning of both the array, here valid partioning means\\n```\\nmerged(arr1, arr2) = merged( ------A, ------B ) + merged( C----------, D-------- )\\n\\t\\t\\t\\t\\t\\t\\t(first k elements)               (last n-k elements)\\n\\t\\t\\t\\t\\t\\t\\t  first part                        second part\\n```\\nAnd *if it is proper division of both array to merged then ```K```<sup>th</sup> smallest element will be last element of first part, which can be either A or B. So our problem reduced to find maximum between A and B.*\\n\\n**Question 3 : What will be criteria to check valid partioning?**\\nTo be valid partioning each element of first part must be less than or equal to second element.\\nBut as arrays are already sorted, we only need to check that `maxElement(part1) <= maxElement(part2)`.\\n```\\nA <= C  (trivial because  [ -----A   C------] was sorted array)\\nA <= D  \\n\\nB <= C\\nB <= D (trivial because  [ -----B   D------] was sorted array)\\n```\\nSo we only need to check ``` (A<=D) && (B<=C) ``` to be a valid partioning.\\n\\n\\n**Question 4 : How to move left or right if the condition is false?**\\n* Let\\'s suppose ( A > D ) which is false condition, then we have to move in direction where it becomes true ( A <= D ), so we can move pointer `x` to left becuase it will decrease A and condition ( A <= D ) may become true.\\n`high = mid - 1`.\\n\\n* Let\\'s suppose ( B > C ) which is false condition, then we have to move in direction where it becomes true ( B <= C ), so we can move pointer `y` to left ( indirectly pointer x to right, because x+y is always equal to k, if x moves toward right then y will move left and vice versa) so it will decrease B and condition ( B <= C ) may become true.\\n`low = mid + 1`.\\n\\n\\n**Initialising range for binary search**\\nHere n1 and n2 are length of array1 and array2\\n```\\n\\t\\t\\t\\tx\\n                \\u2193\\narr1 :  0 ----------------- n1\\narr2 :  0 ----------------------- n2\\n\\t\\t\\t\\t\\t\\t\\u2191\\n\\t\\t\\t\\t\\t\\ty\\nx >= 0                                             -- eq 1\\nx <=n1                                             -- eq 2\\n(y = k - x )  >= 0  => ( x <= k )                  -- eq 3\\n(y = k - x ) <= n2  => ( x >= k-n2 )               -- eq 4\\n\\n\\nFrom eq 1 & eq 4 \\n\\tx >= max(0, k-m)  // low = max(0, k-n1)\\nFrom eq 2 & eq 3\\n\\tx <= min( n2, k ) // high = min( n2, k )\\n```\\n\\n**Corner Condition :**\\n* if x == 0, then arr1[ x - 1 ] will not exist and as this can be valid partioning and we are always comparing A <= D, so to get condition always true (because valid partionining) we have set A as minimum possible value, A = INT_MIN\\n* Same case y == 0,  then arr2[ y - 1 ] will not exist and as this can be valid partioning and we are always comparing B <= C, so to get condition always true (because valid partionining) we have set B as minimum possible value, B = INT_MIN\\n* Similary if x == n1, then arr1[ x ] will not exist and as this can be valid partioning and we are always comparing B <= C, so to get condition always true (because valid partionining) we have set C as maximum possible value, C = INT_MAX.\\n*  Similary if y == n2, then arr2[ y ] will not exist and as this can be valid partioning and we are always comparing A <= D, so to get condition always true (because valid partionining) we have set D as maximum possible value, D = INT_MAX.\\n\\n\\n**Code :**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int kthElement(vector<int> &arr1, vector<int> &arr2, int n, int m, int k)\\n    {\\n        // most important thing, initialization of low, high\\n        int low = max(0, k-m), high = min( n, k );\\n        int indx, indx2;\\n        while(low <= high)\\n        {\\n            \\n            int mid = low + (high - low) / 2;\\n            int x = mid;\\n            int y = k - x;  // x + y == k\\n\\n            int A = ( x==0 ) ? INT_MIN : arr1[x-1];\\n            int B = ( y==0 ) ? INT_MIN : arr2[y-1];\\n  \\n            int C = ( x+1 <= n) ? arr1[x] : INT_MAX ;\\n            int D = ( y+1 <= m) ? arr2[y] : INT_MAX ;\\n\\n\\t\\t\\t// Array visualization\\n            // ---------A     C---------\\n            // ---------B     D---------\\n            \\n            if( (A<=D) && (B<=C) )\\n            {\\n                indx = mid;\\n                indx2 = k - mid;\\n                break;\\n            }\\n            else if( A > D )\\n                high = mid - 1;\\n            else \\n                low = mid + 1;\\n        }\\n\\n        int ans;\\n        if(indx <= n)\\n        {\\n            int a = (indx > 0) ? arr1[indx - 1] : INT_MIN;\\n            int b = (indx2 > 0) ? arr2[ indx2 - 1] : INT_MIN;\\n            return max(a, b);\\n        }\\n        return arr2[ indx2 - 1];\\n    }\\n    \\n    double findMedianSortedArrays(vector<int>& arr1, vector<int>& arr2) {\\n        int n = arr1.size();\\n        int m = arr2.size();\\n        \\n        if( (n+m)%2 ) return kthElement(arr1, arr2, n, m, (n+m+1)/2);\\n        \\n        int a = kthElement(arr1, arr2, n, m, (n+m)/2);\\n        int b = kthElement(arr1, arr2, n, m, (n+m)/2 + 1);\\n\\n        return (a + b) / 2.0 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```x```\n```arr1```\n```y```\n```arr2```\n```x```\n```y```\n```\\narr1    :    ---------A     C---------\\narr2    :    ---------B     D---------\\n```\n```\\nmerged(arr1, arr2) = merged( ------A, ------B ) + merged( C----------, D-------- )\\n\\t\\t\\t\\t\\t\\t\\t(first k elements)               (last n-k elements)\\n\\t\\t\\t\\t\\t\\t\\t  first part                        second part\\n```\n```K```\n```\\nA <= C  (trivial because  [ -----A   C------] was sorted array)\\nA <= D  \\n\\nB <= C\\nB <= D (trivial because  [ -----B   D------] was sorted array)\\n```\n``` (A<=D) && (B<=C) ```\n```\\n\\t\\t\\t\\tx\\n                \\u2193\\narr1 :  0 ----------------- n1\\narr2 :  0 ----------------------- n2\\n\\t\\t\\t\\t\\t\\t\\u2191\\n\\t\\t\\t\\t\\t\\ty\\nx >= 0                                             -- eq 1\\nx <=n1                                             -- eq 2\\n(y = k - x )  >= 0  => ( x <= k )                  -- eq 3\\n(y = k - x ) <= n2  => ( x >= k-n2 )               -- eq 4\\n\\n\\nFrom eq 1 & eq 4 \\n\\tx >= max(0, k-m)  // low = max(0, k-n1)\\nFrom eq 2 & eq 3\\n\\tx <= min( n2, k ) // high = min( n2, k )\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int kthElement(vector<int> &arr1, vector<int> &arr2, int n, int m, int k)\\n    {\\n        // most important thing, initialization of low, high\\n        int low = max(0, k-m), high = min( n, k );\\n        int indx, indx2;\\n        while(low <= high)\\n        {\\n            \\n            int mid = low + (high - low) / 2;\\n            int x = mid;\\n            int y = k - x;  // x + y == k\\n\\n            int A = ( x==0 ) ? INT_MIN : arr1[x-1];\\n            int B = ( y==0 ) ? INT_MIN : arr2[y-1];\\n  \\n            int C = ( x+1 <= n) ? arr1[x] : INT_MAX ;\\n            int D = ( y+1 <= m) ? arr2[y] : INT_MAX ;\\n\\n\\t\\t\\t// Array visualization\\n            // ---------A     C---------\\n            // ---------B     D---------\\n            \\n            if( (A<=D) && (B<=C) )\\n            {\\n                indx = mid;\\n                indx2 = k - mid;\\n                break;\\n            }\\n            else if( A > D )\\n                high = mid - 1;\\n            else \\n                low = mid + 1;\\n        }\\n\\n        int ans;\\n        if(indx <= n)\\n        {\\n            int a = (indx > 0) ? arr1[indx - 1] : INT_MIN;\\n            int b = (indx2 > 0) ? arr2[ indx2 - 1] : INT_MIN;\\n            return max(a, b);\\n        }\\n        return arr2[ indx2 - 1];\\n    }\\n    \\n    double findMedianSortedArrays(vector<int>& arr1, vector<int>& arr2) {\\n        int n = arr1.size();\\n        int m = arr2.size();\\n        \\n        if( (n+m)%2 ) return kthElement(arr1, arr2, n, m, (n+m+1)/2);\\n        \\n        int a = kthElement(arr1, arr2, n, m, (n+m)/2);\\n        int b = kthElement(arr1, arr2, n, m, (n+m)/2 + 1);\\n\\n        return (a + b) / 2.0 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 277759,
                "title": "python-o-log-min-m-n-solution-simple-code",
                "content": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        if len(nums1) > len(nums2):\\n            nums1, nums2 = nums2, nums1\\n        \\n        m, n = len(nums1), len(nums2)\\n        \\n        left_size = (m + n + 1) // 2\\n        start = 0\\n        end = m\\n        is_even = ((m + n) % 2) == 0\\n        while start <= end:\\n            a_part = (start + end) // 2\\n            b_part = left_size - a_part\\n            \\n            aleftmax = float(\"-inf\") if a_part == 0 else nums1[a_part - 1]\\n            arightmin = float(\"inf\") if a_part == m else nums1[a_part]\\n            bleftmax = float(\"-inf\") if b_part == 0 else nums2[b_part - 1]\\n            brightmin = float(\"inf\") if b_part == n else nums2[b_part]\\n            \\n            if aleftmax <= brightmin and bleftmax <= arightmin:\\n                if not is_even:\\n                    return max(aleftmax, bleftmax)\\n                else:\\n                    return (max(aleftmax, bleftmax) + min(arightmin, brightmin))/ 2\\n            elif aleftmax > brightmin:\\n                end = a_part - 1\\n            elif bleftmax > arightmin:\\n                start = a_part + 1\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        if len(nums1) > len(nums2):\\n            nums1, nums2 = nums2, nums1\\n        \\n        m, n = len(nums1), len(nums2)\\n        \\n        left_size = (m + n + 1) // 2\\n        start = 0\\n        end = m\\n        is_even = ((m + n) % 2) == 0\\n        while start <= end:\\n            a_part = (start + end) // 2\\n            b_part = left_size - a_part\\n            \\n            aleftmax = float(\"-inf\") if a_part == 0 else nums1[a_part - 1]\\n            arightmin = float(\"inf\") if a_part == m else nums1[a_part]\\n            bleftmax = float(\"-inf\") if b_part == 0 else nums2[b_part - 1]\\n            brightmin = float(\"inf\") if b_part == n else nums2[b_part]\\n            \\n            if aleftmax <= brightmin and bleftmax <= arightmin:\\n                if not is_even:\\n                    return max(aleftmax, bleftmax)\\n                else:\\n                    return (max(aleftmax, bleftmax) + min(arightmin, brightmin))/ 2\\n            elif aleftmax > brightmin:\\n                end = a_part - 1\\n            elif bleftmax > arightmin:\\n                start = a_part + 1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579,
                "title": "6-lines-o-log-min-m-n-ruby",
                "content": "**For non-Rubyists:** My first line just calls the shorter array `a` and the longer array `b`. It doesn\\'t merge and sort the arrays like some people\\'s thus invalid solutions. Also, you might have trouble reading  the code, but I think the explanation is understandable for non-Rubyists as well.\\n\\nUpdate: I wrote a [Python version](https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2755/9-lines-O(log(min(mn)))-Python) as well.\\n\\n---\\n\\nSolution\\n---\\n\\n    def find_median_sorted_arrays(nums1, nums2)\\n      a, b = [nums1, nums2].sort_by(&:size)\\n      m, n = a.size, b.size\\n      after = (m + n - 1) / 2\\n      i = (0...m).bsearch { |i| after-i-1 < 0 || a[i] >= b[after-i-1] } || m\\n      nextfew = (a[i,2] + b[after-i,2]).sort\\n      (nextfew[0] + nextfew[1 - (m+n)%2]) / 2.0\\n    end\\n\\n---\\n\\nExplanation\\n---\\n\\nLet\\'s do an example: `a = [2,3,6,8]` and `b = [1,4,5,7,9]`.\\n\\nMerged, they\\'d be `[1,2,3,4,5,6,7,8,9]`. I can\\'t afford to actually merge, because of the O(log(m+n)) requirement, but imagine we\\'d merge. The usual way. Then after the first four numbers, the next one is the median.\\n\\nWhat could the status of the merging be after having merged the first four numbers? We\\'d have used `i` numbers from `a` and `4-i` numbers from `b`. The five candidate statuses are:\\n\\n         Remaining    Remaining     Last used    Last used\\n    i    a[i, ...]   b[4-i, ...]    from b       from a\\n    \\n    0    [2,3,6,8]           [9]    7            None\\n    1      [3,6,8]         [7,9]    5            2\\n    2        [6,8]       [5,7,9]    4            3\\n    3          [8]     [4,5,7,9]    1            6\\n    4           []   [1,4,5,7,9]    None         8\\n\\nTo be possible, a status must obey two rules:\\n\\n1. The last number used from `b` can\\'t be larger than the next remaining number in `a` (because it would\\'ve been a mistake to use it first).\\n2. The last number used from `a` can\\'t be larger than the next remaining number in `b`.\\n\\nYou can see that only the first two statuses (`i=0` and `i=1`) violate rule 1. And of course with growing `i`, the last-used `b`-number shrinks and the next remaining `a`-number grows. So it\\'s monotone - from small to large `i`, first you have the rule-1-violaters and then you have the rule-1-obeyers. And for rule 2 it\\'s the other way around.\\n\\nOf course after merging the first four numbers, we must be in **some** status. So there must be some status that obeys both rules. And we can simply take the first one that obeys rule 1. And we can use binary search to find it. In the code, for a given `i`, the next remaining number in `a` is `a[i]` and the last-used number from `b` is `b[after-i-1]`, and my `bsearch` simply tests rule 1.\\n\\nSo in our example we get that after merging four numbers, we\\'d have [6,8] and [5,7,9] left to merge. What I do is I take the next (up to) two numbers from each, and sort that. So the next few numbers in the imagined merge would be [5,6,7,8]. Now if I overall have an odd number of numbers, I could just take the first number, the 5. And if I overall have an even number of numbers (like if `a` had an additional 10), I take the mean of the first two numbers, (5+6)/2.0. For slightly simpler code, I unify the two cases: Instead of taking the 5, I compute (5+5)/2.0.",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "**For non-Rubyists:** My first line just calls the shorter array `a` and the longer array `b`. It doesn\\'t merge and sort the arrays like some people\\'s thus invalid solutions. Also, you might have trouble reading  the code, but I think the explanation is understandable for non-Rubyists as well.\\n\\nUpdate: I wrote a [Python version](https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2755/9-lines-O(log(min(mn)))-Python) as well.\\n\\n---\\n\\nSolution\\n---\\n\\n    def find_median_sorted_arrays(nums1, nums2)\\n      a, b = [nums1, nums2].sort_by(&:size)\\n      m, n = a.size, b.size\\n      after = (m + n - 1) / 2\\n      i = (0...m).bsearch { |i| after-i-1 < 0 || a[i] >= b[after-i-1] } || m\\n      nextfew = (a[i,2] + b[after-i,2]).sort\\n      (nextfew[0] + nextfew[1 - (m+n)%2]) / 2.0\\n    end\\n\\n---\\n\\nExplanation\\n---\\n\\nLet\\'s do an example: `a = [2,3,6,8]` and `b = [1,4,5,7,9]`.\\n\\nMerged, they\\'d be `[1,2,3,4,5,6,7,8,9]`. I can\\'t afford to actually merge, because of the O(log(m+n)) requirement, but imagine we\\'d merge. The usual way. Then after the first four numbers, the next one is the median.\\n\\nWhat could the status of the merging be after having merged the first four numbers? We\\'d have used `i` numbers from `a` and `4-i` numbers from `b`. The five candidate statuses are:\\n\\n         Remaining    Remaining     Last used    Last used\\n    i    a[i, ...]   b[4-i, ...]    from b       from a\\n    \\n    0    [2,3,6,8]           [9]    7            None\\n    1      [3,6,8]         [7,9]    5            2\\n    2        [6,8]       [5,7,9]    4            3\\n    3          [8]     [4,5,7,9]    1            6\\n    4           []   [1,4,5,7,9]    None         8\\n\\nTo be possible, a status must obey two rules:\\n\\n1. The last number used from `b` can\\'t be larger than the next remaining number in `a` (because it would\\'ve been a mistake to use it first).\\n2. The last number used from `a` can\\'t be larger than the next remaining number in `b`.\\n\\nYou can see that only the first two statuses (`i=0` and `i=1`) violate rule 1. And of course with growing `i`, the last-used `b`-number shrinks and the next remaining `a`-number grows. So it\\'s monotone - from small to large `i`, first you have the rule-1-violaters and then you have the rule-1-obeyers. And for rule 2 it\\'s the other way around.\\n\\nOf course after merging the first four numbers, we must be in **some** status. So there must be some status that obeys both rules. And we can simply take the first one that obeys rule 1. And we can use binary search to find it. In the code, for a given `i`, the next remaining number in `a` is `a[i]` and the last-used number from `b` is `b[after-i-1]`, and my `bsearch` simply tests rule 1.\\n\\nSo in our example we get that after merging four numbers, we\\'d have [6,8] and [5,7,9] left to merge. What I do is I take the next (up to) two numbers from each, and sort that. So the next few numbers in the imagined merge would be [5,6,7,8]. Now if I overall have an odd number of numbers, I could just take the first number, the 5. And if I overall have an even number of numbers (like if `a` had an additional 10), I take the mean of the first two numbers, (5+6)/2.0. For slightly simpler code, I unify the two cases: Instead of taking the 5, I compute (5+5)/2.0.",
                "codeTag": "Python3"
            },
            {
                "id": 4070371,
                "title": "94-96-binary-search-two-pointers",
                "content": "# Comprehensive Guide to Solving \"Median of Two Sorted Arrays\"\\n\\n## Introduction & Problem Statement\\n\\n\"Median of Two Sorted Arrays\" is a classic problem that tests one\\'s algorithmic depth and understanding of binary search and two-pointer techniques. The challenge is to find the median of two sorted arrays, `nums1` and `nums2`, with potentially different sizes. The objective is to solve it in logarithmic time complexity in terms of the minimum size of the two arrays.\\n\\n## Key Concepts and Constraints\\n\\n### What Makes This Problem Unique?\\n\\n1. **Array Constraints**:  \\n    - The length of `nums1` (denoted as $$ m $$) can range from 0 to 1000.\\n    - The length of `nums2` (denoted as $$ n $$) can also vary between 0 and 1000.\\n    - The combined size (i.e., $$ m + n $$) of both arrays can go up to 2000.\\n  \\n2. **Element Constraints**:\\n    - Each element in both `nums1` and `nums2` can be any integer from -$$ 10^6 $$ to $$ 10^6 $$.\\n\\n3. **Runtime Complexity**:  \\n    The primary challenge is to achieve a runtime of $$ O(\\\\log(\\\\min(m, n))) $$. This constraint rules out naive solutions that might merge and then find the median.\\n\\n### Solution Strategies:\\n\\n1. **Two Pointers Approach**:  \\n    This technique involves iterating through both arrays using two pointers. By comparing the elements at the current pointers, we can merge the two arrays. Once merged, finding the median is straightforward.\\n\\n2. **Binary Search Approach**:  \\n    Leveraging the properties of sorted arrays, we can apply a binary search on the smaller array, effectively partitioning both arrays. This method ensures we find the median without explicitly merging the arrays, adhering to the desired logarithmic time complexity.\\n\\n---\\n\\n## Live Coding Binary Search & Explain \\nhttps://youtu.be/9LZcuEBjD9o?si=5A6xTTLfH0HW0kal\\n\\n## Strategy to Solve the Problem:\\n\\n## Two Pointers Merging Technique\\n\\nThe core idea here is to merge the two sorted arrays, nums1 and nums2, using a two-pointer approach. After merging, the median of the combined array can be found directly based on its length.\\n\\n## Key Data Structures:\\n\\n- `merged`: An array to store the merged result of `nums1` and `nums2`.\\n- `i` and `j`: Two pointers to traverse `nums1` and `nums2` respectively.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialize Pointers**:\\n   - Set `i` and `j` to 0. These pointers will help traverse `nums1` and `nums2`.\\n\\n2. **Merging using Two Pointers**:\\n   - Merge elements of `nums1` and `nums2` in sorted order using two pointers. If an element in `nums1` is smaller, append it to `merged` and move the `i` pointer. Otherwise, append the element from `nums2` and move the `j` pointer.\\n\\n3. **Handle Remaining Elements**:\\n   - If there are any remaining elements in `nums1` or `nums2`, append them directly to `merged`.\\n\\n4. **Calculate Median**:\\n   - Based on the length of `merged`, compute the median. If the length is even, the median is the average of the two middle elements. Otherwise, it\\'s the middle element.\\n\\n## Complexity Analysis:\\n\\n**Time Complexity**: \\n- The merging process traverses both arrays once, resulting in a time complexity of $$ O(m + n) $$, where $$ m $$ and $$ n $$ are the lengths of `nums1` and `nums2` respectively.\\n\\n**Space Complexity**: \\n- The algorithm creates a merged array of length $$ m + n $$, leading to a space complexity of $$ O(m + n) $$.\\n\\n\\n## Code Two Pointers\\n``` Python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        merged = []\\n        i, j = 0, 0\\n        \\n        while i < len(nums1) and j < len(nums2):\\n            if nums1[i] < nums2[j]:\\n                merged.append(nums1[i])\\n                i += 1\\n            else:\\n                merged.append(nums2[j])\\n                j += 1\\n                \\n        while i < len(nums1):\\n            merged.append(nums1[i])\\n            i += 1\\n            \\n        while j < len(nums2):\\n            merged.append(nums2[j])\\n            j += 1\\n        \\n        mid = len(merged) // 2\\n        if len(merged) % 2 == 0:\\n            return (merged[mid-1] + merged[mid]) / 2\\n        else:\\n            return merged[mid]\\n\\n```\\n``` Go []\\nfunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\\n    merged := make([]int, 0, len(nums1)+len(nums2))\\n    i, j := 0, 0\\n\\n    for i < len(nums1) && j < len(nums2) {\\n        if nums1[i] < nums2[j] {\\n            merged = append(merged, nums1[i])\\n            i++\\n        } else {\\n            merged = append(merged, nums2[j])\\n            j++\\n        }\\n    }\\n\\n    for i < len(nums1) {\\n        merged = append(merged, nums1[i])\\n        i++\\n    }\\n    for j < len(nums2) {\\n        merged = append(merged, nums2[j])\\n        j++\\n    }\\n\\n    mid := len(merged) / 2\\n    if len(merged)%2 == 0 {\\n        return (float64(merged[mid-1]) + float64(merged[mid])) / 2.0\\n    } else {\\n        return float64(merged[mid])\\n    }\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\\n        let mut merged: Vec<i32> = Vec::new();\\n        let (mut i, mut j) = (0, 0);\\n        \\n        while i < nums1.len() && j < nums2.len() {\\n            if nums1[i] < nums2[j] {\\n                merged.push(nums1[i]);\\n                i += 1;\\n            } else {\\n                merged.push(nums2[j]);\\n                j += 1;\\n            }\\n        }\\n        \\n        while i < nums1.len() {\\n            merged.push(nums1[i]);\\n            i += 1;\\n        }\\n        while j < nums2.len() {\\n            merged.push(nums2[j]);\\n            j += 1;\\n        }\\n        \\n        let mid = merged.len() / 2;\\n        if merged.len() % 2 == 0 {\\n            return (merged[mid-1] + merged[mid]) as f64 / 2.0;\\n        } else {\\n            return merged[mid] as f64;\\n        }\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> merged;\\n        int i = 0, j = 0;\\n        \\n        while (i < nums1.size() && j < nums2.size()) {\\n            if (nums1[i] < nums2[j]) {\\n                merged.push_back(nums1[i++]);\\n            } else {\\n                merged.push_back(nums2[j++]);\\n            }\\n        }\\n        \\n        while (i < nums1.size()) merged.push_back(nums1[i++]);\\n        while (j < nums2.size()) merged.push_back(nums2[j++]);\\n        \\n        int mid = merged.size() / 2;\\n        if (merged.size() % 2 == 0) {\\n            return (merged[mid-1] + merged[mid]) / 2.0;\\n        } else {\\n            return merged[mid];\\n        }\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        List<Integer> merged = new ArrayList<>();\\n        int i = 0, j = 0;\\n        \\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                merged.add(nums1[i++]);\\n            } else {\\n                merged.add(nums2[j++]);\\n            }\\n        }\\n        \\n        while (i < nums1.length) merged.add(nums1[i++]);\\n        while (j < nums2.length) merged.add(nums2[j++]);\\n        \\n        int mid = merged.size() / 2;\\n        if (merged.size() % 2 == 0) {\\n            return (merged.get(mid-1) + merged.get(mid)) / 2.0;\\n        } else {\\n            return merged.get(mid);\\n        }\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        List<int> merged = new List<int>();\\n        int i = 0, j = 0;\\n        \\n        while (i < nums1.Length && j < nums2.Length) {\\n            if (nums1[i] < nums2[j]) {\\n                merged.Add(nums1[i++]);\\n            } else {\\n                merged.Add(nums2[j++]);\\n            }\\n        }\\n        \\n        while (i < nums1.Length) merged.Add(nums1[i++]);\\n        while (j < nums2.Length) merged.Add(nums2[j++]);\\n        \\n        int mid = merged.Count / 2;\\n        if (merged.Count % 2 == 0) {\\n            return (merged[mid-1] + merged[mid]) / 2.0;\\n        } else {\\n            return merged[mid];\\n        }\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let merged = [];\\n    let i = 0, j = 0;\\n\\n    while (i < nums1.length && j < nums2.length) {\\n        if (nums1[i] < nums2[j]) {\\n            merged.push(nums1[i++]);\\n        } else {\\n            merged.push(nums2[j++]);\\n        }\\n    }\\n\\n    while (i < nums1.length) merged.push(nums1[i++]);\\n    while (j < nums2.length) merged.push(nums2[j++]);\\n\\n    let mid = Math.floor(merged.length / 2);\\n    if (merged.length % 2 === 0) {\\n        return (merged[mid-1] + merged[mid]) / 2;\\n    } else {\\n        return merged[mid];\\n    }\\n};\\n```\\n``` PHP []\\nclass Solution {\\n\\n    function findMedianSortedArrays($nums1, $nums2) {\\n        $merged = array();\\n        $i = $j = 0;\\n\\n        while ($i < count($nums1) && $j < count($nums2)) {\\n            if ($nums1[$i] < $nums2[$j]) {\\n                array_push($merged, $nums1[$i++]);\\n            } else {\\n                array_push($merged, $nums2[$j++]);\\n            }\\n        }\\n\\n        while ($i < count($nums1)) array_push($merged, $nums1[$i++]);\\n        while ($j < count($nums2)) array_push($merged, $nums2[$j++]);\\n\\n        $mid = intdiv(count($merged), 2);\\n        if (count($merged) % 2 == 0) {\\n            return ($merged[$mid-1] + $merged[$mid]) / 2;\\n        } else {\\n            return $merged[$mid];\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n## Binary Search with Partitioning\\n\\nThe problem can be elegantly solved using binary search by partitioning the two arrays such that elements on the left are smaller or equal to elements on the right.\\n\\n## Key Data Structures:\\n\\n- `partitionX` and `partitionY`: To store the partition indices for `nums1` and `nums2` respectively.\\n- `maxX`, `minX`, `maxY`, `minY`: To store the values around the partition in both arrays.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialize and Swap Arrays if Needed**:\\n   - Swap `nums1` and `nums2` if `nums1` is larger. This ensures we always binary search the smaller array, optimizing the time complexity.\\n\\n2. **Binary Search Setup**:\\n   - Initialize `low` to 0 and `high` to the size of the smaller array.\\n  \\n3. **Start Binary Search Loop**:\\n   - The loop continues until `low` is not greater than `high`.\\n   - Calculate `partitionX` and `partitionY` based on `low` and `high`.\\n\\n4. **Calculate Partition Values**:\\n   - Compute `maxX`, `minX`, `maxY`, `minY` based on the partitions.\\n  \\n5. **Check for Correct Partition**:\\n   - If `maxX <= minY` and `maxY <= minX`, we have found the correct partition.\\n   - Calculate and return the median based on the values around the partition.\\n\\n6. **Adjust Binary Search Bounds**:\\n   - If `maxX > minY`, adjust `high` to `partitionX - 1`.\\n   - Otherwise, adjust `low` to `partitionX + 1`.\\n\\n## Complexity Analysis:\\n\\n**Time Complexity**: \\n- The algorithm performs a binary search on the smaller array, leading to a time complexity of $$ O(\\\\log(\\\\min(m, n))) $$.\\n\\n**Space Complexity**: \\n- The algorithm uses only a constant amount of extra space, thus having a space complexity of $$ O(1) $$.\\n\\n# Code Binary Search\\n``` Python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        if len(nums1) > len(nums2):\\n            nums1, nums2 = nums2, nums1\\n        \\n        m, n = len(nums1), len(nums2)\\n        low, high = 0, m\\n        \\n        while low <= high:\\n            partitionX = (low + high) // 2\\n            partitionY = (m + n + 1) // 2 - partitionX\\n            \\n            maxX = float(\\'-inf\\') if partitionX == 0 else nums1[partitionX - 1]\\n            maxY = float(\\'-inf\\') if partitionY == 0 else nums2[partitionY - 1]\\n            minX = float(\\'inf\\') if partitionX == m else nums1[partitionX]\\n            minY = float(\\'inf\\') if partitionY == n else nums2[partitionY]\\n            \\n            if maxX <= minY and maxY <= minX:\\n                if (m + n) % 2 == 0:\\n                    return (max(maxX, maxY) + min(minX, minY)) / 2\\n                else:\\n                    return max(maxX, maxY)\\n            elif maxX > minY:\\n                high = partitionX - 1\\n            else:\\n                low = partitionX + 1\\n```\\n``` Go []\\nfunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\\n\\tif len(nums1) > len(nums2) {\\n\\t\\tnums1, nums2 = nums2, nums1\\n\\t}\\n\\n\\tm, n := len(nums1), len(nums2)\\n\\tlow, high := 0, m\\n\\n\\tfor low <= high {\\n\\t\\tpartitionX := (low + high) / 2\\n\\t\\tpartitionY := (m + n + 1) / 2 - partitionX\\n\\n\\t\\tmaxX := math.MinInt64\\n\\t\\tif partitionX > 0 {\\n\\t\\t\\tmaxX = nums1[partitionX-1]\\n\\t\\t}\\n\\n\\t\\tminX := math.MaxInt64\\n\\t\\tif partitionX < m {\\n\\t\\t\\tminX = nums1[partitionX]\\n\\t\\t}\\n\\n\\t\\tmaxY := math.MinInt64\\n\\t\\tif partitionY > 0 {\\n\\t\\t\\tmaxY = nums2[partitionY-1]\\n\\t\\t}\\n\\n\\t\\tminY := math.MaxInt64\\n\\t\\tif partitionY < n {\\n\\t\\t\\tminY = nums2[partitionY]\\n\\t\\t}\\n\\n\\t\\tif maxX <= minY && maxY <= minX {\\n\\t\\t\\tif (m+n)%2 == 0 {\\n\\t\\t\\t\\treturn (float64(max(maxX, maxY)) + float64(min(minX, minY))) / 2.0\\n\\t\\t\\t}\\n\\t\\t\\treturn float64(max(maxX, maxY))\\n\\t\\t} else if maxX > minY {\\n\\t\\t\\thigh = partitionX - 1\\n\\t\\t} else {\\n\\t\\t\\tlow = partitionX + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn 0.0\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\\n        let (mut nums1, mut nums2) = if nums1.len() > nums2.len() {\\n            (nums2, nums1)\\n        } else {\\n            (nums1, nums2)\\n        };\\n        \\n        let (m, n) = (nums1.len(), nums2.len());\\n        let (mut low, mut high) = (0, m);\\n        \\n        while low <= high {\\n            let partition_x = (low + high) / 2;\\n            let partition_y = (m + n + 1) / 2 - partition_x;\\n            \\n            let max_x = if partition_x == 0 { i32::MIN } else { nums1[partition_x - 1] };\\n            let min_x = if partition_x == m { i32::MAX } else { nums1[partition_x] };\\n            \\n            let max_y = if partition_y == 0 { i32::MIN } else { nums2[partition_y - 1] };\\n            let min_y = if partition_y == n { i32::MAX } else { nums2[partition_y] };\\n            \\n            if max_x <= min_y && max_y <= min_x {\\n                if (m + n) % 2 == 0 {\\n                    return (max_x.max(max_y) + min_x.min(min_y)) as f64 / 2.0;\\n                } else {\\n                    return max_x.max(max_y) as f64;\\n                }\\n            } else if max_x > min_y {\\n                high = partition_x - 1;\\n            } else {\\n                low = partition_x + 1;\\n            }\\n        }\\n        \\n        0.0\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if (nums1.size() > nums2.size()) {\\n            swap(nums1, nums2);\\n        }\\n        \\n        int m = nums1.size();\\n        int n = nums2.size();\\n        int low = 0, high = m;\\n        \\n        while (low <= high) {\\n            int partitionX = (low + high) / 2;\\n            int partitionY = (m + n + 1) / 2 - partitionX;\\n            \\n            int maxX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];\\n            int maxY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];\\n            \\n            int minX = (partitionX == m) ? INT_MAX : nums1[partitionX];\\n            int minY = (partitionY == n) ? INT_MAX : nums2[partitionY];\\n            \\n            if (maxX <= minY && maxY <= minX) {\\n                if ((m + n) % 2 == 0) {\\n                    return (max(maxX, maxY) + min(minX, minY)) / 2.0;\\n                } else {\\n                    return max(maxX, maxY);\\n                }\\n            } else if (maxX > minY) {\\n                high = partitionX - 1;\\n            } else {\\n                low = partitionX + 1;\\n            }\\n        }\\n        \\n        throw invalid_argument(\"Input arrays are not sorted.\");\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if (nums1.length > nums2.length) {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        \\n        int m = nums1.length;\\n        int n = nums2.length;\\n        int low = 0, high = m;\\n        \\n        while (low <= high) {\\n            int partitionX = (low + high) / 2;\\n            int partitionY = (m + n + 1) / 2 - partitionX;\\n            \\n            int maxX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\\n            int maxY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\\n            \\n            int minX = (partitionX == m) ? Integer.MAX_VALUE : nums1[partitionX];\\n            int minY = (partitionY == n) ? Integer.MAX_VALUE : nums2[partitionY];\\n            \\n            if (maxX <= minY && maxY <= minX) {\\n                if ((m + n) % 2 == 0) {\\n                    return (Math.max(maxX, maxY) + Math.min(minX, minY)) / 2.0;\\n                } else {\\n                    return Math.max(maxX, maxY);\\n                }\\n            } else if (maxX > minY) {\\n                high = partitionX - 1;\\n            } else {\\n                low = partitionX + 1;\\n            }\\n        }\\n        \\n        throw new IllegalArgumentException(\"Input arrays are not sorted.\");\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if (nums1.Length > nums2.Length) {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        \\n        int m = nums1.Length;\\n        int n = nums2.Length;\\n        int low = 0, high = m;\\n        \\n        while (low <= high) {\\n            int partitionX = (low + high) / 2;\\n            int partitionY = (m + n + 1) / 2 - partitionX;\\n            \\n            int maxX = (partitionX == 0) ? int.MinValue : nums1[partitionX - 1];\\n            int maxY = (partitionY == 0) ? int.MinValue : nums2[partitionY - 1];\\n            \\n            int minX = (partitionX == m) ? int.MaxValue : nums1[partitionX];\\n            int minY = (partitionY == n) ? int.MaxValue : nums2[partitionY];\\n            \\n            if (maxX <= minY && maxY <= minX) {\\n                if ((m + n) % 2 == 0) {\\n                    return (Math.Max(maxX, maxY) + Math.Min(minX, minY)) / 2.0;\\n                } else {\\n                    return Math.Max(maxX, maxY);\\n                }\\n            } else if (maxX > minY) {\\n                high = partitionX - 1;\\n            } else {\\n                low = partitionX + 1;\\n            }\\n        }\\n        \\n        throw new ArgumentException(\"Input arrays are not sorted.\");\\n    }\\n}\\n```\\n``` JavaScript []\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    if (nums1.length > nums2.length) {\\n        [nums1, nums2] = [nums2, nums1];\\n    }\\n    \\n    const m = nums1.length;\\n    const n = nums2.length;\\n    let low = 0, high = m;\\n    \\n    while (low <= high) {\\n        const partitionX = Math.floor((low + high) / 2);\\n        const partitionY = Math.floor((m + n + 1) / 2) - partitionX;\\n        \\n        const maxX = (partitionX === 0) ? Number.MIN_SAFE_INTEGER : nums1[partitionX - 1];\\n        const maxY = (partitionY === 0) ? Number.MIN_SAFE_INTEGER : nums2[partitionY - 1];\\n        \\n        const minX = (partitionX === m) ? Number.MAX_SAFE_INTEGER : nums1[partitionX];\\n        const minY = (partitionY === n) ? Number.MAX_SAFE_INTEGER : nums2[partitionY];\\n        \\n        if (maxX <= minY && maxY <= minX) {\\n            if ((m + n) % 2 === 0) {\\n                return (Math.max(maxX, maxY) + Math.min(minX, minY)) / 2;\\n            } else {\\n                return Math.max(maxX, maxY);\\n            }\\n        } else if (maxX > minY) {\\n            high = partitionX - 1;\\n        } else {\\n            low = partitionX + 1;\\n        }\\n    }\\n    \\n    throw new Error(\"Input arrays are not sorted.\");\\n};\\n```\\n``` PHP []\\nclass Solution {\\n    function findMedianSortedArrays($nums1, $nums2) {\\n        if (count($nums1) > count($nums2)) {\\n            list($nums1, $nums2) = [$nums2, $nums1];\\n        }\\n        \\n        $m = count($nums1);\\n        $n = count($nums2);\\n        $low = 0; $high = $m;\\n        \\n        while ($low <= $high) {\\n            $partitionX = intdiv($low + $high, 2);\\n            $partitionY = intdiv($m + $n + 1, 2) - $partitionX;\\n            \\n            $maxX = ($partitionX == 0) ? PHP_INT_MIN : $nums1[$partitionX - 1];\\n            $maxY = ($partitionY == 0) ? PHP_INT_MIN : $nums2[$partitionY - 1];\\n            \\n            $minX = ($partitionX == $m) ? PHP_INT_MAX : $nums1[$partitionX];\\n            $minY = ($partitionY == $n) ? PHP_INT_MAX : $nums2[$partitionY];\\n            \\n            if ($maxX <= $minY && $maxY <= $minX) {\\n                if (($m + $n) % 2 == 0) {\\n                    return (max($maxX, $maxY) + min($minX, $minY)) / 2.0;\\n                } else {\\n                    return max($maxX, $maxY);\\n                }\\n            } elseif ($maxX > $minY) {\\n                $high = $partitionX - 1;\\n            } else {\\n                $low = $partitionX + 1;\\n            }\\n        }\\n        \\n        throw new Exception(\"Input arrays are not sorted.\");\\n    }\\n}\\n```\\n\\n## Performance\\n\\n| Language  | Execution Time (ms) | Memory Usage (MB) |\\n|-----------|---------------------|--------------------|\\n| Rust      | 0                   | 2                  |\\n| Java      | 1                   | 44.5               |\\n| Go        | 9                   | 5.1                |\\n| C++       | 16                  | 89.6               |\\n| PHP       | 28                  | 18.9               |\\n| Python3   | 80                  | 16.5               |\\n| JavaScript| 85                  | 46.6               |\\n| Python3 (Two Pointers)  | 93                  | 16.5               |\\n| C#        | 98                  | 52.1               |\\n\\n![v45.png](https://assets.leetcode.com/users/images/966f2e2c-e145-4ea8-b135-e7091043284c_1695295269.6517363.png)\\n\\n\\n## Live Coding in Rust - 0 ms \\nhttps://youtu.be/i7qROr8VOuA?si=sjYuouuMThe8BUAM\\n\\n## Conclusion\\n\\nBoth strategies have their own unique benefits. While the two-pointers approach offers simplicity and clarity, the binary search approach showcases efficiency and mastery over the properties of sorted arrays. Choosing between them depends on the specific constraints and requirements of a given scenario.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        merged = []\\n        i, j = 0, 0\\n        \\n        while i < len(nums1) and j < len(nums2):\\n            if nums1[i] < nums2[j]:\\n                merged.append(nums1[i])\\n                i += 1\\n            else:\\n                merged.append(nums2[j])\\n                j += 1\\n                \\n        while i < len(nums1):\\n            merged.append(nums1[i])\\n            i += 1\\n            \\n        while j < len(nums2):\\n            merged.append(nums2[j])\\n            j += 1\\n        \\n        mid = len(merged) // 2\\n        if len(merged) % 2 == 0:\\n            return (merged[mid-1] + merged[mid]) / 2\\n        else:\\n            return merged[mid]\\n\\n```\n``` Go []\\nfunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\\n    merged := make([]int, 0, len(nums1)+len(nums2))\\n    i, j := 0, 0\\n\\n    for i < len(nums1) && j < len(nums2) {\\n        if nums1[i] < nums2[j] {\\n            merged = append(merged, nums1[i])\\n            i++\\n        } else {\\n            merged = append(merged, nums2[j])\\n            j++\\n        }\\n    }\\n\\n    for i < len(nums1) {\\n        merged = append(merged, nums1[i])\\n        i++\\n    }\\n    for j < len(nums2) {\\n        merged = append(merged, nums2[j])\\n        j++\\n    }\\n\\n    mid := len(merged) / 2\\n    if len(merged)%2 == 0 {\\n        return (float64(merged[mid-1]) + float64(merged[mid])) / 2.0\\n    } else {\\n        return float64(merged[mid])\\n    }\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\\n        let mut merged: Vec<i32> = Vec::new();\\n        let (mut i, mut j) = (0, 0);\\n        \\n        while i < nums1.len() && j < nums2.len() {\\n            if nums1[i] < nums2[j] {\\n                merged.push(nums1[i]);\\n                i += 1;\\n            } else {\\n                merged.push(nums2[j]);\\n                j += 1;\\n            }\\n        }\\n        \\n        while i < nums1.len() {\\n            merged.push(nums1[i]);\\n            i += 1;\\n        }\\n        while j < nums2.len() {\\n            merged.push(nums2[j]);\\n            j += 1;\\n        }\\n        \\n        let mid = merged.len() / 2;\\n        if merged.len() % 2 == 0 {\\n            return (merged[mid-1] + merged[mid]) as f64 / 2.0;\\n        } else {\\n            return merged[mid] as f64;\\n        }\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> merged;\\n        int i = 0, j = 0;\\n        \\n        while (i < nums1.size() && j < nums2.size()) {\\n            if (nums1[i] < nums2[j]) {\\n                merged.push_back(nums1[i++]);\\n            } else {\\n                merged.push_back(nums2[j++]);\\n            }\\n        }\\n        \\n        while (i < nums1.size()) merged.push_back(nums1[i++]);\\n        while (j < nums2.size()) merged.push_back(nums2[j++]);\\n        \\n        int mid = merged.size() / 2;\\n        if (merged.size() % 2 == 0) {\\n            return (merged[mid-1] + merged[mid]) / 2.0;\\n        } else {\\n            return merged[mid];\\n        }\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        List<Integer> merged = new ArrayList<>();\\n        int i = 0, j = 0;\\n        \\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                merged.add(nums1[i++]);\\n            } else {\\n                merged.add(nums2[j++]);\\n            }\\n        }\\n        \\n        while (i < nums1.length) merged.add(nums1[i++]);\\n        while (j < nums2.length) merged.add(nums2[j++]);\\n        \\n        int mid = merged.size() / 2;\\n        if (merged.size() % 2 == 0) {\\n            return (merged.get(mid-1) + merged.get(mid)) / 2.0;\\n        } else {\\n            return merged.get(mid);\\n        }\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        List<int> merged = new List<int>();\\n        int i = 0, j = 0;\\n        \\n        while (i < nums1.Length && j < nums2.Length) {\\n            if (nums1[i] < nums2[j]) {\\n                merged.Add(nums1[i++]);\\n            } else {\\n                merged.Add(nums2[j++]);\\n            }\\n        }\\n        \\n        while (i < nums1.Length) merged.Add(nums1[i++]);\\n        while (j < nums2.Length) merged.Add(nums2[j++]);\\n        \\n        int mid = merged.Count / 2;\\n        if (merged.Count % 2 == 0) {\\n            return (merged[mid-1] + merged[mid]) / 2.0;\\n        } else {\\n            return merged[mid];\\n        }\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let merged = [];\\n    let i = 0, j = 0;\\n\\n    while (i < nums1.length && j < nums2.length) {\\n        if (nums1[i] < nums2[j]) {\\n            merged.push(nums1[i++]);\\n        } else {\\n            merged.push(nums2[j++]);\\n        }\\n    }\\n\\n    while (i < nums1.length) merged.push(nums1[i++]);\\n    while (j < nums2.length) merged.push(nums2[j++]);\\n\\n    let mid = Math.floor(merged.length / 2);\\n    if (merged.length % 2 === 0) {\\n        return (merged[mid-1] + merged[mid]) / 2;\\n    } else {\\n        return merged[mid];\\n    }\\n};\\n```\n``` PHP []\\nclass Solution {\\n\\n    function findMedianSortedArrays($nums1, $nums2) {\\n        $merged = array();\\n        $i = $j = 0;\\n\\n        while ($i < count($nums1) && $j < count($nums2)) {\\n            if ($nums1[$i] < $nums2[$j]) {\\n                array_push($merged, $nums1[$i++]);\\n            } else {\\n                array_push($merged, $nums2[$j++]);\\n            }\\n        }\\n\\n        while ($i < count($nums1)) array_push($merged, $nums1[$i++]);\\n        while ($j < count($nums2)) array_push($merged, $nums2[$j++]);\\n\\n        $mid = intdiv(count($merged), 2);\\n        if (count($merged) % 2 == 0) {\\n            return ($merged[$mid-1] + $merged[$mid]) / 2;\\n        } else {\\n            return $merged[$mid];\\n        }\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        if len(nums1) > len(nums2):\\n            nums1, nums2 = nums2, nums1\\n        \\n        m, n = len(nums1), len(nums2)\\n        low, high = 0, m\\n        \\n        while low <= high:\\n            partitionX = (low + high) // 2\\n            partitionY = (m + n + 1) // 2 - partitionX\\n            \\n            maxX = float(\\'-inf\\') if partitionX == 0 else nums1[partitionX - 1]\\n            maxY = float(\\'-inf\\') if partitionY == 0 else nums2[partitionY - 1]\\n            minX = float(\\'inf\\') if partitionX == m else nums1[partitionX]\\n            minY = float(\\'inf\\') if partitionY == n else nums2[partitionY]\\n            \\n            if maxX <= minY and maxY <= minX:\\n                if (m + n) % 2 == 0:\\n                    return (max(maxX, maxY) + min(minX, minY)) / 2\\n                else:\\n                    return max(maxX, maxY)\\n            elif maxX > minY:\\n                high = partitionX - 1\\n            else:\\n                low = partitionX + 1\\n```\n``` Go []\\nfunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\\n\\tif len(nums1) > len(nums2) {\\n\\t\\tnums1, nums2 = nums2, nums1\\n\\t}\\n\\n\\tm, n := len(nums1), len(nums2)\\n\\tlow, high := 0, m\\n\\n\\tfor low <= high {\\n\\t\\tpartitionX := (low + high) / 2\\n\\t\\tpartitionY := (m + n + 1) / 2 - partitionX\\n\\n\\t\\tmaxX := math.MinInt64\\n\\t\\tif partitionX > 0 {\\n\\t\\t\\tmaxX = nums1[partitionX-1]\\n\\t\\t}\\n\\n\\t\\tminX := math.MaxInt64\\n\\t\\tif partitionX < m {\\n\\t\\t\\tminX = nums1[partitionX]\\n\\t\\t}\\n\\n\\t\\tmaxY := math.MinInt64\\n\\t\\tif partitionY > 0 {\\n\\t\\t\\tmaxY = nums2[partitionY-1]\\n\\t\\t}\\n\\n\\t\\tminY := math.MaxInt64\\n\\t\\tif partitionY < n {\\n\\t\\t\\tminY = nums2[partitionY]\\n\\t\\t}\\n\\n\\t\\tif maxX <= minY && maxY <= minX {\\n\\t\\t\\tif (m+n)%2 == 0 {\\n\\t\\t\\t\\treturn (float64(max(maxX, maxY)) + float64(min(minX, minY))) / 2.0\\n\\t\\t\\t}\\n\\t\\t\\treturn float64(max(maxX, maxY))\\n\\t\\t} else if maxX > minY {\\n\\t\\t\\thigh = partitionX - 1\\n\\t\\t} else {\\n\\t\\t\\tlow = partitionX + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn 0.0\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\\n        let (mut nums1, mut nums2) = if nums1.len() > nums2.len() {\\n            (nums2, nums1)\\n        } else {\\n            (nums1, nums2)\\n        };\\n        \\n        let (m, n) = (nums1.len(), nums2.len());\\n        let (mut low, mut high) = (0, m);\\n        \\n        while low <= high {\\n            let partition_x = (low + high) / 2;\\n            let partition_y = (m + n + 1) / 2 - partition_x;\\n            \\n            let max_x = if partition_x == 0 { i32::MIN } else { nums1[partition_x - 1] };\\n            let min_x = if partition_x == m { i32::MAX } else { nums1[partition_x] };\\n            \\n            let max_y = if partition_y == 0 { i32::MIN } else { nums2[partition_y - 1] };\\n            let min_y = if partition_y == n { i32::MAX } else { nums2[partition_y] };\\n            \\n            if max_x <= min_y && max_y <= min_x {\\n                if (m + n) % 2 == 0 {\\n                    return (max_x.max(max_y) + min_x.min(min_y)) as f64 / 2.0;\\n                } else {\\n                    return max_x.max(max_y) as f64;\\n                }\\n            } else if max_x > min_y {\\n                high = partition_x - 1;\\n            } else {\\n                low = partition_x + 1;\\n            }\\n        }\\n        \\n        0.0\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if (nums1.size() > nums2.size()) {\\n            swap(nums1, nums2);\\n        }\\n        \\n        int m = nums1.size();\\n        int n = nums2.size();\\n        int low = 0, high = m;\\n        \\n        while (low <= high) {\\n            int partitionX = (low + high) / 2;\\n            int partitionY = (m + n + 1) / 2 - partitionX;\\n            \\n            int maxX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];\\n            int maxY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];\\n            \\n            int minX = (partitionX == m) ? INT_MAX : nums1[partitionX];\\n            int minY = (partitionY == n) ? INT_MAX : nums2[partitionY];\\n            \\n            if (maxX <= minY && maxY <= minX) {\\n                if ((m + n) % 2 == 0) {\\n                    return (max(maxX, maxY) + min(minX, minY)) / 2.0;\\n                } else {\\n                    return max(maxX, maxY);\\n                }\\n            } else if (maxX > minY) {\\n                high = partitionX - 1;\\n            } else {\\n                low = partitionX + 1;\\n            }\\n        }\\n        \\n        throw invalid_argument(\"Input arrays are not sorted.\");\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if (nums1.length > nums2.length) {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        \\n        int m = nums1.length;\\n        int n = nums2.length;\\n        int low = 0, high = m;\\n        \\n        while (low <= high) {\\n            int partitionX = (low + high) / 2;\\n            int partitionY = (m + n + 1) / 2 - partitionX;\\n            \\n            int maxX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\\n            int maxY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\\n            \\n            int minX = (partitionX == m) ? Integer.MAX_VALUE : nums1[partitionX];\\n            int minY = (partitionY == n) ? Integer.MAX_VALUE : nums2[partitionY];\\n            \\n            if (maxX <= minY && maxY <= minX) {\\n                if ((m + n) % 2 == 0) {\\n                    return (Math.max(maxX, maxY) + Math.min(minX, minY)) / 2.0;\\n                } else {\\n                    return Math.max(maxX, maxY);\\n                }\\n            } else if (maxX > minY) {\\n                high = partitionX - 1;\\n            } else {\\n                low = partitionX + 1;\\n            }\\n        }\\n        \\n        throw new IllegalArgumentException(\"Input arrays are not sorted.\");\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if (nums1.Length > nums2.Length) {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        \\n        int m = nums1.Length;\\n        int n = nums2.Length;\\n        int low = 0, high = m;\\n        \\n        while (low <= high) {\\n            int partitionX = (low + high) / 2;\\n            int partitionY = (m + n + 1) / 2 - partitionX;\\n            \\n            int maxX = (partitionX == 0) ? int.MinValue : nums1[partitionX - 1];\\n            int maxY = (partitionY == 0) ? int.MinValue : nums2[partitionY - 1];\\n            \\n            int minX = (partitionX == m) ? int.MaxValue : nums1[partitionX];\\n            int minY = (partitionY == n) ? int.MaxValue : nums2[partitionY];\\n            \\n            if (maxX <= minY && maxY <= minX) {\\n                if ((m + n) % 2 == 0) {\\n                    return (Math.Max(maxX, maxY) + Math.Min(minX, minY)) / 2.0;\\n                } else {\\n                    return Math.Max(maxX, maxY);\\n                }\\n            } else if (maxX > minY) {\\n                high = partitionX - 1;\\n            } else {\\n                low = partitionX + 1;\\n            }\\n        }\\n        \\n        throw new ArgumentException(\"Input arrays are not sorted.\");\\n    }\\n}\\n```\n``` JavaScript []\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    if (nums1.length > nums2.length) {\\n        [nums1, nums2] = [nums2, nums1];\\n    }\\n    \\n    const m = nums1.length;\\n    const n = nums2.length;\\n    let low = 0, high = m;\\n    \\n    while (low <= high) {\\n        const partitionX = Math.floor((low + high) / 2);\\n        const partitionY = Math.floor((m + n + 1) / 2) - partitionX;\\n        \\n        const maxX = (partitionX === 0) ? Number.MIN_SAFE_INTEGER : nums1[partitionX - 1];\\n        const maxY = (partitionY === 0) ? Number.MIN_SAFE_INTEGER : nums2[partitionY - 1];\\n        \\n        const minX = (partitionX === m) ? Number.MAX_SAFE_INTEGER : nums1[partitionX];\\n        const minY = (partitionY === n) ? Number.MAX_SAFE_INTEGER : nums2[partitionY];\\n        \\n        if (maxX <= minY && maxY <= minX) {\\n            if ((m + n) % 2 === 0) {\\n                return (Math.max(maxX, maxY) + Math.min(minX, minY)) / 2;\\n            } else {\\n                return Math.max(maxX, maxY);\\n            }\\n        } else if (maxX > minY) {\\n            high = partitionX - 1;\\n        } else {\\n            low = partitionX + 1;\\n        }\\n    }\\n    \\n    throw new Error(\"Input arrays are not sorted.\");\\n};\\n```\n``` PHP []\\nclass Solution {\\n    function findMedianSortedArrays($nums1, $nums2) {\\n        if (count($nums1) > count($nums2)) {\\n            list($nums1, $nums2) = [$nums2, $nums1];\\n        }\\n        \\n        $m = count($nums1);\\n        $n = count($nums2);\\n        $low = 0; $high = $m;\\n        \\n        while ($low <= $high) {\\n            $partitionX = intdiv($low + $high, 2);\\n            $partitionY = intdiv($m + $n + 1, 2) - $partitionX;\\n            \\n            $maxX = ($partitionX == 0) ? PHP_INT_MIN : $nums1[$partitionX - 1];\\n            $maxY = ($partitionY == 0) ? PHP_INT_MIN : $nums2[$partitionY - 1];\\n            \\n            $minX = ($partitionX == $m) ? PHP_INT_MAX : $nums1[$partitionX];\\n            $minY = ($partitionY == $n) ? PHP_INT_MAX : $nums2[$partitionY];\\n            \\n            if ($maxX <= $minY && $maxY <= $minX) {\\n                if (($m + $n) % 2 == 0) {\\n                    return (max($maxX, $maxY) + min($minX, $minY)) / 2.0;\\n                } else {\\n                    return max($maxX, $maxY);\\n                }\\n            } elseif ($maxX > $minY) {\\n                $high = $partitionX - 1;\\n            } else {\\n                $low = $partitionX + 1;\\n            }\\n        }\\n        \\n        throw new Exception(\"Input arrays are not sorted.\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 908004,
                "title": "python-binary-search-diagram",
                "content": "Let\\'s go through an example of the question\\n ```\\n\\tA      : [2 4 6]\\n\\tB      : [1 3 5]\\n\\tFinal  : [1 2 3 4 5 6]\\n\\tMedian : (3 + 4) / 2 = 3.5\\n```\\n\\n\\nNext, we want to generate **all possible partitions** of A and B. Since both are sorted, we guarantee that these are the **only** possible partitions\\n\\n\\tA      : [ | 2 4 6]    L : [1 3 5]\\n\\tB      : [1 3 5 | ]    R : [2 4 6] ----- \\u274C, since 5 > 2\\n\\n\\tA      : [2 | 4 6]     L : [1 2 3]\\n\\tB      : [1 3 | 5]     R : [4 5 6] ----- \\u2714, since 2 < 5 and 3 < 4\\n\\n\\tA      : [2 4 | 6]     L : [1 2 4]\\n\\tB      : [1 | 3 5]     R : [3 5 6] ----- \\u274C, since 4 > 3\\n\\n\\tA      : [2 4 6 | ]    L : [2 4 6]\\n\\tB      : [ | 1 3 5]    R : [1 3 5] ----- \\u274C, since 6 > 1\\n\\n\\nQ : How do we know if a **partition is valid** (ie. all values in `L` <= all values in `R`?\\n```\\n\\tWe  only need to compare the 4 elements adjacent to the 2 partitions\\n```\\n\\nQ : How do we **represent empty partitions**?\\n```\\nIf it\\'s a empty left partition, we use INT_MIN\\nelse, we use INT_MAX\\n```\\n\\n```\\n\\tWe only need to check the 4 elements adjacent to the partition borders\\n```\\n\\n<br>\\n\\nWith that, we build our solution\\n\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n             \\n        # WE SHALL DO BINARY SEARCH ON THE SMALLER ARRAY, NUMS1\\n        if len(nums1) > len(nums2):\\n            return self.findMedianSortedArrays(nums2, nums1)\\n        \\n        # SETUP INT_MIN AND INT_MAX FOR EMPTY LEFT / RIGHT PARTITION\\n        INT_MIN, INT_MAX = -2**64, 2**64\\n        \\n        # SETUP LO AND HI POINTERS\\n        lo, hi = 0, len(nums1)\\n        left_partition_size = (len(nums1) + len(nums2) + 1) // 2\\n        n = len(nums1) + len(nums2)\\n        \\n        # LOOP TILL OOB\\n        while lo <= hi:\\n            \\n            # GET THE PARITIONS OF BOTH ARRAYS\\n            p1 = (lo + hi) // 2\\n            p2 = left_partition_size - p1\\n            \\n            # print(f\"NUMS1 : {nums1[:p1]} | {nums1[p1:]}\")\\n            # print(f\"NUMS2 : {nums2[:p2]} | {nums2[p2:]}\")\\n\\n            # GET THE 4 BOUNDARY NUMBERS\\n            nums1_left = nums1[p1 - 1] if p1 > 0 else INT_MIN\\n            nums1_right = nums1[p1] if p1 < len(nums1) else INT_MAX\\n            \\n            nums2_left = nums2[p2 - 1] if p2 > 0 else INT_MIN\\n            nums2_right = nums2[p2] if p2 < len(nums2) else INT_MAX\\n            \\n            # MOVE P1 LEFTWARDS\\n            if nums1_left > nums2_right:\\n                hi = p1 - 1\\n            \\n            # MOVE P1 RIGHTWARDS\\n            elif nums2_left > nums1_right:\\n                lo = p1 + 1\\n            \\n            # CORRECT PARTITION FOUND\\n            else:\\n                \\n                # ODD TOTAL LENGTH\\n                if n & 1:\\n                    return max(nums1_left, nums2_left)\\n                \\n                # EVEN TOTAL LENGTH\\n                return (max(nums1_left, nums2_left) + min(nums1_right, nums2_right)) / 2\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n\\tA      : [2 4 6]\\n\\tB      : [1 3 5]\\n\\tFinal  : [1 2 3 4 5 6]\\n\\tMedian : (3 + 4) / 2 = 3.5\\n```\n```\\n\\tWe  only need to compare the 4 elements adjacent to the 2 partitions\\n```\n```\\nIf it\\'s a empty left partition, we use INT_MIN\\nelse, we use INT_MAX\\n```\n```\\n\\tWe only need to check the 4 elements adjacent to the partition borders\\n```\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n             \\n        # WE SHALL DO BINARY SEARCH ON THE SMALLER ARRAY, NUMS1\\n        if len(nums1) > len(nums2):\\n            return self.findMedianSortedArrays(nums2, nums1)\\n        \\n        # SETUP INT_MIN AND INT_MAX FOR EMPTY LEFT / RIGHT PARTITION\\n        INT_MIN, INT_MAX = -2**64, 2**64\\n        \\n        # SETUP LO AND HI POINTERS\\n        lo, hi = 0, len(nums1)\\n        left_partition_size = (len(nums1) + len(nums2) + 1) // 2\\n        n = len(nums1) + len(nums2)\\n        \\n        # LOOP TILL OOB\\n        while lo <= hi:\\n            \\n            # GET THE PARITIONS OF BOTH ARRAYS\\n            p1 = (lo + hi) // 2\\n            p2 = left_partition_size - p1\\n            \\n            # print(f\"NUMS1 : {nums1[:p1]} | {nums1[p1:]}\")\\n            # print(f\"NUMS2 : {nums2[:p2]} | {nums2[p2:]}\")\\n\\n            # GET THE 4 BOUNDARY NUMBERS\\n            nums1_left = nums1[p1 - 1] if p1 > 0 else INT_MIN\\n            nums1_right = nums1[p1] if p1 < len(nums1) else INT_MAX\\n            \\n            nums2_left = nums2[p2 - 1] if p2 > 0 else INT_MIN\\n            nums2_right = nums2[p2] if p2 < len(nums2) else INT_MAX\\n            \\n            # MOVE P1 LEFTWARDS\\n            if nums1_left > nums2_right:\\n                hi = p1 - 1\\n            \\n            # MOVE P1 RIGHTWARDS\\n            elif nums2_left > nums1_right:\\n                lo = p1 + 1\\n            \\n            # CORRECT PARTITION FOUND\\n            else:\\n                \\n                # ODD TOTAL LENGTH\\n                if n & 1:\\n                    return max(nums1_left, nums2_left)\\n                \\n                # EVEN TOTAL LENGTH\\n                return (max(nums1_left, nums2_left) + min(nums1_right, nums2_right)) / 2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489494,
                "title": "c-java-python-javascript-o-log-min-m-n-iterative-solution-with-explanation",
                "content": "\\n# Intuition:\\nGiven two sorted arrays nums1 and nums2 of size n1 and n2 respectively, the median of the combined sorted array can be found by dividing the elements of the combined sorted array into two halves of equal length such that one half is always greater than the other. The median is then the average of the maximum element of the left half and the minimum element of the right half if the total number of elements is even, or the maximum element of the left half if the total number of elements is odd.\\n\\n# Approach:\\nWe can use binary search to find the partition of both arrays such that the number of elements on the left side of the combined array is equal to the number of elements on the right side of the combined array. The partition of nums1 and nums2 is represented by mid1 and mid2 respectively, such that mid1 + mid2 = (n1 + n2 + 1) / 2. We divide the combined sorted array into two halves such that the left half contains all elements before the partition and the right half contains all elements after the partition.\\n\\nWe then check if the maximum element of the left half of nums1 is less than or equal to the minimum element of the right half of nums2 and the maximum element of the left half of nums2 is less than or equal to the minimum element of the right half of nums1. If this condition is true, we have found the partition such that the number of elements on the left side of the combined array is equal to the number of elements on the right side of the combined array. We can then calculate the median using the approach mentioned in the intuition section.\\n\\nIf the condition is false, we adjust the partition of nums1 by changing l to mid1 + 1 if the maximum element of the left half of nums1 is greater than the minimum element of the right half of nums2, or by changing r to mid1 - 1 otherwise. We continue the binary search until we find the partition such that the condition is true or until the search space is exhausted.\\n\\n# Complexity:\\n- The time complexity of the solution is O(log(min(n1, n2))), where n1 and n2 are the sizes of nums1 and nums2 respectively, since we are performing binary search on the smaller array. \\n- The space complexity of the solution is O(1) since we are not using any extra space apart from a few variables to keep track of the search space and the partition of both arrays.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        // If nums1 is larger than nums2, swap them to ensure n1 is smaller than n2.\\n        if (n1 > n2) {\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        int l = 0;\\n        int r = n1;\\n        while (l <= r) {\\n            int mid1 = (l + r) / 2;\\n            int mid2 = (n1 + n2 + 1) / 2 - mid1;\\n            \\n            int maxLeft1 = (mid1 == 0) ? INT_MIN : nums1[mid1-1];\\n            int minRight1 = (mid1 == n1) ? INT_MAX : nums1[mid1];\\n            \\n            int maxLeft2 = (mid2 == 0) ? INT_MIN : nums2[mid2-1];\\n            int minRight2 = (mid2 == n2) ? INT_MAX : nums2[mid2];\\n            \\n            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\\n                if ((n1 + n2) % 2 == 0) {\\n                    return (double)(max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2;\\n                } else {\\n                    return (double)max(maxLeft1, maxLeft2);\\n                }\\n            } else if (maxLeft1 > minRight2) {\\n                r = mid1 - 1;\\n            } else {\\n                l = mid1 + 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\\n---\\n# JavaScript\\n```\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let n1 = nums1.length;\\n    let n2 = nums2.length;\\n    \\n    // If nums1 is larger than nums2, swap them to ensure n1 is smaller than n2.\\n    if (n1 > n2) {\\n        return findMedianSortedArrays(nums2, nums1);\\n    }\\n    \\n    let l = 0;\\n    let r = n1;\\n    while (l <= r) {\\n        let mid1 = Math.floor((l + r) / 2);\\n        let mid2 = Math.floor((n1 + n2 + 1) / 2 - mid1);\\n        \\n        let maxLeft1 = (mid1 == 0) ? Number.MIN_SAFE_INTEGER : nums1[mid1-1];\\n        let minRight1 = (mid1 == n1) ? Number.MAX_SAFE_INTEGER : nums1[mid1];\\n        \\n        let maxLeft2 = (mid2 == 0) ? Number.MIN_SAFE_INTEGER : nums2[mid2-1];\\n        let minRight2 = (mid2 == n2) ? Number.MAX_SAFE_INTEGER : nums2[mid2];\\n        \\n        if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\\n            if ((n1 + n2) % 2 == 0) {\\n                return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2;\\n            } else {\\n                return Math.max(maxLeft1, maxLeft2);\\n            }\\n        } else if (maxLeft1 > minRight2) {\\n            r = mid1 - 1;\\n        } else {\\n            l = mid1 + 1;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n\\n        // If nums1 is larger than nums2, swap them to ensure n1 is smaller than n2.\\n        if (n1 > n2) {\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n\\n        int l = 0;\\n        int r = n1;\\n        while (l <= r) {\\n            int mid1 = (l + r) / 2;\\n            int mid2 = (n1 + n2 + 1) / 2 - mid1;\\n\\n            int maxLeft1 = (mid1 == 0) ? Integer.MIN_VALUE : nums1[mid1 - 1];\\n            int minRight1 = (mid1 == n1) ? Integer.MAX_VALUE : nums1[mid1];\\n\\n            int maxLeft2 = (mid2 == 0) ? Integer.MIN_VALUE : nums2[mid2 - 1];\\n            int minRight2 = (mid2 == n2) ? Integer.MAX_VALUE : nums2[mid2];\\n\\n            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\\n                if ((n1 + n2) % 2 == 0) {\\n                    return (double) (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2;\\n                } else {\\n                    return (double) Math.max(maxLeft1, maxLeft2);\\n                }\\n            } else if (maxLeft1 > minRight2) {\\n                r = mid1 - 1;\\n            } else {\\n                l = mid1 + 1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n\\n        # If nums1 is larger than nums2, swap them to ensure n1 is smaller than n2.\\n        if n1 > n2:\\n            return self.findMedianSortedArrays(nums2, nums1)\\n\\n        l = 0\\n        r = n1\\n        while l <= r:\\n            mid1 = (l + r) / 2\\n            mid2 = (n1 + n2 + 1) / 2 - mid1\\n\\n            maxLeft1 = nums1[mid1-1] if mid1 != 0 else float(\\'-inf\\')\\n            minRight1 = nums1[mid1] if mid1 != n1 else float(\\'inf\\')\\n\\n            maxLeft2 = nums2[mid2-1] if mid2 != 0 else float(\\'-inf\\')\\n            minRight2 = nums2[mid2] if mid2 != n2 else float(\\'inf\\')\\n\\n            if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\\n                if (n1 + n2) % 2 == 0:\\n                    return float(max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2\\n                else:\\n                    return float(max(maxLeft1, maxLeft2))\\n            elif maxLeft1 > minRight2:\\n                r = mid1 - 1\\n            else:\\n                l = mid1 + 1\\n\\n        return -1\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        // If nums1 is larger than nums2, swap them to ensure n1 is smaller than n2.\\n        if (n1 > n2) {\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        int l = 0;\\n        int r = n1;\\n        while (l <= r) {\\n            int mid1 = (l + r) / 2;\\n            int mid2 = (n1 + n2 + 1) / 2 - mid1;\\n            \\n            int maxLeft1 = (mid1 == 0) ? INT_MIN : nums1[mid1-1];\\n            int minRight1 = (mid1 == n1) ? INT_MAX : nums1[mid1];\\n            \\n            int maxLeft2 = (mid2 == 0) ? INT_MIN : nums2[mid2-1];\\n            int minRight2 = (mid2 == n2) ? INT_MAX : nums2[mid2];\\n            \\n            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\\n                if ((n1 + n2) % 2 == 0) {\\n                    return (double)(max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2;\\n                } else {\\n                    return (double)max(maxLeft1, maxLeft2);\\n                }\\n            } else if (maxLeft1 > minRight2) {\\n                r = mid1 - 1;\\n            } else {\\n                l = mid1 + 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\n```\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let n1 = nums1.length;\\n    let n2 = nums2.length;\\n    \\n    // If nums1 is larger than nums2, swap them to ensure n1 is smaller than n2.\\n    if (n1 > n2) {\\n        return findMedianSortedArrays(nums2, nums1);\\n    }\\n    \\n    let l = 0;\\n    let r = n1;\\n    while (l <= r) {\\n        let mid1 = Math.floor((l + r) / 2);\\n        let mid2 = Math.floor((n1 + n2 + 1) / 2 - mid1);\\n        \\n        let maxLeft1 = (mid1 == 0) ? Number.MIN_SAFE_INTEGER : nums1[mid1-1];\\n        let minRight1 = (mid1 == n1) ? Number.MAX_SAFE_INTEGER : nums1[mid1];\\n        \\n        let maxLeft2 = (mid2 == 0) ? Number.MIN_SAFE_INTEGER : nums2[mid2-1];\\n        let minRight2 = (mid2 == n2) ? Number.MAX_SAFE_INTEGER : nums2[mid2];\\n        \\n        if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\\n            if ((n1 + n2) % 2 == 0) {\\n                return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2;\\n            } else {\\n                return Math.max(maxLeft1, maxLeft2);\\n            }\\n        } else if (maxLeft1 > minRight2) {\\n            r = mid1 - 1;\\n        } else {\\n            l = mid1 + 1;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n\\n```\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n\\n        // If nums1 is larger than nums2, swap them to ensure n1 is smaller than n2.\\n        if (n1 > n2) {\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n\\n        int l = 0;\\n        int r = n1;\\n        while (l <= r) {\\n            int mid1 = (l + r) / 2;\\n            int mid2 = (n1 + n2 + 1) / 2 - mid1;\\n\\n            int maxLeft1 = (mid1 == 0) ? Integer.MIN_VALUE : nums1[mid1 - 1];\\n            int minRight1 = (mid1 == n1) ? Integer.MAX_VALUE : nums1[mid1];\\n\\n            int maxLeft2 = (mid2 == 0) ? Integer.MIN_VALUE : nums2[mid2 - 1];\\n            int minRight2 = (mid2 == n2) ? Integer.MAX_VALUE : nums2[mid2];\\n\\n            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\\n                if ((n1 + n2) % 2 == 0) {\\n                    return (double) (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2;\\n                } else {\\n                    return (double) Math.max(maxLeft1, maxLeft2);\\n                }\\n            } else if (maxLeft1 > minRight2) {\\n                r = mid1 - 1;\\n            } else {\\n                l = mid1 + 1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n\\n        # If nums1 is larger than nums2, swap them to ensure n1 is smaller than n2.\\n        if n1 > n2:\\n            return self.findMedianSortedArrays(nums2, nums1)\\n\\n        l = 0\\n        r = n1\\n        while l <= r:\\n            mid1 = (l + r) / 2\\n            mid2 = (n1 + n2 + 1) / 2 - mid1\\n\\n            maxLeft1 = nums1[mid1-1] if mid1 != 0 else float(\\'-inf\\')\\n            minRight1 = nums1[mid1] if mid1 != n1 else float(\\'inf\\')\\n\\n            maxLeft2 = nums2[mid2-1] if mid2 != 0 else float(\\'-inf\\')\\n            minRight2 = nums2[mid2] if mid2 != n2 else float(\\'inf\\')\\n\\n            if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\\n                if (n1 + n2) % 2 == 0:\\n                    return float(max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2\\n                else:\\n                    return float(max(maxLeft1, maxLeft2))\\n            elif maxLeft1 > minRight2:\\n                r = mid1 - 1\\n            else:\\n                l = mid1 + 1\\n\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134918,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {\\n        let ln1 = nums1.count, ln2 = nums2.count\\n        var arr = Array(repeating: 0, count: ln1 + ln2), lna = arr.count\\n        var i = ln1 - 1, t = ln2 - 1, c = lna - 1\\n        \\n        while c >= 0 {\\n            if t < 0 || i >= 0 && nums1[i] > nums2[t] {\\n                arr[c] = nums1[i]\\n                c = c - 1\\n                i = i - 1\\n            } else {\\n                arr[c] = nums2[t]\\n                c = c - 1\\n                t = t - 1\\n            }\\n        }\\n        let m = lna / 2\\n        return lna % 2 == 0 ? Double(arr[m-1] + arr[m]) / 2 : Double(arr[m])\\n    }\\n}\\n```\\n\\n<!--\\nUpdated: 2023-09-21 | ID: c4cd81da-d433-43cb-b773-252966313777\\n-->",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {\\n        let ln1 = nums1.count, ln2 = nums2.count\\n        var arr = Array(repeating: 0, count: ln1 + ln2), lna = arr.count\\n        var i = ln1 - 1, t = ln2 - 1, c = lna - 1\\n        \\n        while c >= 0 {\\n            if t < 0 || i >= 0 && nums1[i] > nums2[t] {\\n                arr[c] = nums1[i]\\n                c = c - 1\\n                i = i - 1\\n            } else {\\n                arr[c] = nums2[t]\\n                c = c - 1\\n                t = t - 1\\n            }\\n        }\\n        let m = lna / 2\\n        return lna % 2 == 0 ? Double(arr[m-1] + arr[m]) / 2 : Double(arr[m])\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584932,
                "title": "java-o-log-m-n-tushar-roy-s-code",
                "content": "This is not my code, I got it from Tushar Roy\\'s channel, I think is one of the best ways to solve this problem and the code is very readable.\\n\\nhttps://www.youtube.com/watch?v=LPFhl65R7ww&t=1013s\\n\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1.length > nums2.length)return findMedianSortedArrays(nums2,nums1);\\n        int x = nums1.length;\\n        int y = nums2.length;\\n        int low = 0;\\n        int high = x;\\n        while(low<=high){\\n            int partX =  (low+high)/2;\\n            int partY =  (x+y+1)/2 - partX;\\n            int xLeft = partX == 0 ? Integer.MIN_VALUE : nums1[partX-1];\\n            int xRight = partX == x ? Integer.MAX_VALUE : nums1[partX];\\n            int yLeft = partY == 0 ? Integer.MIN_VALUE : nums2[partY-1];\\n            int yRight = partY == y ? Integer.MAX_VALUE : nums2[partY];\\n            if(xLeft<=yRight && yLeft<=xRight){\\n               if((x+y)%2==0){\\n                   return ((double)Math.max(xLeft,yLeft) + Math.min(xRight,yRight))/2;\\n               }else{\\n                   return Math.max(xLeft,yLeft);\\n               } \\n            }else if(xLeft>yRight){\\n                high = partX -1;\\n            }else{\\n                low = partX+1;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1.length > nums2.length)return findMedianSortedArrays(nums2,nums1);\\n        int x = nums1.length;\\n        int y = nums2.length;\\n        int low = 0;\\n        int high = x;\\n        while(low<=high){\\n            int partX =  (low+high)/2;\\n            int partY =  (x+y+1)/2 - partX;\\n            int xLeft = partX == 0 ? Integer.MIN_VALUE : nums1[partX-1];\\n            int xRight = partX == x ? Integer.MAX_VALUE : nums1[partX];\\n            int yLeft = partY == 0 ? Integer.MIN_VALUE : nums2[partY-1];\\n            int yRight = partY == y ? Integer.MAX_VALUE : nums2[partY];\\n            if(xLeft<=yRight && yLeft<=xRight){\\n               if((x+y)%2==0){\\n                   return ((double)Math.max(xLeft,yLeft) + Math.min(xRight,yRight))/2;\\n               }else{\\n                   return Math.max(xLeft,yLeft);\\n               } \\n            }else if(xLeft>yRight){\\n                high = partX -1;\\n            }else{\\n                low = partX+1;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 949705,
                "title": "python3-two-pointer-96-21-runtime-commented",
                "content": "```\\nRuntime: 80 ms, faster than 96.21% of Python3 online submissions for Median of Two Sorted Arrays.\\nMemory Usage: 14.5 MB, less than 41.24% of Python3 online submissions for Median of Two Sorted Arrays.\\n```\\n\\nI took a rather easy approach. First generate a sorted list of the two input lists combined, then find the middle one (or middle two, and take the average of those). But you don\\'t need to sort all of it, you just need to sort until you hit the middle.\\n\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n\\t    # Get the lengths of both lists\\n        l1,l2 = len(nums1), len(nums2)\\n\\t\\t# Determine the middle\\n        middle = (l1 + l2) / 2\\n\\t\\t\\n\\t\\t# EDGE CASE:\\n\\t\\t# If we only have 1 value (e.g. [1], []), return nums1[0] if the length of\\n\\t\\t# that list is greater than the length of l2, otherwise return nums2[1]\\n\\t\\tif middle == 0.5: return float(nums1[0]) if l1 > l2 else float(nums2[0])\\n\\n\\t\\t# Initialize 2 pointers\\n        x =  y = 0\\n\\t\\t# Initialize 2 values to store the previous and current value (in case of an even\\n\\t\\t# amount of values, we need to average 2 values)\\n        cur = prev = 0\\n\\t\\t# Determine the amount of loops we need. If the middle is even, loop that amount + 1:\\n\\t\\t# eg: [1, 2, 3, 4, 5, 6]        6 values, middle = 3, loops = 3+1\\n\\t\\t#            ^  ^ \\n\\t\\t#            |  +-- cur\\n\\t\\t#            +----- prev\\n \\t\\t# If the middle is odd, loop that amount + 0.5\\n\\t\\t# eg: [1, 2, 3, 4, 5]           5 values, middle = 2.5, loops = 2.5+0.5\\n\\t\\t#            ^\\n        #            +--- cur\\n        loops = middle+1 if middle % 1 == 0 else middle+0.5\\n\\n\\t\\t# Walk forward the amount of loops\\n        for _ in range(int(loops)):\\n            # Store the value of cur in prev\\n\\t\\t\\tprev = cur\\n\\t\\t\\t# If the x pointer is equal to the amount of elements of nums1 (l1 == len(nums1))\\n            if x == l1:\\n\\t\\t\\t    # Store nums2[y] in cur, \\'cause we hit the end of nums1\\n                cur =  nums2[y]\\n\\t\\t\\t\\t# Move the y pointer one ahead\\n                y += 1\\n\\t\\t    # If the y pointer is equal to the amount of elements of nums2 (l2 == len(nums2))\\n            elif y == l2:\\n\\t\\t\\t    # Store nums1[x] in cur, \\'cause we hit the end of nums2\\n                cur =  nums1[x]\\n\\t\\t\\t\\t# Move the x pointer one ahead\\n                x += 1\\n\\t\\t    # If the value in nums1 is bigger than the value in nums2\\n            elif nums1[x] > nums2[y]:\\n\\t\\t\\t    # Store nums2[y] in cur, because it\\'s the lowest value\\n                cur =  nums2[y]\\n\\t\\t\\t\\t# Move the y pointer one ahead\\n                y += 1\\n\\t\\t\\t# If the value in nums2 is bigger than the value in nums1\\n            else:\\n\\t\\t\\t\\t# Store nums1[x] in, because it\\'s the lowest value\\n                cur =  nums1[x]\\n\\t\\t\\t\\t# Move the x pointer one ahead\\n                x += 1\\n        \\n\\t\\t# If middle is even\\n        if middle % 1 == 0.0:\\n\\t\\t\\t# Return the average of the cur + prev values (which will return a float)\\n            return (cur+prev)/2\\n\\t\\t# If middle is odd\\n        else:\\n\\t\\t\\t# Return the cur value, as a float\\n            return float(cur)\\n```\\n\\nIt might not be the most dense way to write it, but it\\'s fairly readable, IMHO.",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nRuntime: 80 ms, faster than 96.21% of Python3 online submissions for Median of Two Sorted Arrays.\\nMemory Usage: 14.5 MB, less than 41.24% of Python3 online submissions for Median of Two Sorted Arrays.\\n```\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n\\t    # Get the lengths of both lists\\n        l1,l2 = len(nums1), len(nums2)\\n\\t\\t# Determine the middle\\n        middle = (l1 + l2) / 2\\n\\t\\t\\n\\t\\t# EDGE CASE:\\n\\t\\t# If we only have 1 value (e.g. [1], []), return nums1[0] if the length of\\n\\t\\t# that list is greater than the length of l2, otherwise return nums2[1]\\n\\t\\tif middle == 0.5: return float(nums1[0]) if l1 > l2 else float(nums2[0])\\n\\n\\t\\t# Initialize 2 pointers\\n        x =  y = 0\\n\\t\\t# Initialize 2 values to store the previous and current value (in case of an even\\n\\t\\t# amount of values, we need to average 2 values)\\n        cur = prev = 0\\n\\t\\t# Determine the amount of loops we need. If the middle is even, loop that amount + 1:\\n\\t\\t# eg: [1, 2, 3, 4, 5, 6]        6 values, middle = 3, loops = 3+1\\n\\t\\t#            ^  ^ \\n\\t\\t#            |  +-- cur\\n\\t\\t#            +----- prev\\n \\t\\t# If the middle is odd, loop that amount + 0.5\\n\\t\\t# eg: [1, 2, 3, 4, 5]           5 values, middle = 2.5, loops = 2.5+0.5\\n\\t\\t#            ^\\n        #            +--- cur\\n        loops = middle+1 if middle % 1 == 0 else middle+0.5\\n\\n\\t\\t# Walk forward the amount of loops\\n        for _ in range(int(loops)):\\n            # Store the value of cur in prev\\n\\t\\t\\tprev = cur\\n\\t\\t\\t# If the x pointer is equal to the amount of elements of nums1 (l1 == len(nums1))\\n            if x == l1:\\n\\t\\t\\t    # Store nums2[y] in cur, \\'cause we hit the end of nums1\\n                cur =  nums2[y]\\n\\t\\t\\t\\t# Move the y pointer one ahead\\n                y += 1\\n\\t\\t    # If the y pointer is equal to the amount of elements of nums2 (l2 == len(nums2))\\n            elif y == l2:\\n\\t\\t\\t    # Store nums1[x] in cur, \\'cause we hit the end of nums2\\n                cur =  nums1[x]\\n\\t\\t\\t\\t# Move the x pointer one ahead\\n                x += 1\\n\\t\\t    # If the value in nums1 is bigger than the value in nums2\\n            elif nums1[x] > nums2[y]:\\n\\t\\t\\t    # Store nums2[y] in cur, because it\\'s the lowest value\\n                cur =  nums2[y]\\n\\t\\t\\t\\t# Move the y pointer one ahead\\n                y += 1\\n\\t\\t\\t# If the value in nums2 is bigger than the value in nums1\\n            else:\\n\\t\\t\\t\\t# Store nums1[x] in, because it\\'s the lowest value\\n                cur =  nums1[x]\\n\\t\\t\\t\\t# Move the x pointer one ahead\\n                x += 1\\n        \\n\\t\\t# If middle is even\\n        if middle % 1 == 0.0:\\n\\t\\t\\t# Return the average of the cur + prev values (which will return a float)\\n            return (cur+prev)/2\\n\\t\\t# If middle is odd\\n        else:\\n\\t\\t\\t# Return the cur value, as a float\\n            return float(cur)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798913,
                "title": "python-simple-two-pointer-solution-time-o-n-m-space-o-1",
                "content": "**Idea**:\\n- Use two pointer to implictly build half of sorted merged list\\n- BUT INSTEAD of actually building the list, ONLY save the last two values of this (implict) sorted half  list\\n- Use those to values to generate answer\\n\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        n1, n2 = len(nums1), len(nums2)\\n        n = n1 + n2\\n       \\n        end = n // 2    \\n        i, i1, i2  = 0, 0, 0             # Pointer for implict merge list, nums1 pointer, nums2 pointer \\n        current, previous = 0, 0         # current and previous value in implict merge\\n        \\n        # Implictly build half of the sorted merge list\\n        # but only save last values\\n        while i <= end:\\n            previous = current\\n            if i1 == n1:                 # First list is exhausted ==> choose from second list\\n                current = nums2[i2] \\n                i2 += 1\\n            elif i2 == n2:               # Second list ist exhaused ==> choose from first list\\n                current = nums1[i1]\\n                i1 += 1\\n            elif nums1[i1] < nums2[i2]:  # Choose element from first list\\n                current = nums1[i1]\\n                i1 += 1\\n            else:                        # Choose element from second list\\n                current = nums2[i2]      \\n                i2 += 1\\n\\n            i += 1\\n        \\n        if n % 2 == 0:\\n            return (previous + current) / 2.0\\n        else: \\n            return current",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "**Idea**:\\n- Use two pointer to implictly build half of sorted merged list\\n- BUT INSTEAD of actually building the list, ONLY save the last two values of this (implict) sorted half  list\\n- Use those to values to generate answer\\n\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        n1, n2 = len(nums1), len(nums2)\\n        n = n1 + n2\\n       \\n        end = n // 2    \\n        i, i1, i2  = 0, 0, 0             # Pointer for implict merge list, nums1 pointer, nums2 pointer \\n        current, previous = 0, 0         # current and previous value in implict merge\\n        \\n        # Implictly build half of the sorted merge list\\n        # but only save last values\\n        while i <= end:\\n            previous = current\\n            if i1 == n1:                 # First list is exhausted ==> choose from second list\\n                current = nums2[i2] \\n                i2 += 1\\n            elif i2 == n2:               # Second list ist exhaused ==> choose from first list\\n                current = nums1[i1]\\n                i1 += 1\\n            elif nums1[i1] < nums2[i2]:  # Choose element from first list\\n                current = nums1[i1]\\n                i1 += 1\\n            else:                        # Choose element from second list\\n                current = nums2[i2]      \\n                i2 += 1\\n\\n            i += 1\\n        \\n        if n % 2 == 0:\\n            return (previous + current) / 2.0\\n        else: \\n            return current",
                "codeTag": "Java"
            },
            {
                "id": 1541639,
                "title": "worst-solution-ever-c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        for(int idx = 0; idx < nums2.size(); idx++)\\n            nums1.push_back(nums2[idx]);\\n        \\n        sort(nums1.begin(), nums1.end());\\n        int size = nums1.size();\\n        if(size % 2 != 0)\\n            return nums1[size/2];\\n        else\\n            return (nums1[size/2] + nums1[size/2-1])/2.00000;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        for(int idx = 0; idx < nums2.size(); idx++)\\n            nums1.push_back(nums2[idx]);\\n        \\n        sort(nums1.begin(), nums1.end());\\n        int size = nums1.size();\\n        if(size % 2 != 0)\\n            return nums1[size/2];\\n        else\\n            return (nums1[size/2] + nums1[size/2-1])/2.00000;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278326,
                "title": "javascript-100",
                "content": "taken from https://www.youtube.com/watch?v=LPFhl65R7ww\\n```\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    if(nums1.length > nums2.length) return findMedianSortedArrays(nums2, nums1)\\n    let x = nums1.length\\n    let y = nums2.length\\n    let low = 0, high = x\\n    while(low <= high) {\\n        const partitionX = (high + low) >> 1\\n        const partitionY = ((x + y + 1) >> 1) - partitionX\\n        \\n        const maxX = partitionX == 0 ? Number.NEGATIVE_INFINITY : nums1[partitionX - 1]\\n        const maxY = partitionY == 0 ? Number.NEGATIVE_INFINITY : nums2[partitionY - 1]\\n        \\n        const minX = partitionX == nums1.length ? Number.POSITIVE_INFINITY : nums1[partitionX]\\n        const minY = partitionY == nums2.length ? Number.POSITIVE_INFINITY : nums2[partitionY ]\\n        \\n        if(maxX <= minY && maxY <= minX) {\\n            const lowMax = Math.max(maxX, maxY)\\n            if( (x + y) % 2 == 1)\\n                return lowMax\\n            return (lowMax + Math.min(minX, minY)) / 2\\n        } else if(maxX < minY) {\\n            low = partitionX + 1\\n        } else \\n            high = partitionX - 1\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    if(nums1.length > nums2.length) return findMedianSortedArrays(nums2, nums1)\\n    let x = nums1.length\\n    let y = nums2.length\\n    let low = 0, high = x\\n    while(low <= high) {\\n        const partitionX = (high + low) >> 1\\n        const partitionY = ((x + y + 1) >> 1) - partitionX\\n        \\n        const maxX = partitionX == 0 ? Number.NEGATIVE_INFINITY : nums1[partitionX - 1]\\n        const maxY = partitionY == 0 ? Number.NEGATIVE_INFINITY : nums2[partitionY - 1]\\n        \\n        const minX = partitionX == nums1.length ? Number.POSITIVE_INFINITY : nums1[partitionX]\\n        const minY = partitionY == nums2.length ? Number.POSITIVE_INFINITY : nums2[partitionY ]\\n        \\n        if(maxX <= minY && maxY <= minX) {\\n            const lowMax = Math.max(maxX, maxY)\\n            if( (x + y) % 2 == 1)\\n                return lowMax\\n            return (lowMax + Math.min(minX, minY)) / 2\\n        } else if(maxX < minY) {\\n            low = partitionX + 1\\n        } else \\n            high = partitionX - 1\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2616,
                "title": "a-simple-non-recursion-binary-search-o-log-min-m-n",
                "content": "If you solve the k-th minmum value of two sorted arrays, you solve this problem.This is a classical problem of \"Divide and conquer\".\\nHere is another more simple and more neat solution.\\nCosider chosing first x numbers from A and first k - x numbers from B.if these k numbers are the k minmum numbers of A and B, x must satisfies that A[x + 1] >= B[k - x] and B[k - x + 1] >= A[x] (for better explanation index is base-1). \\nSo x is what we want.\\nObviously, if A[x + 1] < B[k - x + 1] then x must be smaller, else if B[k - x] < A[x] then x must be greater.  A nice two-value definition for binary search :)  Let A\\'size is not greater than B\\'s, the value of x can be calculated by binary searching, with time complexity of O(log(A\\'size)).\\nTo simplify edge cases,  we cosider each array infinite, with value of INTMIN when index < 1 and INTMAX when index > n.\\n\\nHere is the solution of c++ version:\\n\\n    typedef vector<int> vi;\\n    const int inf = 0x7fffffff, ninf = 0x80000000;\\n    class Solution {\\n        int kth_min(vi& a, vi& b, int k, int n, int m){\\n            #define A(i) (i < 1 ? ninf : (i > n ? inf : a[i - 1]))\\n            #define B(i) (i < 1 ? ninf : (i > m ? inf : b[i - 1]))\\n            int l = 0, r = n + 1, x;\\n            while(l <= r){\\n                x = (l + r) >> 1;\\n                if(A(x) > B(k - x + 1)) r = x - 1;\\n                else if(B(k - x) > A(x + 1)) l = x + 1;\\n                else return max(A(x), B(k - x));\\n            }\\n            return 0;   //never execute , just to hide the warning :)\\n            #undef A\\n            #undef B\\n        }\\n    public:\\n        double findMedianSortedArrays(vector<int>& a, vector<int>& b) {\\n            int n = a.size(), m = b.size();\\n            if(n > m) return findMedianSortedArrays(b, a); //make sure that a.size() <= b.size()\\n            if((m + n) & 1) return kth_min(a, b, (m + n + 1) >> 1, n, m);\\n            return (0.0 + kth_min(a, b, (m + n + 1) >> 1, n, m) + kth_min(a, b, ((m + n) >> 1) + 1, n, m)) * 0.5;\\n        }\\n    };",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        int kth_min(vi& a, vi& b, int k, int n, int m){\\n            #define A(i) (i < 1 ? ninf : (i > n ? inf : a[i - 1]))\\n            #define B(i) (i < 1 ? ninf : (i > m ? inf : b[i - 1]))\\n            int l = 0, r = n + 1, x;\\n            while(l <= r){\\n                x = (l + r) >> 1;\\n                if(A(x) > B(k - x + 1)) r = x - 1;\\n                else if(B(k - x) > A(x + 1)) l = x + 1;\\n                else return max(A(x), B(k - x));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4070884,
                "title": "my-thought-process-o-log-min-n-m-time-o-1-space-python-javascript-java-c",
                "content": "# Intuition\\nWelcome to my article! This starts with `What is median?`. Understanding `median` is a key to solve this quesiton.\\n\\n---\\n\\n# Solution Video\\n\\nToday, I\\'m going on business trip. This article is written in a train. lol\\nIf I have a time tonight, I will create a solution video for this question.\\n\\nInstead of the video, I added more comments to the codes.\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2,423\\nMy initial goal is 10,000\\nThank you for your support!\\n\\n---\\n\\n# Approach\\n\\n## My thought process - How I think about a solution\\n\\n### What is `median`?\\n\\nFirst and foremost, we must understand what `median` is. Without this understanding, we cannot write a program.\\n\\n`The median is one of the measures of central tendency for data or a set, representing the value that is at the middle position.`\\n\\n-  In the case of an even-sized data set\\n\\nHowever, in the case of an even-sized data set, the arithmetic mean of the two middle values is taken.\\n\\nFor example, in a data set consisting of the ages of 6 individuals: `1, 2, 3, 5, 9, 11`, the median is `4 years old` (taking two middle values `3 + 5` and divide by `2`)\\n\\n- In the case of an odd-sized data set\\n\\nIn the case of an odd-sized data set, for example, in a data set consisting of the ages of 5 individuals: `10, 32, 96, 100, 105` years old, the median is `96 years old`, which is the value at the 3rd position from both the top and the bottom. If there are 2 more children aged `0`, making a total of 7 individuals `0, 0, 10, 32, 96, 100, 105`, the median becomes `32 years old`.\\n\\n### My first thought\\nNow, I hope you understand what `median` is. Simply, when we convert `median` to program, we can write it like this.\\n\\nThis is Python code.\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        # Merge the two sorted arrays\\n        merged = sorted(nums1 + nums2)\\n        length = len(merged)\\n        \\n        # Check if the total length is even or odd\\n        if length % 2 == 0:\\n            # If even, return the average of the two middle elements\\n            return (merged[length // 2 - 1] + merged[length // 2]) / 2\\n        else:\\n            # If odd, return the middle element\\n            return merged[length // 2]\\n```\\nIt\\'s very simple right? In fact, this program passed all cases and execution time is not bad. Beats 68% when I ran the code. If we can use this code for this question. this is acutually easy problem.\\n\\nThat is my first thought.\\n\\n### We have a constraint\\n\\nBut we have a constrant about time complexity. Description says \"The overall run time complexity should be `O(log(m+n))`\", so we can\\'t use my simple solution for this question, even if the simple solution passed all cases.\\n\\nWe need to find another solution.\\n\\nLet\\'s focus on time complexity of the constraint. Time complexity of `O(log(m+n))` is a constraint, on the other hand, it should be a hint to solve the question. If you know time complexity well, you can guess a solution from `O(log(something))`.\\n\\nThat is time complexity of `binary search`. That\\'s why I stated to focus on a binary search-based solution to find the median of two arrays.\\n\\nThat is my thoguht process to reach `binary search-based solution`.\\n\\n---\\n\\n# Solution\\n\\n### Algorithm overview:\\n1. Ensure that nums1 is the smaller array.\\n2. Calculate the lengths of the input arrays nums1 and nums2.\\n3. Set the initial range for binary search on nums1 using the variables left and right.\\n\\n### Detailed Explanation:\\n1. Check and swap nums1 and nums2 if nums1 is longer than nums2 to ensure nums1 is the smaller array.\\n2. Calculate the lengths of nums1 and nums2 and store them in len1 and len2.\\n3. Initialize the binary search range using left (0) and right (length of nums1).\\n4. Enter a while loop that continues as long as the left pointer is less than or equal to the right pointer.\\n5. Inside the loop:\\n   a. Calculate the partition points for nums1 and nums2 based on the binary search.\\n   b. Determine the maximum elements on the left side (max_left) and minimum elements on the right side (min_right) for both arrays.\\n   c. Check if the current partition is correct by comparing max_left and min_right.\\n   d. If the partition is correct:\\n      - If the total length is even, return the average of max_left and min_right.\\n      - If the total length is odd, return max_left.\\n   e. If the partition is not correct, adjust the binary search range based on the comparison of max_left1 and min_right2.\\n\\nThis algorithm efficiently finds the median of two sorted arrays using a binary search approach to adjust the partition points and determine the correct position for the median.\\n\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: O(log(min(N, M)))\\nThe while loop performs binary search, and each iteration divides the search range in half. Thus, the time complexity is O(log(min(N, M))), where `N` is the length of nums1 and `M` is the length of nums2.\\n\\n- Space complexity: O(1)\\nThe algorithm uses a constant amount of extra space for variables like `left`, `right`, `partition1`, `partition2`, `max_left1`, `max_left2`, `max_left`, `min_right1`, `min_right2`, and `min_right`. Therefore, the space complexity is O(1), indicating constant space usage irrespective of the input size.\\n\\n\\n```python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        # Ensure nums1 is the smaller array\\n        if len(nums1) > len(nums2):\\n            nums1, nums2 = nums2, nums1\\n        \\n        # Get the lengths of the two arrays\\n        len1, len2 = len(nums1), len(nums2)\\n        \\n        # Set the range for binary search on nums1\\n        left, right = 0, len1\\n        \\n        while left <= right:\\n            # Partition nums1 and nums2\\n            partition1 = (left + right) // 2\\n            partition2 = (len1 + len2 + 1) // 2 - partition1\\n            \\n            # Find the maximum elements on the left of the partition\\n            max_left1 = nums1[partition1-1] if partition1 > 0 else float(\\'-inf\\')\\n            max_left2 = nums2[partition2-1] if partition2 > 0 else float(\\'-inf\\')\\n            max_left = max(max_left1, max_left2)\\n            \\n            # Find the minimum elements on the right of the partition\\n            min_right1 = nums1[partition1] if partition1 < len1 else float(\\'inf\\')\\n            min_right2 = nums2[partition2] if partition2 < len2 else float(\\'inf\\')\\n            min_right = min(min_right1, min_right2)\\n            \\n            # Check if the partition is correct\\n            if max_left <= min_right:\\n                # If the total length is even, return the average of the two middle elements\\n                if (len1 + len2) % 2 == 0:\\n                    return (max_left + min_right) / 2\\n                # If the total length is odd, return the middle element\\n                else:\\n                    return max_left\\n            elif max_left1 > min_right2:\\n                right = partition1 - 1\\n            else:\\n                left = partition1 + 1\\n```\\n```javascript []\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    // Ensure nums1 is the smaller array\\n    if (nums1.length > nums2.length) {\\n        [nums1, nums2] = [nums2, nums1];\\n    }\\n\\n    // Get the lengths of the two arrays\\n    const len1 = nums1.length;\\n    const len2 = nums2.length;\\n\\n    // Set the range for binary search on nums1\\n    let left = 0;\\n    let right = len1;\\n\\n    while (left <= right) {\\n        // Partition nums1 and nums2\\n        const partition1 = Math.floor((left + right) / 2);\\n        const partition2 = Math.floor((len1 + len2 + 1) / 2) - partition1;\\n\\n        // Find the maximum elements on the left of the partition\\n        const maxLeft1 = partition1 > 0 ? nums1[partition1 - 1] : Number.NEGATIVE_INFINITY;\\n        const maxLeft2 = partition2 > 0 ? nums2[partition2 - 1] : Number.NEGATIVE_INFINITY;\\n        const maxLeft = Math.max(maxLeft1, maxLeft2);\\n\\n        // Find the minimum elements on the right of the partition\\n        const minRight1 = partition1 < len1 ? nums1[partition1] : Number.POSITIVE_INFINITY;\\n        const minRight2 = partition2 < len2 ? nums2[partition2] : Number.POSITIVE_INFINITY;\\n        const minRight = Math.min(minRight1, minRight2);\\n\\n        // Check if the partition is correct\\n        if (maxLeft <= minRight) {\\n            // If the total length is even, return the average of the two middle elements\\n            if ((len1 + len2) % 2 === 0) {\\n                return (maxLeft + minRight) / 2;\\n            }\\n            // If the total length is odd, return the middle element\\n            else {\\n                return maxLeft;\\n            }\\n        } else if (maxLeft1 > minRight2) {\\n            right = partition1 - 1;\\n        } else {\\n            left = partition1 + 1;\\n        }\\n    }    \\n};\\n```\\n```java []\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        // Ensure nums1 is the smaller array\\n        if (nums1.length > nums2.length) {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n\\n        // Get the lengths of the two arrays\\n        int len1 = nums1.length;\\n        int len2 = nums2.length;\\n\\n        // Set the range for binary search on nums1\\n        int left = 0;\\n        int right = len1;\\n\\n        while (left <= right) {\\n            // Partition nums1 and nums2\\n            int partition1 = (left + right) / 2;\\n            int partition2 = (len1 + len2 + 1) / 2 - partition1;\\n\\n            // Find the maximum elements on the left of the partition\\n            int maxLeft1 = partition1 > 0 ? nums1[partition1 - 1] : Integer.MIN_VALUE;\\n            int maxLeft2 = partition2 > 0 ? nums2[partition2 - 1] : Integer.MIN_VALUE;\\n            int maxLeft = Math.max(maxLeft1, maxLeft2);\\n\\n            // Find the minimum elements on the right of the partition\\n            int minRight1 = partition1 < len1 ? nums1[partition1] : Integer.MAX_VALUE;\\n            int minRight2 = partition2 < len2 ? nums2[partition2] : Integer.MAX_VALUE;\\n            int minRight = Math.min(minRight1, minRight2);\\n\\n            // Check if the partition is correct\\n            if (maxLeft <= minRight) {\\n                // If the total length is even, return the average of the two middle elements\\n                if ((len1 + len2) % 2 == 0) {\\n                    return (maxLeft + minRight) / 2.0;\\n                }\\n                // If the total length is odd, return the middle element\\n                else {\\n                    return maxLeft;\\n                }\\n            } else if (maxLeft1 > minRight2) {\\n                right = partition1 - 1;\\n            } else {\\n                left = partition1 + 1;\\n            }\\n        }\\n\\n        return 0.0; // This should not be reached, just to satisfy Java\\'s return requirements\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        // Ensure nums1 is the smaller array\\n        if (nums1.size() > nums2.size()) {\\n            nums1.swap(nums2);\\n        }\\n\\n        // Get the lengths of the two arrays\\n        int len1 = nums1.size();\\n        int len2 = nums2.size();\\n\\n        // Set the range for binary search on nums1\\n        int left = 0;\\n        int right = len1;\\n\\n        while (left <= right) {\\n            // Partition nums1 and nums2\\n            int partition1 = (left + right) / 2;\\n            int partition2 = (len1 + len2 + 1) / 2 - partition1;\\n\\n            // Find the maximum elements on the left of the partition\\n            int maxLeft1 = partition1 > 0 ? nums1[partition1 - 1] : INT_MIN;\\n            int maxLeft2 = partition2 > 0 ? nums2[partition2 - 1] : INT_MIN;\\n            int maxLeft = max(maxLeft1, maxLeft2);\\n\\n            // Find the minimum elements on the right of the partition\\n            int minRight1 = partition1 < len1 ? nums1[partition1] : INT_MAX;\\n            int minRight2 = partition2 < len2 ? nums2[partition2] : INT_MAX;\\n            int minRight = min(minRight1, minRight2);\\n\\n            // Check if the partition is correct\\n            if (maxLeft <= minRight) {\\n                // If the total length is even, return the average of the two middle elements\\n                if ((len1 + len2) % 2 == 0) {\\n                    return (maxLeft + minRight) / 2.0;\\n                }\\n                // If the total length is odd, return the middle element\\n                else {\\n                    return maxLeft;\\n                }\\n            } else if (maxLeft1 > minRight2) {\\n                right = partition1 - 1;\\n            } else {\\n                left = partition1 + 1;\\n            }\\n        }\\n\\n        return 0.0; // This should not be reached, just to satisfy C++\\'s return requirements        \\n    }\\n};\\n```\\n\\n---\\n\\n\\nThank you for reading such a long article.\\n\\n\\u2B50\\uFE0F If you learn something from the article, please upvote it and don\\'t forget to subscribe to my channel!\\n\\nMy next post for daily coding challenge on Sep 22, 2023\\nhttps://leetcode.com/problems/is-subsequence/solutions/4074388/video-how-i-think-about-a-solution-ot-time-o1-space-python-javascript-java-c/\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        # Merge the two sorted arrays\\n        merged = sorted(nums1 + nums2)\\n        length = len(merged)\\n        \\n        # Check if the total length is even or odd\\n        if length % 2 == 0:\\n            # If even, return the average of the two middle elements\\n            return (merged[length // 2 - 1] + merged[length // 2]) / 2\\n        else:\\n            # If odd, return the middle element\\n            return merged[length // 2]\\n```\n```python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        # Ensure nums1 is the smaller array\\n        if len(nums1) > len(nums2):\\n            nums1, nums2 = nums2, nums1\\n        \\n        # Get the lengths of the two arrays\\n        len1, len2 = len(nums1), len(nums2)\\n        \\n        # Set the range for binary search on nums1\\n        left, right = 0, len1\\n        \\n        while left <= right:\\n            # Partition nums1 and nums2\\n            partition1 = (left + right) // 2\\n            partition2 = (len1 + len2 + 1) // 2 - partition1\\n            \\n            # Find the maximum elements on the left of the partition\\n            max_left1 = nums1[partition1-1] if partition1 > 0 else float(\\'-inf\\')\\n            max_left2 = nums2[partition2-1] if partition2 > 0 else float(\\'-inf\\')\\n            max_left = max(max_left1, max_left2)\\n            \\n            # Find the minimum elements on the right of the partition\\n            min_right1 = nums1[partition1] if partition1 < len1 else float(\\'inf\\')\\n            min_right2 = nums2[partition2] if partition2 < len2 else float(\\'inf\\')\\n            min_right = min(min_right1, min_right2)\\n            \\n            # Check if the partition is correct\\n            if max_left <= min_right:\\n                # If the total length is even, return the average of the two middle elements\\n                if (len1 + len2) % 2 == 0:\\n                    return (max_left + min_right) / 2\\n                # If the total length is odd, return the middle element\\n                else:\\n                    return max_left\\n            elif max_left1 > min_right2:\\n                right = partition1 - 1\\n            else:\\n                left = partition1 + 1\\n```\n```javascript []\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    // Ensure nums1 is the smaller array\\n    if (nums1.length > nums2.length) {\\n        [nums1, nums2] = [nums2, nums1];\\n    }\\n\\n    // Get the lengths of the two arrays\\n    const len1 = nums1.length;\\n    const len2 = nums2.length;\\n\\n    // Set the range for binary search on nums1\\n    let left = 0;\\n    let right = len1;\\n\\n    while (left <= right) {\\n        // Partition nums1 and nums2\\n        const partition1 = Math.floor((left + right) / 2);\\n        const partition2 = Math.floor((len1 + len2 + 1) / 2) - partition1;\\n\\n        // Find the maximum elements on the left of the partition\\n        const maxLeft1 = partition1 > 0 ? nums1[partition1 - 1] : Number.NEGATIVE_INFINITY;\\n        const maxLeft2 = partition2 > 0 ? nums2[partition2 - 1] : Number.NEGATIVE_INFINITY;\\n        const maxLeft = Math.max(maxLeft1, maxLeft2);\\n\\n        // Find the minimum elements on the right of the partition\\n        const minRight1 = partition1 < len1 ? nums1[partition1] : Number.POSITIVE_INFINITY;\\n        const minRight2 = partition2 < len2 ? nums2[partition2] : Number.POSITIVE_INFINITY;\\n        const minRight = Math.min(minRight1, minRight2);\\n\\n        // Check if the partition is correct\\n        if (maxLeft <= minRight) {\\n            // If the total length is even, return the average of the two middle elements\\n            if ((len1 + len2) % 2 === 0) {\\n                return (maxLeft + minRight) / 2;\\n            }\\n            // If the total length is odd, return the middle element\\n            else {\\n                return maxLeft;\\n            }\\n        } else if (maxLeft1 > minRight2) {\\n            right = partition1 - 1;\\n        } else {\\n            left = partition1 + 1;\\n        }\\n    }    \\n};\\n```\n```java []\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        // Ensure nums1 is the smaller array\\n        if (nums1.length > nums2.length) {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n\\n        // Get the lengths of the two arrays\\n        int len1 = nums1.length;\\n        int len2 = nums2.length;\\n\\n        // Set the range for binary search on nums1\\n        int left = 0;\\n        int right = len1;\\n\\n        while (left <= right) {\\n            // Partition nums1 and nums2\\n            int partition1 = (left + right) / 2;\\n            int partition2 = (len1 + len2 + 1) / 2 - partition1;\\n\\n            // Find the maximum elements on the left of the partition\\n            int maxLeft1 = partition1 > 0 ? nums1[partition1 - 1] : Integer.MIN_VALUE;\\n            int maxLeft2 = partition2 > 0 ? nums2[partition2 - 1] : Integer.MIN_VALUE;\\n            int maxLeft = Math.max(maxLeft1, maxLeft2);\\n\\n            // Find the minimum elements on the right of the partition\\n            int minRight1 = partition1 < len1 ? nums1[partition1] : Integer.MAX_VALUE;\\n            int minRight2 = partition2 < len2 ? nums2[partition2] : Integer.MAX_VALUE;\\n            int minRight = Math.min(minRight1, minRight2);\\n\\n            // Check if the partition is correct\\n            if (maxLeft <= minRight) {\\n                // If the total length is even, return the average of the two middle elements\\n                if ((len1 + len2) % 2 == 0) {\\n                    return (maxLeft + minRight) / 2.0;\\n                }\\n                // If the total length is odd, return the middle element\\n                else {\\n                    return maxLeft;\\n                }\\n            } else if (maxLeft1 > minRight2) {\\n                right = partition1 - 1;\\n            } else {\\n                left = partition1 + 1;\\n            }\\n        }\\n\\n        return 0.0; // This should not be reached, just to satisfy Java\\'s return requirements\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        // Ensure nums1 is the smaller array\\n        if (nums1.size() > nums2.size()) {\\n            nums1.swap(nums2);\\n        }\\n\\n        // Get the lengths of the two arrays\\n        int len1 = nums1.size();\\n        int len2 = nums2.size();\\n\\n        // Set the range for binary search on nums1\\n        int left = 0;\\n        int right = len1;\\n\\n        while (left <= right) {\\n            // Partition nums1 and nums2\\n            int partition1 = (left + right) / 2;\\n            int partition2 = (len1 + len2 + 1) / 2 - partition1;\\n\\n            // Find the maximum elements on the left of the partition\\n            int maxLeft1 = partition1 > 0 ? nums1[partition1 - 1] : INT_MIN;\\n            int maxLeft2 = partition2 > 0 ? nums2[partition2 - 1] : INT_MIN;\\n            int maxLeft = max(maxLeft1, maxLeft2);\\n\\n            // Find the minimum elements on the right of the partition\\n            int minRight1 = partition1 < len1 ? nums1[partition1] : INT_MAX;\\n            int minRight2 = partition2 < len2 ? nums2[partition2] : INT_MAX;\\n            int minRight = min(minRight1, minRight2);\\n\\n            // Check if the partition is correct\\n            if (maxLeft <= minRight) {\\n                // If the total length is even, return the average of the two middle elements\\n                if ((len1 + len2) % 2 == 0) {\\n                    return (maxLeft + minRight) / 2.0;\\n                }\\n                // If the total length is odd, return the middle element\\n                else {\\n                    return maxLeft;\\n                }\\n            } else if (maxLeft1 > minRight2) {\\n                right = partition1 - 1;\\n            } else {\\n                left = partition1 + 1;\\n            }\\n        }\\n\\n        return 0.0; // This should not be reached, just to satisfy C++\\'s return requirements        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070396,
                "title": "c-easy-tc-o-log-min-m-n-explained",
                "content": "# Annnoumement\\nWe are statrting leetcode 75 days chellange (25 easy,25 medium ,25 hard)So Join us with this journy on Linkdin and instagram check leetcode profile for that . Let\\'s continue our journey of problem-solving and exploration together.\\n\\n# Intuition\\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the **median of the two sorted arrays**.\\nInput: nums1 = [1,2], nums2 = [3,4]\\nOutput: **2.50000**\\nExplanation: **merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.**\\n\\n\\n# Approach\\nTo find the median of two sorted arrays without extra space, we can optimize by considering only the border elements of the arrays. \\n- We have to  Calculate the **total number of elements in both arrays** (the sum of their lengths).\\n- We have to find how many elements from the first array should appear before the median by subtracting half of the total elements from the number of elements selected from the first array.\\n- When we are finding the median, **we have to keep track of two middle elements for an even number of elements or one middle element for an odd number**.\\n- During merging, compare border elements (left value of one array with right value of the other). Since** arrays are sorted**, left values will always be less than right values within their respective arrays. This approach saves space and efficiently finds the median.\\n\\n# Code explaination\\nCertainly, here\\'s the modified algorithm presented in plain text:\\n\\n1. First we will Initialize two variables: `l` and `r`, where `l` is set to 0, and `r` is set to `m` (the size of the smaller array).\\n\\n2. Then we will enter a loop while( `l <= r`)\\n\\n3. After that In each iteration, partition the range by finding the middle point and select the elements before the partition from the first array, which we\\'ll call `fir`. The remaining elements belong to the second array and are called $$\\'sec\\'$$ here fir means first and sec means second .\\n\\n4. Determine the values of the border elements of the elements taken from both arrays:\\n   - `l1`: The leftmost element from the first array.\\n   - `l2`: The leftmost element from the second array.\\n   - `r1`: The rightmost element from the first array.\\n   - `r2`: The rightmost element from the second array.\\n\\n5. After that We will Compare the border elements to ensure the sorting order of the elements, which means checking if `l1 <= r2` and `l2 <= r1`.\\n\\n6. If the above condition is true, and the total number of elements in both arrays is even, then calculate the median as follows: `median = (max(l1, l2) + min(r1, r2)) / 2`. Otherwise, if the total number of elements is odd, set `median` to `max(l1, l2)`.\\n\\n7. If `l1 > r2`, we will reduce the right limit `r` to `fir - 1`.\\n\\n8. Otherwise, we will increment the left limit `l` to `fir + 1`.\\n\\n\\n# Complexity\\n- Time complexity:**O(log(min(m,n)))**\\n- Space complexity:**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int m = nums1.size();\\n        int n = nums2.size();\\n        \\n        if(m > n)\\n            return findMedianSortedArrays(nums2, nums1);\\n        \\n        int l=0, r= m;\\n        int total = m+n+1;\\n        \\n        while(l<=r)\\n        {\\n            int fir = l + (r-l)/2;\\n            int sec = total/2 - fir;\\n            \\n            int l1=INT_MIN, l2=INT_MIN;\\n            int r1=INT_MAX, r2=INT_MAX;\\n            \\n            if(fir > 0)\\n                l1 = nums1[fir-1];\\n            if(sec>0)\\n                l2 = nums2[sec-1];\\n            if((fir>=0) && (fir<m))\\n                r1 = nums1[fir];\\n            if((sec>=0) && (sec<n))\\n                r2 = nums2[sec];\\n            if(l1<=r2 && l2<=r1){\\n                if((n+m)%2 == 0)\\n                    return (max(l1, l2)+min(r1, r2))/2.0;\\n                else\\n                    return max(l1, l2);\\n            }\\n            else if(l1> r2)\\n                r = fir-1;\\n            else\\n                l = fir+1;\\n        }     \\n        return 0;      \\n    }\\n};\\n```\\nIf you really found my solution helpful **please upvote it**, as it motivates me to post such kind of codes.\\n**Let me know in comment if i can do better.**\\n![upvote.jfif](https://assets.leetcode.com/users/images/b0bf2fa1-1680-41fc-be3f-3ba1c8745505_1675216604.7695017.jpeg)",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int m = nums1.size();\\n        int n = nums2.size();\\n        \\n        if(m > n)\\n            return findMedianSortedArrays(nums2, nums1);\\n        \\n        int l=0, r= m;\\n        int total = m+n+1;\\n        \\n        while(l<=r)\\n        {\\n            int fir = l + (r-l)/2;\\n            int sec = total/2 - fir;\\n            \\n            int l1=INT_MIN, l2=INT_MIN;\\n            int r1=INT_MAX, r2=INT_MAX;\\n            \\n            if(fir > 0)\\n                l1 = nums1[fir-1];\\n            if(sec>0)\\n                l2 = nums2[sec-1];\\n            if((fir>=0) && (fir<m))\\n                r1 = nums1[fir];\\n            if((sec>=0) && (sec<n))\\n                r2 = nums2[sec];\\n            if(l1<=r2 && l2<=r1){\\n                if((n+m)%2 == 0)\\n                    return (max(l1, l2)+min(r1, r2))/2.0;\\n                else\\n                    return max(l1, l2);\\n            }\\n            else if(l1> r2)\\n                r = fir-1;\\n            else\\n                l = fir+1;\\n        }     \\n        return 0;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592457,
                "title": "python-o-m-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        m, n = len(nums1), len(nums2)\\n        mid = (m + n) // 2 + 1\\n        prev2 = prev1 = None\\n        i = j = 0\\n\\n        for _ in range(mid):\\n            prev2 = prev1\\n            if j == n or (i != m and nums1[i] <= nums2[j]):\\n                prev1 = nums1[i]\\n                i += 1\\n            else:\\n                prev1 = nums2[j]\\n                j += 1\\n        \\n        return prev1 if (m + n) % 2 else (prev1 + prev2) / 2",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        m, n = len(nums1), len(nums2)\\n        mid = (m + n) // 2 + 1\\n        prev2 = prev1 = None\\n        i = j = 0\\n\\n        for _ in range(mid):\\n            prev2 = prev1\\n            if j == n or (i != m and nums1[i] <= nums2[j]):\\n                prev1 = nums1[i]\\n                i += 1\\n            else:\\n                prev1 = nums2[j]\\n                j += 1\\n        \\n        return prev1 if (m + n) % 2 else (prev1 + prev2) / 2",
                "codeTag": "Java"
            },
            {
                "id": 1299195,
                "title": "java-2ms-99-87-merge-method-with-m-n-2-iterations-solution-with-comment-for-undersanding",
                "content": "The Idea behind this solution is to use **merge sort** method **with ( m + n ) / 2 iterations**. \\n\\nif ( m + n ) is odd then return ( mid )\\nbut if ( m + n ) is even we need to return **( mid + mid - 1)  / 2**, That\\'s why we have **maintained previous value** in code.\\n\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] a, int[] b) {\\n        \\n        int len = a.length + b.length;\\n        \\n        int aIndex = 0;  // Iterator for nums1 array\\n        int bIndex = 0;  // Iterator for nums2 array\\n        \\n        int previous = 0;           // for even case\\n        int current = 0;            // for odd and even case\\n        int resultIndex = 0;        // merged sorted array Index \\n        \\n        while(resultIndex++ <= (len / 2)) {     // LOOP UP TO (M + N) / 2\\n            \\n            previous = current;          // assign current value to previous\\n\\n            if(aIndex >= a.length) {     // if aIndex >= a length then only use b;\\n                current = b[bIndex++];   // update current value and increment bIndex;\\n                continue;                \\n            } \\n            \\n            if(bIndex >= b.length ) {    // similar as above,for bIndex\\n                current = a[aIndex++];\\n                continue;\\n            } \\n            \\n            if(a[aIndex] < b[bIndex]) {  // marge method;\\n                current = a[aIndex++];\\n            } else {\\n                current = b[bIndex++];\\n            }\\n        }\\n        \\n        if(len % 2 == 0) {   \\n            return (double) (previous  + current)/2;   // if len is even\\n        } else {\\n            return (double) current;                   // if len is odd\\n        }\\n    }\\n}\\n```\\n\\n**UPVOTE** if this solution helped you.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] a, int[] b) {\\n        \\n        int len = a.length + b.length;\\n        \\n        int aIndex = 0;  // Iterator for nums1 array\\n        int bIndex = 0;  // Iterator for nums2 array\\n        \\n        int previous = 0;           // for even case\\n        int current = 0;            // for odd and even case\\n        int resultIndex = 0;        // merged sorted array Index \\n        \\n        while(resultIndex++ <= (len / 2)) {     // LOOP UP TO (M + N) / 2\\n            \\n            previous = current;          // assign current value to previous\\n\\n            if(aIndex >= a.length) {     // if aIndex >= a length then only use b;\\n                current = b[bIndex++];   // update current value and increment bIndex;\\n                continue;                \\n            } \\n            \\n            if(bIndex >= b.length ) {    // similar as above,for bIndex\\n                current = a[aIndex++];\\n                continue;\\n            } \\n            \\n            if(a[aIndex] < b[bIndex]) {  // marge method;\\n                current = a[aIndex++];\\n            } else {\\n                current = b[bIndex++];\\n            }\\n        }\\n        \\n        if(len % 2 == 0) {   \\n            return (double) (previous  + current)/2;   // if len is even\\n        } else {\\n            return (double) current;                   // if len is odd\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862,
                "title": "share-my-simple-o-log-m-n-c-solution",
                "content": "    class Solution {\\n    public:\\n        double findMedianSortedArrays(int A[], int m, int B[], int n) {\\n            int length=m+n;\\n            if(length%2)return findkth(A, m, B, n, length/2+1);\\n            else return (double(findkth(A, m, B, n, length/2))+findkth(A, m, B, n, length/2+1))/2;\\n        }\\n        int findkth(int A[],int m,int B[], int n, int k){\\n            if(m>n)\\n                return findkth(B, n, A, m,k);\\n            if(m==0)return B[k-1];\\n            if(k==1)return A[0]<B[0]?A[0]:B[0];\\n            int pa=k/2<m?k/2:m;\\n            int pb=k-pa;\\n            if(A[pa-1]==B[pb-1]){return A[pa-1];}\\n            if(A[pa-1]<B[pb-1])\\n                return findkth(A+pa, m-pa, B, pb, k-pa);\\n            else\\n                return findkth(A,pa,B+pb,n-pb,k-pb);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        double findMedianSortedArrays(int A[], int m, int B[], int n) {\\n            int length=m+n;\\n            if(length%2)return findkth(A, m, B, n, length/2+1);\\n            else return (double(findkth(A, m, B, n, length/2))+findkth(A, m, B, n, length/2+1))/2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2559,
                "title": "what-does-median-mean",
                "content": "    Input:\\t[1,1], [1,2]\\n    Expected:\\t1.00000\\n\\n    Input:\\t[4,5,6,8,9], []\\n    Expected:\\t6.00000\\n\\n    Input:\\t[], [2,3]\\n    Expected:\\t2.50000\\n\\nI don't understand!\\n\\nWhat does `median` mean?\\n\\nWhat on earth should I do?\\n\\nCan anyone help me?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3779910,
                "title": "c-apni-bhasha-mein-easy-explanation-binary-search-interview-prep",
                "content": "# Intuition & Approach\\n- Beautifully Explained in the code.\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n       \\tLOGIC\\n\\n       \\tAPPROACH-1(NAIVE)\\n       \\t1. Merge Sort\\u2753 (Kyoki hame 2 sorted array dikh gaye), Ab median kyoki hame merge karke hi milega.\\n       \\tO(M+N)\\n\\n       \\tAPPROACH-2(BINARY SEARCH)\\n\\n       \\t1.Why\\u2753 Sorted array se hame Binary Search strike karega.\\n\\n       \\t2.Ab isme Binary Search lagayenge kaise\\u2753\\n\\n       \\t3.We will partition both the arrays lets say Left part of both into L1,L2\\n       \\tand Right part of both into R1,R2.\\n\\n       \\t4.Left part and Right part se matlab?->Left part (L1+L2) wo hoga joki agar \\n       \\tmerge karte arrays ko to median ke left part wala hota aur Right part (R1+R2)\\n       \\tjo median ke right mein hota.\\n\\n       \\t5.Now main action of BINARY SEARCH \\uD83D\\uDE0E is \\uD83D\\uDD25PARTITIONING\\uD83D\\uDD25.\\n\\n       \\t6.Implement kaise karenge\\u2753\\n       \\t- We will do the Binary Search in the array having shortest size.\\n\\n       \\t- Why shortest\\u2753TC less hoga \\n\\n       \\t- median = (n+m+1)/2, low=0, high=n\\n\\n       \\t- PARTITION -> cut1 = (low+high)/2 {Pehle array ke kitne elem L1 mein honge}\\n       \\tcut2= median - cut1 {Dusre array ke kitne elem L2 mein honge}.\\n\\n       \\t- Ab L1,L2 ki border values jo ki median ke just left = l1,l2 and R1,R2 ki \\n       \\tborder values jo ki median ke just right will r1,r2\\n\\n       \\tAb sara khel inhi ka hain\\n\\n       \\t- If cut1!=0 take l1=nums1[cut1-1],cut2!=0 l2=nums2[cut2-1],cut1!=n \\n       \\tr1=nums1[cut1],cut2!=m r2=nums2[cut2].\\n\\n       \\tNow the \\uD83D\\uDD25VALIDITY\\uD83D\\uDD25 of Partition is when l1<=r2 and l2<=r1\\n\\n       \\t- Agar aisa hua to hame hamara merged array mil gaya nahin to aur even \\n       \\todd ke hisab se median nikal lenge.\\n\\n       \\t- if(l1>r2) to high=cut1-1(Hame L1 mein number ghatane padenge)\\n\\n       \\t- if(l2>r1) to low=cut1+1(Matlan cut2 kam hoga means L2 se number ghatayenge).\\n\\n       \\t- Aur fir dobara ghumenge loop mein.\\n\\n       \\t- TC: O(log(min(m,n)))\\n//------------------------------------------------------------------------------------------------\\n        double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2)\\n        {\\n            int n = nums1.size();\\n            int m = nums2.size();\\n            if (m < n)\\n                return findMedianSortedArrays(nums2, nums1);\\n           \\t//Shortest Array finding\\n            int medianPos = (n + m + 1) / 2;\\n           \\t//Median Pos in merged array\\n            int low = 0;\\n           \\t//low of shortest array\\n            int high = n;\\n           \\t//high of shortest array\\n            while (low <= high)\\n            {\\n                int cut1 = (low + high) / 2;\\n               \\t//L1 array - 0 to cut1,R1 array - cut1 to n\\n                int cut2 = medianPos - cut1;\\n               \\t//L2 array - 0 to cut2,R2 array - cut2 to m\\n\\n                int l1 = cut1 == 0 ? INT_MIN : nums1[cut1 - 1];\\n                int l2 = cut2 == 0 ? INT_MIN : nums2[cut2 - 1];\\n                int r1 = cut1 == n ? INT_MAX : nums1[cut1];\\n                int r2 = cut2 == m ? INT_MAX : nums2[cut2];\\n               \\t//Above are boundary values of L1,L2,R1,R2\\n               \\t//---------l1 r1--------\\n               \\t//---------l2 r2--------\\n\\n                if (l1 <= r2 && l2 <= r1)\\n               \\t//Validity of Partition\\n                {\\n                    if ((n + m) % 2 == 0)\\n                       \\t//Even no merged array\\n                        return (max(l1, l2) + min(r1, r2)) / 2.0;\\n                    else\\n                       \\t//Odd no merged array\\n                        return max(l1, l2);\\n                }\\n                else if (l1 > r2)\\n                   \\t//Invalid case\\n                    high = cut1 - 1;\\n               \\t//L1 ki boundary se piche jayenge\\n                else\\n                   \\t//L2 ki boundary se piche jayenge\\n                    low = cut1 + 1;\\n            }\\n            return 0.0;\\n        }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $O(log(min(m,n)))$ Binary Search on Shortest array.\\n\\n- Space complexity: $O(1)$\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n       \\tLOGIC\\n\\n       \\tAPPROACH-1(NAIVE)\\n       \\t1. Merge Sort\\u2753 (Kyoki hame 2 sorted array dikh gaye), Ab median kyoki hame merge karke hi milega.\\n       \\tO(M+N)\\n\\n       \\tAPPROACH-2(BINARY SEARCH)\\n\\n       \\t1.Why\\u2753 Sorted array se hame Binary Search strike karega.\\n\\n       \\t2.Ab isme Binary Search lagayenge kaise\\u2753\\n\\n       \\t3.We will partition both the arrays lets say Left part of both into L1,L2\\n       \\tand Right part of both into R1,R2.\\n\\n       \\t4.Left part and Right part se matlab?->Left part (L1+L2) wo hoga joki agar \\n       \\tmerge karte arrays ko to median ke left part wala hota aur Right part (R1+R2)\\n       \\tjo median ke right mein hota.\\n\\n       \\t5.Now main action of BINARY SEARCH \\uD83D\\uDE0E is \\uD83D\\uDD25PARTITIONING\\uD83D\\uDD25.\\n\\n       \\t6.Implement kaise karenge\\u2753\\n       \\t- We will do the Binary Search in the array having shortest size.\\n\\n       \\t- Why shortest\\u2753TC less hoga \\n\\n       \\t- median = (n+m+1)/2, low=0, high=n\\n\\n       \\t- PARTITION -> cut1 = (low+high)/2 {Pehle array ke kitne elem L1 mein honge}\\n       \\tcut2= median - cut1 {Dusre array ke kitne elem L2 mein honge}.\\n\\n       \\t- Ab L1,L2 ki border values jo ki median ke just left = l1,l2 and R1,R2 ki \\n       \\tborder values jo ki median ke just right will r1,r2\\n\\n       \\tAb sara khel inhi ka hain\\n\\n       \\t- If cut1!=0 take l1=nums1[cut1-1],cut2!=0 l2=nums2[cut2-1],cut1!=n \\n       \\tr1=nums1[cut1],cut2!=m r2=nums2[cut2].\\n\\n       \\tNow the \\uD83D\\uDD25VALIDITY\\uD83D\\uDD25 of Partition is when l1<=r2 and l2<=r1\\n\\n       \\t- Agar aisa hua to hame hamara merged array mil gaya nahin to aur even \\n       \\todd ke hisab se median nikal lenge.\\n\\n       \\t- if(l1>r2) to high=cut1-1(Hame L1 mein number ghatane padenge)\\n\\n       \\t- if(l2>r1) to low=cut1+1(Matlan cut2 kam hoga means L2 se number ghatayenge).\\n\\n       \\t- Aur fir dobara ghumenge loop mein.\\n\\n       \\t- TC: O(log(min(m,n)))\\n//------------------------------------------------------------------------------------------------\\n        double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2)\\n        {\\n            int n = nums1.size();\\n            int m = nums2.size();\\n            if (m < n)\\n                return findMedianSortedArrays(nums2, nums1);\\n           \\t//Shortest Array finding\\n            int medianPos = (n + m + 1) / 2;\\n           \\t//Median Pos in merged array\\n            int low = 0;\\n           \\t//low of shortest array\\n            int high = n;\\n           \\t//high of shortest array\\n            while (low <= high)\\n            {\\n                int cut1 = (low + high) / 2;\\n               \\t//L1 array - 0 to cut1,R1 array - cut1 to n\\n                int cut2 = medianPos - cut1;\\n               \\t//L2 array - 0 to cut2,R2 array - cut2 to m\\n\\n                int l1 = cut1 == 0 ? INT_MIN : nums1[cut1 - 1];\\n                int l2 = cut2 == 0 ? INT_MIN : nums2[cut2 - 1];\\n                int r1 = cut1 == n ? INT_MAX : nums1[cut1];\\n                int r2 = cut2 == m ? INT_MAX : nums2[cut2];\\n               \\t//Above are boundary values of L1,L2,R1,R2\\n               \\t//---------l1 r1--------\\n               \\t//---------l2 r2--------\\n\\n                if (l1 <= r2 && l2 <= r1)\\n               \\t//Validity of Partition\\n                {\\n                    if ((n + m) % 2 == 0)\\n                       \\t//Even no merged array\\n                        return (max(l1, l2) + min(r1, r2)) / 2.0;\\n                    else\\n                       \\t//Odd no merged array\\n                        return max(l1, l2);\\n                }\\n                else if (l1 > r2)\\n                   \\t//Invalid case\\n                    high = cut1 - 1;\\n               \\t//L1 ki boundary se piche jayenge\\n                else\\n                   \\t//L2 ki boundary se piche jayenge\\n                    low = cut1 + 1;\\n            }\\n            return 0.0;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284038,
                "title": "simplest-python-solution-with-simplest-explanation-log-m-n",
                "content": "First we decompose this problem into simpler subproblems:\\n1. Find a given index `idx` in a sorted `a+b` array. Let `len(a)=m`, `len(b)=n`, `l=m+n`. Having solution to this problem we can easily compute median as we just need to find: \\na) `idx=l // 2` when `l` is odd as this is median index in odd length array \\n\\te.g. `[1,2,3], l = 3, idx = l//2 = 1`\\nb) `idx=l//2` and `idx=l//2-1` when `l` is even as these are median indices in this case \\n\\t\\te.g. `[1,2,3,4], l = 4, idx1 = l//2 = 2, idx2 = l//2-1 = 1`\\n\\t\\n\\t\\tdef findMedianSortedArrays(self, a, b):\\n\\n\\t\\t\\tl = len(a) + len(b)\\n\\n\\t\\t\\tif l % 2:\\n\\t\\t\\t\\treturn self.get_median(a, b, l // 2)\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn (self.get_median(a, b, l // 2) + self.get_median(a, b, l // 2 - 1))  / 2\\n\\t\\t\\n2. Find recursively value at `idx` in `a+b` by cutting off part of `a` or `b` where `idx` is surely not present. \\na) We take two indices `ai = len(a)//2` in array `a` and `bi = len(b)//2` in array `b`. They roughly cut both arrays in half which will lead to `log(m+n)` time complexity. Denoting `ma = a[ai]` and `mb = b[bi]` the two arrays look like:\\n\\n\\t\\ta=[????? ma *****]\\n\\t\\tb=[........ mb ######]\\n\\n\\t  where `?`,  `.`, `*` and `#` just visualize elements we do not know. \\n\\t b) We know the values `ma` and `mb`. Not to consider many sub-scenarios we make it so that `ma <= mb` i.e. \\n\\n\\t\\t if ma > mb:\\n\\t\\t\\tma, mb = mb, ma\\n\\t\\t\\tai, bi = bi, ai\\n\\t\\t\\ta, b = b, a\\n\\n\\t Thanks to this simplification we will always be able to either cut off beginning of array `a` or end of array `b` as will be explained below.\\n\\t \\n\\tc) Now the rough visualization of combined array is:\\n\\t\\n\\t\\ta+b=[&&&&&& ma &&&& mb &&&&&&]\\n\\t\\t\\t\\n\\tWhere `&` is composed of  `?`,  `.`, `*` and `#` in some way. How exactly we cannot say but we can at least place them with respect to `ma` and `mb`: \\n\\t\\n\\t\\ta+b=[.??.?.?.?? ma **.*.**.. mb ##*##**#*#]\\n\\t\\t\\n\\tNotice that we have three parts here: `.??.?.?.??`, `**.*.**..` and `##*##**#*#`.\\n\\t\\n\\td) Now what can be the maximum possible index of `ma` in `a+b` array? This is if all `.` were to the left of `ma` i.e.\\n\\t\\n\\t\\ta+b=[.??.?.?.?? ma ***** mb ##*##**#*#]\\n\\t\\n\\tthen `len(?????) = len(a)//2`,   `len(......) = len(b)//2` so\\n\\t`max_idx_ma = len(a) // 2 + len(b) // 2`\\n\\t\\n\\te) Now if `max_idx_ma < idx` then we know that index we are looking for is surely not located among `?????? ma` i.e. left part of array `a` because it is located in \\n\\t`***** mb ##*##**#*#` part of array a+b. So we can just cut this part off and repeat the reasoning in `2.` on `a[ai+1:]`, `b`, `idx - (len(??????) + 1) = idx - (len(a)//2 + 1)` (`+1` because we also throw out `ma`).\\n\\t\\n\\tf) Else we know that `max_idx_ma >= idx`. In other words in `a+b` array\\n\\t\\n\\t\\ta+b=[.??.?.?.?? ma ***** mb ##*##**#*#]\\n\\t\\n\\t `idx` is located in `.??.?.?.?? ma` part. Whatever the length of `*****` because `ma` and `mb` are two different elements in a sorted array `a+b` and `ma <= mb`:\\n\\t \\n\\t\\tmax_idx_ma  < min_idx_mb\\n\\t \\n\\t and\\n\\t \\n\\t\\tidx <= max_idx_ma  < min_idx_mb\\n\\t \\n\\t which means that we can throw away `mb ######` part of `b` array in this case and consider new problem on `a`, `b[:bi]`, `idx`. \\n\\t \\nRemarks:\\n1. Without simplification in `1.` we need to be looking for two indices and considering total lenght of the array which greatly complicates solution. \\n2. Without simplification in `2. b)` we would need to consider 4 subcases depending on relative values of `ma` and `mb`.\\n3. A very important point is that we throw out `ma` or `mb` every time we cut off. This way we make sure that we always throw out at leas one element making it possible to reach the point where either `a` is empty or `b` is empty.\\n\\nTime complexity:\\n\\nWe always cut off half of `a` or half of `b`. Therefore it will take `O(log(m) + log(n))` to cut to zero.\\n\\n\\tO(log(m) + log(n)) <= O(log(max(m, n)) + log(max(m, n))) = O(log(max(m, n))) <= O(log(m+n))\\n\\nFull code:\\n\\t\\n\\t\\tclass Solution:     \\n\\t\\t\\tdef findMedianSortedArrays(self, a, b):\\n\\n\\t\\t\\t\\tl = len(a) + len(b)\\n\\n\\t\\t\\t\\tif l % 2:\\n\\t\\t\\t\\t\\treturn self.get_median(a, b, l // 2)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn (self.get_median(a, b, l // 2) + self.get_median(a, b, l // 2 - 1))  / 2\\n\\n\\t\\t\\tdef get_median(self, a, b, idx):\\n\\n\\t\\t\\t\\tif not a:\\n\\t\\t\\t\\t\\treturn b[idx]\\n\\t\\t\\t\\tif not b:\\n\\t\\t\\t\\t\\treturn a[idx]\\n\\n\\t\\t\\t\\tai = len(a) // 2\\n\\t\\t\\t\\tbi = len(b) // 2\\n\\t\\t\\t\\tma = a[ai]\\n\\t\\t\\t\\tmb = b[bi]\\n\\n\\t\\t\\t\\tif ma > mb:\\n\\t\\t\\t\\t\\tma, mb = mb, ma\\n\\t\\t\\t\\t\\tai, bi = bi, ai\\n\\t\\t\\t\\t\\ta, b = b, a\\n\\n\\t\\t\\t\\tmax_idx_ma = len(a) // 2 + len(b) // 2\\n\\n\\t\\t\\t\\tif max_idx_ma < idx:\\n\\t\\t\\t\\t\\tmed = self.get_median(a[ai+1:], b, idx - (len(a)//2+1))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# max_idx_ma < min_idx_mb (because they are different numbers) \\n\\t\\t\\t\\t\\t# => idx <= max_idx_ma <  min_idx_mb => idx < min_idx_mb\\n\\t\\t\\t\\t\\tmed = self.get_median(a, b[:bi], idx)\\n\\n\\t\\t\\t\\treturn med",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "First we decompose this problem into simpler subproblems:\\n1. Find a given index `idx` in a sorted `a+b` array. Let `len(a)=m`, `len(b)=n`, `l=m+n`. Having solution to this problem we can easily compute median as we just need to find: \\na) `idx=l // 2` when `l` is odd as this is median index in odd length array \\n\\te.g. `[1,2,3], l = 3, idx = l//2 = 1`\\nb) `idx=l//2` and `idx=l//2-1` when `l` is even as these are median indices in this case \\n\\t\\te.g. `[1,2,3,4], l = 4, idx1 = l//2 = 2, idx2 = l//2-1 = 1`\\n\\t\\n\\t\\tdef findMedianSortedArrays(self, a, b):\\n\\n\\t\\t\\tl = len(a) + len(b)\\n\\n\\t\\t\\tif l % 2:\\n\\t\\t\\t\\treturn self.get_median(a, b, l // 2)\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn (self.get_median(a, b, l // 2) + self.get_median(a, b, l // 2 - 1))  / 2\\n\\t\\t\\n2. Find recursively value at `idx` in `a+b` by cutting off part of `a` or `b` where `idx` is surely not present. \\na) We take two indices `ai = len(a)//2` in array `a` and `bi = len(b)//2` in array `b`. They roughly cut both arrays in half which will lead to `log(m+n)` time complexity. Denoting `ma = a[ai]` and `mb = b[bi]` the two arrays look like:\\n\\n\\t\\ta=[????? ma *****]\\n\\t\\tb=[........ mb ######]\\n\\n\\t  where `?`,  `.`, `*` and `#` just visualize elements we do not know. \\n\\t b) We know the values `ma` and `mb`. Not to consider many sub-scenarios we make it so that `ma <= mb` i.e. \\n\\n\\t\\t if ma > mb:\\n\\t\\t\\tma, mb = mb, ma\\n\\t\\t\\tai, bi = bi, ai\\n\\t\\t\\ta, b = b, a\\n\\n\\t Thanks to this simplification we will always be able to either cut off beginning of array `a` or end of array `b` as will be explained below.\\n\\t \\n\\tc) Now the rough visualization of combined array is:\\n\\t\\n\\t\\ta+b=[&&&&&& ma &&&& mb &&&&&&]\\n\\t\\t\\t\\n\\tWhere `&` is composed of  `?`,  `.`, `*` and `#` in some way. How exactly we cannot say but we can at least place them with respect to `ma` and `mb`: \\n\\t\\n\\t\\ta+b=[.??.?.?.?? ma **.*.**.. mb ##*##**#*#]\\n\\t\\t\\n\\tNotice that we have three parts here: `.??.?.?.??`, `**.*.**..` and `##*##**#*#`.\\n\\t\\n\\td) Now what can be the maximum possible index of `ma` in `a+b` array? This is if all `.` were to the left of `ma` i.e.\\n\\t\\n\\t\\ta+b=[.??.?.?.?? ma ***** mb ##*##**#*#]\\n\\t\\n\\tthen `len(?????) = len(a)//2`,   `len(......) = len(b)//2` so\\n\\t`max_idx_ma = len(a) // 2 + len(b) // 2`\\n\\t\\n\\te) Now if `max_idx_ma < idx` then we know that index we are looking for is surely not located among `?????? ma` i.e. left part of array `a` because it is located in \\n\\t`***** mb ##*##**#*#` part of array a+b. So we can just cut this part off and repeat the reasoning in `2.` on `a[ai+1:]`, `b`, `idx - (len(??????) + 1) = idx - (len(a)//2 + 1)` (`+1` because we also throw out `ma`).\\n\\t\\n\\tf) Else we know that `max_idx_ma >= idx`. In other words in `a+b` array\\n\\t\\n\\t\\ta+b=[.??.?.?.?? ma ***** mb ##*##**#*#]\\n\\t\\n\\t `idx` is located in `.??.?.?.?? ma` part. Whatever the length of `*****` because `ma` and `mb` are two different elements in a sorted array `a+b` and `ma <= mb`:\\n\\t \\n\\t\\tmax_idx_ma  < min_idx_mb\\n\\t \\n\\t and\\n\\t \\n\\t\\tidx <= max_idx_ma  < min_idx_mb\\n\\t \\n\\t which means that we can throw away `mb ######` part of `b` array in this case and consider new problem on `a`, `b[:bi]`, `idx`. \\n\\t \\nRemarks:\\n1. Without simplification in `1.` we need to be looking for two indices and considering total lenght of the array which greatly complicates solution. \\n2. Without simplification in `2. b)` we would need to consider 4 subcases depending on relative values of `ma` and `mb`.\\n3. A very important point is that we throw out `ma` or `mb` every time we cut off. This way we make sure that we always throw out at leas one element making it possible to reach the point where either `a` is empty or `b` is empty.\\n\\nTime complexity:\\n\\nWe always cut off half of `a` or half of `b`. Therefore it will take `O(log(m) + log(n))` to cut to zero.\\n\\n\\tO(log(m) + log(n)) <= O(log(max(m, n)) + log(max(m, n))) = O(log(max(m, n))) <= O(log(m+n))\\n\\nFull code:\\n\\t\\n\\t\\tclass Solution:     \\n\\t\\t\\tdef findMedianSortedArrays(self, a, b):\\n\\n\\t\\t\\t\\tl = len(a) + len(b)\\n\\n\\t\\t\\t\\tif l % 2:\\n\\t\\t\\t\\t\\treturn self.get_median(a, b, l // 2)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn (self.get_median(a, b, l // 2) + self.get_median(a, b, l // 2 - 1))  / 2\\n\\n\\t\\t\\tdef get_median(self, a, b, idx):\\n\\n\\t\\t\\t\\tif not a:\\n\\t\\t\\t\\t\\treturn b[idx]\\n\\t\\t\\t\\tif not b:\\n\\t\\t\\t\\t\\treturn a[idx]\\n\\n\\t\\t\\t\\tai = len(a) // 2\\n\\t\\t\\t\\tbi = len(b) // 2\\n\\t\\t\\t\\tma = a[ai]\\n\\t\\t\\t\\tmb = b[bi]\\n\\n\\t\\t\\t\\tif ma > mb:\\n\\t\\t\\t\\t\\tma, mb = mb, ma\\n\\t\\t\\t\\t\\tai, bi = bi, ai\\n\\t\\t\\t\\t\\ta, b = b, a\\n\\n\\t\\t\\t\\tmax_idx_ma = len(a) // 2 + len(b) // 2\\n\\n\\t\\t\\t\\tif max_idx_ma < idx:\\n\\t\\t\\t\\t\\tmed = self.get_median(a[ai+1:], b, idx - (len(a)//2+1))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# max_idx_ma < min_idx_mb (because they are different numbers) \\n\\t\\t\\t\\t\\t# => idx <= max_idx_ma <  min_idx_mb => idx < min_idx_mb\\n\\t\\t\\t\\t\\tmed = self.get_median(a, b[:bi], idx)\\n\\n\\t\\t\\t\\treturn med",
                "codeTag": "Java"
            },
            {
                "id": 1310651,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if ((nums1.size() + nums2.size()) % 2 == 1) {\\n            return findKthInTwoSortedArrays(nums1, nums2, (nums1.size() + nums2.size()) / 2 + 1);\\n        } else {\\n            return (findKthInTwoSortedArrays(nums1, nums2, (nums1.size() + nums2.size()) / 2) +\\n                    findKthInTwoSortedArrays(nums1, nums2, (nums1.size() + nums2.size()) / 2 + 1)) / 2.0;\\n        }\\n    }\\n\\n    int findKthInTwoSortedArrays(const vector<int>& A, const vector<int>& B,\\n                                 int k) {\\n        const int m = A.size();\\n        const int n = B.size();\\n\\n        // Make sure m is the smaller one.\\n        if (m > n) {\\n            return findKthInTwoSortedArrays(B, A, k);\\n        }\\n\\n        int left = 0;\\n        int right = m;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (0 <= k - 1 - mid && k - 1 - mid < n && A[mid] >= B[k - 1 - mid]) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        int Ai_minus_1 = left - 1 >= 0 ? A[left - 1] : numeric_limits<int>::min();\\n        int Bj = k - 1 - left >= 0 ? B[k - 1 - left] : numeric_limits<int>::min();\\n\\n        return max(Ai_minus_1, Bj);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if ((nums1.size() + nums2.size()) % 2 == 1) {\\n            return findKthInTwoSortedArrays(nums1, nums2, (nums1.size() + nums2.size()) / 2 + 1);\\n        } else {\\n            return (findKthInTwoSortedArrays(nums1, nums2, (nums1.size() + nums2.size()) / 2) +\\n                    findKthInTwoSortedArrays(nums1, nums2, (nums1.size() + nums2.size()) / 2 + 1)) / 2.0;\\n        }\\n    }\\n\\n    int findKthInTwoSortedArrays(const vector<int>& A, const vector<int>& B,\\n                                 int k) {\\n        const int m = A.size();\\n        const int n = B.size();\\n\\n        // Make sure m is the smaller one.\\n        if (m > n) {\\n            return findKthInTwoSortedArrays(B, A, k);\\n        }\\n\\n        int left = 0;\\n        int right = m;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (0 <= k - 1 - mid && k - 1 - mid < n && A[mid] >= B[k - 1 - mid]) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        int Ai_minus_1 = left - 1 >= 0 ? A[left - 1] : numeric_limits<int>::min();\\n        int Bj = k - 1 - left >= 0 ? B[k - 1 - left] : numeric_limits<int>::min();\\n\\n        return max(Ai_minus_1, Bj);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479,
                "title": "java-easy-version-to-understand",
                "content": "    public static int findKthSmallest(int[] a, int m, int begin1, int[] b, int n, int begin2, int k) {\\n\\n\\t\\tif (m > n)\\n\\t\\t\\treturn findKthSmallest(b, n, begin2, a, m, begin1, k);\\n\\t\\tif (m == 0)\\n\\t\\t\\treturn b[begin2 + k - 1];\\n\\t\\tif (k == 1)\\n\\t\\t\\treturn Integer.min(a[begin1], b[begin2]);\\n\\t\\tint partA = Integer.min(k / 2, m), partB = k - partA;\\n\\t\\tif (a[begin1 + partA - 1] == b[begin2 + partB - 1])\\n\\t\\t\\treturn a[begin1 + partA - 1];\\n\\t\\telse if (a[begin1 + partA - 1] > b[begin2 + partB - 1])\\n\\t\\t\\treturn findKthSmallest(a, m, begin1, b, n - partB, begin2 + partB, k - partB);\\n\\t\\telse\\n\\t\\t\\treturn findKthSmallest(a, m - partA, begin1 + partA, b, n, begin2, k - partA);\\n\\n\\t}\\n\\n\\tpublic static double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n\\t\\tint len1 = nums1.length, len2 = nums2.length, sumLen = len1 + len2;\\n\\t\\tif (sumLen % 2 != 0) {\\n\\n\\t\\t\\treturn findKthSmallest(nums1, len1, 0, nums2, len2, 0, sumLen / 2 + 1);\\n\\t\\t} else {\\n\\t\\t\\treturn (findKthSmallest(nums1, len1, 0, nums2, len2, 0, sumLen / 2)\\n\\t\\t\\t\\t\\t+ findKthSmallest(nums1, len1, 0, nums2, len2, 0, sumLen / 2 + 1)) / 2.0;\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [],
                "code": "    public static int findKthSmallest(int[] a, int m, int begin1, int[] b, int n, int begin2, int k) {\\n\\n\\t\\tif (m > n)\\n\\t\\t\\treturn findKthSmallest(b, n, begin2, a, m, begin1, k);\\n\\t\\tif (m == 0)\\n\\t\\t\\treturn b[begin2 + k - 1];\\n\\t\\tif (k == 1)\\n\\t\\t\\treturn Integer.min(a[begin1], b[begin2]);\\n\\t\\tint partA = Integer.min(k / 2, m), partB = k - partA;\\n\\t\\tif (a[begin1 + partA - 1] == b[begin2 + partB - 1])\\n\\t\\t\\treturn a[begin1 + partA - 1];\\n\\t\\telse if (a[begin1 + partA - 1] > b[begin2 + partB - 1])\\n\\t\\t\\treturn findKthSmallest(a, m, begin1, b, n - partB, begin2 + partB, k - partB);\\n\\t\\telse\\n\\t\\t\\treturn findKthSmallest(a, m - partA, begin1 + partA, b, n, begin2, k - partA);\\n\\n\\t}\\n\\n\\tpublic static double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n\\t\\tint len1 = nums1.length, len2 = nums2.length, sumLen = len1 + len2;\\n\\t\\tif (sumLen % 2 != 0) {\\n\\n\\t\\t\\treturn findKthSmallest(nums1, len1, 0, nums2, len2, 0, sumLen / 2 + 1);\\n\\t\\t} else {\\n\\t\\t\\treturn (findKthSmallest(nums1, len1, 0, nums2, len2, 0, sumLen / 2)\\n\\t\\t\\t\\t\\t+ findKthSmallest(nums1, len1, 0, nums2, len2, 0, sumLen / 2 + 1)) / 2.0;\\n\\t\\t}\\n\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1669917,
                "title": "c-solution-with-detailed-explanation",
                "content": "# **Intitution:**\\nMedian divides the total elements in two equal halves so if we merge two arrays middle element would be the median. But this will require O(m+n) extra space. But this approach can be optimised to work in const space by observing the fact that while merging the array we are only concerned with border elements of the arrays since arrays are already sorted.\\nSo, we need to find out the number of elements to be picked up from first array that will come before the median and number of elements from second array that will come in prefix subarray of the median can be calculated as total elements/2 - no. of selected elements from first array. Also, while calculating median we need the value of two middle elements (in case of even number of elements) or just a single middle element (in case of odd number of elements). So, we will keep the track of these values while performing binary search.\\n**Note:** Compare cross elements while merging i.e. left value of one array with right value of other array since arrays are already sorted so left values will be always less than right values of its own array.\\n# **Algorithm:**\\n1. Initialize variables : l=0 and r=m (size of smaller array)\\n2. Iterate till condition l<=r evaluates to be true\\n3. Make a partition at the middle of the range and pick up the elements before the partition from first array (say fir).\\n4. Now take the remaining elements from the second array (say sec).\\n5. Find the values of border elements of the range of elements taken from both the arrays:\\n*  l1=leftmost element taken from first array\\n*  l2=leftmost element taken from second array\\n*  r1=rightmost element taken from first array\\n*  r2=rightmost element taken from second array\\n6. Now compare the cross elements to ensure sorting order of the elements (l1<=r2 && l2 <=r1). If condition evaluates to be true and total number of elements in both the arrays is even then median =(max(l1, l2) +min(r1, r2))/2 else, median = max(l1, l2)\\n7. If l1>r2 then reduce right limit to fir-1\\n8. Else, increament left limit to fir+1\\n# **Code:**\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int m = nums1.size();\\n        int n = nums2.size();\\n        \\n        if(m > n)\\n        {\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        int l=0, r= m;\\n        int total = m+n+1;\\n        \\n        while(l<=r)\\n        {\\n            int fir = l + (r-l)/2;\\n            int sec = total/2 - fir;\\n            \\n            int l1=INT_MIN, l2=INT_MIN;\\n            int r1=INT_MAX, r2=INT_MAX;\\n            \\n            if(fir > 0)\\n            {\\n                l1 = nums1[fir-1];\\n            }\\n            if(sec>0)\\n            {\\n                l2 = nums2[sec-1];\\n            }\\n            if((fir>=0) && (fir<m))\\n            {\\n                r1 = nums1[fir];\\n            }\\n            if((sec>=0) && (sec<n))\\n            {\\n                r2 = nums2[sec];\\n            }\\n            \\n            if(l1<=r2 && l2<=r1)\\n            {\\n                if((n+m)%2 == 0)\\n                {\\n                    return (max(l1, l2)+min(r1, r2))/2.0;\\n                    \\n                }\\n                else\\n                {\\n                    return max(l1, l2);\\n                }\\n            }\\n            else if(l1> r2)\\n            {\\n                r = fir-1;\\n            }\\n            else\\n            {\\n                l = fir+1;\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```\\n# **Time Complexity:**\\nO(log(min(m, n))\\n# **Space Complexity:**\\nO(1)",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int m = nums1.size();\\n        int n = nums2.size();\\n        \\n        if(m > n)\\n        {\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        int l=0, r= m;\\n        int total = m+n+1;\\n        \\n        while(l<=r)\\n        {\\n            int fir = l + (r-l)/2;\\n            int sec = total/2 - fir;\\n            \\n            int l1=INT_MIN, l2=INT_MIN;\\n            int r1=INT_MAX, r2=INT_MAX;\\n            \\n            if(fir > 0)\\n            {\\n                l1 = nums1[fir-1];\\n            }\\n            if(sec>0)\\n            {\\n                l2 = nums2[sec-1];\\n            }\\n            if((fir>=0) && (fir<m))\\n            {\\n                r1 = nums1[fir];\\n            }\\n            if((sec>=0) && (sec<n))\\n            {\\n                r2 = nums2[sec];\\n            }\\n            \\n            if(l1<=r2 && l2<=r1)\\n            {\\n                if((n+m)%2 == 0)\\n                {\\n                    return (max(l1, l2)+min(r1, r2))/2.0;\\n                    \\n                }\\n                else\\n                {\\n                    return max(l1, l2);\\n                }\\n            }\\n            else if(l1> r2)\\n            {\\n                r = fir-1;\\n            }\\n            else\\n            {\\n                l = fir+1;\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188312,
                "title": "fast-javascript",
                "content": "Fast JavaScript Solution.\\n```\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n  let totalLen = nums1.length + nums2.length;\\n  let idx1 = 0;\\n  let idx2 = 0;\\n  let curr;\\n  let last;\\n\\n  while (idx1 + idx2 <= totalLen/2) {\\n    if (curr) {\\n      last = curr;\\n    }\\n    let elOne = nums1[idx1];\\n    let elTwo = nums2[idx2];\\n    if (elOne === undefined) {\\n      curr = elTwo;\\n      idx2++;\\n    } else if (elTwo === undefined) {\\n      curr = elOne;\\n      idx1++;\\n    } else if (elOne < elTwo) {\\n      curr = elOne;\\n      idx1++;\\n    } else {\\n      curr = elTwo;\\n      idx2++;\\n    }\\n  }\\n  return totalLen % 2 === 0 ? (last + curr) / 2 : curr;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n  let totalLen = nums1.length + nums2.length;\\n  let idx1 = 0;\\n  let idx2 = 0;\\n  let curr;\\n  let last;\\n\\n  while (idx1 + idx2 <= totalLen/2) {\\n    if (curr) {\\n      last = curr;\\n    }\\n    let elOne = nums1[idx1];\\n    let elTwo = nums2[idx2];\\n    if (elOne === undefined) {\\n      curr = elTwo;\\n      idx2++;\\n    } else if (elTwo === undefined) {\\n      curr = elOne;\\n      idx1++;\\n    } else if (elOne < elTwo) {\\n      curr = elOne;\\n      idx1++;\\n    } else {\\n      curr = elTwo;\\n      idx2++;\\n    }\\n  }\\n  return totalLen % 2 === 0 ? (last + curr) / 2 : curr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174195,
                "title": "c-python-o-log-m-n-solution",
                "content": "Good question. Took me a while with bit of a hint to solve this question.\\nHere I\\'ve considered the median in my list for checking the conditions.\\nNote- When la + lb == target what it actually means is that no. of elements in a and b inlcuding median is greater than tar as la and lb are indexes not count of elements. Hence its recursion is same as under the condition la + lb > tar.\\n1. C++\\n```\\nclass Solution {\\npublic:\\n    double median(vector<int>& a, vector<int>& b, int s1, int e1, int s2, int e2, int tar){\\n        int la, lb, ma, mb, m = max(e1 - s1 + 1,0), n = max(e2 - s2 + 1,0), ans;\\n        if(!m)\\n            return b[s2 + tar];\\n        if(!n)\\n            return a[s1 + tar];\\n        \\n        la = m/2;\\n        lb = n/2;\\n        ma = a[s1 + la];\\n        mb = b[s2 + lb];\\n        \\n        if (la + lb >= tar){\\n            if (ma > mb)\\n                ans = median(a,b,s1,s1 + la - 1,s2,e2,tar);\\n            else\\n                ans = median(a,b,s1,e1,s2,s2 + lb - 1,tar);\\n        }\\n        else{\\n            if (ma > mb)\\n                ans = median(a,b,s1,e1,s2 + lb + 1,e2,tar - lb - 1);\\n            else\\n                ans = median(a,b,s1 + la + 1,e1,s2,e2,tar - la - 1);\\n        }\\n        return ans;\\n    }\\n    \\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size(), n = nums2.size();\\n\\n        if (!m)\\n            return n & 1 ? nums2[n / 2] : (nums2[n / 2 - 1] + nums2[n / 2]) / 2.0;\\n        if (!n)\\n            return m & 1 ? nums1[m / 2] : (nums1[m / 2 - 1] + nums1[m / 2]) / 2.0;\\n        \\n        if ((m + n) & 1)\\n            return median(nums1,nums2,0,m-1,0,n-1,(m + n) / 2);\\n        \\n        return (median(nums1,nums2,0,m-1,0,n-1,(m + n) / 2 - 1) + median(nums1,nums2,0,m-1,0,n-1,(m + n) / 2))/2.0;\\n    }\\n};\\n```\\n2. Python\\n```\\nclass Solution:\\n    def findkth(self, a: List[int], b: List[int], target) -> int:\\n        # print(\"a: {}, b:{}\".format(a, b))\\n        n, m = len(a), len(b)\\n        if n <= 0:\\n            return b[target - 1]\\n        if m <= 0:\\n            return a[target - 1]\\n        med_a, med_b = n // 2 + 1, m // 2 + 1\\n        ma, mb = a[n // 2], b[m // 2]\\n        \\n        if med_a + med_b > target:\\n            if ma > mb:\\n                return self.findkth(a[:med_a - 1], b, target)\\n            else:\\n                return self.findkth(a, b[:med_b - 1], target)\\n        else:\\n            if ma > mb:\\n                return self.findkth(a, b[med_b:], target - med_b)\\n            else:\\n                return self.findkth(a[med_a:], b, target - med_a)\\n        \\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        n, m = len(nums1), len(nums2)\\n        if n == 0 :\\n            if m % 2 == 0:\\n                return (nums2[m // 2 - 1] + nums2[m // 2]) / 2\\n            else:\\n                return nums2[m // 2]\\n        if m == 0 :\\n            if n % 2 == 0:\\n                return (nums1[n // 2 - 1] + nums1[n // 2]) / 2\\n            else:\\n                return nums1[n // 2]\\n        if (m + n) % 2 == 0:\\n            return (self.findkth(nums1, nums2, (m + n) // 2) + self.findkth(nums1, nums2, (m + n) // 2 + 1)) / 2\\n        return self.findkth(nums1, nums2, (m + n) // 2 + 1)\\n```\\n**PS : Please upvote if you like the solution.**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Divide and Conquer",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double median(vector<int>& a, vector<int>& b, int s1, int e1, int s2, int e2, int tar){\\n        int la, lb, ma, mb, m = max(e1 - s1 + 1,0), n = max(e2 - s2 + 1,0), ans;\\n        if(!m)\\n            return b[s2 + tar];\\n        if(!n)\\n            return a[s1 + tar];\\n        \\n        la = m/2;\\n        lb = n/2;\\n        ma = a[s1 + la];\\n        mb = b[s2 + lb];\\n        \\n        if (la + lb >= tar){\\n            if (ma > mb)\\n                ans = median(a,b,s1,s1 + la - 1,s2,e2,tar);\\n            else\\n                ans = median(a,b,s1,e1,s2,s2 + lb - 1,tar);\\n        }\\n        else{\\n            if (ma > mb)\\n                ans = median(a,b,s1,e1,s2 + lb + 1,e2,tar - lb - 1);\\n            else\\n                ans = median(a,b,s1 + la + 1,e1,s2,e2,tar - la - 1);\\n        }\\n        return ans;\\n    }\\n    \\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size(), n = nums2.size();\\n\\n        if (!m)\\n            return n & 1 ? nums2[n / 2] : (nums2[n / 2 - 1] + nums2[n / 2]) / 2.0;\\n        if (!n)\\n            return m & 1 ? nums1[m / 2] : (nums1[m / 2 - 1] + nums1[m / 2]) / 2.0;\\n        \\n        if ((m + n) & 1)\\n            return median(nums1,nums2,0,m-1,0,n-1,(m + n) / 2);\\n        \\n        return (median(nums1,nums2,0,m-1,0,n-1,(m + n) / 2 - 1) + median(nums1,nums2,0,m-1,0,n-1,(m + n) / 2))/2.0;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findkth(self, a: List[int], b: List[int], target) -> int:\\n        # print(\"a: {}, b:{}\".format(a, b))\\n        n, m = len(a), len(b)\\n        if n <= 0:\\n            return b[target - 1]\\n        if m <= 0:\\n            return a[target - 1]\\n        med_a, med_b = n // 2 + 1, m // 2 + 1\\n        ma, mb = a[n // 2], b[m // 2]\\n        \\n        if med_a + med_b > target:\\n            if ma > mb:\\n                return self.findkth(a[:med_a - 1], b, target)\\n            else:\\n                return self.findkth(a, b[:med_b - 1], target)\\n        else:\\n            if ma > mb:\\n                return self.findkth(a, b[med_b:], target - med_b)\\n            else:\\n                return self.findkth(a[med_a:], b, target - med_a)\\n        \\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        n, m = len(nums1), len(nums2)\\n        if n == 0 :\\n            if m % 2 == 0:\\n                return (nums2[m // 2 - 1] + nums2[m // 2]) / 2\\n            else:\\n                return nums2[m // 2]\\n        if m == 0 :\\n            if n % 2 == 0:\\n                return (nums1[n // 2 - 1] + nums1[n // 2]) / 2\\n            else:\\n                return nums1[n // 2]\\n        if (m + n) % 2 == 0:\\n            return (self.findkth(nums1, nums2, (m + n) // 2) + self.findkth(nums1, nums2, (m + n) // 2 + 1)) / 2\\n        return self.findkth(nums1, nums2, (m + n) // 2 + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536552,
                "title": "c-100-fastest-solution-detailed-explanation-easy-understand",
                "content": "**Read the below approach to understand the logic.**\\n\\n***Please upvote if you like it***\\n\\n**Binary search Approach**\\n\\n**Intuition :**\\nWe will partition both the arrays in such a way that the left half of the partition will contain elements, which will be there when we merge them, till the median element and rest in the other right half. This partitioning of both arrays will be done by binary search.\\n\\n**Approach :**\\n\\nWe will do a binary search in one of the arrays which have a minimum size among the two. \\n\\nFirstly, calculate the median position with (n+1)/2. Point two-pointer, say low and high, equal to 0 and size of the array on which we are applying binary search respectively. Find the partition of the array. Check if the left half has a total number of elements equal to the median position. If not, get the remaining elements from the second array. Now, check if partitioning is valid. This is only when l1<=r2 and l2<=r1. If valid, return max(l1,l2)(when odd number of elements present) else return (max(l1,l2)+min(r1,r2))/2.\\n\\nIf partitioning is not valid, move ranges. When l1>r2, move left and perform the above operations again. When l2>r2, move right and perform the above operations.\\n\\n**~Time Complexity : O(log(min(m,n)))**\\n* **Reason \\u2013** We are applying binary search on the array which has a minimum size.\\n\\n**~Space Complexity: O(1)**\\n* **Reason \\u2013** No extra array is used.\\n\\n**Dry Run:-**\\n\\n![image](https://assets.leetcode.com/users/images/24e1bfdf-0874-444b-80c6-614e5609f9a3_1662406594.6715615.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        if(n2<n1) return findMedianSortedArrays(nums2,nums1);\\n        \\n        int low=0,high=n1;\\n        while(low<=high){\\n            int cut1=(high+low)/2;\\n            int cut2=(n1+n2+1)/2-cut1;\\n            \\n            int left1=cut1==0?INT_MIN:nums1[cut1-1];\\n            int left2=cut2==0?INT_MIN:nums2[cut2-1];\\n            \\n            int right1=cut1==n1?INT_MAX:nums1[cut1];\\n            int right2=cut2==n2?INT_MAX:nums2[cut2];\\n            \\n            if(left1<=right2 && left2<=right1){\\n                if((n1+n2)%2==0){\\n                    return (max(left1,left2)+min(right1,right2))/2.0;\\n                }else{\\n                    return max(left1,left2);\\n                }\\n            }else if(left1>right2){\\n                high=cut1-1;\\n            }else{\\n                low=cut1+1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        if(n2<n1) return findMedianSortedArrays(nums2,nums1);\\n        \\n        int low=0,high=n1;\\n        while(low<=high){\\n            int cut1=(high+low)/2;\\n            int cut2=(n1+n2+1)/2-cut1;\\n            \\n            int left1=cut1==0?INT_MIN:nums1[cut1-1];\\n            int left2=cut2==0?INT_MIN:nums2[cut2-1];\\n            \\n            int right1=cut1==n1?INT_MAX:nums1[cut1];\\n            int right2=cut2==n2?INT_MAX:nums2[cut2];\\n            \\n            if(left1<=right2 && left2<=right1){\\n                if((n1+n2)%2==0){\\n                    return (max(left1,left2)+min(right1,right2))/2.0;\\n                }else{\\n                    return max(left1,left2);\\n                }\\n            }else if(left1>right2){\\n                high=cut1-1;\\n            }else{\\n                low=cut1+1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142893,
                "title": "a-unique-log-m-log-n-approach-100-faster",
                "content": "Approach is very straightforward and easy to understand, please upvote if this solution helps. Please let me know in comment if the explanation/code can be improved.\\n\\n# Approach\\nLet\\'s say after merging the two arrays `num1` and `num2`, the final merged array gets one of the following form:\\n`[ a1, a2, a3, ... m1, b1, b2, b3, ..]` for odd length of merged array\\n`[ a1, a2, a3, ... m1, m2, b1, b2, b3, ..]` for even length of merged array\\n\\n-> Here `m1` and `m2` are the median of the merged array\\n-> The elements on left (`a1, a2, a3, ...`) are all smaller than or equal to `m1`\\n-> The elements on right (`b1, b2, b3, ..` or `m2, b1, b2, b3, ...`) are all greater than or equal to `m1`\\n-> The count of smaller elements `a1, a2, a3...` can be determined based on length of merged array by following formula, let\\'s store this count in a variable called `onLeft`:\\n```JAVA\\nonLeft = (int)( (mergedLength - 1) / 2 );\\n```\\n\\nNow to solve the problem, our first goal is to find the element `m1`\\n\\nThe approach is simple, to find `m1`, we perform a binary search in both of the arrays one by one. To check if the element that we are currently looking at is the median element `m1`, we count all of the elements which are smaller than the current element we are looking at, and we compare this count with our `onLeft` variable. If our count is equal to `onLeft`, this means current element is median `m1`.\\nDetermining the count of elements which are smaller then current element can take extra $$O(log(n))$$ time, however, with a small twist, we can do this in $$O(1)$$\\n\\nWe will perform this binary search in `num1` first. If `m1` is found, we stop our search and return answer, otherwise if `m1` is not found in `num1`, we perform same binary search in `num2`\\n\\n---\\n\\n\\nLet\\'s say during our binary search for `m1` in `num1`, we are currently looking at an element `e`\\n\\nNow to check if `e` is `m1`, we can follow two approach:\\n\\n**Approach 1:**\\nWe count the number of elements which are smaller than (or to the left of) `e`, this count can be determined in following steps:\\n\\n> 1. Determine position of `e` in `num1`. ($$O(1)$$)\\n> 2. Determine position of largest element in `num2` which is smaller then `e`. ($$O(log(n))$$)\\n> 3. If `position1` is position of `e` in `num1`, and `positoin2` is position of largest element in `num2` which is smaller than `e`, then\\n> Count of all elements smaller than `e` = position1 + position2 + 1; \\n\\nNow we will compare this count with `onLeft`, if our count is equal to `onLeft`, this means `e` is `m1`, we stop our search.\\n\\nAbove approach takes $$O(log(n))$$ time.\\n\\n**Approach 2:**\\nInstead of determining the count with the help of position of elements, we do the opposite, we determine the position of elements with the help of count:\\n> 1. Assume that the current element `e` is median `m1`, hence count of elements to the left of `e` is equal to `onLeft`\\n> 2. Based on this count, determine the position of largest element in `num2` which is smaller then `e` with following step:\\n> 3. If `position1` is position of `e` in `num1`, and `positoin2` is position of largest element in `num2` which is smaller than `e`, then\\n> position2 = `onLeft` - position1 - 1\\n\\nNow we will verify if the element at determined position (`position2`) is actually the largest element in `num2` which is smaller then `e`. If this happens to be true, then this means that the current element `e` is actually the median `m1`, we stop our search.\\n\\nAbove approach takes $$O(1)$$ time.\\n\\n(See [this very short example](https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3142893/a-unique-log-m-log-n-approach-100-faster/comments/1809970) in case you found it hard to understand the approach 2)\\n\\n---\\n\\nAfter finding `m1`, if the merged length is odd, we return this as answer, otherwise, we can easily get `m2` (the element to the right of `m1` in the merged array) in O(1) using the similar approach which is mentioned in **Approach 2** above, and return the average of `m1` and `m2`\\n\\n\\n# Complexity\\n- Time complexity: $$O(log(n) + log(m))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```JAVA\\nclass Solution {\\n    public double solve(int[] nums1, int[] nums2) {\\n        int totalLen = nums1.length + nums2.length;\\n        int onLeft = (totalLen - 1) / 2; //number of element to the left of median m1\\n        int start = 0;\\n        int end = nums1.length > onLeft ? onLeft : nums1.length - 1;\\n        //perform binary search in nums1 to find m1\\n        while (start <= end) {\\n            int mid = (start + end) / 2; //index of current element \\'e\\'\\n            boolean moveLeft = false; //to adjust binary search pointers later\\n            int leftIdx = onLeft - mid - 1; //index of largest element in nums2 which is smaller than the current element \\'e\\'\\n            if (leftIdx >= nums2.length) {\\n                //current element \\'e\\' is smaller than m1, need to move to the right\\n                moveLeft = false;\\n            }\\n            else if (\\n            (leftIdx == -1 || nums2[leftIdx] <= nums1[mid]) &&\\n            (leftIdx == (nums2.length - 1) || nums2[leftIdx + 1] >= nums1[mid])) {\\n                //current element \\'e\\' is median \\'m1\\' return the answer;\\n                if ((totalLen & 1) == 1) //odd length\\n                    return Double.valueOf(nums1[mid]);\\n                else {\\n                    //find \\'m2\\' (element to the right of \\'m1\\')\\n                    int el1 = (leftIdx + 1) < nums2.length ? nums2[leftIdx + 1] : Integer.MAX_VALUE; //smallest element greater than \\'e\\' in nums2\\n                    int el2 = (mid + 1) < nums1.length ? nums1[mid + 1] : Integer.MAX_VALUE; //smallest element greater than \\'e\\' in nums1\\n                    //m2 = Math.min(el1, el2)\\n                    return (nums1[mid] + Math.min(el1, el2)) / 2.0;\\n                }\\n            } else if (leftIdx == - 1 || nums2[leftIdx] < nums1[mid]) {\\n                //current element \\'e\\' is greater than m1, need to move to the left\\n                moveLeft = true;\\n            }\\n            \\n            if (moveLeft)\\n                if (end == mid)\\n                    break;\\n                else\\n                    end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n\\n        //Median \\'m1\\' not found in \\'nums1\\', it must be in \\'nums2\\'.\\n        //Search for \\'m1\\' in \\'nums2\\' and return answer\\n        return solve(nums2, nums1);\\n    }\\n    public double findMedianSortedArrays(int[] a1, int[] a2) {\\n        return solve(a1, a2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```JAVA\\nonLeft = (int)( (mergedLength - 1) / 2 );\\n```\n```JAVA\\nclass Solution {\\n    public double solve(int[] nums1, int[] nums2) {\\n        int totalLen = nums1.length + nums2.length;\\n        int onLeft = (totalLen - 1) / 2; //number of element to the left of median m1\\n        int start = 0;\\n        int end = nums1.length > onLeft ? onLeft : nums1.length - 1;\\n        //perform binary search in nums1 to find m1\\n        while (start <= end) {\\n            int mid = (start + end) / 2; //index of current element \\'e\\'\\n            boolean moveLeft = false; //to adjust binary search pointers later\\n            int leftIdx = onLeft - mid - 1; //index of largest element in nums2 which is smaller than the current element \\'e\\'\\n            if (leftIdx >= nums2.length) {\\n                //current element \\'e\\' is smaller than m1, need to move to the right\\n                moveLeft = false;\\n            }\\n            else if (\\n            (leftIdx == -1 || nums2[leftIdx] <= nums1[mid]) &&\\n            (leftIdx == (nums2.length - 1) || nums2[leftIdx + 1] >= nums1[mid])) {\\n                //current element \\'e\\' is median \\'m1\\' return the answer;\\n                if ((totalLen & 1) == 1) //odd length\\n                    return Double.valueOf(nums1[mid]);\\n                else {\\n                    //find \\'m2\\' (element to the right of \\'m1\\')\\n                    int el1 = (leftIdx + 1) < nums2.length ? nums2[leftIdx + 1] : Integer.MAX_VALUE; //smallest element greater than \\'e\\' in nums2\\n                    int el2 = (mid + 1) < nums1.length ? nums1[mid + 1] : Integer.MAX_VALUE; //smallest element greater than \\'e\\' in nums1\\n                    //m2 = Math.min(el1, el2)\\n                    return (nums1[mid] + Math.min(el1, el2)) / 2.0;\\n                }\\n            } else if (leftIdx == - 1 || nums2[leftIdx] < nums1[mid]) {\\n                //current element \\'e\\' is greater than m1, need to move to the left\\n                moveLeft = true;\\n            }\\n            \\n            if (moveLeft)\\n                if (end == mid)\\n                    break;\\n                else\\n                    end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n\\n        //Median \\'m1\\' not found in \\'nums1\\', it must be in \\'nums2\\'.\\n        //Search for \\'m1\\' in \\'nums2\\' and return answer\\n        return solve(nums2, nums1);\\n    }\\n    public double findMedianSortedArrays(int[] a1, int[] a2) {\\n        return solve(a1, a2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070428,
                "title": "100-two-solutions-two-pointers-divide-and-conquer-commented-code",
                "content": "# Problem Description\\nGiven two sorted arrays, `nums1` and `nums2`, each of sizes `M` and `N` respectively. The **goal** is to find the **median** of the **combined** array formed by merging `nums1` and `nums2`.\\n\\nThe **task** is to design an algorithm with an overall run time complexity of `O(log(min(m, n)))` to calculate the median of the combined sorted array.\\n\\n**The median** of an array is the **middle** element when the array is **sorted**. If the combined array has an even number of elements, the median is the **average** of the two middle elements.\\n\\n![image.png](https://assets.leetcode.com/users/images/3a8f6ac2-ad54-4fb4-a020-b5df18b6dbb4_1695259239.098474.png)\\n\\n\\n\\n---\\n\\n\\n# Intuition\\nHello There\\uD83D\\uDE00\\nLet\\'s take a look on our today\\'s interesting problem\\uD83D\\uDE80\\n\\nIn our today\\'s problem we have, two **sorted** arrays and a **median** to find but the **median** is for the array that **results** from **merging** both of the arrays.\\nSounds like a **neat** problem.\\uD83E\\uDD29\\n\\n## Two Pointers\\nThe **first** solution that would pop in mind is Why don\\'t we **merge** the two arrays.\\uD83E\\uDD14\\nWe can do this in **linear** time since the two arrays are **sorted** then we will have `2` pointer each of them on a **different** array from the other and put the **smaller** number in the **available** position in our **new** array.\\n![image.png](https://assets.leetcode.com/users/images/10266f12-45f6-41a0-87b6-7d8bbdd9e343_1695261379.3813884.png)\\n\\nThe **tricky** part here that this solution has **complexity** of `O(m + n)` and still get **accepted** although the problem said it wants an algorithm with `O(log(min(m, n)))`\\uD83E\\uDD2F\\nBut I had `100%` solution in **Java** with **Two Pointers** solution exactly like the next solution that I will discuss.\\n\\n\\n\\n## Divide And Conquer\\n\\n**Divide and Conquer** in a great technique in the world of computer science.\\uD83D\\uDE80\\nIt **shares** something important with **dynamic programming** that both of them **break** the problem into smaller **subproblems**.\\nThe **diffrenece** between the two approaches that the subproblems are **independent** in divide and conquer but in dynamic programming there is some **overlapping** between the subproblems.\\uD83E\\uDD2F\\n\\n- The **essence** of this solution that two things :\\n    - **drop** the part of the two arrays that we are sure that our median **won\\'t be in it**.\\n    - **choose** the median when one array has **no elements** in it.\\n\\nlet\\'s look at the **base case**, when we have one array is **empty**\\nif you have two arrays `a` , `b` and I told you to get the median of their merge like that:\\n```\\n-> a = [1, 4, 10]\\n-> b = []\\n\\n-> index median of a + b = 1\\n-> median of a + b = 4\\n``` \\nWe can note here that since `b` is empty then the median is in a with the same **index** we are searching for.\\uD83E\\uDD2F\\n\\nLet\\'s look at another example:\\n```\\n-> a = [1, 4, 10]\\n-> b = [2, 4, 7, 15]\\n-> index median of a + b = 3\\n-> mid of a = 1\\n-> mid of b = 2\\n```\\n```\\nnew a and b to search in:\\n-> a = [1, 4, 10]\\n-> b = [2, 4]\\n-> index median of a + b = 3\\n-> mid of a = 1\\n-> mid of b = 1\\n```\\n```\\nnew a and b to search in\\n-> a = [10]\\n-> b = [2, 4]\\n-> index median of a + b = 1\\n-> mid of a = 0\\n-> mid of b = 1\\n```\\n```\\nnew a and b to search in\\n-> a = []\\n-> b = [2, 4]\\n-> index median of a + b = 1\\n```\\nWow, we can see now we reached our **base** case that a is **empty** then the solution is the `1` **index** of our new array of b which is `4`.\\n\\nWe can see in the last example that we applied divide and conquer by **dropping** the **half** of the array that we are sure that our median won\\'t be inside it then recursively search in our new arrays until we reach our base case.\\uD83D\\uDE80\\n\\nAnd this is the solution for our today problem I hope that you understood it\\uD83D\\uDE80\\uD83D\\uDE80\\n\\n\\n---\\n# Approach\\n## 1. Two Pointers\\n1. **Create** a new array `mergedArray` with a size equal to the **sum** of the sizes of `nums1` and `nums2`.\\n2. **Initialize** two pointers `idxNums1` and `idxNums2` to `0`, representing the indices for `nums1` and `nums2`.\\n3. **Iterate** through mergedArray from `0` to its `size`.\\n    - **Compare** the elements pointed by `idxNums1` in `nums1` and `idxNums2` in `nums2`.\\n    - Place the **smaller** element in `mergedArray` and **increment** the respective pointer (`idxNums1` or `idxNums2`).\\n4. Check if the **size** of `mergedArray` is **odd** or **even**.\\n    - If **odd**, return the **middle** element of `mergedArray`.\\n    - If **even**, return the **average** of the two middle elements in `mergedArray`.\\n\\n## Complexity\\n- **Time complexity:** $$O(N + M)$$ \\nSince we are iterating over the big array which has size of `N + M`.\\n- **Space complexity:** $$O(N + M)$$\\nSince we are storing the new merged array with size of `N + M`.\\n\\n\\n---\\n\\n## 2. Divide And Conquer\\n1. **findKthElement** Function.\\n    - Handle **base cases** where one of the arrays is **exhausted**.\\n        - Return the kth element from the remaining array accordingly.\\n    - **Calculate** mid indices for both arrays to divide and conquer.\\n    - Based on mid elements, decide which **portion** of the arrays to **discard** and recurse accordingly.\\n2. **findMedianSortedArrays** Function.\\n    - Calculate the **total size** of the merged arrays.   \\n    - If the total size is **odd**, return the kth element where `k = total_size // 2`.\\n    - If the total size is **even**, find the `kth and (kth - 1)` elements and return their **average**.\\n\\n## Complexity\\n- **Time complexity:** $$O(log(min(M, N)))$$ \\nThe **logarithmic** term is because we are using **Divide And Conquer** then each call we divide the size of the two arrays into half.\\nThe **minimum** term since the base case is when the size of one of the arrays is `0` and the array which will be faster to reach `0` is the smaller array which is `min(M, N)`\\nSo total complexity is `O(log(min(M, N)))` .\\n- **Space complexity:** $$O(1)$$\\nSince we are only store constant number of variables then complexity is `O(1)`.\\n\\n\\n\\n---\\n\\n\\n\\n# Code\\n## 1. Two Pointers\\n```C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        // Merge the sorted arrays into a single array\\n        vector<int> mergedArray(nums1.size() + nums2.size());\\n        \\n        int idxNums1 = 0; // Index for nums1\\n        int idxNums2 = 0; // Index for nums2\\n        \\n        // Merge the arrays while maintaining the sorted order\\n        for(int i = 0; i < mergedArray.size(); i++) {\\n            if (idxNums2 != nums2.size() && (idxNums1 == nums1.size() || nums2[idxNums2] < nums1[idxNums1])) {\\n                mergedArray[i] = nums2[idxNums2++];\\n            } else {\\n                mergedArray[i] = nums1[idxNums1++];\\n            }\\n        }\\n        \\n        // Calculate the median of the merged array\\n        if (mergedArray.size() % 2 == 1) {\\n            return mergedArray[mergedArray.size() / 2];\\n        } else {\\n            return ((mergedArray[mergedArray.size() / 2]) + (mergedArray[mergedArray.size() / 2 - 1])) / 2.0;\\n        }\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        // Merge the sorted arrays into a single array\\n        int[] mergedArray = new int[nums1.length + nums2.length];\\n\\n        int idxNums1 = 0; // Index for nums1\\n        int idxNums2 = 0; // Index for nums2\\n\\n        // Merge the arrays while maintaining the sorted order\\n        for (int i = 0; i < mergedArray.length; i++) {\\n            if (idxNums2 < nums2.length && (idxNums1 == nums1.length || nums2[idxNums2] < nums1[idxNums1])) {\\n                mergedArray[i] = nums2[idxNums2++];\\n            } else {\\n                mergedArray[i] = nums1[idxNums1++];\\n            }\\n        }\\n\\n        // Calculate the median of the merged array\\n        if (mergedArray.length % 2 == 1) {\\n            return mergedArray[mergedArray.length / 2];\\n        } else {\\n            return (mergedArray[mergedArray.length / 2] + mergedArray[mergedArray.length / 2 - 1]) / 2.0;\\n        }\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2) -> float:\\n        merged_array = [0] * (len(nums1) + len(nums2))\\n        idx_nums1 = 0  # Index for nums1\\n        idx_nums2 = 0  # Index for nums2\\n\\n        # Merge the arrays while maintaining the sorted order\\n        for i in range(len(merged_array)):\\n            if idx_nums2 < len(nums2) and (idx_nums1 == len(nums1) or nums2[idx_nums2] < nums1[idx_nums1]):\\n                merged_array[i] = nums2[idx_nums2]\\n                idx_nums2 += 1\\n            else:\\n                merged_array[i] = nums1[idx_nums1]\\n                idx_nums1 += 1\\n\\n        # Calculate the median of the merged array\\n        if len(merged_array) % 2 == 1:\\n            return merged_array[len(merged_array) // 2]\\n        else:\\n            return (merged_array[len(merged_array) // 2] + merged_array[len(merged_array) // 2 - 1]) / 2.0\\n```\\n\\n## 2. Divide And Conquer\\n```C++ []\\nclass Solution {\\npublic:\\n    // Helper function to find the kth element in merged sorted arrays\\n    double findKthElement(int k, vector<int>& nums1, vector<int>& nums2, int start1, int end1, int start2, int end2) {\\n        // Base cases when one array is exhausted\\n        if (start1 >= end1)\\n            return nums2[start2 + k];\\n        if (start2 >= end2)\\n            return nums1[start1 + k];\\n\\n        // Calculate mid indices\\n        int mid1 = (end1 - start1) / 2;\\n        int mid2 = (end2 - start2) / 2;\\n\\n        // Compare mid elements and recurse accordingly\\n        if (mid1 + mid2 < k) {\\n            if (nums1[start1 + mid1] > nums2[start2 + mid2])\\n                // Discard elements before mid2 and search in the remaining array\\n                return findKthElement(k - mid2 - 1, nums1, nums2, start1, end1, start2 + mid2 + 1, end2);\\n            else\\n                // Discard elements before mid1 and search in the remaining array\\n                return findKthElement(k - mid1 - 1, nums1, nums2, start1 + mid1 + 1, end1, start2, end2);\\n        } else {\\n            if (nums1[start1 + mid1] > nums2[start2 + mid2])\\n                // Discard elements after mid1 and search in the remaining array\\n                return findKthElement(k, nums1, nums2, start1, start1 + mid1, start2, end2);\\n            else\\n                // Discard elements after mid2 and search in the remaining array\\n                return findKthElement(k, nums1, nums2, start1, end1, start2, start2 + mid2);\\n        }\\n    }\\n\\n    // Function to find the median of merged sorted arrays\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int size1 = nums1.size();\\n        int size2 = nums2.size();\\n        int totalSize = size1 + size2;\\n\\n        // Check if the total size is odd or even and find the median accordingly\\n        if (totalSize % 2 == 1)\\n            // For odd total size, median is the kth element where k = total_size // 2\\n            return findKthElement(totalSize / 2, nums1, nums2, 0, size1, 0, size2);\\n        else {\\n            // For even total size, median is the average of kth and (kth - 1) elements\\n            int num1 = findKthElement(totalSize / 2, nums1, nums2, 0, size1, 0, size2);\\n            int num2 = findKthElement(totalSize / 2 - 1, nums1, nums2, 0, size1, 0, size2);\\n\\n            return (num1 + num2) / 2.0;\\n        }\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    // Helper function to find the kth element in merged sorted arrays\\n    private double findKthElement(int k, int[] nums1, int[] nums2, int start1, int end1, int start2, int end2) {\\n        // Base cases when one array is exhausted\\n        if (start1 >= end1)\\n            return nums2[start2 + k];\\n        if (start2 >= end2)\\n            return nums1[start1 + k];\\n\\n        // Calculate mid indices\\n        int mid1 = (end1 - start1) / 2;\\n        int mid2 = (end2 - start2) / 2;\\n\\n        // Compare mid elements and recurse accordingly\\n        if (mid1 + mid2 < k) {\\n            if (nums1[start1 + mid1] > nums2[start2 + mid2])\\n                // Discard elements before mid2 and search in the remaining array\\n                return findKthElement(k - mid2 - 1, nums1, nums2, start1, end1, start2 + mid2 + 1, end2);\\n            else\\n                // Discard elements before mid1 and search in the remaining array\\n                return findKthElement(k - mid1 - 1, nums1, nums2, start1 + mid1 + 1, end1, start2, end2);\\n        } else {\\n            if (nums1[start1 + mid1] > nums2[start2 + mid2])\\n                // Discard elements after mid1 and search in the remaining array\\n                return findKthElement(k, nums1, nums2, start1, start1 + mid1, start2, end2);\\n            else\\n                // Discard elements after mid2 and search in the remaining array\\n                return findKthElement(k, nums1, nums2, start1, end1, start2, start2 + mid2);\\n        }\\n    }\\n\\n    // Function to find the median of merged sorted arrays\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int size1 = nums1.length;\\n        int size2 = nums2.length;\\n        int totalSize = size1 + size2;\\n\\n        // Check if the total size is odd or even and find the median accordingly\\n        if (totalSize % 2 == 1)\\n            // For odd total size, median is the kth element where k = total_size // 2\\n            return findKthElement(totalSize / 2, nums1, nums2, 0, size1, 0, size2);\\n        else {\\n            // For even total size, median is the average of kth and (kth - 1) elements\\n            double num1 = findKthElement(totalSize / 2, nums1, nums2, 0, size1, 0, size2);\\n            double num2 = findKthElement(totalSize / 2 - 1, nums1, nums2, 0, size1, 0, size2);\\n\\n            return (num1 + num2) / 2.0;\\n        }\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def find_kth_element(self, k, nums1, nums2):\\n        # Base cases when one array is exhausted\\n        if not nums1:\\n            return nums2[k]\\n        if not nums2:\\n            return nums1[k]\\n\\n        mid1 = len(nums1) // 2  # Midpoint of nums1\\n        mid2 = len(nums2) // 2  # Midpoint of nums2\\n\\n        if mid1 + mid2 < k:\\n            if nums1[mid1] > nums2[mid2]:\\n                # Discard elements before mid2 and search in the remaining array\\n                return self.find_kth_element(k - mid2 - 1, nums1, nums2[mid2 + 1:])\\n            else:\\n                # Discard elements before mid1 and search in the remaining array\\n                return self.find_kth_element(k - mid1 - 1, nums1[mid1 + 1:], nums2)\\n        else:\\n            if nums1[mid1] > nums2[mid2]:\\n                # Discard elements after mid1 and search in the remaining array\\n                return self.find_kth_element(k, nums1[:mid1], nums2)\\n            else:\\n                # Discard elements after mid2 and search in the remaining array\\n                return self.find_kth_element(k, nums1, nums2[:mid2])\\n\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        total_size = len(nums1) + len(nums2)\\n\\n        if total_size % 2 == 1:\\n            # For odd total size, median is the kth element where k = total_size // 2\\n            return self.find_kth_element(total_size // 2, nums1, nums2)\\n        else:\\n            # For even total size, median is the average of kth and (kth - 1) elements\\n            k1 = total_size // 2\\n            k2 = total_size // 2 - 1\\n            num1 = self.find_kth_element(k1, nums1, nums2)\\n            num2 = self.find_kth_element(k2, nums1, nums2)\\n            return (num1 + num2) / 2.0\\n```\\n\\n \\n![leet_sol.jpg](https://assets.leetcode.com/users/images/bfec69ea-4eef-49b6-9926-a982eb9a28b8_1695257729.395488.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Divide and Conquer"
                ],
                "code": "```\\n-> a = [1, 4, 10]\\n-> b = []\\n\\n-> index median of a + b = 1\\n-> median of a + b = 4\\n```\n```\\n-> a = [1, 4, 10]\\n-> b = [2, 4, 7, 15]\\n-> index median of a + b = 3\\n-> mid of a = 1\\n-> mid of b = 2\\n```\n```\\nnew a and b to search in:\\n-> a = [1, 4, 10]\\n-> b = [2, 4]\\n-> index median of a + b = 3\\n-> mid of a = 1\\n-> mid of b = 1\\n```\n```\\nnew a and b to search in\\n-> a = [10]\\n-> b = [2, 4]\\n-> index median of a + b = 1\\n-> mid of a = 0\\n-> mid of b = 1\\n```\n```\\nnew a and b to search in\\n-> a = []\\n-> b = [2, 4]\\n-> index median of a + b = 1\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        // Merge the sorted arrays into a single array\\n        vector<int> mergedArray(nums1.size() + nums2.size());\\n        \\n        int idxNums1 = 0; // Index for nums1\\n        int idxNums2 = 0; // Index for nums2\\n        \\n        // Merge the arrays while maintaining the sorted order\\n        for(int i = 0; i < mergedArray.size(); i++) {\\n            if (idxNums2 != nums2.size() && (idxNums1 == nums1.size() || nums2[idxNums2] < nums1[idxNums1])) {\\n                mergedArray[i] = nums2[idxNums2++];\\n            } else {\\n                mergedArray[i] = nums1[idxNums1++];\\n            }\\n        }\\n        \\n        // Calculate the median of the merged array\\n        if (mergedArray.size() % 2 == 1) {\\n            return mergedArray[mergedArray.size() / 2];\\n        } else {\\n            return ((mergedArray[mergedArray.size() / 2]) + (mergedArray[mergedArray.size() / 2 - 1])) / 2.0;\\n        }\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        // Merge the sorted arrays into a single array\\n        int[] mergedArray = new int[nums1.length + nums2.length];\\n\\n        int idxNums1 = 0; // Index for nums1\\n        int idxNums2 = 0; // Index for nums2\\n\\n        // Merge the arrays while maintaining the sorted order\\n        for (int i = 0; i < mergedArray.length; i++) {\\n            if (idxNums2 < nums2.length && (idxNums1 == nums1.length || nums2[idxNums2] < nums1[idxNums1])) {\\n                mergedArray[i] = nums2[idxNums2++];\\n            } else {\\n                mergedArray[i] = nums1[idxNums1++];\\n            }\\n        }\\n\\n        // Calculate the median of the merged array\\n        if (mergedArray.length % 2 == 1) {\\n            return mergedArray[mergedArray.length / 2];\\n        } else {\\n            return (mergedArray[mergedArray.length / 2] + mergedArray[mergedArray.length / 2 - 1]) / 2.0;\\n        }\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2) -> float:\\n        merged_array = [0] * (len(nums1) + len(nums2))\\n        idx_nums1 = 0  # Index for nums1\\n        idx_nums2 = 0  # Index for nums2\\n\\n        # Merge the arrays while maintaining the sorted order\\n        for i in range(len(merged_array)):\\n            if idx_nums2 < len(nums2) and (idx_nums1 == len(nums1) or nums2[idx_nums2] < nums1[idx_nums1]):\\n                merged_array[i] = nums2[idx_nums2]\\n                idx_nums2 += 1\\n            else:\\n                merged_array[i] = nums1[idx_nums1]\\n                idx_nums1 += 1\\n\\n        # Calculate the median of the merged array\\n        if len(merged_array) % 2 == 1:\\n            return merged_array[len(merged_array) // 2]\\n        else:\\n            return (merged_array[len(merged_array) // 2] + merged_array[len(merged_array) // 2 - 1]) / 2.0\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    // Helper function to find the kth element in merged sorted arrays\\n    double findKthElement(int k, vector<int>& nums1, vector<int>& nums2, int start1, int end1, int start2, int end2) {\\n        // Base cases when one array is exhausted\\n        if (start1 >= end1)\\n            return nums2[start2 + k];\\n        if (start2 >= end2)\\n            return nums1[start1 + k];\\n\\n        // Calculate mid indices\\n        int mid1 = (end1 - start1) / 2;\\n        int mid2 = (end2 - start2) / 2;\\n\\n        // Compare mid elements and recurse accordingly\\n        if (mid1 + mid2 < k) {\\n            if (nums1[start1 + mid1] > nums2[start2 + mid2])\\n                // Discard elements before mid2 and search in the remaining array\\n                return findKthElement(k - mid2 - 1, nums1, nums2, start1, end1, start2 + mid2 + 1, end2);\\n            else\\n                // Discard elements before mid1 and search in the remaining array\\n                return findKthElement(k - mid1 - 1, nums1, nums2, start1 + mid1 + 1, end1, start2, end2);\\n        } else {\\n            if (nums1[start1 + mid1] > nums2[start2 + mid2])\\n                // Discard elements after mid1 and search in the remaining array\\n                return findKthElement(k, nums1, nums2, start1, start1 + mid1, start2, end2);\\n            else\\n                // Discard elements after mid2 and search in the remaining array\\n                return findKthElement(k, nums1, nums2, start1, end1, start2, start2 + mid2);\\n        }\\n    }\\n\\n    // Function to find the median of merged sorted arrays\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int size1 = nums1.size();\\n        int size2 = nums2.size();\\n        int totalSize = size1 + size2;\\n\\n        // Check if the total size is odd or even and find the median accordingly\\n        if (totalSize % 2 == 1)\\n            // For odd total size, median is the kth element where k = total_size // 2\\n            return findKthElement(totalSize / 2, nums1, nums2, 0, size1, 0, size2);\\n        else {\\n            // For even total size, median is the average of kth and (kth - 1) elements\\n            int num1 = findKthElement(totalSize / 2, nums1, nums2, 0, size1, 0, size2);\\n            int num2 = findKthElement(totalSize / 2 - 1, nums1, nums2, 0, size1, 0, size2);\\n\\n            return (num1 + num2) / 2.0;\\n        }\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    // Helper function to find the kth element in merged sorted arrays\\n    private double findKthElement(int k, int[] nums1, int[] nums2, int start1, int end1, int start2, int end2) {\\n        // Base cases when one array is exhausted\\n        if (start1 >= end1)\\n            return nums2[start2 + k];\\n        if (start2 >= end2)\\n            return nums1[start1 + k];\\n\\n        // Calculate mid indices\\n        int mid1 = (end1 - start1) / 2;\\n        int mid2 = (end2 - start2) / 2;\\n\\n        // Compare mid elements and recurse accordingly\\n        if (mid1 + mid2 < k) {\\n            if (nums1[start1 + mid1] > nums2[start2 + mid2])\\n                // Discard elements before mid2 and search in the remaining array\\n                return findKthElement(k - mid2 - 1, nums1, nums2, start1, end1, start2 + mid2 + 1, end2);\\n            else\\n                // Discard elements before mid1 and search in the remaining array\\n                return findKthElement(k - mid1 - 1, nums1, nums2, start1 + mid1 + 1, end1, start2, end2);\\n        } else {\\n            if (nums1[start1 + mid1] > nums2[start2 + mid2])\\n                // Discard elements after mid1 and search in the remaining array\\n                return findKthElement(k, nums1, nums2, start1, start1 + mid1, start2, end2);\\n            else\\n                // Discard elements after mid2 and search in the remaining array\\n                return findKthElement(k, nums1, nums2, start1, end1, start2, start2 + mid2);\\n        }\\n    }\\n\\n    // Function to find the median of merged sorted arrays\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int size1 = nums1.length;\\n        int size2 = nums2.length;\\n        int totalSize = size1 + size2;\\n\\n        // Check if the total size is odd or even and find the median accordingly\\n        if (totalSize % 2 == 1)\\n            // For odd total size, median is the kth element where k = total_size // 2\\n            return findKthElement(totalSize / 2, nums1, nums2, 0, size1, 0, size2);\\n        else {\\n            // For even total size, median is the average of kth and (kth - 1) elements\\n            double num1 = findKthElement(totalSize / 2, nums1, nums2, 0, size1, 0, size2);\\n            double num2 = findKthElement(totalSize / 2 - 1, nums1, nums2, 0, size1, 0, size2);\\n\\n            return (num1 + num2) / 2.0;\\n        }\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def find_kth_element(self, k, nums1, nums2):\\n        # Base cases when one array is exhausted\\n        if not nums1:\\n            return nums2[k]\\n        if not nums2:\\n            return nums1[k]\\n\\n        mid1 = len(nums1) // 2  # Midpoint of nums1\\n        mid2 = len(nums2) // 2  # Midpoint of nums2\\n\\n        if mid1 + mid2 < k:\\n            if nums1[mid1] > nums2[mid2]:\\n                # Discard elements before mid2 and search in the remaining array\\n                return self.find_kth_element(k - mid2 - 1, nums1, nums2[mid2 + 1:])\\n            else:\\n                # Discard elements before mid1 and search in the remaining array\\n                return self.find_kth_element(k - mid1 - 1, nums1[mid1 + 1:], nums2)\\n        else:\\n            if nums1[mid1] > nums2[mid2]:\\n                # Discard elements after mid1 and search in the remaining array\\n                return self.find_kth_element(k, nums1[:mid1], nums2)\\n            else:\\n                # Discard elements after mid2 and search in the remaining array\\n                return self.find_kth_element(k, nums1, nums2[:mid2])\\n\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        total_size = len(nums1) + len(nums2)\\n\\n        if total_size % 2 == 1:\\n            # For odd total size, median is the kth element where k = total_size // 2\\n            return self.find_kth_element(total_size // 2, nums1, nums2)\\n        else:\\n            # For even total size, median is the average of kth and (kth - 1) elements\\n            k1 = total_size // 2\\n            k2 = total_size // 2 - 1\\n            num1 = self.find_kth_element(k1, nums1, nums2)\\n            num2 = self.find_kth_element(k2, nums1, nums2)\\n            return (num1 + num2) / 2.0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384551,
                "title": "accepted-c-binary-search-solution-with-explanation",
                "content": "**Description:**\\n\\n[Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/): Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.\\n\\n**Example:**\\n\\n```\\nInput: nums1 = [1,2,3,4,5], nums2 = [2,3,7]\\nOutput: 3.00000\\nExplanation: merged array = [1,2,2,3,3,4,5,7] and median is (3 + 3) / 2 = 3.\\n```\\n\\n\\n**Solution:**\\n\\nMedian is **the middle number in a sorted list of numbers**, which makes the number of the first half euqal to the the second half.\\n\\nFor one sorted array `A` (shown as follows), if the position `i` is the median, **left_length = right_length** and **max(left element) <= min(right element)**.\\n![image](https://assets.leetcode.com/users/images/7dcb53bf-7beb-47cb-aa1c-413033e91020_1628149083.2297027.png)\\n\\nEven if we divide `A` into two arrays `B` and `C` (shown as follows), we still have these two attributes. Suppose the length of `B` and `C` are `m` and `n`, the median position is `i` and `j` (we disscuss how to get `j` later). So, it is easy to kown, \\n1. **B_left_length + C_left_length = B_right_length + C_right_length**\\n2. **max(left element) <= min(right element)**\\n![image](https://assets.leetcode.com/users/images/cfb0d132-042c-4363-8ad1-5804958642d8_1628149105.0629883.png)\\n\\nAccording to the 1st feature, we can get **i + j = (m - i) + (n - j)**, so `j = (m + n) / 2 - i`. Also, there is a trick, if we set **n >= m**, `j` will be **[0, n]**.\\n\\nSo, the only thing for us is to satify the 2nd feature, in other words, `max(B[i - 1], C[j - 1]) <= max(B[i], C[j])`. It is easy too see that `B[i - 1] <= B[i]` and `C[j - 1] <= C[j]` (in two sorted arrays). Thus, we only consider three situations:\\n\\n1. **B[i - 1] <= C[j]** and **C[j - 1] <= B[i]**: this `i` meets two features, so we return the result\\n2. **B[i - 1] > C[j]**: `i` is too large, we need to decrease it \\n3. **C[j - 1] > B[i]**: `i` is too small, we need to increase it \\n\\nNotice that for the edge situations (**i = 0**, **i = m**, **j = 0** and **j = m**), `B[i - 1]`, `B[i]`, `C[j - 1]` and `C[j]` do **NOT** exist. We just set them to **maxima** or **minima**.\\n\\nFinally, for the return of result, \\n\\n- **m + n** is odd, we return `min(B[i], C[j])`\\n- **m + n** is even, we return `(max(B[i - 1], C[j - 1]) + min(B[i], C[j])) / 2`\\n\\n**Code:**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size(), n = nums2.size();\\n        if(m > n)   return findMedianSortedArrays(nums2, nums1);\\n        \\n        int low = 0, high = m;\\n        while(low <= high) {\\n            int i = low + (high - low) / 2;\\n            int j = (m + n) / 2 - i;\\n            \\n            int left1  = (i == 0)? INT_MIN : nums1[i - 1];\\n            int right1 = (i == m)? INT_MAX : nums1[i];\\n            int left2  = (j == 0)? INT_MIN : nums2[j - 1];\\n            int right2 = (j == n)? INT_MAX : nums2[j];\\n            \\n            if(left1 > right2) {\\n                high = i - 1;\\t// decrease i\\n            }\\n            else if(left2 > right1) {\\n                low = i + 1;\\t// increase i\\n            }\\n            else {\\n                if((m + n) & 1)\\n                    return (i == m)? (double)right2 : (j == n)? (double)right1 : (double)min(right1, right2);\\n                \\n                double l = (i == 0)? (double)left2 : (j == 0)? double(left1) : (double)max(left1, left2);\\n                double r = (i == m)? (double)right2 : (j == n)? (double)right1 : (double)min(right1, right2);\\n                return (l + r) / 2;\\n            }\\n        }\\n        \\n        return double(-1);\\n    }\\n};\\n```\\n\\n**Complexity:**\\nTime complexity: O(log(min(m,n))) for binary search\\nSpace complexity: O(1)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nInput: nums1 = [1,2,3,4,5], nums2 = [2,3,7]\\nOutput: 3.00000\\nExplanation: merged array = [1,2,2,3,3,4,5,7] and median is (3 + 3) / 2 = 3.\\n```\n```cpp\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size(), n = nums2.size();\\n        if(m > n)   return findMedianSortedArrays(nums2, nums1);\\n        \\n        int low = 0, high = m;\\n        while(low <= high) {\\n            int i = low + (high - low) / 2;\\n            int j = (m + n) / 2 - i;\\n            \\n            int left1  = (i == 0)? INT_MIN : nums1[i - 1];\\n            int right1 = (i == m)? INT_MAX : nums1[i];\\n            int left2  = (j == 0)? INT_MIN : nums2[j - 1];\\n            int right2 = (j == n)? INT_MAX : nums2[j];\\n            \\n            if(left1 > right2) {\\n                high = i - 1;\\t// decrease i\\n            }\\n            else if(left2 > right1) {\\n                low = i + 1;\\t// increase i\\n            }\\n            else {\\n                if((m + n) & 1)\\n                    return (i == m)? (double)right2 : (j == n)? (double)right1 : (double)min(right1, right2);\\n                \\n                double l = (i == 0)? (double)left2 : (j == 0)? double(left1) : (double)max(left1, left2);\\n                double r = (i == m)? (double)right2 : (j == n)? (double)right1 : (double)min(right1, right2);\\n                return (l + r) / 2;\\n            }\\n        }\\n        \\n        return double(-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292433,
                "title": "easy-to-understand-c-problem",
                "content": "# Intuition\\nFirst ever Hard problem which i solved in my life so if you like it then please upvote\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 =nums1.size(),n2=nums2.size(),count =0;\\n        float sum;\\n        map<int, int> m;\\n        vector<int> v;\\n        for(int i=0;i<n1;i++){\\n            v.push_back(nums1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n           v.push_back(nums2[i]);\\n        }\\n       sort(v.begin(),v.end());    \\n        for(auto i:v){\\n            count++;\\n        }\\n        float n= v.size();\\n        int start =0, end = n-1;\\n        float mid =start + (end -start)/2;\\n        if (count%2==1){\\n            \\n            return v[mid];\\n        }\\n       \\n        else if(count%2==0){\\n           float sum = (float)((v[mid])+(v[mid+1]))/2;\\n            return sum; \\n        }\\n       \\n     return {};\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/8720385a-216c-4dd0-ac9f-0e7b0edb259d_1678718319.1582518.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 =nums1.size(),n2=nums2.size(),count =0;\\n        float sum;\\n        map<int, int> m;\\n        vector<int> v;\\n        for(int i=0;i<n1;i++){\\n            v.push_back(nums1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n           v.push_back(nums2[i]);\\n        }\\n       sort(v.begin(),v.end());    \\n        for(auto i:v){\\n            count++;\\n        }\\n        float n= v.size();\\n        int start =0, end = n-1;\\n        float mid =start + (end -start)/2;\\n        if (count%2==1){\\n            \\n            return v[mid];\\n        }\\n       \\n        else if(count%2==0){\\n           float sum = (float)((v[mid])+(v[mid+1]))/2;\\n            return sum; \\n        }\\n       \\n     return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838406,
                "title": "2-python-easy-solution-with-video-explanation",
                "content": "[https://youtu.be/rJFXBLxAwrw]()\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(lg n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        if (len(nums1) > len(nums2)):\\n            return self.findMedianSortedArrays(nums2, nums1)\\n\\n        start = 0\\n        end = len(nums1)\\n\\n        X = len(nums1)\\n        Y = len(nums2)\\n\\n        while start <= end:\\n            division1 = (start + end) // 2 # mid\\n            division2 = (X + Y + 1) // 2 - division1\\n\\n            # left of the median of List 1\\n            if (division1 == 0):\\n                X1 = float(\\'-inf\\')\\n            else:\\n                X1 = nums1[division1 - 1]\\n\\n            #right of the median of List 1\\n            if (division1 == len(nums1)):\\n                X2 = float(\\'inf\\')\\n            else:\\n                X2 = nums1[division1]\\n\\n            # left of the median of List 2\\n            if (division2 == 0):\\n                Y1 = float(\\'-inf\\')\\n            else:\\n                Y1 = nums2[division2 - 1]\\n            \\n            # right of the median of List 2\\n            if (division2 == len(nums2)):\\n                Y2 = float(\\'inf\\')\\n            else:\\n                Y2 = nums2[division2]\\n\\n            # check if we found the correct division\\n\\n            if (X1 <= Y2 and Y1 <= X2):\\n                # check if the length of the sum of both lists are even or odd\\n                if (X + Y) % 2 == 0:\\n                    median = ((max(X1, Y1) + min(X2, Y2)) / 2)\\n                    return median\\n                else:\\n                    #odd\\n                    median = max(X1, Y1)\\n                    return median\\n            elif Y1 > X2:\\n                start = division1 + 1\\n            else:\\n                end = division1 - 1\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        if (len(nums1) > len(nums2)):\\n            return self.findMedianSortedArrays(nums2, nums1)\\n\\n        start = 0\\n        end = len(nums1)\\n\\n        X = len(nums1)\\n        Y = len(nums2)\\n\\n        while start <= end:\\n            division1 = (start + end) // 2 # mid\\n            division2 = (X + Y + 1) // 2 - division1\\n\\n            # left of the median of List 1\\n            if (division1 == 0):\\n                X1 = float(\\'-inf\\')\\n            else:\\n                X1 = nums1[division1 - 1]\\n\\n            #right of the median of List 1\\n            if (division1 == len(nums1)):\\n                X2 = float(\\'inf\\')\\n            else:\\n                X2 = nums1[division1]\\n\\n            # left of the median of List 2\\n            if (division2 == 0):\\n                Y1 = float(\\'-inf\\')\\n            else:\\n                Y1 = nums2[division2 - 1]\\n            \\n            # right of the median of List 2\\n            if (division2 == len(nums2)):\\n                Y2 = float(\\'inf\\')\\n            else:\\n                Y2 = nums2[division2]\\n\\n            # check if we found the correct division\\n\\n            if (X1 <= Y2 and Y1 <= X2):\\n                # check if the length of the sum of both lists are even or odd\\n                if (X + Y) % 2 == 0:\\n                    median = ((max(X1, Y1) + min(X2, Y2)) / 2)\\n                    return median\\n                else:\\n                    #odd\\n                    median = max(X1, Y1)\\n                    return median\\n            elif Y1 > X2:\\n                start = division1 + 1\\n            else:\\n                end = division1 - 1\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689,
                "title": "solution-in-c-well-explained",
                "content": "### Solution\\nMedian is the middle number which partitions the sorted array into two halves with same length, even when it comes to two sorted array, the rule will always apply. \\n\\nOverview of the partition:\\n```\\n  A[i-1]   |   A[i]\\n          \\\\|/\\n          /|\\\\\\n  B[i-1]   |   B[j]\\n```\\n\\nSo in this problem, we are to search out the four border numbers A[i-1] and A[i] in array-1 and B[j-1] and B[j] in array-2 to ensure that: \\n- First, `max(A[i-1],B[j-1])` is smaller than or equal to `min(A[i],B[j])`.\\n- Second, `len(A[0]...A[i-1])+len(B[0]...B[j-1])==len(A[i]...A[n-1])+len(B[j]...B[m-1])`, n and m is the size of the array-1 and array-2 respectively. \\n- Third,  to ensure the above two conditions, there must be a equation `mid=i+j-1=(m+n-1)/2` and as a result A[i-1] corresponds to B[j] and B[j-1] corresponds to A[i]; so actually we need to search two pairs, which will meet the following requirements: `A[i-1]<=B[j]` and `B[j-1]<=A[i]`.\\n\\nNow let's dive into details of its implementation.\\n\\n- First, get the index of the final median index of the two arrays `mid=(m+n-1)/2=i+j-1`, in which case if the whole size of the two array is odd, then the median will be `max(A[i-1],B[j-1])`; if it's even, then the median will be `(max(A[i-1],B[j-1])+min(A[i],B[j]))/2`.\\n- Second, do the binary searching based on array-1, starting with `l=0`, `r=n-1` and `m1=l+((r-l)>>1)`; and the corresponding index in array-2 will be `m2=mid-m1`.\\n- Third, if `A[m1] < B[m2]` then we should select the bigger half by `l=m1+1` since `m1` is too small while we need to find the biggest `A[m1]` that is smaller than `B[m2]`, which can then ensure us `A[m1+1]>B[m2-1]`; otherwise select the smaller half by `r=m1-1` since it's too big, which can then ensure us `A[m1-1]<B[m2+1]`.\\n- Forth, after the searching, `r == l-1` and as a result `l` will point to `A[i]` while `r` pointing to `A[i-1]`, which means `A[i-1], A[i], B[j-1] and B[j]` are `A[r], A[l], B[mid-l] and B[mid-r]` respectively. \\n- Fifth, in the end, we can retrieve the median as `First` presents.\\n\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.size() > nums2.size()) nums1.swap(nums2);\\n        int size1 = nums1.size(), size2 = nums2.size(), size = size1+size2;\\n        int mid = (size-1)/2, l = 0, r = size1-1;\\n        while(l <= r){\\n            int m1 = l+((r-l)>>1), m2 = mid-m1;\\n            if(nums1[m1] > nums2[m2]) r = m1-1;\\n            else l = m1+1;\\n        }\\n        int a = max(r>=0? nums1[r]:INT_MIN, mid-l>=0? nums2[mid-l]:INT_MIN);\\n        if(size&1) return a;\\n        int b = min(l<size1? nums1[l]:INT_MAX, mid-r<size2? nums2[mid-r]:INT_MAX);\\n        return (a+b)/2.0;\\n    }\\n};\\n```\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [],
                "code": "```\\n  A[i-1]   |   A[i]\\n          \\\\|/\\n          /|\\\\\\n  B[i-1]   |   B[j]\\n```\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.size() > nums2.size()) nums1.swap(nums2);\\n        int size1 = nums1.size(), size2 = nums2.size(), size = size1+size2;\\n        int mid = (size-1)/2, l = 0, r = size1-1;\\n        while(l <= r){\\n            int m1 = l+((r-l)>>1), m2 = mid-m1;\\n            if(nums1[m1] > nums2[m2]) r = m1-1;\\n            else l = m1+1;\\n        }\\n        int a = max(r>=0? nums1[r]:INT_MIN, mid-l>=0? nums2[mid-l]:INT_MIN);\\n        if(size&1) return a;\\n        int b = min(l<size1? nums1[l]:INT_MAX, mid-r<size2? nums2[mid-r]:INT_MAX);\\n        return (a+b)/2.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779189,
                "title": "java-o-log-min-m-n-solution-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n   public double findMedianSortedArrays(int[] nums1, int[] nums2)\\n   {\\n        /*\\n\\t\\t * consider the two arrays in a whole, we should find a cut in nums1, and another cut in nums2\\n\\t\\t * they will make all the numbers in left side are smaller than all numbers in right side for both array.\\n\\t\\t * for example: nums1 = {1, 2, 3, | 7, 8}, nums2 = {4, 5, | 6, 9, 10}; \"|\" represents the cut place.\\n\\t\\t * consider as a whole, left will be (<1, 2, 3,> <4, 5>); right will be (<7, 8,>  <6, 9, 10>);\\n\\t\\t * all the numbers in left are smaller than all numbers in right.\\n\\t\\t * the median of the whole will be (greatest of left(5) + least of right(6) ) / 2 = 5.5.\\n\\t\\t * \\n\\t\\t * More Detail Explainations:\\n\\t\\t * lens: the total lens of nums1 + nums2.\\n         * Situation of lens % 2 == 1;         | Situation of lens % 2 == 0; \\n         * Median = Math.min(R1, R2);          | Median = (Math.max(L1,L2) + Math.min(R1, R2)) / 2\\n         *               L1 (cut1)  R1         |               L1 (cut1)  R1\\n         * nums1: [1, 2,  3,  |     7, 8];     | nums1: [1, 2,  3,   |    7, 8]\\n         * nums2: [4, 5,   |   6, 9, 10, 12];  | nums2: [4, 5,   |    6, 9, 10]\\n         *            L2 (cut2)  R2            |           L2 (cut2)  R2\\n         * \\n         * cut1: represents the numbers before the cut in nums1.\\n         * cut2: represents the numbers before the cut in nums2.\\n         * cut1 + cut2 = len / 2;\\n         * L1: the rightMost(greatest) element in nums1\\'s left parts after the cut.\\n         * R1: the leftMost(least) element in nums1\\'s right parts after the cut.\\n         * L2: the rightMost(greatest) element in nums2\\'s left parts after the cut.\\n         * R2: the leftMost(least) element in nums2\\'s right parts after the cut.\\n         * cutL/cutR: the range in nums1 for cutting.\\n         * \\n         * After the cut, we know L1 should smaller than R2; R1 should greater than L2\\n         * Then it will be a valid cut, otherwise we should change the cut place:\\n         * \\n         * cut1 to left (if L1 > R2) to let smaller ones in the left bucket of nums1\\n         * cut1 to right (if R1 < L2) to let greater ones in the right bucket of nums2\\n         * \\n         * the moving process will utilize binary search.\\n         */\\n        \\n\\t\\t// make sure we are always dealing with nums1 with smaller array.\\n    \\t// Time Complexity: O(log(min(m, n)));\\n        if (nums1.length > nums2.length)\\n            return findMedianSortedArrays(nums2, nums1);\\n\\t\\t\\t\\n        int cut1 = 0, cut2 = 0;\\n        int len = nums1.length + nums2.length;\\n        // halfLen: the count of numbers in left for nums1 and nums2 after cuts.\\n        int halfLen = len / 2;\\n        // cutL/cutR: for the binary search the cut point, we should give it a range\\n        int cutL = 0, cutR = nums1.length;\\n        \\n        while (cutL <= cutR)\\n        {\\n        \\t// binary search.\\n        \\tcut1 = (cutR - cutL) / 2 + cutL;\\n        \\tcut2 = halfLen - cut1;\\n        \\t// cut1 == 0, meaning no elements before the cut1\\n        \\t// make L1 = MinValue to make sure the later compare go through.\\n        \\tdouble L1 = cut1 == 0 ? Integer.MIN_VALUE : nums1[cut1 - 1];\\n        \\t// cut1 == nums1.length meaning all elements are in the left of the cut\\n        \\t// make R1 = Maxvalue to make sure the later compare go through.\\n        \\tdouble R1 = cut1 == nums1.length ? Integer.MAX_VALUE : nums1[cut1];\\n        \\t\\n        \\tdouble L2 = cut2 == 0 ? Integer.MIN_VALUE : nums2[cut2 - 1];\\n        \\tdouble R2 = cut2 == nums2.length ? Integer.MAX_VALUE : nums2[cut2];\\n        \\t\\n        \\tif (L1 > R2)\\t// meaning cut1 should move left (to make smaller ones in the left bucket)\\n        \\t\\tcutR = cut1 - 1;\\n        \\telse if (R1 < L2) // cut1 should move right (to make larger ones in the right bucket)\\n        \\t\\tcutL = cut1 + 1;\\n        \\telse\\t// this cut makes a perfect match.\\n        \\t{\\n        \\t\\tif (len % 2 == 0)\\n        \\t\\t\\treturn (Math.max(L1,L2) + Math.min(R1, R2)) / 2;\\n        \\t\\telse\\n        \\t\\t\\treturn Math.min(R1, R2);\\n        \\t}\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n   public double findMedianSortedArrays(int[] nums1, int[] nums2)\\n   {\\n        /*\\n\\t\\t * consider the two arrays in a whole, we should find a cut in nums1, and another cut in nums2\\n\\t\\t * they will make all the numbers in left side are smaller than all numbers in right side for both array.\\n\\t\\t * for example: nums1 = {1, 2, 3, | 7, 8}, nums2 = {4, 5, | 6, 9, 10}; \"|\" represents the cut place.\\n\\t\\t * consider as a whole, left will be (<1, 2, 3,> <4, 5>); right will be (<7, 8,>  <6, 9, 10>);\\n\\t\\t * all the numbers in left are smaller than all numbers in right.\\n\\t\\t * the median of the whole will be (greatest of left(5) + least of right(6) ) / 2 = 5.5.\\n\\t\\t * \\n\\t\\t * More Detail Explainations:\\n\\t\\t * lens: the total lens of nums1 + nums2.\\n         * Situation of lens % 2 == 1;         | Situation of lens % 2 == 0; \\n         * Median = Math.min(R1, R2);          | Median = (Math.max(L1,L2) + Math.min(R1, R2)) / 2\\n         *               L1 (cut1)  R1         |               L1 (cut1)  R1\\n         * nums1: [1, 2,  3,  |     7, 8];     | nums1: [1, 2,  3,   |    7, 8]\\n         * nums2: [4, 5,   |   6, 9, 10, 12];  | nums2: [4, 5,   |    6, 9, 10]\\n         *            L2 (cut2)  R2            |           L2 (cut2)  R2\\n         * \\n         * cut1: represents the numbers before the cut in nums1.\\n         * cut2: represents the numbers before the cut in nums2.\\n         * cut1 + cut2 = len / 2;\\n         * L1: the rightMost(greatest) element in nums1\\'s left parts after the cut.\\n         * R1: the leftMost(least) element in nums1\\'s right parts after the cut.\\n         * L2: the rightMost(greatest) element in nums2\\'s left parts after the cut.\\n         * R2: the leftMost(least) element in nums2\\'s right parts after the cut.\\n         * cutL/cutR: the range in nums1 for cutting.\\n         * \\n         * After the cut, we know L1 should smaller than R2; R1 should greater than L2\\n         * Then it will be a valid cut, otherwise we should change the cut place:\\n         * \\n         * cut1 to left (if L1 > R2) to let smaller ones in the left bucket of nums1\\n         * cut1 to right (if R1 < L2) to let greater ones in the right bucket of nums2\\n         * \\n         * the moving process will utilize binary search.\\n         */\\n        \\n\\t\\t// make sure we are always dealing with nums1 with smaller array.\\n    \\t// Time Complexity: O(log(min(m, n)));\\n        if (nums1.length > nums2.length)\\n            return findMedianSortedArrays(nums2, nums1);\\n\\t\\t\\t\\n        int cut1 = 0, cut2 = 0;\\n        int len = nums1.length + nums2.length;\\n        // halfLen: the count of numbers in left for nums1 and nums2 after cuts.\\n        int halfLen = len / 2;\\n        // cutL/cutR: for the binary search the cut point, we should give it a range\\n        int cutL = 0, cutR = nums1.length;\\n        \\n        while (cutL <= cutR)\\n        {\\n        \\t// binary search.\\n        \\tcut1 = (cutR - cutL) / 2 + cutL;\\n        \\tcut2 = halfLen - cut1;\\n        \\t// cut1 == 0, meaning no elements before the cut1\\n        \\t// make L1 = MinValue to make sure the later compare go through.\\n        \\tdouble L1 = cut1 == 0 ? Integer.MIN_VALUE : nums1[cut1 - 1];\\n        \\t// cut1 == nums1.length meaning all elements are in the left of the cut\\n        \\t// make R1 = Maxvalue to make sure the later compare go through.\\n        \\tdouble R1 = cut1 == nums1.length ? Integer.MAX_VALUE : nums1[cut1];\\n        \\t\\n        \\tdouble L2 = cut2 == 0 ? Integer.MIN_VALUE : nums2[cut2 - 1];\\n        \\tdouble R2 = cut2 == nums2.length ? Integer.MAX_VALUE : nums2[cut2];\\n        \\t\\n        \\tif (L1 > R2)\\t// meaning cut1 should move left (to make smaller ones in the left bucket)\\n        \\t\\tcutR = cut1 - 1;\\n        \\telse if (R1 < L2) // cut1 should move right (to make larger ones in the right bucket)\\n        \\t\\tcutL = cut1 + 1;\\n        \\telse\\t// this cut makes a perfect match.\\n        \\t{\\n        \\t\\tif (len % 2 == 0)\\n        \\t\\t\\treturn (Math.max(L1,L2) + Math.min(R1, R2)) / 2;\\n        \\t\\telse\\n        \\t\\t\\treturn Math.min(R1, R2);\\n        \\t}\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362255,
                "title": "java-binary-search-tc-o-log-min-n1-n2-sc-o-1-2ms-faster-than-99-90",
                "content": "```\\n\\n```class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n\\t// applying binary search on smaller array which reduces TC to O(log(min(n1,n2)) where n1 and n2 are len of num1 and nums2 respectively\\n        if(nums2.length<nums1.length)\\n            return findMedianSortedArrays(nums2,nums1);\\n        int n1=nums1.length;\\n        int n2=nums2.length;\\n        int low=0;\\n        int high=n1;\\n        while(low<=high){\\n\\t\\t// dividing the two arrays  into two parts such that each half of output array contains (n1+n2)/2 elements in case of even lenngth arrays\\n            int cut1=(low+high)/2\\nint cut2=(n1+n2)/2-cut1; // or you can write (n1+n2+1)/2-cut1) so in case of odd len left half is having 1 extra element thats why meadian in that is equal to MATH.max(left1,left2) \\n\\t\\t\\t// you can have extra element in either half in odd len case \\n\\t\\t\\t\\n            int left1=cut1==0? Integer.MIN_VALUE:nums1[cut1-1]; // left1 represents last or max element of left half from first array \\n            int left2=cut2==0?Integer.MIN_VALUE:nums2[cut2-1]; // left2 represents last or max element of left half from second array \\n            int right1=cut1==n1?Integer.MAX_VALUE:nums1[cut1]; // right1 represents first or min element of right half of from first array\\n            int right2=cut2==n2?Integer.MAX_VALUE:nums2[cut2]; // right2 represents first or min element of right half of from second array\\n\\t\\t\\t// median is equal to maximum(left half)+minimum(righthalf)/2 in even length case\\n\\t\\t\\t// in case of odd length one half either left or right is going to have 1 extra element\\n\\t\\t\\t// we need to check for these two conditions and decide whether to partiton the array towards left or move towards right side using binary search \\n\\t\\t\\t// Condition 1: left1<=right2\\n\\t\\t\\t// Condition 2: left2<=right1\\n\\t\\t\\t// all elements of left half< elements in right half\\n            if(left1>right2){\\n                high=cut1-1; // moving partition towards left side\\n            }\\n            else if(left2>right1){\\n                low=cut1+1;  // moving partition towards right side\\n            }\\n            else{\\n\\t\\t\\t// If above conditions fails returning the median by checking the length of array that is length is even or odd\\n                return ((n1+n2)%2==0)? (Math.max(left1,left2)+Math.min(right1,right2))/2.0:\\n                Math.min(right1,right2); // because the right half is containing 1 extra element so meadian is equal to min(right half)\\n                \\n            }\\n        }\\n        return 0.0;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1027598,
                "title": "c-o-n-2-1-beats-99-99-o-1-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(), m=nums2.size();\\n        int i=0,j=0,k=0;\\n        int x=0, y=0;\\n        while(i<=((n+m)/2))\\n        {\\n            if(k>=m || (j<n && nums1[j]<nums2[k]))\\n            {\\n                y=x;\\n                x=nums1[j++];\\n            }\\n            else\\n            {\\n                y=x;\\n                x=nums2[k++];\\n            }\\n            i++;\\n        }\\n        if((n+m)%2==0)\\n            return (double)(x+y)/2;\\n        return (double)x;\\n    }\\n};\\n```\\nIf you get stuck at any point,  don\\'t hesitate to leave a message here in the comment section. Will try my best to make you understand.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(), m=nums2.size();\\n        int i=0,j=0,k=0;\\n        int x=0, y=0;\\n        while(i<=((n+m)/2))\\n        {\\n            if(k>=m || (j<n && nums1[j]<nums2[k]))\\n            {\\n                y=x;\\n                x=nums1[j++];\\n            }\\n            else\\n            {\\n                y=x;\\n                x=nums2[k++];\\n            }\\n            i++;\\n        }\\n        if((n+m)%2==0)\\n            return (double)(x+y)/2;\\n        return (double)x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761,
                "title": "my-c-code-binary-partition",
                "content": "The basic idea is to always compare the median of A and B and drop half of A or B elements based on the comparison results.\\n   \\n\\n     class Solution {\\n        public:\\n        // binary-partition search to find the K-the element     \\n            int findKSortedArrays(int A[], int m, int B[], int n, int K)\\n            {\\n                int med_a, med_b;\\n        \\n                if(m<=0)\\n                { // if A is empty, then return the k-th element of B\\n                    return B[K-1];\\n                }\\n                else if(n<=0)\\n                { // if B is empty, then return the k-th element of A\\n                    return A[K-1];\\n                }\\n                else\\n                {\\n                    //get the median element of A and B and do comparison\\n                    med_a = m/2;\\n                    med_b = n/2;\\n                    \\n                    if(B[med_b] >= A[med_a])\\n                    { // if the first half of B and the whole A have NO less than K elements, then dropped the second half of B\\n                        if(med_a + med_b + 1 >= K)\\n                            return findKSortedArrays(A, m, B, med_b, K);\\n                        else  // if the first half of B and the whole A have less than K elements, then dropped the first half of A\\n                            return findKSortedArrays(&A[med_a+1], m-med_a-1, B, n, K-med_a-1);\\n                        \\n                    }\\n                    else\\n                    {// if the first half of A and the whole B have NO less than K elements, then dropped the second half of A\\n                        if(med_a + med_b + 1 >= K)\\n                            return findKSortedArrays(A, med_a, B, n, K);\\n                        else // if the first half of A and the whole B have less than K elements, then dropped the first half of B\\n                            return findKSortedArrays(A, m, &B[med_b+1], n-med_b - 1, K-med_b-1);\\n                    }\\n                }\\n            }\\n        \\n            double findMedianSortedArrays(int A[], int m, int B[], int n) {\\n                double result =0;\\n                int K; // K is the median element index\\n                \\n                if(m>0 || n>0)\\n                {// if at least one of the arraies are non-empty\\n                    K = (m+n+1)/2;  \\n                    result = findKSortedArrays(A, m, B, n, K); // find the K-th element by binary-partition search\\n                    // if m+n is even, then need to find the K+1-th element and the median is the average of the k-th and k+1-th elements \\n                    if((m+n+1)%2)\\n                    {\\n                        K = (m+n)/2 + 1; \\n                        result = (result  + findKSortedArrays(A, m, B, n, K))/2.0;\\n                    }\\n                }\\n                \\n                return result;\\n            }\\n        };\\n\\n\\nUpdated: I added another concise version here, in which a similar idea is used\\n\\n    class Solution {\\n    private:\\n        double findK(vector<int> &nums1, vector<int> &nums2, int s1, int len1, int s2, int len2, int K)\\n        {\\n            if(len1>len2) return findK(nums2,  nums1, s2, len2, s1, len1, K);\\n            if(len1<=0) return nums2[s2 + K - 1];\\n            if(K==1) return min(nums1[s1], nums2[s2]);\\n            int mid1, mid2, hL1, hL2;\\n            hL1 = min(K/2, len1); \\n            mid1 = s1 + hL1 -1;\\n            hL2 = K - hL1; \\n            mid2 = s2 + hL2 -1;\\n            \\n            if(nums1[mid1] == nums2[mid2]) return nums1[mid1];\\n            else if(nums1[mid1] < nums2[mid2]) return findK(nums1, nums2, mid1+1, len1-hL1, s2, len2, K - hL1);\\n            else return findK(nums1, nums2, s1, len1, mid2+1, len2-hL2, K - hL2);\\n        }\\n    public:\\n        double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n           int len1 = nums1.size(), len2=nums2.size();\\n           if(!len1 && !len2) return 0;\\n           if( (len1+len2)%2 ) return findK(nums1, nums2, 0, len1, 0, len2, (len1+len2)/2 + 1);\\n           else return (findK(nums1, nums2, 0, len1, 0, len2, (len1+len2)/2 ) + findK(nums1, nums2, 0, len1, 0, len2, (len1+len2)/2 + 1 )) / 2.0;\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n        // binary-partition search to find the K-the element     \\n            int findKSortedArrays(int A[], int m, int B[], int n, int K)\\n            {\\n                int med_a, med_b;\\n        \\n                if(m<=0)\\n                { // if A is empty, then return the k-th element of B\\n                    return B[K-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3922746,
                "title": "most-optimal-solution-using-binary-search-with-explanation",
                "content": "\\n\\n# Approach\\n- **Choosing the Smaller Array:** To optimize the time complexity, the solution starts by choosing the smaller of the two input arrays (nums1 and nums2) for the binary search operation. This helps in reducing the time complexity of the solution.\\n\\n- **Calculating the Partition Point:** The total number of elements in the combined array is n = n1 + n2. The index left where the partition between the left and right halves of the combined arrays should occur is calculated as (n1 + n2 + 1) / 2. This choice of left is crucial, as it helps in finding the median efficiently, both for odd and even total elements.\\n\\n- **Binary Search in Smaller Array:** A binary search is performed in the smaller array (nums1) to find the correct partition point (mid1) that satisfies the median condition. The corresponding partition point in the larger array (nums2) is calculated as mid2 = left - mid1.\\n\\n- **Setting Up Boundaries:** Four variables are used to store the elements immediately to the left (l1, l2) and to the right (r1, r2) of the calculated partition points in both arrays. These values are initialized to extreme values (INT_MIN and INT_MAX in C++, or negative and positive infinity in Python) to handle edge cases.\\n\\n- **Checking Median Condition:** The conditions l1 <= r2 and l2 <= r1 are checked to ensure that the median condition is met. These conditions ensure that the left half of the combined arrays contains elements smaller than or equal to the right half, which is the requirement for calculating the median.\\n\\n- **Calculating Median**: If the median condition is met, the median is calculated. If the total number of elements is odd, the median is the maximum of the left elements (l1 and l2). If the total number of elements is even, the median is the average of the maximum of the left elements and the minimum of the right elements (r1 and r2).\\n\\n- **Adjusting Binary Search Range:** If the median condition is not met, the binary search range is adjusted. If l1 is greater than r2, it means the partition point mid1 is too far to the right, so the search range is adjusted to the left half. Otherwise, the search range is adjusted to the right half.\\n\\n- **Convergence and Return:** The binary search continues until low is less than or equal to high. Once the binary search converges, the function returns the calculated median.\\n\\n# Complexity\\n- Time complexity:\\nO(log(min(n1, n2))) \\n\\n- Space complexity:\\nO(1)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        if (n1 > n2)\\n            return findMedianSortedArrays(nums2, nums1);\\n        int n = n1 + n2;\\n        int left = (n1 + n2 + 1) / 2;\\n        int low = 0, high = n1;\\n        while (low <= high) {\\n            int mid1 = (low + high) >> 1;\\n            int mid2 = left - mid1;\\n            int l1 = INT_MIN, l2 = INT_MIN, r1 = INT_MAX, r2 = INT_MAX;\\n            if (mid1 < n1)\\n                r1 = nums1[mid1];\\n            if (mid2 < n2)\\n                r2 = nums2[mid2];\\n            if (mid1 - 1 >= 0)\\n                l1 = nums1[mid1 - 1];\\n            if (mid2 - 1 >= 0)\\n                l2 = nums2[mid2 - 1];\\n            if (l1 <= r2 && l2 <= r1) {\\n                if (n % 2 == 1)\\n                    return max(l1, l2);\\n                else\\n                    return ((double)(max(l1, l2) + min(r1, r2))) / 2.0;\\n            }\\n            else if (l1 > r2)\\n                high = mid1 - 1;\\n            else\\n                low = mid1 + 1;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n```JAVA []\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length, n2 = nums2.length;\\n        if (n1 > n2)\\n            return findMedianSortedArrays(nums2, nums1);\\n        int n = n1 + n2;\\n        int left = (n1 + n2 + 1) / 2;\\n        int low = 0, high = n1;\\n        while (low <= high) {\\n            int mid1 = (low + high) / 2;\\n            int mid2 = left - mid1;\\n            int l1 = (mid1 > 0) ? nums1[mid1 - 1] : Integer.MIN_VALUE;\\n            int l2 = (mid2 > 0) ? nums2[mid2 - 1] : Integer.MIN_VALUE;\\n            int r1 = (mid1 < n1) ? nums1[mid1] : Integer.MAX_VALUE;\\n            int r2 = (mid2 < n2) ? nums2[mid2] : Integer.MAX_VALUE;\\n            \\n            if (l1 <= r2 && l2 <= r1) {\\n                if (n % 2 == 1)\\n                    return Math.max(l1, l2);\\n                else\\n                    return (double) (Math.max(l1, l2) + Math.min(r1, r2)) / 2.0;\\n            } else if (l1 > r2)\\n                high = mid1 - 1;\\n            else\\n                low = mid1 + 1;\\n        }\\n        return 0.0;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        n1, n2 = len(nums1), len(nums2)\\n        if n1 > n2:\\n            return self.findMedianSortedArrays(nums2, nums1)\\n        n = n1 + n2\\n        left = (n1 + n2 + 1) // 2\\n        low, high = 0, n1\\n        \\n        while low <= high:\\n            mid1 = (low + high) // 2\\n            mid2 = left - mid1\\n            \\n            l1 = float(\\'-inf\\') if mid1 == 0 else nums1[mid1 - 1]\\n            l2 = float(\\'-inf\\') if mid2 == 0 else nums2[mid2 - 1]\\n            r1 = float(\\'inf\\') if mid1 == n1 else nums1[mid1]\\n            r2 = float(\\'inf\\') if mid2 == n2 else nums2[mid2]\\n            \\n            if l1 <= r2 and l2 <= r1:\\n                if n % 2 == 1:\\n                    return max(l1, l2)\\n                else:\\n                    return (max(l1, l2) + min(r1, r2)) / 2.0\\n            elif l1 > r2:\\n                high = mid1 - 1\\n            else:\\n                low = mid1 + 1\\n        return 0.0\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        if (n1 > n2)\\n            return findMedianSortedArrays(nums2, nums1);\\n        int n = n1 + n2;\\n        int left = (n1 + n2 + 1) / 2;\\n        int low = 0, high = n1;\\n        while (low <= high) {\\n            int mid1 = (low + high) >> 1;\\n            int mid2 = left - mid1;\\n            int l1 = INT_MIN, l2 = INT_MIN, r1 = INT_MAX, r2 = INT_MAX;\\n            if (mid1 < n1)\\n                r1 = nums1[mid1];\\n            if (mid2 < n2)\\n                r2 = nums2[mid2];\\n            if (mid1 - 1 >= 0)\\n                l1 = nums1[mid1 - 1];\\n            if (mid2 - 1 >= 0)\\n                l2 = nums2[mid2 - 1];\\n            if (l1 <= r2 && l2 <= r1) {\\n                if (n % 2 == 1)\\n                    return max(l1, l2);\\n                else\\n                    return ((double)(max(l1, l2) + min(r1, r2))) / 2.0;\\n            }\\n            else if (l1 > r2)\\n                high = mid1 - 1;\\n            else\\n                low = mid1 + 1;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```JAVA []\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length, n2 = nums2.length;\\n        if (n1 > n2)\\n            return findMedianSortedArrays(nums2, nums1);\\n        int n = n1 + n2;\\n        int left = (n1 + n2 + 1) / 2;\\n        int low = 0, high = n1;\\n        while (low <= high) {\\n            int mid1 = (low + high) / 2;\\n            int mid2 = left - mid1;\\n            int l1 = (mid1 > 0) ? nums1[mid1 - 1] : Integer.MIN_VALUE;\\n            int l2 = (mid2 > 0) ? nums2[mid2 - 1] : Integer.MIN_VALUE;\\n            int r1 = (mid1 < n1) ? nums1[mid1] : Integer.MAX_VALUE;\\n            int r2 = (mid2 < n2) ? nums2[mid2] : Integer.MAX_VALUE;\\n            \\n            if (l1 <= r2 && l2 <= r1) {\\n                if (n % 2 == 1)\\n                    return Math.max(l1, l2);\\n                else\\n                    return (double) (Math.max(l1, l2) + Math.min(r1, r2)) / 2.0;\\n            } else if (l1 > r2)\\n                high = mid1 - 1;\\n            else\\n                low = mid1 + 1;\\n        }\\n        return 0.0;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        n1, n2 = len(nums1), len(nums2)\\n        if n1 > n2:\\n            return self.findMedianSortedArrays(nums2, nums1)\\n        n = n1 + n2\\n        left = (n1 + n2 + 1) // 2\\n        low, high = 0, n1\\n        \\n        while low <= high:\\n            mid1 = (low + high) // 2\\n            mid2 = left - mid1\\n            \\n            l1 = float(\\'-inf\\') if mid1 == 0 else nums1[mid1 - 1]\\n            l2 = float(\\'-inf\\') if mid2 == 0 else nums2[mid2 - 1]\\n            r1 = float(\\'inf\\') if mid1 == n1 else nums1[mid1]\\n            r2 = float(\\'inf\\') if mid2 == n2 else nums2[mid2]\\n            \\n            if l1 <= r2 and l2 <= r1:\\n                if n % 2 == 1:\\n                    return max(l1, l2)\\n                else:\\n                    return (max(l1, l2) + min(r1, r2)) / 2.0\\n            elif l1 > r2:\\n                high = mid1 - 1\\n            else:\\n                low = mid1 + 1\\n        return 0.0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560433,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        \\n        int n=nums1.size();\\n        int m=nums2.size();\\n        \\n        if(n>m){\\n            return findMedianSortedArrays(nums2,nums1);\\n        }\\n        int low=0,high=n;\\n        \\n        while(low<=high){\\n            \\n            int mid1=low +(high-low)/2;\\n            \\n            int mid2=(n+m)/2-mid1;\\n            \\n            int lo1=mid1==0?INT_MIN:nums1[mid1-1];\\n            int hi1=mid1==n?INT_MAX:nums1[mid1];\\n            int lo2=mid2==0?INT_MIN:nums2[mid2-1];\\n            int hi2=mid2==m?INT_MAX:nums2[mid2];\\n            \\n            if(lo1>hi2){\\n                high=mid1-1;\\n            }\\n            else if(lo2>hi1){\\n                low=mid1+1;\\n            }\\n            else{\\n                if((m+n)%2==0){\\n                    \\n                    return (float)(max(lo1,lo2)+min(hi1,hi2))/2;\\n                }\\n                else {\\n                    return min(hi1,hi2);\\n                }\\n            }\\n            \\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        \\n        int n=nums1.size();\\n        int m=nums2.size();\\n        \\n        if(n>m){\\n            return findMedianSortedArrays(nums2,nums1);\\n        }\\n        int low=0,high=n;\\n        \\n        while(low<=high){\\n            \\n            int mid1=low +(high-low)/2;\\n            \\n            int mid2=(n+m)/2-mid1;\\n            \\n            int lo1=mid1==0?INT_MIN:nums1[mid1-1];\\n            int hi1=mid1==n?INT_MAX:nums1[mid1];\\n            int lo2=mid2==0?INT_MIN:nums2[mid2-1];\\n            int hi2=mid2==m?INT_MAX:nums2[mid2];\\n            \\n            if(lo1>hi2){\\n                high=mid1-1;\\n            }\\n            else if(lo2>hi1){\\n                low=mid1+1;\\n            }\\n            else{\\n                if((m+n)%2==0){\\n                    \\n                    return (float)(max(lo1,lo2)+min(hi1,hi2))/2;\\n                }\\n                else {\\n                    return min(hi1,hi2);\\n                }\\n            }\\n            \\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334885,
                "title": "my-o-log-min-m-n-solution-in-javascript-with-120ms",
                "content": "```\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    //find the smallest length array\\n    const len1 = nums1.length;\\n    const len2 = nums2.length;\\n    \\n    //swap if len1>len2\\n    if(len1 > len2) return findMedianSortedArrays(nums2, nums1);\\n    \\n    //find high and low\\n    let lo = 0;\\n    let hi = len1;\\n    \\n    while(lo <= hi) {\\n        \\n        //find cut1 and cut2\\n        let cut1 = Math.floor((lo+hi)/2);\\n        let cut2 = Math.floor((len1+len2)/2) - cut1;\\n        \\n        //find l1 , l2, r1, r2\\n        let l1 = (cut1 === 0 ? Number.NEGATIVE_INFINITY : nums1[cut1-1]);\\n        let l2 = (cut2 === 0 ? Number.NEGATIVE_INFINITY : nums2[cut2-1]);\\n        let r1 = (cut1 === len1 ? Number.MAX_VALUE : nums1[cut1]);\\n        let r2 = (cut2 === len2 ? Number.MAX_VALUE : nums2[cut2]);\\n        \\n        //loop again if l1>r2 || l2>r1\\n        if(l1>r2) hi = cut1-1;\\n        else if(l2>r1) lo = cut1+1;\\n        else {\\n    \\n            //return median for even and odd\\n            if((len1+len2)%2 === 0) return (Math.max(l1,l2) + Math.min(r1,r2))/2\\n            else return (Math.min(r1,r2))\\n        }\\n    }\\n    return -1;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    //find the smallest length array\\n    const len1 = nums1.length;\\n    const len2 = nums2.length;\\n    \\n    //swap if len1>len2\\n    if(len1 > len2) return findMedianSortedArrays(nums2, nums1);\\n    \\n    //find high and low\\n    let lo = 0;\\n    let hi = len1;\\n    \\n    while(lo <= hi) {\\n        \\n        //find cut1 and cut2\\n        let cut1 = Math.floor((lo+hi)/2);\\n        let cut2 = Math.floor((len1+len2)/2) - cut1;\\n        \\n        //find l1 , l2, r1, r2\\n        let l1 = (cut1 === 0 ? Number.NEGATIVE_INFINITY : nums1[cut1-1]);\\n        let l2 = (cut2 === 0 ? Number.NEGATIVE_INFINITY : nums2[cut2-1]);\\n        let r1 = (cut1 === len1 ? Number.MAX_VALUE : nums1[cut1]);\\n        let r2 = (cut2 === len2 ? Number.MAX_VALUE : nums2[cut2]);\\n        \\n        //loop again if l1>r2 || l2>r1\\n        if(l1>r2) hi = cut1-1;\\n        else if(l2>r1) lo = cut1+1;\\n        else {\\n    \\n            //return median for even and odd\\n            if((len1+len2)%2 === 0) return (Math.max(l1,l2) + Math.min(r1,r2))/2\\n            else return (Math.min(r1,r2))\\n        }\\n    }\\n    return -1;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919314,
                "title": "c-o-n-solution",
                "content": "# Logic\\n* Sort and merge both sorted arrays\\n* Get the median of merged array.\\n\\n*PS: This is O(N) solution. Not O(logN) solution, as expected by the problem description.*\\n\\n```\\nclass Solution\\n{\\npublic:\\n    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2)\\n    {\\n        int len_1 = nums1.size(), len_2 = nums2.size();\\n        int idx_1 = 0, idx_2 = 0, idx_m = 0;\\n\\n        int len_m = len_1 + len_2;\\n        vector<int> merged(len_m);\\n\\t\\t\\n\\t\\t//Sort and merge both the arrays untill one of them is exausted.\\n        while (idx_1 < len_1 && idx_2 < len_2)\\n        {\\n            if (nums1[idx_1] <= nums2[idx_2])\\n            {\\n                merged[idx_m] = nums1[idx_1];\\n                idx_1++;\\n            }\\n            else\\n            {\\n                merged[idx_m] = nums2[idx_2];\\n                idx_2++;\\n            }\\n            idx_m++;\\n        }\\n\\n\\t\\t//Copy remaining elements of array 1, if any\\n        while (idx_1 < len_1)\\n        {\\n            merged[idx_m++] = nums1[idx_1++];\\n        }\\n\\t\\t\\n\\t\\t//Copy remaining elements of array 2, if any\\n        while (idx_2 < len_2)\\n        {\\n            merged[idx_m++] = nums2[idx_2++];\\n        }\\n\\n        int mid = len_m / 2;\\n\\t\\t\\n\\t\\t//Get median of merged array\\n        if (len_m % 2 == 0)\\n        {\\n            return (merged[mid - 1] + merged[mid]) / 2.0;\\n        }\\n        else\\n        {\\n            return (merged[mid]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2)\\n    {\\n        int len_1 = nums1.size(), len_2 = nums2.size();\\n        int idx_1 = 0, idx_2 = 0, idx_m = 0;\\n\\n        int len_m = len_1 + len_2;\\n        vector<int> merged(len_m);\\n\\t\\t\\n\\t\\t//Sort and merge both the arrays untill one of them is exausted.\\n        while (idx_1 < len_1 && idx_2 < len_2)\\n        {\\n            if (nums1[idx_1] <= nums2[idx_2])\\n            {\\n                merged[idx_m] = nums1[idx_1];\\n                idx_1++;\\n            }\\n            else\\n            {\\n                merged[idx_m] = nums2[idx_2];\\n                idx_2++;\\n            }\\n            idx_m++;\\n        }\\n\\n\\t\\t//Copy remaining elements of array 1, if any\\n        while (idx_1 < len_1)\\n        {\\n            merged[idx_m++] = nums1[idx_1++];\\n        }\\n\\t\\t\\n\\t\\t//Copy remaining elements of array 2, if any\\n        while (idx_2 < len_2)\\n        {\\n            merged[idx_m++] = nums2[idx_2++];\\n        }\\n\\n        int mid = len_m / 2;\\n\\t\\t\\n\\t\\t//Get median of merged array\\n        if (len_m % 2 == 0)\\n        {\\n            return (merged[mid - 1] + merged[mid]) / 2.0;\\n        }\\n        else\\n        {\\n            return (merged[mid]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618,
                "title": "iterative-c-solution-beats-96-75",
                "content": "Iterative C++ solution, beats 96.75%\\n\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        int target = (nums1.size() + nums2.size());\\n        int prev = 0;\\n        \\n        while(true) {\\n            \\n            int n = 0;\\n            \\n            int x = INT_MAX;\\n            int y = INT_MAX;\\n            \\n            if(i < nums1.size()) x = nums1[i];\\n            if(j < nums2.size()) y = nums2[j];\\n            \\n            if(x == INT_MAX && y == INT_MAX) break;\\n            \\n            if(x < y) {\\n                n = x;\\n                i++;\\n            }\\n            else {\\n                n = y;\\n                j++;\\n            }\\n            \\n            if(count == target / 2) {\\n                if(target % 2 != 0) {\\n                    return n;\\n                }\\n                else {\\n                    return (double)(prev + n) / 2;\\n                }\\n            }\\n            prev = n;\\n            count++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        int target = (nums1.size() + nums2.size());\\n        int prev = 0;\\n        \\n        while(true) {\\n            \\n            int n = 0;\\n            \\n            int x = INT_MAX;\\n            int y = INT_MAX;\\n            \\n            if(i < nums1.size()) x = nums1[i];\\n            if(j < nums2.size()) y = nums2[j];\\n            \\n            if(x == INT_MAX && y == INT_MAX) break;\\n            \\n            if(x < y) {\\n                n = x;\\n                i++;\\n            }\\n            else {\\n                n = y;\\n                j++;\\n            }\\n            \\n            if(count == target / 2) {\\n                if(target % 2 != 0) {\\n                    return n;\\n                }\\n                else {\\n                    return (double)(prev + n) / 2;\\n                }\\n            }\\n            prev = n;\\n            count++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802,
                "title": "python-o-lg-m-n-recursive-solution",
                "content": "        \\n\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        l = len(nums1) + len(nums2)\\n        if l % 2:  # the length is odd\\n            return self.findKthSmallest(nums1, nums2, l//2+1)\\n        else:\\n            return (self.findKthSmallest(nums1, nums2, l//2) +\\n            self.findKthSmallest(nums1, nums2, l//2+1))*0.5\\n        \\n    def findKthSmallest(self, nums1, nums2, k):\\n        # force nums1 is not longer than nums2\\n        if len(nums1) > len(nums2):\\n            return self.findKthSmallest(nums2, nums1, k)\\n        if not nums1:\\n            return nums2[k-1]\\n        if k == 1:\\n            return min(nums1[0], nums2[0])\\n        pa = min(k/2, len(nums1)); pb = k-pa  # take care here\\n        if nums1[pa-1] <= nums2[pb-1]:\\n            return self.findKthSmallest(nums1[pa:], nums2, k-pa)\\n        else:\\n            return self.findKthSmallest(nums1, nums2[pb:], k-pb)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "        \\n\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        l = len(nums1) + len(nums2)\\n        if l % 2:  # the length is odd\\n            return self.findKthSmallest(nums1, nums2, l//2+1)\\n        else:\\n            return (self.findKthSmallest(nums1, nums2, l//2) +\\n            self.findKthSmallest(nums1, nums2, l//2+1))*0.5\\n        \\n    def findKthSmallest(self, nums1, nums2, k):\\n        # force nums1 is not longer than nums2\\n        if len(nums1) > len(nums2):\\n            return self.findKthSmallest(nums2, nums1, k)\\n        if not nums1:\\n            return nums2[k-1]\\n        if k == 1:\\n            return min(nums1[0], nums2[0])\\n        pa = min(k/2, len(nums1)); pb = k-pa  # take care here\\n        if nums1[pa-1] <= nums2[pb-1]:\\n            return self.findKthSmallest(nums1[pa:], nums2, k-pa)\\n        else:\\n            return self.findKthSmallest(nums1, nums2[pb:], k-pb)",
                "codeTag": "Python3"
            },
            {
                "id": 2597142,
                "title": "python3-o-log-n-solution",
                "content": "```\\n# -------------------- Method 1 --------- NOT Optimised O(N) Time----------------\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        n1 = len(nums1); n2 = len(nums2)\\n        mid = (n1 + n2) // 2  \\n        i = 0; j = 0\\n        val, preVal = 0, 0\\n        \\n        for k in range(mid+1):\\n            if i < n1 and j < n2:\\n                if nums1[i] <= nums2[j]:\\n                    val = nums1[i]  \\n                    i += 1\\n                else:\\n                    val = nums2[j]\\n                    j += 1\\n            elif i < n1:\\n                val = nums1[i]\\n                i += 1\\n            else:\\n                val = nums2[j]\\n                j += 1\\n            \\n            if k == mid - 1:\\n                preVal = val\\n        \\n        if (n1+n2) % 2 == 0:\\n            return (val + preVal) / 2\\n        return float(val)\\n    \\n# Timw: O(N)\\n# Space: O(1)\\n\\n\\n\\n# -------------------- Method 2 --------- Optimised O(log(N)) Time----------------\\n\\n\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        n1 = len(nums1);   n2 = len(nums2) \\n        if n1 > n2: return self.findMedianSortedArrays(nums2, nums1) # WE SHALL DO BINARY SEARCH ON THE SMALLER ARRAY, NUMS1\\n        \\n        INT_MIN, INT_MAX = -2**64, 2**64  # SETUP INT_MIN AND INT_MAX FOR EMPTY LEFT / RIGHT PARTITION\\n        low = 0;   high = n1  # pointers for BINARY SEARCH ON THE SMALLER ARRAY NUMS1\\n        \\n        while low <= high:\\n            \\n            # GET THE PARITIONS POINTS OF BOTH ARRAYS\\n            cut1 = (low + high) // 2          # partition of nums1\\n            cut2 = (n1 + n2 + 1) // 2 - cut1  # partition of nums2\\n            \\n            # GET THE 4 BOUNDARY NUMBERS\\n            left1 = nums1[cut1-1] if cut1 > 0 else INT_MIN   # left1 is the left partition of cut1\\n            right1 = nums1[cut1] if cut1 < n1 else INT_MAX   # right1 is the right partition of cut1\\n            \\n            left2 = nums2[cut2-1] if cut2 > 0 else INT_MIN   # left2 is the left partition of cut2\\n            right2 = nums2[cut2] if cut2 < n2 else INT_MAX   # right2 is the right partition of cut2\\n            \\n            # CORRECT PARTITION FOUND\\n            if left1 <= right2 and left2 <= right1:  # Got the Answer => Median\\n                if (n1 + n2) % 2 == 0:\\n                    return (max(left1, left2) + min(right1, right2)) / 2\\n                else:\\n                    return max(left1, left2)\\n            \\n            # MOVE cut1 (mid of binary search) LEFTWARDS\\n            elif left1 > right2:\\n                high = cut1 - 1\\n                \\n            # MOVE cut1 (mid of binary search) RIGHTWARDS   \\n            else:\\n                low = cut1 + 1\\n        \\n        return 0.0  # For both empty arrays\\n    \\n\\'\\'\\'\\nTime Complexity: O(log(n1))  \\nSpace Complexity: O(1)\\n\\'\\'\\'\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\n# -------------------- Method 1 --------- NOT Optimised O(N) Time----------------\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        n1 = len(nums1); n2 = len(nums2)\\n        mid = (n1 + n2) // 2  \\n        i = 0; j = 0\\n        val, preVal = 0, 0\\n        \\n        for k in range(mid+1):\\n            if i < n1 and j < n2:\\n                if nums1[i] <= nums2[j]:\\n                    val = nums1[i]  \\n                    i += 1\\n                else:\\n                    val = nums2[j]\\n                    j += 1\\n            elif i < n1:\\n                val = nums1[i]\\n                i += 1\\n            else:\\n                val = nums2[j]\\n                j += 1\\n            \\n            if k == mid - 1:\\n                preVal = val\\n        \\n        if (n1+n2) % 2 == 0:\\n            return (val + preVal) / 2\\n        return float(val)\\n    \\n# Timw: O(N)\\n# Space: O(1)\\n\\n\\n\\n# -------------------- Method 2 --------- Optimised O(log(N)) Time----------------\\n\\n\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        n1 = len(nums1);   n2 = len(nums2) \\n        if n1 > n2: return self.findMedianSortedArrays(nums2, nums1) # WE SHALL DO BINARY SEARCH ON THE SMALLER ARRAY, NUMS1\\n        \\n        INT_MIN, INT_MAX = -2**64, 2**64  # SETUP INT_MIN AND INT_MAX FOR EMPTY LEFT / RIGHT PARTITION\\n        low = 0;   high = n1  # pointers for BINARY SEARCH ON THE SMALLER ARRAY NUMS1\\n        \\n        while low <= high:\\n            \\n            # GET THE PARITIONS POINTS OF BOTH ARRAYS\\n            cut1 = (low + high) // 2          # partition of nums1\\n            cut2 = (n1 + n2 + 1) // 2 - cut1  # partition of nums2\\n            \\n            # GET THE 4 BOUNDARY NUMBERS\\n            left1 = nums1[cut1-1] if cut1 > 0 else INT_MIN   # left1 is the left partition of cut1\\n            right1 = nums1[cut1] if cut1 < n1 else INT_MAX   # right1 is the right partition of cut1\\n            \\n            left2 = nums2[cut2-1] if cut2 > 0 else INT_MIN   # left2 is the left partition of cut2\\n            right2 = nums2[cut2] if cut2 < n2 else INT_MAX   # right2 is the right partition of cut2\\n            \\n            # CORRECT PARTITION FOUND\\n            if left1 <= right2 and left2 <= right1:  # Got the Answer => Median\\n                if (n1 + n2) % 2 == 0:\\n                    return (max(left1, left2) + min(right1, right2)) / 2\\n                else:\\n                    return max(left1, left2)\\n            \\n            # MOVE cut1 (mid of binary search) LEFTWARDS\\n            elif left1 > right2:\\n                high = cut1 - 1\\n                \\n            # MOVE cut1 (mid of binary search) RIGHTWARDS   \\n            else:\\n                low = cut1 + 1\\n        \\n        return 0.0  # For both empty arrays\\n    \\n\\'\\'\\'\\nTime Complexity: O(log(n1))  \\nSpace Complexity: O(1)\\n\\'\\'\\'\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662,
                "title": "rainbowsecret-more-general-c-template-find-k-th-element-2-sorted-array-beats-99-19",
                "content": "The inspiring idea is simple, we just use the binary search idea to solve the problem.\\n\\nWe implement a general template.\\n\\nthe help function parameters mean for array1 and array1's target interval , array2 and array2's target interval.\\n\\nWe need to swap to ensure the array1 is shorter to make logic clean.\\n\\nThe binary analysis is similiar to the top voted solution.\\n\\n       if (nums1[mid1] < nums2[mid2]) \\n\\nWe can eliminate the \\n\\n       nums1[1...mid1-1]  and nums2[mid2+1...end]\\n\\nThe other side is similiar.\\n\\nThe complexity is of course O(log(M+N)).\\n\\nHere is the AC implementation\\n\\n    class Solution {\\n    public:\\n        double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            int n1=nums1.size(), n2=nums2.size();\\n            int count=n1+n2;\\n            /** odd-length **/\\n            if(count&0x1) \\n                return help(nums1, 0, n1, nums2, 0, n2, count/2+1);\\n            /** even-length **/\\n            else\\n                return (help(nums1, 0, n1, nums2, 0, n2, count/2+1)+help(nums1, 0, n1, nums2, 0, n2, count/2)) / 2.0;\\n            \\n        }\\n        \\n        \\n        int help(vector<int>& nums1, int s1, int e1, vector<int>& nums2, int s2, int e2, int k){\\n            int m=e1-s1, n=e2-s2;\\n            if(m>n)  return help(nums2, s2, e2, nums1, s1, e1, k);\\n            if(m==0)  return nums2[s2+k-1];\\n            if(k==1)  return min(nums1[s1], nums2[s2]);\\n            \\n            int t1=min(k/2, m), t2=k-t1;\\n            if(nums1[s1+t1-1] < nums2[s2+t2-1])\\n                return help(nums1, s1+t1, e1, nums2, s2, s2+t2, k-t1);\\n            else if(nums1[s1+t1-1] > nums2[s2+t2-1])\\n                return help(nums1, s1, s1+t1, nums2, s2+t2, e2, k-t2);\\n            else\\n                return nums1[s1+t1-1];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            int n1=nums1.size(), n2=nums2.size();\\n            int count=n1+n2;\\n            /** odd-length **/\\n            if(count&0x1) \\n                return help(nums1, 0, n1, nums2, 0, n2, count/2+1);\\n            /** even-length **/\\n            else\\n                return (help(nums1, 0, n1, nums2, 0, n2, count/2+1)+help(nums1, 0, n1, nums2, 0, n2, count/2)) / 2.0;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2775,
                "title": "c-implementation-o-log-m-n-with-vector-int-as-parameters",
                "content": "the parameters change for this  function these days. It needs vector<int> instead of int[]\\n\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        const int size_1 = nums1.size();\\n        const int size_2 = nums2.size();\\n        int k = (size_1 + size_2) / 2;\\n        int res1 = Kth(nums1.begin(), size_1, nums2.begin(), size_2, k+1);\\n        if ((size_1 + size_2) % 2 == 0) {\\n            int res2 = Kth(nums1.begin(), size_1, nums2.begin(), size_2, k);\\n            return ( (double) res1 + res2) / 2.0;\\n        }\\n        return res1;\\n    }\\n    private:\\n      typedef vector<int>::iterator Iter;\\n\\n      int  Kth(Iter start1, int size_1, Iter start2, int size_2, int kth) {\\n        if (size_1 > size_2) return Kth(start2 , size_2, start1, size_1, kth);\\n        if (size_1 == 0) return *(start2 + kth - 1);\\n        if (kth == 1) return min(*start1, *start2);\\n\\n        int index_1 = min(size_1, kth / 2);\\n        int index_2 = kth - index_1;\\n        if (*(start1 + index_1 - 1) > *(start2 + index_2 - 1)) \\n            return Kth(start1, size_1 ,start2 + index_2, size_2 - index_2, kth - index_2);\\n        return Kth(start1 + index_1, size_1 - index_1, start2, index_2, kth - index_1);\\n    }",
                "solutionTags": [],
                "code": "the parameters change for this  function these days. It needs vector<int> instead of int[]\\n\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        const int size_1 = nums1.size();\\n        const int size_2 = nums2.size();\\n        int k = (size_1 + size_2) / 2;\\n        int res1 = Kth(nums1.begin(), size_1, nums2.begin(), size_2, k+1);\\n        if ((size_1 + size_2) % 2 == 0) {\\n            int res2 = Kth(nums1.begin(), size_1, nums2.begin(), size_2, k);\\n            return ( (double) res1 + res2) / 2.0;\\n        }\\n        return res1;\\n    }\\n    private:\\n      typedef vector<int>::iterator Iter;\\n\\n      int  Kth(Iter start1, int size_1, Iter start2, int size_2, int kth) {\\n        if (size_1 > size_2) return Kth(start2 , size_2, start1, size_1, kth);\\n        if (size_1 == 0) return *(start2 + kth - 1);\\n        if (kth == 1) return min(*start1, *start2);\\n\\n        int index_1 = min(size_1, kth / 2);\\n        int index_2 = kth - index_1;\\n        if (*(start1 + index_1 - 1) > *(start2 + index_2 - 1)) \\n            return Kth(start1, size_1 ,start2 + index_2, size_2 - index_2, kth - index_2);\\n        return Kth(start1 + index_1, size_1 - index_1, start2, index_2, kth - index_1);\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 2685632,
                "title": "runtime-2ms-java-solution-optimized-approach",
                "content": "\\n    public int findKth(int[] nums1, int s1, int[] nums2, int s2, int k) {\\n        if (s1 >= nums1.length) {\\n            return nums2[s2 + k - 1];\\n        }    \\n        if (s2 >= nums2.length) {\\n            return nums1[s1 + k - 1];\\n        }\\n        if (k == 1) {\\n            return Math.min(nums1[s1], nums2[s2]);\\n        }\\n        int m1 = s1 + k / 2 - 1;\\n        int m2 = s2 + k / 2 - 1;\\n        int mid1 = 0;\\n        int mid2 = 0;\\n        if (m1 >= nums1.length) {\\n            mid1 = Integer.MAX_VALUE;\\n        }\\n        else {\\n            mid1 = nums1[m1];\\n        }\\n        if (m2 >= nums2.length) {\\n            mid2 = Integer.MAX_VALUE;\\n        }\\n        else {\\n            mid2 = nums2[m2];\\n        }\\n        if (mid1 < mid2) {\\n            return findKth(nums1, m1 + 1, nums2, s2, k - k/2);\\n        }\\n        else {\\n            return findKth(nums1, s1, nums2, m2 + 1, k - k/2);\\n        }\\n    }\\n\\tpublic double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n          int n = nums1.length + nums2.length;\\n        int one = findKth(nums1, 0, nums2, 0, (n + 1)/2);\\n        int two = findKth(nums1, 0, nums2, 0, (n + 2)/2);\\n        return ((double)one + (double)two )/ 2.0;\\n    }\\n\\n\\n\\t\\n\\n\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "\\n    public int findKth(int[] nums1, int s1, int[] nums2, int s2, int k) {\\n        if (s1 >= nums1.length) {\\n            return nums2[s2 + k - 1];\\n        }    \\n        if (s2 >= nums2.length) {\\n            return nums1[s1 + k - 1];\\n        }\\n        if (k == 1) {\\n            return Math.min(nums1[s1], nums2[s2]);\\n        }\\n        int m1 = s1 + k / 2 - 1;\\n        int m2 = s2 + k / 2 - 1;\\n        int mid1 = 0;\\n        int mid2 = 0;\\n        if (m1 >= nums1.length) {\\n            mid1 = Integer.MAX_VALUE;\\n        }\\n        else {\\n            mid1 = nums1[m1];\\n        }\\n        if (m2 >= nums2.length) {\\n            mid2 = Integer.MAX_VALUE;\\n        }\\n        else {\\n            mid2 = nums2[m2];\\n        }\\n        if (mid1 < mid2) {\\n            return findKth(nums1, m1 + 1, nums2, s2, k - k/2);\\n        }\\n        else {\\n            return findKth(nums1, s1, nums2, m2 + 1, k - k/2);\\n        }\\n    }\\n\\tpublic double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n          int n = nums1.length + nums2.length;\\n        int one = findKth(nums1, 0, nums2, 0, (n + 1)/2);\\n        int two = findKth(nums1, 0, nums2, 0, (n + 2)/2);\\n        return ((double)one + (double)two )/ 2.0;\\n    }\\n\\n\\n\\t\\n\\n\\n\\t\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 3096997,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int temp[nums1Size+nums2Size];\\n    int x =0;\\n        for (int i = 0 ; i<nums1Size+nums2Size ; i++){\\n            if (i < nums1Size)\\n               temp[i] = nums1[i];\\n            else\\n                temp[i] = nums2[x++];\\n\\n        }\\n        for(int i=0;i<nums1Size+nums2Size;i++){\\n            for(int j=i+1;j<nums1Size+nums2Size;j++){\\n                if(temp[i]>temp[j]){\\n                    int t= temp[i];\\n                    temp[i]=temp[j];\\n                    temp[j]=t;\\n                }\\n            }\\n        }\\n        if ((nums1Size+nums2Size) %2 ==0){\\n            int l = (nums1Size+nums2Size) /2;\\n            return (temp[l]+temp[l-1])/2.00;\\n        }\\n        else {\\n            return temp[(nums1Size+nums2Size)/2];\\n        }\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int temp[nums1Size+nums2Size];\\n    int x =0;\\n        for (int i = 0 ; i<nums1Size+nums2Size ; i++){\\n            if (i < nums1Size)\\n               temp[i] = nums1[i];\\n            else\\n                temp[i] = nums2[x++];\\n\\n        }\\n        for(int i=0;i<nums1Size+nums2Size;i++){\\n            for(int j=i+1;j<nums1Size+nums2Size;j++){\\n                if(temp[i]>temp[j]){\\n                    int t= temp[i];\\n                    temp[i]=temp[j];\\n                    temp[j]=t;\\n                }\\n            }\\n        }\\n        if ((nums1Size+nums2Size) %2 ==0){\\n            int l = (nums1Size+nums2Size) /2;\\n            return (temp[l]+temp[l-1])/2.00;\\n        }\\n        else {\\n            return temp[(nums1Size+nums2Size)/2];\\n        }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2672475,
                "title": "python-o-log-min-m-n-solution-with-full-working-explanation",
                "content": "# Optimal \\n```\\nclass Solution:  # Time: O(log(min(m, n))) and Space: O(n)\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        A, B = nums1, nums2\\n        total = len(nums1) + len(nums2)\\n        half = total // 2\\n\\n        if len(A) > len(B):    # for our solution we are assuming that B will be bigger than A, if it\\'s not given than make it\\n            A, B = B, A\\n\\n        l, r = 0, len(A) - 1   # we also assume that A is exactly half of B\\n\\n        while True:            # when any return statement is executed it will stop\\n            i = (l + r) // 2   # A[mid]\\n\\n            # B[mid] = total//2(divide by 2 will get us mid B ) - A[mid](if we sub A from total, B\\'s left) -\\n            # 2(to make it align with starting index 0 of A & B, else it will go out of bounds)\\n            j = half - i - 2\\n\\n            Aleft = A[i] if i >= 0 else float(\"-infinity\")  # if index i is in negative than assign -infinity to Aleft\\n            Aright = A[i + 1] if (i + 1) < len(A) else float(\"infinity\")  # if index i+1 is greater than the size of A assign infinity to Aright\\n            Bleft = B[j] if j >= 0 else float(\"-infinity\")  # if index j is in negative than assign -infinity to Bleft\\n            Bright = B[j + 1] if (j + 1) < len(B) else float(\"infinity\")  # if index j+1 is greater than the size of B assign infinity to Bright\\n\\n            # A = [1, 2, 3(left), 4(right), 5] and B = [1, 2, 3(left), 4(right), 5, 6, 7, 8]  # B = 6 - 2 - 2 = 2(i.e 0,1,2)\\n            if Aleft <= Bright and Bleft <= Aright:  # 3 <= 4 and 3 <= 4\\n                if total % 2:                                         # odd: min(4, 4)\\n                    return min(Aright, Bright) \\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2  # even: max(3, 3) + min(4, 4)  / 2\\n            elif Aleft > Bright:  # A = [1, 2, 3(left), 4(right), 5, 6] and B = [1, 2(left), 3(right), 4, 5]\\n                r = i - 1         # r = 3 - 1 = 2(i.e. index 0,1,2) --> A = [1, 2(L), 3(R), 4, 5, 6] and B = [1, 2, 3(L), 4(R), 5, 6]\\n            else:                 # when Bleft > Aright, we will increase l so L becomes R, and R pointer is shifted to R+1 index\\n                l = i + 1\\n```\\nFor example,\\nLet **nums1 = [1, 3] & nums2 = [2]**\\n1. A, B = [1, 3], [2]\\n1. total = 3\\n1. half = 3 // 2 = 1\\n1. if len(A)=2 > len(B)=1 =  True: A, B = [2], [1, 3]\\n1. l, r = 0, 1-1=0\\n1. while True:\\n* i = (0 + 0) // 2 = 0\\n* j = 1 - 0 - 2 = -1\\n* Aleft = if 0 >= 0 = True: A[0] = 2  \\n* Aright = if (0 + 1) < len(A) = False --> else float(\"infinity\") = infinity\\n* Bleft = if -1 >= 0 = False --> else: float(\"-infinity\") = -infinity\\n* Bright = if (-1+1=0) < len(B)=2 = True: B[-1+1=0] = 1 \\n* if 2 <= 1 and -infinity <= infinity =  False and True = False\\n* elif 2 > 1 = True: r = 0 - 1 = -1\\n\\n7. while True:\\n* i = (0 + -1) // 2 = -1\\n* j = 1 - (-1) - 2 = 0\\n* Aleft = if -1 >= 0 = False --> else: float(\"-infinity\") = -infinity\\n* Aright = if (-1 + 1)=0 < len(A)=1 = True: A[-1+1] = 2\\n* Bleft = if 0 >= 0 = True: B[0] = 1\\n* Bright = if 0+1=1 < len(B)=2 = True: B[0+1=1] = 3 \\n* if -infinity <= 3 and 1 <= 2 =  True and True = True: \\n  * if 3 % 2 = 1 = True --> return  min(2, 3) = **Returns 2**\\n\\n# Easy Non-Optimal \\n```\\nclass Solution:  # Time: O(NLogN) and Space: O(1)\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        nums1 = nums1 + nums2\\n        nums1 = sorted(nums1)\\n        n = len(nums1)\\n        if n % 2 == 0:\\n            return (nums1[n//2 - 1] + nums1[(n//2)])/2 \\n        else:\\n            n = math.ceil(n/2)\\n            return nums1[n-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:  # Time: O(log(min(m, n))) and Space: O(n)\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        A, B = nums1, nums2\\n        total = len(nums1) + len(nums2)\\n        half = total // 2\\n\\n        if len(A) > len(B):    # for our solution we are assuming that B will be bigger than A, if it\\'s not given than make it\\n            A, B = B, A\\n\\n        l, r = 0, len(A) - 1   # we also assume that A is exactly half of B\\n\\n        while True:            # when any return statement is executed it will stop\\n            i = (l + r) // 2   # A[mid]\\n\\n            # B[mid] = total//2(divide by 2 will get us mid B ) - A[mid](if we sub A from total, B\\'s left) -\\n            # 2(to make it align with starting index 0 of A & B, else it will go out of bounds)\\n            j = half - i - 2\\n\\n            Aleft = A[i] if i >= 0 else float(\"-infinity\")  # if index i is in negative than assign -infinity to Aleft\\n            Aright = A[i + 1] if (i + 1) < len(A) else float(\"infinity\")  # if index i+1 is greater than the size of A assign infinity to Aright\\n            Bleft = B[j] if j >= 0 else float(\"-infinity\")  # if index j is in negative than assign -infinity to Bleft\\n            Bright = B[j + 1] if (j + 1) < len(B) else float(\"infinity\")  # if index j+1 is greater than the size of B assign infinity to Bright\\n\\n            # A = [1, 2, 3(left), 4(right), 5] and B = [1, 2, 3(left), 4(right), 5, 6, 7, 8]  # B = 6 - 2 - 2 = 2(i.e 0,1,2)\\n            if Aleft <= Bright and Bleft <= Aright:  # 3 <= 4 and 3 <= 4\\n                if total % 2:                                         # odd: min(4, 4)\\n                    return min(Aright, Bright) \\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2  # even: max(3, 3) + min(4, 4)  / 2\\n            elif Aleft > Bright:  # A = [1, 2, 3(left), 4(right), 5, 6] and B = [1, 2(left), 3(right), 4, 5]\\n                r = i - 1         # r = 3 - 1 = 2(i.e. index 0,1,2) --> A = [1, 2(L), 3(R), 4, 5, 6] and B = [1, 2, 3(L), 4(R), 5, 6]\\n            else:                 # when Bleft > Aright, we will increase l so L becomes R, and R pointer is shifted to R+1 index\\n                l = i + 1\\n```\n```\\nclass Solution:  # Time: O(NLogN) and Space: O(1)\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        nums1 = nums1 + nums2\\n        nums1 = sorted(nums1)\\n        n = len(nums1)\\n        if n % 2 == 0:\\n            return (nums1[n//2 - 1] + nums1[(n//2)])/2 \\n        else:\\n            n = math.ceil(n/2)\\n            return nums1[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025295,
                "title": "javascript-without-extra-array-95-99-video",
                "content": "Loop through half of the total number of elements, plus one (so odd length arrays, e.g. `[1,2,3]` get an even number of iterations, to get the mid element). \\n\\n  *Note:* When the number of elements is even, we will loop *past* the midpoint, so `[4,5] [6,7]` we would have three iterations, then we would take the average of the last iteration and the iteration prior to that, in this case, between `6` and `5`.\\n\\n\\n*Finally:\\u2014*\\n\\n if the total length is odd, take the last iterated value, \\n else, take the average between the last iterated value and the next lowest element, `beforeLast`. \\n\\n```\\nconst findMedianSortedArrays = (nums1, nums2) => {\\n    \"use strict\";\\n    const LEN = nums1.length + nums2.length;\\n    const IS_ODD = LEN % 2 === 1;\\n    const PAST_MID = 1 + (LEN / 2) | 0;\\n    const MAX_NUM = 10E5;\\n    \\n    let j = 0, k = 0, last, beforeLast;\\n    do {\\n        beforeLast = last;\\n        last = nums1[j] < (nums2[k]??MAX_NUM) ? nums1[j++] : nums2[k++];\\n    } while (j + k !== PAST_MID);\\n    return IS_ODD ? last : (last + beforeLast) / 2;\\n};\\n```\\n[Nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator), `??`, handles the case for choosing the lesser between `nums1[j]` and `nums2[k]` where `nums2[k]` is `undefined` and we want `nums1[j]`.\\n```\\n(nums1[j] < (nums2[k]??MAX_NUM)) \\n```\\nThis is distinct from `(nums1[j] < (nums2[k]||MAX_NUM))`. The expression `(nums1[j] < (nums2[k]||MAX_NUM))` is true when `nums2[k]` is 0 and `nums1[j]` is greater than 0 \\u2014 a true value, and not what we want!\\n\\nHere, we want to use `nums1[j]` only when *a.* `nums2[k]` is a number, and *b.* `nums1[j]` is less than `nums2[k]`. Comparing  `nums1[j] < undefined` will always be false (not what we want), hence, we default to `MAX_NUM` when `nums2[k]` is `undefined`.\\n\\n`MAX_NUM = 10E5` is defined by the requirements, which states `-106 <= nums1[i], nums2[i] <= 106`\\n  \\n# *Update* # \\n*Updated `MID` to be one past `array.length/2`. This allows `i` to be replaced with   `j + k`.*\\n\\n*Because `j` and  `k` count from at `0` and `MID` is calculated from `array.length`, the midpoint element at `j + k` is always 1 less than `array.length`. Thus, add one to `MID` and rename it, `PAST_MID = 1 + (LEN / 2) | 0`.*\\n\\nEach iteration, advance on the array whose next element has the lower value.\\n\\nhttps://www.youtube.com/watch?v=3NklJ3pPxm0&list=PL0Lnl_Y4OkS-OeQ7_qjqmV-ELiEmYieaT&index=7&t=186s",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findMedianSortedArrays = (nums1, nums2) => {\\n    \"use strict\";\\n    const LEN = nums1.length + nums2.length;\\n    const IS_ODD = LEN % 2 === 1;\\n    const PAST_MID = 1 + (LEN / 2) | 0;\\n    const MAX_NUM = 10E5;\\n    \\n    let j = 0, k = 0, last, beforeLast;\\n    do {\\n        beforeLast = last;\\n        last = nums1[j] < (nums2[k]??MAX_NUM) ? nums1[j++] : nums2[k++];\\n    } while (j + k !== PAST_MID);\\n    return IS_ODD ? last : (last + beforeLast) / 2;\\n};\\n```\n```\\n(nums1[j] < (nums2[k]??MAX_NUM)) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282809,
                "title": "javascript-beats-100-binarysearch",
                "content": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    if(nums1.length > nums2.length) return findMedianSortedArrays(nums2, nums1);\\n    \\n    const x = nums1.length, y = nums2.length;\\n    let lo = 0, hi = x;\\n    \\n    while(lo <= hi) {\\n        let partitionX = (lo + hi) / 2 | 0,\\n            partitionY = (x + y + 1) / 2 - partitionX | 0;\\n        \\n        let maxLeftX = partitionX === 0 ? -Infinity : nums1[partitionX - 1];\\n        let minRightX = partitionX === x ? Infinity : nums1[partitionX];\\n        \\n        let maxLeftY = partitionY === 0 ? -Infinity : nums2[partitionY - 1];\\n        let minRightY = partitionY === y ? Infinity : nums2[partitionY];\\n        \\n        if(maxLeftX <= minRightY && maxLeftY <= minRightX) {\\n            if((x + y) & 1) return Math.max(maxLeftX, maxLeftY);\\n            return (Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\\n        } else if(maxLeftX > minRightY) {\\n            hi = partitionX - 1;\\n        } else {\\n            lo = partitionX + 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    if(nums1.length > nums2.length) return findMedianSortedArrays(nums2, nums1);\\n    \\n    const x = nums1.length, y = nums2.length;\\n    let lo = 0, hi = x;\\n    \\n    while(lo <= hi) {\\n        let partitionX = (lo + hi) / 2 | 0,\\n            partitionY = (x + y + 1) / 2 - partitionX | 0;\\n        \\n        let maxLeftX = partitionX === 0 ? -Infinity : nums1[partitionX - 1];\\n        let minRightX = partitionX === x ? Infinity : nums1[partitionX];\\n        \\n        let maxLeftY = partitionY === 0 ? -Infinity : nums2[partitionY - 1];\\n        let minRightY = partitionY === y ? Infinity : nums2[partitionY];\\n        \\n        if(maxLeftX <= minRightY && maxLeftY <= minRightX) {\\n            if((x + y) & 1) return Math.max(maxLeftX, maxLeftY);\\n            return (Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\\n        } else if(maxLeftX > minRightY) {\\n            hi = partitionX - 1;\\n        } else {\\n            lo = partitionX + 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169862,
                "title": "java-binary-search-beats-99-82",
                "content": "```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int m = nums1.length;\\n        int n = nums2.length;\\n        int sum = m + n;\\n        if (sum % 2 == 0) {\\n            return (findKth(nums1, 0, nums2, 0, sum / 2) + findKth(nums1, 0, nums2, 0, sum / 2 + 1)) / 2.0;\\n        } else {\\n            return findKth(nums1, 0, nums2, 0, sum / 2 + 1) * 1.0;\\n        }\\n    }\\n    \\n    private int findKth(int[] a, int startA, int[] b, int startB, int k) {\\n        if (startA >= a.length) {\\n            return b[startB + k - 1];\\n        }\\n        if (startB >= b.length) {\\n            return a[startA + k - 1];\\n        }\\n        if (k == 1) {\\n            return Math.min(a[startA], b[startB]);\\n        }\\n        // start to throw away k/2 length array in either a or b\\n        int midA = (startA + k / 2 - 1 >= a.length) ? Integer.MAX_VALUE : a[startA + k / 2 - 1];\\n        int midB = (startB + k / 2 - 1 >= b.length) ? Integer.MAX_VALUE : b[startB + k / 2 - 1];\\n        if (midA > midB) {\\n            return findKth(a, startA, b, startB + k / 2, k - k / 2);\\n        } else {\\n            return findKth(a, startA + k / 2, b, startB, k - k / 2);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int m = nums1.length;\\n        int n = nums2.length;\\n        int sum = m + n;\\n        if (sum % 2 == 0) {\\n            return (findKth(nums1, 0, nums2, 0, sum / 2) + findKth(nums1, 0, nums2, 0, sum / 2 + 1)) / 2.0;\\n        } else {\\n            return findKth(nums1, 0, nums2, 0, sum / 2 + 1) * 1.0;\\n        }\\n    }\\n    \\n    private int findKth(int[] a, int startA, int[] b, int startB, int k) {\\n        if (startA >= a.length) {\\n            return b[startB + k - 1];\\n        }\\n        if (startB >= b.length) {\\n            return a[startA + k - 1];\\n        }\\n        if (k == 1) {\\n            return Math.min(a[startA], b[startB]);\\n        }\\n        // start to throw away k/2 length array in either a or b\\n        int midA = (startA + k / 2 - 1 >= a.length) ? Integer.MAX_VALUE : a[startA + k / 2 - 1];\\n        int midB = (startB + k / 2 - 1 >= b.length) ? Integer.MAX_VALUE : b[startB + k / 2 - 1];\\n        if (midA > midB) {\\n            return findKth(a, startA, b, startB + k / 2, k - k / 2);\\n        } else {\\n            return findKth(a, startA + k / 2, b, startB, k - k / 2);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143837,
                "title": "c-81ms",
                "content": "#### C++\\uFF1A\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int total = nums1.size() + nums2.size();\\n        if (total % 2 == 0)\\n        {\\n            int left = findKthNumber(nums1, 0, nums2, 0, total / 2);\\n            int right = findKthNumber(nums1, 0, nums2, 0, total / 2 + 1);\\n            return (left + right) / 2.0;\\n        }\\n        else\\n        {\\n            return findKthNumber(nums1, 0, nums2, 0, total / 2 + 1);\\n        }\\n    }\\n    \\n    int findKthNumber(vector<int> &nums1, int i, vector<int> &nums2, int j, int k)\\n    {\\n        if (nums1.size() - i > nums2.size() - j) return findKthNumber(nums2, j, nums1, i, k);\\n        if (nums1.size() == i) return nums2[j + k - 1];\\n        if (k == 1) return min(nums1[i], nums2[j]);\\n        int si = min(i + k / 2, int(nums1.size())), sj = j + k / 2;\\n        if (nums1[si - 1] > nums2[sj - 1])\\n        {\\n            return findKthNumber(nums1, i, nums2, j + k / 2, k - k / 2);\\n        }\\n        else\\n        {\\n            return findKthNumber(nums1, si, nums2, j, k - (si - i));\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int total = nums1.size() + nums2.size();\\n        if (total % 2 == 0)\\n        {\\n            int left = findKthNumber(nums1, 0, nums2, 0, total / 2);\\n            int right = findKthNumber(nums1, 0, nums2, 0, total / 2 + 1);\\n            return (left + right) / 2.0;\\n        }\\n        else\\n        {\\n            return findKthNumber(nums1, 0, nums2, 0, total / 2 + 1);\\n        }\\n    }\\n    \\n    int findKthNumber(vector<int> &nums1, int i, vector<int> &nums2, int j, int k)\\n    {\\n        if (nums1.size() - i > nums2.size() - j) return findKthNumber(nums2, j, nums1, i, k);\\n        if (nums1.size() == i) return nums2[j + k - 1];\\n        if (k == 1) return min(nums1[i], nums2[j]);\\n        int si = min(i + k / 2, int(nums1.size())), sj = j + k / 2;\\n        if (nums1[si - 1] > nums2[sj - 1])\\n        {\\n            return findKthNumber(nums1, i, nums2, j + k / 2, k - k / 2);\\n        }\\n        else\\n        {\\n            return findKthNumber(nums1, si, nums2, j, k - (si - i));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788,
                "title": "a-c-solution-with-o-log-m-n",
                "content": "\\n\\n    class Solution {\\n    public:\\n        //get the kth number of two sorted array\\n        double findkth(vector<int>::iterator a,int m,\\n                    vector<int>::iterator b,int n,\\n                    int k)\\n        {\\n            if(m >  n)\\n                return findkth(b,n,a,m,k);\\n            if(m == 0)\\n                return b[k-1];\\n            if(k == 1)\\n                return min(*a,*b);\\n    \\n            int pa = min(k/2,m),pb = k - pa;\\n            if(*(a + pa - 1) < *(b + pb -1))\\n                return findkth(a+pa,m-pa,b,n,k-pa);\\n            else if(*(a + pa -1) > *(b + pb -1))\\n                return findkth(a,m,b+pb,n-pb,k-pb);\\n            else\\n                return *(a+pa-1);\\n        }\\n        \\n        double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            vector<int>::iterator a = nums1.begin();\\n            vector<int>::iterator b = nums2.begin();\\n            int total = nums1.size() + nums2.size();\\n            \\n            // judge the total num of two arrays is odd or even\\n            if(total & 0x1)\\n                return findkth(a,nums1.size(),\\n                               b,nums2.size(),\\n                               total/2+1);\\n            else\\n                return (findkth(a,nums1.size(),\\n                               b,nums2.size(),\\n                               total/2) +\\n                        findkth(a,nums1.size(),\\n                                b,nums2.size(),\\n                                total/2 + 1))/2;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        //get the kth number of two sorted array\\n        double findkth(vector<int>::iterator a,int m,\\n                    vector<int>::iterator b,int n,\\n                    int k)\\n        {\\n            if(m >  n)\\n                return findkth(b,n,a,m,k);\\n            if(m == 0)\\n                return b[k-1];\\n            if(k == 1)\\n                return min(*a,*b);\\n    \\n            int pa = min(k/2,m),pb = k - pa;\\n            if(*(a + pa - 1) < *(b + pb -1))\\n                return findkth(a+pa,m-pa,b,n,k-pa);\\n            else if(*(a + pa -1) > *(b + pb -1))\\n                return findkth(a,m,b+pb,n-pb,k-pb);\\n            else\\n                return *(a+pa-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2922927,
                "title": "java-optimization-to-traditional-approach-2ms-100",
                "content": "PLS UPVOTE IF YOU FIND THIS HELPFUL, THANKS!\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Intuition of traditional approach has been talked about in too many posts, will not be repeated here.\\n- The only optimization in Example, say:\\n    - array a1 has length of 101\\n    - array a2 has length of 10\\n    - So, total length is 111\\n    - Median is 56th smallest element\\n    - half of it is 28\\n    - Because, a2.length < 28, traditional approach will just throw away 28 elements from a1\\n    - instead we could\\n        - calculate 56-10=46 and then\\n        - compare 10th element in a2 vs 46th element in a1, we either\\n        - get rid of 10 from a2, then next round we get answer from a1, or\\n        - get rid of 46 from a1, that\\'s more than 28, thus the improvement\\n            - The improvement is not significant enough to change the TC/SC, this is just for fun.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: (m+n)log(m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public double findMedianSortedArrays(int[] a1, int[] a2) {\\n        int m = a1.length, n = a2.length, len = m + n;\\n        int k = len / 2;\\n        int x = find(a1, a2, 0, 0, k+1);\\n        if (len % 2 == 1) return (double) x;\\n\\n        return ((double) x + find(a1, a2, 0, 0, k)) / 2;\\n    }\\n\\n    private int find(int[] a1, int[] a2, int i, int j, int k) { // i: idx for a1, j: idx for a2\\n        if (i == a1.length) return a2[j+k-1]; // corner case 1\\n        if (j == a2.length) return a1[i+k-1]; // corner case 2\\n        if (k == 1) return Math.min(a1[i], a2[j]); // corner case 3\\n\\n        int d1 = k / 2, d2 = k - d1; // delta 1 vs delta 2\\n        if (i+d1 > a1.length) { // if a1 side is out of bound, we can get rid of more from a2 side\\n            d1 = a1.length-i;\\n            d2 = k - d1;\\n        } else if (j + d2 > a2.length) { // if a2 side is out of bound, we can get rid of more from a1 side\\n            d2 = a2.length - j;\\n            d1 = k - d2;\\n        }\\n\\n        int i2 = i + d1 -1, j2 = j + d2 - 1;\\n\\n        return a1[i2] > a2[j2] ? find(a1, a2, i, j2+1, d1) : find(a1, a2, i2+1, j, d2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```java\\nclass Solution {\\n    public double findMedianSortedArrays(int[] a1, int[] a2) {\\n        int m = a1.length, n = a2.length, len = m + n;\\n        int k = len / 2;\\n        int x = find(a1, a2, 0, 0, k+1);\\n        if (len % 2 == 1) return (double) x;\\n\\n        return ((double) x + find(a1, a2, 0, 0, k)) / 2;\\n    }\\n\\n    private int find(int[] a1, int[] a2, int i, int j, int k) { // i: idx for a1, j: idx for a2\\n        if (i == a1.length) return a2[j+k-1]; // corner case 1\\n        if (j == a2.length) return a1[i+k-1]; // corner case 2\\n        if (k == 1) return Math.min(a1[i], a2[j]); // corner case 3\\n\\n        int d1 = k / 2, d2 = k - d1; // delta 1 vs delta 2\\n        if (i+d1 > a1.length) { // if a1 side is out of bound, we can get rid of more from a2 side\\n            d1 = a1.length-i;\\n            d2 = k - d1;\\n        } else if (j + d2 > a2.length) { // if a2 side is out of bound, we can get rid of more from a1 side\\n            d2 = a2.length - j;\\n            d1 = k - d2;\\n        }\\n\\n        int i2 = i + d1 -1, j2 = j + d2 - 1;\\n\\n        return a1[i2] > a2[j2] ? find(a1, a2, i, j2+1, d1) : find(a1, a2, i2+1, j, d2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089907,
                "title": "c-c-simple-solution-easy-to-understand",
                "content": "This problem can be solved by considering odd-lengthed and even-lengthed arrays as two different cases and treat them separately. Another approach can be combining both cases into one case to get the result..\\n```C++ []\\nclass Solution {\\npublic:\\n    double median(vector<int>& a, vector<int>& b, int s1, int e1, int s2, int e2, int tar){\\n        int la, lb, ma, mb, m = max(e1 - s1 + 1,0), n = max(e2 - s2 + 1,0), ans;\\n        if(!m) return b[s2 + tar];\\n        if(!n) return a[s1 + tar];        \\n        la = m/2;\\n        lb = n/2;\\n        ma = a[s1 + la];\\n        mb = b[s2 + lb];        \\n        if (la + lb >= tar) {\\n            if (ma > mb) ans = median(a,b,s1,s1 + la - 1,s2,e2,tar);\\n            else ans = median(a,b,s1,e1,s2,s2 + lb - 1,tar);\\n        }\\n        else {\\n            if (ma > mb) ans = median(a,b,s1,e1,s2 + lb + 1,e2,tar - lb - 1);\\n            else ans = median(a,b,s1 + la + 1,e1,s2,e2,tar - la - 1);\\n        }\\n        return ans;\\n    }\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size(), n = nums2.size();\\n        if (!m) return n & 1 ? nums2[n / 2] : (nums2[n / 2 - 1] + nums2[n / 2]) / 2.0;\\n        if (!n) return m & 1 ? nums1[m / 2] : (nums1[m / 2 - 1] + nums1[m / 2]) / 2.0;        \\n        if ((m + n) & 1)\\n            return median(nums1,nums2,0,m-1,0,n-1,(m + n) / 2);        \\n        return (median(nums1,nums2,0,m-1,0,n-1,(m + n) / 2 - 1) + median(nums1,nums2,0,m-1,0,n-1,(m + n) / 2))/2.0;\\n    }\\n};\\n```\\n```csharp []\\n//1. Solution #1\\npublic class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\t\\t\\n        int[] ans = nums1.Concat(nums2).OrderBy(x => x).ToArray();\\n\\t\\tint n = ans.Length;\\n        decimal medianSorted;\\n        if (n % 2 !=0) medianSorted = ans[n / 2];\\n        else medianSorted = Decimal.Divide((ans[n / 2] + ans[(n - 1) / 2]), 2);\\n        return Convert.ToDouble(medianSorted);\\n    }\\n}\\n//2. Solution #2\\n//By combining both cases into one to get the result.\\npublic class Solution {\\n     public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int len1=nums1.Length;\\n        int len2=nums2.Length;\\n        if (len1<len2) return FindMedianSortedArrays(nums2,nums1);\\n\\t\\tint low=0, high=len2*2;\\n        while (low<=high) {\\n\\t\\t\\tint mid2=(low+high)/2;\\n            int mid1=len1+len2-mid2;\\n\\t\\t\\tdouble L1=(mid1==0)?Int32.MinValue:nums1[(mid1-1)/2];\\n            double L2=(mid2==0)?Int32.MinValue:nums2[(mid2-1)/2];\\n            double R1=(mid1==len1*2)?Int32.MaxValue:nums1[(mid1)/2];\\n            double R2=(mid2==len2*2)?Int32.MaxValue:nums2[(mid2)/2];\\n            if (L1>R2) low=mid2 + 1;\\n            else if(L2>R1) high=mid2-1;\\n            else return (Math.Max(L1,L2)+Math.Min(R1,R2))/2;\\n        }\\n      return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C#",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    double median(vector<int>& a, vector<int>& b, int s1, int e1, int s2, int e2, int tar){\\n        int la, lb, ma, mb, m = max(e1 - s1 + 1,0), n = max(e2 - s2 + 1,0), ans;\\n        if(!m) return b[s2 + tar];\\n        if(!n) return a[s1 + tar];        \\n        la = m/2;\\n        lb = n/2;\\n        ma = a[s1 + la];\\n        mb = b[s2 + lb];        \\n        if (la + lb >= tar) {\\n            if (ma > mb) ans = median(a,b,s1,s1 + la - 1,s2,e2,tar);\\n            else ans = median(a,b,s1,e1,s2,s2 + lb - 1,tar);\\n        }\\n        else {\\n            if (ma > mb) ans = median(a,b,s1,e1,s2 + lb + 1,e2,tar - lb - 1);\\n            else ans = median(a,b,s1 + la + 1,e1,s2,e2,tar - la - 1);\\n        }\\n        return ans;\\n    }\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size(), n = nums2.size();\\n        if (!m) return n & 1 ? nums2[n / 2] : (nums2[n / 2 - 1] + nums2[n / 2]) / 2.0;\\n        if (!n) return m & 1 ? nums1[m / 2] : (nums1[m / 2 - 1] + nums1[m / 2]) / 2.0;        \\n        if ((m + n) & 1)\\n            return median(nums1,nums2,0,m-1,0,n-1,(m + n) / 2);        \\n        return (median(nums1,nums2,0,m-1,0,n-1,(m + n) / 2 - 1) + median(nums1,nums2,0,m-1,0,n-1,(m + n) / 2))/2.0;\\n    }\\n};\\n```\n```csharp []\\n//1. Solution #1\\npublic class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\t\\t\\n        int[] ans = nums1.Concat(nums2).OrderBy(x => x).ToArray();\\n\\t\\tint n = ans.Length;\\n        decimal medianSorted;\\n        if (n % 2 !=0) medianSorted = ans[n / 2];\\n        else medianSorted = Decimal.Divide((ans[n / 2] + ans[(n - 1) / 2]), 2);\\n        return Convert.ToDouble(medianSorted);\\n    }\\n}\\n//2. Solution #2\\n//By combining both cases into one to get the result.\\npublic class Solution {\\n     public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int len1=nums1.Length;\\n        int len2=nums2.Length;\\n        if (len1<len2) return FindMedianSortedArrays(nums2,nums1);\\n\\t\\tint low=0, high=len2*2;\\n        while (low<=high) {\\n\\t\\t\\tint mid2=(low+high)/2;\\n            int mid1=len1+len2-mid2;\\n\\t\\t\\tdouble L1=(mid1==0)?Int32.MinValue:nums1[(mid1-1)/2];\\n            double L2=(mid2==0)?Int32.MinValue:nums2[(mid2-1)/2];\\n            double R1=(mid1==len1*2)?Int32.MaxValue:nums1[(mid1)/2];\\n            double R2=(mid2==len2*2)?Int32.MaxValue:nums2[(mid2)/2];\\n            if (L1>R2) low=mid2 + 1;\\n            else if(L2>R1) high=mid2-1;\\n            else return (Math.Max(L1,L2)+Math.Min(R1,R2))/2;\\n        }\\n      return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888693,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nfunction findMedianSortedArrays_(nums1: number[], nums2: number[]): number | undefined {\\n  const medianLocation = (nums1.length + nums2.length - 1) / 2\\n  const result = []\\n\\n  for (let i = 0, max = Math.max(nums1.length, nums2.length); i < max; i++) {\\n    result.push(nums1[i] > nums2[i] ? nums2[i] : nums1[i])\\n\\n    if (result.length > medianLocation) {\\n      return (\\n        (result[Math.floor(medianLocation)] +\\n          result[Math.ceil(medianLocation) + 1]) / 2\\n      )\\n    }\\n  }\\n}\\n\\nfunction findMedianSortedArrays(nums1: number[], nums2: number[]): number | undefined {\\n  const result = nums1.concat(nums2).sort((a, b) => a - b)\\n  const medianLocation = (result.length - 1) / 2\\n\\n  return ((result[Math.floor(medianLocation)] + result[Math.ceil(medianLocation)]) / 2)\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction findMedianSortedArrays_(nums1: number[], nums2: number[]): number | undefined {\\n  const medianLocation = (nums1.length + nums2.length - 1) / 2\\n  const result = []\\n\\n  for (let i = 0, max = Math.max(nums1.length, nums2.length); i < max; i++) {\\n    result.push(nums1[i] > nums2[i] ? nums2[i] : nums1[i])\\n\\n    if (result.length > medianLocation) {\\n      return (\\n        (result[Math.floor(medianLocation)] +\\n          result[Math.ceil(medianLocation) + 1]) / 2\\n      )\\n    }\\n  }\\n}\\n\\nfunction findMedianSortedArrays(nums1: number[], nums2: number[]): number | undefined {\\n  const result = nums1.concat(nums2).sort((a, b) => a - b)\\n  const medianLocation = (result.length - 1) / 2\\n\\n  return ((result[Math.floor(medianLocation)] + result[Math.ceil(medianLocation)]) / 2)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309837,
                "title": "elegant-python-binary-search-o-log-min-m-n-o-1",
                "content": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        if len(nums2) < len(nums1): nums1, nums2 = nums2, nums1\\n        m, n = len(nums1), len(nums2)  \\n        \\n        left, right = 0, m-1\\n        while True:\\n            pointer1 = left + (right-left) // 2\\n            pointer2 = (m+n)//2 - pointer1 - 2\\n            \\n            left1 = nums1[pointer1] if pointer1 in range(m) else -math.inf\\n            left2 = nums2[pointer2] if pointer2 in range(n) else -math.inf\\n            right1 = nums1[pointer1+1] if pointer1+1 in range(m) else math.inf\\n            right2 = nums2[pointer2+1] if pointer2+1 in range(n) else math.inf\\n            \\n            if left1 <= right2 and left2 <= right1:\\n                if (m+n) % 2 == 0: return (max(left1, left2) + min(right1, right2)) / 2\\n                else: return min(right1, right2)\\n                \\n            elif left1 > right2: right = pointer1 - 1\\n            else: left = pointer1 + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        if len(nums2) < len(nums1): nums1, nums2 = nums2, nums1\\n        m, n = len(nums1), len(nums2)  \\n        \\n        left, right = 0, m-1\\n        while True:\\n            pointer1 = left + (right-left) // 2\\n            pointer2 = (m+n)//2 - pointer1 - 2\\n            \\n            left1 = nums1[pointer1] if pointer1 in range(m) else -math.inf\\n            left2 = nums2[pointer2] if pointer2 in range(n) else -math.inf\\n            right1 = nums1[pointer1+1] if pointer1+1 in range(m) else math.inf\\n            right2 = nums2[pointer2+1] if pointer2+1 in range(n) else math.inf\\n            \\n            if left1 <= right2 and left2 <= right1:\\n                if (m+n) % 2 == 0: return (max(left1, left2) + min(right1, right2)) / 2\\n                else: return min(right1, right2)\\n                \\n            elif left1 > right2: right = pointer1 - 1\\n            else: left = pointer1 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249025,
                "title": "simple-c-solution-using-binary-search-with-explanation",
                "content": "```\\n// https://leetcode.com/problems/median-of-two-sorted-arrays/\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        // make sure first array is of smaller length i.e n1 < n2\\n        if(n1 > n2) return findMedianSortedArrays(nums2, nums1);\\n        int low = 0;\\n        int high = n1;\\n        while(low <= high)\\n        {\\n            int mid1 = (low + high) / 2;\\n            // works for both odd and even lengths\\n            int mid2 = (n1 + n2 + 1) / 2 - mid1;\\n            // we create two search spaces for applying binary search. left half and right half have elements \\n            // from both the arrays. left1 & right1 have elements from nums1 and  left2 & right2 have elements from nums2\\n            // left half should be smaller than right half\\n            // l1 is max of left1 list, l2 is max of left2 list\\n            // r1 is min of right1 list, r2 is min of right2 list\\n            int l1 = (mid1 - 1 < 0) ? INT_MIN : nums1[mid1 - 1];\\n            int l2 = (mid2 - 1 < 0) ? INT_MIN : nums2[mid2 - 1];\\n            int r1 = (mid1 == n1) ? INT_MAX : nums1[mid1];\\n            int r2 = (mid2 == n2) ? INT_MAX : nums2[mid2];\\n            // correct partioning\\n            if(l1 <= r2 && l2 <= r1)\\n            {\\n                // even length -> two medians -> return average of both\\n                if((n1 + n2) % 2 == 0) return (max(l1, l2) + min(r1, r2)) / 2.0;\\n                // odd length -> one median -> return it\\n                else return max(l1, l2);  \\n            }\\n            if(l1 > r2)\\n            {\\n                high = mid1 - 1;\\n            }\\n            if(l2 > r1)\\n            {\\n                low = mid1 + 1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// https://leetcode.com/problems/median-of-two-sorted-arrays/\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        // make sure first array is of smaller length i.e n1 < n2\\n        if(n1 > n2) return findMedianSortedArrays(nums2, nums1);\\n        int low = 0;\\n        int high = n1;\\n        while(low <= high)\\n        {\\n            int mid1 = (low + high) / 2;\\n            // works for both odd and even lengths\\n            int mid2 = (n1 + n2 + 1) / 2 - mid1;\\n            // we create two search spaces for applying binary search. left half and right half have elements \\n            // from both the arrays. left1 & right1 have elements from nums1 and  left2 & right2 have elements from nums2\\n            // left half should be smaller than right half\\n            // l1 is max of left1 list, l2 is max of left2 list\\n            // r1 is min of right1 list, r2 is min of right2 list\\n            int l1 = (mid1 - 1 < 0) ? INT_MIN : nums1[mid1 - 1];\\n            int l2 = (mid2 - 1 < 0) ? INT_MIN : nums2[mid2 - 1];\\n            int r1 = (mid1 == n1) ? INT_MAX : nums1[mid1];\\n            int r2 = (mid2 == n2) ? INT_MAX : nums2[mid2];\\n            // correct partioning\\n            if(l1 <= r2 && l2 <= r1)\\n            {\\n                // even length -> two medians -> return average of both\\n                if((n1 + n2) % 2 == 0) return (max(l1, l2) + min(r1, r2)) / 2.0;\\n                // odd length -> one median -> return it\\n                else return max(l1, l2);  \\n            }\\n            if(l1 > r2)\\n            {\\n                high = mid1 - 1;\\n            }\\n            if(l2 > r1)\\n            {\\n                low = mid1 + 1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023126,
                "title": "c-binary-search-o-log-min-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    double getMed(vector<int>a1, vector<int>a2, int n, int m)\\n    {\\n        int l = 0, h = n;\\n        int total=n+m;\\n        while(l<=m)\\n        {\\n            int i = (l + h) / 2;\\n            int j = (total + 1) / 2 - i;\\n\\n            int min1 = (i == n)?INT_MAX:a1[i];\\n            int max1 = (i == 0)?INT_MIN:a1[i - 1];\\n\\n            int min2 = (j == m)?INT_MAX:a2[j];\\n            int max2 = (j == 0)?INT_MIN:a2[j - 1];\\n\\n            if(max1 <= min2 && max2 <= min1)\\n            {\\n                if((total) % 2 == 0)\\n                    return ((double)max(max1, max2) + min(min1, min2)) / 2;\\n                else\\n                    return (double)max(max1, max2);\\n            }\\n            else if(max1 > min2)\\n                h = i - 1;\\n            else \\n                l = i + 1;\\n        }\\n        \\n        return 0.0;\\n    }\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(), m=nums2.size();\\n        if(n==0 && m==0)\\n            return 0;\\n        if(n==0)\\n        {\\n            if(m%2)\\n                return nums2[m/2];\\n            else\\n                return (double)(nums2[m/2-1]+nums2[m/2])/2;\\n        }\\n        \\n        if(m==0)\\n        {\\n            if(n%2)\\n                return nums1[n/2];\\n            else\\n                return (double)(nums1[n/2-1]+nums1[n/2])/2;\\n        }\\n        \\n        if(n<m)\\n            return getMed(nums1,nums2,n,m);\\n        else\\n            return getMed(nums2,nums1,m,n);\\n           \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    double getMed(vector<int>a1, vector<int>a2, int n, int m)\\n    {\\n        int l = 0, h = n;\\n        int total=n+m;\\n        while(l<=m)\\n        {\\n            int i = (l + h) / 2;\\n            int j = (total + 1) / 2 - i;\\n\\n            int min1 = (i == n)?INT_MAX:a1[i];\\n            int max1 = (i == 0)?INT_MIN:a1[i - 1];\\n\\n            int min2 = (j == m)?INT_MAX:a2[j];\\n            int max2 = (j == 0)?INT_MIN:a2[j - 1];\\n\\n            if(max1 <= min2 && max2 <= min1)\\n            {\\n                if((total) % 2 == 0)\\n                    return ((double)max(max1, max2) + min(min1, min2)) / 2;\\n                else\\n                    return (double)max(max1, max2);\\n            }\\n            else if(max1 > min2)\\n                h = i - 1;\\n            else \\n                l = i + 1;\\n        }\\n        \\n        return 0.0;\\n    }\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(), m=nums2.size();\\n        if(n==0 && m==0)\\n            return 0;\\n        if(n==0)\\n        {\\n            if(m%2)\\n                return nums2[m/2];\\n            else\\n                return (double)(nums2[m/2-1]+nums2[m/2])/2;\\n        }\\n        \\n        if(m==0)\\n        {\\n            if(n%2)\\n                return nums1[n/2];\\n            else\\n                return (double)(nums1[n/2-1]+nums1[n/2])/2;\\n        }\\n        \\n        if(n<m)\\n            return getMed(nums1,nums2,n,m);\\n        else\\n            return getMed(nums2,nums1,m,n);\\n           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 255538,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {\\n      guard nums1.count <= nums2.count  else {\\n\\t\\t\\treturn findMedianSortedArrays(nums2, nums1)\\n\\t\\t}\\n\\t\\t\\n\\t\\tlet m = nums1.count, n = nums2.count\\n\\t\\tvar start = 0, end = m\\n\\t\\t\\n\\t\\twhile start <= end {\\n\\t\\t\\tlet cutPos1 = (start + end)/2\\n\\t\\t\\tlet cutPos2 = (m + n + 1)/2 - cutPos1\\n\\t\\t\\t\\n\\t\\t\\t// If cutPos1 == 0, nothing in array1 is there on the left,\\n\\t\\t\\t// use Int.min for maxLeft1\\n\\t\\t\\t// If cutPos1 == m, nothing in array1 is there on the right,\\n\\t\\t\\t// use Int.max for minRight1\\n\\t\\t\\tlet maxLeft1 = cutPos1 == 0 ? Int.min : nums1[cutPos1-1]\\n\\t\\t\\tlet minRight1 = cutPos1 == m ? Int.max : nums1[cutPos1]\\n\\t\\t\\t\\n\\t\\t\\tlet maxLeft2 = cutPos2 == 0 ? Int.min : nums2[cutPos2-1]\\n\\t\\t\\tlet minRight2 = cutPos2 == n ? Int.max : nums2[cutPos2]\\n\\t\\t\\t\\n\\t\\t\\tif maxLeft1 <= minRight2, maxLeft2 <= minRight1 {\\n\\t\\t\\t\\t// We have partitioned both array at correct place\\n\\t\\t\\t\\tif (m + n) % 2 == 0 {\\n\\t\\t\\t\\t\\treturn Double(max(maxLeft1, maxLeft2) + min(minRight1, minRight2))/2.0\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn Double(max(maxLeft1, maxLeft2))\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if maxLeft1 > minRight2 {\\n\\t\\t\\t\\t// We are too far on right side for cutPos1, go left side\\n\\t\\t\\t\\tend = cutPos1 - 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// We are too far on left side for cutPos1, go right side\\n\\t\\t\\t\\tstart = cutPos1 + 1\\n\\t\\t\\t}\\n\\t\\t}\\n      return -1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {\\n      guard nums1.count <= nums2.count  else {\\n\\t\\t\\treturn findMedianSortedArrays(nums2, nums1)\\n\\t\\t}\\n\\t\\t\\n\\t\\tlet m = nums1.count, n = nums2.count\\n\\t\\tvar start = 0, end = m\\n\\t\\t\\n\\t\\twhile start <= end {\\n\\t\\t\\tlet cutPos1 = (start + end)/2\\n\\t\\t\\tlet cutPos2 = (m + n + 1)/2 - cutPos1\\n\\t\\t\\t\\n\\t\\t\\t// If cutPos1 == 0, nothing in array1 is there on the left,\\n\\t\\t\\t// use Int.min for maxLeft1\\n\\t\\t\\t// If cutPos1 == m, nothing in array1 is there on the right,\\n\\t\\t\\t// use Int.max for minRight1\\n\\t\\t\\tlet maxLeft1 = cutPos1 == 0 ? Int.min : nums1[cutPos1-1]\\n\\t\\t\\tlet minRight1 = cutPos1 == m ? Int.max : nums1[cutPos1]\\n\\t\\t\\t\\n\\t\\t\\tlet maxLeft2 = cutPos2 == 0 ? Int.min : nums2[cutPos2-1]\\n\\t\\t\\tlet minRight2 = cutPos2 == n ? Int.max : nums2[cutPos2]\\n\\t\\t\\t\\n\\t\\t\\tif maxLeft1 <= minRight2, maxLeft2 <= minRight1 {\\n\\t\\t\\t\\t// We have partitioned both array at correct place\\n\\t\\t\\t\\tif (m + n) % 2 == 0 {\\n\\t\\t\\t\\t\\treturn Double(max(maxLeft1, maxLeft2) + min(minRight1, minRight2))/2.0\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn Double(max(maxLeft1, maxLeft2))\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if maxLeft1 > minRight2 {\\n\\t\\t\\t\\t// We are too far on right side for cutPos1, go left side\\n\\t\\t\\t\\tend = cutPos1 - 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// We are too far on left side for cutPos1, go right side\\n\\t\\t\\t\\tstart = cutPos1 + 1\\n\\t\\t\\t}\\n\\t\\t}\\n      return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641,
                "title": "golang-concise-32ms-solution",
                "content": "beats 95% of golang solutions (although it very much differs whenever I run a submission)\\n\\n```\\nfunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\\n\\tif l := len(nums1) + len(nums2); l%2 == 0 {\\n\\t\\treturn (findKth(nums1, nums2, l/2-1) + findKth(nums1, nums2, l/2)) / 2.0\\n\\t} else {\\n\\t\\treturn findKth(nums1, nums2, l/2)\\n\\t}\\n}\\n\\nfunc findKth(nums1 []int, nums2 []int, k int) float64 {\\n\\tfor {\\n\\t\\tl1, l2 := len(nums1), len(nums2)\\n\\t\\tm1, m2 := l1/2, l2/2\\n\\n\\t\\tif l1 == 0 {\\n\\t\\t\\treturn float64(nums2[k])\\n\\t\\t} else if l2 == 0 {\\n\\t\\t\\treturn float64(nums1[k])\\n\\t\\t} else if k == 0 {\\n\\t\\t\\tif n1, n2 := nums1[0], nums2[0]; n1 <= n2 {\\n\\t\\t\\t\\treturn float64(n1)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn float64(n2)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif k <= m1+m2 {\\n\\t\\t\\tif nums1[m1] <= nums2[m2] {\\n\\t\\t\\t\\tnums2 = nums2[:m2]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnums1 = nums1[:m1]\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif nums1[m1] <= nums2[m2] {\\n\\t\\t\\t\\tnums1 = nums1[m1+1:]\\n\\t\\t\\t\\tk -= m1 + 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnums2 = nums2[m2+1:]\\n\\t\\t\\t\\tk -= m2 + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\\n\\tif l := len(nums1) + len(nums2); l%2 == 0 {\\n\\t\\treturn (findKth(nums1, nums2, l/2-1) + findKth(nums1, nums2, l/2)) / 2.0\\n\\t} else {\\n\\t\\treturn findKth(nums1, nums2, l/2)\\n\\t}\\n}\\n\\nfunc findKth(nums1 []int, nums2 []int, k int) float64 {\\n\\tfor {\\n\\t\\tl1, l2 := len(nums1), len(nums2)\\n\\t\\tm1, m2 := l1/2, l2/2\\n\\n\\t\\tif l1 == 0 {\\n\\t\\t\\treturn float64(nums2[k])\\n\\t\\t} else if l2 == 0 {\\n\\t\\t\\treturn float64(nums1[k])\\n\\t\\t} else if k == 0 {\\n\\t\\t\\tif n1, n2 := nums1[0], nums2[0]; n1 <= n2 {\\n\\t\\t\\t\\treturn float64(n1)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn float64(n2)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif k <= m1+m2 {\\n\\t\\t\\tif nums1[m1] <= nums2[m2] {\\n\\t\\t\\t\\tnums2 = nums2[:m2]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnums1 = nums1[:m1]\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif nums1[m1] <= nums2[m2] {\\n\\t\\t\\t\\tnums1 = nums1[m1+1:]\\n\\t\\t\\t\\tk -= m1 + 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnums2 = nums2[m2+1:]\\n\\t\\t\\t\\tk -= m2 + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808,
                "title": "variant-of-binary-search-in-c-14-ms-o-lg-m-n",
                "content": "Suppose the two arrays are A and B.\\nPerform the following variant of binary search first in A then B to find the median.\\n\\nStart from low = 0, high = |A|, guess i = floor (low + high)/2\\nFor the median m, there should be total half = floor (|A| + |B| + 1) / 2 elements not greater than it.\\nSince there are i + 1 elements not greater than A[i] in A,\\nThere should be half - (i + 1) elements not greater than A[i] in B.\\nDenote j = half - i - 2, thus we can compare if B[j] <= A[i] <= B[j + 1] is satisfied. This indicates\\nThat the guess is the correct median.\\n\\nOtherwise, we can easily tell if the guess is too small or too big, then halve the elements to adjust\\nthe guess.\\n\\n    #define min(x, y) (x < y ? x : y)\\n    \\n    int odd(int n) { return n & 0x1; }\\n    \\n    void swap(int *x, int *y) {\\n        int tmp = *x; *x = *y; *y = tmp;\\n    }\\n    \\n    /* meidan of an array */\\n    double medianof(int A[], int n) {\\n        return odd(n) ? (double) A[n / 2] : (double)(A[ n / 2] + A[n / 2 - 1]) / 2.0;\\n    }\\n    \\n    int find(int A[], int m, int B[], int n) {\\n        int l = 0, u = m;\\n        int i, j, half = (m + n + 1) / 2;\\n        if (!A || m == 0)\\n            return medianof(B, n);\\n        if (!B || n == 0)\\n            return medianof(A, m);\\n        while (l < u) {\\n            i = (l + u) / 2;\\n            j = half - i - 2;\\n            if (j < 0 || j >= n) {\\n                if (j == -1 && A[i] <= B[0])\\n                    return i; /* found */\\n                if (j >= n )\\n                    l = i + 1; /* too small */\\n                else\\n                    u = i; /* too big */\\n            } else {\\n                if (B[j]<= A[i] && (j == n - 1 || A[i] <= B[j+1]))\\n                    return i; /* found */\\n                else if (A[i] < B[j])\\n                    l = i + 1; /* too small */\\n                else\\n                    u = i; /* too big */\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    double findMedianSortedArrays(int A[], int m, int B[], int n) {\\n        int i, j, k, *C;\\n        if (!A || m == 0)\\n            return medianof(B, n);\\n        if (!B || n == 0)\\n            return medianof(A, m);\\n        if ((i = find(A, m, B, n)) == -1) {\\n            i = find(B, n, A, m);\\n            C = A; A = B; B = C;\\n            swap(&m, &n);\\n        }\\n        if (odd(m + n))\\n            return (double)A[i];\\n        j = (m + n) / 2 - i - 2;\\n        if (i == m - 1)\\n            k = B[j+1];\\n        else if (j == n - 1)\\n            k = A[i+1];\\n        else\\n            k = min(A[i+1], B[j+1]);\\n        return (double)(A[i] + k) / 2.0;\\n    }\\n\\nRegards.",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "Suppose the two arrays are A and B.\\nPerform the following variant of binary search first in A then B to find the median.\\n\\nStart from low = 0, high = |A|, guess i = floor (low + high)/2\\nFor the median m, there should be total half = floor (|A| + |B| + 1) / 2 elements not greater than it.\\nSince there are i + 1 elements not greater than A[i] in A,\\nThere should be half - (i + 1) elements not greater than A[i] in B.\\nDenote j = half - i - 2, thus we can compare if B[j] <= A[i] <= B[j + 1] is satisfied. This indicates\\nThat the guess is the correct median.\\n\\nOtherwise, we can easily tell if the guess is too small or too big, then halve the elements to adjust\\nthe guess.\\n\\n    #define min(x, y) (x < y ? x : y)\\n    \\n    int odd(int n) { return n & 0x1; }\\n    \\n    void swap(int *x, int *y) {\\n        int tmp = *x; *x = *y; *y = tmp;\\n    }\\n    \\n    /* meidan of an array */\\n    double medianof(int A[], int n) {\\n        return odd(n) ? (double) A[n / 2] : (double)(A[ n / 2] + A[n / 2 - 1]) / 2.0;\\n    }\\n    \\n    int find(int A[], int m, int B[], int n) {\\n        int l = 0, u = m;\\n        int i, j, half = (m + n + 1) / 2;\\n        if (!A || m == 0)\\n            return medianof(B, n);\\n        if (!B || n == 0)\\n            return medianof(A, m);\\n        while (l < u) {\\n            i = (l + u) / 2;\\n            j = half - i - 2;\\n            if (j < 0 || j >= n) {\\n                if (j == -1 && A[i] <= B[0])\\n                    return i; /* found */\\n                if (j >= n )\\n                    l = i + 1; /* too small */\\n                else\\n                    u = i; /* too big */\\n            } else {\\n                if (B[j]<= A[i] && (j == n - 1 || A[i] <= B[j+1]))\\n                    return i; /* found */\\n                else if (A[i] < B[j])\\n                    l = i + 1; /* too small */\\n                else\\n                    u = i; /* too big */\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    double findMedianSortedArrays(int A[], int m, int B[], int n) {\\n        int i, j, k, *C;\\n        if (!A || m == 0)\\n            return medianof(B, n);\\n        if (!B || n == 0)\\n            return medianof(A, m);\\n        if ((i = find(A, m, B, n)) == -1) {\\n            i = find(B, n, A, m);\\n            C = A; A = B; B = C;\\n            swap(&m, &n);\\n        }\\n        if (odd(m + n))\\n            return (double)A[i];\\n        j = (m + n) / 2 - i - 2;\\n        if (i == m - 1)\\n            k = B[j+1];\\n        else if (j == n - 1)\\n            k = A[i+1];\\n        else\\n            k = min(A[i+1], B[j+1]);\\n        return (double)(A[i] + k) / 2.0;\\n    }\\n\\nRegards.",
                "codeTag": "Unknown"
            },
            {
                "id": 2895,
                "title": "share-my-o-log-min-m-n-solution",
                "content": "A fact::<br>\\nif medianA is the median of array  A, and medianB is the median of array B,<br>\\nthen the median of the two array is between medianA and medianB.<br>\\n\\nsuppose medianA < medianB,<br>\\nwhen we remove some elements that are smaller than medianA in A<br>\\nand remove the same number of elements that are larger than meidanB in B,<br>\\nthe problem become smaller but the median remains the same;<br>\\n\\nsuppose size(A) < size(B)<br>\\nusually half of the  array of A are removed every time <br>\\nuntil there are less than 2 elements in A<br>\\n\\nso it takes O( log(min(m,n))) before we stop the loop.<br>\\n\\nBy far, we got less than 2 elements left in A and still some elements in B.<br>\\nwe can find the median of them easily  in O(1)<br>\\n\\n\\n    double findMedianSortedArrays(int A[], int m, int B[], int n) {\\n    \\n    \\tint lA = 0;\\n    \\tint lB = 0;\\n    \\tint rA = m - 1;\\n    \\tint rB = n - 1;\\n    \\n    \\twhile (lA < rA && lB < rB){\\n    \\t\\t\\n    \\t\\tint sumA = lA + rA;\\n    \\t\\tdouble medianA = (sumA & 0x0001)? 0.5 * (A[ sumA/2 ] + A[ sumA/2 + 1 ]) : A[ sumA/2];\\n    \\n    \\t\\tint sumB = lB + rB;\\n    \\t\\tdouble medianB = (sumB & 0x0001)? 0.5 * (B[ sumB/2 ] + B[ sumB/2 + 1 ]) : B[ sumB/2];\\n    \\n    \\t\\tif (medianA == medianB)\\n    \\t\\t\\treturn medianA;\\n    \\n    \\t\\t// \"step\" is how many elements we can remove on this run\\n    \\t\\tint step = std::min(rA - lA, rB - lB) / 2;  \\n    \\n    \\t\\tif (step == 0)\\n    \\t\\t\\tbreak; // no numbers can be remvoed, means the size of (the shorter array) <= 2.\\n    \\n    \\t\\tif (medianA < medianB){\\n    \\t\\t\\tlA += step;\\n    \\t\\t\\trB -= step;\\n    \\t\\t}else{\\n    \\t\\t\\trA -= step;\\n    \\t\\t\\tlB += step;\\n    \\t\\t}\\n    \\n    \\t}\\n    \\t// since half the shorter array are removed in each run,\\n    \\t// it takes only O(log(min(m,n))) to finish the loop\\n        \\n    \\n    \\tint sumB = lB + rB;\\n    \\tint sumA = lA + rA;\\n    \\n    \\tint * pn = A;\\n    \\tint * p1 = B;\\n    \\tint l = lB;\\n    \\tint r = rB;\\n    \\tint sum = sumA;\\n    \\tint count = rA - lA + 1;\\n    \\n    \\tif ((rA - lA) < (rB - lB)){\\n    \\t\\tpn = B;\\n    \\t\\tp1 = A;\\n    \\t\\tl = lA;\\n    \\t\\tr = rA;\\n    \\t\\tsum = sumB;\\n    \\t\\tcount = rB - lB + 1;\\n    \\t}\\n    \\t\\n    \\t// now pn has more elements than p1 ,\\n        //and  p1 has less than 2 elements;\\n    \\n    \\t// the median can be determined by these elements:\\n    \\t// 1. elements around the middle of pn \\n    \\t// 2. all element of p1 (0,1,2)\\n        // we put them into  \\tvector<int> vec;\\n    \\tvector<int> vec;\\n\\n    \\tif (count % 2){      //------ [sum/2-1] [ sum/2 ] [ sum/2+1 ] --------\\n    \\t\\tvec.push_back(pn[sum/2]);\\n    \\t\\tif (count > 1){\\n    \\t\\t\\tvec.push_back(pn[sum/2 -1]);\\n    \\t\\t\\tvec.push_back(pn[sum/2 +1]);\\n    \\t\\t}\\n    \\t}else{               //------ [sum/2-1] [ sum/2 ] [ sum/2+1 ] [sum/2+2] --------\\n    \\t\\tvec.push_back(pn[sum/2]);\\n    \\t\\tvec.push_back(pn[sum/2 + 1]);\\n    \\t\\tif (count > 2){\\n    \\t\\t\\tvec.push_back(pn[sum/2 - 1]);\\n    \\t\\t\\tvec.push_back(pn[sum/2 + 2]);\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\n    \\tfor (int i = l; i <= r; ++i) // r - l < = 1,  O(1)\\n    \\t\\tvec.push_back(p1[i]);\\n    \\n    \\t// now vec contains the elements that are realy needed to get the median\\n    \\t// in ther words, the median of vec is equal to the median of the two original arrays.\\n    \\tsort(vec.begin(),vec.end());  //  vec.size() <= 6, O(1)\\n    \\n    \\tif (vec.size() % 2)\\n    \\t\\treturn vec[vec.size()/2];\\n    \\telse\\n    \\t\\treturn (vec[vec.size()/2 - 1] + vec[vec.size()/2]) * 0.5;\\n    \\t\\n    }",
                "solutionTags": [],
                "code": "A fact::<br>\\nif medianA is the median of array  A, and medianB is the median of array B,<br>\\nthen the median of the two array is between medianA and medianB.<br>\\n\\nsuppose medianA < medianB,<br>\\nwhen we remove some elements that are smaller than medianA in A<br>\\nand remove the same number of elements that are larger than meidanB in B,<br>\\nthe problem become smaller but the median remains the same;<br>\\n\\nsuppose size(A) < size(B)<br>\\nusually half of the  array of A are removed every time <br>\\nuntil there are less than 2 elements in A<br>\\n\\nso it takes O( log(min(m,n))) before we stop the loop.<br>\\n\\nBy far, we got less than 2 elements left in A and still some elements in B.<br>\\nwe can find the median of them easily  in O(1)<br>\\n\\n\\n    double findMedianSortedArrays(int A[], int m, int B[], int n) {\\n    \\n    \\tint lA = 0;\\n    \\tint lB = 0;\\n    \\tint rA = m - 1;\\n    \\tint rB = n - 1;\\n    \\n    \\twhile (lA < rA && lB < rB){\\n    \\t\\t\\n    \\t\\tint sumA = lA + rA;\\n    \\t\\tdouble medianA = (sumA & 0x0001)? 0.5 * (A[ sumA/2 ] + A[ sumA/2 + 1 ]) : A[ sumA/2];\\n    \\n    \\t\\tint sumB = lB + rB;\\n    \\t\\tdouble medianB = (sumB & 0x0001)? 0.5 * (B[ sumB/2 ] + B[ sumB/2 + 1 ]) : B[ sumB/2];\\n    \\n    \\t\\tif (medianA == medianB)\\n    \\t\\t\\treturn medianA;\\n    \\n    \\t\\t// \"step\" is how many elements we can remove on this run\\n    \\t\\tint step = std::min(rA - lA, rB - lB) / 2;  \\n    \\n    \\t\\tif (step == 0)\\n    \\t\\t\\tbreak; // no numbers can be remvoed, means the size of (the shorter array) <= 2.\\n    \\n    \\t\\tif (medianA < medianB){\\n    \\t\\t\\tlA += step;\\n    \\t\\t\\trB -= step;\\n    \\t\\t}else{\\n    \\t\\t\\trA -= step;\\n    \\t\\t\\tlB += step;\\n    \\t\\t}\\n    \\n    \\t}\\n    \\t// since half the shorter array are removed in each run,\\n    \\t// it takes only O(log(min(m,n))) to finish the loop\\n        \\n    \\n    \\tint sumB = lB + rB;\\n    \\tint sumA = lA + rA;\\n    \\n    \\tint * pn = A;\\n    \\tint * p1 = B;\\n    \\tint l = lB;\\n    \\tint r = rB;\\n    \\tint sum = sumA;\\n    \\tint count = rA - lA + 1;\\n    \\n    \\tif ((rA - lA) < (rB - lB)){\\n    \\t\\tpn = B;\\n    \\t\\tp1 = A;\\n    \\t\\tl = lA;\\n    \\t\\tr = rA;\\n    \\t\\tsum = sumB;\\n    \\t\\tcount = rB - lB + 1;\\n    \\t}\\n    \\t\\n    \\t// now pn has more elements than p1 ,\\n        //and  p1 has less than 2 elements;\\n    \\n    \\t// the median can be determined by these elements:\\n    \\t// 1. elements around the middle of pn \\n    \\t// 2. all element of p1 (0,1,2)\\n        // we put them into  \\tvector<int> vec;\\n    \\tvector<int> vec;\\n\\n    \\tif (count % 2){      //------ [sum/2-1] [ sum/2 ] [ sum/2+1 ] --------\\n    \\t\\tvec.push_back(pn[sum/2]);\\n    \\t\\tif (count > 1){\\n    \\t\\t\\tvec.push_back(pn[sum/2 -1]);\\n    \\t\\t\\tvec.push_back(pn[sum/2 +1]);\\n    \\t\\t}\\n    \\t}else{               //------ [sum/2-1] [ sum/2 ] [ sum/2+1 ] [sum/2+2] --------\\n    \\t\\tvec.push_back(pn[sum/2]);\\n    \\t\\tvec.push_back(pn[sum/2 + 1]);\\n    \\t\\tif (count > 2){\\n    \\t\\t\\tvec.push_back(pn[sum/2 - 1]);\\n    \\t\\t\\tvec.push_back(pn[sum/2 + 2]);\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\n    \\tfor (int i = l; i <= r; ++i) // r - l < = 1,  O(1)\\n    \\t\\tvec.push_back(p1[i]);\\n    \\n    \\t// now vec contains the elements that are realy needed to get the median\\n    \\t// in ther words, the median of vec is equal to the median of the two original arrays.\\n    \\tsort(vec.begin(),vec.end());  //  vec.size() <= 6, O(1)\\n    \\n    \\tif (vec.size() % 2)\\n    \\t\\treturn vec[vec.size()/2];\\n    \\telse\\n    \\t\\treturn (vec[vec.size()/2 - 1] + vec[vec.size()/2]) * 0.5;\\n    \\t\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4070924,
                "title": "98-33-easy-solution-with-explanation-2-approaches",
                "content": "\\n# Brute Force Approach\\nFirstly we create a array `ans` of `double` datatype to store our combined sorted array.\\nNow push the elements of `nums1` and `nums2` into our `ans` array.\\nThen we `sort` the `ans` array and find the median.\\n\\nIf `n` is odd it means our median is `ans[n/2]` else if its even it means we have two mid elements and hence our median is `avg of ans[n/2] and ans[n/2 - 1]`.\\n\\n`Return the answer.`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<double> ans;\\n        for(int i = 0; i < nums1.size(); i++){\\n            ans.push_back(nums1[i]);\\n        }\\n        for(int i = 0; i < nums2.size(); i++){\\n            ans.push_back(nums2[i]);\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n        int n = ans.size();\\n        if(n%2 != 0){\\n            return ans[n/2];\\n        }else{\\n            return (ans[n/2]+ans[n/2 -1])/2;\\n        }\\n    }\\n};\\n```\\n\\n# Binary Search Approach\\nThe approach to finding the `median` of `two sorted arrays` is based on `binary search`. The main idea is to partition the two arrays into `two halves` in such a way that the elements in the left half are less than or equal to the elements in the right half. By doing so, we ensure that the median lies either at the boundary of the two halves or within the halves.\\n\\nHere\\'s a step-by-step explanation of the approach:\\n\\nEnsure `nums1` is the smaller array: To simplify the algorithm, we choose the smaller array `(nums1)` for binary search. If `nums2` is smaller, we `swap` the arrays and their sizes.\\n\\n`Initialize variables`: We initialize `left and right` as the search bounds within `nums1`. The variable `mid` represents the midpoint of the combined array of nums1 and nums2, which is calculated as `(m + n + 1) / 2`, where m is the size of` nums1`, and n is the size of `nums2`.\\n\\n`Binary search`: We perform a binary search on `nums1`. In each iteration, we calculate `partition1` as the midpoint of the current search interval `[left, right]`. We also calculate `partition2` as `mid - partition1`, which corresponds to the partition point in` nums2`.\\n\\n`Determine the elements at the partitions`: We calculate `maxLeft1`, `minRight1, maxLeft2, and minRight2 `to represent the elements around the partitions in both arrays.\\n\\n- `maxLeft1` is the maximum element to the left of partition1 in nums1.\\n- `minRight1` is the minimum element to the right of partition1 in nums1.\\n- `maxLeft2` is the maximum element to the left of partition2 in nums2.\\n- `minRight2` is the minimum element to the right of partition2 in nums2.\\n\\n`Check the partition conditions`: We compare these elements to determine if we have found the correct partitions such that `maxLeft1 <= minRight2` and `maxLeft2 <= minRight1`. If these conditions hold, we have found the `correct partitions`, and we can calculate the median based on the parity of the combined array\\'s length.\\n\\nIf the combined array has an `even length`, the median is the average of the maximum of the left elements `(maxLeft1 and maxLeft2)` and the minimum of the right elements `(minRight1 and minRight2)`.\\nIf the combined array has an `odd length`, the median is simply the maximum of the left elements `(maxLeft1 and maxLeft2)`.\\n`Adjust the search bounds`: If the conditions are not met, we adjust the `search bounds` based on the comparison results. If `maxLeft1` is `greater` than `minRight2`, we move the right boundary to the left` (right = partition1)`. Otherwise, we move the left boundary to the right `(left = partition1 + 1)`.\\n\\n`Repeat the binary search` until we find the correct partitions or the search interval `[left, right]` is exhausted.\\n\\n`Return the median`: Finally, we return the calculated `median`.\\n\\n# Code\\n```\\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n\\n        // Ensure nums1 is the smaller array to simplify the algorithm\\n        if (m > n) {\\n            swap(nums1, nums2);\\n            swap(m, n);\\n        }\\n\\n        int left = 0, right = m;\\n        int mid = (m + n + 1) / 2; // Calculate the midpoint of the combined array\\n\\n        while (left <= right) {\\n            int partition1 = left + (right - left) / 2;\\n            int partition2 = mid - partition1;\\n\\n            int maxLeft1 = (partition1 == 0) ? INT_MIN : nums1[partition1 - 1];\\n            int minRight1 = (partition1 == m) ? INT_MAX : nums1[partition1];\\n\\n            int maxLeft2 = (partition2 == 0) ? INT_MIN : nums2[partition2 - 1];\\n            int minRight2 = (partition2 == n) ? INT_MAX : nums2[partition2];\\n\\n            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\\n                // Found the correct partitions\\n                if ((m + n) % 2 == 0) {\\n                    // If the combined array has an even length, take the average\\n                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0;\\n                } else {\\n                    // If the combined array has an odd length, return the maximum of the left elements\\n                    return max(maxLeft1, maxLeft2);\\n                }\\n            } else if (maxLeft1 > minRight2) {\\n                // Adjust the partition1 to the left\\n                right = partition1;\\n            } else {\\n                // Adjust the partition1 to the right\\n                left = partition1 + 1;\\n            }\\n        }\\n\\n        return 0.0; // Return 0.0 if no solution is found (shouldn\\'t normally happen)\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<double> ans;\\n        for(int i = 0; i < nums1.size(); i++){\\n            ans.push_back(nums1[i]);\\n        }\\n        for(int i = 0; i < nums2.size(); i++){\\n            ans.push_back(nums2[i]);\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n        int n = ans.size();\\n        if(n%2 != 0){\\n            return ans[n/2];\\n        }else{\\n            return (ans[n/2]+ans[n/2 -1])/2;\\n        }\\n    }\\n};\\n```\n```\\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n\\n        // Ensure nums1 is the smaller array to simplify the algorithm\\n        if (m > n) {\\n            swap(nums1, nums2);\\n            swap(m, n);\\n        }\\n\\n        int left = 0, right = m;\\n        int mid = (m + n + 1) / 2; // Calculate the midpoint of the combined array\\n\\n        while (left <= right) {\\n            int partition1 = left + (right - left) / 2;\\n            int partition2 = mid - partition1;\\n\\n            int maxLeft1 = (partition1 == 0) ? INT_MIN : nums1[partition1 - 1];\\n            int minRight1 = (partition1 == m) ? INT_MAX : nums1[partition1];\\n\\n            int maxLeft2 = (partition2 == 0) ? INT_MIN : nums2[partition2 - 1];\\n            int minRight2 = (partition2 == n) ? INT_MAX : nums2[partition2];\\n\\n            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\\n                // Found the correct partitions\\n                if ((m + n) % 2 == 0) {\\n                    // If the combined array has an even length, take the average\\n                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0;\\n                } else {\\n                    // If the combined array has an odd length, return the maximum of the left elements\\n                    return max(maxLeft1, maxLeft2);\\n                }\\n            } else if (maxLeft1 > minRight2) {\\n                // Adjust the partition1 to the left\\n                right = partition1;\\n            } else {\\n                // Adjust the partition1 to the right\\n                left = partition1 + 1;\\n            }\\n        }\\n\\n        return 0.0; // Return 0.0 if no solution is found (shouldn\\'t normally happen)\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535682,
                "title": "c-beats-90-runtime-memory-no-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.empty() || nums2.empty()) {\\n            if(nums1.size() == 1 || nums2.size() == 1)\\n                return nums1.empty() ? nums2.back() : nums1.back();\\n            else {\\n                int n = std::max(nums1.size(), nums2.size());\\n                vector<int>& nonEmpty = nums1.empty() ? nums2 : nums1;\\n                int index = n /2;\\n                if(n % 2 == 1) {\\n                    return nonEmpty[index];\\n                }\\n                else {\\n                    return (static_cast<double>(nonEmpty[index]) + nonEmpty[index-1]) / 2;\\n                }\\n            }\\n        }\\n        if(nums1.size() == 1 && nums2.size() == 1) {\\n            return (static_cast<double>(nums1[0]) + nums2[0]) / 2;\\n        }\\n        int left1 = 0;\\n        int left2 = 0;\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n\\n        int n = n1 + n2;\\n        int index = n / 2;\\n        int lastChanged = 0;\\n\\n        while (left1 + left2 != index) {\\n            if((left2 == n2 || left1 < n1 && nums1[left1] < nums2[left2]) ) {\\n                lastChanged = 1;\\n                ++left1;\\n            }\\n            else {\\n                lastChanged = 2;\\n                ++left2;\\n            }\\n        }\\n\\n        if(n % 2 == 1) {\\n            int result = 10000000;\\n            if(left1 < n1) {\\n                result = std::min(result, nums1[left1]);\\n            }\\n            if(left2 < n2) {\\n                result = std::min(result, nums2[left2]);\\n            }\\n            return result;\\n        }\\n        else {\\n            double first = 0;\\n            if(lastChanged == 1) {\\n                first = nums1[left1-1];\\n                int nextValueInFirst = 1000000;\\n                int nextValueInSecond = 1000000;\\n                if(left1 < n1) {\\n                    while(left1 < n1 && nums1[left1] < first) {\\n                        ++left1;\\n                    }\\n                    if(left1 < n1) {\\n                        nextValueInFirst = nums1[left1];\\n                    }\\n                }\\n                if(left2  < n2) {\\n                    while(left2 < n2 && nums2[left2] < first) {\\n                        ++left2;\\n                    }\\n                    if(left2 < n2) {\\n                        nextValueInSecond = nums2[left2];\\n                    }\\n                }\\n                return (first + std::min(nextValueInSecond, nextValueInFirst)) / 2;\\n            }\\n            else {\\n                first = nums2[left2-1];\\n                int nextValueInFirst = 1000000;\\n                int nextValueInSecond = 1000000;\\n                if(left2 < n2) {\\n                    while(left2 < n2 && nums2[left2] < first) {\\n                        ++left2;\\n                    }\\n                    if(left2 < n2) {\\n                        nextValueInFirst = nums2[left2];\\n                    }\\n                }\\n                if(left1 < n1) {\\n                    while(left1 < n1 && nums1[left1] < first) {\\n                        ++left1;\\n                    }\\n                    if(left1 < n1) {\\n                        nextValueInSecond = nums1[left1];\\n                    }\\n                }\\n                return (first + std::min(nextValueInSecond, nextValueInFirst)) / 2;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.empty() || nums2.empty()) {\\n            if(nums1.size() == 1 || nums2.size() == 1)\\n                return nums1.empty() ? nums2.back() : nums1.back();\\n            else {\\n                int n = std::max(nums1.size(), nums2.size());\\n                vector<int>& nonEmpty = nums1.empty() ? nums2 : nums1;\\n                int index = n /2;\\n                if(n % 2 == 1) {\\n                    return nonEmpty[index];\\n                }\\n                else {\\n                    return (static_cast<double>(nonEmpty[index]) + nonEmpty[index-1]) / 2;\\n                }\\n            }\\n        }\\n        if(nums1.size() == 1 && nums2.size() == 1) {\\n            return (static_cast<double>(nums1[0]) + nums2[0]) / 2;\\n        }\\n        int left1 = 0;\\n        int left2 = 0;\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n\\n        int n = n1 + n2;\\n        int index = n / 2;\\n        int lastChanged = 0;\\n\\n        while (left1 + left2 != index) {\\n            if((left2 == n2 || left1 < n1 && nums1[left1] < nums2[left2]) ) {\\n                lastChanged = 1;\\n                ++left1;\\n            }\\n            else {\\n                lastChanged = 2;\\n                ++left2;\\n            }\\n        }\\n\\n        if(n % 2 == 1) {\\n            int result = 10000000;\\n            if(left1 < n1) {\\n                result = std::min(result, nums1[left1]);\\n            }\\n            if(left2 < n2) {\\n                result = std::min(result, nums2[left2]);\\n            }\\n            return result;\\n        }\\n        else {\\n            double first = 0;\\n            if(lastChanged == 1) {\\n                first = nums1[left1-1];\\n                int nextValueInFirst = 1000000;\\n                int nextValueInSecond = 1000000;\\n                if(left1 < n1) {\\n                    while(left1 < n1 && nums1[left1] < first) {\\n                        ++left1;\\n                    }\\n                    if(left1 < n1) {\\n                        nextValueInFirst = nums1[left1];\\n                    }\\n                }\\n                if(left2  < n2) {\\n                    while(left2 < n2 && nums2[left2] < first) {\\n                        ++left2;\\n                    }\\n                    if(left2 < n2) {\\n                        nextValueInSecond = nums2[left2];\\n                    }\\n                }\\n                return (first + std::min(nextValueInSecond, nextValueInFirst)) / 2;\\n            }\\n            else {\\n                first = nums2[left2-1];\\n                int nextValueInFirst = 1000000;\\n                int nextValueInSecond = 1000000;\\n                if(left2 < n2) {\\n                    while(left2 < n2 && nums2[left2] < first) {\\n                        ++left2;\\n                    }\\n                    if(left2 < n2) {\\n                        nextValueInFirst = nums2[left2];\\n                    }\\n                }\\n                if(left1 < n1) {\\n                    while(left1 < n1 && nums1[left1] < first) {\\n                        ++left1;\\n                    }\\n                    if(left1 < n1) {\\n                        nextValueInSecond = nums1[left1];\\n                    }\\n                }\\n                return (first + std::min(nextValueInSecond, nextValueInFirst)) / 2;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799909,
                "title": "python-easy-solution",
                "content": "\\n# Code\\u2705\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        final = [] \\n        i = 0\\n        j = 0\\n        while i<len(nums1) and j<len(nums2):\\n            if nums1[i] <= nums2[j]:\\n                final.append(nums1[i])\\n                i += 1\\n            else:\\n                final.append(nums2[j])\\n                j += 1\\n        final = final + nums1[i:] + nums2[j:]\\n        size = len(final)\\n        return (final[size//2]) if size % 2 != 0 else (final[size//2 - 1] + final[(size//2)])/2 \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        final = [] \\n        i = 0\\n        j = 0\\n        while i<len(nums1) and j<len(nums2):\\n            if nums1[i] <= nums2[j]:\\n                final.append(nums1[i])\\n                i += 1\\n            else:\\n                final.append(nums2[j])\\n                j += 1\\n        final = final + nums1[i:] + nums2[j:]\\n        size = len(final)\\n        return (final[size//2]) if size % 2 != 0 else (final[size//2 - 1] + final[(size//2)])/2 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501064,
                "title": "simple-dart-solution",
                "content": "**Please upvote if it was helpful!**\\n```\\nclass Solution {\\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\\n    final nums = <int>[...nums1, ...nums2]..sort();\\n    final middle = nums.length ~/ 2; //Rounded integer middle\\n\\n    if (middle == nums.length / 2) { //Is rounded middle == real middle\\n      int x = middle;\\n      int y = middle - 1;\\n      return (nums[x] + nums[y]) / 2;\\n    } else {\\n      int x = middle;\\n      return nums[x].toDouble();\\n    }\\n  }\\n}\\n```\\n\\nOr\\n\\n```\\nclass Solution {\\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\\n    final nums = <int>[...nums1, ...nums2]..sort();\\n    final middle = nums.length / 2;  //Real double middle\\n\\n    if (middle == nums.length ~/ 2) { //Is real middle == rounded middle\\n      int x = (middle - 0.5).toInt();\\n      int y = (middle + 0.5).toInt();\\n      return (nums[x] + nums[y]) / 2;\\n    } else {\\n      int x = (middle - 0.5).toInt();;\\n      return nums[x].toDouble();\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\\n    final nums = <int>[...nums1, ...nums2]..sort();\\n    final middle = nums.length ~/ 2; //Rounded integer middle\\n\\n    if (middle == nums.length / 2) { //Is rounded middle == real middle\\n      int x = middle;\\n      int y = middle - 1;\\n      return (nums[x] + nums[y]) / 2;\\n    } else {\\n      int x = middle;\\n      return nums[x].toDouble();\\n    }\\n  }\\n}\\n```\n```\\nclass Solution {\\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\\n    final nums = <int>[...nums1, ...nums2]..sort();\\n    final middle = nums.length / 2;  //Real double middle\\n\\n    if (middle == nums.length ~/ 2) { //Is real middle == rounded middle\\n      int x = (middle - 0.5).toInt();\\n      int y = (middle + 0.5).toInt();\\n      return (nums[x] + nums[y]) / 2;\\n    } else {\\n      int x = (middle - 0.5).toInt();;\\n      return nums[x].toDouble();\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276865,
                "title": "easy-c-solution-100-fully-explained-and-understandable",
                "content": "# **C++ SOLUTION:**\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        //if the size of nums1 is greater than nums2, then call the algorithm...\\n        if(nums1.size() > nums2.size()){\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        // Pointers for binary search...\\n        int beg = 0;\\n        int end = nums1.size();\\n\\n        // Binary search starts from here...\\n        while(beg <= end){\\n            \\n            // Partitions of both the array...\\n            int part1 = (beg + end)/2;\\n            int part2 = ((nums1.size() + nums2.size() + 1)/2 - part1);\\n            \\n            // If there are no elements left on the left side after partition\\n            int maxL1 = part1 == 0 ? INT_MIN : nums1[part1 - 1];\\n            // If there are no elements left on the right side after partition\\n            int minR1 = part1 == nums1.size() ? INT_MAX : nums1[part1];\\n            // Similarly for nums2\\n            int maxL2 = part2 == 0 ? INT_MIN : nums2[part2 - 1];\\n            int minR2 = part2 == nums2.size() ? INT_MAX : nums2[part2];\\n            \\n            //when the following case is satisfied,\\n            //we find the median based on array size is even or odd...\\n            if(maxL1 <= minR2 && maxL2 <= minR1){\\n                // if array size is even, we add the max value from left side\\n                //with min value from right side...\\n                if((nums1.size() + nums2.size())%2 == 0){\\n                    return double(max(maxL1, maxL2) + min(minR1, minR2))/2;\\n                \\n                }\\n                // if array size is odd we return the max of the two array\\'s left hand-side value..\\n                else {\\n                    return double(max(maxL1, maxL2));\\n                }\\n            }\\n            // If we are too far on the right, we need to go to left side...\\n            else if (maxL1 > minR2){\\n                end = part1 - 1;\\n            }\\n            // If we are too far on the left, we need to go to right side...\\n            else {\\n                beg = part1 + 1;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        //if the size of nums1 is greater than nums2, then call the algorithm...\\n        if(nums1.size() > nums2.size()){\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        // Pointers for binary search...\\n        int beg = 0;\\n        int end = nums1.size();\\n\\n        // Binary search starts from here...\\n        while(beg <= end){\\n            \\n            // Partitions of both the array...\\n            int part1 = (beg + end)/2;\\n            int part2 = ((nums1.size() + nums2.size() + 1)/2 - part1);\\n            \\n            // If there are no elements left on the left side after partition\\n            int maxL1 = part1 == 0 ? INT_MIN : nums1[part1 - 1];\\n            // If there are no elements left on the right side after partition\\n            int minR1 = part1 == nums1.size() ? INT_MAX : nums1[part1];\\n            // Similarly for nums2\\n            int maxL2 = part2 == 0 ? INT_MIN : nums2[part2 - 1];\\n            int minR2 = part2 == nums2.size() ? INT_MAX : nums2[part2];\\n            \\n            //when the following case is satisfied,\\n            //we find the median based on array size is even or odd...\\n            if(maxL1 <= minR2 && maxL2 <= minR1){\\n                // if array size is even, we add the max value from left side\\n                //with min value from right side...\\n                if((nums1.size() + nums2.size())%2 == 0){\\n                    return double(max(maxL1, maxL2) + min(minR1, minR2))/2;\\n                \\n                }\\n                // if array size is odd we return the max of the two array\\'s left hand-side value..\\n                else {\\n                    return double(max(maxL1, maxL2));\\n                }\\n            }\\n            // If we are too far on the right, we need to go to left side...\\n            else if (maxL1 > minR2){\\n                end = part1 - 1;\\n            }\\n            // If we are too far on the left, we need to go to right side...\\n            else {\\n                beg = part1 + 1;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218788,
                "title": "go-o-log-min-m-n-solution-with-detailed-explanations-video-link-included-as-well",
                "content": "```go\\n// follow https://www.youtube.com/watch?v=q6IEA26hvXc&t=670s\\n// The idea is simple:\\n// 0. we know the median should be at index (m+n)/2\\n// 1. odd or even, finding this index solves the problem\\n// 2. we use binary search for the smaller array\\n// 3. first iteration we find the half way of nums1 of index h1\\n// 4. to make the half of the overall, we take (m+n)/2-h1 from nums2 to be h2\\n// 5. define l1, r1, l2, r2 to be the left & right of nums1 & nums2 around the h1 & h2\\n// 6. if l1<r2 && l2<r1, then we found the correct indexes in both array\\n// 7. return the result based of odd or even of the result size\\nfunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\\n    m := len(nums1)\\n    n := len(nums2)\\n    // make sure first array is smaller: do binary search on smaller array\\n    // lowers the complexity\\n    if m > n {\\n        nums1, nums2 = nums2, nums1\\n        m, n = n, m\\n    }\\n    total := m + n\\n    half := (total + 1) / 2 // +1 because we want the size include mid point. i.e. math.Ceiling\\n\\n    // define the left & right index of nums1 to be l, r = 0, len(nums1)-1\\n    // to calculate half point for binary search\\n    l, r := 0, m-1\\n\\n    for {\\n        // next find half index of nums1: h1 = (l+r)/2\\n        // so h1 is either the mid or to the left of mid\\n        //\\n        // then we need to take from nums2 from 0 to h2 to make half of the overall\\n        // In other words: h1+1+h2+1 = half or h2 = half-h1-2\\n        //\\n        // There is a trap: In go -1/2 is 0 not -1. If l is 0 and r is -1, we want to\\n        // h1 to be -1 so that it falls into the l1 = -math.MaxInt condition. Otherwise\\n        // it goes into an infinite loop of l=r=h=0\\n        //\\n        // we can either use h1 := int(math.Floor(float64(l+r) / 2)) or below\\n        h1 := (l+r) >> 1\\n        h2 := half - h1 - 2 // -2 because length is last_index+1 from 0 so h1+1+h2+1 = half\\n\\n        var l1, l2, r1, r2 int // left&right value of nums1&nums2 around h1&h2\\n        if h1 >= 0 { l1 = nums1[h1] } else { l1 = -math.MaxInt }\\n        if h2 >= 0 { l2 = nums2[h2] } else { l2 = -math.MaxInt }\\n        if h1+1 < m { r1 = nums1[h1+1] } else { r1 = math.MaxInt }\\n        if h2+1 < n { r2 = nums2[h2+1] } else { r2 = math.MaxInt }\\n\\n        // now we want to see if this mid point is actually the mid point for the final array:\\n        // cross compare left & right of 1st & 2nd array\\n        if l1 <= r2 && l2 <= r1 {\\n            // if merged array size is even, we need the median of max left and min right\\n            if (m+n)%2 == 0 {\\n                return float64(max(l1, l2)+min(r1, r2)) / 2\\n            }\\n            return float64(max(l1, l2))\\n        }\\n\\n        // otherwise one of two conditions:\\n        if l1 > r2 {\\n            // l1 is too large, meaning we need to move left of nums1. putting right as half point\\n            r = h1 - 1\\n        } else {\\n            // l2 is too large, or r1 is to small, meaning we need to move right of nums1\\n            l = h1 + 1\\n        }\\n    }\\n}\\n\\nfunc max(a, b int) int {\\n    if a>b { return a }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a<b { return a }\\n    return b\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n// follow https://www.youtube.com/watch?v=q6IEA26hvXc&t=670s\\n// The idea is simple:\\n// 0. we know the median should be at index (m+n)/2\\n// 1. odd or even, finding this index solves the problem\\n// 2. we use binary search for the smaller array\\n// 3. first iteration we find the half way of nums1 of index h1\\n// 4. to make the half of the overall, we take (m+n)/2-h1 from nums2 to be h2\\n// 5. define l1, r1, l2, r2 to be the left & right of nums1 & nums2 around the h1 & h2\\n// 6. if l1<r2 && l2<r1, then we found the correct indexes in both array\\n// 7. return the result based of odd or even of the result size\\nfunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\\n    m := len(nums1)\\n    n := len(nums2)\\n    // make sure first array is smaller: do binary search on smaller array\\n    // lowers the complexity\\n    if m > n {\\n        nums1, nums2 = nums2, nums1\\n        m, n = n, m\\n    }\\n    total := m + n\\n    half := (total + 1) / 2 // +1 because we want the size include mid point. i.e. math.Ceiling\\n\\n    // define the left & right index of nums1 to be l, r = 0, len(nums1)-1\\n    // to calculate half point for binary search\\n    l, r := 0, m-1\\n\\n    for {\\n        // next find half index of nums1: h1 = (l+r)/2\\n        // so h1 is either the mid or to the left of mid\\n        //\\n        // then we need to take from nums2 from 0 to h2 to make half of the overall\\n        // In other words: h1+1+h2+1 = half or h2 = half-h1-2\\n        //\\n        // There is a trap: In go -1/2 is 0 not -1. If l is 0 and r is -1, we want to\\n        // h1 to be -1 so that it falls into the l1 = -math.MaxInt condition. Otherwise\\n        // it goes into an infinite loop of l=r=h=0\\n        //\\n        // we can either use h1 := int(math.Floor(float64(l+r) / 2)) or below\\n        h1 := (l+r) >> 1\\n        h2 := half - h1 - 2 // -2 because length is last_index+1 from 0 so h1+1+h2+1 = half\\n\\n        var l1, l2, r1, r2 int // left&right value of nums1&nums2 around h1&h2\\n        if h1 >= 0 { l1 = nums1[h1] } else { l1 = -math.MaxInt }\\n        if h2 >= 0 { l2 = nums2[h2] } else { l2 = -math.MaxInt }\\n        if h1+1 < m { r1 = nums1[h1+1] } else { r1 = math.MaxInt }\\n        if h2+1 < n { r2 = nums2[h2+1] } else { r2 = math.MaxInt }\\n\\n        // now we want to see if this mid point is actually the mid point for the final array:\\n        // cross compare left & right of 1st & 2nd array\\n        if l1 <= r2 && l2 <= r1 {\\n            // if merged array size is even, we need the median of max left and min right\\n            if (m+n)%2 == 0 {\\n                return float64(max(l1, l2)+min(r1, r2)) / 2\\n            }\\n            return float64(max(l1, l2))\\n        }\\n\\n        // otherwise one of two conditions:\\n        if l1 > r2 {\\n            // l1 is too large, meaning we need to move left of nums1. putting right as half point\\n            r = h1 - 1\\n        } else {\\n            // l2 is too large, or r1 is to small, meaning we need to move right of nums1\\n            l = h1 + 1\\n        }\\n    }\\n}\\n\\nfunc max(a, b int) int {\\n    if a>b { return a }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a<b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561604,
                "title": "c-o-log-min-m-n-with-youtube-video-link-reference",
                "content": "This guy makes a very good explanation in this video: https://www.youtube.com/watch?v=LPFhl65R7ww&t=1314s\\n\\n```\\npublic class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if (nums2.Length < nums1.Length) {\\n            var temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        \\n        var n = nums1.Length;\\n        var m = nums2.Length;\\n        \\n        var start = 0;\\n        var end = n;\\n        \\n        while(start <= end) {\\n            var blockN = start + (end - start) / 2;\\n            var blockM = (n + m + 1) / 2 - blockN;\\n            \\n            var blockNMin = blockN == 0 ? int.MinValue : nums1[blockN - 1];\\n            var blockNMax = blockN == n ? int.MaxValue : nums1[blockN];\\n            var blockMMin = blockM == 0 ? int.MinValue : nums2[blockM - 1];\\n            var blockMMax = blockM == m ? int.MaxValue : nums2[blockM];\\n            \\n            if (blockNMin <= blockMMax && blockMMin <= blockNMax) {\\n                if ((m + n) % 2 == 1) {\\n                    return Math.Max(blockNMin, blockMMin);\\n                }\\n                else {\\n                    return (Math.Max(blockNMin, blockMMin) +\\n                            Math.Min(blockNMax, blockMMax)) / 2.0;\\n                }\\n            }\\n            else if (blockNMin > blockMMax) {\\n                end = blockN - 1;\\n            }\\n            else {\\n                start = blockN + 1;\\n            }\\n        }\\n        \\n        throw new Exception();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if (nums2.Length < nums1.Length) {\\n            var temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        \\n        var n = nums1.Length;\\n        var m = nums2.Length;\\n        \\n        var start = 0;\\n        var end = n;\\n        \\n        while(start <= end) {\\n            var blockN = start + (end - start) / 2;\\n            var blockM = (n + m + 1) / 2 - blockN;\\n            \\n            var blockNMin = blockN == 0 ? int.MinValue : nums1[blockN - 1];\\n            var blockNMax = blockN == n ? int.MaxValue : nums1[blockN];\\n            var blockMMin = blockM == 0 ? int.MinValue : nums2[blockM - 1];\\n            var blockMMax = blockM == m ? int.MaxValue : nums2[blockM];\\n            \\n            if (blockNMin <= blockMMax && blockMMin <= blockNMax) {\\n                if ((m + n) % 2 == 1) {\\n                    return Math.Max(blockNMin, blockMMin);\\n                }\\n                else {\\n                    return (Math.Max(blockNMin, blockMMin) +\\n                            Math.Min(blockNMax, blockMMax)) / 2.0;\\n                }\\n            }\\n            else if (blockNMin > blockMMax) {\\n                end = blockN - 1;\\n            }\\n            else {\\n                start = blockN + 1;\\n            }\\n        }\\n        \\n        throw new Exception();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468913,
                "title": "java-o-log-min-m-n-solution-2ms-100",
                "content": "To find the median in the mergerd array, we need to place __(m + n) / 2__ elements on the left side of the median (if the total number is even, place __(m + n) / 2__ elements at the left side of the second median).\\n\\nTo construct the left side, we can use __count1__ number of elements from nums1 and __(m + n) / 2 - count1__ number of elements from nums2. So, we can first find __count1__ with binary search on the array with smaller length, and then calculate the right median correspondingly. If the total number is even, we just need to calculate the left median and take the average.\\n\\n```java\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if (nums1 == null) return findMedianSortedArrays(new int[0], nums2);\\n        if (nums2 == null) return findMedianSortedArrays(nums1, new int[0]);\\n        if (nums1.length > nums2.length) return findMedianSortedArrays(nums2, nums1);\\n        int m = nums1.length, n = nums2.length;\\n        int k = (m + n) / 2;\\n        int l = 0, r = m - 1;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums1[mid] < nums2[k - mid - 1]) {\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        double candidate1 = Math.min(l == m ? Integer.MAX_VALUE : nums1[l], k - l == n ? Integer.MAX_VALUE : nums2[k - l]);\\n        if ((m + n) % 2 == 1) return candidate1;\\n        double candidate2 = Math.max(l == 0 ? Integer.MIN_VALUE : nums1[l - 1], k - l == 0 ? Integer.MIN_VALUE : nums2[k - l - 1]);\\n        return (candidate1 + candidate2) / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```java\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if (nums1 == null) return findMedianSortedArrays(new int[0], nums2);\\n        if (nums2 == null) return findMedianSortedArrays(nums1, new int[0]);\\n        if (nums1.length > nums2.length) return findMedianSortedArrays(nums2, nums1);\\n        int m = nums1.length, n = nums2.length;\\n        int k = (m + n) / 2;\\n        int l = 0, r = m - 1;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums1[mid] < nums2[k - mid - 1]) {\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        double candidate1 = Math.min(l == m ? Integer.MAX_VALUE : nums1[l], k - l == n ? Integer.MAX_VALUE : nums2[k - l]);\\n        if ((m + n) % 2 == 1) return candidate1;\\n        double candidate2 = Math.max(l == 0 ? Integer.MIN_VALUE : nums1[l - 1], k - l == 0 ? Integer.MIN_VALUE : nums2[k - l - 1]);\\n        return (candidate1 + candidate2) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362727,
                "title": "python-o-log-m-n",
                "content": "This solution is inspired from Tushar Roy\\'s approach for finding the median on Youtube. \\n\\n```\\ndef findMedianSortedArrays(self, arr1: List[int], arr2: List[int]) -> float:\\n        x=len(arr1)\\n        y=len(arr2)\\n        if x>y:\\n            return self.findMedianSortedArrays(arr2,arr1)\\n        low=0\\n        high=x\\n        while(low<=high):\\n            #print(low)\\n            partitionX=int((low+high)/2)\\n\\n            partitionY=int(((x+y+1)//2 )-partitionX)\\n            maxLeftX= float(\\'-inf\\') if partitionX==0 else arr1[partitionX-1]\\n            minRightX=float(\\'inf\\') if partitionX==x else arr1[partitionX]\\n            maxLeftY = float(\\'-inf\\') if partitionY == 0 else arr2[partitionY - 1]\\n            minRightY =  float(\\'inf\\') if partitionY == y else arr2[partitionY]\\n            if maxLeftX<=minRightY and maxLeftY<=minRightX:\\n                if (x+y) %2 ==0:\\n                    return (max(maxLeftX,maxLeftY) + min(minRightX,minRightY))/2\\n                else:\\n                    return max(maxLeftY,maxLeftX)\\n            elif(maxLeftX>minRightY):\\n                high=partitionX-1\\n            else:\\n                low=partitionX+1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\ndef findMedianSortedArrays(self, arr1: List[int], arr2: List[int]) -> float:\\n        x=len(arr1)\\n        y=len(arr2)\\n        if x>y:\\n            return self.findMedianSortedArrays(arr2,arr1)\\n        low=0\\n        high=x\\n        while(low<=high):\\n            #print(low)\\n            partitionX=int((low+high)/2)\\n\\n            partitionY=int(((x+y+1)//2 )-partitionX)\\n            maxLeftX= float(\\'-inf\\') if partitionX==0 else arr1[partitionX-1]\\n            minRightX=float(\\'inf\\') if partitionX==x else arr1[partitionX]\\n            maxLeftY = float(\\'-inf\\') if partitionY == 0 else arr2[partitionY - 1]\\n            minRightY =  float(\\'inf\\') if partitionY == y else arr2[partitionY]\\n            if maxLeftX<=minRightY and maxLeftY<=minRightX:\\n                if (x+y) %2 ==0:\\n                    return (max(maxLeftX,maxLeftY) + min(minRightX,minRightY))/2\\n                else:\\n                    return max(maxLeftY,maxLeftX)\\n            elif(maxLeftX>minRightY):\\n                high=partitionX-1\\n            else:\\n                low=partitionX+1\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 245975,
                "title": "java-solutions",
                "content": "**Solution 1:**\\n\\nTime complexity: `O(log Min(m, n))`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n\\tpublic double findMedianSortedArrays(int[] A, int[] B) \\n\\t{\\n        int m = A.length;\\n        int n = B.length;\\n\\t\\tint start = 0;\\n\\t\\tint end = m;\\n\\t\\t\\n        if(m > n)\\n\\t\\t{\\n            return findMedianSortedArrays(B, A);\\n        }\\n        while(start <= end)\\n\\t\\t{\\n            int i = (start + end) / 2;\\n\\t\\t\\tint j = (m + n + 1) / 2 - i;\\n\\n\\t\\t\\tif(i > start && A[i - 1] > B[j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tend = i - 1;\\n            }\\n\\t\\t\\telse if(i < end && B[j - 1] > A[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = i + 1;\\n            }\\n\\t\\t\\telse\\n\\t\\t\\t{\\n                int maxLeft = i == 0 ? B[j - 1] : (j == 0 ? A[i - 1] : Math.max(A[i - 1], B[j - 1]));\\n                \\n\\t\\t\\t\\tif((m + n) % 2 == 1)\\n\\t\\t\\t\\t{\\n                    return maxLeft;\\n                }\\n                int minRight = i == m ? B[j] : (j == n ? A[i] : Math.min(A[i], B[j]));\\n                return (maxLeft + minRight) / 2.0;\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n\\nTime complexity: `O(log Min(m, n))`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public double findMedianSortedArrays(int[] A, int[] B)\\n\\t{\\n        int m = A.length; \\n        int n = B.length;\\n        int start = 0;\\n        int end = m;\\n\\t\\t\\n\\t\\tif(m > n)\\n        {\\n\\t\\t\\treturn findMedianSortedArrays(B, A);\\n\\t\\t}    \\n        while(start <= end)\\n\\t\\t{\\n            int i = start + (end - start) / 2;\\n            int j = (m + n + 1) / 2 - i;\\n            \\n\\t\\t\\tif(i > start && A[i - 1] > B[j])\\n\\t\\t\\t{\\n                end = i - 1;\\n            }\\n\\t\\t\\telse if(i < end && A[i] < B[j - 1])\\n\\t\\t\\t{\\n                start = i + 1;\\n            }\\n\\t\\t\\telse\\n\\t\\t\\t{\\n                int maxLeft = Integer.MIN_VALUE;\\n                int minRight = Integer.MAX_VALUE;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(i - 1 >= 0) maxLeft  = Math.max(maxLeft, A[i - 1]);\\n                if(j - 1 >= 0) maxLeft  = Math.max(maxLeft, B[j - 1]);\\n                if(i <= m - 1) minRight = Math.min(minRight, A[i]);\\n                if(j <= n - 1) minRight = Math.min(minRight, B[j]);\\n\\n                return (m + n) % 2 == 0 ? (maxLeft + minRight) / 2.0 : maxLeft;\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n```\\n\\n**Solution 3:**\\n\\nTime complexity: `O(log(m + n))`\\nSpace complexity: `O(log(m + n))` - space required for the recursive function call stack.\\n\\n```\\nclass Solution\\n{\\n    public double findMedianSortedArrays(int[] A, int[] B)\\n\\t{\\n        int m = A.length;\\n        int n = B.length;\\n\\t\\tint index1 = (m + n + 1) / 2;\\n\\t\\tint index2 = (m + n + 2) / 2;\\n\\t\\t\\n        return (findKth(A, 0, B, 0, index1) + findKth(A, 0, B, 0, index2)) / 2.0;\\n    }\\n\\t\\n    private int findKth(int[] A, int i, int[] B, int j, int k)\\n\\t{\\n        if(i >= A.length) return B[j + k - 1];\\n        if(j >= B.length) return A[i + k - 1];\\n        if(k == 1) return Math.min(A[i], B[j]);\\n        \\n\\t\\tint mid1 = (i + k / 2 - 1 < A.length) ? A[i + k / 2 - 1] : Integer.MAX_VALUE;\\n        int mid2 = (j + k / 2 - 1 < B.length) ? B[j + k / 2 - 1] : Integer.MAX_VALUE;\\n        \\n\\t\\tif(mid1 < mid2)\\n\\t\\t\\treturn findKth(A, i + k / 2, B, j, k - k / 2);\\n        else\\n\\t\\t\\treturn findKth(A, i, B, j + k / 2, k - k / 2);\\n    }\\n}\\n```\\n\\n**Solution 4:**\\n\\nTime complexity: `O(log(m + n))`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n\\tpublic double findMedianSortedArrays(int[] A, int[] B) \\n\\t{\\n        int m = A.length;\\n        int n = B.length;\\n\\t\\tint start = 0;\\n\\t\\tint end = m;\\n\\t\\t\\n        if(m > n)\\n\\t\\t{\\n            return findMedianSortedArrays(B, A);\\n        }\\n\\n        while(start <= end)\\n        {\\n            int i = start + (end - start) / 2;\\n            int j = (m + n + 1) / 2 - i;\\n\\t\\t\\t\\n            double x1 = (i == 0) ? Integer.MIN_VALUE : A[i - 1];\\n            double y1 = (i == m) ? Integer.MAX_VALUE : A[i];\\n            double x2 = (j == 0) ? Integer.MIN_VALUE : B[j - 1];\\n            double y2 = (j == n) ? Integer.MAX_VALUE : B[j];\\n            \\n\\t\\t\\tif(x1 <= y2 && x2 <= y1)\\n                return ((m + n) % 2 == 0) ? (Math.max(x1, x2) + Math.min(y1, y2)) / 2.0 : Math.max(x1, x2);\\n            else if(x1 > y2)\\n                end = i - 1;\\n            else\\n                start = i + 1;\\n        }\\n        return 0.0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n\\tpublic double findMedianSortedArrays(int[] A, int[] B) \\n\\t{\\n        int m = A.length;\\n        int n = B.length;\\n\\t\\tint start = 0;\\n\\t\\tint end = m;\\n\\t\\t\\n        if(m > n)\\n\\t\\t{\\n            return findMedianSortedArrays(B, A);\\n        }\\n        while(start <= end)\\n\\t\\t{\\n            int i = (start + end) / 2;\\n\\t\\t\\tint j = (m + n + 1) / 2 - i;\\n\\n\\t\\t\\tif(i > start && A[i - 1] > B[j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tend = i - 1;\\n            }\\n\\t\\t\\telse if(i < end && B[j - 1] > A[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = i + 1;\\n            }\\n\\t\\t\\telse\\n\\t\\t\\t{\\n                int maxLeft = i == 0 ? B[j - 1] : (j == 0 ? A[i - 1] : Math.max(A[i - 1], B[j - 1]));\\n                \\n\\t\\t\\t\\tif((m + n) % 2 == 1)\\n\\t\\t\\t\\t{\\n                    return maxLeft;\\n                }\\n                int minRight = i == m ? B[j] : (j == n ? A[i] : Math.min(A[i], B[j]));\\n                return (maxLeft + minRight) / 2.0;\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public double findMedianSortedArrays(int[] A, int[] B)\\n\\t{\\n        int m = A.length; \\n        int n = B.length;\\n        int start = 0;\\n        int end = m;\\n\\t\\t\\n\\t\\tif(m > n)\\n        {\\n\\t\\t\\treturn findMedianSortedArrays(B, A);\\n\\t\\t}    \\n        while(start <= end)\\n\\t\\t{\\n            int i = start + (end - start) / 2;\\n            int j = (m + n + 1) / 2 - i;\\n            \\n\\t\\t\\tif(i > start && A[i - 1] > B[j])\\n\\t\\t\\t{\\n                end = i - 1;\\n            }\\n\\t\\t\\telse if(i < end && A[i] < B[j - 1])\\n\\t\\t\\t{\\n                start = i + 1;\\n            }\\n\\t\\t\\telse\\n\\t\\t\\t{\\n                int maxLeft = Integer.MIN_VALUE;\\n                int minRight = Integer.MAX_VALUE;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(i - 1 >= 0) maxLeft  = Math.max(maxLeft, A[i - 1]);\\n                if(j - 1 >= 0) maxLeft  = Math.max(maxLeft, B[j - 1]);\\n                if(i <= m - 1) minRight = Math.min(minRight, A[i]);\\n                if(j <= n - 1) minRight = Math.min(minRight, B[j]);\\n\\n                return (m + n) % 2 == 0 ? (maxLeft + minRight) / 2.0 : maxLeft;\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public double findMedianSortedArrays(int[] A, int[] B)\\n\\t{\\n        int m = A.length;\\n        int n = B.length;\\n\\t\\tint index1 = (m + n + 1) / 2;\\n\\t\\tint index2 = (m + n + 2) / 2;\\n\\t\\t\\n        return (findKth(A, 0, B, 0, index1) + findKth(A, 0, B, 0, index2)) / 2.0;\\n    }\\n\\t\\n    private int findKth(int[] A, int i, int[] B, int j, int k)\\n\\t{\\n        if(i >= A.length) return B[j + k - 1];\\n        if(j >= B.length) return A[i + k - 1];\\n        if(k == 1) return Math.min(A[i], B[j]);\\n        \\n\\t\\tint mid1 = (i + k / 2 - 1 < A.length) ? A[i + k / 2 - 1] : Integer.MAX_VALUE;\\n        int mid2 = (j + k / 2 - 1 < B.length) ? B[j + k / 2 - 1] : Integer.MAX_VALUE;\\n        \\n\\t\\tif(mid1 < mid2)\\n\\t\\t\\treturn findKth(A, i + k / 2, B, j, k - k / 2);\\n        else\\n\\t\\t\\treturn findKth(A, i, B, j + k / 2, k - k / 2);\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n\\tpublic double findMedianSortedArrays(int[] A, int[] B) \\n\\t{\\n        int m = A.length;\\n        int n = B.length;\\n\\t\\tint start = 0;\\n\\t\\tint end = m;\\n\\t\\t\\n        if(m > n)\\n\\t\\t{\\n            return findMedianSortedArrays(B, A);\\n        }\\n\\n        while(start <= end)\\n        {\\n            int i = start + (end - start) / 2;\\n            int j = (m + n + 1) / 2 - i;\\n\\t\\t\\t\\n            double x1 = (i == 0) ? Integer.MIN_VALUE : A[i - 1];\\n            double y1 = (i == m) ? Integer.MAX_VALUE : A[i];\\n            double x2 = (j == 0) ? Integer.MIN_VALUE : B[j - 1];\\n            double y2 = (j == n) ? Integer.MAX_VALUE : B[j];\\n            \\n\\t\\t\\tif(x1 <= y2 && x2 <= y1)\\n                return ((m + n) % 2 == 0) ? (Math.max(x1, x2) + Math.min(y1, y2)) / 2.0 : Math.max(x1, x2);\\n            else if(x1 > y2)\\n                end = i - 1;\\n            else\\n                start = i + 1;\\n        }\\n        return 0.0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791,
                "title": "25-lines-java-solution",
                "content": "The key is to use get(nums,i) function, when index< low bound return Integer.MIN_VALUE and index>hi bound return Integer.MAX_VALUE, so you do not need to deal with all kinds of corner case.\\n\\n    public class Solution {\\n        public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n            int m=nums1.length;\\n            int n=nums2.length;\\n            int k=(m+n)/2;\\n            int i=0, j=k;\\n            int lo=0, hi=Math.min(k,m);\\n            \\n            while (true) {\\n                i=lo+(hi-lo)/2;\\n                j=k-i;\\n                if (get(nums1,i)>=get(nums2,j-1)) {\\n                    if (get(nums2,j)>=get(nums1,i-1)) break;\\n                    else hi=i-1;\\n                }\\n                else lo=i+1;\\n            }\\n            if ((m+n)%2==1) return Math.min(get(nums1,i),get(nums2,j)); //odd\\n            return (double)(Math.min(get(nums1,i),get(nums2,j))+Math.max(get(nums1,i-1),get(nums2,j-1)))/2;//even\\n        }\\n        private int get(int[] nums, int i) {\\n            if (i<0) return Integer.MIN_VALUE;\\n            if (i>=nums.length) return Integer.MAX_VALUE;\\n            return nums[i];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n            int m=nums1.length;\\n            int n=nums2.length;\\n            int k=(m+n)/2;\\n            int i=0, j=k;\\n            int lo=0, hi=Math.min(k,m);\\n            \\n            while (true) {\\n                i=lo+(hi-lo)/2;\\n                j=k-i;\\n                if (get(nums1,i)>=get(nums2,j-1)) {\\n                    if (get(nums2,j)>=get(nums1,i-1)) break;\\n                    else hi=i-1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3472669,
                "title": "2approaches-optimal-solution-easy-to-understand-c-and-java-code",
                "content": "# Intuition\\nThe intuition behind this approach is that if we can partition the arrays in such a way that the number of elements on the left equals the number of elements on the right, then the median will be the average of the maximum element on the left and the minimum element on the right. We can use binary search to find the correct partition indices in logarithmic time complexity, and then compute the median in constant time.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCalculate the total length of the merged array, which is m + n.\\nDetermine the middle index of the merged array, which is (m + n) / 2.\\nTraverse through both arrays at the same time using two pointers, i and j, initialized to 0.\\nCompare the values at the current indices of both arrays.\\nIf nums1[i] is less than or equal to nums2[j], add nums1[i] to the merged array and increment i.\\nIf nums1[i] is greater than nums2[j], add nums2[j] to the merged array and increment j.\\nRepeat steps 4-6 until either i reaches m or j reaches n.\\nIf i has reached m, add the remaining elements of nums2 to the merged array.\\nIf j has reached n, add the remaining elements of nums1 to the merged array.\\nIf the length of the merged array is even, return the average of the values at the middle index and the index before it.\\nIf the length of the merged array is odd, return the value at the middle index.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(m+n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n#-------------------------------------------------------------------\\n# PLS UPVOTE IF IT HELPS YOU\\n#-------------------------------------------------------------------\\n\\n# Code-1\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n\\n        vector<int> num3;\\n        float sum;\\n        int n = nums1.size();\\n        int m = nums2.size(); \\n\\n        for(int i=0;i<n;i++)\\n        {\\n            num3.push_back(nums1[i]);\\n        } \\n        for(int j=0;j<m;j++)\\n        {\\n            num3.push_back(nums2[j]);\\n        } \\n        sort(num3.begin(),num3.end());\\n        if((n+m)%2==0)\\n        {\\n             sum = (float)(num3[(int)(m+n)/2]+num3[(int)(m+n)/2-1])/2;\\n        }\\n        else if((n+m)%2!=0)\\n        {\\n            sum = (float)num3[(int)(m+n-1)/2];\\n        }\\n\\n            return sum;\\n\\n\\n    }\\n};\\n```\\n\\n# Code-2\\n# optimal solution using Binary Search\\n```\\n\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        // Ensure nums1 is smaller or equal in size to nums2\\n        if (nums1.size() > nums2.size()) {\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        // Length of the merged array\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        int total = m + n;\\n        \\n        // Binary search variables\\n        int left = 0;\\n        int right = m;\\n        int i, j;\\n        \\n        // Binary search to find partition indices\\n        while (left <= right) {\\n            i = (left + right) / 2;\\n            j = (total + 1) / 2 - i;\\n            \\n            if (i < m && nums2[j-1] > nums1[i]) {\\n                // i is too small, increase it\\n                left = i + 1;\\n            } else if (i > 0 && nums1[i-1] > nums2[j]) {\\n                // i is too big, decrease it\\n                right = i - 1;\\n            } else {\\n                // i is perfect\\n                int max_left;\\n                if (i == 0) {\\n                    max_left = nums2[j-1];\\n                } else if (j == 0) {\\n                    max_left = nums1[i-1];\\n                } else {\\n                    max_left = max(nums1[i-1], nums2[j-1]);\\n                }\\n                \\n                if (total % 2 == 1) {\\n                    // Odd length, median is in the middle\\n                    return max_left;\\n                }\\n                \\n                int min_right;\\n                if (i == m) {\\n                    min_right = nums2[j];\\n                } else if (j == n) {\\n                    min_right = nums1[i];\\n                } else {\\n                    min_right = min(nums1[i], nums2[j]);\\n                }\\n                \\n                // Even length, median is average of two middle elements\\n                return (max_left + min_right) / 2.0;\\n            }\\n        }\\n        \\n        // Should never reach here\\n        return -1;\\n    }\\n};\\n\\n```\\n\\n# java code ---\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        // Ensure nums1 is smaller or equal in size to nums2\\n        if (nums1.length > nums2.length) {\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        // Length of the merged array\\n        int m = nums1.length;\\n        int n = nums2.length;\\n        int total = m + n;\\n        \\n        // Binary search variables\\n        int left = 0;\\n        int right = m;\\n        int i, j;\\n        \\n        // Binary search to find partition indices\\n        while (left <= right) {\\n            i = (left + right) / 2;\\n            j = (total + 1) / 2 - i;\\n            \\n            if (i < m && nums2[j-1] > nums1[i]) {\\n                // i is too small, increase it\\n                left = i + 1;\\n            } else if (i > 0 && nums1[i-1] > nums2[j]) {\\n                // i is too big, decrease it\\n                right = i - 1;\\n            } else {\\n                // i is perfect\\n                int max_left;\\n                if (i == 0) {\\n                    max_left = nums2[j-1];\\n                } else if (j == 0) {\\n                    max_left = nums1[i-1];\\n                } else {\\n                    max_left = Math.max(nums1[i-1], nums2[j-1]);\\n                }\\n                \\n                if (total % 2 == 1) {\\n                    // Odd length, median is in the middle\\n                    return max_left;\\n                }\\n                \\n                int min_right;\\n                if (i == m) {\\n                    min_right = nums2[j];\\n                } else if (j == n) {\\n                    min_right = nums1[i];\\n                } else {\\n                    min_right = Math.min(nums1[i], nums2[j]);\\n                }\\n                \\n                // Even length, median is average of two middle elements\\n                return (max_left + min_right) / 2.0;\\n            }\\n        }\\n        \\n        // Should never reach here\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n\\n        vector<int> num3;\\n        float sum;\\n        int n = nums1.size();\\n        int m = nums2.size(); \\n\\n        for(int i=0;i<n;i++)\\n        {\\n            num3.push_back(nums1[i]);\\n        } \\n        for(int j=0;j<m;j++)\\n        {\\n            num3.push_back(nums2[j]);\\n        } \\n        sort(num3.begin(),num3.end());\\n        if((n+m)%2==0)\\n        {\\n             sum = (float)(num3[(int)(m+n)/2]+num3[(int)(m+n)/2-1])/2;\\n        }\\n        else if((n+m)%2!=0)\\n        {\\n            sum = (float)num3[(int)(m+n-1)/2];\\n        }\\n\\n            return sum;\\n\\n\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        // Ensure nums1 is smaller or equal in size to nums2\\n        if (nums1.size() > nums2.size()) {\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        // Length of the merged array\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        int total = m + n;\\n        \\n        // Binary search variables\\n        int left = 0;\\n        int right = m;\\n        int i, j;\\n        \\n        // Binary search to find partition indices\\n        while (left <= right) {\\n            i = (left + right) / 2;\\n            j = (total + 1) / 2 - i;\\n            \\n            if (i < m && nums2[j-1] > nums1[i]) {\\n                // i is too small, increase it\\n                left = i + 1;\\n            } else if (i > 0 && nums1[i-1] > nums2[j]) {\\n                // i is too big, decrease it\\n                right = i - 1;\\n            } else {\\n                // i is perfect\\n                int max_left;\\n                if (i == 0) {\\n                    max_left = nums2[j-1];\\n                } else if (j == 0) {\\n                    max_left = nums1[i-1];\\n                } else {\\n                    max_left = max(nums1[i-1], nums2[j-1]);\\n                }\\n                \\n                if (total % 2 == 1) {\\n                    // Odd length, median is in the middle\\n                    return max_left;\\n                }\\n                \\n                int min_right;\\n                if (i == m) {\\n                    min_right = nums2[j];\\n                } else if (j == n) {\\n                    min_right = nums1[i];\\n                } else {\\n                    min_right = min(nums1[i], nums2[j]);\\n                }\\n                \\n                // Even length, median is average of two middle elements\\n                return (max_left + min_right) / 2.0;\\n            }\\n        }\\n        \\n        // Should never reach here\\n        return -1;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        // Ensure nums1 is smaller or equal in size to nums2\\n        if (nums1.length > nums2.length) {\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        // Length of the merged array\\n        int m = nums1.length;\\n        int n = nums2.length;\\n        int total = m + n;\\n        \\n        // Binary search variables\\n        int left = 0;\\n        int right = m;\\n        int i, j;\\n        \\n        // Binary search to find partition indices\\n        while (left <= right) {\\n            i = (left + right) / 2;\\n            j = (total + 1) / 2 - i;\\n            \\n            if (i < m && nums2[j-1] > nums1[i]) {\\n                // i is too small, increase it\\n                left = i + 1;\\n            } else if (i > 0 && nums1[i-1] > nums2[j]) {\\n                // i is too big, decrease it\\n                right = i - 1;\\n            } else {\\n                // i is perfect\\n                int max_left;\\n                if (i == 0) {\\n                    max_left = nums2[j-1];\\n                } else if (j == 0) {\\n                    max_left = nums1[i-1];\\n                } else {\\n                    max_left = Math.max(nums1[i-1], nums2[j-1]);\\n                }\\n                \\n                if (total % 2 == 1) {\\n                    // Odd length, median is in the middle\\n                    return max_left;\\n                }\\n                \\n                int min_right;\\n                if (i == m) {\\n                    min_right = nums2[j];\\n                } else if (j == n) {\\n                    min_right = nums1[i];\\n                } else {\\n                    min_right = Math.min(nums1[i], nums2[j]);\\n                }\\n                \\n                // Even length, median is average of two middle elements\\n                return (max_left + min_right) / 2.0;\\n            }\\n        }\\n        \\n        // Should never reach here\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162206,
                "title": "python-ez-code-binary-search-o-logn-runtime-explained",
                "content": "\\uD83D\\uDCA1The problem \\'Median of two sorted arrays\\' is a classic computer science problem that involves finding the median value in a set of numbers, where the numbers are split between two sorted arrays. The median is the middle value in a set of numbers, or if there are an even numbers of values, the average of the two middle values.\\n\\nThe purpose of finding the median of two sorted arrays is to effciently locate the middle value(s) in a combined set of numbers without having to first merge the arrays. This is useful when working with large arrays,as mergin two large arrays can be time-consuming. By using the sorting information of the arrays, it is possible to find the median in O(log(min(m,n))) time, where m and n are the lengths of the two arryas.\\n\\n---\\n\\n# Approach\\n1. Determine the length of both arrays \\'nums1\\' and \\'nums2\\'. Let \\'m\\' be the length of \\'nums1\\' and \\'n\\' be the length of \\'nums2\\'.\\n2. Choose The array with the smaller length to be the first array. This is because binary search requires that we divide the array into two parts and compare values on both sides. If we start with the larger array, it would take longer to find the partion points because there would be more values to search through. By starting with the smaller array,we reduce the search space and make the process more efficent.\\n3. Initialize two variables, \\'imin\\' and \\'imax\\', to keep track of the range of possible values for \\'i\\', the partition point in \\'nums1\\'. Set \\'imin\\' to 0 and \\'imax\\' to \\'m\\'/\\n4. Calculate the desired length of elements on both sides on the partition points. let \\'half_len\\' be equal to \\'(m+n+1)//2\\n5. Use a while loop to perform binary search. while \\'imin\\' is less than or equal to \\'imax\\',do the following:\\na. Calculate the partition point in \\'nums1\\' by finding the average of \\'imin\\' and \\'imax\\' and rounding down. Let \\'i =(imin +imax) //2\\'\\nb. Calculate the corresponding partion point in \\'nums2\\' by substracting \\'i\\' from \\'half_len\\' . Let \\'j =half_len -i\\'\\nc. Compare the values on both sides of the partition points. If \\'i<m\\' abd \\'nums2[j-1] > nums1[i], it means that \\'i\\' is too small, so we need to increase it. Update \\'imin\\' to \\'i+1\\'. If \\'i>0\\' and \\'nums1[i-1] > nums2[j]\\', It means that \\'i\\' is too large, so we need to decrease it. Update \\'imax\\' to \\'i-1\\'.\\nd. If \\'i\\' is such that the number of elements on both sides of the partion points is roughly equal, we have found the partion points. Go to step 6\\n6. Calculate the median based on the values on both sides of the partion points. If the total number of elements \\'(m+n)\\' is odd, the median is simply the maximun value on the left side of the partition points.If the total number of element is even, the median is the average of the maximun value on the left side and the mimimun value on the right side of the partition points.\\n7. Return the median as the result.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findMedianSortedArrays(self,nums1, nums2):\\n        m, n = len(nums1), len(nums2)\\n        if m > n:\\n            nums1, nums2, m, n = nums2, nums1, n, m\\n\\n        imin, imax, half_len = 0, m, (m + n + 1) // 2\\n        while imin <= imax:\\n            i = (imin + imax) // 2\\n            j = half_len - i\\n            if i < m and nums2[j-1] > nums1[i]:\\n                imin = i + 1\\n            elif i > 0 and nums1[i-1] > nums2[j]:\\n                imax = i - 1\\n            else:\\n                if i == 0: max_of_left = nums2[j-1]\\n                elif j == 0: max_of_left = nums1[i-1]\\n                else: max_of_left = max(nums1[i-1], nums2[j-1])\\n\\n                if (m + n) % 2 == 1:\\n                    return max_of_left\\n\\n                if i == m: min_of_right = nums2[j]\\n                elif j == n: min_of_right = nums1[i]\\n                else: min_of_right = min(nums1[i], nums2[j])\\n\\n                return (max_of_left + min_of_right) / 2.0\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution(object):\\n    def findMedianSortedArrays(self,nums1, nums2):\\n        m, n = len(nums1), len(nums2)\\n        if m > n:\\n            nums1, nums2, m, n = nums2, nums1, n, m\\n\\n        imin, imax, half_len = 0, m, (m + n + 1) // 2\\n        while imin <= imax:\\n            i = (imin + imax) // 2\\n            j = half_len - i\\n            if i < m and nums2[j-1] > nums1[i]:\\n                imin = i + 1\\n            elif i > 0 and nums1[i-1] > nums2[j]:\\n                imax = i - 1\\n            else:\\n                if i == 0: max_of_left = nums2[j-1]\\n                elif j == 0: max_of_left = nums1[i-1]\\n                else: max_of_left = max(nums1[i-1], nums2[j-1])\\n\\n                if (m + n) % 2 == 1:\\n                    return max_of_left\\n\\n                if i == m: min_of_right = nums2[j]\\n                elif j == n: min_of_right = nums1[i]\\n                else: min_of_right = min(nums1[i], nums2[j])\\n\\n                return (max_of_left + min_of_right) / 2.0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253685,
                "title": "java-2ms-99-87-merge-method-with-m-n-2-iterations",
                "content": "```\\nKINDLY UPVOTE IF YOU FIND IT USEFULL\\n```\\n\\n\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] a, int[] b) {\\n       int len = a.length + b.length;\\n        \\n        int aIndex = 0; \\n        int bIndex = 0; \\n        \\n        int previous = 0;          \\n        int current = 0;        \\n        int resultIndex = 0;       \\n        \\n        while(resultIndex ++ <= (len / 2)) {     \\n            \\n            previous = current;          \\n\\n            if(aIndex >= a.length) {     \\n                current = b[bIndex ++];   \\n                continue;                \\n            } \\n            \\n            if(bIndex >= b.length ) {   \\n                current = a[aIndex ++];\\n                continue;\\n            } \\n            \\n            if(a[aIndex] < b[bIndex]) {  \\n                current = a[aIndex ++];\\n               }\\n          \\n          else {\\n                current = b[bIndex ++];\\n            }\\n        }\\n        \\n        if(len % 2 == 0) {   \\n            return (double) (previous  + current) / 2; \\n        } else {\\n            return (double) current;          \\n      }\\n   }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nKINDLY UPVOTE IF YOU FIND IT USEFULL\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1961334,
                "title": "median-of-two-sorted-arrays",
                "content": "## Easy C++ Solution ------->\\n### Using Binary Search                             \\nTc : O(log(n+m))\\n\\nSteps :\\n\\n1) We are taking nums2 as greater size if not call the same function just flipping the argument.\\n2) Using the concept of  binary search, we are taking low and high.\\n3) we are going to partioned both array in two part  i,e   left part(including the elements of nums1 and nums2 or either )  and right  part (Also containing elements of nums1 and nums2 or either ) such that \\n All the elements of left part less than  all the elements of right part\\n -> if (size1 + size2) is even  then median = max(left1,left2)+min(right1,right2)/2\\n -> if odd then median = max(left1,left2).\\n \\n4) else If left1 is greater than right2 (Need to minimize the left1)\\n     so, shift high as  part1-1;\\n\\t \\n\\t else shift low as part1+1;\\n\\n### Please upvote if you understand ---\\n\\n\\n```     \\n\\n  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n           if(nums2.size()<nums1.size())\\n               return findMedianSortedArrays(nums2,nums1);\\n         \\n        int sz1 = nums1.size();\\n        int sz2 = nums2.size();\\n        \\n        int low = 0;\\n        int high = sz1;\\n        \\n        while(low<=high){\\n            \\n            int part1 = (low+high)/2;\\n            int part2 = (sz1+sz2+1)/2 - part1;\\n            \\n            int left1 = part1 == 0 ? INT_MIN : nums1[part1-1];\\n            int left2 = part2==0 ? INT_MIN : nums2[part2-1];\\n            \\n            int right1 = part1==sz1 ? INT_MAX : nums1[part1];\\n            int right2 = part2==sz2 ? INT_MAX : nums2[part2];\\n            \\n            if(left1<= right2  && left2<= right1){\\n                if((sz1+sz2) & 1)\\n                    return max(left1,left2);\\n                \\n                else \\n                    return (max(left1,left2) + min(right1,right2))/2.0;\\n            }\\n            \\n            else if(left1> right2)\\n                high = part1-1;\\n            \\n            else\\n                low = part1+1;\\n        }\\n        \\n        return 0.0;\\n               \\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```     \\n\\n  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n           if(nums2.size()<nums1.size())\\n               return findMedianSortedArrays(nums2,nums1);\\n         \\n        int sz1 = nums1.size();\\n        int sz2 = nums2.size();\\n        \\n        int low = 0;\\n        int high = sz1;\\n        \\n        while(low<=high){\\n            \\n            int part1 = (low+high)/2;\\n            int part2 = (sz1+sz2+1)/2 - part1;\\n            \\n            int left1 = part1 == 0 ? INT_MIN : nums1[part1-1];\\n            int left2 = part2==0 ? INT_MIN : nums2[part2-1];\\n            \\n            int right1 = part1==sz1 ? INT_MAX : nums1[part1];\\n            int right2 = part2==sz2 ? INT_MAX : nums2[part2];\\n            \\n            if(left1<= right2  && left2<= right1){\\n                if((sz1+sz2) & 1)\\n                    return max(left1,left2);\\n                \\n                else \\n                    return (max(left1,left2) + min(right1,right2))/2.0;\\n            }\\n            \\n            else if(left1> right2)\\n                high = part1-1;\\n            \\n            else\\n                low = part1+1;\\n        }\\n        \\n        return 0.0;\\n               \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1535675,
                "title": "python-2-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Merge 2 sorted array idea**\\n```python\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        m, n = len(nums1), len(nums2)\\n        medianIdx1 = (m + n) // 2\\n        medianIdx2 = (m + n - 1) // 2\\n        i = j = k = 0\\n        medianSum = 0\\n        while i < m or j < n:\\n            if j == n or i < m and nums1[i] < nums2[j]:\\n                cur = nums1[i]\\n                i += 1\\n            else:\\n                cur = nums2[j]\\n                j += 1\\n            if k == medianIdx1:\\n                medianSum += cur\\n            if k == medianIdx2:\\n                medianSum += cur\\n            k += 1\\n\\n        return medianSum / 2\\n```\\nComplexity:\\n- Time: `O(M + N)`, where `M <= 1000` is length of `nums1`, `N <= 1000` is length of `nums2`.\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Binary Search**\\n```python\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        m, n = len(nums1), len(nums2)\\n        if m > n: return self.findMedianSortedArrays(nums2, nums1)\\n        left = 0\\n        right = m\\n        while left <= right:\\n            partition1 = (left + right) // 2\\n            partition2 = (m + n + 1) // 2 - partition1\\n            left1 = -math.inf if partition1 == 0 else nums1[partition1-1]\\n            left2 = -math.inf if partition2 == 0 else nums2[partition2-1]\\n            right1 = math.inf if partition1 == m else nums1[partition1]\\n            right2 = math.inf if partition2 == n else nums2[partition2]\\n            if left1 <= right2 and left2 <= right1:\\n                if (m+n) % 2 == 1:\\n                    return max(left1, left2)\\n                return (max(left1, left2) + min(right1, right2)) / 2\\n            if left1 > right2:\\n                right = partition1 - 1\\n            else:\\n                left = partition1 + 1\\n```\\nComplexity:\\n- Time: `O(log(min(M, N)))`, where `M <= 1000` is length of `nums1`, `N <= 1000` is length of `nums2`.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        m, n = len(nums1), len(nums2)\\n        medianIdx1 = (m + n) // 2\\n        medianIdx2 = (m + n - 1) // 2\\n        i = j = k = 0\\n        medianSum = 0\\n        while i < m or j < n:\\n            if j == n or i < m and nums1[i] < nums2[j]:\\n                cur = nums1[i]\\n                i += 1\\n            else:\\n                cur = nums2[j]\\n                j += 1\\n            if k == medianIdx1:\\n                medianSum += cur\\n            if k == medianIdx2:\\n                medianSum += cur\\n            k += 1\\n\\n        return medianSum / 2\\n```\n```python\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        m, n = len(nums1), len(nums2)\\n        if m > n: return self.findMedianSortedArrays(nums2, nums1)\\n        left = 0\\n        right = m\\n        while left <= right:\\n            partition1 = (left + right) // 2\\n            partition2 = (m + n + 1) // 2 - partition1\\n            left1 = -math.inf if partition1 == 0 else nums1[partition1-1]\\n            left2 = -math.inf if partition2 == 0 else nums2[partition2-1]\\n            right1 = math.inf if partition1 == m else nums1[partition1]\\n            right2 = math.inf if partition2 == n else nums2[partition2]\\n            if left1 <= right2 and left2 <= right1:\\n                if (m+n) % 2 == 1:\\n                    return max(left1, left2)\\n                return (max(left1, left2) + min(right1, right2)) / 2\\n            if left1 > right2:\\n                right = partition1 - 1\\n            else:\\n                left = partition1 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067613,
                "title": "python-o-log-m-n-with-explanation-and-comments",
                "content": "- **Intuition:**\\n\\t- time complexity log --> binary search, recursion, each time divide by 2\\n- **Big Idea:**\\n\\t- median: eliminate half of ```(m+n)//2``` --> in other words, find the ```(m+n)//2``` index, let\\'s call the kth index, or eliminate k elements (0-based)\\n- **Recursion:**\\n\\t- base case: ```k = 0``` -> we have eliminated all the elements smaller than k, the median, so we just need to find the next biggest one\\n\\t\\t- i.e. ```min(nums1[0], nums2[0])```\\n\\t- b/c arrays are sorted and we have two arrays, each iteration we can be sure to eliminate k//2 elements by comparing nums1[k//2] and nums2[k//2]\\n\\t\\t- e.g. ```if nums1[k//2] <= nums2[k//2]```, then left of nums1[k//2] (inclusive) would definitely be smaller than the median so can be safely eliminated\\n\\t- b/c k //2 could be bigger than the length of one array (e.g. nums1) and nums1[k//2] would be out of index, the subarray to be eliminated for each round needs to take into account of the length of the two arrays\\n\\t\\t- length to be eliminated for each round: ```min(m, n, k//2)```\\n\\t- update the array that gets its subarray eliminated --> ```nums1 = nums1[k//2+1:]```\\n\\t- update k -> ```k -= eliminated_length```\\n- **Time Complexity: O(log(m+n))**\\n\\t- each time we divide k by 2 until k is 0 so O(log k).\\n\\t- ```k = (m+n) // 2``` so O(log(m+n))\\n- **Space Complexity: ?**\\n\\t- Not sure, O(1)?\\n- **Note:**\\n\\t- I know using starting and ending pointers is better, but I think slicing is easier to explain and understand\\n\\n\\t\\n\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2) -> float:\\n        # odd length -> e.g. length 5, left(2) and right(2) would be the same index\\n        # even length -> e.g. length 6, left(2) and right(3) would be different indices\\n        m, n = len(nums1), len(nums2)\\n        left, right = (m+n-1)//2, (m+n)//2\\n        return (self.getKth(nums1, nums2, left) + self.getKth(nums1, nums2, right))/2\\n    \\n    def getKth(self, nums1, nums2, k):\\n        # if one list is exhausted, return the kth index of the other list\\n        if nums1 == []:\\n            return nums2[k]\\n        if nums2 == []:\\n            return nums1[k]\\n\\n        # base case\\n        # k is 0-based, so finding the kth index equals eliminating k length elements. \\n\\t\\t# k == 0 means we have eliminated all smaller indices, return the next highest number, which would be the median\\n        # e.g. to find the third index (k = 3), we eliminate 3 smaller elements (index 0, 1, 2)\\n        if k == 0:\\n            return min(nums1[0], nums2[0])\\n\\n        # find the subarray to be eliminated this iteration\\n        m, n = len(nums1), len(nums2)\\n        eliminated_length = min(m,n,(k+1)//2)                 # 1-based so k + 1\\n        eliminated_index = eliminated_length - 1              # 0-based so - 1\\n        if nums1[eliminated_index] <= nums2[eliminated_index]:\\n            nums1 = nums1[eliminated_index+1:]\\n        else:\\n            nums2 = nums2[eliminated_index+1:]\\n        \\n        # update k, the number of elements to be eliminated next round\\n        k -= eliminated_length\\n\\n        return self.getKth(nums1, nums2, k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```(m+n)//2```\n```(m+n)//2```\n```k = 0```\n```min(nums1[0], nums2[0])```\n```if nums1[k//2] <= nums2[k//2]```\n```min(m, n, k//2)```\n```nums1 = nums1[k//2+1:]```\n```k -= eliminated_length```\n```k = (m+n) // 2```\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1, nums2) -> float:\\n        # odd length -> e.g. length 5, left(2) and right(2) would be the same index\\n        # even length -> e.g. length 6, left(2) and right(3) would be different indices\\n        m, n = len(nums1), len(nums2)\\n        left, right = (m+n-1)//2, (m+n)//2\\n        return (self.getKth(nums1, nums2, left) + self.getKth(nums1, nums2, right))/2\\n    \\n    def getKth(self, nums1, nums2, k):\\n        # if one list is exhausted, return the kth index of the other list\\n        if nums1 == []:\\n            return nums2[k]\\n        if nums2 == []:\\n            return nums1[k]\\n\\n        # base case\\n        # k is 0-based, so finding the kth index equals eliminating k length elements. \\n\\t\\t# k == 0 means we have eliminated all smaller indices, return the next highest number, which would be the median\\n        # e.g. to find the third index (k = 3), we eliminate 3 smaller elements (index 0, 1, 2)\\n        if k == 0:\\n            return min(nums1[0], nums2[0])\\n\\n        # find the subarray to be eliminated this iteration\\n        m, n = len(nums1), len(nums2)\\n        eliminated_length = min(m,n,(k+1)//2)                 # 1-based so k + 1\\n        eliminated_index = eliminated_length - 1              # 0-based so - 1\\n        if nums1[eliminated_index] <= nums2[eliminated_index]:\\n            nums1 = nums1[eliminated_index+1:]\\n        else:\\n            nums2 = nums2[eliminated_index+1:]\\n        \\n        # update k, the number of elements to be eliminated next round\\n        k -= eliminated_length\\n\\n        return self.getKth(nums1, nums2, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 611526,
                "title": "python-o-log-min-m-n-solution-with-detailed-explaination",
                "content": "* The problem asks solution with log(m+n) which means we have to use something like a binary search to find the median of the two sorted array. Here, to simplify the question, we assume that (len(nums1)+len(nums2))%2==1, which means we only need to find the single element in either nums1 or nums2 that is the overall (m+n+1)/2 th number. \\n* What we are going to do is to find the **ith** number in nums1 and **jth** number in nums2 which satisfy the **i+j=(m+n+1)/2**, and also **max(nums1[i],nums[j])<=min(nums1[i+1],nums2[j+1])**, and the median would simpley be the **max(nums1[i],num2[j])**, because we have find overall **(m+n+1)/2th** number. Assume **len(nums1)<len(nums2)**, we can start from end of nums1 with **i=len(nums1)** and **j=(m+n+1)/2-i**. Now if the pair satisfy the condition, we output the median. However if **nums1[i]>nums2[j+1],we move i to the left in a binary search fashion** and if **nums1[i+1]<num2[j],we move i to the right as in binary search.** There\\'re some small issues you have to take care of when you are at the boundary, **i==0 or i==len(nums1)**, but the whole idea was what I explained above.\\n* I will show a process below of the binary search process, hopefully it will make it easier to understant.\\n![image](https://assets.leetcode.com/users/dtshuai39/image_1588536549.png)\\n\\n* The code is as follows, please fogive me for not writing it in a very consise way. \\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        if not nums1 or not nums2:\\n            if not nums1:\\n                if len(nums2)%2==0:\\n                    return (nums2[len(nums2)//2-1]+nums2[len(nums2)//2])/2\\n                else:\\n                    return nums2[(len(nums2)-1)//2]\\n            else:\\n                if len(nums1)%2==0:\\n                    return (nums1[len(nums1)//2-1]+nums1[len(nums1)//2])/2\\n                else:\\n                    return nums1[(len(nums1)-1)//2]\\n        elif len(nums1)==1 or len(nums2)==1:\\n            if len(nums1)<=len(nums2):\\n                return self.find_median_single(nums1,nums2)\\n            else:\\n                return self.find_median_single(nums2,nums1)\\n        else:\\n            # both nums1 and num2 greater than 1\\n            m=len(nums1)\\n            n=len(nums2)\\n            if m>=n:\\n                if (m+n)%2==1:\\n                    # need to return 1\\n                    return self.find_median(nums1,nums2, 0, 2*(n-1), (m+n+1)//2)\\n                else:\\n                    return (self.find_median(nums1,nums2, 0, 2*(n-1), (m+n)//2)+self.find_median(nums1,nums2, 0, 2*(n-1), (m+n)//2+1))/2\\n            else:\\n                if (m+n)%2==1:\\n                    # need to return 1 number\\n                    return self.find_median(nums2,nums1, 0, 2*(m-1), (m+n+1)//2)\\n                else:\\n                    return (self.find_median(nums2,nums1, 0, 2*(m-1), (m+n)//2)+self.find_median(nums2,nums1, 0, 2*(m-1), (m+n)//2+1))/2\\n        \\n    def find_median_single(self, nums1, nums2):\\n        # len(nums1)<=len(nums2)\\n        if len(nums1)==1 and len(nums2)==1:\\n            return (nums1[0]+nums2[0])/2\\n        else:\\n            if (len(nums1)+len(nums2))%2==1:\\n                # single number\\n                if nums1[0]>nums2[len(nums2)//2]:\\n                    return nums2[len(nums2)//2]\\n                else:\\n                    return max(nums1[0],nums2[len(nums2)//2-1])\\n            else:\\n                # return double number\\n                if nums1[0]>nums2[(len(nums2)+1)//2]:\\n                    return (nums2[(len(nums2)-1)//2]+nums2[(len(nums2)+1)//2])/2\\n                else:\\n                    return (nums2[(len(nums2)-1)//2]+max(nums1[0],nums2[(len(nums2)-3)//2]))/2\\n        \\n    def find_median(self, A, B, low, high, target):\\n        # B is shorter one len(B)<=len(A) and len(B)> 1\\n        j=(low+high)//2\\n        i=target-2-j\\n        # cases when the median \\n        if j<0:\\n            # if j smaller than zero\\n            # that means the median comes from array A\\n            return A[target-1]\\n        elif j==0:\\n            # see if it satisfy the condition\\n            if i==len(A)-1:\\n                if A[i]<=B[j+1]:\\n                    return max(A[i],B[j])\\n                else:\\n                    # move to the right\\n                    return self.find_median(A,B,j+1,high, target)\\n            else:\\n                # see if condition is satisfied\\n                if max(A[i],B[j])<=min(A[i+1],B[j+1]):\\n                    return max(A[i],B[j])\\n                else:\\n                    # move to the right\\n                    if A[i]>B[j+1]:\\n                        return self.find_median(A,B, j+1, high, target)\\n                    elif B[j]>A[i+1]: \\n                        # move to the left\\n                        return self.find_median(A,B, low, j-1, target)\\n        elif j==len(B)-1:\\n            # see if i<=0:\\n            if i<0:\\n                # compare B[j] with A[2]\\n                i=0\\n                if B[j]<=A[i+1]:\\n                    if A[i]>=B[j]:\\n                        return B[j]\\n                    else:\\n                        return max(A[i],B[j-1])\\n                else:\\n                    # move to the left\\n                    return self.find_median(A,B,low, j-1,target)\\n            else:\\n                # initially if it satisfy the condition\\n                if B[j]<=A[i+1]:\\n                    return max(A[i],B[j])\\n                else:\\n                    # move to the left\\n                    return self.find_median(A,B,low, j-1,target)\\n        else:\\n            if max(A[i],B[j])<=min(A[i+1], B[j+1]):\\n                return max(A[i],B[j])\\n            else:\\n                if B[j]>A[i+1]:\\n                    # move to the left\\n                    return self.find_median(A,B,low, j-1,target)\\n                    # move to the right\\n                elif B[j+1]<A[i]:\\n                    if j+1>high:\\n                        return B[j+1]\\n                    else:\\n                        return self.find_median(A,B,j+1,high, target)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        if not nums1 or not nums2:\\n            if not nums1:\\n                if len(nums2)%2==0:\\n                    return (nums2[len(nums2)//2-1]+nums2[len(nums2)//2])/2\\n                else:\\n                    return nums2[(len(nums2)-1)//2]\\n            else:\\n                if len(nums1)%2==0:\\n                    return (nums1[len(nums1)//2-1]+nums1[len(nums1)//2])/2\\n                else:\\n                    return nums1[(len(nums1)-1)//2]\\n        elif len(nums1)==1 or len(nums2)==1:\\n            if len(nums1)<=len(nums2):\\n                return self.find_median_single(nums1,nums2)\\n            else:\\n                return self.find_median_single(nums2,nums1)\\n        else:\\n            # both nums1 and num2 greater than 1\\n            m=len(nums1)\\n            n=len(nums2)\\n            if m>=n:\\n                if (m+n)%2==1:\\n                    # need to return 1\\n                    return self.find_median(nums1,nums2, 0, 2*(n-1), (m+n+1)//2)\\n                else:\\n                    return (self.find_median(nums1,nums2, 0, 2*(n-1), (m+n)//2)+self.find_median(nums1,nums2, 0, 2*(n-1), (m+n)//2+1))/2\\n            else:\\n                if (m+n)%2==1:\\n                    # need to return 1 number\\n                    return self.find_median(nums2,nums1, 0, 2*(m-1), (m+n+1)//2)\\n                else:\\n                    return (self.find_median(nums2,nums1, 0, 2*(m-1), (m+n)//2)+self.find_median(nums2,nums1, 0, 2*(m-1), (m+n)//2+1))/2\\n        \\n    def find_median_single(self, nums1, nums2):\\n        # len(nums1)<=len(nums2)\\n        if len(nums1)==1 and len(nums2)==1:\\n            return (nums1[0]+nums2[0])/2\\n        else:\\n            if (len(nums1)+len(nums2))%2==1:\\n                # single number\\n                if nums1[0]>nums2[len(nums2)//2]:\\n                    return nums2[len(nums2)//2]\\n                else:\\n                    return max(nums1[0],nums2[len(nums2)//2-1])\\n            else:\\n                # return double number\\n                if nums1[0]>nums2[(len(nums2)+1)//2]:\\n                    return (nums2[(len(nums2)-1)//2]+nums2[(len(nums2)+1)//2])/2\\n                else:\\n                    return (nums2[(len(nums2)-1)//2]+max(nums1[0],nums2[(len(nums2)-3)//2]))/2\\n        \\n    def find_median(self, A, B, low, high, target):\\n        # B is shorter one len(B)<=len(A) and len(B)> 1\\n        j=(low+high)//2\\n        i=target-2-j\\n        # cases when the median \\n        if j<0:\\n            # if j smaller than zero\\n            # that means the median comes from array A\\n            return A[target-1]\\n        elif j==0:\\n            # see if it satisfy the condition\\n            if i==len(A)-1:\\n                if A[i]<=B[j+1]:\\n                    return max(A[i],B[j])\\n                else:\\n                    # move to the right\\n                    return self.find_median(A,B,j+1,high, target)\\n            else:\\n                # see if condition is satisfied\\n                if max(A[i],B[j])<=min(A[i+1],B[j+1]):\\n                    return max(A[i],B[j])\\n                else:\\n                    # move to the right\\n                    if A[i]>B[j+1]:\\n                        return self.find_median(A,B, j+1, high, target)\\n                    elif B[j]>A[i+1]: \\n                        # move to the left\\n                        return self.find_median(A,B, low, j-1, target)\\n        elif j==len(B)-1:\\n            # see if i<=0:\\n            if i<0:\\n                # compare B[j] with A[2]\\n                i=0\\n                if B[j]<=A[i+1]:\\n                    if A[i]>=B[j]:\\n                        return B[j]\\n                    else:\\n                        return max(A[i],B[j-1])\\n                else:\\n                    # move to the left\\n                    return self.find_median(A,B,low, j-1,target)\\n            else:\\n                # initially if it satisfy the condition\\n                if B[j]<=A[i+1]:\\n                    return max(A[i],B[j])\\n                else:\\n                    # move to the left\\n                    return self.find_median(A,B,low, j-1,target)\\n        else:\\n            if max(A[i],B[j])<=min(A[i+1], B[j+1]):\\n                return max(A[i],B[j])\\n            else:\\n                if B[j]>A[i+1]:\\n                    # move to the left\\n                    return self.find_median(A,B,low, j-1,target)\\n                    # move to the right\\n                elif B[j+1]<A[i]:\\n                    if j+1>high:\\n                        return B[j+1]\\n                    else:\\n                        return self.find_median(A,B,j+1,high, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284794,
                "title": "java-iterative-explained",
                "content": "**Idea:** \\n* Since the arrays are sorted, we can use binary search\\n* `>> 1` is just a more efficient way of dividing by 2\\n>**T/S:** O(log min(m, n))/O(1), where m = size(nums1), n = size(nums2)\\n```\\npublic double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n\\tvar m = nums1.length;\\n\\tvar n = nums2.length;\\n    var high = m;\\n\\t\\n\\t// ensuring nums2 is longer than num1\\n\\tif (m > n)\\n\\t\\treturn findMedianSortedArrays(nums2, nums1);\\n\\t\\t\\n\\tfor (var low = 0; low <= high;) {\\n\\t\\n\\t\\tvar p1 = low + high >> 1; // partition of nums1\\n\\t\\tvar p2 = (m + n + 1 >> 1) - p1; // partition of nums2. \\n\\t\\t// +1 because it plays well with both odd and even number of elements in the combined array\\n\\t\\tvar maxLeft1 = (p1 == 0) ? Integer.MIN_VALUE : nums1[p1 - 1];\\n\\t\\tvar minRight1 = (p1 == m) ? Integer.MAX_VALUE : nums1[p1];\\n\\t\\tvar maxLeft2 = (p2 == 0) ? Integer.MIN_VALUE : nums2[p2 - 1];\\n\\t\\tvar minRight2 = (p2 == n) ? Integer.MAX_VALUE : nums2[p2];\\n\\n\\t\\tif (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) // median found\\n\\t\\t\\tif ((m + n & 1) == 0) // if m + n is even\\n\\t\\t\\t\\treturn (Math.max(maxLeft1, maxLeft2) \\n\\t\\t\\t\\t\\t  + Math.min(minRight1, minRight2)) / 2d;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn Math.max(maxLeft1, maxLeft2) * 1d;\\n\\t\\telse if (maxLeft1 > minRight2) // too right on nums1, move left\\n\\t\\t\\thigh = p1 - 1;\\n\\t\\telse // too left on nums1, move right\\n\\t\\t\\tlow = p1 + 1;\\n\\t}\\n\\n\\treturn 0;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\npublic double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n\\tvar m = nums1.length;\\n\\tvar n = nums2.length;\\n    var high = m;\\n\\t\\n\\t// ensuring nums2 is longer than num1\\n\\tif (m > n)\\n\\t\\treturn findMedianSortedArrays(nums2, nums1);\\n\\t\\t\\n\\tfor (var low = 0; low <= high;) {\\n\\t\\n\\t\\tvar p1 = low + high >> 1; // partition of nums1\\n\\t\\tvar p2 = (m + n + 1 >> 1) - p1; // partition of nums2. \\n\\t\\t// +1 because it plays well with both odd and even number of elements in the combined array\\n\\t\\tvar maxLeft1 = (p1 == 0) ? Integer.MIN_VALUE : nums1[p1 - 1];\\n\\t\\tvar minRight1 = (p1 == m) ? Integer.MAX_VALUE : nums1[p1];\\n\\t\\tvar maxLeft2 = (p2 == 0) ? Integer.MIN_VALUE : nums2[p2 - 1];\\n\\t\\tvar minRight2 = (p2 == n) ? Integer.MAX_VALUE : nums2[p2];\\n\\n\\t\\tif (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) // median found\\n\\t\\t\\tif ((m + n & 1) == 0) // if m + n is even\\n\\t\\t\\t\\treturn (Math.max(maxLeft1, maxLeft2) \\n\\t\\t\\t\\t\\t  + Math.min(minRight1, minRight2)) / 2d;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn Math.max(maxLeft1, maxLeft2) * 1d;\\n\\t\\telse if (maxLeft1 > minRight2) // too right on nums1, move left\\n\\t\\t\\thigh = p1 - 1;\\n\\t\\telse // too left on nums1, move right\\n\\t\\t\\tlow = p1 + 1;\\n\\t}\\n\\n\\treturn 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169489,
                "title": "c-solution-using-merging",
                "content": "```c\\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    double median, prev;\\n    int mid = (nums1Size + nums2Size) / 2;\\n    for (int i = 0, j = 0; ;) {\\n        if (j == nums2Size) {\\n            median = nums1[i++];\\n        } else if (i == nums1Size) {\\n            median = nums2[j++];\\n        } else if (nums1[i] < nums2[j]) {\\n            median = nums1[i++];\\n        } else {\\n            median = nums2[j++];\\n        }\\n        if (i + j > mid) {\\n            if ((nums1Size + nums2Size) % 2 == 0) {\\n                median = (prev + median) / 2;\\n            }\\n            return median;\\n        }\\n        prev = median;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```c\\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    double median, prev;\\n    int mid = (nums1Size + nums2Size) / 2;\\n    for (int i = 0, j = 0; ;) {\\n        if (j == nums2Size) {\\n            median = nums1[i++];\\n        } else if (i == nums1Size) {\\n            median = nums2[j++];\\n        } else if (nums1[i] < nums2[j]) {\\n            median = nums1[i++];\\n        } else {\\n            median = nums2[j++];\\n        }\\n        if (i + j > mid) {\\n            if ((nums1Size + nums2Size) % 2 == 0) {\\n                median = (prev + median) / 2;\\n            }\\n            return median;\\n        }\\n        prev = median;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3469340,
                "title": "best-solution-c-very-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n\\n\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        if(n2<n1) return findMedianSortedArrays(nums2,nums1);\\n        \\n        int low=0,high=n1;\\n        while(low<=high){\\n            int cut1=(high+low)/2;\\n            int cut2=(n1+n2+1)/2-cut1;\\n            \\n            int left1=cut1==0?INT_MIN:nums1[cut1-1];\\n            int left2=cut2==0?INT_MIN:nums2[cut2-1];\\n            \\n            int right1=cut1==n1?INT_MAX:nums1[cut1];\\n            int right2=cut2==n2?INT_MAX:nums2[cut2];\\n            \\n            if(left1<=right2 && left2<=right1){\\n                if((n1+n2)%2==0){\\n                    return (max(left1,left2)+min(right1,right2))/2.0;\\n                }else{\\n                    return max(left1,left2);\\n                }\\n            }else if(left1>right2){\\n                high=cut1-1;\\n            }else{\\n                low=cut1+1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        if(n2<n1) return findMedianSortedArrays(nums2,nums1);\\n        \\n        int low=0,high=n1;\\n        while(low<=high){\\n            int cut1=(high+low)/2;\\n            int cut2=(n1+n2+1)/2-cut1;\\n            \\n            int left1=cut1==0?INT_MIN:nums1[cut1-1];\\n            int left2=cut2==0?INT_MIN:nums2[cut2-1];\\n            \\n            int right1=cut1==n1?INT_MAX:nums1[cut1];\\n            int right2=cut2==n2?INT_MAX:nums2[cut2];\\n            \\n            if(left1<=right2 && left2<=right1){\\n                if((n1+n2)%2==0){\\n                    return (max(left1,left2)+min(right1,right2))/2.0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2677478,
                "title": "detailed-explanation-o-log-n-m-python3-binary-search-o-1-slicing",
                "content": "This is definitely a hard problem, however it can be solved in a simple way using binary search, with the following observations.\\n\\n\\n## Finding kth element of `nums1` and `nums2`\\nFirst, we solve a more general problem: Find the `kth` element from two sorted arrays, `nums1` and `nums2`.  \\n\\nSuppose that `i1` and `i2` are the indices of the medians of each list, and `med1` and `med2` are the corresponding medians.  We have 2 cases:\\n\\nCase 1: If `i1 + i2 < k`, we can safely discard the first half of one of the lists.  If `med1 < med2` we discard the first half of `nums1`, otherwise we discard the first half of `nums2`.\\n\\nCase 2: If `i1 + i2 >= k`, we can safely discard the right half of one of the lists.  If `med1 > med2`, we discard the right half of `nums1`, otherwise we discard the right half of `nums2`.\\n\\n## Finding median\\nIf `n = n1 + n2` is odd, the median is at `n // 2`.  If `n = n1 + n2` is even, the median is the average of the items at position `n // 2 - 1` and `n // 2`.  Hence, we can obtain the median using the `find_kth` function either once (in the odd case) or twice (in the even case).  \\n\\n## Reducing time complexity of slice\\nFor simplicity and readability, is it easiest to use slice operations to discard the left or right side of the arrays.  However, natively this operation is `O(k)`, where `k` is the length of the slice.  To reduce slice operations to `O(1)` we create a new list class which is a wrapper around python `list`, and which implements index-based slicing.  This class effectively keeps the underlying list unchanged, but just keeps track of the start/end indices of the current slice.  The class also enables repeated slicing.  \\n\\n## Time complexity\\nAt each stage, one of the lists gets subdivided in half.  Hence, the time complexity is `O(log(n1) + log(n2)) <= O(log(max(n1,n2))`.  This time complexity is slightly better than the desired complexity of `O(log(n1+n2))`.   We can prove this as follows:\\n\\n```\\nO(log(max(n1, n2))) <= O(log(max(n1,n2) + min(n1, n2)))\\n= O(log(n1 + n2))\\n```\\n\\n## Example\\n```\\nnums1 = [1,2,3]\\nnums2 = [2, 4]\\n```\\n`n = 5`, median is at `k = n // 2 = 2`\\n\\ncall `find_kth(nums1, num2, 2)`\\n```\\ni1 = 1, med1 = 2\\ni2 = 1, med2 = 4\\n```\\n`i1 + i2 = 2 >= k`, so we can truncate right half\\nsince `med2 >= med1`, we truncate right half of `nums2`\\n```\\nnums1 = [1,2,3]\\nnums2 = [2]\\n\\nfind_kth([1,2,3], [2], k = 2)\\n\\ni1 = 1, med1 = 2\\ni2 = 0, med2 = 2\\n```\\n`i1 + i2 = 1 < k`, so truncate left half\\nsince `med1 >= med2`, we truncate left half of `nums2`\\n```\\nnums1 = [1,2,3]\\nnums2 = []\\n```\\nupdate `k -> k- i2 - 1 = 2 - 0 - 1 = 1`\\n```\\nfind_kth([1,2,3], [], 1)\\n```\\nsince `nums2` is empty, we return `nums1[k] =nums1[1] = 2`\\n\\nHence, we computed `find_kth([1,2,3], [2,4], 2) = 2`.\\n\\nTo confirm this is correct, observe the entries sorted:\\n```\\n[1, 2, 2, 3, 4] - entries\\n[0,1,2,3,4] - indices\\n```\\nIndeed, the entry at position `2` is `2`.\\n\\nNow, since the total number of numbers is odd, we have found the median.  If the numbers were even, we would call find_kth for the two median positions.\\n\\n## Code\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        \"\"\"\\n        Find median \\n        \"\"\"\\n        nums1 = SliceableList(nums1)\\n        nums2 = SliceableList(nums2)\\n        \\n        n = len(nums1) + len(nums2)\\n        if(n % 2):\\n            return find_kth(nums1, nums2, n // 2)\\n        else:\\n            return (find_kth(nums1, nums2, n // 2 - 1) + find_kth(nums1, nums2, n // 2)) / 2\\n\\ndef find_kth(nums1,  nums2, k):\\n    n1, n2 = len(nums1), len(nums2)\\n    i1, i2 = n1 // 2, n2 // 2\\n    \\n    if(not n1):\\n        return nums2[k]\\n    elif(not n2):\\n        return nums1[k]\\n    \\n    med1, med2 = nums1[i1], nums2[i2]\\n\\n    if(i1 + i2 < k):\\n        #truncate first half of nums1 or nums2\\n        return find_kth(nums1[i1+1:],nums2, k- i1 - 1) if med1 < med2 else find_kth(nums1,nums2[i2+1:], k - i2 - 1) \\n    else:\\n        #truncate right half             \\n        return  find_kth(nums1[:i1],nums2, k) if med1 > med2 else find_kth(nums1,nums2[:i2], k) \\n\\nclass SliceableList:\\n    \"\"\"\\n    Sliceable List Class\\n    This is a wrapper around python `list` which enables O(1) slicing by keeping track of start/end indices.\\n    This enables using pythonic slicing syntax, while maintaining O(1) time for all slice operations.\\n    \"\"\"\\n    def __init__(self, _list, _start = 0, _end = None):\\n        n = len(_list)\\n        self._list = _list\\n        self._end = len(self._list) if _end is None else min(n, _end)\\n        self._start = 0 if _start is None else max(0,_start)\\n        \\n    def __len__(self):\\n        return max(0, self._end - self._start)\\n\\n    def __getslice__(self, i, j):\\n        if(i is None):\\n            i = 0\\n        if(j is None):\\n            j = len(self)\\n        return SliceableList(_list = self._list, _start = self._start + i, \\n            _end = min(self._end, self._start + j))\\n        \\n    def __getitem__(self, key):\\n        if(isinstance(key, slice)):\\n            return self.__getslice__(i = key.start, j = key.stop)\\n        \\n        if(self._start + key >= self._end):\\n            raise IndexError(\\'list index out of range\\')\\n        return self._list[self._start + key]\\n  \\n    def __repr__(self):\\n\\t    \"\"\"helper function for printing\"\"\"\\n        return self._list[self._start:self._end].__repr__()\\n```\\n        \\n\\t\\t\\n\\n        \\n\\n",
                "solutionTags": [
                    "Array",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nO(log(max(n1, n2))) <= O(log(max(n1,n2) + min(n1, n2)))\\n= O(log(n1 + n2))\\n```\n```\\nnums1 = [1,2,3]\\nnums2 = [2, 4]\\n```\n```\\ni1 = 1, med1 = 2\\ni2 = 1, med2 = 4\\n```\n```\\nnums1 = [1,2,3]\\nnums2 = [2]\\n\\nfind_kth([1,2,3], [2], k = 2)\\n\\ni1 = 1, med1 = 2\\ni2 = 0, med2 = 2\\n```\n```\\nnums1 = [1,2,3]\\nnums2 = []\\n```\n```\\nfind_kth([1,2,3], [], 1)\\n```\n```\\n[1, 2, 2, 3, 4] - entries\\n[0,1,2,3,4] - indices\\n```\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        \"\"\"\\n        Find median \\n        \"\"\"\\n        nums1 = SliceableList(nums1)\\n        nums2 = SliceableList(nums2)\\n        \\n        n = len(nums1) + len(nums2)\\n        if(n % 2):\\n            return find_kth(nums1, nums2, n // 2)\\n        else:\\n            return (find_kth(nums1, nums2, n // 2 - 1) + find_kth(nums1, nums2, n // 2)) / 2\\n\\ndef find_kth(nums1,  nums2, k):\\n    n1, n2 = len(nums1), len(nums2)\\n    i1, i2 = n1 // 2, n2 // 2\\n    \\n    if(not n1):\\n        return nums2[k]\\n    elif(not n2):\\n        return nums1[k]\\n    \\n    med1, med2 = nums1[i1], nums2[i2]\\n\\n    if(i1 + i2 < k):\\n        #truncate first half of nums1 or nums2\\n        return find_kth(nums1[i1+1:],nums2, k- i1 - 1) if med1 < med2 else find_kth(nums1,nums2[i2+1:], k - i2 - 1) \\n    else:\\n        #truncate right half             \\n        return  find_kth(nums1[:i1],nums2, k) if med1 > med2 else find_kth(nums1,nums2[:i2], k) \\n\\nclass SliceableList:\\n    \"\"\"\\n    Sliceable List Class\\n    This is a wrapper around python `list` which enables O(1) slicing by keeping track of start/end indices.\\n    This enables using pythonic slicing syntax, while maintaining O(1) time for all slice operations.\\n    \"\"\"\\n    def __init__(self, _list, _start = 0, _end = None):\\n        n = len(_list)\\n        self._list = _list\\n        self._end = len(self._list) if _end is None else min(n, _end)\\n        self._start = 0 if _start is None else max(0,_start)\\n        \\n    def __len__(self):\\n        return max(0, self._end - self._start)\\n\\n    def __getslice__(self, i, j):\\n        if(i is None):\\n            i = 0\\n        if(j is None):\\n            j = len(self)\\n        return SliceableList(_list = self._list, _start = self._start + i, \\n            _end = min(self._end, self._start + j))\\n        \\n    def __getitem__(self, key):\\n        if(isinstance(key, slice)):\\n            return self.__getslice__(i = key.start, j = key.stop)\\n        \\n        if(self._start + key >= self._end):\\n            raise IndexError(\\'list index out of range\\')\\n        return self._list[self._start + key]\\n  \\n    def __repr__(self):\\n\\t    \"\"\"helper function for printing\"\"\"\\n        return self._list[self._start:self._end].__repr__()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676267,
                "title": "faster-than-80-java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int index1 = 0;\\n        int index2 = 0;\\n        int med1 = 0;\\n        int med2 = 0;\\n        for (int i=0; i<=(nums1.length+nums2.length)/2; i++) {\\n        med1 = med2;\\n     \\n        if (index1 == nums1.length) \\n        {\\n            med2 = nums2[index2];\\n            index2++;\\n        } \\n        else if (index2 == nums2.length) {\\n            med2 = nums1[index1];\\n            index1++;\\n        } \\n        else if (nums1[index1] < nums2[index2] ) {\\n            med2 = nums1[index1];\\n         index1++;\\n        }\\n            else {\\n            med2 = nums2[index2];\\n            index2++;\\n            }\\n        }\\n    \\n    if ((nums1.length+nums2.length)%2 == 0){\\n            return (float)(med1+med2)/2;\\n    }\\n     return med2;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int index1 = 0;\\n        int index2 = 0;\\n        int med1 = 0;\\n        int med2 = 0;\\n        for (int i=0; i<=(nums1.length+nums2.length)/2; i++) {\\n        med1 = med2;\\n     \\n        if (index1 == nums1.length) \\n        {\\n            med2 = nums2[index2];\\n            index2++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2650989,
                "title": "median-of-two-sorted-arrays-in-simplest-way",
                "content": "```\\n int temp[]=new int[nums1.length+nums2.length];\\n        int i=0,j=0,k=0;\\n        while(i<nums1.length&&j<nums2.length){\\n            if(nums1[i]<nums2[j]){\\n                temp[k++]=nums1[i++];\\n            }\\n            else{\\n                temp[k++]=nums2[j++];\\n            }\\n        }\\n        if(i<nums1.length){\\n            while(i<nums1.length)\\n                temp[k++]=nums1[i++];\\n        }\\n        if(j<nums2.length){\\n            while(j<nums2.length)\\n                temp[k++]=nums2[j++];\\n        }\\n         int len=nums2.length+nums1.length;\\n        if(len%2==1)\\n            return temp[((len+1)/2)-1];\\n        else\\n            return((double)temp[(len/2)-1]+(double)temp[(len/2)])/2.0;\\n\\n\\n\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n int temp[]=new int[nums1.length+nums2.length];\\n        int i=0,j=0,k=0;\\n        while(i<nums1.length&&j<nums2.length){\\n            if(nums1[i]<nums2[j]){\\n                temp[k++]=nums1[i++];\\n            }\\n            else{\\n                temp[k++]=nums2[j++];\\n            }\\n        }\\n        if(i<nums1.length){\\n            while(i<nums1.length)\\n                temp[k++]=nums1[i++];\\n        }\\n        if(j<nums2.length){\\n            while(j<nums2.length)\\n                temp[k++]=nums2[j++];\\n        }\\n         int len=nums2.length+nums1.length;\\n        if(len%2==1)\\n            return temp[((len+1)/2)-1];\\n        else\\n            return((double)temp[(len/2)-1]+(double)temp[(len/2)])/2.0;\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2496488,
                "title": "java-100-faster-with-interview-format-explanation-2-approaches-clean-code",
                "content": "Upvote if the solution helped :) For all my optimised solutions, Click || -->[Here](https://github.com/abhideepghosh/Leetcode-Solutions)<-- ||\\n```\\n/*\\nApproach 1: Brute Force TC: O(n) SC: O(n)\\n    1. We Merge The Two Sorted Array (Basic Merging Method Of Merge Sort, With 2 Pointers.\\n    2. We Find The Median Of The New Array.\\n*/\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        \\n        int nums1Pointer = 0;\\n        int nums2Pointer = 0;\\n        int numsPointer = 0;\\n        int[] nums = new int[nums1.length + nums2.length];\\n        \\n        while(nums1Pointer < nums1.length && nums2Pointer < nums2.length){\\n            if(nums1[nums1Pointer] < nums2[nums2Pointer]){\\n                nums[numsPointer] = nums1[nums1Pointer];\\n                nums1Pointer++;\\n            }else{\\n                nums[numsPointer] = nums2[nums2Pointer];\\n                nums2Pointer++;\\n            }\\n            numsPointer++;\\n        }\\n        \\n        while(nums1Pointer<nums1.length){\\n            nums[numsPointer] = nums1[nums1Pointer];\\n            numsPointer++;\\n            nums1Pointer++;\\n        }\\n        \\n        while(nums2Pointer<nums2.length){\\n            nums[numsPointer] = nums2[nums2Pointer];\\n            numsPointer++;\\n            nums2Pointer++;\\n        }\\n        \\n        if(nums.length%2 == 0){\\n            double median = (double)(nums[nums.length/2] + nums[(nums.length/2) - 1])/2;\\n            return median;\\n        }else{\\n            double median = nums[(nums.length-1)/2];\\n            return median;\\n        }\\n            \\n    }\\n}\\n\\n\\n\\n/*\\nRuntime: 2 ms, faster than 100.00% of Java online submissions for Median of Two Sorted Arrays.\\nMemory Usage: 43 MB, less than 98.54% of Java online submissions for Median of Two Sorted Arrays.\\n\\nApproach 2: Optimized TC: O(logn) SC: O(1) Solution Using Binary Search\\n    1. We Use Binary Search To Create Partitions In Both The Sorted Arrays\\n    2. We Check If The Left And Rights Of The Partition Satisfies The Conditions Which Are Written In Comments Below.\\n*/\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        \\n        //Calling The Function Again With nums1 As The Smaller Size Array \\n        if(nums1.length > nums2.length){\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        // Applying Binary Search To The 2 Arrays\\n        int nums1Length = nums1.length;\\n        int nums2Length = nums2.length;\\n        int start = 0;\\n        int end = nums1Length;\\n        \\n        while(start <= end){\\n            \\n            int partition1 = start + (end-start)/2; // Mid Partition In The Smaller Size Array\\n            int partition2 = (nums1Length + nums2Length + 1)/2 - partition1; // Mid Partition In The Larger Size Array\\n            \\n            // Taking Left And Right Values Of The Partition Of Both The Arrays And Cross Checking Them\\n            int left1 = (partition1 > 0)? nums1[partition1 - 1] : Integer.MIN_VALUE;\\n            int left2 = (partition2 > 0)? nums2[partition2 - 1] : Integer.MIN_VALUE;\\n            \\n            int right1 = (partition1 < nums1Length)? nums1[partition1] : Integer.MAX_VALUE;\\n            int right2 = (partition2 < nums2Length)? nums2[partition2] : Integer.MAX_VALUE;\\n            \\n            /*\\n            If Left Value Of The First Array Is Smaller Than Right Value Of The Second Array \\n                                               And\\n            Left Value Of The Second Array Is Smaller Than Right Value Of The First Array\\n                                              Then\\n            We Check If The Size Of The Sum Of Length Of Both Arrays Is Odd Or Even Because\\n            If Odd, We Return The Max Of Left1 And Left2, And If Even We Return The Average\\n            Of (Max(left1, left2) + Min(right1, right2)) / 2.0 as per the Average Formula.\\n            */\\n            if(left1 <= right2 && left2 <= right1){\\n                if((nums1Length + nums2Length) % 2 == 0){\\n                    return (Math.max(left1, left2) + Math.min(right1, right2)) / 2.0;\\n                }\\n                else{\\n                    return Math.max(left1, left2);\\n                }\\n            }\\n            else if(left1 > right2){    // Base Binary Search Condition\\n                end = partition1 - 1;\\n            }\\n            else{\\n                start = partition1 + 1; // Base Binary Search Condition\\n            }\\n            \\n        }\\n        \\n        // Default Return Input\\n        return 0.0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nApproach 1: Brute Force TC: O(n) SC: O(n)\\n    1. We Merge The Two Sorted Array (Basic Merging Method Of Merge Sort, With 2 Pointers.\\n    2. We Find The Median Of The New Array.\\n*/\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        \\n        int nums1Pointer = 0;\\n        int nums2Pointer = 0;\\n        int numsPointer = 0;\\n        int[] nums = new int[nums1.length + nums2.length];\\n        \\n        while(nums1Pointer < nums1.length && nums2Pointer < nums2.length){\\n            if(nums1[nums1Pointer] < nums2[nums2Pointer]){\\n                nums[numsPointer] = nums1[nums1Pointer];\\n                nums1Pointer++;\\n            }else{\\n                nums[numsPointer] = nums2[nums2Pointer];\\n                nums2Pointer++;\\n            }\\n            numsPointer++;\\n        }\\n        \\n        while(nums1Pointer<nums1.length){\\n            nums[numsPointer] = nums1[nums1Pointer];\\n            numsPointer++;\\n            nums1Pointer++;\\n        }\\n        \\n        while(nums2Pointer<nums2.length){\\n            nums[numsPointer] = nums2[nums2Pointer];\\n            numsPointer++;\\n            nums2Pointer++;\\n        }\\n        \\n        if(nums.length%2 == 0){\\n            double median = (double)(nums[nums.length/2] + nums[(nums.length/2) - 1])/2;\\n            return median;\\n        }else{\\n            double median = nums[(nums.length-1)/2];\\n            return median;\\n        }\\n            \\n    }\\n}\\n\\n\\n\\n/*\\nRuntime: 2 ms, faster than 100.00% of Java online submissions for Median of Two Sorted Arrays.\\nMemory Usage: 43 MB, less than 98.54% of Java online submissions for Median of Two Sorted Arrays.\\n\\nApproach 2: Optimized TC: O(logn) SC: O(1) Solution Using Binary Search\\n    1. We Use Binary Search To Create Partitions In Both The Sorted Arrays\\n    2. We Check If The Left And Rights Of The Partition Satisfies The Conditions Which Are Written In Comments Below.\\n*/\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        \\n        //Calling The Function Again With nums1 As The Smaller Size Array \\n        if(nums1.length > nums2.length){\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        // Applying Binary Search To The 2 Arrays\\n        int nums1Length = nums1.length;\\n        int nums2Length = nums2.length;\\n        int start = 0;\\n        int end = nums1Length;\\n        \\n        while(start <= end){\\n            \\n            int partition1 = start + (end-start)/2; // Mid Partition In The Smaller Size Array\\n            int partition2 = (nums1Length + nums2Length + 1)/2 - partition1; // Mid Partition In The Larger Size Array\\n            \\n            // Taking Left And Right Values Of The Partition Of Both The Arrays And Cross Checking Them\\n            int left1 = (partition1 > 0)? nums1[partition1 - 1] : Integer.MIN_VALUE;\\n            int left2 = (partition2 > 0)? nums2[partition2 - 1] : Integer.MIN_VALUE;\\n            \\n            int right1 = (partition1 < nums1Length)? nums1[partition1] : Integer.MAX_VALUE;\\n            int right2 = (partition2 < nums2Length)? nums2[partition2] : Integer.MAX_VALUE;\\n            \\n            /*\\n            If Left Value Of The First Array Is Smaller Than Right Value Of The Second Array \\n                                               And\\n            Left Value Of The Second Array Is Smaller Than Right Value Of The First Array\\n                                              Then\\n            We Check If The Size Of The Sum Of Length Of Both Arrays Is Odd Or Even Because\\n            If Odd, We Return The Max Of Left1 And Left2, And If Even We Return The Average\\n            Of (Max(left1, left2) + Min(right1, right2)) / 2.0 as per the Average Formula.\\n            */\\n            if(left1 <= right2 && left2 <= right1){\\n                if((nums1Length + nums2Length) % 2 == 0){\\n                    return (Math.max(left1, left2) + Math.min(right1, right2)) / 2.0;\\n                }\\n                else{\\n                    return Math.max(left1, left2);\\n                }\\n            }\\n            else if(left1 > right2){    // Base Binary Search Condition\\n                end = partition1 - 1;\\n            }\\n            else{\\n                start = partition1 + 1; // Base Binary Search Condition\\n            }\\n            \\n        }\\n        \\n        // Default Return Input\\n        return 0.0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277052,
                "title": "easy-java-solution-100-fully-explained-and-understandable",
                "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        \\n        //if the length of nums1 is greater than nums2, then call the algorithm...\\n        if (nums1.length > nums2.length) {\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        // Pointers for binary search...\\n        int beg = 0;\\n        int end = nums1.length;\\n        \\n        // Binary search starts from here\\n        while (beg <= end) {\\n            \\n            // Partitions of both the array\\n            int part1 = (beg + end) / 2;\\n            int part2 = (nums1.length + nums2.length + 1) / 2 - part1;\\n            \\n            // If there are no elements left on the left side after partition\\n            int maxL1 = part1 == 0 ? Integer.MIN_VALUE : nums1[part1 - 1];\\n            // If there are no elements left on the right side after partition\\n            int minR1 = part1 == nums1.length ? Integer.MAX_VALUE : nums1[part1];\\n            // Similarly for nums2\\n            int maxL2 = part2 == 0 ? Integer.MIN_VALUE : nums2[part2 - 1];\\n            int minR2 = part2 == nums2.length ? Integer.MAX_VALUE : nums2[part2];\\n            \\n            //when the following case is satisfied,\\n            //we find the median based on array size is even or odd...\\n            if (maxL1 <= minR2 && maxL2 <= minR1) {\\n                // if array size is even, we add the max value from left side\\n                //with min value from right side...\\n                if ((nums1.length + nums2.length) % 2 == 0) {\\n                    return (Math.max(maxL1, maxL2) + Math.min(minR1, minR2)) / 2.0;\\n                }\\n                // if array size is odd we return the max of the two array\\'s left hand-side value..\\n                else {\\n                    return Math.max(maxL1, maxL2);\\n                }\\n            }\\n            // If we are too far on the right, we need to go to left side...\\n            else if (maxL1 > minR2) {\\n                end = part1 - 1;\\n            }\\n            // If we are too far on the left, we need to go to right side...\\n            else {\\n                beg = part1 + 1;\\n            }\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        \\n        //if the length of nums1 is greater than nums2, then call the algorithm...\\n        if (nums1.length > nums2.length) {\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        // Pointers for binary search...\\n        int beg = 0;\\n        int end = nums1.length;\\n        \\n        // Binary search starts from here\\n        while (beg <= end) {\\n            \\n            // Partitions of both the array\\n            int part1 = (beg + end) / 2;\\n            int part2 = (nums1.length + nums2.length + 1) / 2 - part1;\\n            \\n            // If there are no elements left on the left side after partition\\n            int maxL1 = part1 == 0 ? Integer.MIN_VALUE : nums1[part1 - 1];\\n            // If there are no elements left on the right side after partition\\n            int minR1 = part1 == nums1.length ? Integer.MAX_VALUE : nums1[part1];\\n            // Similarly for nums2\\n            int maxL2 = part2 == 0 ? Integer.MIN_VALUE : nums2[part2 - 1];\\n            int minR2 = part2 == nums2.length ? Integer.MAX_VALUE : nums2[part2];\\n            \\n            //when the following case is satisfied,\\n            //we find the median based on array size is even or odd...\\n            if (maxL1 <= minR2 && maxL2 <= minR1) {\\n                // if array size is even, we add the max value from left side\\n                //with min value from right side...\\n                if ((nums1.length + nums2.length) % 2 == 0) {\\n                    return (Math.max(maxL1, maxL2) + Math.min(minR1, minR2)) / 2.0;\\n                }\\n                // if array size is odd we return the max of the two array\\'s left hand-side value..\\n                else {\\n                    return Math.max(maxL1, maxL2);\\n                }\\n            }\\n            // If we are too far on the right, we need to go to left side...\\n            else if (maxL1 > minR2) {\\n                end = part1 - 1;\\n            }\\n            // If we are too far on the left, we need to go to right side...\\n            else {\\n                beg = part1 + 1;\\n            }\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224378,
                "title": "o-logn-java-solution-with-explanation-in-comments",
                "content": "```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) \\n    {\\n        // according to given constraints all numbers are in this range\\n        int low = (int)-1e6, high = (int)1e6 ;\\n        \\n        int n = nums1.length, m = nums2.length ;\\n        \\n        int totalLen = n + m ;\\n        \\n        int pos = totalLen/2 ;\\n        \\n        // binary search to find the element which will be present at pos = totalLen/2 \\n        // after merging two arrays in sorted order\\n        while (low <= high)\\n        {\\n            int mid = low + ((high-low)>>1) ;   \\n            \\n            // total number of elements in arrays which are less than mid\\n            int ub = upperBound(nums1, mid) + upperBound(nums2, mid) ;\\n             \\n            if (ub <= pos) low = mid + 1 ;\\n            else high = mid - 1 ;\\n        }\\n        \\n  \\n        double ans = low ;\\n        \\n        // if there are even number of elements, we will also have to \\n        // find element at pos = totalLen/2 - 1\\n        if ((totalLen)%2 == 0)\\n        {\\n            pos-- ;\\n            low = (int)-1e6; high = (int)1e6 ;\\n            while (low <= high)\\n            {\\n               int mid = low + ((high-low)>>1) ;   \\n               int ub = upperBound(nums1, mid) + upperBound(nums2, mid) ;\\n               \\n               if (ub <= pos) low = mid + 1 ;\\n               else high = mid - 1 ;\\n            }\\n            \\n            // average of two elements in case of even number of elements\\n            ans = (ans + low*1.0)/2 ;\\n        }\\n        \\n        return ans ;\\n    }\\n    \\n    // a function which returns the index of smallest element which is strictly greater than\\n    // key (i.e. it returns number of elements which are less than or equal to key)\\n    public int upperBound(int[] arr, int key)\\n    {\\n        int low = 0, high = arr.length ;\\n        \\n        while (low < high)\\n        {\\n            int mid = low + ((high-low)>>1) ;\\n            \\n            if (arr[mid] <= key)\\n                low = mid + 1 ;\\n            else high = mid ;\\n        }\\n        \\n        return low ;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) \\n    {\\n        // according to given constraints all numbers are in this range\\n        int low = (int)-1e6, high = (int)1e6 ;\\n        \\n        int n = nums1.length, m = nums2.length ;\\n        \\n        int totalLen = n + m ;\\n        \\n        int pos = totalLen/2 ;\\n        \\n        // binary search to find the element which will be present at pos = totalLen/2 \\n        // after merging two arrays in sorted order\\n        while (low <= high)\\n        {\\n            int mid = low + ((high-low)>>1) ;   \\n            \\n            // total number of elements in arrays which are less than mid\\n            int ub = upperBound(nums1, mid) + upperBound(nums2, mid) ;\\n             \\n            if (ub <= pos) low = mid + 1 ;\\n            else high = mid - 1 ;\\n        }\\n        \\n  \\n        double ans = low ;\\n        \\n        // if there are even number of elements, we will also have to \\n        // find element at pos = totalLen/2 - 1\\n        if ((totalLen)%2 == 0)\\n        {\\n            pos-- ;\\n            low = (int)-1e6; high = (int)1e6 ;\\n            while (low <= high)\\n            {\\n               int mid = low + ((high-low)>>1) ;   \\n               int ub = upperBound(nums1, mid) + upperBound(nums2, mid) ;\\n               \\n               if (ub <= pos) low = mid + 1 ;\\n               else high = mid - 1 ;\\n            }\\n            \\n            // average of two elements in case of even number of elements\\n            ans = (ans + low*1.0)/2 ;\\n        }\\n        \\n        return ans ;\\n    }\\n    \\n    // a function which returns the index of smallest element which is strictly greater than\\n    // key (i.e. it returns number of elements which are less than or equal to key)\\n    public int upperBound(int[] arr, int key)\\n    {\\n        int low = 0, high = arr.length ;\\n        \\n        while (low < high)\\n        {\\n            int mid = low + ((high-low)>>1) ;\\n            \\n            if (arr[mid] <= key)\\n                low = mid + 1 ;\\n            else high = mid ;\\n        }\\n        \\n        return low ;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896583,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {\\n        let total = nums1.count + nums2.count\\n        var index = 0\\n        var index1 = 0\\n        var index2 = 0\\n        var mergedArray: [Int] = []\\n        var res: Double = 0\\n\\n        while total > 0 && index <= total / 2 {\\n            if index1 < nums1.count && index2 < nums2.count {\\n                if nums1[index1] < nums2[index2] {\\n                    mergedArray.append(nums1[index1])\\n                    index1 += 1\\n                } else {\\n                    mergedArray.append(nums2[index2])\\n                    index2 += 1\\n                }\\n            } else if index1 < nums1.count && index2 >= nums2.count {\\n                mergedArray.append(nums1[index1])\\n                index1 += 1\\n            } else {\\n                mergedArray.append(nums2[index2])\\n                index2 += 1\\n            }\\n            index += 1\\n        }\\n\\n        if total > 0 {\\n            if total % 2 == 1 {\\n                res = Double(mergedArray[total / 2])\\n            } else {\\n                res = (Double(mergedArray[total / 2]) + Double(mergedArray[total / 2 - 1])) / 2\\n            }\\n        }\\n\\n        return res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {\\n        let total = nums1.count + nums2.count\\n        var index = 0\\n        var index1 = 0\\n        var index2 = 0\\n        var mergedArray: [Int] = []\\n        var res: Double = 0\\n\\n        while total > 0 && index <= total / 2 {\\n            if index1 < nums1.count && index2 < nums2.count {\\n                if nums1[index1] < nums2[index2] {\\n                    mergedArray.append(nums1[index1])\\n                    index1 += 1\\n                } else {\\n                    mergedArray.append(nums2[index2])\\n                    index2 += 1\\n                }\\n            } else if index1 < nums1.count && index2 >= nums2.count {\\n                mergedArray.append(nums1[index1])\\n                index1 += 1\\n            } else {\\n                mergedArray.append(nums2[index2])\\n                index2 += 1\\n            }\\n            index += 1\\n        }\\n\\n        if total > 0 {\\n            if total % 2 == 1 {\\n                res = Double(mergedArray[total / 2])\\n            } else {\\n                res = (Double(mergedArray[total / 2]) + Double(mergedArray[total / 2 - 1])) / 2\\n            }\\n        }\\n\\n        return res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737297,
                "title": "java-100-faster",
                "content": "```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        \\n        if(nums2.length<nums1.length) return findMedianSortedArrays(nums2,nums1);\\n       int n1=nums1.length , n2=nums2.length;\\n        int lo=0,hi=n1;\\n        while(lo<=hi){\\n            int cut1=(lo+hi)/2;\\n            int cut2= (n1+n2+1)/2-cut1;\\n            \\n            int l1= cut1==0 ? Integer.MIN_VALUE:nums1[cut1-1];\\n            int l2= cut2==0 ? Integer.MIN_VALUE:nums2[cut2-1];\\n            int r1= cut1==n1 ? Integer.MAX_VALUE:nums1[cut1];\\n            int r2= cut2==n2 ? Integer.MAX_VALUE:nums2[cut2];\\n            \\n            if(l1 <= r2 && l2 <= r1){\\n                if((n1+n2)%2==0)\\n                    return (Math.max(l1,l2)+Math.min(r1,r2))/2.0;\\n                else return Math.max(l1,l2);\\n            }else if(l1>r2){\\n                hi=cut1-1;\\n            }\\n            else lo=cut1+1;\\n        }\\n        return 0.0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        \\n        if(nums2.length<nums1.length) return findMedianSortedArrays(nums2,nums1);\\n       int n1=nums1.length , n2=nums2.length;\\n        int lo=0,hi=n1;\\n        while(lo<=hi){\\n            int cut1=(lo+hi)/2;\\n            int cut2= (n1+n2+1)/2-cut1;\\n            \\n            int l1= cut1==0 ? Integer.MIN_VALUE:nums1[cut1-1];\\n            int l2= cut2==0 ? Integer.MIN_VALUE:nums2[cut2-1];\\n            int r1= cut1==n1 ? Integer.MAX_VALUE:nums1[cut1];\\n            int r2= cut2==n2 ? Integer.MAX_VALUE:nums2[cut2];\\n            \\n            if(l1 <= r2 && l2 <= r1){\\n                if((n1+n2)%2==0)\\n                    return (Math.max(l1,l2)+Math.min(r1,r2))/2.0;\\n                else return Math.max(l1,l2);\\n            }else if(l1>r2){\\n                hi=cut1-1;\\n            }\\n            else lo=cut1+1;\\n        }\\n        return 0.0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389478,
                "title": "c-tc-o-log-min-n-m-sc-o-1-binary-search",
                "content": "# Feel free to post your doubts in comment section\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& A, vector<int>& B) {\\n        \\n        int n=A.size();\\n        int m=B.size();\\n        \\n        if(n>m) return findMedianSortedArrays(B,A);\\n        \\n        int totalLeft = (n+m+1)/2;\\n        \\n        int s=0, e=n;\\n        \\n        while(s<=e){\\n            int mid = (s+e)/2;\\n            int countA = mid;\\n            int countB = totalLeft-countA;\\n            \\n            double leftA = (countA==0) ? INT_MIN : A[countA-1] ;\\n            double rightA = (countA==n) ? INT_MAX : A[countA] ;\\n            \\n            double leftB = (countB==0) ? INT_MIN : B[countB-1] ;\\n            double rightB = (countB==m) ? INT_MAX : B[countB] ;\\n            \\n            if(leftB > rightA) \\n                s=mid+1;\\n            else if(leftA > rightB)\\n                e=mid-1;\\n            else{\\n                int total = (n+m);\\n                if( total % 2 != 0 )\\n                    return double(max(leftA,leftB));\\n                else \\n                    return (double(max(leftA,leftB)) + double(min(rightA,rightB)))/2;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& A, vector<int>& B) {\\n        \\n        int n=A.size();\\n        int m=B.size();\\n        \\n        if(n>m) return findMedianSortedArrays(B,A);\\n        \\n        int totalLeft = (n+m+1)/2;\\n        \\n        int s=0, e=n;\\n        \\n        while(s<=e){\\n            int mid = (s+e)/2;\\n            int countA = mid;\\n            int countB = totalLeft-countA;\\n            \\n            double leftA = (countA==0) ? INT_MIN : A[countA-1] ;\\n            double rightA = (countA==n) ? INT_MAX : A[countA] ;\\n            \\n            double leftB = (countB==0) ? INT_MIN : B[countB-1] ;\\n            double rightB = (countB==m) ? INT_MAX : B[countB] ;\\n            \\n            if(leftB > rightA) \\n                s=mid+1;\\n            else if(leftA > rightB)\\n                e=mid-1;\\n            else{\\n                int total = (n+m);\\n                if( total % 2 != 0 )\\n                    return double(max(leftA,leftB));\\n                else \\n                    return (double(max(leftA,leftB)) + double(min(rightA,rightB)))/2;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174293,
                "title": "faster-than-99-68-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.size()>nums2.size()){\\n            return findMedianSortedArrays(nums2,nums1);\\n        }\\n        int x = nums1.size();\\n        int y = nums2.size();\\n        \\n        int high = x;\\n        int low = 0;\\n        while(low<=high){\\n            int divideX = low + (high - low)/2;\\n            int divideY = (x + y + 1)/2 - divideX;\\n            \\n            double maxLeftX = (divideX == 0 ? INT_MIN : nums1[divideX-1]);\\n            double minRightX = (divideX == x ? INT_MAX : nums1[divideX]);\\n            \\n            double maxLeftY = (divideY == 0 ? INT_MIN : nums2[divideY-1]);\\n            double minRightY = (divideY == y ? INT_MAX : nums2[divideY]);\\n            \\n            if(maxLeftX <= minRightY && maxLeftY <= minRightX){\\n                if((x+y)%2==0){\\n                    return (max(maxLeftX,maxLeftY) + min(minRightX,minRightY))/2.0;\\n                }else{\\n                    return max(maxLeftX,maxLeftY);\\n                }\\n            }else if(maxLeftX>minRightY){\\n                high = divideX-1;\\n            }else{\\n                low = divideX +1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.size()>nums2.size()){\\n            return findMedianSortedArrays(nums2,nums1);\\n        }\\n        int x = nums1.size();\\n        int y = nums2.size();\\n        \\n        int high = x;\\n        int low = 0;\\n        while(low<=high){\\n            int divideX = low + (high - low)/2;\\n            int divideY = (x + y + 1)/2 - divideX;\\n            \\n            double maxLeftX = (divideX == 0 ? INT_MIN : nums1[divideX-1]);\\n            double minRightX = (divideX == x ? INT_MAX : nums1[divideX]);\\n            \\n            double maxLeftY = (divideY == 0 ? INT_MIN : nums2[divideY-1]);\\n            double minRightY = (divideY == y ? INT_MAX : nums2[divideY]);\\n            \\n            if(maxLeftX <= minRightY && maxLeftY <= minRightX){\\n                if((x+y)%2==0){\\n                    return (max(maxLeftX,maxLeftY) + min(minRightX,minRightY))/2.0;\\n                }else{\\n                    return max(maxLeftX,maxLeftY);\\n                }\\n            }else if(maxLeftX>minRightY){\\n                high = divideX-1;\\n            }else{\\n                low = divideX +1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021101,
                "title": "simple-and-clean",
                "content": "```\\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int m, n;\\n    \\n    for (int i = 0, j = 0, k = 0; i < (nums1Size + nums2Size) / 2 + 1; i++) {\\n        if (j >= nums1Size)\\n            m = nums2[k++];\\n        else if (k >= nums2Size) \\n            m = nums1[j++];\\n        else\\n            m = nums1[j] < nums2[k] ? nums1[j++] : nums2[k++];\\n        \\n        if (i == (nums1Size + nums2Size - 1) / 2) {\\n           n = m; \\n        }\\n    }\\n    \\n    return (n + m) / 2.0f;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int m, n;\\n    \\n    for (int i = 0, j = 0, k = 0; i < (nums1Size + nums2Size) / 2 + 1; i++) {\\n        if (j >= nums1Size)\\n            m = nums2[k++];\\n        else if (k >= nums2Size) \\n            m = nums1[j++];\\n        else\\n            m = nums1[j] < nums2[k] ? nums1[j++] : nums2[k++];\\n        \\n        if (i == (nums1Size + nums2Size - 1) / 2) {\\n           n = m; \\n        }\\n    }\\n    \\n    return (n + m) / 2.0f;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 697669,
                "title": "python-simple-binary-search-o-log-min-m-n",
                "content": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        \\n        nums1_len = len(nums1)\\n        nums2_len = len(nums2)\\n        \\n        if (nums1_len > nums2_len):\\n            return self.findMedianSortedArrays(nums2,nums1)\\n        \\n        low = 0\\n        high = nums1_len\\n        \\n        while(low<=high):\\n            partition_nums1 = (low+high)//2\\n            partition_nums2 = (nums1_len+nums2_len+1)//2 - partition_nums1\\n            \\n            max_left_x = nums1[partition_nums1-1] if partition_nums1 else -float(\\'inf\\')\\n            min_right_x = nums1[partition_nums1] if partition_nums1 < nums1_len else float(\\'inf\\')\\n            \\n            max_left_y = nums2[partition_nums2-1] if partition_nums2 else -float(\\'inf\\')\\n            min_right_y = nums2[partition_nums2] if partition_nums2 < nums2_len else float(\\'inf\\')\\n            \\n            if (max_left_x<=min_right_y and max_left_y <= min_right_x):\\n                \\n                if (nums1_len+nums2_len)%2 == 0:\\n                    return (max(max_left_x,max_left_y)+min(min_right_x,min_right_y))/2\\n                else:\\n                    return max(max_left_x,max_left_y)\\n            elif(max_left_x>min_right_y):\\n                high = partition_nums1-1\\n            else:\\n                low = partition_nums1+1\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        \\n        nums1_len = len(nums1)\\n        nums2_len = len(nums2)\\n        \\n        if (nums1_len > nums2_len):\\n            return self.findMedianSortedArrays(nums2,nums1)\\n        \\n        low = 0\\n        high = nums1_len\\n        \\n        while(low<=high):\\n            partition_nums1 = (low+high)//2\\n            partition_nums2 = (nums1_len+nums2_len+1)//2 - partition_nums1\\n            \\n            max_left_x = nums1[partition_nums1-1] if partition_nums1 else -float(\\'inf\\')\\n            min_right_x = nums1[partition_nums1] if partition_nums1 < nums1_len else float(\\'inf\\')\\n            \\n            max_left_y = nums2[partition_nums2-1] if partition_nums2 else -float(\\'inf\\')\\n            min_right_y = nums2[partition_nums2] if partition_nums2 < nums2_len else float(\\'inf\\')\\n            \\n            if (max_left_x<=min_right_y and max_left_y <= min_right_x):\\n                \\n                if (nums1_len+nums2_len)%2 == 0:\\n                    return (max(max_left_x,max_left_y)+min(min_right_x,min_right_y))/2\\n                else:\\n                    return max(max_left_x,max_left_y)\\n            elif(max_left_x>min_right_y):\\n                high = partition_nums1-1\\n            else:\\n                low = partition_nums1+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723,
                "title": "simple-java-solution-o-log-m-n-binary-search-for-kth-element",
                "content": "Simple to get the median basically what we want is to find the kth element in 2 sorted arrays.\\n\\nThrow the arrays and kth element (mid: (length of array1 + length of array2 + 1) / 2) to getkth API and\\n\\n    public class Solution {\\n        public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n            //Get the middle element\\n            int mid = (nums2.length+nums1.length+1)/2;\\n            //Find that middle element\\n            double res = getkth(nums1, nums2, mid);\\n            //If the combined length is even then find mid+1 element as well\\n            if((nums2.length+nums1.length) % 2 == 0) {\\n                res += getkth(nums1, nums2, mid+1);\\n                //Find the average of two elements\\n                res = res/2;\\n            }\\n            return res;\\n        }\\n        public int getkth(int[] A, int[] B, int k) {\\n            //Make sure array A is the smaller array\\n            if(B.length < A.length ) return getkth(B, A, k);\\n            //If smaller array is empty, simply return the value from second array\\n            if(A.length == 0) return B[k-1];\\n            //If k is 1, then it must be the smaller of first element of the array\\n            if(k == 1) return Math.min(A[0], B[0]);\\n            \\n            //Get the index for array A to compare\\n            int i = Math.min((A.length), k/2);\\n            //Index for array B must be such that i + j = k\\n            int j = k - i;\\n            \\n            //Remove the smaller elemets from the array A if, ith index of A is smaller than jth index of B\\n            if(A[i- 1] <  B[j-1]) {\\n                int[] newA = new int[A.length - i];\\n                //Make a new array and copy the rest of the array elements\\n                System.arraycopy(A, i, newA, 0, (A.length - i));\\n                return getkth(newA, B, k - i);\\n            }\\n            else {\\n                int[] newB = new int[B.length - j];\\n                System.arraycopy(B, j, newB, 0, (B.length - j));\\n                return getkth(A, newB, k - j);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n            //Get the middle element\\n            int mid = (nums2.length+nums1.length+1)/2;\\n            //Find that middle element\\n            double res = getkth(nums1, nums2, mid);\\n            //If the combined length is even then find mid+1 element as well\\n            if((nums2.length+nums1.length) % 2 == 0) {\\n                res += getkth(nums1, nums2, mid+1);\\n                //Find the average of two elements\\n                res = res/2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2746,
                "title": "my-simple-o-log-m-n-java-solution-using-binary-search",
                "content": "    public double findMedianSortedArrays(int[] A, int[] B) {\\n        int m = A.length, n = B.length;\\n        int l = (m + n + 1) / 2;\\n        int r = (m + n + 2) / 2;\\n        return (getkth(A, 0, B, 0, l) + getkth(A, 0, B, 0, r)) / 2.0;\\n    }\\n\\n    public double getkth(int[] A, int aStart, int[] B, int bStart, int k) {\\n       if (aStart > A.length - 1) return B[bStart + k - 1];            \\n       if (bStart > B.length - 1) return A[aStart + k - 1];                \\n       if (k == 1) return Math.min(A[aStart], B[bStart]);\\n\\n       int aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE;\\n       if (aStart + k/2 - 1 < A.length) aMid = A[aStart + k/2 - 1]; \\n       if (bStart + k/2 - 1 < B.length) bMid = B[bStart + k/2 - 1];        \\n\\n       if (aMid < bMid) \\n        return getkth(A, aStart + k/2, B, bStart,       k - k/2);// Check: aRight + bLeft \\n      else \\n        return getkth(A, aStart,       B, bStart + k/2, k - k/2);// Check: bRight + aLeft\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "    public double findMedianSortedArrays(int[] A, int[] B) {\\n        int m = A.length, n = B.length;\\n        int l = (m + n + 1) / 2;\\n        int r = (m + n + 2) / 2;\\n        return (getkth(A, 0, B, 0, l) + getkth(A, 0, B, 0, r)) / 2.0;\\n    }\\n\\n    public double getkth(int[] A, int aStart, int[] B, int bStart, int k) {\\n       if (aStart > A.length - 1) return B[bStart + k - 1];            \\n       if (bStart > B.length - 1) return A[aStart + k - 1];                \\n       if (k == 1) return Math.min(A[aStart], B[bStart]);\\n\\n       int aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE;\\n       if (aStart + k/2 - 1 < A.length) aMid = A[aStart + k/2 - 1]; \\n       if (bStart + k/2 - 1 < B.length) bMid = B[bStart + k/2 - 1];        \\n\\n       if (aMid < bMid) \\n        return getkth(A, aStart + k/2, B, bStart,       k - k/2);// Check: aRight + bLeft \\n      else \\n        return getkth(A, aStart,       B, bStart + k/2, k - k/2);// Check: bRight + aLeft\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2753,
                "title": "sharing-my-c-solution-using-binary-search",
                "content": "    class Solution {\\n    private:\\n        int findkth(int* num1, int n1, int* num2, int n2, int k)\\n        {\\n            if(n1>n2)\\n                return findkth(num2, n2, num1, n1, k); // ensure the first array is shorter than the second one\\n            if(n1==0)\\n                return num2[k-1];\\n            if(k==1)\\n                return min(num1[0], num2[0]);\\n        \\n            int k1 = min(k/2, n1);\\n            int k2 = k - k1;\\n            if(num1[k1-1]==num2[k2-1])\\n                return num1[k1-1];\\n            else if(num1[k1-1]<num2[k2-1])\\n                return findkth(num1+k1, n1-k1, num2, n2, k-k1);\\n            else\\n                return findkth(num1, n1, num2+k2, n2-k2, k-k2);\\n        }\\n        \\n    public:\\n        double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            int n1 = nums1.size();\\n            int* num1=NULL;\\n            if(n1>0)\\n                num1 = (int*) malloc(n1*sizeof(int));\\n            for(int i=0; i<n1; i++)\\n                num1[i] = nums1[i];\\n                \\n            int n2 = nums2.size();\\n            int* num2=NULL;\\n            if(n2>0)\\n                num2 = (int*) malloc(n2*sizeof(int));\\n            for(int j=0; j<n2; j++)\\n                num2[j] = nums2[j];        \\n                \\n            double result;\\n            int n = n1+n2;\\n    \\n            if(n%2==1)\\n                result = 1.0*findkth(num1, n1, num2, n2, (n+1)/2);\\n            else\\n            {\\n                result = 0.5*findkth(num1, n1, num2, n2, n/2);\\n                result += 0.5*findkth(num1, n1, num2, n2, n/2+1);\\n            }\\n            \\n            if(n1>0)\\n                free(num1);\\n            if(n2>0)\\n                free(num2);\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    private:\\n        int findkth(int* num1, int n1, int* num2, int n2, int k)\\n        {\\n            if(n1>n2)\\n                return findkth(num2, n2, num1, n1, k); // ensure the first array is shorter than the second one\\n            if(n1==0)\\n                return num2[k-1];\\n            if(k==1)\\n                return min(num1[0], num2[0]);\\n        \\n            int k1 = min(k/2, n1);\\n            int k2 = k - k1;\\n            if(num1[k1-1]==num2[k2-1])\\n                return num1[k1-1];\\n            else if(num1[k1-1]<num2[k2-1])\\n                return findkth(num1+k1, n1-k1, num2, n2, k-k1);\\n            else\\n                return findkth(num1, n1, num2+k2, n2-k2, k-k2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4070434,
                "title": "c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& A, vector<int>& B) \\n    {    \\n        if (A.size() > B.size()) \\n            return findMedianSortedArrays(B, A);\\n        \\n        int nA = A.size(), nB = B.size();\\n        int l = 0, r = nA;\\n        \\n        while (l <= r) {\\n            int cutA = (l + r) / 2;\\n            int cutB = (nA + nB + 1) / 2 - cutA;\\n            \\n            int maxLeftA = (cutA == 0) ? INT_MIN : A[cutA - 1];\\n            int minRightA = (cutA == nA) ? INT_MAX : A[cutA];\\n            int maxLeftB = (cutB == 0) ? INT_MIN : B[cutB - 1];\\n            int minRightB = (cutB == nB) ? INT_MAX : B[cutB];\\n            \\n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\\n                if ((nA + nB) % 2 == 0) return \\n                (max(maxLeftA, maxLeftB)+min(minRightA,minRightB))/2.0;\\n                else return max(maxLeftA, maxLeftB); \\n            } \\n            else if (maxLeftA > minRightB) \\n                r = cutA - 1;\\n            else \\n                l = cutA + 1;\\n        }\\n        return 0.0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& A, vector<int>& B) \\n    {    \\n        if (A.size() > B.size()) \\n            return findMedianSortedArrays(B, A);\\n        \\n        int nA = A.size(), nB = B.size();\\n        int l = 0, r = nA;\\n        \\n        while (l <= r) {\\n            int cutA = (l + r) / 2;\\n            int cutB = (nA + nB + 1) / 2 - cutA;\\n            \\n            int maxLeftA = (cutA == 0) ? INT_MIN : A[cutA - 1];\\n            int minRightA = (cutA == nA) ? INT_MAX : A[cutA];\\n            int maxLeftB = (cutB == 0) ? INT_MIN : B[cutB - 1];\\n            int minRightB = (cutB == nB) ? INT_MAX : B[cutB];\\n            \\n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\\n                if ((nA + nB) % 2 == 0) return \\n                (max(maxLeftA, maxLeftB)+min(minRightA,minRightB))/2.0;\\n                else return max(maxLeftA, maxLeftB); \\n            } \\n            else if (maxLeftA > minRightB) \\n                r = cutA - 1;\\n            else \\n                l = cutA + 1;\\n        }\\n        return 0.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998279,
                "title": "cpp-c-6-line-code-easy-solution-by-using-inbuilt-function",
                "content": "\\nFor Newbies\\n# Complexity\\n- Time complexity:\\n O((m+n) log(m+n)) \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        double flag=0;\\n       \\n        nums1.insert(nums1.end(),nums2.begin(),nums2.end());\\n               sort(nums1.begin(),nums1.end());\\n              \\n              \\n              if(nums1.size() % 2==0) return flag=(nums1[nums1.size()/2.0]+nums1[(nums1.size()/2.0)-1])/2.0;\\n               else return flag=nums1[nums1.size()/2.0];\\n    \\n                   \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        double flag=0;\\n       \\n        nums1.insert(nums1.end(),nums2.begin(),nums2.end());\\n               sort(nums1.begin(),nums1.end());\\n              \\n              \\n              if(nums1.size() % 2==0) return flag=(nums1[nums1.size()/2.0]+nums1[(nums1.size()/2.0)-1])/2.0;\\n               else return flag=nums1[nums1.size()/2.0];\\n    \\n                   \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944052,
                "title": "putta-easy-solution-c-beats-96",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        if(n > m) return findMedianSortedArrays(nums2,nums1);\\n\\n        int half = (n+m+1)/2;\\n        int left = 0;\\n        int right = n;\\n\\n        while(left<= right){\\n            int mid = left + (right-left)/2;\\n            int lefA = mid;\\n            int lefB = half-mid;\\n            int leftA = (lefA > 0)?nums1[lefA-1]:INT_MIN;\\n            int leftB = (lefB > 0)?nums2[lefB-1]:INT_MIN;\\n            int rightA = (lefA <n)?nums1[lefA]:INT_MAX;\\n            int rightB = (lefB < m)?nums2[lefB]:INT_MAX;\\n\\n            if(leftA <= rightB && leftB <= rightA) {\\n                if((n+m)%2 == 0) {\\n                    double ans = max(leftA,leftB)+min(rightA,rightB);\\n                    \\n                    return ans/double(2); }\\n                return max(leftA,leftB);\\n            }\\n            else if(leftA > rightB) right = mid-1;\\n            else left = mid +1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        if(n > m) return findMedianSortedArrays(nums2,nums1);\\n\\n        int half = (n+m+1)/2;\\n        int left = 0;\\n        int right = n;\\n\\n        while(left<= right){\\n            int mid = left + (right-left)/2;\\n            int lefA = mid;\\n            int lefB = half-mid;\\n            int leftA = (lefA > 0)?nums1[lefA-1]:INT_MIN;\\n            int leftB = (lefB > 0)?nums2[lefB-1]:INT_MIN;\\n            int rightA = (lefA <n)?nums1[lefA]:INT_MAX;\\n            int rightB = (lefB < m)?nums2[lefB]:INT_MAX;\\n\\n            if(leftA <= rightB && leftB <= rightA) {\\n                if((n+m)%2 == 0) {\\n                    double ans = max(leftA,leftB)+min(rightA,rightB);\\n                    \\n                    return ans/double(2); }\\n                return max(leftA,leftB);\\n            }\\n            else if(leftA > rightB) right = mid-1;\\n            else left = mid +1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748279,
                "title": "c-linear-search-binary-search",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n<b>Linear Search</b>\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& a, vector<int>& b) {\\n        int n=a.size(), m=b.size();\\n        int len=n+m;\\n        \\n        int i=0, j=0, k=0;\\n        bool found_first=false, found_second=false;\\n        int first, second;\\n        while(i<n || j<m){\\n            k++; // length of merged array\\n            int val1 = (i<n ? a[i]:INT_MAX);\\n            int val2 = (j<m ? b[j]:INT_MAX);\\n            \\n            int cur;\\n            if(val1<=val2){\\n                cur=val1;\\n                i++;\\n            }else{\\n                cur=val2;\\n                j++;\\n            }\\n            \\n            if(len%2 && k==(len+1)/2) return cur;\\n            if(len%2==0){\\n                if(k==len/2) first=cur, found_first=true;\\n                if(k==len/2 +1) second=cur, found_second=true;\\n                \\n                if(found_first && found_second) return (first + second)/(double)2;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n<b>Binary Search</b>\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int> &a, vector<int> &b) {\\n        if(b.size() < a.size()) return findMedianSortedArrays(b,a); // to reduce range for Binary Seacrh \\n        int n=a.size(), m=b.size();\\n        \\n        int low=0, high=n;\\n        \\n        while(low<=high){\\n            int cut1=(high+low)/2; // no. of elements taken on left from a\\n            int cut2=(n+m+1)/2 - cut1; // no. of elements taken on left from b\\n            \\n            int left1=(cut1==0 ? INT_MIN:a[cut1-1]);\\n            int left2=(cut2==0 ? INT_MIN:b[cut2-1]);\\n            int right1=(cut1==n ? INT_MAX:a[cut1]);\\n            int right2=(cut2==m ? INT_MAX:b[cut2]);\\n            \\n            // left1<=right2 && left2<=right1\\n            if(max(left1, left2) <= min(right1, right2)){\\n                if((n+m)%2==0) return (max(left1,left2)+min(right1,right2))/2.0;\\n                return max(left1,left2);\\n            }else if(left1>right2){\\n                high=cut1-1;\\n            }else{\\n                low=cut1+1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& a, vector<int>& b) {\\n        int n=a.size(), m=b.size();\\n        int len=n+m;\\n        \\n        int i=0, j=0, k=0;\\n        bool found_first=false, found_second=false;\\n        int first, second;\\n        while(i<n || j<m){\\n            k++; // length of merged array\\n            int val1 = (i<n ? a[i]:INT_MAX);\\n            int val2 = (j<m ? b[j]:INT_MAX);\\n            \\n            int cur;\\n            if(val1<=val2){\\n                cur=val1;\\n                i++;\\n            }else{\\n                cur=val2;\\n                j++;\\n            }\\n            \\n            if(len%2 && k==(len+1)/2) return cur;\\n            if(len%2==0){\\n                if(k==len/2) first=cur, found_first=true;\\n                if(k==len/2 +1) second=cur, found_second=true;\\n                \\n                if(found_first && found_second) return (first + second)/(double)2;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int> &a, vector<int> &b) {\\n        if(b.size() < a.size()) return findMedianSortedArrays(b,a); // to reduce range for Binary Seacrh \\n        int n=a.size(), m=b.size();\\n        \\n        int low=0, high=n;\\n        \\n        while(low<=high){\\n            int cut1=(high+low)/2; // no. of elements taken on left from a\\n            int cut2=(n+m+1)/2 - cut1; // no. of elements taken on left from b\\n            \\n            int left1=(cut1==0 ? INT_MIN:a[cut1-1]);\\n            int left2=(cut2==0 ? INT_MIN:b[cut2-1]);\\n            int right1=(cut1==n ? INT_MAX:a[cut1]);\\n            int right2=(cut2==m ? INT_MAX:b[cut2]);\\n            \\n            // left1<=right2 && left2<=right1\\n            if(max(left1, left2) <= min(right1, right2)){\\n                if((n+m)%2==0) return (max(left1,left2)+min(right1,right2))/2.0;\\n                return max(left1,left2);\\n            }else if(left1>right2){\\n                high=cut1-1;\\n            }else{\\n                low=cut1+1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489128,
                "title": "easy-java-solution-beats-100-2ms-easy-to-understand-double-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Given two sorted arrays, we need to find the median of their merged array.\\n- We can find the median of a sorted array in O(1) time. Therefore, the problem reduces to merging the two arrays and finding the median of the merged array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We can use a two-pointer approach to merge the two arrays into a new array in sorted order.\\n- We initialize two pointers, one for each array, and compare the elements at their respective pointers.\\n- The smaller element is added to the new array and its corresponding pointer is incremented.\\n- This process continues until we have exhausted one of the arrays.\\n- If there are still elements remaining in the other array, we add them to the new array.\\n- Finally, we compute the median of the new array based on its length.\\n\\n# Complexity\\n- Time complexity:O(m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int i=0,i1=0,i2=0;\\n        int l=nums1.length+nums2.length;\\n        int[] a =new int[(l/2)+1];\\n        while(i<a.length){\\n               if(i1<nums1.length&&i2<nums2.length){\\n                   a[i++] = nums1[i1]<nums2[i2] ? nums1[i1++]:nums2[i2++];\\n               }\\n               else if(i1<nums1.length){\\n                   a[i++]=nums1[i1++];\\n               }\\n               else{\\n                   a[i++]=nums2[i2++];\\n               }\\n        } \\n        if(l%2==1){\\n            return a[a.length-1];\\n        }\\n        else{double t=(a[a.length-2]+a[a.length-1]);\\n        return t/2.00;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int i=0,i1=0,i2=0;\\n        int l=nums1.length+nums2.length;\\n        int[] a =new int[(l/2)+1];\\n        while(i<a.length){\\n               if(i1<nums1.length&&i2<nums2.length){\\n                   a[i++] = nums1[i1]<nums2[i2] ? nums1[i1++]:nums2[i2++];\\n               }\\n               else if(i1<nums1.length){\\n                   a[i++]=nums1[i1++];\\n               }\\n               else{\\n                   a[i++]=nums2[i2++];\\n               }\\n        } \\n        if(l%2==1){\\n            return a[a.length-1];\\n        }\\n        else{double t=(a[a.length-2]+a[a.length-1]);\\n        return t/2.00;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486424,
                "title": "o-log-min-m-n-very-concise-easy-vivid-explanation-divide-and-conquer",
                "content": "# Intuition\\n\\nDivide-and-conquer Method\\n- big question: Find Kth smallest number in two sorted array A,B.\\n- divide big question into smaller question: find (K-ak)th smallest number in two sorted array A[aK~aLength],B.\\n\\nUse recursion to deal with each smaller question.\\n\\n![image.png](https://assets.leetcode.com/users/images/645a3c2a-c864-4d78-a958-1ec74673000e_1684006587.5993981.png)\\n\\n\\n# Approach\\n\\nparameters in `FindKthSmallList()`:\\n- `A` `B`: lists A,b\\n- `aL` `bL`: left border of list A/B\\n- `a` `b`: length of A/B\\n\\n# Complexity\\n- Time complexity: $O(log(min(m,n)))$\\n\\n# TypeScript Code\\n\\n`FindKthSmallList()`:\\n```ts\\nconst FindKthSmallList = (A: number[], aL: number, a: number, B: number[], bL: number, b: number, K: number): number => {\\n  if (a > b) return FindKthSmallList(B, bL, b, A, aL, a, K);\\n\\n  if (a === 0) return B[bL + K - 1];\\n  if (K === 1) return Math.min(A[aL], B[bL]);\\n\\n  const aK = Math.min(a, Math.ceil(K / 2));   // A+K/2 > A length\\n  const bK = K - aK;   // aK+bK=K (K/2+K/2=K or a+bK=K)\\n\\n  if (A[aL + aK - 1] < B[bL + bK - 1]) { // array index include 0 so index=length-1\\n    return FindKthSmallList(A, aL + aK, a - aK, B, bL, b, K - aK); \\n  } else {\\n    return FindKthSmallList(A, aL, a, B, bL + bK, b - bK, K - bK);\\n  }\\n};\\n```\\n`Main()`:\\n\\n```ts\\nfunction findMedianSortedArrays(nums1: number[], nums2: number[]): number {\\n  const mn = nums1.length + nums2.length;\\n  const res = FindKthSmallList(nums1, 0, nums1.length, nums2, 0, nums2.length, Math.ceil(mn / 2));\\n  if (mn % 2) return res;\\n  return (res + FindKthSmallList(nums1, 0, nums1.length, nums2, 0, nums2.length, (mn + 2) / 2)) / 2;\\n}\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/93f71222-1ef3-4eff-957d-2b71d4fa2105_1683413158.3855317.png)\\n\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nconst FindKthSmallList = (A: number[], aL: number, a: number, B: number[], bL: number, b: number, K: number): number => {\\n  if (a > b) return FindKthSmallList(B, bL, b, A, aL, a, K);\\n\\n  if (a === 0) return B[bL + K - 1];\\n  if (K === 1) return Math.min(A[aL], B[bL]);\\n\\n  const aK = Math.min(a, Math.ceil(K / 2));   // A+K/2 > A length\\n  const bK = K - aK;   // aK+bK=K (K/2+K/2=K or a+bK=K)\\n\\n  if (A[aL + aK - 1] < B[bL + bK - 1]) { // array index include 0 so index=length-1\\n    return FindKthSmallList(A, aL + aK, a - aK, B, bL, b, K - aK); \\n  } else {\\n    return FindKthSmallList(A, aL, a, B, bL + bK, b - bK, K - bK);\\n  }\\n};\\n```\n```ts\\nfunction findMedianSortedArrays(nums1: number[], nums2: number[]): number {\\n  const mn = nums1.length + nums2.length;\\n  const res = FindKthSmallList(nums1, 0, nums1.length, nums2, 0, nums2.length, Math.ceil(mn / 2));\\n  if (mn % 2) return res;\\n  return (res + FindKthSmallList(nums1, 0, nums1.length, nums2, 0, nums2.length, (mn + 2) / 2)) / 2;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485615,
                "title": "fast-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    private:\\n        int dop_num1(vector<int>& nums1) {\\n            if (nums1.size() == 0) {\\n                return 0;\\n            } else if (nums1.size()/2 > nums1.size() -1 && nums1.size() > 1) {\\n                return nums1[nums1.size()/2 -1];\\n            } else {\\n                return nums1[nums1.size()/2];\\n            }\\n        }\\n        int dop_num2(vector<int>& nums2) {\\n            if (nums2.size() == 0) {\\n                return 0;\\n            } else if (nums2.size() > 1){\\n                return nums2[nums2.size()/2 - 1];\\n            } else {\\n                return nums2[nums2.size()/2];\\n            }\\n        }\\n\\n    public:\\n        double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            vector<int> all;\\n            all = nums1;\\n            for (int i = 0; i < nums2.size(); i++) all.push_back(nums2[i]);\\n            std::sort(all.begin(), all.end());\\n            if (all.size() % 2 == 0) {\\n                return (double)(dop_num1(all)+dop_num2(all))/2;\\n            } else {\\n                return (double)dop_num1(all);\\n            } \\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\n    private:\\n        int dop_num1(vector<int>& nums1) {\\n            if (nums1.size() == 0) {\\n                return 0;\\n            } else if (nums1.size()/2 > nums1.size() -1 && nums1.size() > 1) {\\n                return nums1[nums1.size()/2 -1];\\n            } else {\\n                return nums1[nums1.size()/2];\\n            }\\n        }\\n        int dop_num2(vector<int>& nums2) {\\n            if (nums2.size() == 0) {\\n                return 0;\\n            } else if (nums2.size() > 1){\\n                return nums2[nums2.size()/2 - 1];\\n            } else {\\n                return nums2[nums2.size()/2];\\n            }\\n        }\\n\\n    public:\\n        double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            vector<int> all;\\n            all = nums1;\\n            for (int i = 0; i < nums2.size(); i++) all.push_back(nums2[i]);\\n            std::sort(all.begin(), all.end());\\n            if (all.size() % 2 == 0) {\\n                return (double)(dop_num1(all)+dop_num2(all))/2;\\n            } else {\\n                return (double)dop_num1(all);\\n            } \\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468638,
                "title": "median-of-two-sorted-arrays-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        double med=0;\\n        nums1.insert(nums1.end(), nums2.begin(), nums2.end());\\n        sort(nums1.begin(), nums1.end());\\n        if(nums1.size()%2==0)\\n        {\\n            med = (double)(nums1[nums1.size()/2-1]+nums1[nums1.size()/2])/2;\\n        }\\n        else\\n        {\\n            med = nums1[nums1.size()/2];\\n        }\\n        return med;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/04e51100-7856-432f-a1ac-1bdd5905eccc_1682832077.2801096.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        double med=0;\\n        nums1.insert(nums1.end(), nums2.begin(), nums2.end());\\n        sort(nums1.begin(), nums1.end());\\n        if(nums1.size()%2==0)\\n        {\\n            med = (double)(nums1[nums1.size()/2-1]+nums1[nums1.size()/2])/2;\\n        }\\n        else\\n        {\\n            med = nums1[nums1.size()/2];\\n        }\\n        return med;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424711,
                "title": "100-faster",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDivide and conquer \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log(Max(m , n)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    O(log(Max(m , n)))\\n\\n\\n# Code\\n```\\n class Solution {\\n        public int find(int[] nums1, int l1,\\n                        int r1,int[] nums2,\\n                        int l2,int r2,\\n                        int targetIndex){\\n            if(r1<l1){\\n                return nums2[ l2 + targetIndex];\\n            }\\n            if(r2<l2){\\n                return nums1[ l1 + targetIndex];\\n            }\\n            int mid1= (r1 + l1)/2;\\n            int mid2= (r2 + l2)/2;\\n            if(nums1[mid1] > nums2[mid2]){\\n                if(targetIndex >= ((mid2 - l2 )+ (mid1 - l1) + 1)){\\n                    return find(nums1, l1, r1, nums2, mid2+1, r2, targetIndex - (mid2 - l2 +1) );\\n                }\\n                else{\\n                    return find(nums1, l1, mid1- 1, nums2, l2, r2, targetIndex);\\n                }\\n            }\\n            else{\\n                if(targetIndex >= (mid2 - l2 + mid1 - l1 + 1)){\\n                    return find(nums1, mid1 + 1, r1, nums2, l2, r2, targetIndex - (mid1 - l1 +1)  );\\n                }\\n                else{\\n                    return find(nums1, l1, r1, nums2, l2, mid2 - 1, targetIndex);\\n                }  \\n            }\\n        }\\n        public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n            int l = nums1.length + nums2.length;\\n            if(l%2 == 0){\\n                int mid1 = find(nums1,0,nums1.length-1,nums2,0,nums2.length-1,l/2);\\n                int mid2 =find(nums1,0,nums1.length-1,nums2,0,nums2.length-1,l/2 - 1);\\n                return ((double)mid1 +(double)mid2) / 2.0; \\n            }\\n            double ans =(double) find(nums1,0,nums1.length-1,nums2,0,nums2.length-1,l/2);\\n            return  ans;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```\\n class Solution {\\n        public int find(int[] nums1, int l1,\\n                        int r1,int[] nums2,\\n                        int l2,int r2,\\n                        int targetIndex){\\n            if(r1<l1){\\n                return nums2[ l2 + targetIndex];\\n            }\\n            if(r2<l2){\\n                return nums1[ l1 + targetIndex];\\n            }\\n            int mid1= (r1 + l1)/2;\\n            int mid2= (r2 + l2)/2;\\n            if(nums1[mid1] > nums2[mid2]){\\n                if(targetIndex >= ((mid2 - l2 )+ (mid1 - l1) + 1)){\\n                    return find(nums1, l1, r1, nums2, mid2+1, r2, targetIndex - (mid2 - l2 +1) );\\n                }\\n                else{\\n                    return find(nums1, l1, mid1- 1, nums2, l2, r2, targetIndex);\\n                }\\n            }\\n            else{\\n                if(targetIndex >= (mid2 - l2 + mid1 - l1 + 1)){\\n                    return find(nums1, mid1 + 1, r1, nums2, l2, r2, targetIndex - (mid1 - l1 +1)  );\\n                }\\n                else{\\n                    return find(nums1, l1, r1, nums2, l2, mid2 - 1, targetIndex);\\n                }  \\n            }\\n        }\\n        public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n            int l = nums1.length + nums2.length;\\n            if(l%2 == 0){\\n                int mid1 = find(nums1,0,nums1.length-1,nums2,0,nums2.length-1,l/2);\\n                int mid2 =find(nums1,0,nums1.length-1,nums2,0,nums2.length-1,l/2 - 1);\\n                return ((double)mid1 +(double)mid2) / 2.0; \\n            }\\n            double ans =(double) find(nums1,0,nums1.length-1,nums2,0,nums2.length-1,l/2);\\n            return  ans;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243113,
                "title": "discover-the-mind-blowing-algorithm-to-find-the-median-of-two-sorted-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to find the median of two sorted arrays. To solve this, we can combine the two arrays, sort them, and find the median. However, this solution would have a time complexity of O(nlogn). We can do better by using the fact that both arrays are sorted.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use binary search to find the median of two sorted arrays. First, we select the smaller of the two arrays and perform binary search on it. We set imin = 0 and imax = length of the smaller array. We then find the mid index of the smaller array, i.e., i = (imin + imax) // 2. We also find the corresponding mid index of the larger array, j = (m + n + 1) // 2 - i, where m and n are the lengths of the two arrays.\\n\\nIf nums1[i-1] is greater than nums2[j], we move imax to the left, i.e., imax = i - 1. Otherwise, if nums2[j-1] is greater than nums1[i], we move imin to the right, i.e., imin = i + 1. If neither of the above conditions hold, we have found the correct i.\\n\\nIf the combined length of the two arrays is odd, the median is the maximum of nums1[i-1] and nums2[j-1]. If the length is even, the median is the average of the maximum of nums1[i-1] and nums2[j-1] and the minimum of nums1[i] and nums2[j].\\n# Complexity\\n- Time complexity: O(log(min(m, n))), where m and n are the lengths of the two arrays. We perform binary search on the smaller array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1), we only use a constant amount of extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        if len(nums1) > len(nums2):\\n            nums1, nums2 = nums2, nums1\\n        \\n        m, n = len(nums1), len(nums2)\\n        imin, imax, half_len = 0, m, (m + n + 1) // 2\\n        \\n        while imin <= imax:\\n            i = (imin + imax) // 2\\n            j = half_len - i\\n            \\n            if i < m and nums2[j-1] > nums1[i]:\\n                imin = i + 1\\n            elif i > 0 and nums1[i-1] > nums2[j]:\\n                imax = i - 1\\n            else:\\n                if i == 0: max_left = nums2[j-1]\\n                elif j == 0: max_left = nums1[i-1]\\n                else: max_left = max(nums1[i-1], nums2[j-1])\\n                \\n                if (m + n) % 2 == 1:\\n                    return float(max_left)\\n                \\n                if i == m: min_right = nums2[j]\\n                elif j == n: min_right = nums1[i]\\n                else: min_right = min(nums1[i], nums2[j])\\n                \\n                return (max_left + min_right) / 2.0\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        if len(nums1) > len(nums2):\\n            nums1, nums2 = nums2, nums1\\n        \\n        m, n = len(nums1), len(nums2)\\n        imin, imax, half_len = 0, m, (m + n + 1) // 2\\n        \\n        while imin <= imax:\\n            i = (imin + imax) // 2\\n            j = half_len - i\\n            \\n            if i < m and nums2[j-1] > nums1[i]:\\n                imin = i + 1\\n            elif i > 0 and nums1[i-1] > nums2[j]:\\n                imax = i - 1\\n            else:\\n                if i == 0: max_left = nums2[j-1]\\n                elif j == 0: max_left = nums1[i-1]\\n                else: max_left = max(nums1[i-1], nums2[j-1])\\n                \\n                if (m + n) % 2 == 1:\\n                    return float(max_left)\\n                \\n                if i == m: min_right = nums2[j]\\n                elif j == n: min_right = nums1[i]\\n                else: min_right = min(nums1[i], nums2[j])\\n                \\n                return (max_left + min_right) / 2.0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197519,
                "title": "c-worst-solution-yet-beats-97-brute-force-o-n",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        for (int i = 0 ; i < nums2.size() ; i++)\\n        {\\n            nums1.push_back(nums2[i]) ;\\n        }\\n\\n        sort (nums1.begin(), nums1.end()) ; \\n        int size = nums1.size() ; \\n\\n        double ans = 0 ; \\n        if (size % 2 != 0)\\n        {\\n            ans = nums1[size/2] ; \\n        }\\n        else\\n        {\\n            // note to divide by 2.00000 if you divide by 2 you will get wrong answer because 2 is an integer and 2.00000 is the double format we have to return \\n            ans = (nums1[size/2] + nums1[size/2-1]) / 2.00000 ;\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/8e736dd0-b219-4cea-b728-fb4880408e41_1676641518.2288203.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        for (int i = 0 ; i < nums2.size() ; i++)\\n        {\\n            nums1.push_back(nums2[i]) ;\\n        }\\n\\n        sort (nums1.begin(), nums1.end()) ; \\n        int size = nums1.size() ; \\n\\n        double ans = 0 ; \\n        if (size % 2 != 0)\\n        {\\n            ans = nums1[size/2] ; \\n        }\\n        else\\n        {\\n            // note to divide by 2.00000 if you divide by 2 you will get wrong answer because 2 is an integer and 2.00000 is the double format we have to return \\n            ans = (nums1[size/2] + nums1[size/2-1]) / 2.00000 ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037383,
                "title": "binary-search",
                "content": "# Intuition\\nNormally, we can use combination-sorting to arrange the two sorted list into a new sorted list. Since we know the number of elements, we can stop at the $$(m+n)//2 + 1 th$$ element, maybe also $$(m+n)//2th$$, to compute the median. However, it ends up with $$O(m+n)$$ time complexity. \\nActually, When we see $$O(log(m+n))$$, it is natural to think of binary search method for the above searching process. \\n\\n# Approach\\nComputing the median is actually asking us to look for the $$kth$$ smallest element in two sorted lists, A and B. We can use binary perspective to compare the middle number of A and B so that we can sort out some numbers at the first half of A or B, since they are definitely smallest numbers. After sorting these numbers out, we have a new A or B, and then do the same thing to sort out more numbers.\\n\\nFor example, we want to find the `7th` smallest number of the below lists\\n```\\nA = [1 3 4 9]\\n         \\u2191\\nB = [1 2 3 4 5 6 7 8 9]\\n         \\u2191\\n```\\nWe can rule out `B[0]` and `B[1]` by `B[2] < A[2]`, since they are the smallest two elements. Then problem becomes finding the `5th` smallest number in the below lists (bracket means sorting out)\\n```\\nA: 1 3 4 9\\n     \\u2191\\nB: [1 2 3] 4 5 6 7 8 9\\n             \\u2191 \\n```\\nContinue doing this:\\nfind the `2nd` smallest number in\\n```\\nA: [1 3] 4 9\\n         \\u2191\\nB: [1 2 3] 4 5 6 7 8 9\\n           \\u2191\\n```\\nfind the `1st` smallest in\\n```\\nA: [1 3 4] 9\\n           \\u2191\\nB: [1 2 3] 4 5 6 7 8 9\\n           \\u2191\\n```\\nand result is obviously 4\\n\\nSummary:\\n1. compare the `A[k//2 - 1]` and `B[k//2 - 1]`.\\n2. generate a new sorted list and new $$k$$ by ruling out the number before the smaller one\\n3. repeat above result until $$k = 1$$ and choose the smaller one of the first element in two lists\\n\\n# Tips\\n- If `k//2 - 1` exceeds the index of A or B, that means one of the list has been throughly checked and sorted out. The `kth` element is definitely in the other list. Then we just pick the `B[k-1]`\\n# Complexity\\n- Time complexity:\\n$$O(log(m+n))$$\\n\\n\\n# Code\\n\\n```python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        def getKthElement(k):\\n            beginIndex1, beginIndex2 = 0, 0\\n            while True:\\n                if beginIndex1 == m:\\n                    return nums2[beginIndex2 + k - 1]\\n                if beginIndex2 == n:\\n                    return nums1[beginIndex1 + k - 1]\\n                if k == 1:\\n                    return min(nums1[beginIndex1], nums2[beginIndex2]) \\n\\n                pivotIndex1 = min(beginIndex1 + k//2 - 1, m - 1)\\n                pivotIndex2 = min(beginIndex2 + k//2 - 1, n - 1)\\n                pivot1 = nums1[pivotIndex1]\\n                pivot2 = nums2[pivotIndex2]\\n\\n                if pivot1 <= pivot2:\\n                    k -= pivotIndex1 - beginIndex1 + 1\\n                    beginIndex1 = pivotIndex1 + 1\\n                else:\\n                    k -= pivotIndex2 - beginIndex2 + 1\\n                    beginIndex2 = pivotIndex2 + 1             \\n\\n        m, n = len(nums1), len(nums2)\\n        length = m + n\\n        if length % 2 == 1:\\n            return getKthElement(length//2 + 1)\\n        else:\\n            return (getKthElement(length//2) + getKthElement(length//2 + 1)) / 2\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nA = [1 3 4 9]\\n         \\u2191\\nB = [1 2 3 4 5 6 7 8 9]\\n         \\u2191\\n```\n```\\nA: 1 3 4 9\\n     \\u2191\\nB: [1 2 3] 4 5 6 7 8 9\\n             \\u2191 \\n```\n```\\nA: [1 3] 4 9\\n         \\u2191\\nB: [1 2 3] 4 5 6 7 8 9\\n           \\u2191\\n```\n```\\nA: [1 3 4] 9\\n           \\u2191\\nB: [1 2 3] 4 5 6 7 8 9\\n           \\u2191\\n```\n```python []\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        def getKthElement(k):\\n            beginIndex1, beginIndex2 = 0, 0\\n            while True:\\n                if beginIndex1 == m:\\n                    return nums2[beginIndex2 + k - 1]\\n                if beginIndex2 == n:\\n                    return nums1[beginIndex1 + k - 1]\\n                if k == 1:\\n                    return min(nums1[beginIndex1], nums2[beginIndex2]) \\n\\n                pivotIndex1 = min(beginIndex1 + k//2 - 1, m - 1)\\n                pivotIndex2 = min(beginIndex2 + k//2 - 1, n - 1)\\n                pivot1 = nums1[pivotIndex1]\\n                pivot2 = nums2[pivotIndex2]\\n\\n                if pivot1 <= pivot2:\\n                    k -= pivotIndex1 - beginIndex1 + 1\\n                    beginIndex1 = pivotIndex1 + 1\\n                else:\\n                    k -= pivotIndex2 - beginIndex2 + 1\\n                    beginIndex2 = pivotIndex2 + 1             \\n\\n        m, n = len(nums1), len(nums2)\\n        length = m + n\\n        if length % 2 == 1:\\n            return getKthElement(length//2 + 1)\\n        else:\\n            return (getKthElement(length//2) + getKthElement(length//2 + 1)) / 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785188,
                "title": "c-solution",
                "content": "``\\n\\n\\nclass Solution {\\npublic:\\n\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\n        //method 1 is to make a loop for both vectors and combine them into 1 then find the middle most element with setprecision of 5; (brute force)\\n        //method 2 merge sort\\n            // i can merge them like we do in merge sort then return the middle most element with setprecision \\n        //method 3 binary search \\n            //we will partition the elements in such a way the left half will contain all the which we need to merge till the mediun and rest will be in the right one\\n            //partition will be done using binary search \\n            //binary search on the smaller vetor given \\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        if(n2<n1) return findMedianSortedArrays(nums2,nums1);\\n        \\n        int low=0,high=n1;\\n        while(low<=high){\\n            int cut1=(high+low)/2;\\n            int cut2=(n1+n2+1)/2-cut1;\\n            \\n            int l1=cut1==0?INT_MIN:nums1[cut1-1];\\n            int l2=cut2==0?INT_MIN:nums2[cut2-1];\\n            \\n            int r1=cut1==n1?INT_MAX:nums1[cut1];\\n            int r2=cut2==n2?INT_MAX:nums2[cut2];\\n            \\n            if(l1<=r2 && l2<=r1){\\n                if((n1+n2)%2==0){\\n                    return (max(l1,l2)+min(r1,r2))/2.0;\\n                }\\n                else{\\n                    return max(l1,l2);\\n                }\\n            }\\n            else if(l1>r2){\\n                high=cut1-1;\\n            }\\n            else{\\n                low=cut1+1;\\n            }\\n        }\\n        return 0.0;\\n        \\n        \\n        \\n    }\\n};\\n``",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\n        //method 1 is to make a loop for both vectors and combine them into 1 then find the middle most element with setprecision of 5; (brute force)\\n        //method 2 merge sort\\n            // i can merge them like we do in merge sort then return the middle most element with setprecision \\n        //method 3 binary search \\n            //we will partition the elements in such a way the left half will contain all the which we need to merge till the mediun and rest will be in the right one\\n            //partition will be done using binary search \\n            //binary search on the smaller vetor given \\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        if(n2<n1) return findMedianSortedArrays(nums2,nums1);\\n        \\n        int low=0,high=n1;\\n        while(low<=high){\\n            int cut1=(high+low)/2;\\n            int cut2=(n1+n2+1)/2-cut1;\\n            \\n            int l1=cut1==0?INT_MIN:nums1[cut1-1];\\n            int l2=cut2==0?INT_MIN:nums2[cut2-1];\\n            \\n            int r1=cut1==n1?INT_MAX:nums1[cut1];\\n            int r2=cut2==n2?INT_MAX:nums2[cut2];\\n            \\n            if(l1<=r2 && l2<=r1){\\n                if((n1+n2)%2==0){\\n                    return (max(l1,l2)+min(r1,r2))/2.0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2637637,
                "title": "hard-problem-python-solution-o-log-min-m-n",
                "content": "Please Upvote if you find this helpful! Thanks\\n```\\n# --------------------------------------------- Method 1 O(m + n) Complexity not optimized ---------------------------------------------\\n\\n\\ndef findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        nums = nums1 + nums2           # Concatenate the 2 lists\\n        nums.sort()                                # sort list\\n        div, is_odd = len(nums)//2, len(nums)%2         \\n        return nums[div] if is_odd else (nums[div-1] + nums[div])/2 # if list length is odd return : the middle number in the list, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# else return : sum of the 2 middle numbers and divide them by 2\\n\\n# Time = O(m + n) because sorting merged array (num1 + num2)\\n# Space = O(1)\\n\\n# ------------------------------------ Method 2 O( log(min(m, n)) ) Complexity **Optimized** ------------------------------------\\n\\n\\ndef findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        A, B = nums1, nums2\\n        total = len(nums1) + len(nums2)\\n        half = total // 2\\n        \\n        if len(B) < len(A):\\n            A, B = B, A\\n        \\n        l, r = 0, len(A) - 1\\n        while True:\\n            i = (l + r) // 2\\n            j = half - i -2\\n            \\n\\t\\t\\t# float(\"inf) and float(\"-inf\") is for EDGE CASES\\n            Aleft = A[i] if i >= 0 else float(\"-inf\")\\n            Aright = A[i + 1] if (i + 1) < len(A) else float(\"inf\")\\n            Bleft = B[j] if j >= 0 else float(\"-inf\")\\n            Bright = B[j + 1] if (j + 1) < len(B) else float(\"inf\")\\n            \\n            #check whether partition is correct or not\\n            if Aleft <= Bright and Bleft <= Aright:\\n                #odd\\n                if total % 2:\\n                    return min(Aright, Bright)\\n                #even\\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2\\n            elif Aleft > Bright:\\n                r = i - 1\\n            else:\\n                l = i + 1\\n\\t\\t\\t\\t\\n# Time - O( log(min(m, n)) ) min of A and B because binary search is applied on only one sorted array which has minimum length\\n# Space - O(1)\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n# --------------------------------------------- Method 1 O(m + n) Complexity not optimized ---------------------------------------------\\n\\n\\ndef findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        nums = nums1 + nums2           # Concatenate the 2 lists\\n        nums.sort()                                # sort list\\n        div, is_odd = len(nums)//2, len(nums)%2         \\n        return nums[div] if is_odd else (nums[div-1] + nums[div])/2 # if list length is odd return : the middle number in the list, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# else return : sum of the 2 middle numbers and divide them by 2\\n\\n# Time = O(m + n) because sorting merged array (num1 + num2)\\n# Space = O(1)\\n\\n# ------------------------------------ Method 2 O( log(min(m, n)) ) Complexity **Optimized** ------------------------------------\\n\\n\\ndef findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        A, B = nums1, nums2\\n        total = len(nums1) + len(nums2)\\n        half = total // 2\\n        \\n        if len(B) < len(A):\\n            A, B = B, A\\n        \\n        l, r = 0, len(A) - 1\\n        while True:\\n            i = (l + r) // 2\\n            j = half - i -2\\n            \\n\\t\\t\\t# float(\"inf) and float(\"-inf\") is for EDGE CASES\\n            Aleft = A[i] if i >= 0 else float(\"-inf\")\\n            Aright = A[i + 1] if (i + 1) < len(A) else float(\"inf\")\\n            Bleft = B[j] if j >= 0 else float(\"-inf\")\\n            Bright = B[j + 1] if (j + 1) < len(B) else float(\"inf\")\\n            \\n            #check whether partition is correct or not\\n            if Aleft <= Bright and Bleft <= Aright:\\n                #odd\\n                if total % 2:\\n                    return min(Aright, Bright)\\n                #even\\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2\\n            elif Aleft > Bright:\\n                r = i - 1\\n            else:\\n                l = i + 1\\n\\t\\t\\t\\t\\n# Time - O( log(min(m, n)) ) min of A and B because binary search is applied on only one sorted array which has minimum length\\n# Space - O(1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2284686,
                "title": "for-guys-who-find-it-simple",
                "content": "After looking at the problem statement its so tempting to simply merge two arrays and run in built sort algorithm and give the median. So easy, isn\\'t it. \\n\\nBut wait, in real interview the moment you propose your approach interviewer will 100% ask you to improve your solution. Now comes the hard part. Now you have to solve it in lon(n+m) time complexity without using any extra space. \\n\\nCan you do it? If you haven\\'t solved it here then its almost sure you wont be able to solve it there too and you missed your chance for a seen problem. So guys dont take it easy and try to do it again.",
                "solutionTags": [],
                "code": "After looking at the problem statement its so tempting to simply merge two arrays and run in built sort algorithm and give the median. So easy, isn\\'t it. \\n\\nBut wait, in real interview the moment you propose your approach interviewer will 100% ask you to improve your solution. Now comes the hard part. Now you have to solve it in lon(n+m) time complexity without using any extra space. \\n\\nCan you do it? If you haven\\'t solved it here then its almost sure you wont be able to solve it there too and you missed your chance for a seen problem. So guys dont take it easy and try to do it again.",
                "codeTag": "Unknown"
            },
            {
                "id": 2191273,
                "title": "java-how-to-approach-simple-explanation",
                "content": "**Brute force** solution has **linear time complexity** and easy to think but here it will give us **TLE** . Hence we will try it to solve in **lograthmic** time complexity.\\n\\nSince both given arrays(**nums1** and **nums2**) are sorted only algorithm that came into mind which has **lograthmic** time complexity  is **binary search**. So in this solution we will think **binary search** kind of logic. We will find middle terms and calculate the **median** and return it.\\n\\n**Efficient Solution thinking approach** : \\n\\nObserve following numbers :\\n \\t \\n\\t  1   2   3   4   5   6   7   8    9    10\\n\\n**Middle numbers** = **5** and **6** (according to median formula) **n/2** and **(n+1)/2 th** term , if **n is even**\\n\\nHence **median** = (5 + 6) / 2.0    (Divided by 2.0 because need to return dobule value not integer)\\n\\nObviously,\\n1.\\tAll elements **left** to mid (1,2,3,4) is less than 5 & 6\\n2.\\tAll elements **right** to mid  (7,8,9,10) is greater than 5 & 6\\n3.\\t**Count** of the elements to the right and left of the mid (5&6) is equals. i.e **count = 4**.\\nSo, we need to meet these 3 requirements to find median.\\n\\n\\n**Example solution**:  \\n\\nInstead of merging and then sorting, we **logically** divide arrays in two **sets**  based on index by finding **middle** element such that above **three mentioned** condition are met.\\n\\n**See Example for more details**\\n\\n**nums1[]** = [1 3,8 9];\\n**nums2[]** = [2,4,5,6,7,10]\\n\\n![image](https://assets.leetcode.com/users/images/e955ebc4-7178-43c1-829b-8f02057758b3_1656069598.199844.png)\\n\\n\\n\\nIf you observe carefully:\\n\\n**nums1** array is partitioned from **index 2**. Elements to the left of **index2** added in **set1** and rest of elements added in set2\\n**nums2** array is partitioned from **index 3**. Elements to the left of **index3** added in **set1** and rest of elements added in set2\\n\\n**Observe carefully once again**\\n\\n1. All the elements in first set are **smaller** than all the element in **second** set. if you visualize both set as individual **combined** set **on number line** this is sorted whole sorted array.\\n2. **Count** of elements in both half are same.\\n3. Also This will be **termination** condition for our binary search based solution.\\n\\n### That\\'s it. Ultimately our goal and catch of this problem is to reach at this point and find indexes, from here it is very easy to calculate median.\\n\\n![image](https://assets.leetcode.com/users/images/161a5f69-3228-46b3-91ca-ea78c5bc3db1_1656070494.025955.png)\\n\\nAgain think of number line: (on paper put these numbers on number line to understand following if condition)\\n\\nSo if we want to check if both set are sorted as whole is:\\n\\n```\\n    if((max1 <= min2) && (max2 <=min1)){\\n                if((n+m)%2 == 0){\\n                   //means both set are sorted.Hence calculating median\\n                    res = (Math.max(max1,max2) + Math.min(min1,min2))*0.5;\\n                }\\n                else{\\n                    res = Math.max(max1,max2);\\n                }\\n                break; // condition to break outer loop if median is calculated.\\n            }\\n```\\n\\nHere n & m is size of both array. Multiplied by 0.5 because we need to return double value.\\n\\n### Logic to find Partioned index for both arrays\\n\\n**Note**: For simplicity, assumption of this solution is  **num1.length < num2.length**.  so this condition is not satisfied then, reverese the pointer. (Call the function again by swapping arguments position). \\n\\n\\n  1. index for nums1 can be found using :   `i1 =  (0 + nums1.length)/2`     **[This is how we find mid in binary search]**\\n  Divide array in two equal parts at index i1. **left** part go in set 1 (**see diagram**) and **right** part wiill go in set 2.\\n  \\n  in above example **i1 = 8** we put 0 to i1 - 1 element to set1 and rest elements in set2\\n  \\n  2. index for **nums2** can be found using :  ` i2 =  (nums1.length + nums2.length() + 1)/2 - i1`  **[Find mid for second array]**\\n\\nHere  i1 case be seen as **length**. So what this do is  **totalLength - length**.\\n\\n**This condition distribute equal number of elements in both of set. You need not to care add check for count of elements in both set1 and set2 are equal, which is one of the manadatory condition for median**\\n\\n\\n### Handle corner cases here:\\n\\n```\\nif i1 == 0 then i1=Integer.MIN_VALUE\\nif i1 == n then i1=  Integer.MAX_VALUE\\n\\nif i2 ==0 then i2=Integer.MIN_VALUE\\nif i2==m then i2= Integer.MAX_VALUE\\n```\\n\\n\\n### Complete Code:\\n\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        \\n        int n = nums1.length;\\n        int m = nums2.length;\\n        \\n        //make sure first array should have smaller length.\\n        if(n > m){\\n            return findMedianSortedArrays(nums2,nums1);\\n        }\\n        \\n        int start = 0;\\n        int end = n;\\n        \\n        double res = 0;\\n        \\n        while(start <= end){\\n            int i1 = (start + end)/2;\\n            int i2 = (n + m + 1)/2 - i1;\\n            \\n\\t\\t\\t//handle edge cases\\n            int min1 = (i1 == n) ? Integer.MAX_VALUE : nums1[i1];  // this always go right. basically handling if mid at index n\\n            int max1 = (i1 == 0) ? Integer.MIN_VALUE : nums1[i1 - 1]; // this always go to left. basically handling if mid at index 0\\n                \\n            int min2 = (i2 == m) ? Integer.MAX_VALUE : nums2[i2];\\n            int max2 = (i2 == 0) ? Integer.MIN_VALUE : nums2[i2 - 1];\\n            \\n\\t\\t\\t//condition for sorted partition\\n            if((max1 <= min2) && (max2 <=min1)){\\n                if((n+m)%2 == 0){\\n                     // divding by will 2 gives wrong result hennce mulitpy by 0.5 or divide by 2.0 not 2\\n                    res = (Math.max(max1,max2) + Math.min(min1,min2))*0.5;\\n                }\\n                else{\\n\\t\\t\\t\\t//median in case of odd.\\n                    res = Math.max(max1,max2);\\n                }\\n                break;\\n            }\\n            else if(max1 > min2){ //means wrong element selected in set. it should be smaller. Shift to left or one step back.\\n                end = i1-1;\\n            }\\n            else{\\n                start = i1+1;  //shift right\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nThis is how this problem can be solved using modifying binary search. Ultimate goal is to find right i1 & i2.\\n\\n\\n  \\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n    if((max1 <= min2) && (max2 <=min1)){\\n                if((n+m)%2 == 0){\\n                   //means both set are sorted.Hence calculating median\\n                    res = (Math.max(max1,max2) + Math.min(min1,min2))*0.5;\\n                }\\n                else{\\n                    res = Math.max(max1,max2);\\n                }\\n                break; // condition to break outer loop if median is calculated.\\n            }\\n```\n```\\nif i1 == 0 then i1=Integer.MIN_VALUE\\nif i1 == n then i1=  Integer.MAX_VALUE\\n\\nif i2 ==0 then i2=Integer.MIN_VALUE\\nif i2==m then i2= Integer.MAX_VALUE\\n```\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        \\n        int n = nums1.length;\\n        int m = nums2.length;\\n        \\n        //make sure first array should have smaller length.\\n        if(n > m){\\n            return findMedianSortedArrays(nums2,nums1);\\n        }\\n        \\n        int start = 0;\\n        int end = n;\\n        \\n        double res = 0;\\n        \\n        while(start <= end){\\n            int i1 = (start + end)/2;\\n            int i2 = (n + m + 1)/2 - i1;\\n            \\n\\t\\t\\t//handle edge cases\\n            int min1 = (i1 == n) ? Integer.MAX_VALUE : nums1[i1];  // this always go right. basically handling if mid at index n\\n            int max1 = (i1 == 0) ? Integer.MIN_VALUE : nums1[i1 - 1]; // this always go to left. basically handling if mid at index 0\\n                \\n            int min2 = (i2 == m) ? Integer.MAX_VALUE : nums2[i2];\\n            int max2 = (i2 == 0) ? Integer.MIN_VALUE : nums2[i2 - 1];\\n            \\n\\t\\t\\t//condition for sorted partition\\n            if((max1 <= min2) && (max2 <=min1)){\\n                if((n+m)%2 == 0){\\n                     // divding by will 2 gives wrong result hennce mulitpy by 0.5 or divide by 2.0 not 2\\n                    res = (Math.max(max1,max2) + Math.min(min1,min2))*0.5;\\n                }\\n                else{\\n\\t\\t\\t\\t//median in case of odd.\\n                    res = Math.max(max1,max2);\\n                }\\n                break;\\n            }\\n            else if(max1 > min2){ //means wrong element selected in set. it should be smaller. Shift to left or one step back.\\n                end = i1-1;\\n            }\\n            else{\\n                start = i1+1;  //shift right\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065455,
                "title": "python-3-intuitive-o-log-m-n-solution-with-pictures-and-detailed-explanation",
                "content": "Hi! I would like to share with you my solution and try to explain it clearly with pictures. To solve the find median problem, first let\\'s write a more general algorithm called `findi` .\\n\\nDefinition of `findi(A, B, i)`:\\nLet A={ a_0, a_1, ... , a_(m-1) }, B={ b_0, b_1, ... , b_(n-1) } and S=A+B={ s_0, ... , s_(m+n-1) }, \\nwhere A, B and S are sorted in non-decending order.\\nGiven an index i, find the value of s_i.\\n\\nSolving `findi(A, B, i)`:\\nChoose two pivot values, a_p and b_q, we have \\nA={ a_0, ... , a_p, ..., a_(m-1)}\\nB={ b_0, ... , b_q, ... , b_(n-1)}\\nWe see that a_p and b_q divide the two arrays into four sections, \\nAL={a_0, ... , a_(p-1)}, AR={a_p, ... , a(m-1)}\\nBL={b_0, ... , b_(q-1)}, BR={b_q, ... , b(n-1)}\\n\\n**if a(p-1)>=b(q-1), then** \\nAR>=BL, BR>=BL, |AR|=m-p+1, |BR|=n-q, \\nthis means in S, there are at least |AR|+|BR|=m+n-p-q+1 elements >= BL\\nso the index of BL <= m+n-1-(m+n-p-q+1)=p+q-2\\n\\nAR>=BL, AR>=AL, |BL|=q, |AL|=p-1,\\nthis means in S, there are at least |BL|+|AL|=p+q-1 elements <= AR\\nso the index of AR >= p+q-1\\n\\nFor i there are two cases:\\ncase (1):\\nif i<=p+q-2, we know s_i cannot be in AR, we can exclude AR and recurse on `findi(AL, B, i)`.\\n\\ncase (2):\\nif i>=p+q-1, we know s_i cannot be in BL, we can exclude BL, \\nbut by removing BL, we have removed |BL|=q elements from the left, so now we need to find i-q by calling `findi(A, BR, i-q)`.\\n![image](https://assets.leetcode.com/users/images/d1b8ec3b-a2e7-4276-9901-bcf3f9cb384b_1653275848.64813.png)\\n\\n**if a(p-1)<b(q-1), then**\\nBR>AL, AR>=AL, |BR|=n-q+1, |AR|=m-p\\nthis means in S, there are at least |BR|+|AR|=m+n-p-q+1 elements >= AL\\nso the index of AL <= m+n-1-(n+m-p-q+1)=p+q-2\\n\\nBR>=AL, BR>=BL, |AL|=p, |BL|=q-1, \\nthis means in S, there are at least |AL|+|BL|=p+q-1 elements <= BR\\nso the index of BR >= p+q-1\\n\\nFor i there are also two cases:\\ncase (3):\\nif i<=p+q-2, we know si cannot be in BR, we can exclude BR and recurse on `findi(A, BL, i)`.\\ncase (4):\\nif i>=p+q-1, we know si cannot be in AL, we can exclude AL, \\nbut by removing AL, we have removed |BL|=p elements from the left, so now we need to find i-p by calling `findi(AR, B, i-p)`.\\n![image](https://assets.leetcode.com/users/images/c73797c2-2501-4718-90bc-4d3737a304bc_1653275876.6314259.png)\\n\\nContinue recursion until A or B is empty. Then S is the same as B or A and we can simply return B[i] or A[i].\\nThis completes the solution to `findi`.\\n\\nTo solve the original find median problem. We can seperate it into two cases:\\nIf |S| is odd, then median=findi(A, B, (|A|+|B|)//2)\\nIf |S| is even, median=mean[ findi(A, B, (|A|+|B|)//2-1), findi(A, B, (|A|+|B|)//2)]\\nThis completes the solution to the original problem.\\n\\nThe code is shown below.\\nBy selecting the mid point as pivots for both A and B, it has an average time and space complexity of both O(log (m+n)).\\n\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n                    \\n        def findi(a:List[int], b:List[int], i:int)->int:\\n\\n            m=len(a)\\n            n=len(b)\\n\\t\\t\\t\\n\\t\\t\\t# end case for recursion\\n            if m==0: return b[i]\\n            if n==0: return a[i]\\n\\t\\t\\t\\n\\t\\t\\t# choose pivot\\n            p=m//2+1\\n            q=n//2+1\\n\\n\\t\\t\\t# handle case 1 and 2 (see explanation above)\\n            if a[p-1]>=b[q-1]:\\n                if i<=p+q-2: return findi(a[:p-1], b, i)\\n                else: return findi(a, b[q:], i-q)\\n\\t\\t\\t\\t\\n\\t\\t\\t# handle case 3 and 4 (see explanation above)\\n            else:\\n                if i<=p+q-2: return findi(a, b[:q-1], i)\\n                else: return findi(a[p:], b, i-p)\\n            \\n\\t\\t# use findi to solve the find median problem\\n        l1=len(nums1)\\n        l2=len(nums2)\\n        if (l1+l2)%2==1: return findi(nums1, nums2, (l1+l2)//2)\\n        else: \\n            return (findi(nums1, nums2, (l1+l2)//2-1)+findi(nums1, nums2, (l1+l2)//2))/2\\n            \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n                    \\n        def findi(a:List[int], b:List[int], i:int)->int:\\n\\n            m=len(a)\\n            n=len(b)\\n\\t\\t\\t\\n\\t\\t\\t# end case for recursion\\n            if m==0: return b[i]\\n            if n==0: return a[i]\\n\\t\\t\\t\\n\\t\\t\\t# choose pivot\\n            p=m//2+1\\n            q=n//2+1\\n\\n\\t\\t\\t# handle case 1 and 2 (see explanation above)\\n            if a[p-1]>=b[q-1]:\\n                if i<=p+q-2: return findi(a[:p-1], b, i)\\n                else: return findi(a, b[q:], i-q)\\n\\t\\t\\t\\t\\n\\t\\t\\t# handle case 3 and 4 (see explanation above)\\n            else:\\n                if i<=p+q-2: return findi(a, b[:q-1], i)\\n                else: return findi(a[p:], b, i-p)\\n            \\n\\t\\t# use findi to solve the find median problem\\n        l1=len(nums1)\\n        l2=len(nums2)\\n        if (l1+l2)%2==1: return findi(nums1, nums2, (l1+l2)//2)\\n        else: \\n            return (findi(nums1, nums2, (l1+l2)//2-1)+findi(nums1, nums2, (l1+l2)//2))/2\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032243,
                "title": "python-tushar-roy-s-solution-94-63",
                "content": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        if len(nums1) > len(nums2):\\n            return self.findMedianSortedArrays(nums2, nums1)\\n        \\n        all_len = len(nums1) + len(nums2)\\n        left_size = (all_len + 1) // 2\\n\\n        lo, hi = 0, len(nums1) - 1\\n        while True:\\n            med1 = (lo + hi) // 2\\n            med2 = left_size - 1 - (med1 + 1)\\n            \\n            left1 = -float(\\'inf\\') if med1 < 0 else nums1[med1]\\n            right1 = float(\\'inf\\') if med1 + 1 >= len(nums1) else nums1[med1 + 1]\\n            left2 = -float(\\'inf\\') if med2 < 0 else nums2[med2]\\n            right2 = float(\\'inf\\') if med2 + 1 >= len(nums2) else nums2[med2 + 1]\\n            \\n            if left1 > right2:\\n                hi = med1 if hi != 0 else med1 - 1\\n            elif left2 > right1:\\n                lo = med1 + 1\\n            else:\\n                break\\n        \\n        if all_len % 2 == 1:\\n            return max(left1, left2)\\n        else:\\n            return (max(left1, left2) + min(right1, right2)) / 2\\n```\\n\\n**Why do we need that** ```len(nums1) <= len(nums2)```? **(third line in code)**\\n```\\nif len(nums1) > len(nums2):\\n    return self.findMedianSortedArrays(nums2, nums1)\\n```\\nbecause if the length of ```nums1``` is greater than the length of ```nums2```, and we go to the left in binary search, it may turn out that the second ```nums2``` doesn\\'t have enough elements to fill left_size, example:\\n\\n```\\nnums1 = [2, 3, 4, 5, 6, 7, 8]\\nnums2 = [1]\\n```\\n\\nFirst ```if left1 > right2```? -> ```5 > 1```? -> Yes! -> ```hi = med1```\\n```left_size = 4```, ```nums1``` median index is ```1``` (and that\\'s ```2``` elements in the left part for ```nums1```), but ```nums2``` has only ```1``` element!!! That is, ```2 + 1 = 3```, and ```3 < 4``` (```left_size```), and here our code breaks. Therefore it is necessary that the first list is less than the second!!!\\n\\nTime Complexity - ```O(log(min(m, n)))```, Space Complexity - ```O(1)```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        if len(nums1) > len(nums2):\\n            return self.findMedianSortedArrays(nums2, nums1)\\n        \\n        all_len = len(nums1) + len(nums2)\\n        left_size = (all_len + 1) // 2\\n\\n        lo, hi = 0, len(nums1) - 1\\n        while True:\\n            med1 = (lo + hi) // 2\\n            med2 = left_size - 1 - (med1 + 1)\\n            \\n            left1 = -float(\\'inf\\') if med1 < 0 else nums1[med1]\\n            right1 = float(\\'inf\\') if med1 + 1 >= len(nums1) else nums1[med1 + 1]\\n            left2 = -float(\\'inf\\') if med2 < 0 else nums2[med2]\\n            right2 = float(\\'inf\\') if med2 + 1 >= len(nums2) else nums2[med2 + 1]\\n            \\n            if left1 > right2:\\n                hi = med1 if hi != 0 else med1 - 1\\n            elif left2 > right1:\\n                lo = med1 + 1\\n            else:\\n                break\\n        \\n        if all_len % 2 == 1:\\n            return max(left1, left2)\\n        else:\\n            return (max(left1, left2) + min(right1, right2)) / 2\\n```\n```len(nums1) <= len(nums2)```\n```\\nif len(nums1) > len(nums2):\\n    return self.findMedianSortedArrays(nums2, nums1)\\n```\n```nums1```\n```nums2```\n```nums2```\n```\\nnums1 = [2, 3, 4, 5, 6, 7, 8]\\nnums2 = [1]\\n```\n```if left1 > right2```\n```5 > 1```\n```hi = med1```\n```left_size = 4```\n```nums1```\n```1```\n```2```\n```nums1```\n```nums2```\n```1```\n```2 + 1 = 3```\n```3 < 4```\n```left_size```\n```O(log(min(m, n)))```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1980572,
                "title": "java-c-python-kotlin-javascript-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***C++***\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        int target = (nums1.size() + nums2.size());\\n        int prev = 0;\\n        \\n        while(true) {\\n            \\n            int n = 0;\\n            \\n            int x = INT_MAX;\\n            int y = INT_MAX;\\n            \\n            if(i < nums1.size()) x = nums1[i];\\n            if(j < nums2.size()) y = nums2[j];\\n            \\n            if(x == INT_MAX && y == INT_MAX) break;\\n            \\n            if(x < y) {\\n                n = x;\\n                i++;\\n            }\\n            else {\\n                n = y;\\n                j++;\\n            }\\n            \\n            if(count == target / 2) {\\n                if(target % 2 != 0) {\\n                    return n;\\n                }\\n                else {\\n                    return (double)(prev + n) / 2;\\n                }\\n            }\\n            prev = n;\\n            count++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n***Java***\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1 == null && nums2 == null){\\n            return 0;\\n        }\\n        \\n        if(nums1 == null){\\n            int n = nums2.length;\\n            return nums2[(n - 1) / 2] * 0.5 + nums2[n / 2] * 0.5;\\n        }\\n        \\n        if(nums2 == null){\\n            int n = nums1.length;\\n            return nums1[(n - 1) / 2] * 0.5 + nums1[n / 2] * 0.5;\\n        }\\n        \\n        if(nums1.length > nums2.length){\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        // choose shorter to binary search\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int left = 0;\\n        int right = n;\\n        \\n        while(left < right){\\n            int i = (left + right) / 2;\\n            int j = (n + m) / 2 - i;\\n            \\n            if(nums1[i] < nums2[j - 1]){\\n                left = i + 1;\\n            }else{\\n                right = i;\\n            }\\n        }\\n        \\n        int first = left;\\n        int second = (n + m) / 2 - left;\\n        \\n        int shorterLeft = first == 0 ? Integer.MIN_VALUE : nums1[first - 1];\\n        int shorterRight = first == n ? Integer.MAX_VALUE : nums1[first];\\n        \\n        int longerLeft = second == 0 ? Integer.MIN_VALUE : nums2[second - 1];\\n        int longerRight = second == m ? Integer.MAX_VALUE : nums2[second];\\n        \\n        if((n + m) % 2 == 1) {\\n            return Math.min(shorterRight, longerRight);\\n        }else{\\n            return Math.max(shorterLeft, longerLeft) * 0.5 + Math.min(shorterRight, longerRight) * 0.5;\\n        }\\n \\n\\n        \\n    }\\n}\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        n = len(nums1) + len(nums2)\\n        i1 = -1\\n        i2 = -1\\n        last = 0\\n        last_last = 0\\n        if n % 2 == 0:\\n            for i in range(int(n / 2) + 1):\\n                if i1 + 1 > len(nums1) - 1:\\n                    i2 += 1\\n                    last_last = last\\n                    last = nums2[i2]\\n                elif i2 + 1 > len(nums2) - 1:\\n                    i1 += 1\\n                    last_last = last\\n                    last = nums1[i1]\\n                else:\\n                    if nums1[i1 + 1] < nums2[i2 + 1]:\\n                        i1 += 1\\n                        last_last = last\\n                        last = nums1[i1]\\n                    else:\\n                        i2 += 1\\n                        last_last = last\\n                        last = nums2[i2]\\n            return (last + last_last) / 2\\n        else:\\n            for i in range(int(n / 2) + 1):\\n                if i1 + 1 > len(nums1) - 1:\\n                    i2 += 1\\n                    last = nums2[i2]\\n                elif i2 + 1 > len(nums2) - 1:\\n                    i1 += 1\\n                    last = nums1[i1]\\n                else:\\n                    if (nums1[i1 + 1] < nums2[i2 + 1]):\\n                        i1 += 1\\n                        last = nums1[i1]\\n                    else:\\n                        i2 += 1\\n                        last = nums2[i2]\\n\\n            return last\\n```\\n\\n***Kotlin***\\n```\\nclass Solution {\\n     fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {\\n        val n = nums1.size \\n        val m = nums2.size \\n        val ans = DoubleArray(n+m)\\n        var i = 0// track array 1\\n        var j = 0// track array 2\\n        var index = 0\\n        while(i < n && j< m){\\n            if(nums1[i] < nums2[j]){\\n                ans[index++] = nums1[i++].toDouble()\\n            } else {\\n                ans[index++] = nums2[j++].toDouble()\\n            }\\n        }\\n        \\n        while(i < n) ans[index++] = nums1[i++].toDouble()\\n        while(j < m) ans[index++] = nums2[j++].toDouble()\\n        val mid = (n+m)/2\\n        \\n        if ((n+m) %2 ==0){\\n            return (ans[mid] + ans[mid-1])/2.0\\n        }\\n        \\n        return ans[mid]\\n    }\\n}\\n```\\n\\n***JavaScript***\\n```\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    if(nums1.length > nums2.length) return findMedianSortedArrays(nums2, nums1)\\n    let x = nums1.length\\n    let y = nums2.length\\n    let low = 0, high = x\\n    while(low <= high) {\\n        const partitionX = (high + low) >> 1\\n        const partitionY = ((x + y + 1) >> 1) - partitionX\\n        \\n        const maxX = partitionX == 0 ? Number.NEGATIVE_INFINITY : nums1[partitionX - 1]\\n        const maxY = partitionY == 0 ? Number.NEGATIVE_INFINITY : nums2[partitionY - 1]\\n        \\n        const minX = partitionX == nums1.length ? Number.POSITIVE_INFINITY : nums1[partitionX]\\n        const minY = partitionY == nums2.length ? Number.POSITIVE_INFINITY : nums2[partitionY ]\\n        \\n        if(maxX <= minY && maxY <= minX) {\\n            const lowMax = Math.max(maxX, maxY)\\n            if( (x + y) % 2 == 1)\\n                return lowMax\\n            return (lowMax + Math.min(minX, minY)) / 2\\n        } else if(maxX < minY) {\\n            low = partitionX + 1\\n        } else \\n            high = partitionX - 1\\n    }\\n    \\n};\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Kotlin",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        int target = (nums1.size() + nums2.size());\\n        int prev = 0;\\n        \\n        while(true) {\\n            \\n            int n = 0;\\n            \\n            int x = INT_MAX;\\n            int y = INT_MAX;\\n            \\n            if(i < nums1.size()) x = nums1[i];\\n            if(j < nums2.size()) y = nums2[j];\\n            \\n            if(x == INT_MAX && y == INT_MAX) break;\\n            \\n            if(x < y) {\\n                n = x;\\n                i++;\\n            }\\n            else {\\n                n = y;\\n                j++;\\n            }\\n            \\n            if(count == target / 2) {\\n                if(target % 2 != 0) {\\n                    return n;\\n                }\\n                else {\\n                    return (double)(prev + n) / 2;\\n                }\\n            }\\n            prev = n;\\n            count++;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1 == null && nums2 == null){\\n            return 0;\\n        }\\n        \\n        if(nums1 == null){\\n            int n = nums2.length;\\n            return nums2[(n - 1) / 2] * 0.5 + nums2[n / 2] * 0.5;\\n        }\\n        \\n        if(nums2 == null){\\n            int n = nums1.length;\\n            return nums1[(n - 1) / 2] * 0.5 + nums1[n / 2] * 0.5;\\n        }\\n        \\n        if(nums1.length > nums2.length){\\n            return findMedianSortedArrays(nums2, nums1);\\n        }\\n        \\n        // choose shorter to binary search\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int left = 0;\\n        int right = n;\\n        \\n        while(left < right){\\n            int i = (left + right) / 2;\\n            int j = (n + m) / 2 - i;\\n            \\n            if(nums1[i] < nums2[j - 1]){\\n                left = i + 1;\\n            }else{\\n                right = i;\\n            }\\n        }\\n        \\n        int first = left;\\n        int second = (n + m) / 2 - left;\\n        \\n        int shorterLeft = first == 0 ? Integer.MIN_VALUE : nums1[first - 1];\\n        int shorterRight = first == n ? Integer.MAX_VALUE : nums1[first];\\n        \\n        int longerLeft = second == 0 ? Integer.MIN_VALUE : nums2[second - 1];\\n        int longerRight = second == m ? Integer.MAX_VALUE : nums2[second];\\n        \\n        if((n + m) % 2 == 1) {\\n            return Math.min(shorterRight, longerRight);\\n        }else{\\n            return Math.max(shorterLeft, longerLeft) * 0.5 + Math.min(shorterRight, longerRight) * 0.5;\\n        }\\n \\n\\n        \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        n = len(nums1) + len(nums2)\\n        i1 = -1\\n        i2 = -1\\n        last = 0\\n        last_last = 0\\n        if n % 2 == 0:\\n            for i in range(int(n / 2) + 1):\\n                if i1 + 1 > len(nums1) - 1:\\n                    i2 += 1\\n                    last_last = last\\n                    last = nums2[i2]\\n                elif i2 + 1 > len(nums2) - 1:\\n                    i1 += 1\\n                    last_last = last\\n                    last = nums1[i1]\\n                else:\\n                    if nums1[i1 + 1] < nums2[i2 + 1]:\\n                        i1 += 1\\n                        last_last = last\\n                        last = nums1[i1]\\n                    else:\\n                        i2 += 1\\n                        last_last = last\\n                        last = nums2[i2]\\n            return (last + last_last) / 2\\n        else:\\n            for i in range(int(n / 2) + 1):\\n                if i1 + 1 > len(nums1) - 1:\\n                    i2 += 1\\n                    last = nums2[i2]\\n                elif i2 + 1 > len(nums2) - 1:\\n                    i1 += 1\\n                    last = nums1[i1]\\n                else:\\n                    if (nums1[i1 + 1] < nums2[i2 + 1]):\\n                        i1 += 1\\n                        last = nums1[i1]\\n                    else:\\n                        i2 += 1\\n                        last = nums2[i2]\\n\\n            return last\\n```\n```\\nclass Solution {\\n     fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {\\n        val n = nums1.size \\n        val m = nums2.size \\n        val ans = DoubleArray(n+m)\\n        var i = 0// track array 1\\n        var j = 0// track array 2\\n        var index = 0\\n        while(i < n && j< m){\\n            if(nums1[i] < nums2[j]){\\n                ans[index++] = nums1[i++].toDouble()\\n            } else {\\n                ans[index++] = nums2[j++].toDouble()\\n            }\\n        }\\n        \\n        while(i < n) ans[index++] = nums1[i++].toDouble()\\n        while(j < m) ans[index++] = nums2[j++].toDouble()\\n        val mid = (n+m)/2\\n        \\n        if ((n+m) %2 ==0){\\n            return (ans[mid] + ans[mid-1])/2.0\\n        }\\n        \\n        return ans[mid]\\n    }\\n}\\n```\n```\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    if(nums1.length > nums2.length) return findMedianSortedArrays(nums2, nums1)\\n    let x = nums1.length\\n    let y = nums2.length\\n    let low = 0, high = x\\n    while(low <= high) {\\n        const partitionX = (high + low) >> 1\\n        const partitionY = ((x + y + 1) >> 1) - partitionX\\n        \\n        const maxX = partitionX == 0 ? Number.NEGATIVE_INFINITY : nums1[partitionX - 1]\\n        const maxY = partitionY == 0 ? Number.NEGATIVE_INFINITY : nums2[partitionY - 1]\\n        \\n        const minX = partitionX == nums1.length ? Number.POSITIVE_INFINITY : nums1[partitionX]\\n        const minY = partitionY == nums2.length ? Number.POSITIVE_INFINITY : nums2[partitionY ]\\n        \\n        if(maxX <= minY && maxY <= minX) {\\n            const lowMax = Math.max(maxX, maxY)\\n            if( (x + y) % 2 == 1)\\n                return lowMax\\n            return (lowMax + Math.min(minX, minY)) / 2\\n        } else if(maxX < minY) {\\n            low = partitionX + 1\\n        } else \\n            high = partitionX - 1\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733644,
                "title": "easy-c-solution-time-complexity-o-log-min-n1-n2",
                "content": "**time complexity = O(log(min(n1, n2))) \\nspace complexity = O(1)**\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       if(nums2.size() < nums1.size())\\n       return findMedianSortedArrays(nums2, nums1);\\n       int n1 = nums1.size();\\n       int n2 = nums2.size();\\n       int lo = 0, hi = n1;\\n       while(lo<=hi)\\n       {\\n           int cut1 = (lo+hi) /2;\\n           int cut2 = (n1+n2+1)/2 - cut1;\\n           int left1 = cut1 == 0 ? INT_MIN : nums1[cut1-1];\\n           int left2 = cut2 == 0 ? INT_MIN : nums2[cut2-1];\\n\\n           int right1 = cut1 == n1 ? INT_MAX : nums1[cut1];\\n           int right2 = cut2 == n2 ? INT_MAX : nums2[cut2];\\n\\n           if(left1 <= right2 && left2 <= right1)\\n           {\\n               if((n1+n2)%2 == 0)\\n               return (max(left1, left2)+min(right1, right2))/2.0;\\n               else\\n               return max(left1, left2);\\n           }\\n           else if(left1 > right2)\\n           {\\n               hi = cut1 - 1;\\n           }\\n           else\\n           lo = cut1+1;\\n       }\\n       return 0.0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       if(nums2.size() < nums1.size())\\n       return findMedianSortedArrays(nums2, nums1);\\n       int n1 = nums1.size();\\n       int n2 = nums2.size();\\n       int lo = 0, hi = n1;\\n       while(lo<=hi)\\n       {\\n           int cut1 = (lo+hi) /2;\\n           int cut2 = (n1+n2+1)/2 - cut1;\\n           int left1 = cut1 == 0 ? INT_MIN : nums1[cut1-1];\\n           int left2 = cut2 == 0 ? INT_MIN : nums2[cut2-1];\\n\\n           int right1 = cut1 == n1 ? INT_MAX : nums1[cut1];\\n           int right2 = cut2 == n2 ? INT_MAX : nums2[cut2];\\n\\n           if(left1 <= right2 && left2 <= right1)\\n           {\\n               if((n1+n2)%2 == 0)\\n               return (max(left1, left2)+min(right1, right2))/2.0;\\n               else\\n               return max(left1, left2);\\n           }\\n           else if(left1 > right2)\\n           {\\n               hi = cut1 - 1;\\n           }\\n           else\\n           lo = cut1+1;\\n       }\\n       return 0.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642033,
                "title": "simple-binary-search-solution-o-log-m-n-log-max-min",
                "content": "In this problem we can binary search for the answer which will be in the range `minimum number` to `maximum number`\\n1. We can write a helper function `find_nth` to find `nth` element in the combined `nums1` + `nums2` sorted array.\\n2. If `n` is odd then we find for `n//2`th element else we find for `n//2`th, `n//2 - 1`th element and take their average.\\n\\n```\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        INF = 10**6\\n        self.min, self.max = -INF, INF\\n        \\n        # Standard Binary Search Template\\n        # Returns the nth element out of the two sorted arrays.\\n        def find_nth(nth):\\n            left, right = self.min, self.max\\n            \\n            while left < right:\\n                mid = left + right >> 1\\n                idx = bisect.bisect(nums1, mid) + bisect.bisect(nums2, mid)\\n                if idx <= nth:\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n                    \\n            return left\\n        \\n        # Calculating the Median\\n        n = len(nums1) + len(nums2)\\n        \\n        if n & 1:\\n            return 1.0 * find_nth(n//2)\\n        \\n        return (find_nth(n//2) + find_nth(n//2 - 1))/2.0\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        INF = 10**6\\n        self.min, self.max = -INF, INF\\n        \\n        # Standard Binary Search Template\\n        # Returns the nth element out of the two sorted arrays.\\n        def find_nth(nth):\\n            left, right = self.min, self.max\\n            \\n            while left < right:\\n                mid = left + right >> 1\\n                idx = bisect.bisect(nums1, mid) + bisect.bisect(nums2, mid)\\n                if idx <= nth:\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n                    \\n            return left\\n        \\n        # Calculating the Median\\n        n = len(nums1) + len(nums2)\\n        \\n        if n & 1:\\n            return 1.0 * find_nth(n//2)\\n        \\n        return (find_nth(n//2) + find_nth(n//2 - 1))/2.0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1566686,
                "title": "rust-clean-o-log-min-m-n-solution",
                "content": "### Algorithm Overview\\n Use a binary search to find the smallest component of the median.\\n Note: the smallest component is either in `a` or `b`. If the\\n binary search returns `Ok(...)` then the smallest component is in `a`,\\n `Err(...)` indicates it\\'s in `b`.\\n\\n Then if the total number of elements is odd, the smallest component is only the component\\n and is hence the median. This case corresponds to the first two cases of the match statement. \\n\\n When the total number of elements is even, the median is the average of the smallest component\\n and the next larger element. This case corresponds to the last two cases of the match statement.\\n\\n Note: The binary search considers a candidate partition of `a`,`x`, as `(a[0..=x],a[x+1..])`. If\\n `a[x]` is the smallest component of the median then we know how many elements of from `b`\\n must be <= and >= to `a[x]` in `b`. The partition of `b`, `y = s-x` corresponds to these elements.\\n All elements in `b[0..s-x]` are `<= b[s-x-1]`, similarly  All elements in `b[s-x..]` are `<= b[s-x]`.\\n Either: \\n - `a[x] < b[s-x-1] <=  b[s-x]`:  `a[x]` is too small, hence `x` too small.\\n - `b[s-x-1] <= b[s-x] < a[x]`:  `a[x]` is too large, hence `x` too large.\\n - `b[s-x-1] <= a[x] <= b[s-x]`:  `a[x]` is the smallest median component. \\n\\nWhen the binary search fails, `b[s-x]` ends being the smallest median component symmetrically,\\nand `a[x]` is the smallest value larger then `b[s-x]` in `a`.\\n\\n\\n### Asymptotic Complexity Analysis\\n`O(1)` before and after the `binary_search`,\\nThe `binary_search` starts with a range of the shortest array length.\\nEach step of the binary search is `O(1)`, hence overall: `O(log(min(m,n)))`\\n\\n### Code\\n\\n```rust\\npub fn find_median_sorted_arrays(mut a: Vec<i32>, mut b: Vec<i32>) -> f64 {\\n    if a.len() > b.len() {std::mem::swap(&mut a, &mut b);}\\n    let s = (a.len() + b.len() - 1)/2;\\n\\n    let partition = binary_search(0..a.len(), |x| {\\n        if b[s-x] < a[x] {Ordering::Greater}\\n        else if s-x > 0 && b[s-x-1] > a[x] {Ordering::Less}\\n        else {Ordering::Equal}\\n    });\\n\\n    match (partition, (a.len() + b.len())&0b1 == 1) {\\n        (Ok(x) , true) => a[x]   as f64,\\n        (Err(x), true) => b[s-x] as f64,\\n        (Ok(x) , false) => (a[x]   + unwrap_min(a.get(x+1), b.get(s-x))) as f64/2.0,\\n        (Err(x), false) => (b[s-x] + unwrap_min(a.get(x), b.get(s-x+1))) as f64/2.0,\\n    }\\n}\\n\\nuse std::ops::Range;\\nuse std::cmp::Ordering;\\nfn unwrap_min(a:Option<&i32>, b:Option<&i32>) -> i32 {\\n    match (a,b) {\\n        (Some(&a), Some(&b)) => a.min(b),\\n        (Some(x),None)|(None,Some(x)) => *x,\\n        (None,None) => panic!()\\n    }\\n}\\n\\nfn binary_search(Range{mut start, mut end}: Range<usize>, fnx: impl Fn(usize) -> Ordering) -> Result<usize,usize> {\\n    while end > start {\\n        let next = (start+end)/2;\\n        match fnx(next) {\\n            Ordering::Less => start = next+1,\\n            Ordering::Greater => end = next,\\n            Ordering::Equal => return Ok(next)\\n        }\\n    }\\n    return Err(end)\\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```rust\\npub fn find_median_sorted_arrays(mut a: Vec<i32>, mut b: Vec<i32>) -> f64 {\\n    if a.len() > b.len() {std::mem::swap(&mut a, &mut b);}\\n    let s = (a.len() + b.len() - 1)/2;\\n\\n    let partition = binary_search(0..a.len(), |x| {\\n        if b[s-x] < a[x] {Ordering::Greater}\\n        else if s-x > 0 && b[s-x-1] > a[x] {Ordering::Less}\\n        else {Ordering::Equal}\\n    });\\n\\n    match (partition, (a.len() + b.len())&0b1 == 1) {\\n        (Ok(x) , true) => a[x]   as f64,\\n        (Err(x), true) => b[s-x] as f64,\\n        (Ok(x) , false) => (a[x]   + unwrap_min(a.get(x+1), b.get(s-x))) as f64/2.0,\\n        (Err(x), false) => (b[s-x] + unwrap_min(a.get(x), b.get(s-x+1))) as f64/2.0,\\n    }\\n}\\n\\nuse std::ops::Range;\\nuse std::cmp::Ordering;\\nfn unwrap_min(a:Option<&i32>, b:Option<&i32>) -> i32 {\\n    match (a,b) {\\n        (Some(&a), Some(&b)) => a.min(b),\\n        (Some(x),None)|(None,Some(x)) => *x,\\n        (None,None) => panic!()\\n    }\\n}\\n\\nfn binary_search(Range{mut start, mut end}: Range<usize>, fnx: impl Fn(usize) -> Ordering) -> Result<usize,usize> {\\n    while end > start {\\n        let next = (start+end)/2;\\n        match fnx(next) {\\n            Ordering::Less => start = next+1,\\n            Ordering::Greater => end = next,\\n            Ordering::Equal => return Ok(next)\\n        }\\n    }\\n    return Err(end)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1520704,
                "title": "java-easy-to-follow-o-log-min-m-n",
                "content": "```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] a, int[] b) {\\n        \\n        //Swap if a size is > b size\\n        if(a.length > b.length){\\n            return findMedianSortedArrays(b,a);\\n        }\\n        \\n        int alength = a.length;\\n        int blength = b.length;\\n        int total =  (a.length + b.length);\\n        \\n        int high = alength;\\n        int low = 0;\\n        \\n        while(low <= high){\\n            //amid and bmid are partition points. \\n            //elements on both sides will be \\n            //a[amid - 1 ] | a[amid]\\n            //b[bmid - 1 ] | b[bmid]\\n            int amid = low + (high-low)/2;\\n            int bmid = (total+1)/2 - amid;\\n            \\n            //Checking boundary conditions\\n            int a1 = (amid == 0) ? Integer.MIN_VALUE : a[amid -1];\\n            int b1 = (bmid == 0) ? Integer.MIN_VALUE : b[bmid -1];\\n            \\n            int a2 = (amid == alength) ? Integer.MAX_VALUE : a[amid];\\n            int b2 = (bmid == blength) ? Integer.MAX_VALUE : b[bmid];\\n            \\n            if(a1 <= b2 && a2 >= b1){\\n\\n                double median  = 0.0;\\n                int lMax = Math.max(a1,b1);\\n                int rMin = Math.min(a2,b2);\\n                \\n                if(total%2 == 0){\\n                   median = (lMax + rMin)/2.0 ;\\n                }\\n                else{\\n                    median = lMax;\\n                }\\n                return median;\\n            }\\n            else if(a2 < b1){\\n                low = amid +1;\\n            }\\n            else{\\n                high = amid -1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] a, int[] b) {\\n        \\n        //Swap if a size is > b size\\n        if(a.length > b.length){\\n            return findMedianSortedArrays(b,a);\\n        }\\n        \\n        int alength = a.length;\\n        int blength = b.length;\\n        int total =  (a.length + b.length);\\n        \\n        int high = alength;\\n        int low = 0;\\n        \\n        while(low <= high){\\n            //amid and bmid are partition points. \\n            //elements on both sides will be \\n            //a[amid - 1 ] | a[amid]\\n            //b[bmid - 1 ] | b[bmid]\\n            int amid = low + (high-low)/2;\\n            int bmid = (total+1)/2 - amid;\\n            \\n            //Checking boundary conditions\\n            int a1 = (amid == 0) ? Integer.MIN_VALUE : a[amid -1];\\n            int b1 = (bmid == 0) ? Integer.MIN_VALUE : b[bmid -1];\\n            \\n            int a2 = (amid == alength) ? Integer.MAX_VALUE : a[amid];\\n            int b2 = (bmid == blength) ? Integer.MAX_VALUE : b[bmid];\\n            \\n            if(a1 <= b2 && a2 >= b1){\\n\\n                double median  = 0.0;\\n                int lMax = Math.max(a1,b1);\\n                int rMin = Math.min(a2,b2);\\n                \\n                if(total%2 == 0){\\n                   median = (lMax + rMin)/2.0 ;\\n                }\\n                else{\\n                    median = lMax;\\n                }\\n                return median;\\n            }\\n            else if(a2 < b1){\\n                low = amid +1;\\n            }\\n            else{\\n                high = amid -1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425005,
                "title": "c-solution",
                "content": "Runtime: 12 ms, faster than 82.51% of C online submissions for Median of Two Sorted Arrays.\\nMemory Usage: 6.5 MB, less than 74.75% of C online submissions for Median of Two Sorted Arrays.\\n\\n\\n```\\n\\n\\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\nint n=nums1Size+nums2Size;\\n    float f;\\n    float nums3[n];\\n    int i,j,k,a;\\n    i=j=k=0;\\n    while(i<nums1Size && j<nums2Size){\\n        if(nums1[i]<nums2[j])\\n            nums3[k++]=nums1[i++];\\n        else\\n            nums3[k++]=nums2[j++];\\n    }\\n    for(;i<nums1Size;i++)\\n         nums3[k++]=nums1[i];\\n    for(;j<nums2Size;j++)\\n         nums3[k++]=nums2[j];\\n    \\n    if(n%2==0){\\n        a=n/2;\\n        f=(nums3[a]+nums3[a-1])/2;\\n        \\n        return f;\\n    }\\n    else{\\n        f=nums3[n/2];\\n         return f;\\n    }\\n    \\n    return -1;\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\nint n=nums1Size+nums2Size;\\n    float f;\\n    float nums3[n];\\n    int i,j,k,a;\\n    i=j=k=0;\\n    while(i<nums1Size && j<nums2Size){\\n        if(nums1[i]<nums2[j])\\n            nums3[k++]=nums1[i++];\\n        else\\n            nums3[k++]=nums2[j++];\\n    }\\n    for(;i<nums1Size;i++)\\n         nums3[k++]=nums1[i];\\n    for(;j<nums2Size;j++)\\n         nums3[k++]=nums2[j];\\n    \\n    if(n%2==0){\\n        a=n/2;\\n        f=(nums3[a]+nums3[a-1])/2;\\n        \\n        return f;\\n    }\\n    else{\\n        f=nums3[n/2];\\n         return f;\\n    }\\n    \\n    return -1;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1100698,
                "title": "python3-binary-search-from-tushar-roy-s-solution-video",
                "content": "```python\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        if len(nums1) > len(nums2):\\n            return self.findMedianSortedArrays(nums2, nums1)\\n\\n        l1, l2 = len(nums1), len(nums2)\\n        left, right = 0, l1\\n        while left <= right:\\n            position_x = (left + right) // 2\\n            position_y = (l1 + l2 + 1) // 2 - position_x\\n\\n            max_left_x = nums1[position_x - 1] if position_x != 0 else float(\\'-inf\\')\\n            max_left_y = nums2[position_y - 1] if position_y != 0 else float(\\'-inf\\')\\n\\n            min_right_x = nums1[position_x] if position_x < l1 else float(\\'inf\\')\\n            min_right_y = nums2[position_y] if position_y < l2 else float(\\'inf\\')\\n\\n            if (max_left_x <= min_right_y and max_left_y <= min_right_x):\\n                # we found the partition\\n                if (l1 + l2) % 2 == 0:\\n                    return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2\\n                else:\\n                    return max(max_left_x, max_left_y)\\n\\n            elif max_left_x > min_right_y:\\n                # we should move left\\n                right = position_x - 1\\n\\n            else:\\n                left = position_x + 1\\n\\n        return 0\\n```\\n\\nrelated video: https://www.youtube.com/watch?v=LPFhl65R7ww&ab_channel=TusharRoy-CodingMadeSimple\\n\\n\\n***\\n\\nI also wrote a quick select solution, the time complexity is `O(m+n)`. (it passed the judge, **just for practice...**\\n\\n```python\\nclass Solution_QuickSelect:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n\\n        nums = nums1[:] + nums2[:]\\n        length = len(nums)\\n        if length % 2 == 0:\\n            return (self._quick_select(nums, 0, length - 1, length // 2 + 1) + self._quick_select(nums, 0, length - 1, (length - 1) // 2 + 1)) / 2\\n        else:\\n            return self._quick_select(nums, 0, length - 1, length // 2 + 1)\\n\\n    def _quick_select(self, nums, start, end, k):\\n        left, right = start, end\\n        pivot = nums[(left + right) // 2]\\n\\n        while left <= right:\\n            while left <= right and nums[left] > pivot:\\n                left += 1\\n            while left <= right and nums[right] < pivot:\\n                right -= 1\\n            if left <= right:\\n                nums[left], nums[right] = nums[right], nums[left]\\n                left += 1\\n                right -= 1\\n\\n        if start + k - 1 <= right:\\n            return self._quick_select(nums, start, right, k)\\n        if start + k - 1 >= left:\\n            return self._quick_select(nums, left, end, k - (left - start))\\n\\n        return nums[right + 1]\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree",
                    "Quickselect"
                ],
                "code": "```python\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        if len(nums1) > len(nums2):\\n            return self.findMedianSortedArrays(nums2, nums1)\\n\\n        l1, l2 = len(nums1), len(nums2)\\n        left, right = 0, l1\\n        while left <= right:\\n            position_x = (left + right) // 2\\n            position_y = (l1 + l2 + 1) // 2 - position_x\\n\\n            max_left_x = nums1[position_x - 1] if position_x != 0 else float(\\'-inf\\')\\n            max_left_y = nums2[position_y - 1] if position_y != 0 else float(\\'-inf\\')\\n\\n            min_right_x = nums1[position_x] if position_x < l1 else float(\\'inf\\')\\n            min_right_y = nums2[position_y] if position_y < l2 else float(\\'inf\\')\\n\\n            if (max_left_x <= min_right_y and max_left_y <= min_right_x):\\n                # we found the partition\\n                if (l1 + l2) % 2 == 0:\\n                    return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2\\n                else:\\n                    return max(max_left_x, max_left_y)\\n\\n            elif max_left_x > min_right_y:\\n                # we should move left\\n                right = position_x - 1\\n\\n            else:\\n                left = position_x + 1\\n\\n        return 0\\n```\n```python\\nclass Solution_QuickSelect:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n\\n        nums = nums1[:] + nums2[:]\\n        length = len(nums)\\n        if length % 2 == 0:\\n            return (self._quick_select(nums, 0, length - 1, length // 2 + 1) + self._quick_select(nums, 0, length - 1, (length - 1) // 2 + 1)) / 2\\n        else:\\n            return self._quick_select(nums, 0, length - 1, length // 2 + 1)\\n\\n    def _quick_select(self, nums, start, end, k):\\n        left, right = start, end\\n        pivot = nums[(left + right) // 2]\\n\\n        while left <= right:\\n            while left <= right and nums[left] > pivot:\\n                left += 1\\n            while left <= right and nums[right] < pivot:\\n                right -= 1\\n            if left <= right:\\n                nums[left], nums[right] = nums[right], nums[left]\\n                left += 1\\n                right -= 1\\n\\n        if start + k - 1 <= right:\\n            return self._quick_select(nums, start, right, k)\\n        if start + k - 1 >= left:\\n            return self._quick_select(nums, left, end, k - (left - start))\\n\\n        return nums[right + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950857,
                "title": "youtube-tushar-roy-python-solution",
                "content": "This idea is coming from Tushar Roy\\'s Youtube video explanation. Time complexity is O(log(min(m,n))). I implement the idea using Python. People who are interested in the algorithm can refer to this youtube link https://www.youtube.com/watch?v=LPFhl65R7ww&t=1013s\\n```\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n         \\n        if len(nums1) < len(nums2):\\n            input1 = nums1\\n            input2 = nums2\\n        else:\\n            input1 = nums2\\n            input2 = nums1\\n            \\n        n1 = len(input1)\\n        n2 = len(input2)\\n        low = 0\\n        \\n        # !!! need to set as n1, because this means number of elements on the left side or right side, not the index\\n        high = n1\\n        \\n        while low<=high:\\n            partition_x = (low+high)//2\\n            partition_y = (n1+n2+1)//2-partition_x\\n            \\n            maxLeft_x = input1[partition_x-1] if partition_x!=0 else float(\\'-inf\\')\\n            minRight_x = input1[partition_x] if partition_x!=n1 else float(\\'inf\\')\\n            \\n            maxLeft_y = input2[partition_y-1] if partition_y!=0 else float(\\'-inf\\')\\n            minRight_y = input2[partition_y] if partition_y!=n2 else float(\\'inf\\')\\n            \\n            if maxLeft_x <= minRight_y and maxLeft_y <= minRight_x:\\n                if (n1+n2)%2==0:\\n                    return (max(maxLeft_x,maxLeft_y)+min(minRight_x,minRight_y))/2\\n                else:\\n                    return max(maxLeft_x,maxLeft_y)\\n            elif maxLeft_x > minRight_y:\\n                high = partition_x-1\\n            else:\\n                low = partition_x+1\\n```",
                "solutionTags": [],
                "code": "```\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n         \\n        if len(nums1) < len(nums2):\\n            input1 = nums1\\n            input2 = nums2\\n        else:\\n            input1 = nums2\\n            input2 = nums1\\n            \\n        n1 = len(input1)\\n        n2 = len(input2)\\n        low = 0\\n        \\n        # !!! need to set as n1, because this means number of elements on the left side or right side, not the index\\n        high = n1\\n        \\n        while low<=high:\\n            partition_x = (low+high)//2\\n            partition_y = (n1+n2+1)//2-partition_x\\n            \\n            maxLeft_x = input1[partition_x-1] if partition_x!=0 else float(\\'-inf\\')\\n            minRight_x = input1[partition_x] if partition_x!=n1 else float(\\'inf\\')\\n            \\n            maxLeft_y = input2[partition_y-1] if partition_y!=0 else float(\\'-inf\\')\\n            minRight_y = input2[partition_y] if partition_y!=n2 else float(\\'inf\\')\\n            \\n            if maxLeft_x <= minRight_y and maxLeft_y <= minRight_x:\\n                if (n1+n2)%2==0:\\n                    return (max(maxLeft_x,maxLeft_y)+min(minRight_x,minRight_y))/2\\n                else:\\n                    return max(maxLeft_x,maxLeft_y)\\n            elif maxLeft_x > minRight_y:\\n                high = partition_x-1\\n            else:\\n                low = partition_x+1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 807121,
                "title": "o-log-m-n-by-kth-smallest-element-with-understanding-to-avoid-infinite-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int a = nums1.size(), \\n            b = nums2.size();\\n        int n = a + b;\\n        if (n % 2 == 1) {\\n            return (double)kthElement(nums1, nums2, 0, a - 1, 0, b - 1, n / 2);\\n        }\\n        double sum = kthElement(nums1, nums2, 0, a - 1, 0, b - 1, n / 2) + \\n            kthElement(nums1, nums2, 0, a - 1, 0, b - 1, n / 2 - 1);\\n        return sum / 2;\\n    }\\n    \\n    // kth index element in new array.\\n    int kthElement(vector<int>& nums1, vector<int>& nums2, int l1, int h1, int l2, int h2, int k) {\\n        if (l1 > h1) {\\n            return nums2[l2 + k];\\n        }\\n        \\n        if (l2 > h2) {\\n            return nums1[l1 + k];\\n        }\\n        \\n        // we have to divide in such a manner that in every iteration, we are reducing the size of array for us to leave with only one array in end\\n        // we divide such that mid elements are on brink of being kth element, i.e. in cases when first k elements lie in first half of both arrays,\\n        // the kth element could either be m1 or m2, giving us a chance to eliminate one of them, hence reducing the size\\n        int m1 = (l1 + h1) / 2,\\n            m2 = (l2 + h2) / 2,\\n            leftLen1 = m1 - l1,\\n            leftLen2 = m2 - l2;\\n        \\n        // Case 1 : kth index occurs in second half. So we can reduce the first half of nums1 or nums2. We discard the smaller half\\n        // Note here that while reducing we remove the mid element as well. While counting we didn\\'t include mid elements in leftLen.\\n        // when we say k > leftlen, that means, we can discard all elements to left (only by numbers - k- 1 elements) + 1 of the mid elements\\n        // while still having kth element in new boundaries. \\n        // Although, we don\\'t know if kth element lies in smaller second half or first half, hence we just remove smaller first half.\\n        if (leftLen1 + leftLen2 < k) {\\n            if (nums1[m1] < nums2[m2]) {\\n                return kthElement(nums1, nums2, m1 + 1, h1, l2, h2, k - leftLen1 - 1);\\n            }\\n            \\n            return kthElement(nums1, nums2, l1, h1, m2 + 1, h2, k - leftLen2 - 1);\\n        }\\n        \\n        // Case 2: kth element is present in first half.\\n        // kth element can not be greater than m1 or m2, which means we can discard one of it.\\n        // discard greater second half\\n        if (nums1[m1] < nums2[m2]) {\\n            return kthElement(nums1, nums2, l1, h1, l2, m2 - 1, k);\\n        }\\n\\n        return kthElement(nums1, nums2, l1, m1 - 1, l2, h2, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int a = nums1.size(), \\n            b = nums2.size();\\n        int n = a + b;\\n        if (n % 2 == 1) {\\n            return (double)kthElement(nums1, nums2, 0, a - 1, 0, b - 1, n / 2);\\n        }\\n        double sum = kthElement(nums1, nums2, 0, a - 1, 0, b - 1, n / 2) + \\n            kthElement(nums1, nums2, 0, a - 1, 0, b - 1, n / 2 - 1);\\n        return sum / 2;\\n    }\\n    \\n    // kth index element in new array.\\n    int kthElement(vector<int>& nums1, vector<int>& nums2, int l1, int h1, int l2, int h2, int k) {\\n        if (l1 > h1) {\\n            return nums2[l2 + k];\\n        }\\n        \\n        if (l2 > h2) {\\n            return nums1[l1 + k];\\n        }\\n        \\n        // we have to divide in such a manner that in every iteration, we are reducing the size of array for us to leave with only one array in end\\n        // we divide such that mid elements are on brink of being kth element, i.e. in cases when first k elements lie in first half of both arrays,\\n        // the kth element could either be m1 or m2, giving us a chance to eliminate one of them, hence reducing the size\\n        int m1 = (l1 + h1) / 2,\\n            m2 = (l2 + h2) / 2,\\n            leftLen1 = m1 - l1,\\n            leftLen2 = m2 - l2;\\n        \\n        // Case 1 : kth index occurs in second half. So we can reduce the first half of nums1 or nums2. We discard the smaller half\\n        // Note here that while reducing we remove the mid element as well. While counting we didn\\'t include mid elements in leftLen.\\n        // when we say k > leftlen, that means, we can discard all elements to left (only by numbers - k- 1 elements) + 1 of the mid elements\\n        // while still having kth element in new boundaries. \\n        // Although, we don\\'t know if kth element lies in smaller second half or first half, hence we just remove smaller first half.\\n        if (leftLen1 + leftLen2 < k) {\\n            if (nums1[m1] < nums2[m2]) {\\n                return kthElement(nums1, nums2, m1 + 1, h1, l2, h2, k - leftLen1 - 1);\\n            }\\n            \\n            return kthElement(nums1, nums2, l1, h1, m2 + 1, h2, k - leftLen2 - 1);\\n        }\\n        \\n        // Case 2: kth element is present in first half.\\n        // kth element can not be greater than m1 or m2, which means we can discard one of it.\\n        // discard greater second half\\n        if (nums1[m1] < nums2[m2]) {\\n            return kthElement(nums1, nums2, l1, h1, l2, m2 - 1, k);\\n        }\\n\\n        return kthElement(nums1, nums2, l1, m1 - 1, l2, h2, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 682506,
                "title": "c-median-of-two-sorted-arrays",
                "content": "/*\\nThere are two sorted arrays nums1 and nums2 of size m and n respectively.\\n\\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\\n\\nYou may assume nums1 and nums2 cannot be both empty.\\n\\nExample 1:\\n\\nnums1 = [1, 3]\\nnums2 = [2]\\n\\nThe median is 2.0\\nExample 2:\\n\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\n\\nThe median is (2 + 3)/2 = 2.5\\n*/\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int> all (nums1.size()+nums2.size());\\n        int k = 0;\\n        int i = 0;\\n        int j = 0;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        while(k < (m + n))\\n        {\\n            if (i < n && j < m)\\n            {\\n                if (nums1[i] < nums2[j])\\n                {\\n                    all[k] = nums1[i];\\n                    i++;                  \\n                }\\n                else\\n                {\\n                    all[k] = nums2[j];\\n                    j++;\\n                }\\n            }\\n            else if (i < n)\\n            {\\n                all[k] = nums1[i];\\n                i++;\\n            }\\n            else if ( j < m)\\n            {\\n                all[k] = nums2[j];\\n                j++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n            k++;\\n        }\\n        int median_index = (m + n) / 2;\\n        if ((m + n) %2 == 0)\\n        {\\n            return (all[median_index - 1] + all[median_index]) / 2.0;\\n        }\\n        else\\n        {\\n            return all[median_index];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int> all (nums1.size()+nums2.size());\\n        int k = 0;\\n        int i = 0;\\n        int j = 0;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        while(k < (m + n))\\n        {\\n            if (i < n && j < m)\\n            {\\n                if (nums1[i] < nums2[j])\\n                {\\n                    all[k] = nums1[i];\\n                    i++;                  \\n                }\\n                else\\n                {\\n                    all[k] = nums2[j];\\n                    j++;\\n                }\\n            }\\n            else if (i < n)\\n            {\\n                all[k] = nums1[i];\\n                i++;\\n            }\\n            else if ( j < m)\\n            {\\n                all[k] = nums2[j];\\n                j++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n            k++;\\n        }\\n        int median_index = (m + n) / 2;\\n        if ((m + n) %2 == 0)\\n        {\\n            return (all[median_index - 1] + all[median_index]) / 2.0;\\n        }\\n        else\\n        {\\n            return all[median_index];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351909,
                "title": "cleanest-python-solution-i-could-imagine",
                "content": "```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, A, B):\\n        num = len(A) + len(B)\\n        if num % 2 == 0:\\n            return (self.findKth(A, B, num//2 + 1) + \\n                    self.findKth(A, B, num//2)) / 2.\\n        else:\\n            return self.findKth(A, B, num//2 + 1)\\n            \\n    def findKth(self, A, B, K):\\n        if not A:\\n            return B[K - 1]\\n        if not B:\\n            return A[K - 1]\\n        if K == 1:\\n            return min(A[0], B[0])\\n        step = min(K//2, min(len(A), len(B)))\\n        if A[step - 1]  < B[step - 1]:\\n            return self.findKth(A[step:], B, K - step)\\n        else:\\n            return self.findKth(A, B[step:], K - step)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, A, B):\\n        num = len(A) + len(B)\\n        if num % 2 == 0:\\n            return (self.findKth(A, B, num//2 + 1) + \\n                    self.findKth(A, B, num//2)) / 2.\\n        else:\\n            return self.findKth(A, B, num//2 + 1)\\n            \\n    def findKth(self, A, B, K):\\n        if not A:\\n            return B[K - 1]\\n        if not B:\\n            return A[K - 1]\\n        if K == 1:\\n            return min(A[0], B[0])\\n        step = min(K//2, min(len(A), len(B)))\\n        if A[step - 1]  < B[step - 1]:\\n            return self.findKth(A[step:], B, K - step)\\n        else:\\n            return self.findKth(A, B[step:], K - step)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346167,
                "title": "java-solution-with-explanation",
                "content": "**Idea**\\nWithout doing merge sort on two arrays, we should still be able to reason out what could be the middle elements to find the median.\\nThe way we find the median is we split the sorted array into `\"two equal halves\"` and pick the middle element where `\"left half\" <= \"right half\"`. \\nIn this case, since individual arrays are sorted, we will try splitting the arrays at various points in order to reach the above condition without actually sorting all elements.\\nSplitting `nums1` forces us to split `nums2` at a specific position as we need to balance the # of elements in two halves.\\nHow many split positions are possible on `nums1`? none on left side, 1 on left side,...,all on left side. That is `nums1.length` splits.\\nAt each of the above split position, we will see if `\"left half\" <= \"right half\"`, what does it mean? `max from left <= min from right` in the overall \"imaginary sorted array\".\\n\\n\\n**Credit**: https://www.youtube.com/watch?v=LPFhl65R7ww\\n\\n\\n\\n```\\npublic double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums2.length < nums1.length)\\n            return findMedianSortedArrays(nums2, nums1);\\n        return helper(nums1, 0, nums1.length, nums2);\\n    }\\n    private double helper(int[] nums1, int l, int h, int[] nums2){\\n        while(l <= h){\\n            int m1 = l+(h-l)/2;                                                     //# of elements on left in nums1\\n            int m2 = (nums2.length+nums1.length+1)/2-m1;                            //# of elements on left in nums2\\n            if(m1 > 0 && m2 < nums2.length && nums1[m1-1] > nums2[m2])              //m1 needs to reduced\\n                h = m1-1;\\n            else if(m2 > 0 && m1 < nums1.length && nums2[m2-1] > nums1[m1])\\n                l = m1+1;\\n            else{\\n                int total = nums1.length+nums2.length;\\n                int maxLeft = -Integer.MAX_VALUE;\\n                if(m1 > 0)\\n                    maxLeft = Math.max(maxLeft, nums1[m1-1]);\\n                if(m2 > 0)\\n                    maxLeft = Math.max(maxLeft, nums2[m2-1]);\\n                if(total % 2 != 0)\\n                    return maxLeft;\\n                int minRight = Integer.MAX_VALUE;\\n                if(m1 < nums1.length)\\n                    minRight = Math.min(minRight, nums1[m1]);\\n                if(m2 < nums2.length)\\n                    minRight = Math.min(minRight, nums2[m2]);\\n                return (maxLeft+minRight)/2.0;\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums2.length < nums1.length)\\n            return findMedianSortedArrays(nums2, nums1);\\n        return helper(nums1, 0, nums1.length, nums2);\\n    }\\n    private double helper(int[] nums1, int l, int h, int[] nums2){\\n        while(l <= h){\\n            int m1 = l+(h-l)/2;                                                     //# of elements on left in nums1\\n            int m2 = (nums2.length+nums1.length+1)/2-m1;                            //# of elements on left in nums2\\n            if(m1 > 0 && m2 < nums2.length && nums1[m1-1] > nums2[m2])              //m1 needs to reduced\\n                h = m1-1;\\n            else if(m2 > 0 && m1 < nums1.length && nums2[m2-1] > nums1[m1])\\n                l = m1+1;\\n            else{\\n                int total = nums1.length+nums2.length;\\n                int maxLeft = -Integer.MAX_VALUE;\\n                if(m1 > 0)\\n                    maxLeft = Math.max(maxLeft, nums1[m1-1]);\\n                if(m2 > 0)\\n                    maxLeft = Math.max(maxLeft, nums2[m2-1]);\\n                if(total % 2 != 0)\\n                    return maxLeft;\\n                int minRight = Integer.MAX_VALUE;\\n                if(m1 < nums1.length)\\n                    minRight = Math.min(minRight, nums1[m1]);\\n                if(m2 < nums2.length)\\n                    minRight = Math.min(minRight, nums2[m2]);\\n                return (maxLeft+minRight)/2.0;\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 335995,
                "title": "rust-0ms-4ms-impl-iterator-o-n",
                "content": "![image](https://assets.leetcode.com/users/obliquemotion/image_1563646755.png)\\n\\n\\n```rust\\nstruct SortedVecsIter {\\n    vec1: Vec<i32>,\\n    vec2: Vec<i32>,\\n}\\n\\nimpl SortedVecsIter {\\n    fn len(&self) -> usize {\\n        self.vec1.len() + self.vec2.len()\\n    }\\n}\\n\\nimpl Iterator for SortedVecsIter {\\n    type Item = i32;\\n    fn next(&mut self) -> Option<i32> {\\n        match (self.vec1.last(), self.vec2.last()) {\\n            (Some(n1), Some(n2)) if n1 >= n2 => self.vec1.pop(),\\n            (Some(_), Some(_))               => self.vec2.pop(),\\n            (Some(_), _)                     => self.vec1.pop(),\\n            (_, Some(_))                     => self.vec2.pop(),\\n            _                                => None,\\n        }\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\\n        let mut vecs_iter = SortedVecsIter {\\n            vec1: nums1,\\n            vec2: nums2,\\n        };\\n        let length = vecs_iter.len();\\n        let middle = length / 2;\\n        if 0 == length % 2 {\\n            let mut halves = vecs_iter.skip(middle - 1);\\n            (halves.next().unwrap() as f64 + halves.next().unwrap() as f64) / 2.0\\n        } else {\\n            vecs_iter.nth(middle).unwrap() as f64\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nstruct SortedVecsIter {\\n    vec1: Vec<i32>,\\n    vec2: Vec<i32>,\\n}\\n\\nimpl SortedVecsIter {\\n    fn len(&self) -> usize {\\n        self.vec1.len() + self.vec2.len()\\n    }\\n}\\n\\nimpl Iterator for SortedVecsIter {\\n    type Item = i32;\\n    fn next(&mut self) -> Option<i32> {\\n        match (self.vec1.last(), self.vec2.last()) {\\n            (Some(n1), Some(n2)) if n1 >= n2 => self.vec1.pop(),\\n            (Some(_), Some(_))               => self.vec2.pop(),\\n            (Some(_), _)                     => self.vec1.pop(),\\n            (_, Some(_))                     => self.vec2.pop(),\\n            _                                => None,\\n        }\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\\n        let mut vecs_iter = SortedVecsIter {\\n            vec1: nums1,\\n            vec2: nums2,\\n        };\\n        let length = vecs_iter.len();\\n        let middle = length / 2;\\n        if 0 == length % 2 {\\n            let mut halves = vecs_iter.skip(middle - 1);\\n            (halves.next().unwrap() as f64 + halves.next().unwrap() as f64) / 2.0\\n        } else {\\n            vecs_iter.nth(middle).unwrap() as f64\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 143046,
                "title": "different-solutions-explained-in-depth-easy-o-log-n-m-with-getkth",
                "content": "Full version of this explanation, with diagrams at: https://fizzbuzzed.com/top-interview-questions-2/\\n\\n## O(n+m) and O((n+m)log(n+m)) Solutions \\nConcatenating the two lists, sorting, and grabbing the middle item passes the leetcode online judge, but it is not O((n+m)log(n+m)) and would never be accepted in an interview (it doesn\\'t even use the sorted structure of the list). Using a merge (as in mergesort) is better (O(n+m)) but still isn\\'t what we want.\\n\\n## Finding a O(log(n+ m)) solution \\nTo find a O(log(n+ m)) solution, we start with the same structure as our linear solution:\\n\\n```\\ndef findMedianSortedArrays(nums1, nums2):\\n    total_nums = len(nums1) + len(nums2)\\n    midpoint = total_nums // 2 + 1\\n\\n    if total_nums % 2 == 0:\\n        return (getKth(nums1, nums2, total_nums // 2 - 1) + \\n                getKth(nums1, nums2, total_nums // 2)) / 2\\n    else:\\n        return getKth(nums1, 0, nums2, 0, total_nums // 2) \\n```\\n\\nNow, if we can create a getKth method that runs in O(log n) we have our solution.\\n\\nIntuition says this should be possible since we can find if an element in an array in O(log n) (using binary search).\\n\\nFollowing binary search (or really just a general divide and conquer approach), let\\'s try to get an initial range, and then cut it in half repeatedly:\\n\\nWe know no numbers in nums1, or nums2 that are past index k can be the kth item in nums1 + nums2 (the sorted concatenation of nums1 and nums2).\\n\\nSo let\\'s start with: nums1 [0..k] and nums2 [0..k] as our initial range.\\n\\nLet\\'s assume the general case (where nums1 and nums2 both have more than k elements), and let the k/2nd item in nums1 be \\'a\\' and the k/2nd item in nums2 be \\'b\\'.\\n\\nAssume a < b (without loss of generality). We\\'ll prove that some numbers are too small to be the kth:\\n\\nand then let\\'s imagine what the sorted merged array. We know it would look like:\\n\\n--------- a ----- b ---------\\n\\nLet\\'s label the initial arrays:\\n\\nnums1: ---section1---a---section2---\\nnums2: ---section3---b---section4---\\n\\nWe know:\\n1) Any item in section 1 < a < b\\n2) Any item in section 3 < b (and possibly but not necessarily < a)\\n\\nConsider the situation where a is as big as possible (then any item in section 3 < b):\\n\\n----section1 and section3 --- a b ---section 2 and 4\\n\\nSection 3 has k/2 - 1 elements and Section 1 has k/2 - 1 elements, so a is at most the k - 1st element. (Since k/2 - 1 + k/2 - 1 + 1 = k - 1).\\n\\nSo, no matter what, a, and all elements in section1, cannot possibly be the k-th element. \\n\\nThere are a few things to be careful about:\\n\\nWhen we have an odd number of elements, we need to make sure we don\\u2019t look at the wrong element (if we have seven elements, make sure we look at the 3rd not the 4th (indexing from 1)).\\nWe need to handle the case where one array is shorter than k/2.\\n\\nThe code (// means integer divide in python3):\\n```\\ndef findMedianSortedArrays(nums1, nums2):\\n    # We consider nums1[i], nums2[j] to be the first element in nums1 and nums2 respectively.\\n    def getKth(i, j, k):\\n        if i == len(nums1):\\n            return nums2[j + k]\\n        elif j == len(nums2):\\n            return nums1[i + k]\\n        elif k == 0:\\n            return min(nums1[i], nums2[j])\\n        mid1 = min(len(nums1) - i, (k + 1) // 2)\\n        mid2 = min(len(nums2) - j, (k + 1) // 2)\\n        a = nums1[i + mid1 - 1]\\n        b = nums2[j + mid2 - 1]\\n        if a < b:\\n            return getKth(i + mid1, j, k - mid1)\\n        return getKth(i, j + mid2, k - mid2)\\n\\n    total_nums = len(nums1) + len(nums2)\\n    midpoint = total_nums // 2 + 1\\n    if total_nums % 2 == 0:\\n        first = getKth(0, 0, total_nums // 2 - 1)\\n        second = getKth(0, 0, total_nums // 2)\\n        return (first + second) / 2\\n    else:\\n        return getKth(0, 0, total_nums // 2)  \\n```",
                "solutionTags": [],
                "code": "```\\ndef findMedianSortedArrays(nums1, nums2):\\n    total_nums = len(nums1) + len(nums2)\\n    midpoint = total_nums // 2 + 1\\n\\n    if total_nums % 2 == 0:\\n        return (getKth(nums1, nums2, total_nums // 2 - 1) + \\n                getKth(nums1, nums2, total_nums // 2)) / 2\\n    else:\\n        return getKth(nums1, 0, nums2, 0, total_nums // 2) \\n```\n```\\ndef findMedianSortedArrays(nums1, nums2):\\n    # We consider nums1[i], nums2[j] to be the first element in nums1 and nums2 respectively.\\n    def getKth(i, j, k):\\n        if i == len(nums1):\\n            return nums2[j + k]\\n        elif j == len(nums2):\\n            return nums1[i + k]\\n        elif k == 0:\\n            return min(nums1[i], nums2[j])\\n        mid1 = min(len(nums1) - i, (k + 1) // 2)\\n        mid2 = min(len(nums2) - j, (k + 1) // 2)\\n        a = nums1[i + mid1 - 1]\\n        b = nums2[j + mid2 - 1]\\n        if a < b:\\n            return getKth(i + mid1, j, k - mid1)\\n        return getKth(i, j + mid2, k - mid2)\\n\\n    total_nums = len(nums1) + len(nums2)\\n    midpoint = total_nums // 2 + 1\\n    if total_nums % 2 == 0:\\n        first = getKth(0, 0, total_nums // 2 - 1)\\n        second = getKth(0, 0, total_nums // 2)\\n        return (first + second) / 2\\n    else:\\n        return getKth(0, 0, total_nums // 2)  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2637,
                "title": "20-line-o-log-k-solution-with-clear-explanation-illustration",
                "content": "The idea is to reduce the problem into the problem of finding the kth element in two sorted arrays. If the total size of the array was even, then we know that the result would be the average of the middle two numbers (where k = totalLength/2, k & k + 1). If it was odd, then it would just be the middle number, which would be k.\\n\\nKnowing this, we just need to implement the function to find the Kth element.\\n\\nWe can establish a few base cases. (1) If one of the array is empty, then the result would just be the kth element of the second array. (2) If k == 1, then we just need to return the smallest element of the two arrays (remember, k = 1 means the smallest possible number).\\n\\nWe can then check for k recursively, by comparing the midpoints of both arrays. Think about it this way. Let's imagine we have two arrays\\n\\n```[a 0 .... a mid .... a n]```\\n```[b 0 ... b mid ... b n]```\\n\\nNow if a mid was less than b mid, then when we merge the two arrays, we get something like this:\\n\\n```[a 0 ... a mid ... a n && b 0 ... b mid ... bn]```\\n\\nSince a mid is at index of k/2, b mid is also at index k/2, and b mid > a mid, we know that k must be ahead of a mid, therefore we can move the pointer for s1 to a mid. However, we cannot conclusively rule out b mid to bn, since we do not know how many characters there are in between b mid and bn. \\n\\nSimilarly, if b mid < a mid, we have an array that looks like this:\\n\\n``` [b 0 ... b mid ... bn && a 0 ... a mid ... an] ```\\n\\nWe can then move pointers of b 0 to b mid. Each step reduces our search of k by k/2 times. This gives us a logarithmic solution. \\n\\n```\\npublic class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int totalLength = nums1.length + nums2.length;\\n        int k = totalLength / 2;\\n        if (totalLength % 2 == 0) {\\n            return (findKth(k+1, nums1, nums2, 0, 0) + findKth(k, nums1, nums2, 0, 0)) /2.0;\\n        } else {\\n            return findKth(k+1, nums1, nums2, 0, 0);\\n        }\\n    }\\n    public int findKth(int k, int[] nums1, int[] nums2, int s1, int s2) {\\n        if (s1 >= nums1.length) return nums2[s2+k-1];\\n        if (s2 >= nums2.length) return nums1[s1+k-1];\\n        if (k == 1) return Math.min(nums1[s1], nums2[s2]);\\n        int m1 = s1 + k/2 - 1, m2 = s2 + k/2 - 1;\\n        int mid1 = m1 >= nums1.length ? Integer.MAX_VALUE : nums1[m1];\\n        int mid2 = m2 >= nums2.length ? Integer.MAX_VALUE : nums2[m2];\\n        if (mid1 > mid2) return findKth(k-k/2, nums1, nums2, s1, m2+1);\\n        return findKth(k-k/2, nums1, nums2, m1+1, s2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```[a 0 .... a mid .... a n]```\n```[b 0 ... b mid ... b n]```\n```[a 0 ... a mid ... a n && b 0 ... b mid ... bn]```\n``` [b 0 ... b mid ... bn && a 0 ... a mid ... an] ```\n```\\npublic class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int totalLength = nums1.length + nums2.length;\\n        int k = totalLength / 2;\\n        if (totalLength % 2 == 0) {\\n            return (findKth(k+1, nums1, nums2, 0, 0) + findKth(k, nums1, nums2, 0, 0)) /2.0;\\n        } else {\\n            return findKth(k+1, nums1, nums2, 0, 0);\\n        }\\n    }\\n    public int findKth(int k, int[] nums1, int[] nums2, int s1, int s2) {\\n        if (s1 >= nums1.length) return nums2[s2+k-1];\\n        if (s2 >= nums2.length) return nums1[s1+k-1];\\n        if (k == 1) return Math.min(nums1[s1], nums2[s2]);\\n        int m1 = s1 + k/2 - 1, m2 = s2 + k/2 - 1;\\n        int mid1 = m1 >= nums1.length ? Integer.MAX_VALUE : nums1[m1];\\n        int mid2 = m2 >= nums2.length ? Integer.MAX_VALUE : nums2[m2];\\n        if (mid1 > mid2) return findKth(k-k/2, nums1, nums2, s1, m2+1);\\n        return findKth(k-k/2, nums1, nums2, m1+1, s2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711,
                "title": "c-solution-o-log-m-n-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            int m = nums1.size(), n = nums2.size();\\n            int total = m+n;\\n            if(total%2 == 1)\\n                return helper(nums1, m, nums2, n, total/2+1, 0, 0);\\n            else\\n                return (helper(nums1, m, nums2, n, total/2, 0, 0) + helper(nums1, m, nums2, n, total/2+1, 0, 0))/2;\\n        }\\n        double helper(vector<int>& nums1, int m, vector<int>& nums2, int n, int k, int start1, int start2){\\n            if(m > n)\\n                return helper(nums2, n, nums1, m, k, start2, start1);\\n            if(m == 0)\\n                return nums2[k-1];\\n            if(k == 1)\\n                return min(nums1[start1], nums2[start2]);\\n            int a = min(k/2, m);\\n            int b = k-a;\\n            if(nums1[a+start1-1] <= nums2[b+start2-1]){\\n                return helper(nums1, m-a, nums2, n, k-a, start1+a, start2);\\n            }\\n            else{\\n                return helper(nums1, m, nums2, n-b, k-b, start1, start2+b);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            int m = nums1.size(), n = nums2.size();\\n            int total = m+n;\\n            if(total%2 == 1)\\n                return helper(nums1, m, nums2, n, total/2+1, 0, 0);\\n            else\\n                return (helper(nums1, m, nums2, n, total/2, 0, 0) + helper(nums1, m, nums2, n, total/2+1, 0, 0))/2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4009065,
                "title": "best-o-log-min-n1-n2-solution",
                "content": "# Approach\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(min(n1,n2))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        if (n1 > n2)\\n            return findMedianSortedArrays(nums2, nums1);\\n            \\n        int low = 0, high = n1;\\n        while (low <= high) {\\n            int cut1 = (low + high) / 2;\\n            int cut2 = (n1 + n2 + 1) / 2 - cut1;\\n\\n            int left1 = (cut1 == 0) ? -1e7 : nums1[cut1 - 1];\\n            int left2 = (cut2 == 0) ? -1e7 : nums2[cut2 - 1];\\n            int right1 = (cut1 == n1) ? 1e7 : nums1[cut1];\\n            int right2 = (cut2 == n2) ? 1e7 : nums2[cut2];\\n\\n            if (left1 <= right2 && left2 <= right1) {\\n                if ((n1 + n2) % 2 == 1)\\n                    return max (left1, left2);\\n                else\\n                    return (max (left1, left2) + min (right1, right2)) / 2.0;    \\n            } \\n            else if (left1 > right2) \\n                high = cut1 - 1;\\n            else \\n                low = cut1 + 1;\\n        }    \\n        return 0.0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        if (n1 > n2)\\n            return findMedianSortedArrays(nums2, nums1);\\n            \\n        int low = 0, high = n1;\\n        while (low <= high) {\\n            int cut1 = (low + high) / 2;\\n            int cut2 = (n1 + n2 + 1) / 2 - cut1;\\n\\n            int left1 = (cut1 == 0) ? -1e7 : nums1[cut1 - 1];\\n            int left2 = (cut2 == 0) ? -1e7 : nums2[cut2 - 1];\\n            int right1 = (cut1 == n1) ? 1e7 : nums1[cut1];\\n            int right2 = (cut2 == n2) ? 1e7 : nums2[cut2];\\n\\n            if (left1 <= right2 && left2 <= right1) {\\n                if ((n1 + n2) % 2 == 1)\\n                    return max (left1, left2);\\n                else\\n                    return (max (left1, left2) + min (right1, right2)) / 2.0;    \\n            } \\n            else if (left1 > right2) \\n                high = cut1 - 1;\\n            else \\n                low = cut1 + 1;\\n        }    \\n        return 0.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565045,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1569776,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1568767,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1566464,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1739225,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1566462,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1567357,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1565797,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1567344,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1572693,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1565045,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1569776,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1568767,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1566464,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1739225,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1566462,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1567357,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1565797,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1567344,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1572693,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Ok, sorry.  I\\'m trying to bottle up my disgust for the interviewing process in the silicon valley.  But I couldn\\'t help it after looking at the solution for this one... \\n\\nI actually was asked this question in an interview with VMware.  And after reviewing the solution I\\'m astonished at how/why this question is ever asked.  Isn\\'t it insane to ask this sort of question in a 20-50min interview?  And in the end, does it really tell you anything about the candidate?  Either you get a) a stumped candidate or b) someone who remembers how to solve it because they\\'ve seen it before.  \\n\\nI\\'m trying to review the overall approach in my head.  I find myself just memorizing the solution.  I\\'m pretty certain this process isn\\'t just about memorizing the solutions.  But if you\\'ve seen the solution, it becomes somewhat familiar.  10 or 20 years down the road and you\\'ll never encounter it in industry and will have forgotten the solution.  So you end up just having to recall how its solved, i.e. \"oh yeah, i remember how this one is solved in O(logn) complexity\".   I doubt most candidates could solve this in a short 20-50 min interview."
                    },
                    {
                        "username": "realitant",
                        "content": "Huh? You do the obvious approach to merging two sorted arrays (which is a subproblem of coding a merge sort) and do an O(1) median function on it. \nEDIT: I am just now realizing that it says the time complexity should be O(log(m+n)) and not O(m+n). It feels like the test cases should be tightened up to stop O(m+n) from passing"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "[@PiyushRaj27](/PiyushRaj27) first thing I would think when its sorted or or soething like that is binary search but it is hard even I could solve it "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "Absolutely correct, It took me 5 hours of thought and the tags at the end of the question to even start thinking about binary search. I was able to come up with a solution, though I haven\\'t coded it yet. Seems futile to me as one can solve the problem in O(m+n) without any problem. My friend even submitted that solution and it surprisingly was accepted. Low on motivation now. Clearly not a problem for interview purpose."
                    },
                    {
                        "username": "aroldorosenberg",
                        "content": "I could do this in O( (n + m)/2 ) which is fairly obvious, but there\\'s no fucking way I\\'d ever come up with the \"binary search solution\""
                    },
                    {
                        "username": "yugi122",
                        "content": "[@KautsIITD](/KautsIITD) Of course a guy from IIT would say that \\uD83D\\uDE02"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s one parochial thought I would say.."
                    },
                    {
                        "username": "anandmehrotra",
                        "content": "[@kuelf](/kuelf) Theory yes. Coding it up end-to-end is its own beast"
                    },
                    {
                        "username": "carminemangione",
                        "content": "It is not you and you are absolutely right.\n\nI solved it in about 20 minutes, HOWEVER, i solved it in my refactoring browser (IntelliJ) using test driven design (TDD) AND I teach statistics. \n\nI do not believe I could do it in the total crap environment of LEETcode or any of the even shittier ones used in interviews (looking at you Google).\n\nYou are absolutely correct. I proves nothing about the interviewee.  I specialize in algorithms. You won't encounter these problems and never in a 45 minute window. It is a turn on the ridiculous \"problem solving questions\" from some stupid logic problem Microsoft was famous \n\nActually, on second thought, I would be hesitant to hire anyone who is comfortable solving problems in these problems in crap editors. Can they write solid code with proper unit tests or are they simply a hack?"
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Yeah IRL I\\'d be very disappointed if one of my devs implemented the official solution, instead of walking over to the developer that wrote the code sending him 2 sorted arrays, and saying \"Hey is it really the case that you never need to merge those arrays for anything except one-off calling my code?  because it would be so way easier for me if they were just merged before calling me.\""
                    },
                    {
                        "username": "aikhan",
                        "content": "Spot on\\n"
                    },
                    {
                        "username": "user7257QQ",
                        "content": "I definitely need spend 4+ hours to get the O(log(n)) solution."
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I don\\'t know about that.\\nI\\'m very green at programming, but I think years of statistics made me feel that this did not really deserve the hard tag..."
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Its 4th question of leetcode, of course the interviewer expects to know its solution. Interviewers don\\'t make any questions unless they are newton or Einstein. "
                    },
                    {
                        "username": "kuelf",
                        "content": "I disagree. The O(log(m+n)) solution is a corollary of binary search. As binary search is a fundamental algorithm any coder should be able to extend it\\'s theory to apply to this problem in under 20 minutes. "
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) You are not supposed to sort my dude. Sorting is O(NlogN) .. Beginners need to understand that calling library functions does not overcome the underlying complexity of the library function called. This is also why you should start coding with C++ to avoid the \\'ease\\' of python. Cause a lot of python \\'tricks\\' are merely syntactically great that hide high time cost underneath. "
                    },
                    {
                        "username": "samuelmayna",
                        "content": "I am f*** honest. I can\\'t come up with an O(log(m+n)) solution to this one in 20 min if I hadn\\'t seen the question at all .I came realize that most of the companies do interviews to gamble with candidates not to get the best people. I view interviews as a gamble. If I don\\'t get the job with this kind of questions, I don\\'t feel an ounce of remorse. What I can advise you, apply to as many companies as you can and interview  as much as you can. If you know the question, well and good,if you don\\'t get it, move on."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "csanivar",
                        "content": "You do not have to come up with an log(n) solution. In leetcode solutions, obviously everyone will put THE MOST efficient solution, but that doesn't have to be the case in an interview, it is okay for your solution to be not perfect.\nI came up with an O(n) solution in interview and it was well received, then I checked on leetcode and it was accepted here as well - https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2886872/o-m-n-solution-which-is-more-feasible-in-an-actual-interview/"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I actually immediately knew the solution was binary search, its just all the stupid edge cases made me retry several times"
                    },
                    {
                        "username": "pbrubak",
                        "content": "I love data structures and algorithms and study them, and do leetcode, for fun. \n\nAnd I 100% agree with you.\n\n As someone who solves these from scratch without help, the idea of solving them from scratch without help in 20-50 minutes is ridiculous. It's actually deeply depressing to see such a beautiful subject commoditized and trivialized in such as a way. I think it is the money, naturally. Mega corps tend to have a ruinous effect on everything they touch eventually, either by design or just as a side effect.\n\nVery high salaries have led to an arms race between companies trying to conduct interviews and people trying to bull*** interviews, until the interviews are so hard that bull**** is almost a requirement. I think these very hard questions are okay if the interviewer actually deeply understands the problems they are asking -- then they can make a fair assessment of the candidate's problem solving process. And it is much easier for them to sniff out the memorizers...\n\nBut I have a feeling this is not the case, that in fact many interviewers do not deeply understand the material, and the subjects of mathematics, algorithms, and problem solving in general, well enough to do anything but check a box -- candidate did or did not solve the problem in the way my document said they should.\n\nAnd for most jobs, the sort of thinking needed to solve these problems going in blind.. Is simply not needed. In fact it could be a detriment. I for one would be happier in the world of academia, working at a high level of abstraction closer to the math, but I don't come from money, and life in America ain't getting any cheaper. So software engineer it is. And while I strive to be good at my job, I don't harbor any illusions about this stuff making me much better at it. I think experience building real world software is much more important, as evidenced by my boss who doesn't give a rats a** about leetcode being far, far better at software engineering than me."
                    },
                    {
                        "username": "sandeshnep",
                        "content": "i\\'m pretty certain a huge component of this process if memorizing solutions"
                    },
                    {
                        "username": "quinn-dougherty",
                        "content": "the description says a `log(n+m)` solution exists, but many of us did a naive `median(sorted(nums1 + nums2))` function which worked great even tho it\\'s way worse than `log(n+m)`. \\n\\nTest cases should be harder to force us to think harder, or it should be marked easy or medium."
                    },
                    {
                        "username": "192731",
                        "content": "Getting a logarithmic time complexity is whats supposed to make it hard."
                    },
                    {
                        "username": "Msey",
                        "content": ">  should be marked easy \n\nnice joke"
                    },
                    {
                        "username": "kennysliding",
                        "content": "[@azuregcp](/azuregcp) For some programming languages, such as Rust which I used, the method of simply concat the two arrays, run a sort and get the median from the sorted vector yields <0ms\\n\\nThe test cases can\\'t really reflect the constraints and force a O(log(m+n)) solution, rendering the runtime chart inaccurate for this question."
                    },
                    {
                        "username": "azuregcp",
                        "content": "Even median(nums1+nums2) works fine. It doesn\\'t require sorted list."
                    },
                    {
                        "username": "honey-grapes",
                        "content": "Hi, \\n\\nI am wondering why .sort() is used in most of the solutions when the time complexity requirement is O(log(m+n))?"
                    },
                    {
                        "username": "mochiball",
                        "content": "These people want to cheat and get the green checkmark "
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mandarinorange](/mandarinorange) that\\'s not the point though, why even bother doing the problem if you do it in a way that makes it trivial."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "because they\\'re dumb"
                    },
                    {
                        "username": "atultripathi589",
                        "content": "In python the sort() method is not a regular merge sort. It tries to avoid sorting as much as it can(if its already sorted). But still dont know why even O(n) solutions are getting accepted."
                    },
                    {
                        "username": "rn_durge",
                        "content": "[@mandarinorange](/mandarinorange) can you share me your solution??"
                    },
                    {
                        "username": "Denis411",
                        "content": "Agree, it would be way too easy. Furthermore, using .sort() is not allowed in interviews."
                    },
                    {
                        "username": "mandarinorange",
                        "content": "Because it passes.  My solution is O(m+n) and is faster than 90%."
                    },
                    {
                        "username": "00pauln00",
                        "content": "It\\'s because the input arrays are already sorted -- the bulk of the sorting work has already been done.   "
                    },
                    {
                        "username": "parismania",
                        "content": "When you use .sort(), the complexity is always O(n log(n)), ie. you won't meet the required complexity constraint. Also, to sort, you have to merge the two arrays, which needs O(m+n)."
                    },
                    {
                        "username": "pbrubak",
                        "content": "I haven't looked at others, but my solution involves getting the smaller array down to a small constant size, and then using a constant time subroutine to deliver the final answer. This was easier for me on a first pass at the problem than thinking through all edge cases that come up when the subarrays get small. Sorting is perfectly okay to use in an O(log(m+n)) solution as long as the length of the subarray to sort is below a small constant threshold.\n\nEdit: I see people are saying the test cases will allow through O(n+m) or worse solutions. I take the view that acceptance or rejection of a solution is merely a helpful hint, rather than a final arbiter of correctness, and I think this is the only view that makes any sense. One should be able to determine on one's own, by analyzing the algorithm and code in question, whether it is correct and meets the given time and / or space complexity criterion. That is the entire point, and all the speed scores and badges and whatnot are merely there to gamify the platform in order to boost engagement + revenue."
                    },
                    {
                        "username": "alexkyllo",
                        "content": "I submitted two solutions, one with O(m+n) complexity (merge the entire arrays first and then find the median), and one with O(log(m+n)) complexity (divide-and-conquer to find K smallest element of the two arrays and then calculate median) and latter was only 2ms faster. Suggest providing a test case that's sufficiently large to make the difference between logarithmic and linear runtime performance obvious."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@kljhdfv](/kljhdfv) exactly\\n"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can you show us the code for o(log(m+n)) Complexity?"
                    },
                    {
                        "username": "cagils",
                        "content": "[@utsav1123](/utsav1123) Well printf statements and like are in fact always slow so it is to be expected. But beside that, yes leetcode runtime i snot determiistic and will return sometimes really different results for consecutive runs."
                    },
                    {
                        "username": "kljhdfv",
                        "content": "Are you sure that it\\'s $$O(log(m + n))$$? Probably it\\'s just $$O((m+n)/2)$$"
                    },
                    {
                        "username": "F-aang",
                        "content": "[@utsav1123](/utsav1123) printf statements take a lot of cpu time. Always remove them for getting the best run time."
                    },
                    {
                        "username": "dimitryku",
                        "content": "[@utsav1123](/utsav1123) you don\\'t even need to delete something. Usually, I submitting 2 or 3 times, to find out, what is the real percentage."
                    },
                    {
                        "username": "tsalazar",
                        "content": "[@utsav1123](/utsav1123) More than that: I submitted the same code twice and had it beating 12% and 86% of the submitted solutions. \\nThat being said, I\\'ve done enough data engineering to sympathize with them. "
                    },
                    {
                        "username": "utsav1123",
                        "content": "Leetcode runtime is broken I think, I submitted the same code twice. First one was beating 16% and the second one beats 75+% .\\nAll changes I did was to remove all the printf statements which I placed for dry running."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I got this exact question in an interview last week. I almost gave up because I knew I\\'m unable to come up with the optimal `O(log(n+m))` solution. I quickly did a naive `median(sorted(nums1 + nums2))` function and briefly mentioned the optimal approach. The interviewers laughed and said they don\\'t even expect people can implement this within 45 min. \\n\\nToday I received a call telling me I\\'ve passed the interview. What a relief!"
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "wow, surprisingly LC also accepts the O(m+n) space solution, basically putting into auxiliary array and just returning the middle element :)"
                    },
                    {
                        "username": "rivera",
                        "content": "Technical correctness is the best type of correctness. \\n\\na sample illustrates that [1,2,3,4] ought to yield 2.5. \\nHowever, the STATISTICAL DEFINITION of median is the DATA POINT which seperates the upper half from the lower half. By definition, the median MUST be a member of the data set. \\n\\nBad question."
                    },
                    {
                        "username": "hammeramr",
                        "content": "wrong - less Futurama more studying ;)"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "technical correctness is the best type of correctness AND technical ignorance is the best type of ignorance . Median of a discrete set of values is defined as the data point that seperates the upper from lower when it is present IF NOT then the median is the mean of the values of the middle indices. Might as well research a bit more before labeling a question as bad, might just be your in technical insufficiency. "
                    },
                    {
                        "username": "archibald1418",
                        "content": "The data points could be in a continuous random variable distribution as well. Median of a continuous distribution is a real number on x axis where all the preceding values and all of the succeeding values occur with probability of 1/2 (i.e. the center of the distribution). Be careful, an array of integers doesn't instantly imply a discrete variable, they could just happen to be integers"
                    },
                    {
                        "username": "zgreen777",
                        "content": "https://www.omnicalculator.com/statistics/median"
                    },
                    {
                        "username": "kuelf",
                        "content": "[@lznpgxn809](/lznpgxn809) Stop spamming your o(nlogn) answer."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "iinthesky",
                        "content": "This is the standard way to define the median of a discrete set of values. It is also clearly defined in the problem statement and examples. Thus the problem, which is clearly stated, agrees with the standard definitions used in statistics. How does that make it a bad problem?"
                    },
                    {
                        "username": "dpinto",
                        "content": "The problem statement in the description states that we can assume there are no empty arrays but the test case inputs includes few examples with empty arrays."
                    },
                    {
                        "username": "utsav1123",
                        "content": "It was mentioned in the constraint that either one of the arrays can be empty.\\n"
                    },
                    {
                        "username": "SnorlaxNYC",
                        "content": "Rating: 3. This is marked as Hard problem, as you will find that the expected time compelxity is O(ln(m+n)). Therefore, you can\\'t merge the two sorted arrays into one sorted array and find the median. As the merging operation it self takes O(m + n). I give this problem a low rating, for reason that in reality, you barely need to optimize a solution like this, and the expected solution adds too much cognitive load to a problem than can be addressed pretty easily with a little sacrifice on space. \\n\\nWhat can you learn from solving this problem? Nothing.\\n\\nThis should not be used for interview."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@koff82](/koff82) Not just merging here but merging while keeping the final array sorted and it will definitely take o(m+n) not constant in any lang "
                    },
                    {
                        "username": "LachyM",
                        "content": "[@koff82](/koff82) In python, lists are actually variable sized arrays. They are not linked lists under the hood."
                    },
                    {
                        "username": "user1323zI",
                        "content": "[@koff82](/koff82) event if the collections can be merged in O(1) time, they still need to be sorted again because it\\'s possible that nums2[0] < nums1[-1]."
                    },
                    {
                        "username": "coleboggus",
                        "content": "[@svenkratz](/svenkratz) that would no longer be sorted"
                    },
                    {
                        "username": "koff82",
                        "content": "Re: Merging takes O(m+n). This might be true in languages such as C which use \"real\" arrays. However in higher-level languages such as Python, appending the two lists is probably constant time, since linked lists underlying the input just get extended by adding the list head of nums2 to to the tail of nums1. "
                    },
                    {
                        "username": "dreydyl",
                        "content": "Do they mean \"mean\" and not \"median\". I thought \"median\" was the element in the center of the set."
                    },
                    {
                        "username": "D33PBLU3",
                        "content": "It is supposed to be median. The average of 2 numbers is taken only if there are an even number of elements."
                    },
                    {
                        "username": "he11mean",
                        "content": "I just implemented a solution in Scala and looked at other people\\'s submissions. Apperently trivial merge arrays + sort approach passes all tests and even beats my O(log n) solution in terms of actual time. I.e. the tests instances are too small / weak. Please fix."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "It says my O(n +m) solution is takes 2 ms and beats 100% of solutions lol."
                    }
                ]
            },
            {
                "id": 1568798,
                "content": [
                    {
                        "username": "yon",
                        "content": "Input:\\t[1,1], [1,2]\\nExpected:\\t1.00000\\n\\nMy solution way is merge [1,1] and [1,2] to [1,2], so the answer would be (1+2)/2 = 1.5\\nWhat did I made wrong?"
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "you first merge it (preserving duplicates).\\n[1, 1, 1, 2]\\n\\nWhats the middle element here?\\noh wait. there are two elements at the middle. 1 and 1.\\nso you average em. \\n(1 + 1) / 2 = 1"
                    },
                    {
                        "username": "RISHIKA_GANDHI",
                        "content": "change your (1+2)/2 to this (1+2)/2.0 you will get you result into float/double type"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "the merged array will we [1,1,1,2] ,\\nno of elements are even so median will we (1+1)/2=1.\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the hell nooo. median is 1 here"
                    },
                    {
                        "username": "hankIgoe",
                        "content": "the merged string is [1,1,1,2], so the median is (1+1)/2 = 1.0\\n"
                    },
                    {
                        "username": "vyshnusanthosh",
                        "content": "If you are using java, when two integers are divided the answer will also be an integer in order to get floating point you need to type cast the integers to double or float before division."
                    },
                    {
                        "username": "megazortti",
                        "content": "i\\'m facing the same problem..\\n"
                    },
                    {
                        "username": "khushal1201",
                        "content": "[@zwicky](/zwicky) the merged array should be [1,1,1,2]. Hence the median would be (1+1)/2 = 1."
                    },
                    {
                        "username": "zwicky",
                        "content": "you shouldn\\'t remove duplicates"
                    },
                    {
                        "username": "hing_liu",
                        "content": "Let try to interate the algorithm first:\\n\\nIt is basically a k-th smallest element problem between two sorted arrays, let assume we have the following two arrays:\\n\\n5,7,8,11\\n4,9,12,14\\n\\nk = 4 (expected ans = 8 because when it is sorted: 4,5,7,**8**,9,11,12,14)\\n\\nStep 1: Cut the two arrays into two pieces such that the left side will have total items of 4 (i.e. the **K=4**)\\n5,7 | 8, 11\\n4,9 | 12, 14\\n\\nStep 2: We remove [5,7] because its end index at the left side is smaller (7. v.s 9) and we update K = 2 (since we removed 2 item=> K - 2 = 4 - 2 = 2), it will becomes:\\n8,11 <-- removed [5,7]\\n4,9,12,14\\n\\n(basically the rest of the steps below is to repeat 1 and 2 until K = 1)\\n\\nStep 3: Repeat Step 1, Cut into two half base on **K = 2**\\n8 | 11\\n4 | 9 12 14\\n\\nStep 4: Repeat Step 2, that is remove 4 and update **K = 1** (since we removed 1 item=>K-1 = 2-1 1)\\n\\nStep 5: Repeat Step 1, Cut into two half base on K = 1, since K = 1 is not able to split (we have two arrays, don\\'t know how to split), we conclude the solution as the minimum of the first item of the two array, that is min(8,9) = 8\\n8,11\\n9,12,14\\n\\nWe are all done, how about K = 3 initially? Basically the point of \\'cut\\' is K/2 - 1, therefore when K = 3, the cutting point is index=0, let us go though this again quickly for this:\\n\\nK=3\\n5|7,8,11\\n4|9,12,14\\n\\nK=2\\n5|7,8,11\\n9|12,14\\n\\nK=1\\n7|8,11\\n9|12,14 \\nAns=min(7,9) = 7\\n\\nThere is some edge case not tell here, this is just a general idea. We want to have the first K-th item, so, the first target is to collect the first K item from the two array, so we fairly cut them at K/2 - 1 and remove the smaller list until K = 1.\\n\\nThis might be still hard to understand, consider we are not greedy, we do it one by one (we don\\'t cut base on K, but always cut by two):\\n\\nK=4\\n5 | 7 8 11\\n4 | 9 12 14\\n\\nAt this point, we remove the smaller one and have:\\nK=3\\n5 | 7 8 11\\n9 | 12 14\\n\\nKeep doing this until K = 1\\nK=2\\n7 | 8 11\\n9 | 12 14\\n\\nK = 1\\n8 | 11\\n9 | 12 14\\n(at this point, all done)\\n\\nWe are now reaching the answer = 8 by doing this in one-by-one manner, the cutting point at this \\'slow-version\\' is always [0], and the faster version is doing the cutting point at [k/2 - 1], that still work because they are sorted, it is safe to jump further and remove the whole preceding items rather than doing this one-by-one manner.\\n\\nAgain, this might still be hard to convince yourself why the \\'faster-version\\' has no issue, just hope this can help you understand more.\\n\\nGoing back to tell why it is a k-th minimum issue, consider when we have ths int kth(arr1, arr2, k) function, we can put k to be the middle of sizeof(arr1) and sizeof(arr2), if it is even number of size we just get the adjacent (run kth function two times) so we can get the middle two and divide it by 2, so the answer ..."
                    },
                    {
                        "username": "rds8rds",
                        "content": "thanks properly understand the concept!"
                    },
                    {
                        "username": "parismania",
                        "content": "That\\'s quite a good explanation. Thank you!"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I tried to avoid this question for as long as possible"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally solved this by merging the two arrays. I always intended to do the proper solution - one day. Today is the day."
                    },
                    {
                        "username": "raviTejaY",
                        "content": "\\tvar findMedianSortedArrays = function(nums1, nums2) {\\n  \\tlet mid;\\n\\t  let res = [...nums1, ...nums2].sort((a,b) => a-b);\\n\\t mid = (res.length-1)/2;\\n\\t  if(res.length % 2 === 1){\\n\\t\\treturn res[mid].toFixed(5);\\n\\t  } else {\\n\\t\\tlet median = (res[Math.floor(mid)] + res[Math.ceil(mid)]) / 2;\\n\\t\\treturn median.toFixed(5)\\n\\t  }\\n\\t};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, you use .sort(), which does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "hongbin2",
                        "content": "My naive solution is just merge two array and find the median. Obvious we can do better. But I just have no idea about it."
                    },
                    {
                        "username": "aneesfathimasaifudeen",
                        "content": "Input\\n[1,2]\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000\\n\\nThis test case always fails for me in leetcode, whereas it works for me in my machine\\'s python compiler with the same code.\\n\\nCan anyone tell, what would be the problem here?"
                    },
                    {
                        "username": "evenn",
                        "content": "choose Python3 rather than Python to execute code"
                    },
                    {
                        "username": "kapilkapuriya",
                        "content": "[@jeetu16](/jeetu16)  use type cast when you perform   ** ans = a/2 **  so do like this  **  ans = double(a)/2 ** "
                    },
                    {
                        "username": "doubleshab",
                        "content": "[@jeetu16](/jeetu16) I had a similar problem using Python3. For me, the issue was that the math I was using to generate my index values was producing float values. By forcing them to integer types using the int() builtin, I was able to get around it."
                    },
                    {
                        "username": "python_is_cheat_code",
                        "content": "Facing the same issue. Have no idea what to do."
                    },
                    {
                        "username": "AtrijPaul",
                        "content": "If you are coding in Java then division of two integers will be integer only , after performing the division it get stored as double. So instead of dividing by 2 , divide by 2.0 , it will work."
                    },
                    {
                        "username": "jeetu16",
                        "content": "have you found the solution till now?\\ni faced the same problem"
                    },
                    {
                        "username": "scott40",
                        "content": "The question states: \"There are two sorted arrays nums1 and nums2 of size m and n respectively.\" This does not tell me whether the sort order is largest to smallest, or smallest to largest. It would even be possible for nums1 to be sorted largest to smallest while nums2 is sorted from smallest to largest. So I thought we would need to be able to handle such cases, making no assumptions as to the direction of the sorts. As a test case of opposite sort directions in the inputs I tried:\\n[10,8,3]\\n[5,9,17]\\n\\nBoth input lists sorted as required, but in opposite directions. The median here should be 8.5, but when I ran the test case it gave me an expected answer of 6.5. So I think leetcode is making an assumption about the sort directions of the inputs that should not be made, and it is not designed to properly handle this case. What are we allowed to assume about the input sort direction?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement does not explicitly mention the sort order. However, it is conventionally assumed that, unless stated otherwise, a \"sorted\" array or list is in non-decreasing order, meaning from smallest to largest. This assumption is consistent with most problems and discussions involving sorted data in computer science and mathematics.\\n\\nTherefore, in the context of this problem, you can assume that both input arrays are sorted in non-decreasing order. This assumption informs the approach to solving the problem. If the arrays were sorted in non-increasing order or if one array was sorted in increasing order while the other in decreasing order, a different approach might be necessary.\\n\\nHowever, if the problem were to handle arrays sorted in either direction, a pre-processing step could be added to sort the arrays in the desired order before proceeding with the rest of the algorithm. This would increase the time complexity, though, because sorting is generally an O(n log n) operation."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit before validating your solution against a few edge cases, e.g.\n```\n[-932210,-932056,-922328,-917451,-913929,-907514,-883337,-802571,-739964,-709048,-692863,-690427,-679691,-666576,-643630,-638229,-585992,-574362,-571309,-541584,-538138,-497470,-480909,-459608,-444410,-426022,-403497,-393857,-363379,-359219,-347291,-330378,-314805,-303621,-291243,-251965,-244657,-243891,-236303,-234099,-217309,-210326,-199139,-197450,-177317,-172519,-170556,-137069,-128436,-113727,-95170,-79317,-52534,-4681,40199,89215,107649,109238,124507,157189,162498,180216,200111,228032,251189,262426,319119,323615,344264,345305,373566,399588,411387,427092,427955,456725,461974,468467,474372,476390,562956,577916,580839,591862,616385,638656,650816,653650,672517,753495,769837,779299,801738,809541,836250,872512,917419,949439,959386,979587]\n[]\n[]\n[-999311,-995487,-993598,-993127,-989482,-973229,-926998,-898485,-851725,-850712,-836433,-795269,-784476,-764197,-763427,-756479,-755190,-753600,-717158,-677976,-668634,-640052,-597569,-589282,-520481,-515063,-499955,-479622,-477302,-473002,-403966,-400582,-388037,-363473,-344547,-324788,-320701,-314920,-296000,-290463,-276432,-273513,-244152,-215671,-192226,-184426,-128230,-122297,-75423,-58001,-8481,2993,27765,54297,64282,81674,93781,96008,152144,154165,166583,169777,181118,191164,216155,263473,271293,308484,360932,380484,405656,413389,432913,436707,461128,530274,555172,576238,595665,608718,624952,644037,684003,697121,727400,730624,751135,768207,784915,792103,809755,831583,832823,844259,886508,913559,941025,950966,975298]\n[-999567,-997502,-997320,-997131,-995209,-993605,-991650,-991613,-991417,-990564,-989776,-987550,-985870,-985386,-982368,-981518,-979842,-979718,-978628,-976620,-974345,-973518,-972291,-967402,-967265,-966730,-965785,-962771,-961174,-960505,-959719,-955802,-955134,-953099,-948117,-944790,-941695,-941693,-939131,-938510,-937577,-937038,-935074,-933558,-933056,-930614,-929544,-924799,-922049,-920262,-919703,-917939,-916145,-915636,-914995,-913579,-896888,-894679,-894651,-891943,-891618,-891260,-888315,-886543,-884101,-883513,-872873,-872826,-872120,-871050,-870232,-869805,-868351,-867330,-866646,-866243,-863978,-863009,-859149,-858906,-858758,-854975,-852689,-852164,-851427,-850218,-847970,-845912,-845486,-844687,-844411,-843956,-843353,-839477,-837499,-836703,-833607,-831373,-830358,-827611,-827276,-827145,-827057,-825816,-823331,-822868,-822693,-821423,-820561,-819808,-815340,-814889,-814639,-814554,-813263,-811601,-810742,-810567,-808592,-807943,-805362,-805085,-803725,-798929,-792149,-789206,-785856,-783704,-783011,-781163,-775292,-772930,-769271,-764889,-764165,-763180,-758264,-756607,-755921,-752956,-752637,-751864,-751318,-750878,-750246,-749003,-746825,-744464,-744367,-743637,-741289,-738903,-736545,-732164,-731981,-731878,-730164,-727779,-725497,-725433,-720206,-715719,-714089,-707566,-705091,-705008,-705000,-699566,-696000,-694414,-689552,-688092,-683083,-681058,-680084,-676059,-675854,-675730,-672990,-671402,-669298,-669292,-667660,-667250,-662853,-660122,-658209,-657793,-657002,-656472,-653603,-647017,-643156,-642765,-642520,-638572,-637837,-636344,-635145,-629818,-628344,-624890,-622582,-621602,-619124,-617701,-616391,-613542,-609069,-605811,-604133,-603960,-602075,-601936,-601600,-599041,-598358,-597574,-597092,-596147,-594696,-592955,-592300,-591877,-591829,-591201,-589912,-584118,-583933,-574753,-567021,-566697,-565332,-564305,-562776,-561152,-557378,-553247,-551405,-541292,-536736,-533881,-533615,-532784,-531029,-530553,-527184,-526662,-525823,-525625,-525093,-520969,-520545,-515036,-510919,-507746,-504592,-504032,-503595,-501437,-499214,-496301,-494795,-490284,-486646,-485513,-484383,-480751,-476832,-476559,-474296,-469572,-469152,-468659,-466347,-462419,-460567,-458882,-457050,-454911,-453624,-452324,-450481,-449509,-440836,-439940,-436508,-434347,-431863,-426890,-422954,-422337,-419891,-419812,-419313,-415360,-413516,-410195,-409526,-409454,-408360,-408054,-406101,-404269,-401590,-400963,-394836,-385314,-375836,-374995,-374048,-368693,-368131,-367859,-361397,-360458,-356055,-354270,-354227,-346946,-346223,-346099,-345855,-344808,-344247,-343806,-342087,-339682,-338497,-335912,-334945,-330597,-328200,-327450,-323098,-320641,-319061,-316787,-314312,-314133,-313427,-313020,-311735,-311556,-308652,-307950,-307902,-305049,-304780,-304200,-301782,-301539,-296853,-296489,-293520,-285339,-284857,-284262,-283709,-282070,-281202,-281164,-277190,-276021,-274641,-273757,-273728,-270394,-269087,-265427,-265272,-264115,-263447,-262116,-259606,-257673,-257419,-257235,-257127,-257053,-256900,-256146,-255547,-253986,-249576,-249079,-245481,-239011,-235597,-230997,-228005,-227497,-227250,-226380,-225431,-216611,-210008,-208956,-208838,-201921,-199428,-196686,-191696,-190547,-189199,-188847,-188753,-186418,-185773,-185206,-182706,-180515,-179348,-178474,-175203,-174731,-173012,-173012,-171115,-170095,-168308,-168128,-166905,-166742,-164733,-164448,-158590,-157720,-156014,-155429,-153638,-149375,-148870,-148098,-147945,-145512,-145183,-141591,-139964,-137213,-134488,-133486,-132424,-131215,-130615,-125187,-124332,-117324,-113085,-112523,-111751,-111383,-104409,-104344,-102517,-102161,-98185,-97846,-91902,-89723,-84742,-84067,-83948,-82603,-82579,-78160,-76854,-75430,-75344,-74962,-71408,-69102,-66641,-65642,-64757,-61211,-60329,-57886,-53220,-52898,-49270,-49124,-48080,-45815,-44789,-37626,-34882,-34859,-32485,-31102,-29729,-24983,-22453,-20259,-16334,-16193,-15026,-12533,-11486,-9861,-4017,-404,704,6117,7576,8139,8688,16526,17499,22574,25852,26549,29362,30492,33676,37645,40152,43767,44242,46314,47444,50651,52396,53898,59922,60919,63930,68755,69424,70153,71709,73909,75531,75770,77643,78793,81457,83544,85477,89943,91011,91041,91192,94363,94670,95048,96537,98525,98539,104346,107800,108042,109819,110121,115691,117048,118363,118924,120311,125092,127555,127995,128168,135729,138889,140152,140261,140971,145327,145731,145860,152322,155692,159510,161250,163594,164930,166753,167883,168915,172982,173783,174795,175457,179314,180491,180628,189221,190490,190611,193586,195760,199322,201329,202231,202971,205732,206448,209484,210079,213383,213627,214223,215757,218866,223260,224593,225505,228101,229883,232562,234221,235355,236464,236563,238608,240104,242362,242959,245209,246122,246173,249953,255505,258524,260918,261968,262033,262830,263342,263665,265410,265772,266591,268471,270067,274107,276862,277801,277848,278505,278931,279516,285322,286378,293299,294255,296317,296787,297292,300002,302027,302121,302296,304390,304403,306514,311250,311643,316657,317008,319056,320827,322849,324605,326098,326173,326315,326588,328330,329876,330948,331341,331948,332124,341297,341942,343708,344436,344659,350897,351495,351893,352596,353479,355046,356056,357088,357742,358398,360172,365218,372048,375602,376611,382420,386919,389469,391011,392771,396046,403823,404843,407192,409690,410139,411497,418925,419472,419584,420171,421967,425637,428244,428593,429601,430662,431024,432899,434667,438639,438690,438839,441713,443399,449585,454891,459572,461567,464223,464977,468031,468216,468980,469952,471601,473590,476517,477804,478040,479232,481442,482516,487561,489198,493596,494509,498310,500634,502180,503663,504932,507455,511419,515818,517896,518474,520182,520335,520403,520452,523949,524745,525015,526693,531560,536815,536885,536922,537002,537675,541832,543158,547884,548488,549711,559134,559481,559820,560772,560870,561935,563399,563985,568956,569744,570203,573437,574202,574696,578813,579430,588576,588747,590647,604861,606852,606861,607746,608154,609468,609523,611937,611965,612112,614230,619688,620348,621041,621873,622766,633850,636410,645785,647203,647468,648663,651250,653354,655650,655736,656313,656473,660352,665886,668634,668889,668947,670032,670182,670412,673826,686025,686683,691645,692054,692284,695765,697395,697829,702166,708541,709011,711141,712520,714573,716618,721072,721706,721848,721884,722339,722954,724012,724181,726931,729781,730450,732815,734038,734313,735874,736725,737913,738002,740812,743047,744545,745638,746517,747495,747721,754971,755927,760296,760368,768237,770512,771998,772642,773928,775652,776009,776528,778433,784050,788493,788662,790251,794398,797252,797470,798288,800465,801126,806618,807774,810900,812412,812864,815004,819410,819576,821429,822144,828766,831814,834893,834987,838359,839232,839741,845812,846318,851048,851400,852080,856264,859668,861457,862611,863385,867019,872146,872332,877196,879288,879573,883230,888081,889012,889628,889844,890313,891004,891633,897234,900619,901180,901991,904976,905449,905491,905566,906218,906325,911636,912008,912597,917627,919382,921003,924181,925430,925724,925947,929266,934039,935863,937145,938405,941714,945193,946019,948295,950933,951602,951856,952469,953824,954207,954485,954748,959150,960644,962815,963477,963549,963815,964638,965098,967348,967682,969084,971079,973452,974228,976702,976910,978359,981049,982811,982859,987419,993386,994771,995167,996051,998221]\n[-987944,-969636,-969382,-963918,-960334,-957471,-955419,-954534,-949617,-948164,-941370,-934887,-933385,-933024,-925395,-920598,-914952,-912930,-910713,-898551,-897943,-895093,-883721,-881114,-868961,-862108,-859224,-844995,-843122,-841350,-839681,-837319,-833916,-832929,-824567,-821404,-817679,-816414,-815142,-814794,-814428,-812717,-803053,-800629,-791874,-784923,-776546,-772543,-770170,-769595,-767768,-764581,-760610,-755916,-750060,-738122,-734792,-733242,-728895,-725665,-725507,-718134,-717075,-715534,-715202,-713373,-712097,-708739,-707414,-706871,-703365,-702017,-693735,-683042,-672054,-669261,-668919,-664791,-661728,-660926,-656147,-645420,-643702,-643193,-641435,-638420,-634551,-628772,-615960,-603372,-601747,-598111,-594931,-589739,-582816,-582756,-578800,-578594,-573174,-567081,-559766,-559620,-556681,-554084,-553002,-549693,-548262,-545226,-544969,-537261,-533737,-528123,-520081,-506744,-504736,-499021,-496520,-496470,-495274,-493267,-486175,-485863,-484654,-482183,-481473,-479689,-476360,-474984,-474568,-470604,-469841,-458033,-456643,-456026,-449361,-448407,-447725,-446572,-444202,-444122,-438385,-438174,-436049,-433511,-429215,-428895,-423500,-419598,-414944,-413779,-413601,-413134,-395813,-386542,-386081,-384022,-383217,-377664,-375237,-370842,-368652,-368619,-367534,-360286,-359315,-356864,-346574,-344238,-342362,-338322,-337904,-317031,-315369,-311471,-307529,-291585,-288367,-282217,-273392,-268202,-266384,-262947,-261304,-259484,-253107,-253097,-247496,-240183,-238502,-232673,-225567,-225273,-220556,-218540,-217405,-209508,-209191,-198492,-196102,-194657,-187900,-187654,-187409,-183298,-183195,-178895,-172948,-164463,-150912,-150447,-147157,-146039,-142859,-142513,-141007,-140514,-133632,-121672,-120655,-111524,-106570,-104308,-101032,-100077,-99330,-98302,-93625,-88734,-88072,-87928,-84357,-71659,-69515,-67676,-63282,-58552,-56529,-55822,-52857,-49183,-49096,-36632,-35822,-22044,-15543,-13193,-11327,-8347,-5921,367,2667,4951,5292,12503,13977,16698,20683,21104,29329,29383,32131,36676,38796,38939,39209,47231,48354,58584,63004,67608,68400,79071,80602,81795,86542,94114,101023,103400,104656,104880,111548,112896,115766,121077,122734,127019,127444,132932,138051,140440,154194,158884,165068,166138,166908,169497,170785,171990,179699,180030,188999,195927,197727,215034,218444,219489,222687,224521,235464,235727,241470,243528,246904,258231,259122,260441,263591,265308,267313,269450,272354,272547,274104,276239,278349,282844,283153,284414,285344,292275,301326,301817,303601,305996,308758,308841,318258,318758,326276,328210,328413,329591,330688,335804,336586,338827,350724,353017,355893,356488,358137,367458,369246,373776,375814,388619,389665,391494,398826,410285,414310,434616,436368,437657,441921,442891,443722,445197,448982,449981,452442,455491,458606,458789,459482,459977,460011,467293,480680,484432,486822,491840,495107,498402,498655,499730,501125,506371,507661,508352,508531,510705,517473,521451,521763,531020,535521,536548,538401,543120,545936,546904,551503,551845,552061,557919,565312,566269,568604,574239,574420,578570,579251,582167,587488,592161,594286,604994,619288,622829,629325,652728,657554,659113,659971,661630,664091,664280,667722,673155,674069,675252,680792,683874,685152,698652,701722,703282,708464,710121,710242,712200,718611,720934,732059,736885,739191,742494,750812,759987,772722,776392,782107,782131,783537,783996,785898,793147,799555,806418,807432,808677,831974,841540,844398,849513,849656,854080,855359,858674,865625,866262,870340,877863,886981,896266,898306,900880,903869,907452,914307,916336,916960,922084,923604,924431,926571,930085,935193,948240,948473,954648,957779,959463,960134,960965,975144,979240,997354,999899]\n[0,2,3,4,4,6,6,7,8,8,8,8,11,11,15,16,17,20,22,26,26,28,29,30,31,32,36,39,40,41,41,44,45,52,52,53,54,56,57,62,70,71,72,74,78,78,80,80,83,84,86,87,88,90,91,92,92,96,99,104,105,106,110,110,112,113,113,115,116,118,119,121,121,123,124,125,125,129,129,131,131,134,135,140,141,141,143,144,145,145,145,150,152,153,154,157,158,159,159,159,164,164,169,172,176,176,177,178,178,184,185,189,189,190,191,192,193,193,194,194,195,196,196,200,203,204,205,206,210,211,211,212,212,213,216,219,220,222,225,226,229,229,233,234,237,238,239,241,243,243,246,246,248,249,249,250,250,251,253,255,256,258,260,260,262,266,268,268,269,271,272,273,273,280,281,282,283,288,288,295,296,296,298,302,304,305,305,305,305,306,306,308,309,310,312,313,315,315,318,318,319,319,321,322,323,324,324,326,329,329,329,331,331,333,333,334,334,336,339,339,340,341,341,343,344,348,351,351,352,353,354,354,358,359,363,364,364,365,367,367,368,369,370,372,372,373,376,376,378,379,379,381,382,383,385,386,391,391,391,394,396,399,400,411,414,414,414,416,423,429,429,430,430,431,435,436,437,438,442,443,444,447,448,452,452,452,452,452,455,456,457,457,462,466,468,468,468,472,472,472,472,473,473,475,476,476,477,477,480,481,481,482,483,483,484,485,485,486,486,491,491,491,491,492,494,495,497,497,500,502,503,505,505,509,510,514,515,515,515,516,516,518,519,519,520,522,524,525,527,528,529,531,534,537,537,540,543,543,544,544,545,549,552,552,556,558,558,565,565,566,569,570,571,572,575,577,577,578,579,579,581,583,584,586,586,590,591,593,597,603,603,605,607,608,611,613,614,622,622,622,623,631,631,633,635,638,638,639,642,643,644,645,646,649,652,653,653,654,655,655,655,655,657,659,660,661,664,665,666,667,671,682,684,685,686,688,691,692,694,694,696,698,699,702,704,704,704,706,706,709,710,713,713,714,717,723,725,726,727,727,729,730,730,732,732,733,734,738,740,740,741,746,750,751,751,755,755,758,759,759,760,764,765,767,769,771,773,774,775,776,779,779,781,782,785,797,797,798,798,798,802,803,804,804,806,807,808,809,809,810,810,812,814,814,818,819,820,822,822,823,824,826,826,826,827,830,831,833,833,833,834,837,838,838,839,840,840,841,844,844,847,848,851,852,853,854,857,860,862,864,868,868,869,870,872,874,880,881,881,883,884,885,888,889,892,892,896,897,897,898,899,901,904,905,907,908,914,914,915,915,916,918,920,921,921,921,927,927,928,928,929,932,932,932,932,933,937,937,938,939,940,941,941,942,942,942,944,945,945,946,947,948,952,952,955,956,960,962,964,964,966,968,968,968,971,973,973,973,974,978,979,979,981,982,983,985,985,989,990,990,990,993,994,994,995,998,999,999,1000]\n[999,999,1002,1003,1003,1004,1007,1010,1016,1016,1016,1020,1020,1022,1022,1024,1024,1027,1035,1038,1038,1041,1043,1044,1054,1055,1060,1064,1066,1067,1069,1070,1070,1071,1074,1074,1075,1081,1081,1087,1090,1092,1092,1094,1095,1095,1096,1097,1097,1098,1099,1103,1103,1103,1104,1104,1104,1105,1105,1108,1109,1109,1112,1112,1113,1116,1117,1117,1117,1117,1119,1121,1122,1124,1124,1125,1129,1129,1130,1131,1133,1133,1133,1135,1139,1140,1142,1142,1143,1144,1145,1146,1146,1148,1149,1151,1151,1151,1151,1152,1153,1153,1158,1159,1161,1164,1167,1171,1172,1173,1174,1176,1178,1178,1179,1180,1181,1182,1182,1183,1183,1185,1185,1186,1188,1189,1191,1192,1195,1200,1201,1201,1203,1204,1206,1207,1208,1208,1209,1210,1212,1212,1215,1216,1217,1222,1224,1225,1226,1226,1229,1230,1232,1232,1239,1241,1241,1243,1243,1244,1249,1252,1255,1256,1257,1263,1266,1266,1266,1270,1272,1274,1274,1280,1281,1288,1288,1288,1291,1291,1292,1296,1299,1301,1304,1304,1305,1306,1307,1310,1311,1311,1311,1312,1313,1313,1315,1315,1315,1319,1320,1321,1321,1321,1324,1324,1326,1327,1328,1330,1335,1348,1350,1351,1353,1355,1357,1357,1361,1365,1367,1368,1372,1374,1377,1383,1385,1388,1390,1390,1393,1393,1397,1398,1398,1398,1401,1402,1404,1405,1406,1407,1410,1410,1412,1412,1413,1414,1416,1416,1416,1416,1417,1418,1419,1423,1423,1428,1430,1432,1432,1433,1435,1436,1437,1438,1441,1441,1444,1444,1445,1449,1449,1449,1453,1457,1464,1466,1467,1469,1472,1475,1475,1478,1480,1485,1488,1488,1488,1489,1491,1493,1499,1500,1500,1500,1504,1505,1507,1508,1509,1510,1512,1512,1516,1519,1522,1528,1530,1532,1532,1538,1540,1540,1543,1545,1546,1548,1551,1553,1554,1555,1555,1561,1562,1563,1564,1565,1565,1569,1570,1570,1571,1572,1572,1577,1580,1580,1589,1589,1596,1599,1600,1600,1600,1600,1601,1602,1603,1607,1609,1610,1617,1618,1623,1623,1624,1626,1628,1629,1629,1630,1634,1637,1637,1637,1642,1645,1646,1646,1647,1647,1652,1657,1660,1662,1663,1666,1666,1667,1669,1670,1673,1675,1675,1677,1678,1678,1684,1686,1691,1691,1692,1694,1694,1697,1700,1700,1703,1704,1706,1706,1714,1715,1720,1720,1720,1720,1721,1721,1723,1725,1726,1728,1730,1730,1732,1733,1736,1739,1742,1744,1744,1752,1758,1759,1760,1764,1765,1766,1767,1769,1769,1773,1773,1773,1774,1775,1775,1775,1780,1783,1785,1785,1790,1791,1792,1793,1793,1795,1800,1803,1805,1807,1808,1811,1811,1811,1812,1812,1815,1816,1818,1819,1820,1821,1822,1823,1827,1828,1829,1830,1832,1835,1835,1835,1837,1839,1843,1843,1846,1849,1849,1849,1849,1851,1853,1853,1853,1854,1855,1861,1863,1865,1868,1870,1873,1878,1879,1881,1881,1881,1883,1883,1884,1885,1887,1889,1890,1891,1891,1894,1895,1896,1898,1899,1899,1901,1902,1904,1906,1907,1912,1912,1914,1914,1915,1917,1920,1921,1924,1926,1928,1930,1930,1931,1932,1933,1934,1934,1935,1936,1942,1943,1944,1947,1947,1948,1950,1951,1952,1953,1954,1956,1956,1957,1963,1964,1965,1966,1968,1968,1970,1971,1973,1979,1979,1981,1982,1986,1986,1986,1989,1992,1992,1998,1998,1999,1999,1999,2000]\n[1,1,2,4,7,10,10,11,17,24,26,26,27,28,32,33,33,35,35,35,37,37,37,38,40,41,45,48,50,50,53,53,54,55,55,55,56,57,63,66,68,71,76,79,81,81,82,83,85,88,89,91,95,96,100,102,103,104,104,105,107,107,108,109,109,112,116,118,118,118,119,119,120,121,123,124,124,127,128,128,128,130,132,134,134,140,141,141,143,143,144,147,148,150,150,152,153,155,156,157,164,166,166,167,167,168,176,178,184,185,190,191,191,192,193,194,197,199,201,201,204,207,207,211,211,216,225,225,228,229,233,234,235,237,237,237,238,239,239,244,247,248,248,251,251,254,258,259,259,261,263,266,268,269,269,269,269,271,281,282,285,285,286,287,292,293,295,295,295,296,300,300,302,305,305,305,309,310,310,310,311,318,319,319,320,320,321,321,322,328,329,332,333,334,335,336,336,339,339,339,341,341,345,346,346,347,348,348,349,349,349,350,351,351,355,356,361,363,363,364,366,366,367,368,368,371,371,373,377,380,381,381,382,384,384,387,387,389,394,395,399,400,402,406,406,407,407,410,415,418,419,424,427,433,434,436,437,442,444,445,451,455,455,456,457,459,461,462,463,464,464,465,465,465,467,468,469,473,476,476,476,480,482,483,486,488,489,490,493,495,495,496,496,497,499,499,500,502,504,505,509,509,511,511,516,516,517,521,523,525,526,528,528,530,534,534,535,538,538,541,541,544,544,544,544,546,547,550,550,551,553,555,556,556,557,558,558,559,561,563,567,569,569,570,571,571,572,574,574,575,575,578,582,583,583,584,584,586,590,592,592,594,595,596,598,598,598,601,603,603,604,612,617,618,620,620,624,626,627,628,631,635,637,637,638,641,645,650,651,652,653,654,657,659,659,661,661,661,661,662,663,663,664,664,665,666,669,670,670,671,675,676,683,684,688,689,689,689,690,691,692,694,695,695,696,697,697,700,705,705,707,708,708,709,709,710,710,712,714,716,716,716,718,721,722,722,723,724,725,728,728,729,730,735,735,737,737,741,741,744,747,748,749,750,751,751,754,754,755,757,757,759,759,761,763,763,763,764,766,767,771,771,777,778,778,778,781,782,782,786,786,786,787,787,787,790,790,790,791,792,792,793,801,803,804,805,805,805,805,807,808,808,808,810,815,817,819,819,822,829,829,830,832,832,834,834,836,836,836,837,842,843,844,846,846,847,847,847,850,851,852,853,853,854,854,855,855,858,860,863,864,866,866,867,871,875,881,883,883,886,888,888,890,891,892,894,897,903,913,914,915,918,918,919,920,920,922,923,925,927,927,927,927,928,937,943,943,943,946,948,949,950,953,954,958,966,968,968,971,979,980,981,983,984,985,985,987,987,990,991,992,992,992,997,999]\n[999,1000,1001,1001,1002,1005,1006,1008,1009,1011,1014,1014,1018,1019,1021,1026,1027,1031,1031,1032,1033,1034,1037,1038,1039,1041,1042,1043,1043,1043,1046,1049,1054,1055,1055,1058,1060,1064,1065,1065,1067,1067,1068,1074,1076,1076,1082,1082,1083,1084,1085,1086,1087,1094,1094,1095,1098,1101,1104,1104,1105,1105,1106,1106,1106,1107,1108,1112,1112,1113,1117,1118,1118,1119,1124,1124,1126,1126,1126,1130,1130,1132,1132,1133,1133,1134,1134,1136,1137,1139,1139,1139,1139,1139,1140,1141,1141,1141,1143,1144,1145,1147,1147,1150,1152,1153,1155,1157,1158,1159,1160,1161,1162,1163,1163,1165,1167,1167,1167,1167,1168,1168,1168,1168,1169,1171,1171,1172,1172,1173,1176,1177,1178,1178,1180,1181,1183,1184,1184,1185,1186,1186,1187,1188,1188,1189,1190,1191,1195,1196,1199,1200,1200,1201,1202,1206,1207,1208,1209,1211,1211,1212,1217,1221,1221,1222,1222,1224,1225,1226,1230,1230,1231,1232,1237,1237,1240,1243,1243,1243,1243,1243,1245,1245,1248,1248,1248,1249,1249,1253,1254,1255,1257,1258,1260,1265,1266,1268,1269,1270,1271,1271,1273,1274,1275,1277,1278,1279,1280,1281,1281,1283,1283,1284,1284,1286,1286,1287,1288,1288,1289,1290,1291,1292,1292,1295,1297,1298,1298,1299,1301,1302,1304,1306,1306,1307,1308,1310,1311,1312,1316,1316,1317,1318,1319,1320,1320,1321,1322,1324,1324,1324,1325,1327,1329,1330,1331,1331,1331,1332,1333,1333,1334,1336,1342,1345,1346,1347,1347,1349,1349,1350,1351,1352,1355,1355,1356,1357,1357,1362,1363,1364,1364,1364,1365,1370,1370,1372,1372,1374,1374,1375,1375,1376,1376,1378,1379,1379,1381,1382,1383,1384,1385,1386,1389,1391,1391,1391,1393,1394,1395,1397,1397,1401,1403,1405,1405,1406,1407,1407,1408,1409,1410,1413,1413,1416,1418,1418,1421,1422,1422,1424,1424,1425,1426,1428,1428,1429,1430,1434,1436,1439,1439,1439,1439,1440,1440,1441,1441,1442,1442,1442,1444,1445,1447,1447,1451,1451,1452,1456,1460,1462,1463,1468,1469,1469,1470,1470,1471,1472,1472,1474,1476,1478,1478,1482,1484,1486,1486,1488,1489,1489,1493,1494,1495,1495,1497,1498,1502,1503,1505,1506,1507,1507,1508,1511,1512,1513,1514,1515,1516,1518,1520,1520,1520,1522,1523,1525,1525,1527,1527,1528,1531,1531,1532,1533,1534,1535,1537,1538,1540,1540,1541,1543,1543,1544,1545,1546,1548,1549,1551,1551,1552,1552,1552,1553,1556,1556,1557,1557,1557,1559,1559,1560,1561,1561,1562,1564,1564,1564,1564,1566,1566,1567,1571,1571,1572,1573,1573,1574,1574,1577,1577,1583,1584,1584,1588,1589,1590,1593,1593,1595,1596,1596,1596,1597,1598,1601,1604,1604,1606,1606,1607,1607,1610,1610,1611,1611,1612,1612,1614,1615,1616,1617,1621,1622,1622,1622,1623,1626,1627,1631,1632,1636,1637,1637,1638,1640,1642,1642,1644,1645,1647,1648,1650,1651,1652,1653,1655,1655,1656,1656,1656,1656,1658,1658,1658,1660,1660,1663,1664,1665,1666,1667,1667,1667,1669,1669,1670,1676,1678,1680,1681,1681,1682,1684,1684,1685,1686,1686,1687,1689,1689,1689,1690,1693,1694,1698,1700,1702,1703,1706,1708,1708,1708,1710,1712,1712,1712,1713,1715,1715,1717,1719,1719,1720,1720,1721,1722,1722,1724,1731,1732,1734,1734,1737,1737,1741,1743,1743,1749,1749,1751,1753,1754,1754,1756,1757,1757,1758,1759,1761,1761,1762,1764,1766,1766,1767,1769,1769,1771,1772,1772,1775,1775,1775,1777,1779,1779,1781,1782,1782,1783,1786,1788,1788,1788,1790,1793,1793,1793,1793,1794,1795,1795,1796,1796,1796,1797,1799,1800,1803,1810,1811,1814,1814,1814,1816,1817,1819,1820,1820,1822,1824,1826,1826,1826,1827,1828,1828,1831,1832,1834,1835,1836,1837,1838,1838,1841,1843,1849,1851,1851,1852,1852,1853,1853,1854,1854,1856,1858,1859,1863,1863,1863,1869,1871,1872,1872,1873,1874,1879,1880,1881,1881,1882,1883,1883,1883,1885,1885,1885,1886,1887,1887,1889,1894,1898,1899,1901,1902,1903,1904,1907,1908,1910,1911,1911,1911,1913,1914,1914,1915,1916,1917,1918,1921,1922,1923,1923,1924,1926,1926,1933,1933,1934,1934,1934,1936,1938,1938,1939,1939,1941,1941,1942,1942,1947,1947,1947,1947,1949,1949,1952,1954,1955,1957,1958,1959,1960,1960,1963,1964,1964,1964,1966,1968,1971,1973,1975,1977,1978,1978,1979,1979,1980,1981,1981,1982,1984,1985,1985,1987,1987,1987,1987,1987,1988,1989,1990,1991,1994,1994,1995,1996,1997,1997,1998]\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this help](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e)s and makes thinks clear\\nand do clap \\uD83D\\uDC4F to appreciate the article"
                    },
                    {
                        "username": "pwho",
                        "content": "If you\\'re going to share an article here, don\\'t hide it behind a paywall. =\\\\"
                    },
                    {
                        "username": "user5979vk",
                        "content": "Thanks (https://archive.is/E2agn)"
                    },
                    {
                        "username": "4alisha",
                        "content": "very helpful\\uD83D\\uDC4F"
                    },
                    {
                        "username": "thecodingkid",
                        "content": "Any help would be appreciated if you could explain why the solution in the O(log(min(m,n))) case requires a swap if the second array is smaller.\\n\\nIf you could specify any edge case that is failing , that would be of great help."
                    },
                    {
                        "username": "bparanj",
                        "content": "Swapping nums1 and nums2 if nums1 is larger than nums2 is a trick to simplify the problem by reducing it to a condition where we always binary search on the smaller array. This doesn\\'t change the result because the median of two arrays doesn\\'t depend on which array is longer, but it makes the code cleaner and easier to understand, and it also improves performance by minimizing the search space.\\n\\nMoreover, this technique ensures that we do not run into an index out of bounds error during our binary search process. \\n\\nLet\\'s consider an edge case where the swapping would be important:\\n\\nnums1 = [6, 7, 8, 9, 10]\\nnums2 = [1, 2, 3]\\n\\nIf we did not swap, and started the binary search on nums1, we would end up exploring unnecessary parts of nums1 that wouldn\\'t impact the final result, since we know that the median must be within the range covered by nums2 due to its smaller size and range of values. \\n\\nIf we swap and binary search on nums2, we can find the median more efficiently because we focus on the smaller range of values. We then only need to compare with a few specific elements of nums1.\\n\\nTo summarize, the swap is used to ensure efficiency and simplicity by always performing binary search on the smaller array."
                    }
                ]
            },
            {
                "id": 1575243,
                "content": [
                    {
                        "username": "yon",
                        "content": "Input:\\t[1,1], [1,2]\\nExpected:\\t1.00000\\n\\nMy solution way is merge [1,1] and [1,2] to [1,2], so the answer would be (1+2)/2 = 1.5\\nWhat did I made wrong?"
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "you first merge it (preserving duplicates).\\n[1, 1, 1, 2]\\n\\nWhats the middle element here?\\noh wait. there are two elements at the middle. 1 and 1.\\nso you average em. \\n(1 + 1) / 2 = 1"
                    },
                    {
                        "username": "RISHIKA_GANDHI",
                        "content": "change your (1+2)/2 to this (1+2)/2.0 you will get you result into float/double type"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "the merged array will we [1,1,1,2] ,\\nno of elements are even so median will we (1+1)/2=1.\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the hell nooo. median is 1 here"
                    },
                    {
                        "username": "hankIgoe",
                        "content": "the merged string is [1,1,1,2], so the median is (1+1)/2 = 1.0\\n"
                    },
                    {
                        "username": "vyshnusanthosh",
                        "content": "If you are using java, when two integers are divided the answer will also be an integer in order to get floating point you need to type cast the integers to double or float before division."
                    },
                    {
                        "username": "megazortti",
                        "content": "i\\'m facing the same problem..\\n"
                    },
                    {
                        "username": "khushal1201",
                        "content": "[@zwicky](/zwicky) the merged array should be [1,1,1,2]. Hence the median would be (1+1)/2 = 1."
                    },
                    {
                        "username": "zwicky",
                        "content": "you shouldn\\'t remove duplicates"
                    },
                    {
                        "username": "hing_liu",
                        "content": "Let try to interate the algorithm first:\\n\\nIt is basically a k-th smallest element problem between two sorted arrays, let assume we have the following two arrays:\\n\\n5,7,8,11\\n4,9,12,14\\n\\nk = 4 (expected ans = 8 because when it is sorted: 4,5,7,**8**,9,11,12,14)\\n\\nStep 1: Cut the two arrays into two pieces such that the left side will have total items of 4 (i.e. the **K=4**)\\n5,7 | 8, 11\\n4,9 | 12, 14\\n\\nStep 2: We remove [5,7] because its end index at the left side is smaller (7. v.s 9) and we update K = 2 (since we removed 2 item=> K - 2 = 4 - 2 = 2), it will becomes:\\n8,11 <-- removed [5,7]\\n4,9,12,14\\n\\n(basically the rest of the steps below is to repeat 1 and 2 until K = 1)\\n\\nStep 3: Repeat Step 1, Cut into two half base on **K = 2**\\n8 | 11\\n4 | 9 12 14\\n\\nStep 4: Repeat Step 2, that is remove 4 and update **K = 1** (since we removed 1 item=>K-1 = 2-1 1)\\n\\nStep 5: Repeat Step 1, Cut into two half base on K = 1, since K = 1 is not able to split (we have two arrays, don\\'t know how to split), we conclude the solution as the minimum of the first item of the two array, that is min(8,9) = 8\\n8,11\\n9,12,14\\n\\nWe are all done, how about K = 3 initially? Basically the point of \\'cut\\' is K/2 - 1, therefore when K = 3, the cutting point is index=0, let us go though this again quickly for this:\\n\\nK=3\\n5|7,8,11\\n4|9,12,14\\n\\nK=2\\n5|7,8,11\\n9|12,14\\n\\nK=1\\n7|8,11\\n9|12,14 \\nAns=min(7,9) = 7\\n\\nThere is some edge case not tell here, this is just a general idea. We want to have the first K-th item, so, the first target is to collect the first K item from the two array, so we fairly cut them at K/2 - 1 and remove the smaller list until K = 1.\\n\\nThis might be still hard to understand, consider we are not greedy, we do it one by one (we don\\'t cut base on K, but always cut by two):\\n\\nK=4\\n5 | 7 8 11\\n4 | 9 12 14\\n\\nAt this point, we remove the smaller one and have:\\nK=3\\n5 | 7 8 11\\n9 | 12 14\\n\\nKeep doing this until K = 1\\nK=2\\n7 | 8 11\\n9 | 12 14\\n\\nK = 1\\n8 | 11\\n9 | 12 14\\n(at this point, all done)\\n\\nWe are now reaching the answer = 8 by doing this in one-by-one manner, the cutting point at this \\'slow-version\\' is always [0], and the faster version is doing the cutting point at [k/2 - 1], that still work because they are sorted, it is safe to jump further and remove the whole preceding items rather than doing this one-by-one manner.\\n\\nAgain, this might still be hard to convince yourself why the \\'faster-version\\' has no issue, just hope this can help you understand more.\\n\\nGoing back to tell why it is a k-th minimum issue, consider when we have ths int kth(arr1, arr2, k) function, we can put k to be the middle of sizeof(arr1) and sizeof(arr2), if it is even number of size we just get the adjacent (run kth function two times) so we can get the middle two and divide it by 2, so the answer ..."
                    },
                    {
                        "username": "rds8rds",
                        "content": "thanks properly understand the concept!"
                    },
                    {
                        "username": "parismania",
                        "content": "That\\'s quite a good explanation. Thank you!"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I tried to avoid this question for as long as possible"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally solved this by merging the two arrays. I always intended to do the proper solution - one day. Today is the day."
                    },
                    {
                        "username": "raviTejaY",
                        "content": "\\tvar findMedianSortedArrays = function(nums1, nums2) {\\n  \\tlet mid;\\n\\t  let res = [...nums1, ...nums2].sort((a,b) => a-b);\\n\\t mid = (res.length-1)/2;\\n\\t  if(res.length % 2 === 1){\\n\\t\\treturn res[mid].toFixed(5);\\n\\t  } else {\\n\\t\\tlet median = (res[Math.floor(mid)] + res[Math.ceil(mid)]) / 2;\\n\\t\\treturn median.toFixed(5)\\n\\t  }\\n\\t};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, you use .sort(), which does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "hongbin2",
                        "content": "My naive solution is just merge two array and find the median. Obvious we can do better. But I just have no idea about it."
                    },
                    {
                        "username": "aneesfathimasaifudeen",
                        "content": "Input\\n[1,2]\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000\\n\\nThis test case always fails for me in leetcode, whereas it works for me in my machine\\'s python compiler with the same code.\\n\\nCan anyone tell, what would be the problem here?"
                    },
                    {
                        "username": "evenn",
                        "content": "choose Python3 rather than Python to execute code"
                    },
                    {
                        "username": "kapilkapuriya",
                        "content": "[@jeetu16](/jeetu16)  use type cast when you perform   ** ans = a/2 **  so do like this  **  ans = double(a)/2 ** "
                    },
                    {
                        "username": "doubleshab",
                        "content": "[@jeetu16](/jeetu16) I had a similar problem using Python3. For me, the issue was that the math I was using to generate my index values was producing float values. By forcing them to integer types using the int() builtin, I was able to get around it."
                    },
                    {
                        "username": "python_is_cheat_code",
                        "content": "Facing the same issue. Have no idea what to do."
                    },
                    {
                        "username": "AtrijPaul",
                        "content": "If you are coding in Java then division of two integers will be integer only , after performing the division it get stored as double. So instead of dividing by 2 , divide by 2.0 , it will work."
                    },
                    {
                        "username": "jeetu16",
                        "content": "have you found the solution till now?\\ni faced the same problem"
                    },
                    {
                        "username": "scott40",
                        "content": "The question states: \"There are two sorted arrays nums1 and nums2 of size m and n respectively.\" This does not tell me whether the sort order is largest to smallest, or smallest to largest. It would even be possible for nums1 to be sorted largest to smallest while nums2 is sorted from smallest to largest. So I thought we would need to be able to handle such cases, making no assumptions as to the direction of the sorts. As a test case of opposite sort directions in the inputs I tried:\\n[10,8,3]\\n[5,9,17]\\n\\nBoth input lists sorted as required, but in opposite directions. The median here should be 8.5, but when I ran the test case it gave me an expected answer of 6.5. So I think leetcode is making an assumption about the sort directions of the inputs that should not be made, and it is not designed to properly handle this case. What are we allowed to assume about the input sort direction?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement does not explicitly mention the sort order. However, it is conventionally assumed that, unless stated otherwise, a \"sorted\" array or list is in non-decreasing order, meaning from smallest to largest. This assumption is consistent with most problems and discussions involving sorted data in computer science and mathematics.\\n\\nTherefore, in the context of this problem, you can assume that both input arrays are sorted in non-decreasing order. This assumption informs the approach to solving the problem. If the arrays were sorted in non-increasing order or if one array was sorted in increasing order while the other in decreasing order, a different approach might be necessary.\\n\\nHowever, if the problem were to handle arrays sorted in either direction, a pre-processing step could be added to sort the arrays in the desired order before proceeding with the rest of the algorithm. This would increase the time complexity, though, because sorting is generally an O(n log n) operation."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit before validating your solution against a few edge cases, e.g.\n```\n[-932210,-932056,-922328,-917451,-913929,-907514,-883337,-802571,-739964,-709048,-692863,-690427,-679691,-666576,-643630,-638229,-585992,-574362,-571309,-541584,-538138,-497470,-480909,-459608,-444410,-426022,-403497,-393857,-363379,-359219,-347291,-330378,-314805,-303621,-291243,-251965,-244657,-243891,-236303,-234099,-217309,-210326,-199139,-197450,-177317,-172519,-170556,-137069,-128436,-113727,-95170,-79317,-52534,-4681,40199,89215,107649,109238,124507,157189,162498,180216,200111,228032,251189,262426,319119,323615,344264,345305,373566,399588,411387,427092,427955,456725,461974,468467,474372,476390,562956,577916,580839,591862,616385,638656,650816,653650,672517,753495,769837,779299,801738,809541,836250,872512,917419,949439,959386,979587]\n[]\n[]\n[-999311,-995487,-993598,-993127,-989482,-973229,-926998,-898485,-851725,-850712,-836433,-795269,-784476,-764197,-763427,-756479,-755190,-753600,-717158,-677976,-668634,-640052,-597569,-589282,-520481,-515063,-499955,-479622,-477302,-473002,-403966,-400582,-388037,-363473,-344547,-324788,-320701,-314920,-296000,-290463,-276432,-273513,-244152,-215671,-192226,-184426,-128230,-122297,-75423,-58001,-8481,2993,27765,54297,64282,81674,93781,96008,152144,154165,166583,169777,181118,191164,216155,263473,271293,308484,360932,380484,405656,413389,432913,436707,461128,530274,555172,576238,595665,608718,624952,644037,684003,697121,727400,730624,751135,768207,784915,792103,809755,831583,832823,844259,886508,913559,941025,950966,975298]\n[-999567,-997502,-997320,-997131,-995209,-993605,-991650,-991613,-991417,-990564,-989776,-987550,-985870,-985386,-982368,-981518,-979842,-979718,-978628,-976620,-974345,-973518,-972291,-967402,-967265,-966730,-965785,-962771,-961174,-960505,-959719,-955802,-955134,-953099,-948117,-944790,-941695,-941693,-939131,-938510,-937577,-937038,-935074,-933558,-933056,-930614,-929544,-924799,-922049,-920262,-919703,-917939,-916145,-915636,-914995,-913579,-896888,-894679,-894651,-891943,-891618,-891260,-888315,-886543,-884101,-883513,-872873,-872826,-872120,-871050,-870232,-869805,-868351,-867330,-866646,-866243,-863978,-863009,-859149,-858906,-858758,-854975,-852689,-852164,-851427,-850218,-847970,-845912,-845486,-844687,-844411,-843956,-843353,-839477,-837499,-836703,-833607,-831373,-830358,-827611,-827276,-827145,-827057,-825816,-823331,-822868,-822693,-821423,-820561,-819808,-815340,-814889,-814639,-814554,-813263,-811601,-810742,-810567,-808592,-807943,-805362,-805085,-803725,-798929,-792149,-789206,-785856,-783704,-783011,-781163,-775292,-772930,-769271,-764889,-764165,-763180,-758264,-756607,-755921,-752956,-752637,-751864,-751318,-750878,-750246,-749003,-746825,-744464,-744367,-743637,-741289,-738903,-736545,-732164,-731981,-731878,-730164,-727779,-725497,-725433,-720206,-715719,-714089,-707566,-705091,-705008,-705000,-699566,-696000,-694414,-689552,-688092,-683083,-681058,-680084,-676059,-675854,-675730,-672990,-671402,-669298,-669292,-667660,-667250,-662853,-660122,-658209,-657793,-657002,-656472,-653603,-647017,-643156,-642765,-642520,-638572,-637837,-636344,-635145,-629818,-628344,-624890,-622582,-621602,-619124,-617701,-616391,-613542,-609069,-605811,-604133,-603960,-602075,-601936,-601600,-599041,-598358,-597574,-597092,-596147,-594696,-592955,-592300,-591877,-591829,-591201,-589912,-584118,-583933,-574753,-567021,-566697,-565332,-564305,-562776,-561152,-557378,-553247,-551405,-541292,-536736,-533881,-533615,-532784,-531029,-530553,-527184,-526662,-525823,-525625,-525093,-520969,-520545,-515036,-510919,-507746,-504592,-504032,-503595,-501437,-499214,-496301,-494795,-490284,-486646,-485513,-484383,-480751,-476832,-476559,-474296,-469572,-469152,-468659,-466347,-462419,-460567,-458882,-457050,-454911,-453624,-452324,-450481,-449509,-440836,-439940,-436508,-434347,-431863,-426890,-422954,-422337,-419891,-419812,-419313,-415360,-413516,-410195,-409526,-409454,-408360,-408054,-406101,-404269,-401590,-400963,-394836,-385314,-375836,-374995,-374048,-368693,-368131,-367859,-361397,-360458,-356055,-354270,-354227,-346946,-346223,-346099,-345855,-344808,-344247,-343806,-342087,-339682,-338497,-335912,-334945,-330597,-328200,-327450,-323098,-320641,-319061,-316787,-314312,-314133,-313427,-313020,-311735,-311556,-308652,-307950,-307902,-305049,-304780,-304200,-301782,-301539,-296853,-296489,-293520,-285339,-284857,-284262,-283709,-282070,-281202,-281164,-277190,-276021,-274641,-273757,-273728,-270394,-269087,-265427,-265272,-264115,-263447,-262116,-259606,-257673,-257419,-257235,-257127,-257053,-256900,-256146,-255547,-253986,-249576,-249079,-245481,-239011,-235597,-230997,-228005,-227497,-227250,-226380,-225431,-216611,-210008,-208956,-208838,-201921,-199428,-196686,-191696,-190547,-189199,-188847,-188753,-186418,-185773,-185206,-182706,-180515,-179348,-178474,-175203,-174731,-173012,-173012,-171115,-170095,-168308,-168128,-166905,-166742,-164733,-164448,-158590,-157720,-156014,-155429,-153638,-149375,-148870,-148098,-147945,-145512,-145183,-141591,-139964,-137213,-134488,-133486,-132424,-131215,-130615,-125187,-124332,-117324,-113085,-112523,-111751,-111383,-104409,-104344,-102517,-102161,-98185,-97846,-91902,-89723,-84742,-84067,-83948,-82603,-82579,-78160,-76854,-75430,-75344,-74962,-71408,-69102,-66641,-65642,-64757,-61211,-60329,-57886,-53220,-52898,-49270,-49124,-48080,-45815,-44789,-37626,-34882,-34859,-32485,-31102,-29729,-24983,-22453,-20259,-16334,-16193,-15026,-12533,-11486,-9861,-4017,-404,704,6117,7576,8139,8688,16526,17499,22574,25852,26549,29362,30492,33676,37645,40152,43767,44242,46314,47444,50651,52396,53898,59922,60919,63930,68755,69424,70153,71709,73909,75531,75770,77643,78793,81457,83544,85477,89943,91011,91041,91192,94363,94670,95048,96537,98525,98539,104346,107800,108042,109819,110121,115691,117048,118363,118924,120311,125092,127555,127995,128168,135729,138889,140152,140261,140971,145327,145731,145860,152322,155692,159510,161250,163594,164930,166753,167883,168915,172982,173783,174795,175457,179314,180491,180628,189221,190490,190611,193586,195760,199322,201329,202231,202971,205732,206448,209484,210079,213383,213627,214223,215757,218866,223260,224593,225505,228101,229883,232562,234221,235355,236464,236563,238608,240104,242362,242959,245209,246122,246173,249953,255505,258524,260918,261968,262033,262830,263342,263665,265410,265772,266591,268471,270067,274107,276862,277801,277848,278505,278931,279516,285322,286378,293299,294255,296317,296787,297292,300002,302027,302121,302296,304390,304403,306514,311250,311643,316657,317008,319056,320827,322849,324605,326098,326173,326315,326588,328330,329876,330948,331341,331948,332124,341297,341942,343708,344436,344659,350897,351495,351893,352596,353479,355046,356056,357088,357742,358398,360172,365218,372048,375602,376611,382420,386919,389469,391011,392771,396046,403823,404843,407192,409690,410139,411497,418925,419472,419584,420171,421967,425637,428244,428593,429601,430662,431024,432899,434667,438639,438690,438839,441713,443399,449585,454891,459572,461567,464223,464977,468031,468216,468980,469952,471601,473590,476517,477804,478040,479232,481442,482516,487561,489198,493596,494509,498310,500634,502180,503663,504932,507455,511419,515818,517896,518474,520182,520335,520403,520452,523949,524745,525015,526693,531560,536815,536885,536922,537002,537675,541832,543158,547884,548488,549711,559134,559481,559820,560772,560870,561935,563399,563985,568956,569744,570203,573437,574202,574696,578813,579430,588576,588747,590647,604861,606852,606861,607746,608154,609468,609523,611937,611965,612112,614230,619688,620348,621041,621873,622766,633850,636410,645785,647203,647468,648663,651250,653354,655650,655736,656313,656473,660352,665886,668634,668889,668947,670032,670182,670412,673826,686025,686683,691645,692054,692284,695765,697395,697829,702166,708541,709011,711141,712520,714573,716618,721072,721706,721848,721884,722339,722954,724012,724181,726931,729781,730450,732815,734038,734313,735874,736725,737913,738002,740812,743047,744545,745638,746517,747495,747721,754971,755927,760296,760368,768237,770512,771998,772642,773928,775652,776009,776528,778433,784050,788493,788662,790251,794398,797252,797470,798288,800465,801126,806618,807774,810900,812412,812864,815004,819410,819576,821429,822144,828766,831814,834893,834987,838359,839232,839741,845812,846318,851048,851400,852080,856264,859668,861457,862611,863385,867019,872146,872332,877196,879288,879573,883230,888081,889012,889628,889844,890313,891004,891633,897234,900619,901180,901991,904976,905449,905491,905566,906218,906325,911636,912008,912597,917627,919382,921003,924181,925430,925724,925947,929266,934039,935863,937145,938405,941714,945193,946019,948295,950933,951602,951856,952469,953824,954207,954485,954748,959150,960644,962815,963477,963549,963815,964638,965098,967348,967682,969084,971079,973452,974228,976702,976910,978359,981049,982811,982859,987419,993386,994771,995167,996051,998221]\n[-987944,-969636,-969382,-963918,-960334,-957471,-955419,-954534,-949617,-948164,-941370,-934887,-933385,-933024,-925395,-920598,-914952,-912930,-910713,-898551,-897943,-895093,-883721,-881114,-868961,-862108,-859224,-844995,-843122,-841350,-839681,-837319,-833916,-832929,-824567,-821404,-817679,-816414,-815142,-814794,-814428,-812717,-803053,-800629,-791874,-784923,-776546,-772543,-770170,-769595,-767768,-764581,-760610,-755916,-750060,-738122,-734792,-733242,-728895,-725665,-725507,-718134,-717075,-715534,-715202,-713373,-712097,-708739,-707414,-706871,-703365,-702017,-693735,-683042,-672054,-669261,-668919,-664791,-661728,-660926,-656147,-645420,-643702,-643193,-641435,-638420,-634551,-628772,-615960,-603372,-601747,-598111,-594931,-589739,-582816,-582756,-578800,-578594,-573174,-567081,-559766,-559620,-556681,-554084,-553002,-549693,-548262,-545226,-544969,-537261,-533737,-528123,-520081,-506744,-504736,-499021,-496520,-496470,-495274,-493267,-486175,-485863,-484654,-482183,-481473,-479689,-476360,-474984,-474568,-470604,-469841,-458033,-456643,-456026,-449361,-448407,-447725,-446572,-444202,-444122,-438385,-438174,-436049,-433511,-429215,-428895,-423500,-419598,-414944,-413779,-413601,-413134,-395813,-386542,-386081,-384022,-383217,-377664,-375237,-370842,-368652,-368619,-367534,-360286,-359315,-356864,-346574,-344238,-342362,-338322,-337904,-317031,-315369,-311471,-307529,-291585,-288367,-282217,-273392,-268202,-266384,-262947,-261304,-259484,-253107,-253097,-247496,-240183,-238502,-232673,-225567,-225273,-220556,-218540,-217405,-209508,-209191,-198492,-196102,-194657,-187900,-187654,-187409,-183298,-183195,-178895,-172948,-164463,-150912,-150447,-147157,-146039,-142859,-142513,-141007,-140514,-133632,-121672,-120655,-111524,-106570,-104308,-101032,-100077,-99330,-98302,-93625,-88734,-88072,-87928,-84357,-71659,-69515,-67676,-63282,-58552,-56529,-55822,-52857,-49183,-49096,-36632,-35822,-22044,-15543,-13193,-11327,-8347,-5921,367,2667,4951,5292,12503,13977,16698,20683,21104,29329,29383,32131,36676,38796,38939,39209,47231,48354,58584,63004,67608,68400,79071,80602,81795,86542,94114,101023,103400,104656,104880,111548,112896,115766,121077,122734,127019,127444,132932,138051,140440,154194,158884,165068,166138,166908,169497,170785,171990,179699,180030,188999,195927,197727,215034,218444,219489,222687,224521,235464,235727,241470,243528,246904,258231,259122,260441,263591,265308,267313,269450,272354,272547,274104,276239,278349,282844,283153,284414,285344,292275,301326,301817,303601,305996,308758,308841,318258,318758,326276,328210,328413,329591,330688,335804,336586,338827,350724,353017,355893,356488,358137,367458,369246,373776,375814,388619,389665,391494,398826,410285,414310,434616,436368,437657,441921,442891,443722,445197,448982,449981,452442,455491,458606,458789,459482,459977,460011,467293,480680,484432,486822,491840,495107,498402,498655,499730,501125,506371,507661,508352,508531,510705,517473,521451,521763,531020,535521,536548,538401,543120,545936,546904,551503,551845,552061,557919,565312,566269,568604,574239,574420,578570,579251,582167,587488,592161,594286,604994,619288,622829,629325,652728,657554,659113,659971,661630,664091,664280,667722,673155,674069,675252,680792,683874,685152,698652,701722,703282,708464,710121,710242,712200,718611,720934,732059,736885,739191,742494,750812,759987,772722,776392,782107,782131,783537,783996,785898,793147,799555,806418,807432,808677,831974,841540,844398,849513,849656,854080,855359,858674,865625,866262,870340,877863,886981,896266,898306,900880,903869,907452,914307,916336,916960,922084,923604,924431,926571,930085,935193,948240,948473,954648,957779,959463,960134,960965,975144,979240,997354,999899]\n[0,2,3,4,4,6,6,7,8,8,8,8,11,11,15,16,17,20,22,26,26,28,29,30,31,32,36,39,40,41,41,44,45,52,52,53,54,56,57,62,70,71,72,74,78,78,80,80,83,84,86,87,88,90,91,92,92,96,99,104,105,106,110,110,112,113,113,115,116,118,119,121,121,123,124,125,125,129,129,131,131,134,135,140,141,141,143,144,145,145,145,150,152,153,154,157,158,159,159,159,164,164,169,172,176,176,177,178,178,184,185,189,189,190,191,192,193,193,194,194,195,196,196,200,203,204,205,206,210,211,211,212,212,213,216,219,220,222,225,226,229,229,233,234,237,238,239,241,243,243,246,246,248,249,249,250,250,251,253,255,256,258,260,260,262,266,268,268,269,271,272,273,273,280,281,282,283,288,288,295,296,296,298,302,304,305,305,305,305,306,306,308,309,310,312,313,315,315,318,318,319,319,321,322,323,324,324,326,329,329,329,331,331,333,333,334,334,336,339,339,340,341,341,343,344,348,351,351,352,353,354,354,358,359,363,364,364,365,367,367,368,369,370,372,372,373,376,376,378,379,379,381,382,383,385,386,391,391,391,394,396,399,400,411,414,414,414,416,423,429,429,430,430,431,435,436,437,438,442,443,444,447,448,452,452,452,452,452,455,456,457,457,462,466,468,468,468,472,472,472,472,473,473,475,476,476,477,477,480,481,481,482,483,483,484,485,485,486,486,491,491,491,491,492,494,495,497,497,500,502,503,505,505,509,510,514,515,515,515,516,516,518,519,519,520,522,524,525,527,528,529,531,534,537,537,540,543,543,544,544,545,549,552,552,556,558,558,565,565,566,569,570,571,572,575,577,577,578,579,579,581,583,584,586,586,590,591,593,597,603,603,605,607,608,611,613,614,622,622,622,623,631,631,633,635,638,638,639,642,643,644,645,646,649,652,653,653,654,655,655,655,655,657,659,660,661,664,665,666,667,671,682,684,685,686,688,691,692,694,694,696,698,699,702,704,704,704,706,706,709,710,713,713,714,717,723,725,726,727,727,729,730,730,732,732,733,734,738,740,740,741,746,750,751,751,755,755,758,759,759,760,764,765,767,769,771,773,774,775,776,779,779,781,782,785,797,797,798,798,798,802,803,804,804,806,807,808,809,809,810,810,812,814,814,818,819,820,822,822,823,824,826,826,826,827,830,831,833,833,833,834,837,838,838,839,840,840,841,844,844,847,848,851,852,853,854,857,860,862,864,868,868,869,870,872,874,880,881,881,883,884,885,888,889,892,892,896,897,897,898,899,901,904,905,907,908,914,914,915,915,916,918,920,921,921,921,927,927,928,928,929,932,932,932,932,933,937,937,938,939,940,941,941,942,942,942,944,945,945,946,947,948,952,952,955,956,960,962,964,964,966,968,968,968,971,973,973,973,974,978,979,979,981,982,983,985,985,989,990,990,990,993,994,994,995,998,999,999,1000]\n[999,999,1002,1003,1003,1004,1007,1010,1016,1016,1016,1020,1020,1022,1022,1024,1024,1027,1035,1038,1038,1041,1043,1044,1054,1055,1060,1064,1066,1067,1069,1070,1070,1071,1074,1074,1075,1081,1081,1087,1090,1092,1092,1094,1095,1095,1096,1097,1097,1098,1099,1103,1103,1103,1104,1104,1104,1105,1105,1108,1109,1109,1112,1112,1113,1116,1117,1117,1117,1117,1119,1121,1122,1124,1124,1125,1129,1129,1130,1131,1133,1133,1133,1135,1139,1140,1142,1142,1143,1144,1145,1146,1146,1148,1149,1151,1151,1151,1151,1152,1153,1153,1158,1159,1161,1164,1167,1171,1172,1173,1174,1176,1178,1178,1179,1180,1181,1182,1182,1183,1183,1185,1185,1186,1188,1189,1191,1192,1195,1200,1201,1201,1203,1204,1206,1207,1208,1208,1209,1210,1212,1212,1215,1216,1217,1222,1224,1225,1226,1226,1229,1230,1232,1232,1239,1241,1241,1243,1243,1244,1249,1252,1255,1256,1257,1263,1266,1266,1266,1270,1272,1274,1274,1280,1281,1288,1288,1288,1291,1291,1292,1296,1299,1301,1304,1304,1305,1306,1307,1310,1311,1311,1311,1312,1313,1313,1315,1315,1315,1319,1320,1321,1321,1321,1324,1324,1326,1327,1328,1330,1335,1348,1350,1351,1353,1355,1357,1357,1361,1365,1367,1368,1372,1374,1377,1383,1385,1388,1390,1390,1393,1393,1397,1398,1398,1398,1401,1402,1404,1405,1406,1407,1410,1410,1412,1412,1413,1414,1416,1416,1416,1416,1417,1418,1419,1423,1423,1428,1430,1432,1432,1433,1435,1436,1437,1438,1441,1441,1444,1444,1445,1449,1449,1449,1453,1457,1464,1466,1467,1469,1472,1475,1475,1478,1480,1485,1488,1488,1488,1489,1491,1493,1499,1500,1500,1500,1504,1505,1507,1508,1509,1510,1512,1512,1516,1519,1522,1528,1530,1532,1532,1538,1540,1540,1543,1545,1546,1548,1551,1553,1554,1555,1555,1561,1562,1563,1564,1565,1565,1569,1570,1570,1571,1572,1572,1577,1580,1580,1589,1589,1596,1599,1600,1600,1600,1600,1601,1602,1603,1607,1609,1610,1617,1618,1623,1623,1624,1626,1628,1629,1629,1630,1634,1637,1637,1637,1642,1645,1646,1646,1647,1647,1652,1657,1660,1662,1663,1666,1666,1667,1669,1670,1673,1675,1675,1677,1678,1678,1684,1686,1691,1691,1692,1694,1694,1697,1700,1700,1703,1704,1706,1706,1714,1715,1720,1720,1720,1720,1721,1721,1723,1725,1726,1728,1730,1730,1732,1733,1736,1739,1742,1744,1744,1752,1758,1759,1760,1764,1765,1766,1767,1769,1769,1773,1773,1773,1774,1775,1775,1775,1780,1783,1785,1785,1790,1791,1792,1793,1793,1795,1800,1803,1805,1807,1808,1811,1811,1811,1812,1812,1815,1816,1818,1819,1820,1821,1822,1823,1827,1828,1829,1830,1832,1835,1835,1835,1837,1839,1843,1843,1846,1849,1849,1849,1849,1851,1853,1853,1853,1854,1855,1861,1863,1865,1868,1870,1873,1878,1879,1881,1881,1881,1883,1883,1884,1885,1887,1889,1890,1891,1891,1894,1895,1896,1898,1899,1899,1901,1902,1904,1906,1907,1912,1912,1914,1914,1915,1917,1920,1921,1924,1926,1928,1930,1930,1931,1932,1933,1934,1934,1935,1936,1942,1943,1944,1947,1947,1948,1950,1951,1952,1953,1954,1956,1956,1957,1963,1964,1965,1966,1968,1968,1970,1971,1973,1979,1979,1981,1982,1986,1986,1986,1989,1992,1992,1998,1998,1999,1999,1999,2000]\n[1,1,2,4,7,10,10,11,17,24,26,26,27,28,32,33,33,35,35,35,37,37,37,38,40,41,45,48,50,50,53,53,54,55,55,55,56,57,63,66,68,71,76,79,81,81,82,83,85,88,89,91,95,96,100,102,103,104,104,105,107,107,108,109,109,112,116,118,118,118,119,119,120,121,123,124,124,127,128,128,128,130,132,134,134,140,141,141,143,143,144,147,148,150,150,152,153,155,156,157,164,166,166,167,167,168,176,178,184,185,190,191,191,192,193,194,197,199,201,201,204,207,207,211,211,216,225,225,228,229,233,234,235,237,237,237,238,239,239,244,247,248,248,251,251,254,258,259,259,261,263,266,268,269,269,269,269,271,281,282,285,285,286,287,292,293,295,295,295,296,300,300,302,305,305,305,309,310,310,310,311,318,319,319,320,320,321,321,322,328,329,332,333,334,335,336,336,339,339,339,341,341,345,346,346,347,348,348,349,349,349,350,351,351,355,356,361,363,363,364,366,366,367,368,368,371,371,373,377,380,381,381,382,384,384,387,387,389,394,395,399,400,402,406,406,407,407,410,415,418,419,424,427,433,434,436,437,442,444,445,451,455,455,456,457,459,461,462,463,464,464,465,465,465,467,468,469,473,476,476,476,480,482,483,486,488,489,490,493,495,495,496,496,497,499,499,500,502,504,505,509,509,511,511,516,516,517,521,523,525,526,528,528,530,534,534,535,538,538,541,541,544,544,544,544,546,547,550,550,551,553,555,556,556,557,558,558,559,561,563,567,569,569,570,571,571,572,574,574,575,575,578,582,583,583,584,584,586,590,592,592,594,595,596,598,598,598,601,603,603,604,612,617,618,620,620,624,626,627,628,631,635,637,637,638,641,645,650,651,652,653,654,657,659,659,661,661,661,661,662,663,663,664,664,665,666,669,670,670,671,675,676,683,684,688,689,689,689,690,691,692,694,695,695,696,697,697,700,705,705,707,708,708,709,709,710,710,712,714,716,716,716,718,721,722,722,723,724,725,728,728,729,730,735,735,737,737,741,741,744,747,748,749,750,751,751,754,754,755,757,757,759,759,761,763,763,763,764,766,767,771,771,777,778,778,778,781,782,782,786,786,786,787,787,787,790,790,790,791,792,792,793,801,803,804,805,805,805,805,807,808,808,808,810,815,817,819,819,822,829,829,830,832,832,834,834,836,836,836,837,842,843,844,846,846,847,847,847,850,851,852,853,853,854,854,855,855,858,860,863,864,866,866,867,871,875,881,883,883,886,888,888,890,891,892,894,897,903,913,914,915,918,918,919,920,920,922,923,925,927,927,927,927,928,937,943,943,943,946,948,949,950,953,954,958,966,968,968,971,979,980,981,983,984,985,985,987,987,990,991,992,992,992,997,999]\n[999,1000,1001,1001,1002,1005,1006,1008,1009,1011,1014,1014,1018,1019,1021,1026,1027,1031,1031,1032,1033,1034,1037,1038,1039,1041,1042,1043,1043,1043,1046,1049,1054,1055,1055,1058,1060,1064,1065,1065,1067,1067,1068,1074,1076,1076,1082,1082,1083,1084,1085,1086,1087,1094,1094,1095,1098,1101,1104,1104,1105,1105,1106,1106,1106,1107,1108,1112,1112,1113,1117,1118,1118,1119,1124,1124,1126,1126,1126,1130,1130,1132,1132,1133,1133,1134,1134,1136,1137,1139,1139,1139,1139,1139,1140,1141,1141,1141,1143,1144,1145,1147,1147,1150,1152,1153,1155,1157,1158,1159,1160,1161,1162,1163,1163,1165,1167,1167,1167,1167,1168,1168,1168,1168,1169,1171,1171,1172,1172,1173,1176,1177,1178,1178,1180,1181,1183,1184,1184,1185,1186,1186,1187,1188,1188,1189,1190,1191,1195,1196,1199,1200,1200,1201,1202,1206,1207,1208,1209,1211,1211,1212,1217,1221,1221,1222,1222,1224,1225,1226,1230,1230,1231,1232,1237,1237,1240,1243,1243,1243,1243,1243,1245,1245,1248,1248,1248,1249,1249,1253,1254,1255,1257,1258,1260,1265,1266,1268,1269,1270,1271,1271,1273,1274,1275,1277,1278,1279,1280,1281,1281,1283,1283,1284,1284,1286,1286,1287,1288,1288,1289,1290,1291,1292,1292,1295,1297,1298,1298,1299,1301,1302,1304,1306,1306,1307,1308,1310,1311,1312,1316,1316,1317,1318,1319,1320,1320,1321,1322,1324,1324,1324,1325,1327,1329,1330,1331,1331,1331,1332,1333,1333,1334,1336,1342,1345,1346,1347,1347,1349,1349,1350,1351,1352,1355,1355,1356,1357,1357,1362,1363,1364,1364,1364,1365,1370,1370,1372,1372,1374,1374,1375,1375,1376,1376,1378,1379,1379,1381,1382,1383,1384,1385,1386,1389,1391,1391,1391,1393,1394,1395,1397,1397,1401,1403,1405,1405,1406,1407,1407,1408,1409,1410,1413,1413,1416,1418,1418,1421,1422,1422,1424,1424,1425,1426,1428,1428,1429,1430,1434,1436,1439,1439,1439,1439,1440,1440,1441,1441,1442,1442,1442,1444,1445,1447,1447,1451,1451,1452,1456,1460,1462,1463,1468,1469,1469,1470,1470,1471,1472,1472,1474,1476,1478,1478,1482,1484,1486,1486,1488,1489,1489,1493,1494,1495,1495,1497,1498,1502,1503,1505,1506,1507,1507,1508,1511,1512,1513,1514,1515,1516,1518,1520,1520,1520,1522,1523,1525,1525,1527,1527,1528,1531,1531,1532,1533,1534,1535,1537,1538,1540,1540,1541,1543,1543,1544,1545,1546,1548,1549,1551,1551,1552,1552,1552,1553,1556,1556,1557,1557,1557,1559,1559,1560,1561,1561,1562,1564,1564,1564,1564,1566,1566,1567,1571,1571,1572,1573,1573,1574,1574,1577,1577,1583,1584,1584,1588,1589,1590,1593,1593,1595,1596,1596,1596,1597,1598,1601,1604,1604,1606,1606,1607,1607,1610,1610,1611,1611,1612,1612,1614,1615,1616,1617,1621,1622,1622,1622,1623,1626,1627,1631,1632,1636,1637,1637,1638,1640,1642,1642,1644,1645,1647,1648,1650,1651,1652,1653,1655,1655,1656,1656,1656,1656,1658,1658,1658,1660,1660,1663,1664,1665,1666,1667,1667,1667,1669,1669,1670,1676,1678,1680,1681,1681,1682,1684,1684,1685,1686,1686,1687,1689,1689,1689,1690,1693,1694,1698,1700,1702,1703,1706,1708,1708,1708,1710,1712,1712,1712,1713,1715,1715,1717,1719,1719,1720,1720,1721,1722,1722,1724,1731,1732,1734,1734,1737,1737,1741,1743,1743,1749,1749,1751,1753,1754,1754,1756,1757,1757,1758,1759,1761,1761,1762,1764,1766,1766,1767,1769,1769,1771,1772,1772,1775,1775,1775,1777,1779,1779,1781,1782,1782,1783,1786,1788,1788,1788,1790,1793,1793,1793,1793,1794,1795,1795,1796,1796,1796,1797,1799,1800,1803,1810,1811,1814,1814,1814,1816,1817,1819,1820,1820,1822,1824,1826,1826,1826,1827,1828,1828,1831,1832,1834,1835,1836,1837,1838,1838,1841,1843,1849,1851,1851,1852,1852,1853,1853,1854,1854,1856,1858,1859,1863,1863,1863,1869,1871,1872,1872,1873,1874,1879,1880,1881,1881,1882,1883,1883,1883,1885,1885,1885,1886,1887,1887,1889,1894,1898,1899,1901,1902,1903,1904,1907,1908,1910,1911,1911,1911,1913,1914,1914,1915,1916,1917,1918,1921,1922,1923,1923,1924,1926,1926,1933,1933,1934,1934,1934,1936,1938,1938,1939,1939,1941,1941,1942,1942,1947,1947,1947,1947,1949,1949,1952,1954,1955,1957,1958,1959,1960,1960,1963,1964,1964,1964,1966,1968,1971,1973,1975,1977,1978,1978,1979,1979,1980,1981,1981,1982,1984,1985,1985,1987,1987,1987,1987,1987,1988,1989,1990,1991,1994,1994,1995,1996,1997,1997,1998]\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this help](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e)s and makes thinks clear\\nand do clap \\uD83D\\uDC4F to appreciate the article"
                    },
                    {
                        "username": "pwho",
                        "content": "If you\\'re going to share an article here, don\\'t hide it behind a paywall. =\\\\"
                    },
                    {
                        "username": "user5979vk",
                        "content": "Thanks (https://archive.is/E2agn)"
                    },
                    {
                        "username": "4alisha",
                        "content": "very helpful\\uD83D\\uDC4F"
                    },
                    {
                        "username": "thecodingkid",
                        "content": "Any help would be appreciated if you could explain why the solution in the O(log(min(m,n))) case requires a swap if the second array is smaller.\\n\\nIf you could specify any edge case that is failing , that would be of great help."
                    },
                    {
                        "username": "bparanj",
                        "content": "Swapping nums1 and nums2 if nums1 is larger than nums2 is a trick to simplify the problem by reducing it to a condition where we always binary search on the smaller array. This doesn\\'t change the result because the median of two arrays doesn\\'t depend on which array is longer, but it makes the code cleaner and easier to understand, and it also improves performance by minimizing the search space.\\n\\nMoreover, this technique ensures that we do not run into an index out of bounds error during our binary search process. \\n\\nLet\\'s consider an edge case where the swapping would be important:\\n\\nnums1 = [6, 7, 8, 9, 10]\\nnums2 = [1, 2, 3]\\n\\nIf we did not swap, and started the binary search on nums1, we would end up exploring unnecessary parts of nums1 that wouldn\\'t impact the final result, since we know that the median must be within the range covered by nums2 due to its smaller size and range of values. \\n\\nIf we swap and binary search on nums2, we can find the median more efficiently because we focus on the smaller range of values. We then only need to compare with a few specific elements of nums1.\\n\\nTo summarize, the swap is used to ensure efficiency and simplicity by always performing binary search on the smaller array."
                    }
                ]
            },
            {
                "id": 2066414,
                "content": [
                    {
                        "username": "yon",
                        "content": "Input:\\t[1,1], [1,2]\\nExpected:\\t1.00000\\n\\nMy solution way is merge [1,1] and [1,2] to [1,2], so the answer would be (1+2)/2 = 1.5\\nWhat did I made wrong?"
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "you first merge it (preserving duplicates).\\n[1, 1, 1, 2]\\n\\nWhats the middle element here?\\noh wait. there are two elements at the middle. 1 and 1.\\nso you average em. \\n(1 + 1) / 2 = 1"
                    },
                    {
                        "username": "RISHIKA_GANDHI",
                        "content": "change your (1+2)/2 to this (1+2)/2.0 you will get you result into float/double type"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "the merged array will we [1,1,1,2] ,\\nno of elements are even so median will we (1+1)/2=1.\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the hell nooo. median is 1 here"
                    },
                    {
                        "username": "hankIgoe",
                        "content": "the merged string is [1,1,1,2], so the median is (1+1)/2 = 1.0\\n"
                    },
                    {
                        "username": "vyshnusanthosh",
                        "content": "If you are using java, when two integers are divided the answer will also be an integer in order to get floating point you need to type cast the integers to double or float before division."
                    },
                    {
                        "username": "megazortti",
                        "content": "i\\'m facing the same problem..\\n"
                    },
                    {
                        "username": "khushal1201",
                        "content": "[@zwicky](/zwicky) the merged array should be [1,1,1,2]. Hence the median would be (1+1)/2 = 1."
                    },
                    {
                        "username": "zwicky",
                        "content": "you shouldn\\'t remove duplicates"
                    },
                    {
                        "username": "hing_liu",
                        "content": "Let try to interate the algorithm first:\\n\\nIt is basically a k-th smallest element problem between two sorted arrays, let assume we have the following two arrays:\\n\\n5,7,8,11\\n4,9,12,14\\n\\nk = 4 (expected ans = 8 because when it is sorted: 4,5,7,**8**,9,11,12,14)\\n\\nStep 1: Cut the two arrays into two pieces such that the left side will have total items of 4 (i.e. the **K=4**)\\n5,7 | 8, 11\\n4,9 | 12, 14\\n\\nStep 2: We remove [5,7] because its end index at the left side is smaller (7. v.s 9) and we update K = 2 (since we removed 2 item=> K - 2 = 4 - 2 = 2), it will becomes:\\n8,11 <-- removed [5,7]\\n4,9,12,14\\n\\n(basically the rest of the steps below is to repeat 1 and 2 until K = 1)\\n\\nStep 3: Repeat Step 1, Cut into two half base on **K = 2**\\n8 | 11\\n4 | 9 12 14\\n\\nStep 4: Repeat Step 2, that is remove 4 and update **K = 1** (since we removed 1 item=>K-1 = 2-1 1)\\n\\nStep 5: Repeat Step 1, Cut into two half base on K = 1, since K = 1 is not able to split (we have two arrays, don\\'t know how to split), we conclude the solution as the minimum of the first item of the two array, that is min(8,9) = 8\\n8,11\\n9,12,14\\n\\nWe are all done, how about K = 3 initially? Basically the point of \\'cut\\' is K/2 - 1, therefore when K = 3, the cutting point is index=0, let us go though this again quickly for this:\\n\\nK=3\\n5|7,8,11\\n4|9,12,14\\n\\nK=2\\n5|7,8,11\\n9|12,14\\n\\nK=1\\n7|8,11\\n9|12,14 \\nAns=min(7,9) = 7\\n\\nThere is some edge case not tell here, this is just a general idea. We want to have the first K-th item, so, the first target is to collect the first K item from the two array, so we fairly cut them at K/2 - 1 and remove the smaller list until K = 1.\\n\\nThis might be still hard to understand, consider we are not greedy, we do it one by one (we don\\'t cut base on K, but always cut by two):\\n\\nK=4\\n5 | 7 8 11\\n4 | 9 12 14\\n\\nAt this point, we remove the smaller one and have:\\nK=3\\n5 | 7 8 11\\n9 | 12 14\\n\\nKeep doing this until K = 1\\nK=2\\n7 | 8 11\\n9 | 12 14\\n\\nK = 1\\n8 | 11\\n9 | 12 14\\n(at this point, all done)\\n\\nWe are now reaching the answer = 8 by doing this in one-by-one manner, the cutting point at this \\'slow-version\\' is always [0], and the faster version is doing the cutting point at [k/2 - 1], that still work because they are sorted, it is safe to jump further and remove the whole preceding items rather than doing this one-by-one manner.\\n\\nAgain, this might still be hard to convince yourself why the \\'faster-version\\' has no issue, just hope this can help you understand more.\\n\\nGoing back to tell why it is a k-th minimum issue, consider when we have ths int kth(arr1, arr2, k) function, we can put k to be the middle of sizeof(arr1) and sizeof(arr2), if it is even number of size we just get the adjacent (run kth function two times) so we can get the middle two and divide it by 2, so the answer ..."
                    },
                    {
                        "username": "rds8rds",
                        "content": "thanks properly understand the concept!"
                    },
                    {
                        "username": "parismania",
                        "content": "That\\'s quite a good explanation. Thank you!"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I tried to avoid this question for as long as possible"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally solved this by merging the two arrays. I always intended to do the proper solution - one day. Today is the day."
                    },
                    {
                        "username": "raviTejaY",
                        "content": "\\tvar findMedianSortedArrays = function(nums1, nums2) {\\n  \\tlet mid;\\n\\t  let res = [...nums1, ...nums2].sort((a,b) => a-b);\\n\\t mid = (res.length-1)/2;\\n\\t  if(res.length % 2 === 1){\\n\\t\\treturn res[mid].toFixed(5);\\n\\t  } else {\\n\\t\\tlet median = (res[Math.floor(mid)] + res[Math.ceil(mid)]) / 2;\\n\\t\\treturn median.toFixed(5)\\n\\t  }\\n\\t};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, you use .sort(), which does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "hongbin2",
                        "content": "My naive solution is just merge two array and find the median. Obvious we can do better. But I just have no idea about it."
                    },
                    {
                        "username": "aneesfathimasaifudeen",
                        "content": "Input\\n[1,2]\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000\\n\\nThis test case always fails for me in leetcode, whereas it works for me in my machine\\'s python compiler with the same code.\\n\\nCan anyone tell, what would be the problem here?"
                    },
                    {
                        "username": "evenn",
                        "content": "choose Python3 rather than Python to execute code"
                    },
                    {
                        "username": "kapilkapuriya",
                        "content": "[@jeetu16](/jeetu16)  use type cast when you perform   ** ans = a/2 **  so do like this  **  ans = double(a)/2 ** "
                    },
                    {
                        "username": "doubleshab",
                        "content": "[@jeetu16](/jeetu16) I had a similar problem using Python3. For me, the issue was that the math I was using to generate my index values was producing float values. By forcing them to integer types using the int() builtin, I was able to get around it."
                    },
                    {
                        "username": "python_is_cheat_code",
                        "content": "Facing the same issue. Have no idea what to do."
                    },
                    {
                        "username": "AtrijPaul",
                        "content": "If you are coding in Java then division of two integers will be integer only , after performing the division it get stored as double. So instead of dividing by 2 , divide by 2.0 , it will work."
                    },
                    {
                        "username": "jeetu16",
                        "content": "have you found the solution till now?\\ni faced the same problem"
                    },
                    {
                        "username": "scott40",
                        "content": "The question states: \"There are two sorted arrays nums1 and nums2 of size m and n respectively.\" This does not tell me whether the sort order is largest to smallest, or smallest to largest. It would even be possible for nums1 to be sorted largest to smallest while nums2 is sorted from smallest to largest. So I thought we would need to be able to handle such cases, making no assumptions as to the direction of the sorts. As a test case of opposite sort directions in the inputs I tried:\\n[10,8,3]\\n[5,9,17]\\n\\nBoth input lists sorted as required, but in opposite directions. The median here should be 8.5, but when I ran the test case it gave me an expected answer of 6.5. So I think leetcode is making an assumption about the sort directions of the inputs that should not be made, and it is not designed to properly handle this case. What are we allowed to assume about the input sort direction?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement does not explicitly mention the sort order. However, it is conventionally assumed that, unless stated otherwise, a \"sorted\" array or list is in non-decreasing order, meaning from smallest to largest. This assumption is consistent with most problems and discussions involving sorted data in computer science and mathematics.\\n\\nTherefore, in the context of this problem, you can assume that both input arrays are sorted in non-decreasing order. This assumption informs the approach to solving the problem. If the arrays were sorted in non-increasing order or if one array was sorted in increasing order while the other in decreasing order, a different approach might be necessary.\\n\\nHowever, if the problem were to handle arrays sorted in either direction, a pre-processing step could be added to sort the arrays in the desired order before proceeding with the rest of the algorithm. This would increase the time complexity, though, because sorting is generally an O(n log n) operation."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit before validating your solution against a few edge cases, e.g.\n```\n[-932210,-932056,-922328,-917451,-913929,-907514,-883337,-802571,-739964,-709048,-692863,-690427,-679691,-666576,-643630,-638229,-585992,-574362,-571309,-541584,-538138,-497470,-480909,-459608,-444410,-426022,-403497,-393857,-363379,-359219,-347291,-330378,-314805,-303621,-291243,-251965,-244657,-243891,-236303,-234099,-217309,-210326,-199139,-197450,-177317,-172519,-170556,-137069,-128436,-113727,-95170,-79317,-52534,-4681,40199,89215,107649,109238,124507,157189,162498,180216,200111,228032,251189,262426,319119,323615,344264,345305,373566,399588,411387,427092,427955,456725,461974,468467,474372,476390,562956,577916,580839,591862,616385,638656,650816,653650,672517,753495,769837,779299,801738,809541,836250,872512,917419,949439,959386,979587]\n[]\n[]\n[-999311,-995487,-993598,-993127,-989482,-973229,-926998,-898485,-851725,-850712,-836433,-795269,-784476,-764197,-763427,-756479,-755190,-753600,-717158,-677976,-668634,-640052,-597569,-589282,-520481,-515063,-499955,-479622,-477302,-473002,-403966,-400582,-388037,-363473,-344547,-324788,-320701,-314920,-296000,-290463,-276432,-273513,-244152,-215671,-192226,-184426,-128230,-122297,-75423,-58001,-8481,2993,27765,54297,64282,81674,93781,96008,152144,154165,166583,169777,181118,191164,216155,263473,271293,308484,360932,380484,405656,413389,432913,436707,461128,530274,555172,576238,595665,608718,624952,644037,684003,697121,727400,730624,751135,768207,784915,792103,809755,831583,832823,844259,886508,913559,941025,950966,975298]\n[-999567,-997502,-997320,-997131,-995209,-993605,-991650,-991613,-991417,-990564,-989776,-987550,-985870,-985386,-982368,-981518,-979842,-979718,-978628,-976620,-974345,-973518,-972291,-967402,-967265,-966730,-965785,-962771,-961174,-960505,-959719,-955802,-955134,-953099,-948117,-944790,-941695,-941693,-939131,-938510,-937577,-937038,-935074,-933558,-933056,-930614,-929544,-924799,-922049,-920262,-919703,-917939,-916145,-915636,-914995,-913579,-896888,-894679,-894651,-891943,-891618,-891260,-888315,-886543,-884101,-883513,-872873,-872826,-872120,-871050,-870232,-869805,-868351,-867330,-866646,-866243,-863978,-863009,-859149,-858906,-858758,-854975,-852689,-852164,-851427,-850218,-847970,-845912,-845486,-844687,-844411,-843956,-843353,-839477,-837499,-836703,-833607,-831373,-830358,-827611,-827276,-827145,-827057,-825816,-823331,-822868,-822693,-821423,-820561,-819808,-815340,-814889,-814639,-814554,-813263,-811601,-810742,-810567,-808592,-807943,-805362,-805085,-803725,-798929,-792149,-789206,-785856,-783704,-783011,-781163,-775292,-772930,-769271,-764889,-764165,-763180,-758264,-756607,-755921,-752956,-752637,-751864,-751318,-750878,-750246,-749003,-746825,-744464,-744367,-743637,-741289,-738903,-736545,-732164,-731981,-731878,-730164,-727779,-725497,-725433,-720206,-715719,-714089,-707566,-705091,-705008,-705000,-699566,-696000,-694414,-689552,-688092,-683083,-681058,-680084,-676059,-675854,-675730,-672990,-671402,-669298,-669292,-667660,-667250,-662853,-660122,-658209,-657793,-657002,-656472,-653603,-647017,-643156,-642765,-642520,-638572,-637837,-636344,-635145,-629818,-628344,-624890,-622582,-621602,-619124,-617701,-616391,-613542,-609069,-605811,-604133,-603960,-602075,-601936,-601600,-599041,-598358,-597574,-597092,-596147,-594696,-592955,-592300,-591877,-591829,-591201,-589912,-584118,-583933,-574753,-567021,-566697,-565332,-564305,-562776,-561152,-557378,-553247,-551405,-541292,-536736,-533881,-533615,-532784,-531029,-530553,-527184,-526662,-525823,-525625,-525093,-520969,-520545,-515036,-510919,-507746,-504592,-504032,-503595,-501437,-499214,-496301,-494795,-490284,-486646,-485513,-484383,-480751,-476832,-476559,-474296,-469572,-469152,-468659,-466347,-462419,-460567,-458882,-457050,-454911,-453624,-452324,-450481,-449509,-440836,-439940,-436508,-434347,-431863,-426890,-422954,-422337,-419891,-419812,-419313,-415360,-413516,-410195,-409526,-409454,-408360,-408054,-406101,-404269,-401590,-400963,-394836,-385314,-375836,-374995,-374048,-368693,-368131,-367859,-361397,-360458,-356055,-354270,-354227,-346946,-346223,-346099,-345855,-344808,-344247,-343806,-342087,-339682,-338497,-335912,-334945,-330597,-328200,-327450,-323098,-320641,-319061,-316787,-314312,-314133,-313427,-313020,-311735,-311556,-308652,-307950,-307902,-305049,-304780,-304200,-301782,-301539,-296853,-296489,-293520,-285339,-284857,-284262,-283709,-282070,-281202,-281164,-277190,-276021,-274641,-273757,-273728,-270394,-269087,-265427,-265272,-264115,-263447,-262116,-259606,-257673,-257419,-257235,-257127,-257053,-256900,-256146,-255547,-253986,-249576,-249079,-245481,-239011,-235597,-230997,-228005,-227497,-227250,-226380,-225431,-216611,-210008,-208956,-208838,-201921,-199428,-196686,-191696,-190547,-189199,-188847,-188753,-186418,-185773,-185206,-182706,-180515,-179348,-178474,-175203,-174731,-173012,-173012,-171115,-170095,-168308,-168128,-166905,-166742,-164733,-164448,-158590,-157720,-156014,-155429,-153638,-149375,-148870,-148098,-147945,-145512,-145183,-141591,-139964,-137213,-134488,-133486,-132424,-131215,-130615,-125187,-124332,-117324,-113085,-112523,-111751,-111383,-104409,-104344,-102517,-102161,-98185,-97846,-91902,-89723,-84742,-84067,-83948,-82603,-82579,-78160,-76854,-75430,-75344,-74962,-71408,-69102,-66641,-65642,-64757,-61211,-60329,-57886,-53220,-52898,-49270,-49124,-48080,-45815,-44789,-37626,-34882,-34859,-32485,-31102,-29729,-24983,-22453,-20259,-16334,-16193,-15026,-12533,-11486,-9861,-4017,-404,704,6117,7576,8139,8688,16526,17499,22574,25852,26549,29362,30492,33676,37645,40152,43767,44242,46314,47444,50651,52396,53898,59922,60919,63930,68755,69424,70153,71709,73909,75531,75770,77643,78793,81457,83544,85477,89943,91011,91041,91192,94363,94670,95048,96537,98525,98539,104346,107800,108042,109819,110121,115691,117048,118363,118924,120311,125092,127555,127995,128168,135729,138889,140152,140261,140971,145327,145731,145860,152322,155692,159510,161250,163594,164930,166753,167883,168915,172982,173783,174795,175457,179314,180491,180628,189221,190490,190611,193586,195760,199322,201329,202231,202971,205732,206448,209484,210079,213383,213627,214223,215757,218866,223260,224593,225505,228101,229883,232562,234221,235355,236464,236563,238608,240104,242362,242959,245209,246122,246173,249953,255505,258524,260918,261968,262033,262830,263342,263665,265410,265772,266591,268471,270067,274107,276862,277801,277848,278505,278931,279516,285322,286378,293299,294255,296317,296787,297292,300002,302027,302121,302296,304390,304403,306514,311250,311643,316657,317008,319056,320827,322849,324605,326098,326173,326315,326588,328330,329876,330948,331341,331948,332124,341297,341942,343708,344436,344659,350897,351495,351893,352596,353479,355046,356056,357088,357742,358398,360172,365218,372048,375602,376611,382420,386919,389469,391011,392771,396046,403823,404843,407192,409690,410139,411497,418925,419472,419584,420171,421967,425637,428244,428593,429601,430662,431024,432899,434667,438639,438690,438839,441713,443399,449585,454891,459572,461567,464223,464977,468031,468216,468980,469952,471601,473590,476517,477804,478040,479232,481442,482516,487561,489198,493596,494509,498310,500634,502180,503663,504932,507455,511419,515818,517896,518474,520182,520335,520403,520452,523949,524745,525015,526693,531560,536815,536885,536922,537002,537675,541832,543158,547884,548488,549711,559134,559481,559820,560772,560870,561935,563399,563985,568956,569744,570203,573437,574202,574696,578813,579430,588576,588747,590647,604861,606852,606861,607746,608154,609468,609523,611937,611965,612112,614230,619688,620348,621041,621873,622766,633850,636410,645785,647203,647468,648663,651250,653354,655650,655736,656313,656473,660352,665886,668634,668889,668947,670032,670182,670412,673826,686025,686683,691645,692054,692284,695765,697395,697829,702166,708541,709011,711141,712520,714573,716618,721072,721706,721848,721884,722339,722954,724012,724181,726931,729781,730450,732815,734038,734313,735874,736725,737913,738002,740812,743047,744545,745638,746517,747495,747721,754971,755927,760296,760368,768237,770512,771998,772642,773928,775652,776009,776528,778433,784050,788493,788662,790251,794398,797252,797470,798288,800465,801126,806618,807774,810900,812412,812864,815004,819410,819576,821429,822144,828766,831814,834893,834987,838359,839232,839741,845812,846318,851048,851400,852080,856264,859668,861457,862611,863385,867019,872146,872332,877196,879288,879573,883230,888081,889012,889628,889844,890313,891004,891633,897234,900619,901180,901991,904976,905449,905491,905566,906218,906325,911636,912008,912597,917627,919382,921003,924181,925430,925724,925947,929266,934039,935863,937145,938405,941714,945193,946019,948295,950933,951602,951856,952469,953824,954207,954485,954748,959150,960644,962815,963477,963549,963815,964638,965098,967348,967682,969084,971079,973452,974228,976702,976910,978359,981049,982811,982859,987419,993386,994771,995167,996051,998221]\n[-987944,-969636,-969382,-963918,-960334,-957471,-955419,-954534,-949617,-948164,-941370,-934887,-933385,-933024,-925395,-920598,-914952,-912930,-910713,-898551,-897943,-895093,-883721,-881114,-868961,-862108,-859224,-844995,-843122,-841350,-839681,-837319,-833916,-832929,-824567,-821404,-817679,-816414,-815142,-814794,-814428,-812717,-803053,-800629,-791874,-784923,-776546,-772543,-770170,-769595,-767768,-764581,-760610,-755916,-750060,-738122,-734792,-733242,-728895,-725665,-725507,-718134,-717075,-715534,-715202,-713373,-712097,-708739,-707414,-706871,-703365,-702017,-693735,-683042,-672054,-669261,-668919,-664791,-661728,-660926,-656147,-645420,-643702,-643193,-641435,-638420,-634551,-628772,-615960,-603372,-601747,-598111,-594931,-589739,-582816,-582756,-578800,-578594,-573174,-567081,-559766,-559620,-556681,-554084,-553002,-549693,-548262,-545226,-544969,-537261,-533737,-528123,-520081,-506744,-504736,-499021,-496520,-496470,-495274,-493267,-486175,-485863,-484654,-482183,-481473,-479689,-476360,-474984,-474568,-470604,-469841,-458033,-456643,-456026,-449361,-448407,-447725,-446572,-444202,-444122,-438385,-438174,-436049,-433511,-429215,-428895,-423500,-419598,-414944,-413779,-413601,-413134,-395813,-386542,-386081,-384022,-383217,-377664,-375237,-370842,-368652,-368619,-367534,-360286,-359315,-356864,-346574,-344238,-342362,-338322,-337904,-317031,-315369,-311471,-307529,-291585,-288367,-282217,-273392,-268202,-266384,-262947,-261304,-259484,-253107,-253097,-247496,-240183,-238502,-232673,-225567,-225273,-220556,-218540,-217405,-209508,-209191,-198492,-196102,-194657,-187900,-187654,-187409,-183298,-183195,-178895,-172948,-164463,-150912,-150447,-147157,-146039,-142859,-142513,-141007,-140514,-133632,-121672,-120655,-111524,-106570,-104308,-101032,-100077,-99330,-98302,-93625,-88734,-88072,-87928,-84357,-71659,-69515,-67676,-63282,-58552,-56529,-55822,-52857,-49183,-49096,-36632,-35822,-22044,-15543,-13193,-11327,-8347,-5921,367,2667,4951,5292,12503,13977,16698,20683,21104,29329,29383,32131,36676,38796,38939,39209,47231,48354,58584,63004,67608,68400,79071,80602,81795,86542,94114,101023,103400,104656,104880,111548,112896,115766,121077,122734,127019,127444,132932,138051,140440,154194,158884,165068,166138,166908,169497,170785,171990,179699,180030,188999,195927,197727,215034,218444,219489,222687,224521,235464,235727,241470,243528,246904,258231,259122,260441,263591,265308,267313,269450,272354,272547,274104,276239,278349,282844,283153,284414,285344,292275,301326,301817,303601,305996,308758,308841,318258,318758,326276,328210,328413,329591,330688,335804,336586,338827,350724,353017,355893,356488,358137,367458,369246,373776,375814,388619,389665,391494,398826,410285,414310,434616,436368,437657,441921,442891,443722,445197,448982,449981,452442,455491,458606,458789,459482,459977,460011,467293,480680,484432,486822,491840,495107,498402,498655,499730,501125,506371,507661,508352,508531,510705,517473,521451,521763,531020,535521,536548,538401,543120,545936,546904,551503,551845,552061,557919,565312,566269,568604,574239,574420,578570,579251,582167,587488,592161,594286,604994,619288,622829,629325,652728,657554,659113,659971,661630,664091,664280,667722,673155,674069,675252,680792,683874,685152,698652,701722,703282,708464,710121,710242,712200,718611,720934,732059,736885,739191,742494,750812,759987,772722,776392,782107,782131,783537,783996,785898,793147,799555,806418,807432,808677,831974,841540,844398,849513,849656,854080,855359,858674,865625,866262,870340,877863,886981,896266,898306,900880,903869,907452,914307,916336,916960,922084,923604,924431,926571,930085,935193,948240,948473,954648,957779,959463,960134,960965,975144,979240,997354,999899]\n[0,2,3,4,4,6,6,7,8,8,8,8,11,11,15,16,17,20,22,26,26,28,29,30,31,32,36,39,40,41,41,44,45,52,52,53,54,56,57,62,70,71,72,74,78,78,80,80,83,84,86,87,88,90,91,92,92,96,99,104,105,106,110,110,112,113,113,115,116,118,119,121,121,123,124,125,125,129,129,131,131,134,135,140,141,141,143,144,145,145,145,150,152,153,154,157,158,159,159,159,164,164,169,172,176,176,177,178,178,184,185,189,189,190,191,192,193,193,194,194,195,196,196,200,203,204,205,206,210,211,211,212,212,213,216,219,220,222,225,226,229,229,233,234,237,238,239,241,243,243,246,246,248,249,249,250,250,251,253,255,256,258,260,260,262,266,268,268,269,271,272,273,273,280,281,282,283,288,288,295,296,296,298,302,304,305,305,305,305,306,306,308,309,310,312,313,315,315,318,318,319,319,321,322,323,324,324,326,329,329,329,331,331,333,333,334,334,336,339,339,340,341,341,343,344,348,351,351,352,353,354,354,358,359,363,364,364,365,367,367,368,369,370,372,372,373,376,376,378,379,379,381,382,383,385,386,391,391,391,394,396,399,400,411,414,414,414,416,423,429,429,430,430,431,435,436,437,438,442,443,444,447,448,452,452,452,452,452,455,456,457,457,462,466,468,468,468,472,472,472,472,473,473,475,476,476,477,477,480,481,481,482,483,483,484,485,485,486,486,491,491,491,491,492,494,495,497,497,500,502,503,505,505,509,510,514,515,515,515,516,516,518,519,519,520,522,524,525,527,528,529,531,534,537,537,540,543,543,544,544,545,549,552,552,556,558,558,565,565,566,569,570,571,572,575,577,577,578,579,579,581,583,584,586,586,590,591,593,597,603,603,605,607,608,611,613,614,622,622,622,623,631,631,633,635,638,638,639,642,643,644,645,646,649,652,653,653,654,655,655,655,655,657,659,660,661,664,665,666,667,671,682,684,685,686,688,691,692,694,694,696,698,699,702,704,704,704,706,706,709,710,713,713,714,717,723,725,726,727,727,729,730,730,732,732,733,734,738,740,740,741,746,750,751,751,755,755,758,759,759,760,764,765,767,769,771,773,774,775,776,779,779,781,782,785,797,797,798,798,798,802,803,804,804,806,807,808,809,809,810,810,812,814,814,818,819,820,822,822,823,824,826,826,826,827,830,831,833,833,833,834,837,838,838,839,840,840,841,844,844,847,848,851,852,853,854,857,860,862,864,868,868,869,870,872,874,880,881,881,883,884,885,888,889,892,892,896,897,897,898,899,901,904,905,907,908,914,914,915,915,916,918,920,921,921,921,927,927,928,928,929,932,932,932,932,933,937,937,938,939,940,941,941,942,942,942,944,945,945,946,947,948,952,952,955,956,960,962,964,964,966,968,968,968,971,973,973,973,974,978,979,979,981,982,983,985,985,989,990,990,990,993,994,994,995,998,999,999,1000]\n[999,999,1002,1003,1003,1004,1007,1010,1016,1016,1016,1020,1020,1022,1022,1024,1024,1027,1035,1038,1038,1041,1043,1044,1054,1055,1060,1064,1066,1067,1069,1070,1070,1071,1074,1074,1075,1081,1081,1087,1090,1092,1092,1094,1095,1095,1096,1097,1097,1098,1099,1103,1103,1103,1104,1104,1104,1105,1105,1108,1109,1109,1112,1112,1113,1116,1117,1117,1117,1117,1119,1121,1122,1124,1124,1125,1129,1129,1130,1131,1133,1133,1133,1135,1139,1140,1142,1142,1143,1144,1145,1146,1146,1148,1149,1151,1151,1151,1151,1152,1153,1153,1158,1159,1161,1164,1167,1171,1172,1173,1174,1176,1178,1178,1179,1180,1181,1182,1182,1183,1183,1185,1185,1186,1188,1189,1191,1192,1195,1200,1201,1201,1203,1204,1206,1207,1208,1208,1209,1210,1212,1212,1215,1216,1217,1222,1224,1225,1226,1226,1229,1230,1232,1232,1239,1241,1241,1243,1243,1244,1249,1252,1255,1256,1257,1263,1266,1266,1266,1270,1272,1274,1274,1280,1281,1288,1288,1288,1291,1291,1292,1296,1299,1301,1304,1304,1305,1306,1307,1310,1311,1311,1311,1312,1313,1313,1315,1315,1315,1319,1320,1321,1321,1321,1324,1324,1326,1327,1328,1330,1335,1348,1350,1351,1353,1355,1357,1357,1361,1365,1367,1368,1372,1374,1377,1383,1385,1388,1390,1390,1393,1393,1397,1398,1398,1398,1401,1402,1404,1405,1406,1407,1410,1410,1412,1412,1413,1414,1416,1416,1416,1416,1417,1418,1419,1423,1423,1428,1430,1432,1432,1433,1435,1436,1437,1438,1441,1441,1444,1444,1445,1449,1449,1449,1453,1457,1464,1466,1467,1469,1472,1475,1475,1478,1480,1485,1488,1488,1488,1489,1491,1493,1499,1500,1500,1500,1504,1505,1507,1508,1509,1510,1512,1512,1516,1519,1522,1528,1530,1532,1532,1538,1540,1540,1543,1545,1546,1548,1551,1553,1554,1555,1555,1561,1562,1563,1564,1565,1565,1569,1570,1570,1571,1572,1572,1577,1580,1580,1589,1589,1596,1599,1600,1600,1600,1600,1601,1602,1603,1607,1609,1610,1617,1618,1623,1623,1624,1626,1628,1629,1629,1630,1634,1637,1637,1637,1642,1645,1646,1646,1647,1647,1652,1657,1660,1662,1663,1666,1666,1667,1669,1670,1673,1675,1675,1677,1678,1678,1684,1686,1691,1691,1692,1694,1694,1697,1700,1700,1703,1704,1706,1706,1714,1715,1720,1720,1720,1720,1721,1721,1723,1725,1726,1728,1730,1730,1732,1733,1736,1739,1742,1744,1744,1752,1758,1759,1760,1764,1765,1766,1767,1769,1769,1773,1773,1773,1774,1775,1775,1775,1780,1783,1785,1785,1790,1791,1792,1793,1793,1795,1800,1803,1805,1807,1808,1811,1811,1811,1812,1812,1815,1816,1818,1819,1820,1821,1822,1823,1827,1828,1829,1830,1832,1835,1835,1835,1837,1839,1843,1843,1846,1849,1849,1849,1849,1851,1853,1853,1853,1854,1855,1861,1863,1865,1868,1870,1873,1878,1879,1881,1881,1881,1883,1883,1884,1885,1887,1889,1890,1891,1891,1894,1895,1896,1898,1899,1899,1901,1902,1904,1906,1907,1912,1912,1914,1914,1915,1917,1920,1921,1924,1926,1928,1930,1930,1931,1932,1933,1934,1934,1935,1936,1942,1943,1944,1947,1947,1948,1950,1951,1952,1953,1954,1956,1956,1957,1963,1964,1965,1966,1968,1968,1970,1971,1973,1979,1979,1981,1982,1986,1986,1986,1989,1992,1992,1998,1998,1999,1999,1999,2000]\n[1,1,2,4,7,10,10,11,17,24,26,26,27,28,32,33,33,35,35,35,37,37,37,38,40,41,45,48,50,50,53,53,54,55,55,55,56,57,63,66,68,71,76,79,81,81,82,83,85,88,89,91,95,96,100,102,103,104,104,105,107,107,108,109,109,112,116,118,118,118,119,119,120,121,123,124,124,127,128,128,128,130,132,134,134,140,141,141,143,143,144,147,148,150,150,152,153,155,156,157,164,166,166,167,167,168,176,178,184,185,190,191,191,192,193,194,197,199,201,201,204,207,207,211,211,216,225,225,228,229,233,234,235,237,237,237,238,239,239,244,247,248,248,251,251,254,258,259,259,261,263,266,268,269,269,269,269,271,281,282,285,285,286,287,292,293,295,295,295,296,300,300,302,305,305,305,309,310,310,310,311,318,319,319,320,320,321,321,322,328,329,332,333,334,335,336,336,339,339,339,341,341,345,346,346,347,348,348,349,349,349,350,351,351,355,356,361,363,363,364,366,366,367,368,368,371,371,373,377,380,381,381,382,384,384,387,387,389,394,395,399,400,402,406,406,407,407,410,415,418,419,424,427,433,434,436,437,442,444,445,451,455,455,456,457,459,461,462,463,464,464,465,465,465,467,468,469,473,476,476,476,480,482,483,486,488,489,490,493,495,495,496,496,497,499,499,500,502,504,505,509,509,511,511,516,516,517,521,523,525,526,528,528,530,534,534,535,538,538,541,541,544,544,544,544,546,547,550,550,551,553,555,556,556,557,558,558,559,561,563,567,569,569,570,571,571,572,574,574,575,575,578,582,583,583,584,584,586,590,592,592,594,595,596,598,598,598,601,603,603,604,612,617,618,620,620,624,626,627,628,631,635,637,637,638,641,645,650,651,652,653,654,657,659,659,661,661,661,661,662,663,663,664,664,665,666,669,670,670,671,675,676,683,684,688,689,689,689,690,691,692,694,695,695,696,697,697,700,705,705,707,708,708,709,709,710,710,712,714,716,716,716,718,721,722,722,723,724,725,728,728,729,730,735,735,737,737,741,741,744,747,748,749,750,751,751,754,754,755,757,757,759,759,761,763,763,763,764,766,767,771,771,777,778,778,778,781,782,782,786,786,786,787,787,787,790,790,790,791,792,792,793,801,803,804,805,805,805,805,807,808,808,808,810,815,817,819,819,822,829,829,830,832,832,834,834,836,836,836,837,842,843,844,846,846,847,847,847,850,851,852,853,853,854,854,855,855,858,860,863,864,866,866,867,871,875,881,883,883,886,888,888,890,891,892,894,897,903,913,914,915,918,918,919,920,920,922,923,925,927,927,927,927,928,937,943,943,943,946,948,949,950,953,954,958,966,968,968,971,979,980,981,983,984,985,985,987,987,990,991,992,992,992,997,999]\n[999,1000,1001,1001,1002,1005,1006,1008,1009,1011,1014,1014,1018,1019,1021,1026,1027,1031,1031,1032,1033,1034,1037,1038,1039,1041,1042,1043,1043,1043,1046,1049,1054,1055,1055,1058,1060,1064,1065,1065,1067,1067,1068,1074,1076,1076,1082,1082,1083,1084,1085,1086,1087,1094,1094,1095,1098,1101,1104,1104,1105,1105,1106,1106,1106,1107,1108,1112,1112,1113,1117,1118,1118,1119,1124,1124,1126,1126,1126,1130,1130,1132,1132,1133,1133,1134,1134,1136,1137,1139,1139,1139,1139,1139,1140,1141,1141,1141,1143,1144,1145,1147,1147,1150,1152,1153,1155,1157,1158,1159,1160,1161,1162,1163,1163,1165,1167,1167,1167,1167,1168,1168,1168,1168,1169,1171,1171,1172,1172,1173,1176,1177,1178,1178,1180,1181,1183,1184,1184,1185,1186,1186,1187,1188,1188,1189,1190,1191,1195,1196,1199,1200,1200,1201,1202,1206,1207,1208,1209,1211,1211,1212,1217,1221,1221,1222,1222,1224,1225,1226,1230,1230,1231,1232,1237,1237,1240,1243,1243,1243,1243,1243,1245,1245,1248,1248,1248,1249,1249,1253,1254,1255,1257,1258,1260,1265,1266,1268,1269,1270,1271,1271,1273,1274,1275,1277,1278,1279,1280,1281,1281,1283,1283,1284,1284,1286,1286,1287,1288,1288,1289,1290,1291,1292,1292,1295,1297,1298,1298,1299,1301,1302,1304,1306,1306,1307,1308,1310,1311,1312,1316,1316,1317,1318,1319,1320,1320,1321,1322,1324,1324,1324,1325,1327,1329,1330,1331,1331,1331,1332,1333,1333,1334,1336,1342,1345,1346,1347,1347,1349,1349,1350,1351,1352,1355,1355,1356,1357,1357,1362,1363,1364,1364,1364,1365,1370,1370,1372,1372,1374,1374,1375,1375,1376,1376,1378,1379,1379,1381,1382,1383,1384,1385,1386,1389,1391,1391,1391,1393,1394,1395,1397,1397,1401,1403,1405,1405,1406,1407,1407,1408,1409,1410,1413,1413,1416,1418,1418,1421,1422,1422,1424,1424,1425,1426,1428,1428,1429,1430,1434,1436,1439,1439,1439,1439,1440,1440,1441,1441,1442,1442,1442,1444,1445,1447,1447,1451,1451,1452,1456,1460,1462,1463,1468,1469,1469,1470,1470,1471,1472,1472,1474,1476,1478,1478,1482,1484,1486,1486,1488,1489,1489,1493,1494,1495,1495,1497,1498,1502,1503,1505,1506,1507,1507,1508,1511,1512,1513,1514,1515,1516,1518,1520,1520,1520,1522,1523,1525,1525,1527,1527,1528,1531,1531,1532,1533,1534,1535,1537,1538,1540,1540,1541,1543,1543,1544,1545,1546,1548,1549,1551,1551,1552,1552,1552,1553,1556,1556,1557,1557,1557,1559,1559,1560,1561,1561,1562,1564,1564,1564,1564,1566,1566,1567,1571,1571,1572,1573,1573,1574,1574,1577,1577,1583,1584,1584,1588,1589,1590,1593,1593,1595,1596,1596,1596,1597,1598,1601,1604,1604,1606,1606,1607,1607,1610,1610,1611,1611,1612,1612,1614,1615,1616,1617,1621,1622,1622,1622,1623,1626,1627,1631,1632,1636,1637,1637,1638,1640,1642,1642,1644,1645,1647,1648,1650,1651,1652,1653,1655,1655,1656,1656,1656,1656,1658,1658,1658,1660,1660,1663,1664,1665,1666,1667,1667,1667,1669,1669,1670,1676,1678,1680,1681,1681,1682,1684,1684,1685,1686,1686,1687,1689,1689,1689,1690,1693,1694,1698,1700,1702,1703,1706,1708,1708,1708,1710,1712,1712,1712,1713,1715,1715,1717,1719,1719,1720,1720,1721,1722,1722,1724,1731,1732,1734,1734,1737,1737,1741,1743,1743,1749,1749,1751,1753,1754,1754,1756,1757,1757,1758,1759,1761,1761,1762,1764,1766,1766,1767,1769,1769,1771,1772,1772,1775,1775,1775,1777,1779,1779,1781,1782,1782,1783,1786,1788,1788,1788,1790,1793,1793,1793,1793,1794,1795,1795,1796,1796,1796,1797,1799,1800,1803,1810,1811,1814,1814,1814,1816,1817,1819,1820,1820,1822,1824,1826,1826,1826,1827,1828,1828,1831,1832,1834,1835,1836,1837,1838,1838,1841,1843,1849,1851,1851,1852,1852,1853,1853,1854,1854,1856,1858,1859,1863,1863,1863,1869,1871,1872,1872,1873,1874,1879,1880,1881,1881,1882,1883,1883,1883,1885,1885,1885,1886,1887,1887,1889,1894,1898,1899,1901,1902,1903,1904,1907,1908,1910,1911,1911,1911,1913,1914,1914,1915,1916,1917,1918,1921,1922,1923,1923,1924,1926,1926,1933,1933,1934,1934,1934,1936,1938,1938,1939,1939,1941,1941,1942,1942,1947,1947,1947,1947,1949,1949,1952,1954,1955,1957,1958,1959,1960,1960,1963,1964,1964,1964,1966,1968,1971,1973,1975,1977,1978,1978,1979,1979,1980,1981,1981,1982,1984,1985,1985,1987,1987,1987,1987,1987,1988,1989,1990,1991,1994,1994,1995,1996,1997,1997,1998]\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this help](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e)s and makes thinks clear\\nand do clap \\uD83D\\uDC4F to appreciate the article"
                    },
                    {
                        "username": "pwho",
                        "content": "If you\\'re going to share an article here, don\\'t hide it behind a paywall. =\\\\"
                    },
                    {
                        "username": "user5979vk",
                        "content": "Thanks (https://archive.is/E2agn)"
                    },
                    {
                        "username": "4alisha",
                        "content": "very helpful\\uD83D\\uDC4F"
                    },
                    {
                        "username": "thecodingkid",
                        "content": "Any help would be appreciated if you could explain why the solution in the O(log(min(m,n))) case requires a swap if the second array is smaller.\\n\\nIf you could specify any edge case that is failing , that would be of great help."
                    },
                    {
                        "username": "bparanj",
                        "content": "Swapping nums1 and nums2 if nums1 is larger than nums2 is a trick to simplify the problem by reducing it to a condition where we always binary search on the smaller array. This doesn\\'t change the result because the median of two arrays doesn\\'t depend on which array is longer, but it makes the code cleaner and easier to understand, and it also improves performance by minimizing the search space.\\n\\nMoreover, this technique ensures that we do not run into an index out of bounds error during our binary search process. \\n\\nLet\\'s consider an edge case where the swapping would be important:\\n\\nnums1 = [6, 7, 8, 9, 10]\\nnums2 = [1, 2, 3]\\n\\nIf we did not swap, and started the binary search on nums1, we would end up exploring unnecessary parts of nums1 that wouldn\\'t impact the final result, since we know that the median must be within the range covered by nums2 due to its smaller size and range of values. \\n\\nIf we swap and binary search on nums2, we can find the median more efficiently because we focus on the smaller range of values. We then only need to compare with a few specific elements of nums1.\\n\\nTo summarize, the swap is used to ensure efficiency and simplicity by always performing binary search on the smaller array."
                    }
                ]
            },
            {
                "id": 1568752,
                "content": [
                    {
                        "username": "yon",
                        "content": "Input:\\t[1,1], [1,2]\\nExpected:\\t1.00000\\n\\nMy solution way is merge [1,1] and [1,2] to [1,2], so the answer would be (1+2)/2 = 1.5\\nWhat did I made wrong?"
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "you first merge it (preserving duplicates).\\n[1, 1, 1, 2]\\n\\nWhats the middle element here?\\noh wait. there are two elements at the middle. 1 and 1.\\nso you average em. \\n(1 + 1) / 2 = 1"
                    },
                    {
                        "username": "RISHIKA_GANDHI",
                        "content": "change your (1+2)/2 to this (1+2)/2.0 you will get you result into float/double type"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "the merged array will we [1,1,1,2] ,\\nno of elements are even so median will we (1+1)/2=1.\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the hell nooo. median is 1 here"
                    },
                    {
                        "username": "hankIgoe",
                        "content": "the merged string is [1,1,1,2], so the median is (1+1)/2 = 1.0\\n"
                    },
                    {
                        "username": "vyshnusanthosh",
                        "content": "If you are using java, when two integers are divided the answer will also be an integer in order to get floating point you need to type cast the integers to double or float before division."
                    },
                    {
                        "username": "megazortti",
                        "content": "i\\'m facing the same problem..\\n"
                    },
                    {
                        "username": "khushal1201",
                        "content": "[@zwicky](/zwicky) the merged array should be [1,1,1,2]. Hence the median would be (1+1)/2 = 1."
                    },
                    {
                        "username": "zwicky",
                        "content": "you shouldn\\'t remove duplicates"
                    },
                    {
                        "username": "hing_liu",
                        "content": "Let try to interate the algorithm first:\\n\\nIt is basically a k-th smallest element problem between two sorted arrays, let assume we have the following two arrays:\\n\\n5,7,8,11\\n4,9,12,14\\n\\nk = 4 (expected ans = 8 because when it is sorted: 4,5,7,**8**,9,11,12,14)\\n\\nStep 1: Cut the two arrays into two pieces such that the left side will have total items of 4 (i.e. the **K=4**)\\n5,7 | 8, 11\\n4,9 | 12, 14\\n\\nStep 2: We remove [5,7] because its end index at the left side is smaller (7. v.s 9) and we update K = 2 (since we removed 2 item=> K - 2 = 4 - 2 = 2), it will becomes:\\n8,11 <-- removed [5,7]\\n4,9,12,14\\n\\n(basically the rest of the steps below is to repeat 1 and 2 until K = 1)\\n\\nStep 3: Repeat Step 1, Cut into two half base on **K = 2**\\n8 | 11\\n4 | 9 12 14\\n\\nStep 4: Repeat Step 2, that is remove 4 and update **K = 1** (since we removed 1 item=>K-1 = 2-1 1)\\n\\nStep 5: Repeat Step 1, Cut into two half base on K = 1, since K = 1 is not able to split (we have two arrays, don\\'t know how to split), we conclude the solution as the minimum of the first item of the two array, that is min(8,9) = 8\\n8,11\\n9,12,14\\n\\nWe are all done, how about K = 3 initially? Basically the point of \\'cut\\' is K/2 - 1, therefore when K = 3, the cutting point is index=0, let us go though this again quickly for this:\\n\\nK=3\\n5|7,8,11\\n4|9,12,14\\n\\nK=2\\n5|7,8,11\\n9|12,14\\n\\nK=1\\n7|8,11\\n9|12,14 \\nAns=min(7,9) = 7\\n\\nThere is some edge case not tell here, this is just a general idea. We want to have the first K-th item, so, the first target is to collect the first K item from the two array, so we fairly cut them at K/2 - 1 and remove the smaller list until K = 1.\\n\\nThis might be still hard to understand, consider we are not greedy, we do it one by one (we don\\'t cut base on K, but always cut by two):\\n\\nK=4\\n5 | 7 8 11\\n4 | 9 12 14\\n\\nAt this point, we remove the smaller one and have:\\nK=3\\n5 | 7 8 11\\n9 | 12 14\\n\\nKeep doing this until K = 1\\nK=2\\n7 | 8 11\\n9 | 12 14\\n\\nK = 1\\n8 | 11\\n9 | 12 14\\n(at this point, all done)\\n\\nWe are now reaching the answer = 8 by doing this in one-by-one manner, the cutting point at this \\'slow-version\\' is always [0], and the faster version is doing the cutting point at [k/2 - 1], that still work because they are sorted, it is safe to jump further and remove the whole preceding items rather than doing this one-by-one manner.\\n\\nAgain, this might still be hard to convince yourself why the \\'faster-version\\' has no issue, just hope this can help you understand more.\\n\\nGoing back to tell why it is a k-th minimum issue, consider when we have ths int kth(arr1, arr2, k) function, we can put k to be the middle of sizeof(arr1) and sizeof(arr2), if it is even number of size we just get the adjacent (run kth function two times) so we can get the middle two and divide it by 2, so the answer ..."
                    },
                    {
                        "username": "rds8rds",
                        "content": "thanks properly understand the concept!"
                    },
                    {
                        "username": "parismania",
                        "content": "That\\'s quite a good explanation. Thank you!"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I tried to avoid this question for as long as possible"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally solved this by merging the two arrays. I always intended to do the proper solution - one day. Today is the day."
                    },
                    {
                        "username": "raviTejaY",
                        "content": "\\tvar findMedianSortedArrays = function(nums1, nums2) {\\n  \\tlet mid;\\n\\t  let res = [...nums1, ...nums2].sort((a,b) => a-b);\\n\\t mid = (res.length-1)/2;\\n\\t  if(res.length % 2 === 1){\\n\\t\\treturn res[mid].toFixed(5);\\n\\t  } else {\\n\\t\\tlet median = (res[Math.floor(mid)] + res[Math.ceil(mid)]) / 2;\\n\\t\\treturn median.toFixed(5)\\n\\t  }\\n\\t};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, you use .sort(), which does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "hongbin2",
                        "content": "My naive solution is just merge two array and find the median. Obvious we can do better. But I just have no idea about it."
                    },
                    {
                        "username": "aneesfathimasaifudeen",
                        "content": "Input\\n[1,2]\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000\\n\\nThis test case always fails for me in leetcode, whereas it works for me in my machine\\'s python compiler with the same code.\\n\\nCan anyone tell, what would be the problem here?"
                    },
                    {
                        "username": "evenn",
                        "content": "choose Python3 rather than Python to execute code"
                    },
                    {
                        "username": "kapilkapuriya",
                        "content": "[@jeetu16](/jeetu16)  use type cast when you perform   ** ans = a/2 **  so do like this  **  ans = double(a)/2 ** "
                    },
                    {
                        "username": "doubleshab",
                        "content": "[@jeetu16](/jeetu16) I had a similar problem using Python3. For me, the issue was that the math I was using to generate my index values was producing float values. By forcing them to integer types using the int() builtin, I was able to get around it."
                    },
                    {
                        "username": "python_is_cheat_code",
                        "content": "Facing the same issue. Have no idea what to do."
                    },
                    {
                        "username": "AtrijPaul",
                        "content": "If you are coding in Java then division of two integers will be integer only , after performing the division it get stored as double. So instead of dividing by 2 , divide by 2.0 , it will work."
                    },
                    {
                        "username": "jeetu16",
                        "content": "have you found the solution till now?\\ni faced the same problem"
                    },
                    {
                        "username": "scott40",
                        "content": "The question states: \"There are two sorted arrays nums1 and nums2 of size m and n respectively.\" This does not tell me whether the sort order is largest to smallest, or smallest to largest. It would even be possible for nums1 to be sorted largest to smallest while nums2 is sorted from smallest to largest. So I thought we would need to be able to handle such cases, making no assumptions as to the direction of the sorts. As a test case of opposite sort directions in the inputs I tried:\\n[10,8,3]\\n[5,9,17]\\n\\nBoth input lists sorted as required, but in opposite directions. The median here should be 8.5, but when I ran the test case it gave me an expected answer of 6.5. So I think leetcode is making an assumption about the sort directions of the inputs that should not be made, and it is not designed to properly handle this case. What are we allowed to assume about the input sort direction?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement does not explicitly mention the sort order. However, it is conventionally assumed that, unless stated otherwise, a \"sorted\" array or list is in non-decreasing order, meaning from smallest to largest. This assumption is consistent with most problems and discussions involving sorted data in computer science and mathematics.\\n\\nTherefore, in the context of this problem, you can assume that both input arrays are sorted in non-decreasing order. This assumption informs the approach to solving the problem. If the arrays were sorted in non-increasing order or if one array was sorted in increasing order while the other in decreasing order, a different approach might be necessary.\\n\\nHowever, if the problem were to handle arrays sorted in either direction, a pre-processing step could be added to sort the arrays in the desired order before proceeding with the rest of the algorithm. This would increase the time complexity, though, because sorting is generally an O(n log n) operation."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit before validating your solution against a few edge cases, e.g.\n```\n[-932210,-932056,-922328,-917451,-913929,-907514,-883337,-802571,-739964,-709048,-692863,-690427,-679691,-666576,-643630,-638229,-585992,-574362,-571309,-541584,-538138,-497470,-480909,-459608,-444410,-426022,-403497,-393857,-363379,-359219,-347291,-330378,-314805,-303621,-291243,-251965,-244657,-243891,-236303,-234099,-217309,-210326,-199139,-197450,-177317,-172519,-170556,-137069,-128436,-113727,-95170,-79317,-52534,-4681,40199,89215,107649,109238,124507,157189,162498,180216,200111,228032,251189,262426,319119,323615,344264,345305,373566,399588,411387,427092,427955,456725,461974,468467,474372,476390,562956,577916,580839,591862,616385,638656,650816,653650,672517,753495,769837,779299,801738,809541,836250,872512,917419,949439,959386,979587]\n[]\n[]\n[-999311,-995487,-993598,-993127,-989482,-973229,-926998,-898485,-851725,-850712,-836433,-795269,-784476,-764197,-763427,-756479,-755190,-753600,-717158,-677976,-668634,-640052,-597569,-589282,-520481,-515063,-499955,-479622,-477302,-473002,-403966,-400582,-388037,-363473,-344547,-324788,-320701,-314920,-296000,-290463,-276432,-273513,-244152,-215671,-192226,-184426,-128230,-122297,-75423,-58001,-8481,2993,27765,54297,64282,81674,93781,96008,152144,154165,166583,169777,181118,191164,216155,263473,271293,308484,360932,380484,405656,413389,432913,436707,461128,530274,555172,576238,595665,608718,624952,644037,684003,697121,727400,730624,751135,768207,784915,792103,809755,831583,832823,844259,886508,913559,941025,950966,975298]\n[-999567,-997502,-997320,-997131,-995209,-993605,-991650,-991613,-991417,-990564,-989776,-987550,-985870,-985386,-982368,-981518,-979842,-979718,-978628,-976620,-974345,-973518,-972291,-967402,-967265,-966730,-965785,-962771,-961174,-960505,-959719,-955802,-955134,-953099,-948117,-944790,-941695,-941693,-939131,-938510,-937577,-937038,-935074,-933558,-933056,-930614,-929544,-924799,-922049,-920262,-919703,-917939,-916145,-915636,-914995,-913579,-896888,-894679,-894651,-891943,-891618,-891260,-888315,-886543,-884101,-883513,-872873,-872826,-872120,-871050,-870232,-869805,-868351,-867330,-866646,-866243,-863978,-863009,-859149,-858906,-858758,-854975,-852689,-852164,-851427,-850218,-847970,-845912,-845486,-844687,-844411,-843956,-843353,-839477,-837499,-836703,-833607,-831373,-830358,-827611,-827276,-827145,-827057,-825816,-823331,-822868,-822693,-821423,-820561,-819808,-815340,-814889,-814639,-814554,-813263,-811601,-810742,-810567,-808592,-807943,-805362,-805085,-803725,-798929,-792149,-789206,-785856,-783704,-783011,-781163,-775292,-772930,-769271,-764889,-764165,-763180,-758264,-756607,-755921,-752956,-752637,-751864,-751318,-750878,-750246,-749003,-746825,-744464,-744367,-743637,-741289,-738903,-736545,-732164,-731981,-731878,-730164,-727779,-725497,-725433,-720206,-715719,-714089,-707566,-705091,-705008,-705000,-699566,-696000,-694414,-689552,-688092,-683083,-681058,-680084,-676059,-675854,-675730,-672990,-671402,-669298,-669292,-667660,-667250,-662853,-660122,-658209,-657793,-657002,-656472,-653603,-647017,-643156,-642765,-642520,-638572,-637837,-636344,-635145,-629818,-628344,-624890,-622582,-621602,-619124,-617701,-616391,-613542,-609069,-605811,-604133,-603960,-602075,-601936,-601600,-599041,-598358,-597574,-597092,-596147,-594696,-592955,-592300,-591877,-591829,-591201,-589912,-584118,-583933,-574753,-567021,-566697,-565332,-564305,-562776,-561152,-557378,-553247,-551405,-541292,-536736,-533881,-533615,-532784,-531029,-530553,-527184,-526662,-525823,-525625,-525093,-520969,-520545,-515036,-510919,-507746,-504592,-504032,-503595,-501437,-499214,-496301,-494795,-490284,-486646,-485513,-484383,-480751,-476832,-476559,-474296,-469572,-469152,-468659,-466347,-462419,-460567,-458882,-457050,-454911,-453624,-452324,-450481,-449509,-440836,-439940,-436508,-434347,-431863,-426890,-422954,-422337,-419891,-419812,-419313,-415360,-413516,-410195,-409526,-409454,-408360,-408054,-406101,-404269,-401590,-400963,-394836,-385314,-375836,-374995,-374048,-368693,-368131,-367859,-361397,-360458,-356055,-354270,-354227,-346946,-346223,-346099,-345855,-344808,-344247,-343806,-342087,-339682,-338497,-335912,-334945,-330597,-328200,-327450,-323098,-320641,-319061,-316787,-314312,-314133,-313427,-313020,-311735,-311556,-308652,-307950,-307902,-305049,-304780,-304200,-301782,-301539,-296853,-296489,-293520,-285339,-284857,-284262,-283709,-282070,-281202,-281164,-277190,-276021,-274641,-273757,-273728,-270394,-269087,-265427,-265272,-264115,-263447,-262116,-259606,-257673,-257419,-257235,-257127,-257053,-256900,-256146,-255547,-253986,-249576,-249079,-245481,-239011,-235597,-230997,-228005,-227497,-227250,-226380,-225431,-216611,-210008,-208956,-208838,-201921,-199428,-196686,-191696,-190547,-189199,-188847,-188753,-186418,-185773,-185206,-182706,-180515,-179348,-178474,-175203,-174731,-173012,-173012,-171115,-170095,-168308,-168128,-166905,-166742,-164733,-164448,-158590,-157720,-156014,-155429,-153638,-149375,-148870,-148098,-147945,-145512,-145183,-141591,-139964,-137213,-134488,-133486,-132424,-131215,-130615,-125187,-124332,-117324,-113085,-112523,-111751,-111383,-104409,-104344,-102517,-102161,-98185,-97846,-91902,-89723,-84742,-84067,-83948,-82603,-82579,-78160,-76854,-75430,-75344,-74962,-71408,-69102,-66641,-65642,-64757,-61211,-60329,-57886,-53220,-52898,-49270,-49124,-48080,-45815,-44789,-37626,-34882,-34859,-32485,-31102,-29729,-24983,-22453,-20259,-16334,-16193,-15026,-12533,-11486,-9861,-4017,-404,704,6117,7576,8139,8688,16526,17499,22574,25852,26549,29362,30492,33676,37645,40152,43767,44242,46314,47444,50651,52396,53898,59922,60919,63930,68755,69424,70153,71709,73909,75531,75770,77643,78793,81457,83544,85477,89943,91011,91041,91192,94363,94670,95048,96537,98525,98539,104346,107800,108042,109819,110121,115691,117048,118363,118924,120311,125092,127555,127995,128168,135729,138889,140152,140261,140971,145327,145731,145860,152322,155692,159510,161250,163594,164930,166753,167883,168915,172982,173783,174795,175457,179314,180491,180628,189221,190490,190611,193586,195760,199322,201329,202231,202971,205732,206448,209484,210079,213383,213627,214223,215757,218866,223260,224593,225505,228101,229883,232562,234221,235355,236464,236563,238608,240104,242362,242959,245209,246122,246173,249953,255505,258524,260918,261968,262033,262830,263342,263665,265410,265772,266591,268471,270067,274107,276862,277801,277848,278505,278931,279516,285322,286378,293299,294255,296317,296787,297292,300002,302027,302121,302296,304390,304403,306514,311250,311643,316657,317008,319056,320827,322849,324605,326098,326173,326315,326588,328330,329876,330948,331341,331948,332124,341297,341942,343708,344436,344659,350897,351495,351893,352596,353479,355046,356056,357088,357742,358398,360172,365218,372048,375602,376611,382420,386919,389469,391011,392771,396046,403823,404843,407192,409690,410139,411497,418925,419472,419584,420171,421967,425637,428244,428593,429601,430662,431024,432899,434667,438639,438690,438839,441713,443399,449585,454891,459572,461567,464223,464977,468031,468216,468980,469952,471601,473590,476517,477804,478040,479232,481442,482516,487561,489198,493596,494509,498310,500634,502180,503663,504932,507455,511419,515818,517896,518474,520182,520335,520403,520452,523949,524745,525015,526693,531560,536815,536885,536922,537002,537675,541832,543158,547884,548488,549711,559134,559481,559820,560772,560870,561935,563399,563985,568956,569744,570203,573437,574202,574696,578813,579430,588576,588747,590647,604861,606852,606861,607746,608154,609468,609523,611937,611965,612112,614230,619688,620348,621041,621873,622766,633850,636410,645785,647203,647468,648663,651250,653354,655650,655736,656313,656473,660352,665886,668634,668889,668947,670032,670182,670412,673826,686025,686683,691645,692054,692284,695765,697395,697829,702166,708541,709011,711141,712520,714573,716618,721072,721706,721848,721884,722339,722954,724012,724181,726931,729781,730450,732815,734038,734313,735874,736725,737913,738002,740812,743047,744545,745638,746517,747495,747721,754971,755927,760296,760368,768237,770512,771998,772642,773928,775652,776009,776528,778433,784050,788493,788662,790251,794398,797252,797470,798288,800465,801126,806618,807774,810900,812412,812864,815004,819410,819576,821429,822144,828766,831814,834893,834987,838359,839232,839741,845812,846318,851048,851400,852080,856264,859668,861457,862611,863385,867019,872146,872332,877196,879288,879573,883230,888081,889012,889628,889844,890313,891004,891633,897234,900619,901180,901991,904976,905449,905491,905566,906218,906325,911636,912008,912597,917627,919382,921003,924181,925430,925724,925947,929266,934039,935863,937145,938405,941714,945193,946019,948295,950933,951602,951856,952469,953824,954207,954485,954748,959150,960644,962815,963477,963549,963815,964638,965098,967348,967682,969084,971079,973452,974228,976702,976910,978359,981049,982811,982859,987419,993386,994771,995167,996051,998221]\n[-987944,-969636,-969382,-963918,-960334,-957471,-955419,-954534,-949617,-948164,-941370,-934887,-933385,-933024,-925395,-920598,-914952,-912930,-910713,-898551,-897943,-895093,-883721,-881114,-868961,-862108,-859224,-844995,-843122,-841350,-839681,-837319,-833916,-832929,-824567,-821404,-817679,-816414,-815142,-814794,-814428,-812717,-803053,-800629,-791874,-784923,-776546,-772543,-770170,-769595,-767768,-764581,-760610,-755916,-750060,-738122,-734792,-733242,-728895,-725665,-725507,-718134,-717075,-715534,-715202,-713373,-712097,-708739,-707414,-706871,-703365,-702017,-693735,-683042,-672054,-669261,-668919,-664791,-661728,-660926,-656147,-645420,-643702,-643193,-641435,-638420,-634551,-628772,-615960,-603372,-601747,-598111,-594931,-589739,-582816,-582756,-578800,-578594,-573174,-567081,-559766,-559620,-556681,-554084,-553002,-549693,-548262,-545226,-544969,-537261,-533737,-528123,-520081,-506744,-504736,-499021,-496520,-496470,-495274,-493267,-486175,-485863,-484654,-482183,-481473,-479689,-476360,-474984,-474568,-470604,-469841,-458033,-456643,-456026,-449361,-448407,-447725,-446572,-444202,-444122,-438385,-438174,-436049,-433511,-429215,-428895,-423500,-419598,-414944,-413779,-413601,-413134,-395813,-386542,-386081,-384022,-383217,-377664,-375237,-370842,-368652,-368619,-367534,-360286,-359315,-356864,-346574,-344238,-342362,-338322,-337904,-317031,-315369,-311471,-307529,-291585,-288367,-282217,-273392,-268202,-266384,-262947,-261304,-259484,-253107,-253097,-247496,-240183,-238502,-232673,-225567,-225273,-220556,-218540,-217405,-209508,-209191,-198492,-196102,-194657,-187900,-187654,-187409,-183298,-183195,-178895,-172948,-164463,-150912,-150447,-147157,-146039,-142859,-142513,-141007,-140514,-133632,-121672,-120655,-111524,-106570,-104308,-101032,-100077,-99330,-98302,-93625,-88734,-88072,-87928,-84357,-71659,-69515,-67676,-63282,-58552,-56529,-55822,-52857,-49183,-49096,-36632,-35822,-22044,-15543,-13193,-11327,-8347,-5921,367,2667,4951,5292,12503,13977,16698,20683,21104,29329,29383,32131,36676,38796,38939,39209,47231,48354,58584,63004,67608,68400,79071,80602,81795,86542,94114,101023,103400,104656,104880,111548,112896,115766,121077,122734,127019,127444,132932,138051,140440,154194,158884,165068,166138,166908,169497,170785,171990,179699,180030,188999,195927,197727,215034,218444,219489,222687,224521,235464,235727,241470,243528,246904,258231,259122,260441,263591,265308,267313,269450,272354,272547,274104,276239,278349,282844,283153,284414,285344,292275,301326,301817,303601,305996,308758,308841,318258,318758,326276,328210,328413,329591,330688,335804,336586,338827,350724,353017,355893,356488,358137,367458,369246,373776,375814,388619,389665,391494,398826,410285,414310,434616,436368,437657,441921,442891,443722,445197,448982,449981,452442,455491,458606,458789,459482,459977,460011,467293,480680,484432,486822,491840,495107,498402,498655,499730,501125,506371,507661,508352,508531,510705,517473,521451,521763,531020,535521,536548,538401,543120,545936,546904,551503,551845,552061,557919,565312,566269,568604,574239,574420,578570,579251,582167,587488,592161,594286,604994,619288,622829,629325,652728,657554,659113,659971,661630,664091,664280,667722,673155,674069,675252,680792,683874,685152,698652,701722,703282,708464,710121,710242,712200,718611,720934,732059,736885,739191,742494,750812,759987,772722,776392,782107,782131,783537,783996,785898,793147,799555,806418,807432,808677,831974,841540,844398,849513,849656,854080,855359,858674,865625,866262,870340,877863,886981,896266,898306,900880,903869,907452,914307,916336,916960,922084,923604,924431,926571,930085,935193,948240,948473,954648,957779,959463,960134,960965,975144,979240,997354,999899]\n[0,2,3,4,4,6,6,7,8,8,8,8,11,11,15,16,17,20,22,26,26,28,29,30,31,32,36,39,40,41,41,44,45,52,52,53,54,56,57,62,70,71,72,74,78,78,80,80,83,84,86,87,88,90,91,92,92,96,99,104,105,106,110,110,112,113,113,115,116,118,119,121,121,123,124,125,125,129,129,131,131,134,135,140,141,141,143,144,145,145,145,150,152,153,154,157,158,159,159,159,164,164,169,172,176,176,177,178,178,184,185,189,189,190,191,192,193,193,194,194,195,196,196,200,203,204,205,206,210,211,211,212,212,213,216,219,220,222,225,226,229,229,233,234,237,238,239,241,243,243,246,246,248,249,249,250,250,251,253,255,256,258,260,260,262,266,268,268,269,271,272,273,273,280,281,282,283,288,288,295,296,296,298,302,304,305,305,305,305,306,306,308,309,310,312,313,315,315,318,318,319,319,321,322,323,324,324,326,329,329,329,331,331,333,333,334,334,336,339,339,340,341,341,343,344,348,351,351,352,353,354,354,358,359,363,364,364,365,367,367,368,369,370,372,372,373,376,376,378,379,379,381,382,383,385,386,391,391,391,394,396,399,400,411,414,414,414,416,423,429,429,430,430,431,435,436,437,438,442,443,444,447,448,452,452,452,452,452,455,456,457,457,462,466,468,468,468,472,472,472,472,473,473,475,476,476,477,477,480,481,481,482,483,483,484,485,485,486,486,491,491,491,491,492,494,495,497,497,500,502,503,505,505,509,510,514,515,515,515,516,516,518,519,519,520,522,524,525,527,528,529,531,534,537,537,540,543,543,544,544,545,549,552,552,556,558,558,565,565,566,569,570,571,572,575,577,577,578,579,579,581,583,584,586,586,590,591,593,597,603,603,605,607,608,611,613,614,622,622,622,623,631,631,633,635,638,638,639,642,643,644,645,646,649,652,653,653,654,655,655,655,655,657,659,660,661,664,665,666,667,671,682,684,685,686,688,691,692,694,694,696,698,699,702,704,704,704,706,706,709,710,713,713,714,717,723,725,726,727,727,729,730,730,732,732,733,734,738,740,740,741,746,750,751,751,755,755,758,759,759,760,764,765,767,769,771,773,774,775,776,779,779,781,782,785,797,797,798,798,798,802,803,804,804,806,807,808,809,809,810,810,812,814,814,818,819,820,822,822,823,824,826,826,826,827,830,831,833,833,833,834,837,838,838,839,840,840,841,844,844,847,848,851,852,853,854,857,860,862,864,868,868,869,870,872,874,880,881,881,883,884,885,888,889,892,892,896,897,897,898,899,901,904,905,907,908,914,914,915,915,916,918,920,921,921,921,927,927,928,928,929,932,932,932,932,933,937,937,938,939,940,941,941,942,942,942,944,945,945,946,947,948,952,952,955,956,960,962,964,964,966,968,968,968,971,973,973,973,974,978,979,979,981,982,983,985,985,989,990,990,990,993,994,994,995,998,999,999,1000]\n[999,999,1002,1003,1003,1004,1007,1010,1016,1016,1016,1020,1020,1022,1022,1024,1024,1027,1035,1038,1038,1041,1043,1044,1054,1055,1060,1064,1066,1067,1069,1070,1070,1071,1074,1074,1075,1081,1081,1087,1090,1092,1092,1094,1095,1095,1096,1097,1097,1098,1099,1103,1103,1103,1104,1104,1104,1105,1105,1108,1109,1109,1112,1112,1113,1116,1117,1117,1117,1117,1119,1121,1122,1124,1124,1125,1129,1129,1130,1131,1133,1133,1133,1135,1139,1140,1142,1142,1143,1144,1145,1146,1146,1148,1149,1151,1151,1151,1151,1152,1153,1153,1158,1159,1161,1164,1167,1171,1172,1173,1174,1176,1178,1178,1179,1180,1181,1182,1182,1183,1183,1185,1185,1186,1188,1189,1191,1192,1195,1200,1201,1201,1203,1204,1206,1207,1208,1208,1209,1210,1212,1212,1215,1216,1217,1222,1224,1225,1226,1226,1229,1230,1232,1232,1239,1241,1241,1243,1243,1244,1249,1252,1255,1256,1257,1263,1266,1266,1266,1270,1272,1274,1274,1280,1281,1288,1288,1288,1291,1291,1292,1296,1299,1301,1304,1304,1305,1306,1307,1310,1311,1311,1311,1312,1313,1313,1315,1315,1315,1319,1320,1321,1321,1321,1324,1324,1326,1327,1328,1330,1335,1348,1350,1351,1353,1355,1357,1357,1361,1365,1367,1368,1372,1374,1377,1383,1385,1388,1390,1390,1393,1393,1397,1398,1398,1398,1401,1402,1404,1405,1406,1407,1410,1410,1412,1412,1413,1414,1416,1416,1416,1416,1417,1418,1419,1423,1423,1428,1430,1432,1432,1433,1435,1436,1437,1438,1441,1441,1444,1444,1445,1449,1449,1449,1453,1457,1464,1466,1467,1469,1472,1475,1475,1478,1480,1485,1488,1488,1488,1489,1491,1493,1499,1500,1500,1500,1504,1505,1507,1508,1509,1510,1512,1512,1516,1519,1522,1528,1530,1532,1532,1538,1540,1540,1543,1545,1546,1548,1551,1553,1554,1555,1555,1561,1562,1563,1564,1565,1565,1569,1570,1570,1571,1572,1572,1577,1580,1580,1589,1589,1596,1599,1600,1600,1600,1600,1601,1602,1603,1607,1609,1610,1617,1618,1623,1623,1624,1626,1628,1629,1629,1630,1634,1637,1637,1637,1642,1645,1646,1646,1647,1647,1652,1657,1660,1662,1663,1666,1666,1667,1669,1670,1673,1675,1675,1677,1678,1678,1684,1686,1691,1691,1692,1694,1694,1697,1700,1700,1703,1704,1706,1706,1714,1715,1720,1720,1720,1720,1721,1721,1723,1725,1726,1728,1730,1730,1732,1733,1736,1739,1742,1744,1744,1752,1758,1759,1760,1764,1765,1766,1767,1769,1769,1773,1773,1773,1774,1775,1775,1775,1780,1783,1785,1785,1790,1791,1792,1793,1793,1795,1800,1803,1805,1807,1808,1811,1811,1811,1812,1812,1815,1816,1818,1819,1820,1821,1822,1823,1827,1828,1829,1830,1832,1835,1835,1835,1837,1839,1843,1843,1846,1849,1849,1849,1849,1851,1853,1853,1853,1854,1855,1861,1863,1865,1868,1870,1873,1878,1879,1881,1881,1881,1883,1883,1884,1885,1887,1889,1890,1891,1891,1894,1895,1896,1898,1899,1899,1901,1902,1904,1906,1907,1912,1912,1914,1914,1915,1917,1920,1921,1924,1926,1928,1930,1930,1931,1932,1933,1934,1934,1935,1936,1942,1943,1944,1947,1947,1948,1950,1951,1952,1953,1954,1956,1956,1957,1963,1964,1965,1966,1968,1968,1970,1971,1973,1979,1979,1981,1982,1986,1986,1986,1989,1992,1992,1998,1998,1999,1999,1999,2000]\n[1,1,2,4,7,10,10,11,17,24,26,26,27,28,32,33,33,35,35,35,37,37,37,38,40,41,45,48,50,50,53,53,54,55,55,55,56,57,63,66,68,71,76,79,81,81,82,83,85,88,89,91,95,96,100,102,103,104,104,105,107,107,108,109,109,112,116,118,118,118,119,119,120,121,123,124,124,127,128,128,128,130,132,134,134,140,141,141,143,143,144,147,148,150,150,152,153,155,156,157,164,166,166,167,167,168,176,178,184,185,190,191,191,192,193,194,197,199,201,201,204,207,207,211,211,216,225,225,228,229,233,234,235,237,237,237,238,239,239,244,247,248,248,251,251,254,258,259,259,261,263,266,268,269,269,269,269,271,281,282,285,285,286,287,292,293,295,295,295,296,300,300,302,305,305,305,309,310,310,310,311,318,319,319,320,320,321,321,322,328,329,332,333,334,335,336,336,339,339,339,341,341,345,346,346,347,348,348,349,349,349,350,351,351,355,356,361,363,363,364,366,366,367,368,368,371,371,373,377,380,381,381,382,384,384,387,387,389,394,395,399,400,402,406,406,407,407,410,415,418,419,424,427,433,434,436,437,442,444,445,451,455,455,456,457,459,461,462,463,464,464,465,465,465,467,468,469,473,476,476,476,480,482,483,486,488,489,490,493,495,495,496,496,497,499,499,500,502,504,505,509,509,511,511,516,516,517,521,523,525,526,528,528,530,534,534,535,538,538,541,541,544,544,544,544,546,547,550,550,551,553,555,556,556,557,558,558,559,561,563,567,569,569,570,571,571,572,574,574,575,575,578,582,583,583,584,584,586,590,592,592,594,595,596,598,598,598,601,603,603,604,612,617,618,620,620,624,626,627,628,631,635,637,637,638,641,645,650,651,652,653,654,657,659,659,661,661,661,661,662,663,663,664,664,665,666,669,670,670,671,675,676,683,684,688,689,689,689,690,691,692,694,695,695,696,697,697,700,705,705,707,708,708,709,709,710,710,712,714,716,716,716,718,721,722,722,723,724,725,728,728,729,730,735,735,737,737,741,741,744,747,748,749,750,751,751,754,754,755,757,757,759,759,761,763,763,763,764,766,767,771,771,777,778,778,778,781,782,782,786,786,786,787,787,787,790,790,790,791,792,792,793,801,803,804,805,805,805,805,807,808,808,808,810,815,817,819,819,822,829,829,830,832,832,834,834,836,836,836,837,842,843,844,846,846,847,847,847,850,851,852,853,853,854,854,855,855,858,860,863,864,866,866,867,871,875,881,883,883,886,888,888,890,891,892,894,897,903,913,914,915,918,918,919,920,920,922,923,925,927,927,927,927,928,937,943,943,943,946,948,949,950,953,954,958,966,968,968,971,979,980,981,983,984,985,985,987,987,990,991,992,992,992,997,999]\n[999,1000,1001,1001,1002,1005,1006,1008,1009,1011,1014,1014,1018,1019,1021,1026,1027,1031,1031,1032,1033,1034,1037,1038,1039,1041,1042,1043,1043,1043,1046,1049,1054,1055,1055,1058,1060,1064,1065,1065,1067,1067,1068,1074,1076,1076,1082,1082,1083,1084,1085,1086,1087,1094,1094,1095,1098,1101,1104,1104,1105,1105,1106,1106,1106,1107,1108,1112,1112,1113,1117,1118,1118,1119,1124,1124,1126,1126,1126,1130,1130,1132,1132,1133,1133,1134,1134,1136,1137,1139,1139,1139,1139,1139,1140,1141,1141,1141,1143,1144,1145,1147,1147,1150,1152,1153,1155,1157,1158,1159,1160,1161,1162,1163,1163,1165,1167,1167,1167,1167,1168,1168,1168,1168,1169,1171,1171,1172,1172,1173,1176,1177,1178,1178,1180,1181,1183,1184,1184,1185,1186,1186,1187,1188,1188,1189,1190,1191,1195,1196,1199,1200,1200,1201,1202,1206,1207,1208,1209,1211,1211,1212,1217,1221,1221,1222,1222,1224,1225,1226,1230,1230,1231,1232,1237,1237,1240,1243,1243,1243,1243,1243,1245,1245,1248,1248,1248,1249,1249,1253,1254,1255,1257,1258,1260,1265,1266,1268,1269,1270,1271,1271,1273,1274,1275,1277,1278,1279,1280,1281,1281,1283,1283,1284,1284,1286,1286,1287,1288,1288,1289,1290,1291,1292,1292,1295,1297,1298,1298,1299,1301,1302,1304,1306,1306,1307,1308,1310,1311,1312,1316,1316,1317,1318,1319,1320,1320,1321,1322,1324,1324,1324,1325,1327,1329,1330,1331,1331,1331,1332,1333,1333,1334,1336,1342,1345,1346,1347,1347,1349,1349,1350,1351,1352,1355,1355,1356,1357,1357,1362,1363,1364,1364,1364,1365,1370,1370,1372,1372,1374,1374,1375,1375,1376,1376,1378,1379,1379,1381,1382,1383,1384,1385,1386,1389,1391,1391,1391,1393,1394,1395,1397,1397,1401,1403,1405,1405,1406,1407,1407,1408,1409,1410,1413,1413,1416,1418,1418,1421,1422,1422,1424,1424,1425,1426,1428,1428,1429,1430,1434,1436,1439,1439,1439,1439,1440,1440,1441,1441,1442,1442,1442,1444,1445,1447,1447,1451,1451,1452,1456,1460,1462,1463,1468,1469,1469,1470,1470,1471,1472,1472,1474,1476,1478,1478,1482,1484,1486,1486,1488,1489,1489,1493,1494,1495,1495,1497,1498,1502,1503,1505,1506,1507,1507,1508,1511,1512,1513,1514,1515,1516,1518,1520,1520,1520,1522,1523,1525,1525,1527,1527,1528,1531,1531,1532,1533,1534,1535,1537,1538,1540,1540,1541,1543,1543,1544,1545,1546,1548,1549,1551,1551,1552,1552,1552,1553,1556,1556,1557,1557,1557,1559,1559,1560,1561,1561,1562,1564,1564,1564,1564,1566,1566,1567,1571,1571,1572,1573,1573,1574,1574,1577,1577,1583,1584,1584,1588,1589,1590,1593,1593,1595,1596,1596,1596,1597,1598,1601,1604,1604,1606,1606,1607,1607,1610,1610,1611,1611,1612,1612,1614,1615,1616,1617,1621,1622,1622,1622,1623,1626,1627,1631,1632,1636,1637,1637,1638,1640,1642,1642,1644,1645,1647,1648,1650,1651,1652,1653,1655,1655,1656,1656,1656,1656,1658,1658,1658,1660,1660,1663,1664,1665,1666,1667,1667,1667,1669,1669,1670,1676,1678,1680,1681,1681,1682,1684,1684,1685,1686,1686,1687,1689,1689,1689,1690,1693,1694,1698,1700,1702,1703,1706,1708,1708,1708,1710,1712,1712,1712,1713,1715,1715,1717,1719,1719,1720,1720,1721,1722,1722,1724,1731,1732,1734,1734,1737,1737,1741,1743,1743,1749,1749,1751,1753,1754,1754,1756,1757,1757,1758,1759,1761,1761,1762,1764,1766,1766,1767,1769,1769,1771,1772,1772,1775,1775,1775,1777,1779,1779,1781,1782,1782,1783,1786,1788,1788,1788,1790,1793,1793,1793,1793,1794,1795,1795,1796,1796,1796,1797,1799,1800,1803,1810,1811,1814,1814,1814,1816,1817,1819,1820,1820,1822,1824,1826,1826,1826,1827,1828,1828,1831,1832,1834,1835,1836,1837,1838,1838,1841,1843,1849,1851,1851,1852,1852,1853,1853,1854,1854,1856,1858,1859,1863,1863,1863,1869,1871,1872,1872,1873,1874,1879,1880,1881,1881,1882,1883,1883,1883,1885,1885,1885,1886,1887,1887,1889,1894,1898,1899,1901,1902,1903,1904,1907,1908,1910,1911,1911,1911,1913,1914,1914,1915,1916,1917,1918,1921,1922,1923,1923,1924,1926,1926,1933,1933,1934,1934,1934,1936,1938,1938,1939,1939,1941,1941,1942,1942,1947,1947,1947,1947,1949,1949,1952,1954,1955,1957,1958,1959,1960,1960,1963,1964,1964,1964,1966,1968,1971,1973,1975,1977,1978,1978,1979,1979,1980,1981,1981,1982,1984,1985,1985,1987,1987,1987,1987,1987,1988,1989,1990,1991,1994,1994,1995,1996,1997,1997,1998]\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this help](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e)s and makes thinks clear\\nand do clap \\uD83D\\uDC4F to appreciate the article"
                    },
                    {
                        "username": "pwho",
                        "content": "If you\\'re going to share an article here, don\\'t hide it behind a paywall. =\\\\"
                    },
                    {
                        "username": "user5979vk",
                        "content": "Thanks (https://archive.is/E2agn)"
                    },
                    {
                        "username": "4alisha",
                        "content": "very helpful\\uD83D\\uDC4F"
                    },
                    {
                        "username": "thecodingkid",
                        "content": "Any help would be appreciated if you could explain why the solution in the O(log(min(m,n))) case requires a swap if the second array is smaller.\\n\\nIf you could specify any edge case that is failing , that would be of great help."
                    },
                    {
                        "username": "bparanj",
                        "content": "Swapping nums1 and nums2 if nums1 is larger than nums2 is a trick to simplify the problem by reducing it to a condition where we always binary search on the smaller array. This doesn\\'t change the result because the median of two arrays doesn\\'t depend on which array is longer, but it makes the code cleaner and easier to understand, and it also improves performance by minimizing the search space.\\n\\nMoreover, this technique ensures that we do not run into an index out of bounds error during our binary search process. \\n\\nLet\\'s consider an edge case where the swapping would be important:\\n\\nnums1 = [6, 7, 8, 9, 10]\\nnums2 = [1, 2, 3]\\n\\nIf we did not swap, and started the binary search on nums1, we would end up exploring unnecessary parts of nums1 that wouldn\\'t impact the final result, since we know that the median must be within the range covered by nums2 due to its smaller size and range of values. \\n\\nIf we swap and binary search on nums2, we can find the median more efficiently because we focus on the smaller range of values. We then only need to compare with a few specific elements of nums1.\\n\\nTo summarize, the swap is used to ensure efficiency and simplicity by always performing binary search on the smaller array."
                    }
                ]
            },
            {
                "id": 1567155,
                "content": [
                    {
                        "username": "yon",
                        "content": "Input:\\t[1,1], [1,2]\\nExpected:\\t1.00000\\n\\nMy solution way is merge [1,1] and [1,2] to [1,2], so the answer would be (1+2)/2 = 1.5\\nWhat did I made wrong?"
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "you first merge it (preserving duplicates).\\n[1, 1, 1, 2]\\n\\nWhats the middle element here?\\noh wait. there are two elements at the middle. 1 and 1.\\nso you average em. \\n(1 + 1) / 2 = 1"
                    },
                    {
                        "username": "RISHIKA_GANDHI",
                        "content": "change your (1+2)/2 to this (1+2)/2.0 you will get you result into float/double type"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "the merged array will we [1,1,1,2] ,\\nno of elements are even so median will we (1+1)/2=1.\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the hell nooo. median is 1 here"
                    },
                    {
                        "username": "hankIgoe",
                        "content": "the merged string is [1,1,1,2], so the median is (1+1)/2 = 1.0\\n"
                    },
                    {
                        "username": "vyshnusanthosh",
                        "content": "If you are using java, when two integers are divided the answer will also be an integer in order to get floating point you need to type cast the integers to double or float before division."
                    },
                    {
                        "username": "megazortti",
                        "content": "i\\'m facing the same problem..\\n"
                    },
                    {
                        "username": "khushal1201",
                        "content": "[@zwicky](/zwicky) the merged array should be [1,1,1,2]. Hence the median would be (1+1)/2 = 1."
                    },
                    {
                        "username": "zwicky",
                        "content": "you shouldn\\'t remove duplicates"
                    },
                    {
                        "username": "hing_liu",
                        "content": "Let try to interate the algorithm first:\\n\\nIt is basically a k-th smallest element problem between two sorted arrays, let assume we have the following two arrays:\\n\\n5,7,8,11\\n4,9,12,14\\n\\nk = 4 (expected ans = 8 because when it is sorted: 4,5,7,**8**,9,11,12,14)\\n\\nStep 1: Cut the two arrays into two pieces such that the left side will have total items of 4 (i.e. the **K=4**)\\n5,7 | 8, 11\\n4,9 | 12, 14\\n\\nStep 2: We remove [5,7] because its end index at the left side is smaller (7. v.s 9) and we update K = 2 (since we removed 2 item=> K - 2 = 4 - 2 = 2), it will becomes:\\n8,11 <-- removed [5,7]\\n4,9,12,14\\n\\n(basically the rest of the steps below is to repeat 1 and 2 until K = 1)\\n\\nStep 3: Repeat Step 1, Cut into two half base on **K = 2**\\n8 | 11\\n4 | 9 12 14\\n\\nStep 4: Repeat Step 2, that is remove 4 and update **K = 1** (since we removed 1 item=>K-1 = 2-1 1)\\n\\nStep 5: Repeat Step 1, Cut into two half base on K = 1, since K = 1 is not able to split (we have two arrays, don\\'t know how to split), we conclude the solution as the minimum of the first item of the two array, that is min(8,9) = 8\\n8,11\\n9,12,14\\n\\nWe are all done, how about K = 3 initially? Basically the point of \\'cut\\' is K/2 - 1, therefore when K = 3, the cutting point is index=0, let us go though this again quickly for this:\\n\\nK=3\\n5|7,8,11\\n4|9,12,14\\n\\nK=2\\n5|7,8,11\\n9|12,14\\n\\nK=1\\n7|8,11\\n9|12,14 \\nAns=min(7,9) = 7\\n\\nThere is some edge case not tell here, this is just a general idea. We want to have the first K-th item, so, the first target is to collect the first K item from the two array, so we fairly cut them at K/2 - 1 and remove the smaller list until K = 1.\\n\\nThis might be still hard to understand, consider we are not greedy, we do it one by one (we don\\'t cut base on K, but always cut by two):\\n\\nK=4\\n5 | 7 8 11\\n4 | 9 12 14\\n\\nAt this point, we remove the smaller one and have:\\nK=3\\n5 | 7 8 11\\n9 | 12 14\\n\\nKeep doing this until K = 1\\nK=2\\n7 | 8 11\\n9 | 12 14\\n\\nK = 1\\n8 | 11\\n9 | 12 14\\n(at this point, all done)\\n\\nWe are now reaching the answer = 8 by doing this in one-by-one manner, the cutting point at this \\'slow-version\\' is always [0], and the faster version is doing the cutting point at [k/2 - 1], that still work because they are sorted, it is safe to jump further and remove the whole preceding items rather than doing this one-by-one manner.\\n\\nAgain, this might still be hard to convince yourself why the \\'faster-version\\' has no issue, just hope this can help you understand more.\\n\\nGoing back to tell why it is a k-th minimum issue, consider when we have ths int kth(arr1, arr2, k) function, we can put k to be the middle of sizeof(arr1) and sizeof(arr2), if it is even number of size we just get the adjacent (run kth function two times) so we can get the middle two and divide it by 2, so the answer ..."
                    },
                    {
                        "username": "rds8rds",
                        "content": "thanks properly understand the concept!"
                    },
                    {
                        "username": "parismania",
                        "content": "That\\'s quite a good explanation. Thank you!"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I tried to avoid this question for as long as possible"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally solved this by merging the two arrays. I always intended to do the proper solution - one day. Today is the day."
                    },
                    {
                        "username": "raviTejaY",
                        "content": "\\tvar findMedianSortedArrays = function(nums1, nums2) {\\n  \\tlet mid;\\n\\t  let res = [...nums1, ...nums2].sort((a,b) => a-b);\\n\\t mid = (res.length-1)/2;\\n\\t  if(res.length % 2 === 1){\\n\\t\\treturn res[mid].toFixed(5);\\n\\t  } else {\\n\\t\\tlet median = (res[Math.floor(mid)] + res[Math.ceil(mid)]) / 2;\\n\\t\\treturn median.toFixed(5)\\n\\t  }\\n\\t};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, you use .sort(), which does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "hongbin2",
                        "content": "My naive solution is just merge two array and find the median. Obvious we can do better. But I just have no idea about it."
                    },
                    {
                        "username": "aneesfathimasaifudeen",
                        "content": "Input\\n[1,2]\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000\\n\\nThis test case always fails for me in leetcode, whereas it works for me in my machine\\'s python compiler with the same code.\\n\\nCan anyone tell, what would be the problem here?"
                    },
                    {
                        "username": "evenn",
                        "content": "choose Python3 rather than Python to execute code"
                    },
                    {
                        "username": "kapilkapuriya",
                        "content": "[@jeetu16](/jeetu16)  use type cast when you perform   ** ans = a/2 **  so do like this  **  ans = double(a)/2 ** "
                    },
                    {
                        "username": "doubleshab",
                        "content": "[@jeetu16](/jeetu16) I had a similar problem using Python3. For me, the issue was that the math I was using to generate my index values was producing float values. By forcing them to integer types using the int() builtin, I was able to get around it."
                    },
                    {
                        "username": "python_is_cheat_code",
                        "content": "Facing the same issue. Have no idea what to do."
                    },
                    {
                        "username": "AtrijPaul",
                        "content": "If you are coding in Java then division of two integers will be integer only , after performing the division it get stored as double. So instead of dividing by 2 , divide by 2.0 , it will work."
                    },
                    {
                        "username": "jeetu16",
                        "content": "have you found the solution till now?\\ni faced the same problem"
                    },
                    {
                        "username": "scott40",
                        "content": "The question states: \"There are two sorted arrays nums1 and nums2 of size m and n respectively.\" This does not tell me whether the sort order is largest to smallest, or smallest to largest. It would even be possible for nums1 to be sorted largest to smallest while nums2 is sorted from smallest to largest. So I thought we would need to be able to handle such cases, making no assumptions as to the direction of the sorts. As a test case of opposite sort directions in the inputs I tried:\\n[10,8,3]\\n[5,9,17]\\n\\nBoth input lists sorted as required, but in opposite directions. The median here should be 8.5, but when I ran the test case it gave me an expected answer of 6.5. So I think leetcode is making an assumption about the sort directions of the inputs that should not be made, and it is not designed to properly handle this case. What are we allowed to assume about the input sort direction?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement does not explicitly mention the sort order. However, it is conventionally assumed that, unless stated otherwise, a \"sorted\" array or list is in non-decreasing order, meaning from smallest to largest. This assumption is consistent with most problems and discussions involving sorted data in computer science and mathematics.\\n\\nTherefore, in the context of this problem, you can assume that both input arrays are sorted in non-decreasing order. This assumption informs the approach to solving the problem. If the arrays were sorted in non-increasing order or if one array was sorted in increasing order while the other in decreasing order, a different approach might be necessary.\\n\\nHowever, if the problem were to handle arrays sorted in either direction, a pre-processing step could be added to sort the arrays in the desired order before proceeding with the rest of the algorithm. This would increase the time complexity, though, because sorting is generally an O(n log n) operation."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit before validating your solution against a few edge cases, e.g.\n```\n[-932210,-932056,-922328,-917451,-913929,-907514,-883337,-802571,-739964,-709048,-692863,-690427,-679691,-666576,-643630,-638229,-585992,-574362,-571309,-541584,-538138,-497470,-480909,-459608,-444410,-426022,-403497,-393857,-363379,-359219,-347291,-330378,-314805,-303621,-291243,-251965,-244657,-243891,-236303,-234099,-217309,-210326,-199139,-197450,-177317,-172519,-170556,-137069,-128436,-113727,-95170,-79317,-52534,-4681,40199,89215,107649,109238,124507,157189,162498,180216,200111,228032,251189,262426,319119,323615,344264,345305,373566,399588,411387,427092,427955,456725,461974,468467,474372,476390,562956,577916,580839,591862,616385,638656,650816,653650,672517,753495,769837,779299,801738,809541,836250,872512,917419,949439,959386,979587]\n[]\n[]\n[-999311,-995487,-993598,-993127,-989482,-973229,-926998,-898485,-851725,-850712,-836433,-795269,-784476,-764197,-763427,-756479,-755190,-753600,-717158,-677976,-668634,-640052,-597569,-589282,-520481,-515063,-499955,-479622,-477302,-473002,-403966,-400582,-388037,-363473,-344547,-324788,-320701,-314920,-296000,-290463,-276432,-273513,-244152,-215671,-192226,-184426,-128230,-122297,-75423,-58001,-8481,2993,27765,54297,64282,81674,93781,96008,152144,154165,166583,169777,181118,191164,216155,263473,271293,308484,360932,380484,405656,413389,432913,436707,461128,530274,555172,576238,595665,608718,624952,644037,684003,697121,727400,730624,751135,768207,784915,792103,809755,831583,832823,844259,886508,913559,941025,950966,975298]\n[-999567,-997502,-997320,-997131,-995209,-993605,-991650,-991613,-991417,-990564,-989776,-987550,-985870,-985386,-982368,-981518,-979842,-979718,-978628,-976620,-974345,-973518,-972291,-967402,-967265,-966730,-965785,-962771,-961174,-960505,-959719,-955802,-955134,-953099,-948117,-944790,-941695,-941693,-939131,-938510,-937577,-937038,-935074,-933558,-933056,-930614,-929544,-924799,-922049,-920262,-919703,-917939,-916145,-915636,-914995,-913579,-896888,-894679,-894651,-891943,-891618,-891260,-888315,-886543,-884101,-883513,-872873,-872826,-872120,-871050,-870232,-869805,-868351,-867330,-866646,-866243,-863978,-863009,-859149,-858906,-858758,-854975,-852689,-852164,-851427,-850218,-847970,-845912,-845486,-844687,-844411,-843956,-843353,-839477,-837499,-836703,-833607,-831373,-830358,-827611,-827276,-827145,-827057,-825816,-823331,-822868,-822693,-821423,-820561,-819808,-815340,-814889,-814639,-814554,-813263,-811601,-810742,-810567,-808592,-807943,-805362,-805085,-803725,-798929,-792149,-789206,-785856,-783704,-783011,-781163,-775292,-772930,-769271,-764889,-764165,-763180,-758264,-756607,-755921,-752956,-752637,-751864,-751318,-750878,-750246,-749003,-746825,-744464,-744367,-743637,-741289,-738903,-736545,-732164,-731981,-731878,-730164,-727779,-725497,-725433,-720206,-715719,-714089,-707566,-705091,-705008,-705000,-699566,-696000,-694414,-689552,-688092,-683083,-681058,-680084,-676059,-675854,-675730,-672990,-671402,-669298,-669292,-667660,-667250,-662853,-660122,-658209,-657793,-657002,-656472,-653603,-647017,-643156,-642765,-642520,-638572,-637837,-636344,-635145,-629818,-628344,-624890,-622582,-621602,-619124,-617701,-616391,-613542,-609069,-605811,-604133,-603960,-602075,-601936,-601600,-599041,-598358,-597574,-597092,-596147,-594696,-592955,-592300,-591877,-591829,-591201,-589912,-584118,-583933,-574753,-567021,-566697,-565332,-564305,-562776,-561152,-557378,-553247,-551405,-541292,-536736,-533881,-533615,-532784,-531029,-530553,-527184,-526662,-525823,-525625,-525093,-520969,-520545,-515036,-510919,-507746,-504592,-504032,-503595,-501437,-499214,-496301,-494795,-490284,-486646,-485513,-484383,-480751,-476832,-476559,-474296,-469572,-469152,-468659,-466347,-462419,-460567,-458882,-457050,-454911,-453624,-452324,-450481,-449509,-440836,-439940,-436508,-434347,-431863,-426890,-422954,-422337,-419891,-419812,-419313,-415360,-413516,-410195,-409526,-409454,-408360,-408054,-406101,-404269,-401590,-400963,-394836,-385314,-375836,-374995,-374048,-368693,-368131,-367859,-361397,-360458,-356055,-354270,-354227,-346946,-346223,-346099,-345855,-344808,-344247,-343806,-342087,-339682,-338497,-335912,-334945,-330597,-328200,-327450,-323098,-320641,-319061,-316787,-314312,-314133,-313427,-313020,-311735,-311556,-308652,-307950,-307902,-305049,-304780,-304200,-301782,-301539,-296853,-296489,-293520,-285339,-284857,-284262,-283709,-282070,-281202,-281164,-277190,-276021,-274641,-273757,-273728,-270394,-269087,-265427,-265272,-264115,-263447,-262116,-259606,-257673,-257419,-257235,-257127,-257053,-256900,-256146,-255547,-253986,-249576,-249079,-245481,-239011,-235597,-230997,-228005,-227497,-227250,-226380,-225431,-216611,-210008,-208956,-208838,-201921,-199428,-196686,-191696,-190547,-189199,-188847,-188753,-186418,-185773,-185206,-182706,-180515,-179348,-178474,-175203,-174731,-173012,-173012,-171115,-170095,-168308,-168128,-166905,-166742,-164733,-164448,-158590,-157720,-156014,-155429,-153638,-149375,-148870,-148098,-147945,-145512,-145183,-141591,-139964,-137213,-134488,-133486,-132424,-131215,-130615,-125187,-124332,-117324,-113085,-112523,-111751,-111383,-104409,-104344,-102517,-102161,-98185,-97846,-91902,-89723,-84742,-84067,-83948,-82603,-82579,-78160,-76854,-75430,-75344,-74962,-71408,-69102,-66641,-65642,-64757,-61211,-60329,-57886,-53220,-52898,-49270,-49124,-48080,-45815,-44789,-37626,-34882,-34859,-32485,-31102,-29729,-24983,-22453,-20259,-16334,-16193,-15026,-12533,-11486,-9861,-4017,-404,704,6117,7576,8139,8688,16526,17499,22574,25852,26549,29362,30492,33676,37645,40152,43767,44242,46314,47444,50651,52396,53898,59922,60919,63930,68755,69424,70153,71709,73909,75531,75770,77643,78793,81457,83544,85477,89943,91011,91041,91192,94363,94670,95048,96537,98525,98539,104346,107800,108042,109819,110121,115691,117048,118363,118924,120311,125092,127555,127995,128168,135729,138889,140152,140261,140971,145327,145731,145860,152322,155692,159510,161250,163594,164930,166753,167883,168915,172982,173783,174795,175457,179314,180491,180628,189221,190490,190611,193586,195760,199322,201329,202231,202971,205732,206448,209484,210079,213383,213627,214223,215757,218866,223260,224593,225505,228101,229883,232562,234221,235355,236464,236563,238608,240104,242362,242959,245209,246122,246173,249953,255505,258524,260918,261968,262033,262830,263342,263665,265410,265772,266591,268471,270067,274107,276862,277801,277848,278505,278931,279516,285322,286378,293299,294255,296317,296787,297292,300002,302027,302121,302296,304390,304403,306514,311250,311643,316657,317008,319056,320827,322849,324605,326098,326173,326315,326588,328330,329876,330948,331341,331948,332124,341297,341942,343708,344436,344659,350897,351495,351893,352596,353479,355046,356056,357088,357742,358398,360172,365218,372048,375602,376611,382420,386919,389469,391011,392771,396046,403823,404843,407192,409690,410139,411497,418925,419472,419584,420171,421967,425637,428244,428593,429601,430662,431024,432899,434667,438639,438690,438839,441713,443399,449585,454891,459572,461567,464223,464977,468031,468216,468980,469952,471601,473590,476517,477804,478040,479232,481442,482516,487561,489198,493596,494509,498310,500634,502180,503663,504932,507455,511419,515818,517896,518474,520182,520335,520403,520452,523949,524745,525015,526693,531560,536815,536885,536922,537002,537675,541832,543158,547884,548488,549711,559134,559481,559820,560772,560870,561935,563399,563985,568956,569744,570203,573437,574202,574696,578813,579430,588576,588747,590647,604861,606852,606861,607746,608154,609468,609523,611937,611965,612112,614230,619688,620348,621041,621873,622766,633850,636410,645785,647203,647468,648663,651250,653354,655650,655736,656313,656473,660352,665886,668634,668889,668947,670032,670182,670412,673826,686025,686683,691645,692054,692284,695765,697395,697829,702166,708541,709011,711141,712520,714573,716618,721072,721706,721848,721884,722339,722954,724012,724181,726931,729781,730450,732815,734038,734313,735874,736725,737913,738002,740812,743047,744545,745638,746517,747495,747721,754971,755927,760296,760368,768237,770512,771998,772642,773928,775652,776009,776528,778433,784050,788493,788662,790251,794398,797252,797470,798288,800465,801126,806618,807774,810900,812412,812864,815004,819410,819576,821429,822144,828766,831814,834893,834987,838359,839232,839741,845812,846318,851048,851400,852080,856264,859668,861457,862611,863385,867019,872146,872332,877196,879288,879573,883230,888081,889012,889628,889844,890313,891004,891633,897234,900619,901180,901991,904976,905449,905491,905566,906218,906325,911636,912008,912597,917627,919382,921003,924181,925430,925724,925947,929266,934039,935863,937145,938405,941714,945193,946019,948295,950933,951602,951856,952469,953824,954207,954485,954748,959150,960644,962815,963477,963549,963815,964638,965098,967348,967682,969084,971079,973452,974228,976702,976910,978359,981049,982811,982859,987419,993386,994771,995167,996051,998221]\n[-987944,-969636,-969382,-963918,-960334,-957471,-955419,-954534,-949617,-948164,-941370,-934887,-933385,-933024,-925395,-920598,-914952,-912930,-910713,-898551,-897943,-895093,-883721,-881114,-868961,-862108,-859224,-844995,-843122,-841350,-839681,-837319,-833916,-832929,-824567,-821404,-817679,-816414,-815142,-814794,-814428,-812717,-803053,-800629,-791874,-784923,-776546,-772543,-770170,-769595,-767768,-764581,-760610,-755916,-750060,-738122,-734792,-733242,-728895,-725665,-725507,-718134,-717075,-715534,-715202,-713373,-712097,-708739,-707414,-706871,-703365,-702017,-693735,-683042,-672054,-669261,-668919,-664791,-661728,-660926,-656147,-645420,-643702,-643193,-641435,-638420,-634551,-628772,-615960,-603372,-601747,-598111,-594931,-589739,-582816,-582756,-578800,-578594,-573174,-567081,-559766,-559620,-556681,-554084,-553002,-549693,-548262,-545226,-544969,-537261,-533737,-528123,-520081,-506744,-504736,-499021,-496520,-496470,-495274,-493267,-486175,-485863,-484654,-482183,-481473,-479689,-476360,-474984,-474568,-470604,-469841,-458033,-456643,-456026,-449361,-448407,-447725,-446572,-444202,-444122,-438385,-438174,-436049,-433511,-429215,-428895,-423500,-419598,-414944,-413779,-413601,-413134,-395813,-386542,-386081,-384022,-383217,-377664,-375237,-370842,-368652,-368619,-367534,-360286,-359315,-356864,-346574,-344238,-342362,-338322,-337904,-317031,-315369,-311471,-307529,-291585,-288367,-282217,-273392,-268202,-266384,-262947,-261304,-259484,-253107,-253097,-247496,-240183,-238502,-232673,-225567,-225273,-220556,-218540,-217405,-209508,-209191,-198492,-196102,-194657,-187900,-187654,-187409,-183298,-183195,-178895,-172948,-164463,-150912,-150447,-147157,-146039,-142859,-142513,-141007,-140514,-133632,-121672,-120655,-111524,-106570,-104308,-101032,-100077,-99330,-98302,-93625,-88734,-88072,-87928,-84357,-71659,-69515,-67676,-63282,-58552,-56529,-55822,-52857,-49183,-49096,-36632,-35822,-22044,-15543,-13193,-11327,-8347,-5921,367,2667,4951,5292,12503,13977,16698,20683,21104,29329,29383,32131,36676,38796,38939,39209,47231,48354,58584,63004,67608,68400,79071,80602,81795,86542,94114,101023,103400,104656,104880,111548,112896,115766,121077,122734,127019,127444,132932,138051,140440,154194,158884,165068,166138,166908,169497,170785,171990,179699,180030,188999,195927,197727,215034,218444,219489,222687,224521,235464,235727,241470,243528,246904,258231,259122,260441,263591,265308,267313,269450,272354,272547,274104,276239,278349,282844,283153,284414,285344,292275,301326,301817,303601,305996,308758,308841,318258,318758,326276,328210,328413,329591,330688,335804,336586,338827,350724,353017,355893,356488,358137,367458,369246,373776,375814,388619,389665,391494,398826,410285,414310,434616,436368,437657,441921,442891,443722,445197,448982,449981,452442,455491,458606,458789,459482,459977,460011,467293,480680,484432,486822,491840,495107,498402,498655,499730,501125,506371,507661,508352,508531,510705,517473,521451,521763,531020,535521,536548,538401,543120,545936,546904,551503,551845,552061,557919,565312,566269,568604,574239,574420,578570,579251,582167,587488,592161,594286,604994,619288,622829,629325,652728,657554,659113,659971,661630,664091,664280,667722,673155,674069,675252,680792,683874,685152,698652,701722,703282,708464,710121,710242,712200,718611,720934,732059,736885,739191,742494,750812,759987,772722,776392,782107,782131,783537,783996,785898,793147,799555,806418,807432,808677,831974,841540,844398,849513,849656,854080,855359,858674,865625,866262,870340,877863,886981,896266,898306,900880,903869,907452,914307,916336,916960,922084,923604,924431,926571,930085,935193,948240,948473,954648,957779,959463,960134,960965,975144,979240,997354,999899]\n[0,2,3,4,4,6,6,7,8,8,8,8,11,11,15,16,17,20,22,26,26,28,29,30,31,32,36,39,40,41,41,44,45,52,52,53,54,56,57,62,70,71,72,74,78,78,80,80,83,84,86,87,88,90,91,92,92,96,99,104,105,106,110,110,112,113,113,115,116,118,119,121,121,123,124,125,125,129,129,131,131,134,135,140,141,141,143,144,145,145,145,150,152,153,154,157,158,159,159,159,164,164,169,172,176,176,177,178,178,184,185,189,189,190,191,192,193,193,194,194,195,196,196,200,203,204,205,206,210,211,211,212,212,213,216,219,220,222,225,226,229,229,233,234,237,238,239,241,243,243,246,246,248,249,249,250,250,251,253,255,256,258,260,260,262,266,268,268,269,271,272,273,273,280,281,282,283,288,288,295,296,296,298,302,304,305,305,305,305,306,306,308,309,310,312,313,315,315,318,318,319,319,321,322,323,324,324,326,329,329,329,331,331,333,333,334,334,336,339,339,340,341,341,343,344,348,351,351,352,353,354,354,358,359,363,364,364,365,367,367,368,369,370,372,372,373,376,376,378,379,379,381,382,383,385,386,391,391,391,394,396,399,400,411,414,414,414,416,423,429,429,430,430,431,435,436,437,438,442,443,444,447,448,452,452,452,452,452,455,456,457,457,462,466,468,468,468,472,472,472,472,473,473,475,476,476,477,477,480,481,481,482,483,483,484,485,485,486,486,491,491,491,491,492,494,495,497,497,500,502,503,505,505,509,510,514,515,515,515,516,516,518,519,519,520,522,524,525,527,528,529,531,534,537,537,540,543,543,544,544,545,549,552,552,556,558,558,565,565,566,569,570,571,572,575,577,577,578,579,579,581,583,584,586,586,590,591,593,597,603,603,605,607,608,611,613,614,622,622,622,623,631,631,633,635,638,638,639,642,643,644,645,646,649,652,653,653,654,655,655,655,655,657,659,660,661,664,665,666,667,671,682,684,685,686,688,691,692,694,694,696,698,699,702,704,704,704,706,706,709,710,713,713,714,717,723,725,726,727,727,729,730,730,732,732,733,734,738,740,740,741,746,750,751,751,755,755,758,759,759,760,764,765,767,769,771,773,774,775,776,779,779,781,782,785,797,797,798,798,798,802,803,804,804,806,807,808,809,809,810,810,812,814,814,818,819,820,822,822,823,824,826,826,826,827,830,831,833,833,833,834,837,838,838,839,840,840,841,844,844,847,848,851,852,853,854,857,860,862,864,868,868,869,870,872,874,880,881,881,883,884,885,888,889,892,892,896,897,897,898,899,901,904,905,907,908,914,914,915,915,916,918,920,921,921,921,927,927,928,928,929,932,932,932,932,933,937,937,938,939,940,941,941,942,942,942,944,945,945,946,947,948,952,952,955,956,960,962,964,964,966,968,968,968,971,973,973,973,974,978,979,979,981,982,983,985,985,989,990,990,990,993,994,994,995,998,999,999,1000]\n[999,999,1002,1003,1003,1004,1007,1010,1016,1016,1016,1020,1020,1022,1022,1024,1024,1027,1035,1038,1038,1041,1043,1044,1054,1055,1060,1064,1066,1067,1069,1070,1070,1071,1074,1074,1075,1081,1081,1087,1090,1092,1092,1094,1095,1095,1096,1097,1097,1098,1099,1103,1103,1103,1104,1104,1104,1105,1105,1108,1109,1109,1112,1112,1113,1116,1117,1117,1117,1117,1119,1121,1122,1124,1124,1125,1129,1129,1130,1131,1133,1133,1133,1135,1139,1140,1142,1142,1143,1144,1145,1146,1146,1148,1149,1151,1151,1151,1151,1152,1153,1153,1158,1159,1161,1164,1167,1171,1172,1173,1174,1176,1178,1178,1179,1180,1181,1182,1182,1183,1183,1185,1185,1186,1188,1189,1191,1192,1195,1200,1201,1201,1203,1204,1206,1207,1208,1208,1209,1210,1212,1212,1215,1216,1217,1222,1224,1225,1226,1226,1229,1230,1232,1232,1239,1241,1241,1243,1243,1244,1249,1252,1255,1256,1257,1263,1266,1266,1266,1270,1272,1274,1274,1280,1281,1288,1288,1288,1291,1291,1292,1296,1299,1301,1304,1304,1305,1306,1307,1310,1311,1311,1311,1312,1313,1313,1315,1315,1315,1319,1320,1321,1321,1321,1324,1324,1326,1327,1328,1330,1335,1348,1350,1351,1353,1355,1357,1357,1361,1365,1367,1368,1372,1374,1377,1383,1385,1388,1390,1390,1393,1393,1397,1398,1398,1398,1401,1402,1404,1405,1406,1407,1410,1410,1412,1412,1413,1414,1416,1416,1416,1416,1417,1418,1419,1423,1423,1428,1430,1432,1432,1433,1435,1436,1437,1438,1441,1441,1444,1444,1445,1449,1449,1449,1453,1457,1464,1466,1467,1469,1472,1475,1475,1478,1480,1485,1488,1488,1488,1489,1491,1493,1499,1500,1500,1500,1504,1505,1507,1508,1509,1510,1512,1512,1516,1519,1522,1528,1530,1532,1532,1538,1540,1540,1543,1545,1546,1548,1551,1553,1554,1555,1555,1561,1562,1563,1564,1565,1565,1569,1570,1570,1571,1572,1572,1577,1580,1580,1589,1589,1596,1599,1600,1600,1600,1600,1601,1602,1603,1607,1609,1610,1617,1618,1623,1623,1624,1626,1628,1629,1629,1630,1634,1637,1637,1637,1642,1645,1646,1646,1647,1647,1652,1657,1660,1662,1663,1666,1666,1667,1669,1670,1673,1675,1675,1677,1678,1678,1684,1686,1691,1691,1692,1694,1694,1697,1700,1700,1703,1704,1706,1706,1714,1715,1720,1720,1720,1720,1721,1721,1723,1725,1726,1728,1730,1730,1732,1733,1736,1739,1742,1744,1744,1752,1758,1759,1760,1764,1765,1766,1767,1769,1769,1773,1773,1773,1774,1775,1775,1775,1780,1783,1785,1785,1790,1791,1792,1793,1793,1795,1800,1803,1805,1807,1808,1811,1811,1811,1812,1812,1815,1816,1818,1819,1820,1821,1822,1823,1827,1828,1829,1830,1832,1835,1835,1835,1837,1839,1843,1843,1846,1849,1849,1849,1849,1851,1853,1853,1853,1854,1855,1861,1863,1865,1868,1870,1873,1878,1879,1881,1881,1881,1883,1883,1884,1885,1887,1889,1890,1891,1891,1894,1895,1896,1898,1899,1899,1901,1902,1904,1906,1907,1912,1912,1914,1914,1915,1917,1920,1921,1924,1926,1928,1930,1930,1931,1932,1933,1934,1934,1935,1936,1942,1943,1944,1947,1947,1948,1950,1951,1952,1953,1954,1956,1956,1957,1963,1964,1965,1966,1968,1968,1970,1971,1973,1979,1979,1981,1982,1986,1986,1986,1989,1992,1992,1998,1998,1999,1999,1999,2000]\n[1,1,2,4,7,10,10,11,17,24,26,26,27,28,32,33,33,35,35,35,37,37,37,38,40,41,45,48,50,50,53,53,54,55,55,55,56,57,63,66,68,71,76,79,81,81,82,83,85,88,89,91,95,96,100,102,103,104,104,105,107,107,108,109,109,112,116,118,118,118,119,119,120,121,123,124,124,127,128,128,128,130,132,134,134,140,141,141,143,143,144,147,148,150,150,152,153,155,156,157,164,166,166,167,167,168,176,178,184,185,190,191,191,192,193,194,197,199,201,201,204,207,207,211,211,216,225,225,228,229,233,234,235,237,237,237,238,239,239,244,247,248,248,251,251,254,258,259,259,261,263,266,268,269,269,269,269,271,281,282,285,285,286,287,292,293,295,295,295,296,300,300,302,305,305,305,309,310,310,310,311,318,319,319,320,320,321,321,322,328,329,332,333,334,335,336,336,339,339,339,341,341,345,346,346,347,348,348,349,349,349,350,351,351,355,356,361,363,363,364,366,366,367,368,368,371,371,373,377,380,381,381,382,384,384,387,387,389,394,395,399,400,402,406,406,407,407,410,415,418,419,424,427,433,434,436,437,442,444,445,451,455,455,456,457,459,461,462,463,464,464,465,465,465,467,468,469,473,476,476,476,480,482,483,486,488,489,490,493,495,495,496,496,497,499,499,500,502,504,505,509,509,511,511,516,516,517,521,523,525,526,528,528,530,534,534,535,538,538,541,541,544,544,544,544,546,547,550,550,551,553,555,556,556,557,558,558,559,561,563,567,569,569,570,571,571,572,574,574,575,575,578,582,583,583,584,584,586,590,592,592,594,595,596,598,598,598,601,603,603,604,612,617,618,620,620,624,626,627,628,631,635,637,637,638,641,645,650,651,652,653,654,657,659,659,661,661,661,661,662,663,663,664,664,665,666,669,670,670,671,675,676,683,684,688,689,689,689,690,691,692,694,695,695,696,697,697,700,705,705,707,708,708,709,709,710,710,712,714,716,716,716,718,721,722,722,723,724,725,728,728,729,730,735,735,737,737,741,741,744,747,748,749,750,751,751,754,754,755,757,757,759,759,761,763,763,763,764,766,767,771,771,777,778,778,778,781,782,782,786,786,786,787,787,787,790,790,790,791,792,792,793,801,803,804,805,805,805,805,807,808,808,808,810,815,817,819,819,822,829,829,830,832,832,834,834,836,836,836,837,842,843,844,846,846,847,847,847,850,851,852,853,853,854,854,855,855,858,860,863,864,866,866,867,871,875,881,883,883,886,888,888,890,891,892,894,897,903,913,914,915,918,918,919,920,920,922,923,925,927,927,927,927,928,937,943,943,943,946,948,949,950,953,954,958,966,968,968,971,979,980,981,983,984,985,985,987,987,990,991,992,992,992,997,999]\n[999,1000,1001,1001,1002,1005,1006,1008,1009,1011,1014,1014,1018,1019,1021,1026,1027,1031,1031,1032,1033,1034,1037,1038,1039,1041,1042,1043,1043,1043,1046,1049,1054,1055,1055,1058,1060,1064,1065,1065,1067,1067,1068,1074,1076,1076,1082,1082,1083,1084,1085,1086,1087,1094,1094,1095,1098,1101,1104,1104,1105,1105,1106,1106,1106,1107,1108,1112,1112,1113,1117,1118,1118,1119,1124,1124,1126,1126,1126,1130,1130,1132,1132,1133,1133,1134,1134,1136,1137,1139,1139,1139,1139,1139,1140,1141,1141,1141,1143,1144,1145,1147,1147,1150,1152,1153,1155,1157,1158,1159,1160,1161,1162,1163,1163,1165,1167,1167,1167,1167,1168,1168,1168,1168,1169,1171,1171,1172,1172,1173,1176,1177,1178,1178,1180,1181,1183,1184,1184,1185,1186,1186,1187,1188,1188,1189,1190,1191,1195,1196,1199,1200,1200,1201,1202,1206,1207,1208,1209,1211,1211,1212,1217,1221,1221,1222,1222,1224,1225,1226,1230,1230,1231,1232,1237,1237,1240,1243,1243,1243,1243,1243,1245,1245,1248,1248,1248,1249,1249,1253,1254,1255,1257,1258,1260,1265,1266,1268,1269,1270,1271,1271,1273,1274,1275,1277,1278,1279,1280,1281,1281,1283,1283,1284,1284,1286,1286,1287,1288,1288,1289,1290,1291,1292,1292,1295,1297,1298,1298,1299,1301,1302,1304,1306,1306,1307,1308,1310,1311,1312,1316,1316,1317,1318,1319,1320,1320,1321,1322,1324,1324,1324,1325,1327,1329,1330,1331,1331,1331,1332,1333,1333,1334,1336,1342,1345,1346,1347,1347,1349,1349,1350,1351,1352,1355,1355,1356,1357,1357,1362,1363,1364,1364,1364,1365,1370,1370,1372,1372,1374,1374,1375,1375,1376,1376,1378,1379,1379,1381,1382,1383,1384,1385,1386,1389,1391,1391,1391,1393,1394,1395,1397,1397,1401,1403,1405,1405,1406,1407,1407,1408,1409,1410,1413,1413,1416,1418,1418,1421,1422,1422,1424,1424,1425,1426,1428,1428,1429,1430,1434,1436,1439,1439,1439,1439,1440,1440,1441,1441,1442,1442,1442,1444,1445,1447,1447,1451,1451,1452,1456,1460,1462,1463,1468,1469,1469,1470,1470,1471,1472,1472,1474,1476,1478,1478,1482,1484,1486,1486,1488,1489,1489,1493,1494,1495,1495,1497,1498,1502,1503,1505,1506,1507,1507,1508,1511,1512,1513,1514,1515,1516,1518,1520,1520,1520,1522,1523,1525,1525,1527,1527,1528,1531,1531,1532,1533,1534,1535,1537,1538,1540,1540,1541,1543,1543,1544,1545,1546,1548,1549,1551,1551,1552,1552,1552,1553,1556,1556,1557,1557,1557,1559,1559,1560,1561,1561,1562,1564,1564,1564,1564,1566,1566,1567,1571,1571,1572,1573,1573,1574,1574,1577,1577,1583,1584,1584,1588,1589,1590,1593,1593,1595,1596,1596,1596,1597,1598,1601,1604,1604,1606,1606,1607,1607,1610,1610,1611,1611,1612,1612,1614,1615,1616,1617,1621,1622,1622,1622,1623,1626,1627,1631,1632,1636,1637,1637,1638,1640,1642,1642,1644,1645,1647,1648,1650,1651,1652,1653,1655,1655,1656,1656,1656,1656,1658,1658,1658,1660,1660,1663,1664,1665,1666,1667,1667,1667,1669,1669,1670,1676,1678,1680,1681,1681,1682,1684,1684,1685,1686,1686,1687,1689,1689,1689,1690,1693,1694,1698,1700,1702,1703,1706,1708,1708,1708,1710,1712,1712,1712,1713,1715,1715,1717,1719,1719,1720,1720,1721,1722,1722,1724,1731,1732,1734,1734,1737,1737,1741,1743,1743,1749,1749,1751,1753,1754,1754,1756,1757,1757,1758,1759,1761,1761,1762,1764,1766,1766,1767,1769,1769,1771,1772,1772,1775,1775,1775,1777,1779,1779,1781,1782,1782,1783,1786,1788,1788,1788,1790,1793,1793,1793,1793,1794,1795,1795,1796,1796,1796,1797,1799,1800,1803,1810,1811,1814,1814,1814,1816,1817,1819,1820,1820,1822,1824,1826,1826,1826,1827,1828,1828,1831,1832,1834,1835,1836,1837,1838,1838,1841,1843,1849,1851,1851,1852,1852,1853,1853,1854,1854,1856,1858,1859,1863,1863,1863,1869,1871,1872,1872,1873,1874,1879,1880,1881,1881,1882,1883,1883,1883,1885,1885,1885,1886,1887,1887,1889,1894,1898,1899,1901,1902,1903,1904,1907,1908,1910,1911,1911,1911,1913,1914,1914,1915,1916,1917,1918,1921,1922,1923,1923,1924,1926,1926,1933,1933,1934,1934,1934,1936,1938,1938,1939,1939,1941,1941,1942,1942,1947,1947,1947,1947,1949,1949,1952,1954,1955,1957,1958,1959,1960,1960,1963,1964,1964,1964,1966,1968,1971,1973,1975,1977,1978,1978,1979,1979,1980,1981,1981,1982,1984,1985,1985,1987,1987,1987,1987,1987,1988,1989,1990,1991,1994,1994,1995,1996,1997,1997,1998]\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this help](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e)s and makes thinks clear\\nand do clap \\uD83D\\uDC4F to appreciate the article"
                    },
                    {
                        "username": "pwho",
                        "content": "If you\\'re going to share an article here, don\\'t hide it behind a paywall. =\\\\"
                    },
                    {
                        "username": "user5979vk",
                        "content": "Thanks (https://archive.is/E2agn)"
                    },
                    {
                        "username": "4alisha",
                        "content": "very helpful\\uD83D\\uDC4F"
                    },
                    {
                        "username": "thecodingkid",
                        "content": "Any help would be appreciated if you could explain why the solution in the O(log(min(m,n))) case requires a swap if the second array is smaller.\\n\\nIf you could specify any edge case that is failing , that would be of great help."
                    },
                    {
                        "username": "bparanj",
                        "content": "Swapping nums1 and nums2 if nums1 is larger than nums2 is a trick to simplify the problem by reducing it to a condition where we always binary search on the smaller array. This doesn\\'t change the result because the median of two arrays doesn\\'t depend on which array is longer, but it makes the code cleaner and easier to understand, and it also improves performance by minimizing the search space.\\n\\nMoreover, this technique ensures that we do not run into an index out of bounds error during our binary search process. \\n\\nLet\\'s consider an edge case where the swapping would be important:\\n\\nnums1 = [6, 7, 8, 9, 10]\\nnums2 = [1, 2, 3]\\n\\nIf we did not swap, and started the binary search on nums1, we would end up exploring unnecessary parts of nums1 that wouldn\\'t impact the final result, since we know that the median must be within the range covered by nums2 due to its smaller size and range of values. \\n\\nIf we swap and binary search on nums2, we can find the median more efficiently because we focus on the smaller range of values. We then only need to compare with a few specific elements of nums1.\\n\\nTo summarize, the swap is used to ensure efficiency and simplicity by always performing binary search on the smaller array."
                    }
                ]
            },
            {
                "id": 1573664,
                "content": [
                    {
                        "username": "yon",
                        "content": "Input:\\t[1,1], [1,2]\\nExpected:\\t1.00000\\n\\nMy solution way is merge [1,1] and [1,2] to [1,2], so the answer would be (1+2)/2 = 1.5\\nWhat did I made wrong?"
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "you first merge it (preserving duplicates).\\n[1, 1, 1, 2]\\n\\nWhats the middle element here?\\noh wait. there are two elements at the middle. 1 and 1.\\nso you average em. \\n(1 + 1) / 2 = 1"
                    },
                    {
                        "username": "RISHIKA_GANDHI",
                        "content": "change your (1+2)/2 to this (1+2)/2.0 you will get you result into float/double type"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "the merged array will we [1,1,1,2] ,\\nno of elements are even so median will we (1+1)/2=1.\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the hell nooo. median is 1 here"
                    },
                    {
                        "username": "hankIgoe",
                        "content": "the merged string is [1,1,1,2], so the median is (1+1)/2 = 1.0\\n"
                    },
                    {
                        "username": "vyshnusanthosh",
                        "content": "If you are using java, when two integers are divided the answer will also be an integer in order to get floating point you need to type cast the integers to double or float before division."
                    },
                    {
                        "username": "megazortti",
                        "content": "i\\'m facing the same problem..\\n"
                    },
                    {
                        "username": "khushal1201",
                        "content": "[@zwicky](/zwicky) the merged array should be [1,1,1,2]. Hence the median would be (1+1)/2 = 1."
                    },
                    {
                        "username": "zwicky",
                        "content": "you shouldn\\'t remove duplicates"
                    },
                    {
                        "username": "hing_liu",
                        "content": "Let try to interate the algorithm first:\\n\\nIt is basically a k-th smallest element problem between two sorted arrays, let assume we have the following two arrays:\\n\\n5,7,8,11\\n4,9,12,14\\n\\nk = 4 (expected ans = 8 because when it is sorted: 4,5,7,**8**,9,11,12,14)\\n\\nStep 1: Cut the two arrays into two pieces such that the left side will have total items of 4 (i.e. the **K=4**)\\n5,7 | 8, 11\\n4,9 | 12, 14\\n\\nStep 2: We remove [5,7] because its end index at the left side is smaller (7. v.s 9) and we update K = 2 (since we removed 2 item=> K - 2 = 4 - 2 = 2), it will becomes:\\n8,11 <-- removed [5,7]\\n4,9,12,14\\n\\n(basically the rest of the steps below is to repeat 1 and 2 until K = 1)\\n\\nStep 3: Repeat Step 1, Cut into two half base on **K = 2**\\n8 | 11\\n4 | 9 12 14\\n\\nStep 4: Repeat Step 2, that is remove 4 and update **K = 1** (since we removed 1 item=>K-1 = 2-1 1)\\n\\nStep 5: Repeat Step 1, Cut into two half base on K = 1, since K = 1 is not able to split (we have two arrays, don\\'t know how to split), we conclude the solution as the minimum of the first item of the two array, that is min(8,9) = 8\\n8,11\\n9,12,14\\n\\nWe are all done, how about K = 3 initially? Basically the point of \\'cut\\' is K/2 - 1, therefore when K = 3, the cutting point is index=0, let us go though this again quickly for this:\\n\\nK=3\\n5|7,8,11\\n4|9,12,14\\n\\nK=2\\n5|7,8,11\\n9|12,14\\n\\nK=1\\n7|8,11\\n9|12,14 \\nAns=min(7,9) = 7\\n\\nThere is some edge case not tell here, this is just a general idea. We want to have the first K-th item, so, the first target is to collect the first K item from the two array, so we fairly cut them at K/2 - 1 and remove the smaller list until K = 1.\\n\\nThis might be still hard to understand, consider we are not greedy, we do it one by one (we don\\'t cut base on K, but always cut by two):\\n\\nK=4\\n5 | 7 8 11\\n4 | 9 12 14\\n\\nAt this point, we remove the smaller one and have:\\nK=3\\n5 | 7 8 11\\n9 | 12 14\\n\\nKeep doing this until K = 1\\nK=2\\n7 | 8 11\\n9 | 12 14\\n\\nK = 1\\n8 | 11\\n9 | 12 14\\n(at this point, all done)\\n\\nWe are now reaching the answer = 8 by doing this in one-by-one manner, the cutting point at this \\'slow-version\\' is always [0], and the faster version is doing the cutting point at [k/2 - 1], that still work because they are sorted, it is safe to jump further and remove the whole preceding items rather than doing this one-by-one manner.\\n\\nAgain, this might still be hard to convince yourself why the \\'faster-version\\' has no issue, just hope this can help you understand more.\\n\\nGoing back to tell why it is a k-th minimum issue, consider when we have ths int kth(arr1, arr2, k) function, we can put k to be the middle of sizeof(arr1) and sizeof(arr2), if it is even number of size we just get the adjacent (run kth function two times) so we can get the middle two and divide it by 2, so the answer ..."
                    },
                    {
                        "username": "rds8rds",
                        "content": "thanks properly understand the concept!"
                    },
                    {
                        "username": "parismania",
                        "content": "That\\'s quite a good explanation. Thank you!"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I tried to avoid this question for as long as possible"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally solved this by merging the two arrays. I always intended to do the proper solution - one day. Today is the day."
                    },
                    {
                        "username": "raviTejaY",
                        "content": "\\tvar findMedianSortedArrays = function(nums1, nums2) {\\n  \\tlet mid;\\n\\t  let res = [...nums1, ...nums2].sort((a,b) => a-b);\\n\\t mid = (res.length-1)/2;\\n\\t  if(res.length % 2 === 1){\\n\\t\\treturn res[mid].toFixed(5);\\n\\t  } else {\\n\\t\\tlet median = (res[Math.floor(mid)] + res[Math.ceil(mid)]) / 2;\\n\\t\\treturn median.toFixed(5)\\n\\t  }\\n\\t};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, you use .sort(), which does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "hongbin2",
                        "content": "My naive solution is just merge two array and find the median. Obvious we can do better. But I just have no idea about it."
                    },
                    {
                        "username": "aneesfathimasaifudeen",
                        "content": "Input\\n[1,2]\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000\\n\\nThis test case always fails for me in leetcode, whereas it works for me in my machine\\'s python compiler with the same code.\\n\\nCan anyone tell, what would be the problem here?"
                    },
                    {
                        "username": "evenn",
                        "content": "choose Python3 rather than Python to execute code"
                    },
                    {
                        "username": "kapilkapuriya",
                        "content": "[@jeetu16](/jeetu16)  use type cast when you perform   ** ans = a/2 **  so do like this  **  ans = double(a)/2 ** "
                    },
                    {
                        "username": "doubleshab",
                        "content": "[@jeetu16](/jeetu16) I had a similar problem using Python3. For me, the issue was that the math I was using to generate my index values was producing float values. By forcing them to integer types using the int() builtin, I was able to get around it."
                    },
                    {
                        "username": "python_is_cheat_code",
                        "content": "Facing the same issue. Have no idea what to do."
                    },
                    {
                        "username": "AtrijPaul",
                        "content": "If you are coding in Java then division of two integers will be integer only , after performing the division it get stored as double. So instead of dividing by 2 , divide by 2.0 , it will work."
                    },
                    {
                        "username": "jeetu16",
                        "content": "have you found the solution till now?\\ni faced the same problem"
                    },
                    {
                        "username": "scott40",
                        "content": "The question states: \"There are two sorted arrays nums1 and nums2 of size m and n respectively.\" This does not tell me whether the sort order is largest to smallest, or smallest to largest. It would even be possible for nums1 to be sorted largest to smallest while nums2 is sorted from smallest to largest. So I thought we would need to be able to handle such cases, making no assumptions as to the direction of the sorts. As a test case of opposite sort directions in the inputs I tried:\\n[10,8,3]\\n[5,9,17]\\n\\nBoth input lists sorted as required, but in opposite directions. The median here should be 8.5, but when I ran the test case it gave me an expected answer of 6.5. So I think leetcode is making an assumption about the sort directions of the inputs that should not be made, and it is not designed to properly handle this case. What are we allowed to assume about the input sort direction?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement does not explicitly mention the sort order. However, it is conventionally assumed that, unless stated otherwise, a \"sorted\" array or list is in non-decreasing order, meaning from smallest to largest. This assumption is consistent with most problems and discussions involving sorted data in computer science and mathematics.\\n\\nTherefore, in the context of this problem, you can assume that both input arrays are sorted in non-decreasing order. This assumption informs the approach to solving the problem. If the arrays were sorted in non-increasing order or if one array was sorted in increasing order while the other in decreasing order, a different approach might be necessary.\\n\\nHowever, if the problem were to handle arrays sorted in either direction, a pre-processing step could be added to sort the arrays in the desired order before proceeding with the rest of the algorithm. This would increase the time complexity, though, because sorting is generally an O(n log n) operation."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit before validating your solution against a few edge cases, e.g.\n```\n[-932210,-932056,-922328,-917451,-913929,-907514,-883337,-802571,-739964,-709048,-692863,-690427,-679691,-666576,-643630,-638229,-585992,-574362,-571309,-541584,-538138,-497470,-480909,-459608,-444410,-426022,-403497,-393857,-363379,-359219,-347291,-330378,-314805,-303621,-291243,-251965,-244657,-243891,-236303,-234099,-217309,-210326,-199139,-197450,-177317,-172519,-170556,-137069,-128436,-113727,-95170,-79317,-52534,-4681,40199,89215,107649,109238,124507,157189,162498,180216,200111,228032,251189,262426,319119,323615,344264,345305,373566,399588,411387,427092,427955,456725,461974,468467,474372,476390,562956,577916,580839,591862,616385,638656,650816,653650,672517,753495,769837,779299,801738,809541,836250,872512,917419,949439,959386,979587]\n[]\n[]\n[-999311,-995487,-993598,-993127,-989482,-973229,-926998,-898485,-851725,-850712,-836433,-795269,-784476,-764197,-763427,-756479,-755190,-753600,-717158,-677976,-668634,-640052,-597569,-589282,-520481,-515063,-499955,-479622,-477302,-473002,-403966,-400582,-388037,-363473,-344547,-324788,-320701,-314920,-296000,-290463,-276432,-273513,-244152,-215671,-192226,-184426,-128230,-122297,-75423,-58001,-8481,2993,27765,54297,64282,81674,93781,96008,152144,154165,166583,169777,181118,191164,216155,263473,271293,308484,360932,380484,405656,413389,432913,436707,461128,530274,555172,576238,595665,608718,624952,644037,684003,697121,727400,730624,751135,768207,784915,792103,809755,831583,832823,844259,886508,913559,941025,950966,975298]\n[-999567,-997502,-997320,-997131,-995209,-993605,-991650,-991613,-991417,-990564,-989776,-987550,-985870,-985386,-982368,-981518,-979842,-979718,-978628,-976620,-974345,-973518,-972291,-967402,-967265,-966730,-965785,-962771,-961174,-960505,-959719,-955802,-955134,-953099,-948117,-944790,-941695,-941693,-939131,-938510,-937577,-937038,-935074,-933558,-933056,-930614,-929544,-924799,-922049,-920262,-919703,-917939,-916145,-915636,-914995,-913579,-896888,-894679,-894651,-891943,-891618,-891260,-888315,-886543,-884101,-883513,-872873,-872826,-872120,-871050,-870232,-869805,-868351,-867330,-866646,-866243,-863978,-863009,-859149,-858906,-858758,-854975,-852689,-852164,-851427,-850218,-847970,-845912,-845486,-844687,-844411,-843956,-843353,-839477,-837499,-836703,-833607,-831373,-830358,-827611,-827276,-827145,-827057,-825816,-823331,-822868,-822693,-821423,-820561,-819808,-815340,-814889,-814639,-814554,-813263,-811601,-810742,-810567,-808592,-807943,-805362,-805085,-803725,-798929,-792149,-789206,-785856,-783704,-783011,-781163,-775292,-772930,-769271,-764889,-764165,-763180,-758264,-756607,-755921,-752956,-752637,-751864,-751318,-750878,-750246,-749003,-746825,-744464,-744367,-743637,-741289,-738903,-736545,-732164,-731981,-731878,-730164,-727779,-725497,-725433,-720206,-715719,-714089,-707566,-705091,-705008,-705000,-699566,-696000,-694414,-689552,-688092,-683083,-681058,-680084,-676059,-675854,-675730,-672990,-671402,-669298,-669292,-667660,-667250,-662853,-660122,-658209,-657793,-657002,-656472,-653603,-647017,-643156,-642765,-642520,-638572,-637837,-636344,-635145,-629818,-628344,-624890,-622582,-621602,-619124,-617701,-616391,-613542,-609069,-605811,-604133,-603960,-602075,-601936,-601600,-599041,-598358,-597574,-597092,-596147,-594696,-592955,-592300,-591877,-591829,-591201,-589912,-584118,-583933,-574753,-567021,-566697,-565332,-564305,-562776,-561152,-557378,-553247,-551405,-541292,-536736,-533881,-533615,-532784,-531029,-530553,-527184,-526662,-525823,-525625,-525093,-520969,-520545,-515036,-510919,-507746,-504592,-504032,-503595,-501437,-499214,-496301,-494795,-490284,-486646,-485513,-484383,-480751,-476832,-476559,-474296,-469572,-469152,-468659,-466347,-462419,-460567,-458882,-457050,-454911,-453624,-452324,-450481,-449509,-440836,-439940,-436508,-434347,-431863,-426890,-422954,-422337,-419891,-419812,-419313,-415360,-413516,-410195,-409526,-409454,-408360,-408054,-406101,-404269,-401590,-400963,-394836,-385314,-375836,-374995,-374048,-368693,-368131,-367859,-361397,-360458,-356055,-354270,-354227,-346946,-346223,-346099,-345855,-344808,-344247,-343806,-342087,-339682,-338497,-335912,-334945,-330597,-328200,-327450,-323098,-320641,-319061,-316787,-314312,-314133,-313427,-313020,-311735,-311556,-308652,-307950,-307902,-305049,-304780,-304200,-301782,-301539,-296853,-296489,-293520,-285339,-284857,-284262,-283709,-282070,-281202,-281164,-277190,-276021,-274641,-273757,-273728,-270394,-269087,-265427,-265272,-264115,-263447,-262116,-259606,-257673,-257419,-257235,-257127,-257053,-256900,-256146,-255547,-253986,-249576,-249079,-245481,-239011,-235597,-230997,-228005,-227497,-227250,-226380,-225431,-216611,-210008,-208956,-208838,-201921,-199428,-196686,-191696,-190547,-189199,-188847,-188753,-186418,-185773,-185206,-182706,-180515,-179348,-178474,-175203,-174731,-173012,-173012,-171115,-170095,-168308,-168128,-166905,-166742,-164733,-164448,-158590,-157720,-156014,-155429,-153638,-149375,-148870,-148098,-147945,-145512,-145183,-141591,-139964,-137213,-134488,-133486,-132424,-131215,-130615,-125187,-124332,-117324,-113085,-112523,-111751,-111383,-104409,-104344,-102517,-102161,-98185,-97846,-91902,-89723,-84742,-84067,-83948,-82603,-82579,-78160,-76854,-75430,-75344,-74962,-71408,-69102,-66641,-65642,-64757,-61211,-60329,-57886,-53220,-52898,-49270,-49124,-48080,-45815,-44789,-37626,-34882,-34859,-32485,-31102,-29729,-24983,-22453,-20259,-16334,-16193,-15026,-12533,-11486,-9861,-4017,-404,704,6117,7576,8139,8688,16526,17499,22574,25852,26549,29362,30492,33676,37645,40152,43767,44242,46314,47444,50651,52396,53898,59922,60919,63930,68755,69424,70153,71709,73909,75531,75770,77643,78793,81457,83544,85477,89943,91011,91041,91192,94363,94670,95048,96537,98525,98539,104346,107800,108042,109819,110121,115691,117048,118363,118924,120311,125092,127555,127995,128168,135729,138889,140152,140261,140971,145327,145731,145860,152322,155692,159510,161250,163594,164930,166753,167883,168915,172982,173783,174795,175457,179314,180491,180628,189221,190490,190611,193586,195760,199322,201329,202231,202971,205732,206448,209484,210079,213383,213627,214223,215757,218866,223260,224593,225505,228101,229883,232562,234221,235355,236464,236563,238608,240104,242362,242959,245209,246122,246173,249953,255505,258524,260918,261968,262033,262830,263342,263665,265410,265772,266591,268471,270067,274107,276862,277801,277848,278505,278931,279516,285322,286378,293299,294255,296317,296787,297292,300002,302027,302121,302296,304390,304403,306514,311250,311643,316657,317008,319056,320827,322849,324605,326098,326173,326315,326588,328330,329876,330948,331341,331948,332124,341297,341942,343708,344436,344659,350897,351495,351893,352596,353479,355046,356056,357088,357742,358398,360172,365218,372048,375602,376611,382420,386919,389469,391011,392771,396046,403823,404843,407192,409690,410139,411497,418925,419472,419584,420171,421967,425637,428244,428593,429601,430662,431024,432899,434667,438639,438690,438839,441713,443399,449585,454891,459572,461567,464223,464977,468031,468216,468980,469952,471601,473590,476517,477804,478040,479232,481442,482516,487561,489198,493596,494509,498310,500634,502180,503663,504932,507455,511419,515818,517896,518474,520182,520335,520403,520452,523949,524745,525015,526693,531560,536815,536885,536922,537002,537675,541832,543158,547884,548488,549711,559134,559481,559820,560772,560870,561935,563399,563985,568956,569744,570203,573437,574202,574696,578813,579430,588576,588747,590647,604861,606852,606861,607746,608154,609468,609523,611937,611965,612112,614230,619688,620348,621041,621873,622766,633850,636410,645785,647203,647468,648663,651250,653354,655650,655736,656313,656473,660352,665886,668634,668889,668947,670032,670182,670412,673826,686025,686683,691645,692054,692284,695765,697395,697829,702166,708541,709011,711141,712520,714573,716618,721072,721706,721848,721884,722339,722954,724012,724181,726931,729781,730450,732815,734038,734313,735874,736725,737913,738002,740812,743047,744545,745638,746517,747495,747721,754971,755927,760296,760368,768237,770512,771998,772642,773928,775652,776009,776528,778433,784050,788493,788662,790251,794398,797252,797470,798288,800465,801126,806618,807774,810900,812412,812864,815004,819410,819576,821429,822144,828766,831814,834893,834987,838359,839232,839741,845812,846318,851048,851400,852080,856264,859668,861457,862611,863385,867019,872146,872332,877196,879288,879573,883230,888081,889012,889628,889844,890313,891004,891633,897234,900619,901180,901991,904976,905449,905491,905566,906218,906325,911636,912008,912597,917627,919382,921003,924181,925430,925724,925947,929266,934039,935863,937145,938405,941714,945193,946019,948295,950933,951602,951856,952469,953824,954207,954485,954748,959150,960644,962815,963477,963549,963815,964638,965098,967348,967682,969084,971079,973452,974228,976702,976910,978359,981049,982811,982859,987419,993386,994771,995167,996051,998221]\n[-987944,-969636,-969382,-963918,-960334,-957471,-955419,-954534,-949617,-948164,-941370,-934887,-933385,-933024,-925395,-920598,-914952,-912930,-910713,-898551,-897943,-895093,-883721,-881114,-868961,-862108,-859224,-844995,-843122,-841350,-839681,-837319,-833916,-832929,-824567,-821404,-817679,-816414,-815142,-814794,-814428,-812717,-803053,-800629,-791874,-784923,-776546,-772543,-770170,-769595,-767768,-764581,-760610,-755916,-750060,-738122,-734792,-733242,-728895,-725665,-725507,-718134,-717075,-715534,-715202,-713373,-712097,-708739,-707414,-706871,-703365,-702017,-693735,-683042,-672054,-669261,-668919,-664791,-661728,-660926,-656147,-645420,-643702,-643193,-641435,-638420,-634551,-628772,-615960,-603372,-601747,-598111,-594931,-589739,-582816,-582756,-578800,-578594,-573174,-567081,-559766,-559620,-556681,-554084,-553002,-549693,-548262,-545226,-544969,-537261,-533737,-528123,-520081,-506744,-504736,-499021,-496520,-496470,-495274,-493267,-486175,-485863,-484654,-482183,-481473,-479689,-476360,-474984,-474568,-470604,-469841,-458033,-456643,-456026,-449361,-448407,-447725,-446572,-444202,-444122,-438385,-438174,-436049,-433511,-429215,-428895,-423500,-419598,-414944,-413779,-413601,-413134,-395813,-386542,-386081,-384022,-383217,-377664,-375237,-370842,-368652,-368619,-367534,-360286,-359315,-356864,-346574,-344238,-342362,-338322,-337904,-317031,-315369,-311471,-307529,-291585,-288367,-282217,-273392,-268202,-266384,-262947,-261304,-259484,-253107,-253097,-247496,-240183,-238502,-232673,-225567,-225273,-220556,-218540,-217405,-209508,-209191,-198492,-196102,-194657,-187900,-187654,-187409,-183298,-183195,-178895,-172948,-164463,-150912,-150447,-147157,-146039,-142859,-142513,-141007,-140514,-133632,-121672,-120655,-111524,-106570,-104308,-101032,-100077,-99330,-98302,-93625,-88734,-88072,-87928,-84357,-71659,-69515,-67676,-63282,-58552,-56529,-55822,-52857,-49183,-49096,-36632,-35822,-22044,-15543,-13193,-11327,-8347,-5921,367,2667,4951,5292,12503,13977,16698,20683,21104,29329,29383,32131,36676,38796,38939,39209,47231,48354,58584,63004,67608,68400,79071,80602,81795,86542,94114,101023,103400,104656,104880,111548,112896,115766,121077,122734,127019,127444,132932,138051,140440,154194,158884,165068,166138,166908,169497,170785,171990,179699,180030,188999,195927,197727,215034,218444,219489,222687,224521,235464,235727,241470,243528,246904,258231,259122,260441,263591,265308,267313,269450,272354,272547,274104,276239,278349,282844,283153,284414,285344,292275,301326,301817,303601,305996,308758,308841,318258,318758,326276,328210,328413,329591,330688,335804,336586,338827,350724,353017,355893,356488,358137,367458,369246,373776,375814,388619,389665,391494,398826,410285,414310,434616,436368,437657,441921,442891,443722,445197,448982,449981,452442,455491,458606,458789,459482,459977,460011,467293,480680,484432,486822,491840,495107,498402,498655,499730,501125,506371,507661,508352,508531,510705,517473,521451,521763,531020,535521,536548,538401,543120,545936,546904,551503,551845,552061,557919,565312,566269,568604,574239,574420,578570,579251,582167,587488,592161,594286,604994,619288,622829,629325,652728,657554,659113,659971,661630,664091,664280,667722,673155,674069,675252,680792,683874,685152,698652,701722,703282,708464,710121,710242,712200,718611,720934,732059,736885,739191,742494,750812,759987,772722,776392,782107,782131,783537,783996,785898,793147,799555,806418,807432,808677,831974,841540,844398,849513,849656,854080,855359,858674,865625,866262,870340,877863,886981,896266,898306,900880,903869,907452,914307,916336,916960,922084,923604,924431,926571,930085,935193,948240,948473,954648,957779,959463,960134,960965,975144,979240,997354,999899]\n[0,2,3,4,4,6,6,7,8,8,8,8,11,11,15,16,17,20,22,26,26,28,29,30,31,32,36,39,40,41,41,44,45,52,52,53,54,56,57,62,70,71,72,74,78,78,80,80,83,84,86,87,88,90,91,92,92,96,99,104,105,106,110,110,112,113,113,115,116,118,119,121,121,123,124,125,125,129,129,131,131,134,135,140,141,141,143,144,145,145,145,150,152,153,154,157,158,159,159,159,164,164,169,172,176,176,177,178,178,184,185,189,189,190,191,192,193,193,194,194,195,196,196,200,203,204,205,206,210,211,211,212,212,213,216,219,220,222,225,226,229,229,233,234,237,238,239,241,243,243,246,246,248,249,249,250,250,251,253,255,256,258,260,260,262,266,268,268,269,271,272,273,273,280,281,282,283,288,288,295,296,296,298,302,304,305,305,305,305,306,306,308,309,310,312,313,315,315,318,318,319,319,321,322,323,324,324,326,329,329,329,331,331,333,333,334,334,336,339,339,340,341,341,343,344,348,351,351,352,353,354,354,358,359,363,364,364,365,367,367,368,369,370,372,372,373,376,376,378,379,379,381,382,383,385,386,391,391,391,394,396,399,400,411,414,414,414,416,423,429,429,430,430,431,435,436,437,438,442,443,444,447,448,452,452,452,452,452,455,456,457,457,462,466,468,468,468,472,472,472,472,473,473,475,476,476,477,477,480,481,481,482,483,483,484,485,485,486,486,491,491,491,491,492,494,495,497,497,500,502,503,505,505,509,510,514,515,515,515,516,516,518,519,519,520,522,524,525,527,528,529,531,534,537,537,540,543,543,544,544,545,549,552,552,556,558,558,565,565,566,569,570,571,572,575,577,577,578,579,579,581,583,584,586,586,590,591,593,597,603,603,605,607,608,611,613,614,622,622,622,623,631,631,633,635,638,638,639,642,643,644,645,646,649,652,653,653,654,655,655,655,655,657,659,660,661,664,665,666,667,671,682,684,685,686,688,691,692,694,694,696,698,699,702,704,704,704,706,706,709,710,713,713,714,717,723,725,726,727,727,729,730,730,732,732,733,734,738,740,740,741,746,750,751,751,755,755,758,759,759,760,764,765,767,769,771,773,774,775,776,779,779,781,782,785,797,797,798,798,798,802,803,804,804,806,807,808,809,809,810,810,812,814,814,818,819,820,822,822,823,824,826,826,826,827,830,831,833,833,833,834,837,838,838,839,840,840,841,844,844,847,848,851,852,853,854,857,860,862,864,868,868,869,870,872,874,880,881,881,883,884,885,888,889,892,892,896,897,897,898,899,901,904,905,907,908,914,914,915,915,916,918,920,921,921,921,927,927,928,928,929,932,932,932,932,933,937,937,938,939,940,941,941,942,942,942,944,945,945,946,947,948,952,952,955,956,960,962,964,964,966,968,968,968,971,973,973,973,974,978,979,979,981,982,983,985,985,989,990,990,990,993,994,994,995,998,999,999,1000]\n[999,999,1002,1003,1003,1004,1007,1010,1016,1016,1016,1020,1020,1022,1022,1024,1024,1027,1035,1038,1038,1041,1043,1044,1054,1055,1060,1064,1066,1067,1069,1070,1070,1071,1074,1074,1075,1081,1081,1087,1090,1092,1092,1094,1095,1095,1096,1097,1097,1098,1099,1103,1103,1103,1104,1104,1104,1105,1105,1108,1109,1109,1112,1112,1113,1116,1117,1117,1117,1117,1119,1121,1122,1124,1124,1125,1129,1129,1130,1131,1133,1133,1133,1135,1139,1140,1142,1142,1143,1144,1145,1146,1146,1148,1149,1151,1151,1151,1151,1152,1153,1153,1158,1159,1161,1164,1167,1171,1172,1173,1174,1176,1178,1178,1179,1180,1181,1182,1182,1183,1183,1185,1185,1186,1188,1189,1191,1192,1195,1200,1201,1201,1203,1204,1206,1207,1208,1208,1209,1210,1212,1212,1215,1216,1217,1222,1224,1225,1226,1226,1229,1230,1232,1232,1239,1241,1241,1243,1243,1244,1249,1252,1255,1256,1257,1263,1266,1266,1266,1270,1272,1274,1274,1280,1281,1288,1288,1288,1291,1291,1292,1296,1299,1301,1304,1304,1305,1306,1307,1310,1311,1311,1311,1312,1313,1313,1315,1315,1315,1319,1320,1321,1321,1321,1324,1324,1326,1327,1328,1330,1335,1348,1350,1351,1353,1355,1357,1357,1361,1365,1367,1368,1372,1374,1377,1383,1385,1388,1390,1390,1393,1393,1397,1398,1398,1398,1401,1402,1404,1405,1406,1407,1410,1410,1412,1412,1413,1414,1416,1416,1416,1416,1417,1418,1419,1423,1423,1428,1430,1432,1432,1433,1435,1436,1437,1438,1441,1441,1444,1444,1445,1449,1449,1449,1453,1457,1464,1466,1467,1469,1472,1475,1475,1478,1480,1485,1488,1488,1488,1489,1491,1493,1499,1500,1500,1500,1504,1505,1507,1508,1509,1510,1512,1512,1516,1519,1522,1528,1530,1532,1532,1538,1540,1540,1543,1545,1546,1548,1551,1553,1554,1555,1555,1561,1562,1563,1564,1565,1565,1569,1570,1570,1571,1572,1572,1577,1580,1580,1589,1589,1596,1599,1600,1600,1600,1600,1601,1602,1603,1607,1609,1610,1617,1618,1623,1623,1624,1626,1628,1629,1629,1630,1634,1637,1637,1637,1642,1645,1646,1646,1647,1647,1652,1657,1660,1662,1663,1666,1666,1667,1669,1670,1673,1675,1675,1677,1678,1678,1684,1686,1691,1691,1692,1694,1694,1697,1700,1700,1703,1704,1706,1706,1714,1715,1720,1720,1720,1720,1721,1721,1723,1725,1726,1728,1730,1730,1732,1733,1736,1739,1742,1744,1744,1752,1758,1759,1760,1764,1765,1766,1767,1769,1769,1773,1773,1773,1774,1775,1775,1775,1780,1783,1785,1785,1790,1791,1792,1793,1793,1795,1800,1803,1805,1807,1808,1811,1811,1811,1812,1812,1815,1816,1818,1819,1820,1821,1822,1823,1827,1828,1829,1830,1832,1835,1835,1835,1837,1839,1843,1843,1846,1849,1849,1849,1849,1851,1853,1853,1853,1854,1855,1861,1863,1865,1868,1870,1873,1878,1879,1881,1881,1881,1883,1883,1884,1885,1887,1889,1890,1891,1891,1894,1895,1896,1898,1899,1899,1901,1902,1904,1906,1907,1912,1912,1914,1914,1915,1917,1920,1921,1924,1926,1928,1930,1930,1931,1932,1933,1934,1934,1935,1936,1942,1943,1944,1947,1947,1948,1950,1951,1952,1953,1954,1956,1956,1957,1963,1964,1965,1966,1968,1968,1970,1971,1973,1979,1979,1981,1982,1986,1986,1986,1989,1992,1992,1998,1998,1999,1999,1999,2000]\n[1,1,2,4,7,10,10,11,17,24,26,26,27,28,32,33,33,35,35,35,37,37,37,38,40,41,45,48,50,50,53,53,54,55,55,55,56,57,63,66,68,71,76,79,81,81,82,83,85,88,89,91,95,96,100,102,103,104,104,105,107,107,108,109,109,112,116,118,118,118,119,119,120,121,123,124,124,127,128,128,128,130,132,134,134,140,141,141,143,143,144,147,148,150,150,152,153,155,156,157,164,166,166,167,167,168,176,178,184,185,190,191,191,192,193,194,197,199,201,201,204,207,207,211,211,216,225,225,228,229,233,234,235,237,237,237,238,239,239,244,247,248,248,251,251,254,258,259,259,261,263,266,268,269,269,269,269,271,281,282,285,285,286,287,292,293,295,295,295,296,300,300,302,305,305,305,309,310,310,310,311,318,319,319,320,320,321,321,322,328,329,332,333,334,335,336,336,339,339,339,341,341,345,346,346,347,348,348,349,349,349,350,351,351,355,356,361,363,363,364,366,366,367,368,368,371,371,373,377,380,381,381,382,384,384,387,387,389,394,395,399,400,402,406,406,407,407,410,415,418,419,424,427,433,434,436,437,442,444,445,451,455,455,456,457,459,461,462,463,464,464,465,465,465,467,468,469,473,476,476,476,480,482,483,486,488,489,490,493,495,495,496,496,497,499,499,500,502,504,505,509,509,511,511,516,516,517,521,523,525,526,528,528,530,534,534,535,538,538,541,541,544,544,544,544,546,547,550,550,551,553,555,556,556,557,558,558,559,561,563,567,569,569,570,571,571,572,574,574,575,575,578,582,583,583,584,584,586,590,592,592,594,595,596,598,598,598,601,603,603,604,612,617,618,620,620,624,626,627,628,631,635,637,637,638,641,645,650,651,652,653,654,657,659,659,661,661,661,661,662,663,663,664,664,665,666,669,670,670,671,675,676,683,684,688,689,689,689,690,691,692,694,695,695,696,697,697,700,705,705,707,708,708,709,709,710,710,712,714,716,716,716,718,721,722,722,723,724,725,728,728,729,730,735,735,737,737,741,741,744,747,748,749,750,751,751,754,754,755,757,757,759,759,761,763,763,763,764,766,767,771,771,777,778,778,778,781,782,782,786,786,786,787,787,787,790,790,790,791,792,792,793,801,803,804,805,805,805,805,807,808,808,808,810,815,817,819,819,822,829,829,830,832,832,834,834,836,836,836,837,842,843,844,846,846,847,847,847,850,851,852,853,853,854,854,855,855,858,860,863,864,866,866,867,871,875,881,883,883,886,888,888,890,891,892,894,897,903,913,914,915,918,918,919,920,920,922,923,925,927,927,927,927,928,937,943,943,943,946,948,949,950,953,954,958,966,968,968,971,979,980,981,983,984,985,985,987,987,990,991,992,992,992,997,999]\n[999,1000,1001,1001,1002,1005,1006,1008,1009,1011,1014,1014,1018,1019,1021,1026,1027,1031,1031,1032,1033,1034,1037,1038,1039,1041,1042,1043,1043,1043,1046,1049,1054,1055,1055,1058,1060,1064,1065,1065,1067,1067,1068,1074,1076,1076,1082,1082,1083,1084,1085,1086,1087,1094,1094,1095,1098,1101,1104,1104,1105,1105,1106,1106,1106,1107,1108,1112,1112,1113,1117,1118,1118,1119,1124,1124,1126,1126,1126,1130,1130,1132,1132,1133,1133,1134,1134,1136,1137,1139,1139,1139,1139,1139,1140,1141,1141,1141,1143,1144,1145,1147,1147,1150,1152,1153,1155,1157,1158,1159,1160,1161,1162,1163,1163,1165,1167,1167,1167,1167,1168,1168,1168,1168,1169,1171,1171,1172,1172,1173,1176,1177,1178,1178,1180,1181,1183,1184,1184,1185,1186,1186,1187,1188,1188,1189,1190,1191,1195,1196,1199,1200,1200,1201,1202,1206,1207,1208,1209,1211,1211,1212,1217,1221,1221,1222,1222,1224,1225,1226,1230,1230,1231,1232,1237,1237,1240,1243,1243,1243,1243,1243,1245,1245,1248,1248,1248,1249,1249,1253,1254,1255,1257,1258,1260,1265,1266,1268,1269,1270,1271,1271,1273,1274,1275,1277,1278,1279,1280,1281,1281,1283,1283,1284,1284,1286,1286,1287,1288,1288,1289,1290,1291,1292,1292,1295,1297,1298,1298,1299,1301,1302,1304,1306,1306,1307,1308,1310,1311,1312,1316,1316,1317,1318,1319,1320,1320,1321,1322,1324,1324,1324,1325,1327,1329,1330,1331,1331,1331,1332,1333,1333,1334,1336,1342,1345,1346,1347,1347,1349,1349,1350,1351,1352,1355,1355,1356,1357,1357,1362,1363,1364,1364,1364,1365,1370,1370,1372,1372,1374,1374,1375,1375,1376,1376,1378,1379,1379,1381,1382,1383,1384,1385,1386,1389,1391,1391,1391,1393,1394,1395,1397,1397,1401,1403,1405,1405,1406,1407,1407,1408,1409,1410,1413,1413,1416,1418,1418,1421,1422,1422,1424,1424,1425,1426,1428,1428,1429,1430,1434,1436,1439,1439,1439,1439,1440,1440,1441,1441,1442,1442,1442,1444,1445,1447,1447,1451,1451,1452,1456,1460,1462,1463,1468,1469,1469,1470,1470,1471,1472,1472,1474,1476,1478,1478,1482,1484,1486,1486,1488,1489,1489,1493,1494,1495,1495,1497,1498,1502,1503,1505,1506,1507,1507,1508,1511,1512,1513,1514,1515,1516,1518,1520,1520,1520,1522,1523,1525,1525,1527,1527,1528,1531,1531,1532,1533,1534,1535,1537,1538,1540,1540,1541,1543,1543,1544,1545,1546,1548,1549,1551,1551,1552,1552,1552,1553,1556,1556,1557,1557,1557,1559,1559,1560,1561,1561,1562,1564,1564,1564,1564,1566,1566,1567,1571,1571,1572,1573,1573,1574,1574,1577,1577,1583,1584,1584,1588,1589,1590,1593,1593,1595,1596,1596,1596,1597,1598,1601,1604,1604,1606,1606,1607,1607,1610,1610,1611,1611,1612,1612,1614,1615,1616,1617,1621,1622,1622,1622,1623,1626,1627,1631,1632,1636,1637,1637,1638,1640,1642,1642,1644,1645,1647,1648,1650,1651,1652,1653,1655,1655,1656,1656,1656,1656,1658,1658,1658,1660,1660,1663,1664,1665,1666,1667,1667,1667,1669,1669,1670,1676,1678,1680,1681,1681,1682,1684,1684,1685,1686,1686,1687,1689,1689,1689,1690,1693,1694,1698,1700,1702,1703,1706,1708,1708,1708,1710,1712,1712,1712,1713,1715,1715,1717,1719,1719,1720,1720,1721,1722,1722,1724,1731,1732,1734,1734,1737,1737,1741,1743,1743,1749,1749,1751,1753,1754,1754,1756,1757,1757,1758,1759,1761,1761,1762,1764,1766,1766,1767,1769,1769,1771,1772,1772,1775,1775,1775,1777,1779,1779,1781,1782,1782,1783,1786,1788,1788,1788,1790,1793,1793,1793,1793,1794,1795,1795,1796,1796,1796,1797,1799,1800,1803,1810,1811,1814,1814,1814,1816,1817,1819,1820,1820,1822,1824,1826,1826,1826,1827,1828,1828,1831,1832,1834,1835,1836,1837,1838,1838,1841,1843,1849,1851,1851,1852,1852,1853,1853,1854,1854,1856,1858,1859,1863,1863,1863,1869,1871,1872,1872,1873,1874,1879,1880,1881,1881,1882,1883,1883,1883,1885,1885,1885,1886,1887,1887,1889,1894,1898,1899,1901,1902,1903,1904,1907,1908,1910,1911,1911,1911,1913,1914,1914,1915,1916,1917,1918,1921,1922,1923,1923,1924,1926,1926,1933,1933,1934,1934,1934,1936,1938,1938,1939,1939,1941,1941,1942,1942,1947,1947,1947,1947,1949,1949,1952,1954,1955,1957,1958,1959,1960,1960,1963,1964,1964,1964,1966,1968,1971,1973,1975,1977,1978,1978,1979,1979,1980,1981,1981,1982,1984,1985,1985,1987,1987,1987,1987,1987,1988,1989,1990,1991,1994,1994,1995,1996,1997,1997,1998]\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this help](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e)s and makes thinks clear\\nand do clap \\uD83D\\uDC4F to appreciate the article"
                    },
                    {
                        "username": "pwho",
                        "content": "If you\\'re going to share an article here, don\\'t hide it behind a paywall. =\\\\"
                    },
                    {
                        "username": "user5979vk",
                        "content": "Thanks (https://archive.is/E2agn)"
                    },
                    {
                        "username": "4alisha",
                        "content": "very helpful\\uD83D\\uDC4F"
                    },
                    {
                        "username": "thecodingkid",
                        "content": "Any help would be appreciated if you could explain why the solution in the O(log(min(m,n))) case requires a swap if the second array is smaller.\\n\\nIf you could specify any edge case that is failing , that would be of great help."
                    },
                    {
                        "username": "bparanj",
                        "content": "Swapping nums1 and nums2 if nums1 is larger than nums2 is a trick to simplify the problem by reducing it to a condition where we always binary search on the smaller array. This doesn\\'t change the result because the median of two arrays doesn\\'t depend on which array is longer, but it makes the code cleaner and easier to understand, and it also improves performance by minimizing the search space.\\n\\nMoreover, this technique ensures that we do not run into an index out of bounds error during our binary search process. \\n\\nLet\\'s consider an edge case where the swapping would be important:\\n\\nnums1 = [6, 7, 8, 9, 10]\\nnums2 = [1, 2, 3]\\n\\nIf we did not swap, and started the binary search on nums1, we would end up exploring unnecessary parts of nums1 that wouldn\\'t impact the final result, since we know that the median must be within the range covered by nums2 due to its smaller size and range of values. \\n\\nIf we swap and binary search on nums2, we can find the median more efficiently because we focus on the smaller range of values. We then only need to compare with a few specific elements of nums1.\\n\\nTo summarize, the swap is used to ensure efficiency and simplicity by always performing binary search on the smaller array."
                    }
                ]
            },
            {
                "id": 1568801,
                "content": [
                    {
                        "username": "yon",
                        "content": "Input:\\t[1,1], [1,2]\\nExpected:\\t1.00000\\n\\nMy solution way is merge [1,1] and [1,2] to [1,2], so the answer would be (1+2)/2 = 1.5\\nWhat did I made wrong?"
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "you first merge it (preserving duplicates).\\n[1, 1, 1, 2]\\n\\nWhats the middle element here?\\noh wait. there are two elements at the middle. 1 and 1.\\nso you average em. \\n(1 + 1) / 2 = 1"
                    },
                    {
                        "username": "RISHIKA_GANDHI",
                        "content": "change your (1+2)/2 to this (1+2)/2.0 you will get you result into float/double type"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "the merged array will we [1,1,1,2] ,\\nno of elements are even so median will we (1+1)/2=1.\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the hell nooo. median is 1 here"
                    },
                    {
                        "username": "hankIgoe",
                        "content": "the merged string is [1,1,1,2], so the median is (1+1)/2 = 1.0\\n"
                    },
                    {
                        "username": "vyshnusanthosh",
                        "content": "If you are using java, when two integers are divided the answer will also be an integer in order to get floating point you need to type cast the integers to double or float before division."
                    },
                    {
                        "username": "megazortti",
                        "content": "i\\'m facing the same problem..\\n"
                    },
                    {
                        "username": "khushal1201",
                        "content": "[@zwicky](/zwicky) the merged array should be [1,1,1,2]. Hence the median would be (1+1)/2 = 1."
                    },
                    {
                        "username": "zwicky",
                        "content": "you shouldn\\'t remove duplicates"
                    },
                    {
                        "username": "hing_liu",
                        "content": "Let try to interate the algorithm first:\\n\\nIt is basically a k-th smallest element problem between two sorted arrays, let assume we have the following two arrays:\\n\\n5,7,8,11\\n4,9,12,14\\n\\nk = 4 (expected ans = 8 because when it is sorted: 4,5,7,**8**,9,11,12,14)\\n\\nStep 1: Cut the two arrays into two pieces such that the left side will have total items of 4 (i.e. the **K=4**)\\n5,7 | 8, 11\\n4,9 | 12, 14\\n\\nStep 2: We remove [5,7] because its end index at the left side is smaller (7. v.s 9) and we update K = 2 (since we removed 2 item=> K - 2 = 4 - 2 = 2), it will becomes:\\n8,11 <-- removed [5,7]\\n4,9,12,14\\n\\n(basically the rest of the steps below is to repeat 1 and 2 until K = 1)\\n\\nStep 3: Repeat Step 1, Cut into two half base on **K = 2**\\n8 | 11\\n4 | 9 12 14\\n\\nStep 4: Repeat Step 2, that is remove 4 and update **K = 1** (since we removed 1 item=>K-1 = 2-1 1)\\n\\nStep 5: Repeat Step 1, Cut into two half base on K = 1, since K = 1 is not able to split (we have two arrays, don\\'t know how to split), we conclude the solution as the minimum of the first item of the two array, that is min(8,9) = 8\\n8,11\\n9,12,14\\n\\nWe are all done, how about K = 3 initially? Basically the point of \\'cut\\' is K/2 - 1, therefore when K = 3, the cutting point is index=0, let us go though this again quickly for this:\\n\\nK=3\\n5|7,8,11\\n4|9,12,14\\n\\nK=2\\n5|7,8,11\\n9|12,14\\n\\nK=1\\n7|8,11\\n9|12,14 \\nAns=min(7,9) = 7\\n\\nThere is some edge case not tell here, this is just a general idea. We want to have the first K-th item, so, the first target is to collect the first K item from the two array, so we fairly cut them at K/2 - 1 and remove the smaller list until K = 1.\\n\\nThis might be still hard to understand, consider we are not greedy, we do it one by one (we don\\'t cut base on K, but always cut by two):\\n\\nK=4\\n5 | 7 8 11\\n4 | 9 12 14\\n\\nAt this point, we remove the smaller one and have:\\nK=3\\n5 | 7 8 11\\n9 | 12 14\\n\\nKeep doing this until K = 1\\nK=2\\n7 | 8 11\\n9 | 12 14\\n\\nK = 1\\n8 | 11\\n9 | 12 14\\n(at this point, all done)\\n\\nWe are now reaching the answer = 8 by doing this in one-by-one manner, the cutting point at this \\'slow-version\\' is always [0], and the faster version is doing the cutting point at [k/2 - 1], that still work because they are sorted, it is safe to jump further and remove the whole preceding items rather than doing this one-by-one manner.\\n\\nAgain, this might still be hard to convince yourself why the \\'faster-version\\' has no issue, just hope this can help you understand more.\\n\\nGoing back to tell why it is a k-th minimum issue, consider when we have ths int kth(arr1, arr2, k) function, we can put k to be the middle of sizeof(arr1) and sizeof(arr2), if it is even number of size we just get the adjacent (run kth function two times) so we can get the middle two and divide it by 2, so the answer ..."
                    },
                    {
                        "username": "rds8rds",
                        "content": "thanks properly understand the concept!"
                    },
                    {
                        "username": "parismania",
                        "content": "That\\'s quite a good explanation. Thank you!"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I tried to avoid this question for as long as possible"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally solved this by merging the two arrays. I always intended to do the proper solution - one day. Today is the day."
                    },
                    {
                        "username": "raviTejaY",
                        "content": "\\tvar findMedianSortedArrays = function(nums1, nums2) {\\n  \\tlet mid;\\n\\t  let res = [...nums1, ...nums2].sort((a,b) => a-b);\\n\\t mid = (res.length-1)/2;\\n\\t  if(res.length % 2 === 1){\\n\\t\\treturn res[mid].toFixed(5);\\n\\t  } else {\\n\\t\\tlet median = (res[Math.floor(mid)] + res[Math.ceil(mid)]) / 2;\\n\\t\\treturn median.toFixed(5)\\n\\t  }\\n\\t};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, you use .sort(), which does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "hongbin2",
                        "content": "My naive solution is just merge two array and find the median. Obvious we can do better. But I just have no idea about it."
                    },
                    {
                        "username": "aneesfathimasaifudeen",
                        "content": "Input\\n[1,2]\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000\\n\\nThis test case always fails for me in leetcode, whereas it works for me in my machine\\'s python compiler with the same code.\\n\\nCan anyone tell, what would be the problem here?"
                    },
                    {
                        "username": "evenn",
                        "content": "choose Python3 rather than Python to execute code"
                    },
                    {
                        "username": "kapilkapuriya",
                        "content": "[@jeetu16](/jeetu16)  use type cast when you perform   ** ans = a/2 **  so do like this  **  ans = double(a)/2 ** "
                    },
                    {
                        "username": "doubleshab",
                        "content": "[@jeetu16](/jeetu16) I had a similar problem using Python3. For me, the issue was that the math I was using to generate my index values was producing float values. By forcing them to integer types using the int() builtin, I was able to get around it."
                    },
                    {
                        "username": "python_is_cheat_code",
                        "content": "Facing the same issue. Have no idea what to do."
                    },
                    {
                        "username": "AtrijPaul",
                        "content": "If you are coding in Java then division of two integers will be integer only , after performing the division it get stored as double. So instead of dividing by 2 , divide by 2.0 , it will work."
                    },
                    {
                        "username": "jeetu16",
                        "content": "have you found the solution till now?\\ni faced the same problem"
                    },
                    {
                        "username": "scott40",
                        "content": "The question states: \"There are two sorted arrays nums1 and nums2 of size m and n respectively.\" This does not tell me whether the sort order is largest to smallest, or smallest to largest. It would even be possible for nums1 to be sorted largest to smallest while nums2 is sorted from smallest to largest. So I thought we would need to be able to handle such cases, making no assumptions as to the direction of the sorts. As a test case of opposite sort directions in the inputs I tried:\\n[10,8,3]\\n[5,9,17]\\n\\nBoth input lists sorted as required, but in opposite directions. The median here should be 8.5, but when I ran the test case it gave me an expected answer of 6.5. So I think leetcode is making an assumption about the sort directions of the inputs that should not be made, and it is not designed to properly handle this case. What are we allowed to assume about the input sort direction?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement does not explicitly mention the sort order. However, it is conventionally assumed that, unless stated otherwise, a \"sorted\" array or list is in non-decreasing order, meaning from smallest to largest. This assumption is consistent with most problems and discussions involving sorted data in computer science and mathematics.\\n\\nTherefore, in the context of this problem, you can assume that both input arrays are sorted in non-decreasing order. This assumption informs the approach to solving the problem. If the arrays were sorted in non-increasing order or if one array was sorted in increasing order while the other in decreasing order, a different approach might be necessary.\\n\\nHowever, if the problem were to handle arrays sorted in either direction, a pre-processing step could be added to sort the arrays in the desired order before proceeding with the rest of the algorithm. This would increase the time complexity, though, because sorting is generally an O(n log n) operation."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit before validating your solution against a few edge cases, e.g.\n```\n[-932210,-932056,-922328,-917451,-913929,-907514,-883337,-802571,-739964,-709048,-692863,-690427,-679691,-666576,-643630,-638229,-585992,-574362,-571309,-541584,-538138,-497470,-480909,-459608,-444410,-426022,-403497,-393857,-363379,-359219,-347291,-330378,-314805,-303621,-291243,-251965,-244657,-243891,-236303,-234099,-217309,-210326,-199139,-197450,-177317,-172519,-170556,-137069,-128436,-113727,-95170,-79317,-52534,-4681,40199,89215,107649,109238,124507,157189,162498,180216,200111,228032,251189,262426,319119,323615,344264,345305,373566,399588,411387,427092,427955,456725,461974,468467,474372,476390,562956,577916,580839,591862,616385,638656,650816,653650,672517,753495,769837,779299,801738,809541,836250,872512,917419,949439,959386,979587]\n[]\n[]\n[-999311,-995487,-993598,-993127,-989482,-973229,-926998,-898485,-851725,-850712,-836433,-795269,-784476,-764197,-763427,-756479,-755190,-753600,-717158,-677976,-668634,-640052,-597569,-589282,-520481,-515063,-499955,-479622,-477302,-473002,-403966,-400582,-388037,-363473,-344547,-324788,-320701,-314920,-296000,-290463,-276432,-273513,-244152,-215671,-192226,-184426,-128230,-122297,-75423,-58001,-8481,2993,27765,54297,64282,81674,93781,96008,152144,154165,166583,169777,181118,191164,216155,263473,271293,308484,360932,380484,405656,413389,432913,436707,461128,530274,555172,576238,595665,608718,624952,644037,684003,697121,727400,730624,751135,768207,784915,792103,809755,831583,832823,844259,886508,913559,941025,950966,975298]\n[-999567,-997502,-997320,-997131,-995209,-993605,-991650,-991613,-991417,-990564,-989776,-987550,-985870,-985386,-982368,-981518,-979842,-979718,-978628,-976620,-974345,-973518,-972291,-967402,-967265,-966730,-965785,-962771,-961174,-960505,-959719,-955802,-955134,-953099,-948117,-944790,-941695,-941693,-939131,-938510,-937577,-937038,-935074,-933558,-933056,-930614,-929544,-924799,-922049,-920262,-919703,-917939,-916145,-915636,-914995,-913579,-896888,-894679,-894651,-891943,-891618,-891260,-888315,-886543,-884101,-883513,-872873,-872826,-872120,-871050,-870232,-869805,-868351,-867330,-866646,-866243,-863978,-863009,-859149,-858906,-858758,-854975,-852689,-852164,-851427,-850218,-847970,-845912,-845486,-844687,-844411,-843956,-843353,-839477,-837499,-836703,-833607,-831373,-830358,-827611,-827276,-827145,-827057,-825816,-823331,-822868,-822693,-821423,-820561,-819808,-815340,-814889,-814639,-814554,-813263,-811601,-810742,-810567,-808592,-807943,-805362,-805085,-803725,-798929,-792149,-789206,-785856,-783704,-783011,-781163,-775292,-772930,-769271,-764889,-764165,-763180,-758264,-756607,-755921,-752956,-752637,-751864,-751318,-750878,-750246,-749003,-746825,-744464,-744367,-743637,-741289,-738903,-736545,-732164,-731981,-731878,-730164,-727779,-725497,-725433,-720206,-715719,-714089,-707566,-705091,-705008,-705000,-699566,-696000,-694414,-689552,-688092,-683083,-681058,-680084,-676059,-675854,-675730,-672990,-671402,-669298,-669292,-667660,-667250,-662853,-660122,-658209,-657793,-657002,-656472,-653603,-647017,-643156,-642765,-642520,-638572,-637837,-636344,-635145,-629818,-628344,-624890,-622582,-621602,-619124,-617701,-616391,-613542,-609069,-605811,-604133,-603960,-602075,-601936,-601600,-599041,-598358,-597574,-597092,-596147,-594696,-592955,-592300,-591877,-591829,-591201,-589912,-584118,-583933,-574753,-567021,-566697,-565332,-564305,-562776,-561152,-557378,-553247,-551405,-541292,-536736,-533881,-533615,-532784,-531029,-530553,-527184,-526662,-525823,-525625,-525093,-520969,-520545,-515036,-510919,-507746,-504592,-504032,-503595,-501437,-499214,-496301,-494795,-490284,-486646,-485513,-484383,-480751,-476832,-476559,-474296,-469572,-469152,-468659,-466347,-462419,-460567,-458882,-457050,-454911,-453624,-452324,-450481,-449509,-440836,-439940,-436508,-434347,-431863,-426890,-422954,-422337,-419891,-419812,-419313,-415360,-413516,-410195,-409526,-409454,-408360,-408054,-406101,-404269,-401590,-400963,-394836,-385314,-375836,-374995,-374048,-368693,-368131,-367859,-361397,-360458,-356055,-354270,-354227,-346946,-346223,-346099,-345855,-344808,-344247,-343806,-342087,-339682,-338497,-335912,-334945,-330597,-328200,-327450,-323098,-320641,-319061,-316787,-314312,-314133,-313427,-313020,-311735,-311556,-308652,-307950,-307902,-305049,-304780,-304200,-301782,-301539,-296853,-296489,-293520,-285339,-284857,-284262,-283709,-282070,-281202,-281164,-277190,-276021,-274641,-273757,-273728,-270394,-269087,-265427,-265272,-264115,-263447,-262116,-259606,-257673,-257419,-257235,-257127,-257053,-256900,-256146,-255547,-253986,-249576,-249079,-245481,-239011,-235597,-230997,-228005,-227497,-227250,-226380,-225431,-216611,-210008,-208956,-208838,-201921,-199428,-196686,-191696,-190547,-189199,-188847,-188753,-186418,-185773,-185206,-182706,-180515,-179348,-178474,-175203,-174731,-173012,-173012,-171115,-170095,-168308,-168128,-166905,-166742,-164733,-164448,-158590,-157720,-156014,-155429,-153638,-149375,-148870,-148098,-147945,-145512,-145183,-141591,-139964,-137213,-134488,-133486,-132424,-131215,-130615,-125187,-124332,-117324,-113085,-112523,-111751,-111383,-104409,-104344,-102517,-102161,-98185,-97846,-91902,-89723,-84742,-84067,-83948,-82603,-82579,-78160,-76854,-75430,-75344,-74962,-71408,-69102,-66641,-65642,-64757,-61211,-60329,-57886,-53220,-52898,-49270,-49124,-48080,-45815,-44789,-37626,-34882,-34859,-32485,-31102,-29729,-24983,-22453,-20259,-16334,-16193,-15026,-12533,-11486,-9861,-4017,-404,704,6117,7576,8139,8688,16526,17499,22574,25852,26549,29362,30492,33676,37645,40152,43767,44242,46314,47444,50651,52396,53898,59922,60919,63930,68755,69424,70153,71709,73909,75531,75770,77643,78793,81457,83544,85477,89943,91011,91041,91192,94363,94670,95048,96537,98525,98539,104346,107800,108042,109819,110121,115691,117048,118363,118924,120311,125092,127555,127995,128168,135729,138889,140152,140261,140971,145327,145731,145860,152322,155692,159510,161250,163594,164930,166753,167883,168915,172982,173783,174795,175457,179314,180491,180628,189221,190490,190611,193586,195760,199322,201329,202231,202971,205732,206448,209484,210079,213383,213627,214223,215757,218866,223260,224593,225505,228101,229883,232562,234221,235355,236464,236563,238608,240104,242362,242959,245209,246122,246173,249953,255505,258524,260918,261968,262033,262830,263342,263665,265410,265772,266591,268471,270067,274107,276862,277801,277848,278505,278931,279516,285322,286378,293299,294255,296317,296787,297292,300002,302027,302121,302296,304390,304403,306514,311250,311643,316657,317008,319056,320827,322849,324605,326098,326173,326315,326588,328330,329876,330948,331341,331948,332124,341297,341942,343708,344436,344659,350897,351495,351893,352596,353479,355046,356056,357088,357742,358398,360172,365218,372048,375602,376611,382420,386919,389469,391011,392771,396046,403823,404843,407192,409690,410139,411497,418925,419472,419584,420171,421967,425637,428244,428593,429601,430662,431024,432899,434667,438639,438690,438839,441713,443399,449585,454891,459572,461567,464223,464977,468031,468216,468980,469952,471601,473590,476517,477804,478040,479232,481442,482516,487561,489198,493596,494509,498310,500634,502180,503663,504932,507455,511419,515818,517896,518474,520182,520335,520403,520452,523949,524745,525015,526693,531560,536815,536885,536922,537002,537675,541832,543158,547884,548488,549711,559134,559481,559820,560772,560870,561935,563399,563985,568956,569744,570203,573437,574202,574696,578813,579430,588576,588747,590647,604861,606852,606861,607746,608154,609468,609523,611937,611965,612112,614230,619688,620348,621041,621873,622766,633850,636410,645785,647203,647468,648663,651250,653354,655650,655736,656313,656473,660352,665886,668634,668889,668947,670032,670182,670412,673826,686025,686683,691645,692054,692284,695765,697395,697829,702166,708541,709011,711141,712520,714573,716618,721072,721706,721848,721884,722339,722954,724012,724181,726931,729781,730450,732815,734038,734313,735874,736725,737913,738002,740812,743047,744545,745638,746517,747495,747721,754971,755927,760296,760368,768237,770512,771998,772642,773928,775652,776009,776528,778433,784050,788493,788662,790251,794398,797252,797470,798288,800465,801126,806618,807774,810900,812412,812864,815004,819410,819576,821429,822144,828766,831814,834893,834987,838359,839232,839741,845812,846318,851048,851400,852080,856264,859668,861457,862611,863385,867019,872146,872332,877196,879288,879573,883230,888081,889012,889628,889844,890313,891004,891633,897234,900619,901180,901991,904976,905449,905491,905566,906218,906325,911636,912008,912597,917627,919382,921003,924181,925430,925724,925947,929266,934039,935863,937145,938405,941714,945193,946019,948295,950933,951602,951856,952469,953824,954207,954485,954748,959150,960644,962815,963477,963549,963815,964638,965098,967348,967682,969084,971079,973452,974228,976702,976910,978359,981049,982811,982859,987419,993386,994771,995167,996051,998221]\n[-987944,-969636,-969382,-963918,-960334,-957471,-955419,-954534,-949617,-948164,-941370,-934887,-933385,-933024,-925395,-920598,-914952,-912930,-910713,-898551,-897943,-895093,-883721,-881114,-868961,-862108,-859224,-844995,-843122,-841350,-839681,-837319,-833916,-832929,-824567,-821404,-817679,-816414,-815142,-814794,-814428,-812717,-803053,-800629,-791874,-784923,-776546,-772543,-770170,-769595,-767768,-764581,-760610,-755916,-750060,-738122,-734792,-733242,-728895,-725665,-725507,-718134,-717075,-715534,-715202,-713373,-712097,-708739,-707414,-706871,-703365,-702017,-693735,-683042,-672054,-669261,-668919,-664791,-661728,-660926,-656147,-645420,-643702,-643193,-641435,-638420,-634551,-628772,-615960,-603372,-601747,-598111,-594931,-589739,-582816,-582756,-578800,-578594,-573174,-567081,-559766,-559620,-556681,-554084,-553002,-549693,-548262,-545226,-544969,-537261,-533737,-528123,-520081,-506744,-504736,-499021,-496520,-496470,-495274,-493267,-486175,-485863,-484654,-482183,-481473,-479689,-476360,-474984,-474568,-470604,-469841,-458033,-456643,-456026,-449361,-448407,-447725,-446572,-444202,-444122,-438385,-438174,-436049,-433511,-429215,-428895,-423500,-419598,-414944,-413779,-413601,-413134,-395813,-386542,-386081,-384022,-383217,-377664,-375237,-370842,-368652,-368619,-367534,-360286,-359315,-356864,-346574,-344238,-342362,-338322,-337904,-317031,-315369,-311471,-307529,-291585,-288367,-282217,-273392,-268202,-266384,-262947,-261304,-259484,-253107,-253097,-247496,-240183,-238502,-232673,-225567,-225273,-220556,-218540,-217405,-209508,-209191,-198492,-196102,-194657,-187900,-187654,-187409,-183298,-183195,-178895,-172948,-164463,-150912,-150447,-147157,-146039,-142859,-142513,-141007,-140514,-133632,-121672,-120655,-111524,-106570,-104308,-101032,-100077,-99330,-98302,-93625,-88734,-88072,-87928,-84357,-71659,-69515,-67676,-63282,-58552,-56529,-55822,-52857,-49183,-49096,-36632,-35822,-22044,-15543,-13193,-11327,-8347,-5921,367,2667,4951,5292,12503,13977,16698,20683,21104,29329,29383,32131,36676,38796,38939,39209,47231,48354,58584,63004,67608,68400,79071,80602,81795,86542,94114,101023,103400,104656,104880,111548,112896,115766,121077,122734,127019,127444,132932,138051,140440,154194,158884,165068,166138,166908,169497,170785,171990,179699,180030,188999,195927,197727,215034,218444,219489,222687,224521,235464,235727,241470,243528,246904,258231,259122,260441,263591,265308,267313,269450,272354,272547,274104,276239,278349,282844,283153,284414,285344,292275,301326,301817,303601,305996,308758,308841,318258,318758,326276,328210,328413,329591,330688,335804,336586,338827,350724,353017,355893,356488,358137,367458,369246,373776,375814,388619,389665,391494,398826,410285,414310,434616,436368,437657,441921,442891,443722,445197,448982,449981,452442,455491,458606,458789,459482,459977,460011,467293,480680,484432,486822,491840,495107,498402,498655,499730,501125,506371,507661,508352,508531,510705,517473,521451,521763,531020,535521,536548,538401,543120,545936,546904,551503,551845,552061,557919,565312,566269,568604,574239,574420,578570,579251,582167,587488,592161,594286,604994,619288,622829,629325,652728,657554,659113,659971,661630,664091,664280,667722,673155,674069,675252,680792,683874,685152,698652,701722,703282,708464,710121,710242,712200,718611,720934,732059,736885,739191,742494,750812,759987,772722,776392,782107,782131,783537,783996,785898,793147,799555,806418,807432,808677,831974,841540,844398,849513,849656,854080,855359,858674,865625,866262,870340,877863,886981,896266,898306,900880,903869,907452,914307,916336,916960,922084,923604,924431,926571,930085,935193,948240,948473,954648,957779,959463,960134,960965,975144,979240,997354,999899]\n[0,2,3,4,4,6,6,7,8,8,8,8,11,11,15,16,17,20,22,26,26,28,29,30,31,32,36,39,40,41,41,44,45,52,52,53,54,56,57,62,70,71,72,74,78,78,80,80,83,84,86,87,88,90,91,92,92,96,99,104,105,106,110,110,112,113,113,115,116,118,119,121,121,123,124,125,125,129,129,131,131,134,135,140,141,141,143,144,145,145,145,150,152,153,154,157,158,159,159,159,164,164,169,172,176,176,177,178,178,184,185,189,189,190,191,192,193,193,194,194,195,196,196,200,203,204,205,206,210,211,211,212,212,213,216,219,220,222,225,226,229,229,233,234,237,238,239,241,243,243,246,246,248,249,249,250,250,251,253,255,256,258,260,260,262,266,268,268,269,271,272,273,273,280,281,282,283,288,288,295,296,296,298,302,304,305,305,305,305,306,306,308,309,310,312,313,315,315,318,318,319,319,321,322,323,324,324,326,329,329,329,331,331,333,333,334,334,336,339,339,340,341,341,343,344,348,351,351,352,353,354,354,358,359,363,364,364,365,367,367,368,369,370,372,372,373,376,376,378,379,379,381,382,383,385,386,391,391,391,394,396,399,400,411,414,414,414,416,423,429,429,430,430,431,435,436,437,438,442,443,444,447,448,452,452,452,452,452,455,456,457,457,462,466,468,468,468,472,472,472,472,473,473,475,476,476,477,477,480,481,481,482,483,483,484,485,485,486,486,491,491,491,491,492,494,495,497,497,500,502,503,505,505,509,510,514,515,515,515,516,516,518,519,519,520,522,524,525,527,528,529,531,534,537,537,540,543,543,544,544,545,549,552,552,556,558,558,565,565,566,569,570,571,572,575,577,577,578,579,579,581,583,584,586,586,590,591,593,597,603,603,605,607,608,611,613,614,622,622,622,623,631,631,633,635,638,638,639,642,643,644,645,646,649,652,653,653,654,655,655,655,655,657,659,660,661,664,665,666,667,671,682,684,685,686,688,691,692,694,694,696,698,699,702,704,704,704,706,706,709,710,713,713,714,717,723,725,726,727,727,729,730,730,732,732,733,734,738,740,740,741,746,750,751,751,755,755,758,759,759,760,764,765,767,769,771,773,774,775,776,779,779,781,782,785,797,797,798,798,798,802,803,804,804,806,807,808,809,809,810,810,812,814,814,818,819,820,822,822,823,824,826,826,826,827,830,831,833,833,833,834,837,838,838,839,840,840,841,844,844,847,848,851,852,853,854,857,860,862,864,868,868,869,870,872,874,880,881,881,883,884,885,888,889,892,892,896,897,897,898,899,901,904,905,907,908,914,914,915,915,916,918,920,921,921,921,927,927,928,928,929,932,932,932,932,933,937,937,938,939,940,941,941,942,942,942,944,945,945,946,947,948,952,952,955,956,960,962,964,964,966,968,968,968,971,973,973,973,974,978,979,979,981,982,983,985,985,989,990,990,990,993,994,994,995,998,999,999,1000]\n[999,999,1002,1003,1003,1004,1007,1010,1016,1016,1016,1020,1020,1022,1022,1024,1024,1027,1035,1038,1038,1041,1043,1044,1054,1055,1060,1064,1066,1067,1069,1070,1070,1071,1074,1074,1075,1081,1081,1087,1090,1092,1092,1094,1095,1095,1096,1097,1097,1098,1099,1103,1103,1103,1104,1104,1104,1105,1105,1108,1109,1109,1112,1112,1113,1116,1117,1117,1117,1117,1119,1121,1122,1124,1124,1125,1129,1129,1130,1131,1133,1133,1133,1135,1139,1140,1142,1142,1143,1144,1145,1146,1146,1148,1149,1151,1151,1151,1151,1152,1153,1153,1158,1159,1161,1164,1167,1171,1172,1173,1174,1176,1178,1178,1179,1180,1181,1182,1182,1183,1183,1185,1185,1186,1188,1189,1191,1192,1195,1200,1201,1201,1203,1204,1206,1207,1208,1208,1209,1210,1212,1212,1215,1216,1217,1222,1224,1225,1226,1226,1229,1230,1232,1232,1239,1241,1241,1243,1243,1244,1249,1252,1255,1256,1257,1263,1266,1266,1266,1270,1272,1274,1274,1280,1281,1288,1288,1288,1291,1291,1292,1296,1299,1301,1304,1304,1305,1306,1307,1310,1311,1311,1311,1312,1313,1313,1315,1315,1315,1319,1320,1321,1321,1321,1324,1324,1326,1327,1328,1330,1335,1348,1350,1351,1353,1355,1357,1357,1361,1365,1367,1368,1372,1374,1377,1383,1385,1388,1390,1390,1393,1393,1397,1398,1398,1398,1401,1402,1404,1405,1406,1407,1410,1410,1412,1412,1413,1414,1416,1416,1416,1416,1417,1418,1419,1423,1423,1428,1430,1432,1432,1433,1435,1436,1437,1438,1441,1441,1444,1444,1445,1449,1449,1449,1453,1457,1464,1466,1467,1469,1472,1475,1475,1478,1480,1485,1488,1488,1488,1489,1491,1493,1499,1500,1500,1500,1504,1505,1507,1508,1509,1510,1512,1512,1516,1519,1522,1528,1530,1532,1532,1538,1540,1540,1543,1545,1546,1548,1551,1553,1554,1555,1555,1561,1562,1563,1564,1565,1565,1569,1570,1570,1571,1572,1572,1577,1580,1580,1589,1589,1596,1599,1600,1600,1600,1600,1601,1602,1603,1607,1609,1610,1617,1618,1623,1623,1624,1626,1628,1629,1629,1630,1634,1637,1637,1637,1642,1645,1646,1646,1647,1647,1652,1657,1660,1662,1663,1666,1666,1667,1669,1670,1673,1675,1675,1677,1678,1678,1684,1686,1691,1691,1692,1694,1694,1697,1700,1700,1703,1704,1706,1706,1714,1715,1720,1720,1720,1720,1721,1721,1723,1725,1726,1728,1730,1730,1732,1733,1736,1739,1742,1744,1744,1752,1758,1759,1760,1764,1765,1766,1767,1769,1769,1773,1773,1773,1774,1775,1775,1775,1780,1783,1785,1785,1790,1791,1792,1793,1793,1795,1800,1803,1805,1807,1808,1811,1811,1811,1812,1812,1815,1816,1818,1819,1820,1821,1822,1823,1827,1828,1829,1830,1832,1835,1835,1835,1837,1839,1843,1843,1846,1849,1849,1849,1849,1851,1853,1853,1853,1854,1855,1861,1863,1865,1868,1870,1873,1878,1879,1881,1881,1881,1883,1883,1884,1885,1887,1889,1890,1891,1891,1894,1895,1896,1898,1899,1899,1901,1902,1904,1906,1907,1912,1912,1914,1914,1915,1917,1920,1921,1924,1926,1928,1930,1930,1931,1932,1933,1934,1934,1935,1936,1942,1943,1944,1947,1947,1948,1950,1951,1952,1953,1954,1956,1956,1957,1963,1964,1965,1966,1968,1968,1970,1971,1973,1979,1979,1981,1982,1986,1986,1986,1989,1992,1992,1998,1998,1999,1999,1999,2000]\n[1,1,2,4,7,10,10,11,17,24,26,26,27,28,32,33,33,35,35,35,37,37,37,38,40,41,45,48,50,50,53,53,54,55,55,55,56,57,63,66,68,71,76,79,81,81,82,83,85,88,89,91,95,96,100,102,103,104,104,105,107,107,108,109,109,112,116,118,118,118,119,119,120,121,123,124,124,127,128,128,128,130,132,134,134,140,141,141,143,143,144,147,148,150,150,152,153,155,156,157,164,166,166,167,167,168,176,178,184,185,190,191,191,192,193,194,197,199,201,201,204,207,207,211,211,216,225,225,228,229,233,234,235,237,237,237,238,239,239,244,247,248,248,251,251,254,258,259,259,261,263,266,268,269,269,269,269,271,281,282,285,285,286,287,292,293,295,295,295,296,300,300,302,305,305,305,309,310,310,310,311,318,319,319,320,320,321,321,322,328,329,332,333,334,335,336,336,339,339,339,341,341,345,346,346,347,348,348,349,349,349,350,351,351,355,356,361,363,363,364,366,366,367,368,368,371,371,373,377,380,381,381,382,384,384,387,387,389,394,395,399,400,402,406,406,407,407,410,415,418,419,424,427,433,434,436,437,442,444,445,451,455,455,456,457,459,461,462,463,464,464,465,465,465,467,468,469,473,476,476,476,480,482,483,486,488,489,490,493,495,495,496,496,497,499,499,500,502,504,505,509,509,511,511,516,516,517,521,523,525,526,528,528,530,534,534,535,538,538,541,541,544,544,544,544,546,547,550,550,551,553,555,556,556,557,558,558,559,561,563,567,569,569,570,571,571,572,574,574,575,575,578,582,583,583,584,584,586,590,592,592,594,595,596,598,598,598,601,603,603,604,612,617,618,620,620,624,626,627,628,631,635,637,637,638,641,645,650,651,652,653,654,657,659,659,661,661,661,661,662,663,663,664,664,665,666,669,670,670,671,675,676,683,684,688,689,689,689,690,691,692,694,695,695,696,697,697,700,705,705,707,708,708,709,709,710,710,712,714,716,716,716,718,721,722,722,723,724,725,728,728,729,730,735,735,737,737,741,741,744,747,748,749,750,751,751,754,754,755,757,757,759,759,761,763,763,763,764,766,767,771,771,777,778,778,778,781,782,782,786,786,786,787,787,787,790,790,790,791,792,792,793,801,803,804,805,805,805,805,807,808,808,808,810,815,817,819,819,822,829,829,830,832,832,834,834,836,836,836,837,842,843,844,846,846,847,847,847,850,851,852,853,853,854,854,855,855,858,860,863,864,866,866,867,871,875,881,883,883,886,888,888,890,891,892,894,897,903,913,914,915,918,918,919,920,920,922,923,925,927,927,927,927,928,937,943,943,943,946,948,949,950,953,954,958,966,968,968,971,979,980,981,983,984,985,985,987,987,990,991,992,992,992,997,999]\n[999,1000,1001,1001,1002,1005,1006,1008,1009,1011,1014,1014,1018,1019,1021,1026,1027,1031,1031,1032,1033,1034,1037,1038,1039,1041,1042,1043,1043,1043,1046,1049,1054,1055,1055,1058,1060,1064,1065,1065,1067,1067,1068,1074,1076,1076,1082,1082,1083,1084,1085,1086,1087,1094,1094,1095,1098,1101,1104,1104,1105,1105,1106,1106,1106,1107,1108,1112,1112,1113,1117,1118,1118,1119,1124,1124,1126,1126,1126,1130,1130,1132,1132,1133,1133,1134,1134,1136,1137,1139,1139,1139,1139,1139,1140,1141,1141,1141,1143,1144,1145,1147,1147,1150,1152,1153,1155,1157,1158,1159,1160,1161,1162,1163,1163,1165,1167,1167,1167,1167,1168,1168,1168,1168,1169,1171,1171,1172,1172,1173,1176,1177,1178,1178,1180,1181,1183,1184,1184,1185,1186,1186,1187,1188,1188,1189,1190,1191,1195,1196,1199,1200,1200,1201,1202,1206,1207,1208,1209,1211,1211,1212,1217,1221,1221,1222,1222,1224,1225,1226,1230,1230,1231,1232,1237,1237,1240,1243,1243,1243,1243,1243,1245,1245,1248,1248,1248,1249,1249,1253,1254,1255,1257,1258,1260,1265,1266,1268,1269,1270,1271,1271,1273,1274,1275,1277,1278,1279,1280,1281,1281,1283,1283,1284,1284,1286,1286,1287,1288,1288,1289,1290,1291,1292,1292,1295,1297,1298,1298,1299,1301,1302,1304,1306,1306,1307,1308,1310,1311,1312,1316,1316,1317,1318,1319,1320,1320,1321,1322,1324,1324,1324,1325,1327,1329,1330,1331,1331,1331,1332,1333,1333,1334,1336,1342,1345,1346,1347,1347,1349,1349,1350,1351,1352,1355,1355,1356,1357,1357,1362,1363,1364,1364,1364,1365,1370,1370,1372,1372,1374,1374,1375,1375,1376,1376,1378,1379,1379,1381,1382,1383,1384,1385,1386,1389,1391,1391,1391,1393,1394,1395,1397,1397,1401,1403,1405,1405,1406,1407,1407,1408,1409,1410,1413,1413,1416,1418,1418,1421,1422,1422,1424,1424,1425,1426,1428,1428,1429,1430,1434,1436,1439,1439,1439,1439,1440,1440,1441,1441,1442,1442,1442,1444,1445,1447,1447,1451,1451,1452,1456,1460,1462,1463,1468,1469,1469,1470,1470,1471,1472,1472,1474,1476,1478,1478,1482,1484,1486,1486,1488,1489,1489,1493,1494,1495,1495,1497,1498,1502,1503,1505,1506,1507,1507,1508,1511,1512,1513,1514,1515,1516,1518,1520,1520,1520,1522,1523,1525,1525,1527,1527,1528,1531,1531,1532,1533,1534,1535,1537,1538,1540,1540,1541,1543,1543,1544,1545,1546,1548,1549,1551,1551,1552,1552,1552,1553,1556,1556,1557,1557,1557,1559,1559,1560,1561,1561,1562,1564,1564,1564,1564,1566,1566,1567,1571,1571,1572,1573,1573,1574,1574,1577,1577,1583,1584,1584,1588,1589,1590,1593,1593,1595,1596,1596,1596,1597,1598,1601,1604,1604,1606,1606,1607,1607,1610,1610,1611,1611,1612,1612,1614,1615,1616,1617,1621,1622,1622,1622,1623,1626,1627,1631,1632,1636,1637,1637,1638,1640,1642,1642,1644,1645,1647,1648,1650,1651,1652,1653,1655,1655,1656,1656,1656,1656,1658,1658,1658,1660,1660,1663,1664,1665,1666,1667,1667,1667,1669,1669,1670,1676,1678,1680,1681,1681,1682,1684,1684,1685,1686,1686,1687,1689,1689,1689,1690,1693,1694,1698,1700,1702,1703,1706,1708,1708,1708,1710,1712,1712,1712,1713,1715,1715,1717,1719,1719,1720,1720,1721,1722,1722,1724,1731,1732,1734,1734,1737,1737,1741,1743,1743,1749,1749,1751,1753,1754,1754,1756,1757,1757,1758,1759,1761,1761,1762,1764,1766,1766,1767,1769,1769,1771,1772,1772,1775,1775,1775,1777,1779,1779,1781,1782,1782,1783,1786,1788,1788,1788,1790,1793,1793,1793,1793,1794,1795,1795,1796,1796,1796,1797,1799,1800,1803,1810,1811,1814,1814,1814,1816,1817,1819,1820,1820,1822,1824,1826,1826,1826,1827,1828,1828,1831,1832,1834,1835,1836,1837,1838,1838,1841,1843,1849,1851,1851,1852,1852,1853,1853,1854,1854,1856,1858,1859,1863,1863,1863,1869,1871,1872,1872,1873,1874,1879,1880,1881,1881,1882,1883,1883,1883,1885,1885,1885,1886,1887,1887,1889,1894,1898,1899,1901,1902,1903,1904,1907,1908,1910,1911,1911,1911,1913,1914,1914,1915,1916,1917,1918,1921,1922,1923,1923,1924,1926,1926,1933,1933,1934,1934,1934,1936,1938,1938,1939,1939,1941,1941,1942,1942,1947,1947,1947,1947,1949,1949,1952,1954,1955,1957,1958,1959,1960,1960,1963,1964,1964,1964,1966,1968,1971,1973,1975,1977,1978,1978,1979,1979,1980,1981,1981,1982,1984,1985,1985,1987,1987,1987,1987,1987,1988,1989,1990,1991,1994,1994,1995,1996,1997,1997,1998]\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this help](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e)s and makes thinks clear\\nand do clap \\uD83D\\uDC4F to appreciate the article"
                    },
                    {
                        "username": "pwho",
                        "content": "If you\\'re going to share an article here, don\\'t hide it behind a paywall. =\\\\"
                    },
                    {
                        "username": "user5979vk",
                        "content": "Thanks (https://archive.is/E2agn)"
                    },
                    {
                        "username": "4alisha",
                        "content": "very helpful\\uD83D\\uDC4F"
                    },
                    {
                        "username": "thecodingkid",
                        "content": "Any help would be appreciated if you could explain why the solution in the O(log(min(m,n))) case requires a swap if the second array is smaller.\\n\\nIf you could specify any edge case that is failing , that would be of great help."
                    },
                    {
                        "username": "bparanj",
                        "content": "Swapping nums1 and nums2 if nums1 is larger than nums2 is a trick to simplify the problem by reducing it to a condition where we always binary search on the smaller array. This doesn\\'t change the result because the median of two arrays doesn\\'t depend on which array is longer, but it makes the code cleaner and easier to understand, and it also improves performance by minimizing the search space.\\n\\nMoreover, this technique ensures that we do not run into an index out of bounds error during our binary search process. \\n\\nLet\\'s consider an edge case where the swapping would be important:\\n\\nnums1 = [6, 7, 8, 9, 10]\\nnums2 = [1, 2, 3]\\n\\nIf we did not swap, and started the binary search on nums1, we would end up exploring unnecessary parts of nums1 that wouldn\\'t impact the final result, since we know that the median must be within the range covered by nums2 due to its smaller size and range of values. \\n\\nIf we swap and binary search on nums2, we can find the median more efficiently because we focus on the smaller range of values. We then only need to compare with a few specific elements of nums1.\\n\\nTo summarize, the swap is used to ensure efficiency and simplicity by always performing binary search on the smaller array."
                    }
                ]
            },
            {
                "id": 2066587,
                "content": [
                    {
                        "username": "yon",
                        "content": "Input:\\t[1,1], [1,2]\\nExpected:\\t1.00000\\n\\nMy solution way is merge [1,1] and [1,2] to [1,2], so the answer would be (1+2)/2 = 1.5\\nWhat did I made wrong?"
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "you first merge it (preserving duplicates).\\n[1, 1, 1, 2]\\n\\nWhats the middle element here?\\noh wait. there are two elements at the middle. 1 and 1.\\nso you average em. \\n(1 + 1) / 2 = 1"
                    },
                    {
                        "username": "RISHIKA_GANDHI",
                        "content": "change your (1+2)/2 to this (1+2)/2.0 you will get you result into float/double type"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "the merged array will we [1,1,1,2] ,\\nno of elements are even so median will we (1+1)/2=1.\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the hell nooo. median is 1 here"
                    },
                    {
                        "username": "hankIgoe",
                        "content": "the merged string is [1,1,1,2], so the median is (1+1)/2 = 1.0\\n"
                    },
                    {
                        "username": "vyshnusanthosh",
                        "content": "If you are using java, when two integers are divided the answer will also be an integer in order to get floating point you need to type cast the integers to double or float before division."
                    },
                    {
                        "username": "megazortti",
                        "content": "i\\'m facing the same problem..\\n"
                    },
                    {
                        "username": "khushal1201",
                        "content": "[@zwicky](/zwicky) the merged array should be [1,1,1,2]. Hence the median would be (1+1)/2 = 1."
                    },
                    {
                        "username": "zwicky",
                        "content": "you shouldn\\'t remove duplicates"
                    },
                    {
                        "username": "hing_liu",
                        "content": "Let try to interate the algorithm first:\\n\\nIt is basically a k-th smallest element problem between two sorted arrays, let assume we have the following two arrays:\\n\\n5,7,8,11\\n4,9,12,14\\n\\nk = 4 (expected ans = 8 because when it is sorted: 4,5,7,**8**,9,11,12,14)\\n\\nStep 1: Cut the two arrays into two pieces such that the left side will have total items of 4 (i.e. the **K=4**)\\n5,7 | 8, 11\\n4,9 | 12, 14\\n\\nStep 2: We remove [5,7] because its end index at the left side is smaller (7. v.s 9) and we update K = 2 (since we removed 2 item=> K - 2 = 4 - 2 = 2), it will becomes:\\n8,11 <-- removed [5,7]\\n4,9,12,14\\n\\n(basically the rest of the steps below is to repeat 1 and 2 until K = 1)\\n\\nStep 3: Repeat Step 1, Cut into two half base on **K = 2**\\n8 | 11\\n4 | 9 12 14\\n\\nStep 4: Repeat Step 2, that is remove 4 and update **K = 1** (since we removed 1 item=>K-1 = 2-1 1)\\n\\nStep 5: Repeat Step 1, Cut into two half base on K = 1, since K = 1 is not able to split (we have two arrays, don\\'t know how to split), we conclude the solution as the minimum of the first item of the two array, that is min(8,9) = 8\\n8,11\\n9,12,14\\n\\nWe are all done, how about K = 3 initially? Basically the point of \\'cut\\' is K/2 - 1, therefore when K = 3, the cutting point is index=0, let us go though this again quickly for this:\\n\\nK=3\\n5|7,8,11\\n4|9,12,14\\n\\nK=2\\n5|7,8,11\\n9|12,14\\n\\nK=1\\n7|8,11\\n9|12,14 \\nAns=min(7,9) = 7\\n\\nThere is some edge case not tell here, this is just a general idea. We want to have the first K-th item, so, the first target is to collect the first K item from the two array, so we fairly cut them at K/2 - 1 and remove the smaller list until K = 1.\\n\\nThis might be still hard to understand, consider we are not greedy, we do it one by one (we don\\'t cut base on K, but always cut by two):\\n\\nK=4\\n5 | 7 8 11\\n4 | 9 12 14\\n\\nAt this point, we remove the smaller one and have:\\nK=3\\n5 | 7 8 11\\n9 | 12 14\\n\\nKeep doing this until K = 1\\nK=2\\n7 | 8 11\\n9 | 12 14\\n\\nK = 1\\n8 | 11\\n9 | 12 14\\n(at this point, all done)\\n\\nWe are now reaching the answer = 8 by doing this in one-by-one manner, the cutting point at this \\'slow-version\\' is always [0], and the faster version is doing the cutting point at [k/2 - 1], that still work because they are sorted, it is safe to jump further and remove the whole preceding items rather than doing this one-by-one manner.\\n\\nAgain, this might still be hard to convince yourself why the \\'faster-version\\' has no issue, just hope this can help you understand more.\\n\\nGoing back to tell why it is a k-th minimum issue, consider when we have ths int kth(arr1, arr2, k) function, we can put k to be the middle of sizeof(arr1) and sizeof(arr2), if it is even number of size we just get the adjacent (run kth function two times) so we can get the middle two and divide it by 2, so the answer ..."
                    },
                    {
                        "username": "rds8rds",
                        "content": "thanks properly understand the concept!"
                    },
                    {
                        "username": "parismania",
                        "content": "That\\'s quite a good explanation. Thank you!"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I tried to avoid this question for as long as possible"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally solved this by merging the two arrays. I always intended to do the proper solution - one day. Today is the day."
                    },
                    {
                        "username": "raviTejaY",
                        "content": "\\tvar findMedianSortedArrays = function(nums1, nums2) {\\n  \\tlet mid;\\n\\t  let res = [...nums1, ...nums2].sort((a,b) => a-b);\\n\\t mid = (res.length-1)/2;\\n\\t  if(res.length % 2 === 1){\\n\\t\\treturn res[mid].toFixed(5);\\n\\t  } else {\\n\\t\\tlet median = (res[Math.floor(mid)] + res[Math.ceil(mid)]) / 2;\\n\\t\\treturn median.toFixed(5)\\n\\t  }\\n\\t};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, you use .sort(), which does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "hongbin2",
                        "content": "My naive solution is just merge two array and find the median. Obvious we can do better. But I just have no idea about it."
                    },
                    {
                        "username": "aneesfathimasaifudeen",
                        "content": "Input\\n[1,2]\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000\\n\\nThis test case always fails for me in leetcode, whereas it works for me in my machine\\'s python compiler with the same code.\\n\\nCan anyone tell, what would be the problem here?"
                    },
                    {
                        "username": "evenn",
                        "content": "choose Python3 rather than Python to execute code"
                    },
                    {
                        "username": "kapilkapuriya",
                        "content": "[@jeetu16](/jeetu16)  use type cast when you perform   ** ans = a/2 **  so do like this  **  ans = double(a)/2 ** "
                    },
                    {
                        "username": "doubleshab",
                        "content": "[@jeetu16](/jeetu16) I had a similar problem using Python3. For me, the issue was that the math I was using to generate my index values was producing float values. By forcing them to integer types using the int() builtin, I was able to get around it."
                    },
                    {
                        "username": "python_is_cheat_code",
                        "content": "Facing the same issue. Have no idea what to do."
                    },
                    {
                        "username": "AtrijPaul",
                        "content": "If you are coding in Java then division of two integers will be integer only , after performing the division it get stored as double. So instead of dividing by 2 , divide by 2.0 , it will work."
                    },
                    {
                        "username": "jeetu16",
                        "content": "have you found the solution till now?\\ni faced the same problem"
                    },
                    {
                        "username": "scott40",
                        "content": "The question states: \"There are two sorted arrays nums1 and nums2 of size m and n respectively.\" This does not tell me whether the sort order is largest to smallest, or smallest to largest. It would even be possible for nums1 to be sorted largest to smallest while nums2 is sorted from smallest to largest. So I thought we would need to be able to handle such cases, making no assumptions as to the direction of the sorts. As a test case of opposite sort directions in the inputs I tried:\\n[10,8,3]\\n[5,9,17]\\n\\nBoth input lists sorted as required, but in opposite directions. The median here should be 8.5, but when I ran the test case it gave me an expected answer of 6.5. So I think leetcode is making an assumption about the sort directions of the inputs that should not be made, and it is not designed to properly handle this case. What are we allowed to assume about the input sort direction?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement does not explicitly mention the sort order. However, it is conventionally assumed that, unless stated otherwise, a \"sorted\" array or list is in non-decreasing order, meaning from smallest to largest. This assumption is consistent with most problems and discussions involving sorted data in computer science and mathematics.\\n\\nTherefore, in the context of this problem, you can assume that both input arrays are sorted in non-decreasing order. This assumption informs the approach to solving the problem. If the arrays were sorted in non-increasing order or if one array was sorted in increasing order while the other in decreasing order, a different approach might be necessary.\\n\\nHowever, if the problem were to handle arrays sorted in either direction, a pre-processing step could be added to sort the arrays in the desired order before proceeding with the rest of the algorithm. This would increase the time complexity, though, because sorting is generally an O(n log n) operation."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit before validating your solution against a few edge cases, e.g.\n```\n[-932210,-932056,-922328,-917451,-913929,-907514,-883337,-802571,-739964,-709048,-692863,-690427,-679691,-666576,-643630,-638229,-585992,-574362,-571309,-541584,-538138,-497470,-480909,-459608,-444410,-426022,-403497,-393857,-363379,-359219,-347291,-330378,-314805,-303621,-291243,-251965,-244657,-243891,-236303,-234099,-217309,-210326,-199139,-197450,-177317,-172519,-170556,-137069,-128436,-113727,-95170,-79317,-52534,-4681,40199,89215,107649,109238,124507,157189,162498,180216,200111,228032,251189,262426,319119,323615,344264,345305,373566,399588,411387,427092,427955,456725,461974,468467,474372,476390,562956,577916,580839,591862,616385,638656,650816,653650,672517,753495,769837,779299,801738,809541,836250,872512,917419,949439,959386,979587]\n[]\n[]\n[-999311,-995487,-993598,-993127,-989482,-973229,-926998,-898485,-851725,-850712,-836433,-795269,-784476,-764197,-763427,-756479,-755190,-753600,-717158,-677976,-668634,-640052,-597569,-589282,-520481,-515063,-499955,-479622,-477302,-473002,-403966,-400582,-388037,-363473,-344547,-324788,-320701,-314920,-296000,-290463,-276432,-273513,-244152,-215671,-192226,-184426,-128230,-122297,-75423,-58001,-8481,2993,27765,54297,64282,81674,93781,96008,152144,154165,166583,169777,181118,191164,216155,263473,271293,308484,360932,380484,405656,413389,432913,436707,461128,530274,555172,576238,595665,608718,624952,644037,684003,697121,727400,730624,751135,768207,784915,792103,809755,831583,832823,844259,886508,913559,941025,950966,975298]\n[-999567,-997502,-997320,-997131,-995209,-993605,-991650,-991613,-991417,-990564,-989776,-987550,-985870,-985386,-982368,-981518,-979842,-979718,-978628,-976620,-974345,-973518,-972291,-967402,-967265,-966730,-965785,-962771,-961174,-960505,-959719,-955802,-955134,-953099,-948117,-944790,-941695,-941693,-939131,-938510,-937577,-937038,-935074,-933558,-933056,-930614,-929544,-924799,-922049,-920262,-919703,-917939,-916145,-915636,-914995,-913579,-896888,-894679,-894651,-891943,-891618,-891260,-888315,-886543,-884101,-883513,-872873,-872826,-872120,-871050,-870232,-869805,-868351,-867330,-866646,-866243,-863978,-863009,-859149,-858906,-858758,-854975,-852689,-852164,-851427,-850218,-847970,-845912,-845486,-844687,-844411,-843956,-843353,-839477,-837499,-836703,-833607,-831373,-830358,-827611,-827276,-827145,-827057,-825816,-823331,-822868,-822693,-821423,-820561,-819808,-815340,-814889,-814639,-814554,-813263,-811601,-810742,-810567,-808592,-807943,-805362,-805085,-803725,-798929,-792149,-789206,-785856,-783704,-783011,-781163,-775292,-772930,-769271,-764889,-764165,-763180,-758264,-756607,-755921,-752956,-752637,-751864,-751318,-750878,-750246,-749003,-746825,-744464,-744367,-743637,-741289,-738903,-736545,-732164,-731981,-731878,-730164,-727779,-725497,-725433,-720206,-715719,-714089,-707566,-705091,-705008,-705000,-699566,-696000,-694414,-689552,-688092,-683083,-681058,-680084,-676059,-675854,-675730,-672990,-671402,-669298,-669292,-667660,-667250,-662853,-660122,-658209,-657793,-657002,-656472,-653603,-647017,-643156,-642765,-642520,-638572,-637837,-636344,-635145,-629818,-628344,-624890,-622582,-621602,-619124,-617701,-616391,-613542,-609069,-605811,-604133,-603960,-602075,-601936,-601600,-599041,-598358,-597574,-597092,-596147,-594696,-592955,-592300,-591877,-591829,-591201,-589912,-584118,-583933,-574753,-567021,-566697,-565332,-564305,-562776,-561152,-557378,-553247,-551405,-541292,-536736,-533881,-533615,-532784,-531029,-530553,-527184,-526662,-525823,-525625,-525093,-520969,-520545,-515036,-510919,-507746,-504592,-504032,-503595,-501437,-499214,-496301,-494795,-490284,-486646,-485513,-484383,-480751,-476832,-476559,-474296,-469572,-469152,-468659,-466347,-462419,-460567,-458882,-457050,-454911,-453624,-452324,-450481,-449509,-440836,-439940,-436508,-434347,-431863,-426890,-422954,-422337,-419891,-419812,-419313,-415360,-413516,-410195,-409526,-409454,-408360,-408054,-406101,-404269,-401590,-400963,-394836,-385314,-375836,-374995,-374048,-368693,-368131,-367859,-361397,-360458,-356055,-354270,-354227,-346946,-346223,-346099,-345855,-344808,-344247,-343806,-342087,-339682,-338497,-335912,-334945,-330597,-328200,-327450,-323098,-320641,-319061,-316787,-314312,-314133,-313427,-313020,-311735,-311556,-308652,-307950,-307902,-305049,-304780,-304200,-301782,-301539,-296853,-296489,-293520,-285339,-284857,-284262,-283709,-282070,-281202,-281164,-277190,-276021,-274641,-273757,-273728,-270394,-269087,-265427,-265272,-264115,-263447,-262116,-259606,-257673,-257419,-257235,-257127,-257053,-256900,-256146,-255547,-253986,-249576,-249079,-245481,-239011,-235597,-230997,-228005,-227497,-227250,-226380,-225431,-216611,-210008,-208956,-208838,-201921,-199428,-196686,-191696,-190547,-189199,-188847,-188753,-186418,-185773,-185206,-182706,-180515,-179348,-178474,-175203,-174731,-173012,-173012,-171115,-170095,-168308,-168128,-166905,-166742,-164733,-164448,-158590,-157720,-156014,-155429,-153638,-149375,-148870,-148098,-147945,-145512,-145183,-141591,-139964,-137213,-134488,-133486,-132424,-131215,-130615,-125187,-124332,-117324,-113085,-112523,-111751,-111383,-104409,-104344,-102517,-102161,-98185,-97846,-91902,-89723,-84742,-84067,-83948,-82603,-82579,-78160,-76854,-75430,-75344,-74962,-71408,-69102,-66641,-65642,-64757,-61211,-60329,-57886,-53220,-52898,-49270,-49124,-48080,-45815,-44789,-37626,-34882,-34859,-32485,-31102,-29729,-24983,-22453,-20259,-16334,-16193,-15026,-12533,-11486,-9861,-4017,-404,704,6117,7576,8139,8688,16526,17499,22574,25852,26549,29362,30492,33676,37645,40152,43767,44242,46314,47444,50651,52396,53898,59922,60919,63930,68755,69424,70153,71709,73909,75531,75770,77643,78793,81457,83544,85477,89943,91011,91041,91192,94363,94670,95048,96537,98525,98539,104346,107800,108042,109819,110121,115691,117048,118363,118924,120311,125092,127555,127995,128168,135729,138889,140152,140261,140971,145327,145731,145860,152322,155692,159510,161250,163594,164930,166753,167883,168915,172982,173783,174795,175457,179314,180491,180628,189221,190490,190611,193586,195760,199322,201329,202231,202971,205732,206448,209484,210079,213383,213627,214223,215757,218866,223260,224593,225505,228101,229883,232562,234221,235355,236464,236563,238608,240104,242362,242959,245209,246122,246173,249953,255505,258524,260918,261968,262033,262830,263342,263665,265410,265772,266591,268471,270067,274107,276862,277801,277848,278505,278931,279516,285322,286378,293299,294255,296317,296787,297292,300002,302027,302121,302296,304390,304403,306514,311250,311643,316657,317008,319056,320827,322849,324605,326098,326173,326315,326588,328330,329876,330948,331341,331948,332124,341297,341942,343708,344436,344659,350897,351495,351893,352596,353479,355046,356056,357088,357742,358398,360172,365218,372048,375602,376611,382420,386919,389469,391011,392771,396046,403823,404843,407192,409690,410139,411497,418925,419472,419584,420171,421967,425637,428244,428593,429601,430662,431024,432899,434667,438639,438690,438839,441713,443399,449585,454891,459572,461567,464223,464977,468031,468216,468980,469952,471601,473590,476517,477804,478040,479232,481442,482516,487561,489198,493596,494509,498310,500634,502180,503663,504932,507455,511419,515818,517896,518474,520182,520335,520403,520452,523949,524745,525015,526693,531560,536815,536885,536922,537002,537675,541832,543158,547884,548488,549711,559134,559481,559820,560772,560870,561935,563399,563985,568956,569744,570203,573437,574202,574696,578813,579430,588576,588747,590647,604861,606852,606861,607746,608154,609468,609523,611937,611965,612112,614230,619688,620348,621041,621873,622766,633850,636410,645785,647203,647468,648663,651250,653354,655650,655736,656313,656473,660352,665886,668634,668889,668947,670032,670182,670412,673826,686025,686683,691645,692054,692284,695765,697395,697829,702166,708541,709011,711141,712520,714573,716618,721072,721706,721848,721884,722339,722954,724012,724181,726931,729781,730450,732815,734038,734313,735874,736725,737913,738002,740812,743047,744545,745638,746517,747495,747721,754971,755927,760296,760368,768237,770512,771998,772642,773928,775652,776009,776528,778433,784050,788493,788662,790251,794398,797252,797470,798288,800465,801126,806618,807774,810900,812412,812864,815004,819410,819576,821429,822144,828766,831814,834893,834987,838359,839232,839741,845812,846318,851048,851400,852080,856264,859668,861457,862611,863385,867019,872146,872332,877196,879288,879573,883230,888081,889012,889628,889844,890313,891004,891633,897234,900619,901180,901991,904976,905449,905491,905566,906218,906325,911636,912008,912597,917627,919382,921003,924181,925430,925724,925947,929266,934039,935863,937145,938405,941714,945193,946019,948295,950933,951602,951856,952469,953824,954207,954485,954748,959150,960644,962815,963477,963549,963815,964638,965098,967348,967682,969084,971079,973452,974228,976702,976910,978359,981049,982811,982859,987419,993386,994771,995167,996051,998221]\n[-987944,-969636,-969382,-963918,-960334,-957471,-955419,-954534,-949617,-948164,-941370,-934887,-933385,-933024,-925395,-920598,-914952,-912930,-910713,-898551,-897943,-895093,-883721,-881114,-868961,-862108,-859224,-844995,-843122,-841350,-839681,-837319,-833916,-832929,-824567,-821404,-817679,-816414,-815142,-814794,-814428,-812717,-803053,-800629,-791874,-784923,-776546,-772543,-770170,-769595,-767768,-764581,-760610,-755916,-750060,-738122,-734792,-733242,-728895,-725665,-725507,-718134,-717075,-715534,-715202,-713373,-712097,-708739,-707414,-706871,-703365,-702017,-693735,-683042,-672054,-669261,-668919,-664791,-661728,-660926,-656147,-645420,-643702,-643193,-641435,-638420,-634551,-628772,-615960,-603372,-601747,-598111,-594931,-589739,-582816,-582756,-578800,-578594,-573174,-567081,-559766,-559620,-556681,-554084,-553002,-549693,-548262,-545226,-544969,-537261,-533737,-528123,-520081,-506744,-504736,-499021,-496520,-496470,-495274,-493267,-486175,-485863,-484654,-482183,-481473,-479689,-476360,-474984,-474568,-470604,-469841,-458033,-456643,-456026,-449361,-448407,-447725,-446572,-444202,-444122,-438385,-438174,-436049,-433511,-429215,-428895,-423500,-419598,-414944,-413779,-413601,-413134,-395813,-386542,-386081,-384022,-383217,-377664,-375237,-370842,-368652,-368619,-367534,-360286,-359315,-356864,-346574,-344238,-342362,-338322,-337904,-317031,-315369,-311471,-307529,-291585,-288367,-282217,-273392,-268202,-266384,-262947,-261304,-259484,-253107,-253097,-247496,-240183,-238502,-232673,-225567,-225273,-220556,-218540,-217405,-209508,-209191,-198492,-196102,-194657,-187900,-187654,-187409,-183298,-183195,-178895,-172948,-164463,-150912,-150447,-147157,-146039,-142859,-142513,-141007,-140514,-133632,-121672,-120655,-111524,-106570,-104308,-101032,-100077,-99330,-98302,-93625,-88734,-88072,-87928,-84357,-71659,-69515,-67676,-63282,-58552,-56529,-55822,-52857,-49183,-49096,-36632,-35822,-22044,-15543,-13193,-11327,-8347,-5921,367,2667,4951,5292,12503,13977,16698,20683,21104,29329,29383,32131,36676,38796,38939,39209,47231,48354,58584,63004,67608,68400,79071,80602,81795,86542,94114,101023,103400,104656,104880,111548,112896,115766,121077,122734,127019,127444,132932,138051,140440,154194,158884,165068,166138,166908,169497,170785,171990,179699,180030,188999,195927,197727,215034,218444,219489,222687,224521,235464,235727,241470,243528,246904,258231,259122,260441,263591,265308,267313,269450,272354,272547,274104,276239,278349,282844,283153,284414,285344,292275,301326,301817,303601,305996,308758,308841,318258,318758,326276,328210,328413,329591,330688,335804,336586,338827,350724,353017,355893,356488,358137,367458,369246,373776,375814,388619,389665,391494,398826,410285,414310,434616,436368,437657,441921,442891,443722,445197,448982,449981,452442,455491,458606,458789,459482,459977,460011,467293,480680,484432,486822,491840,495107,498402,498655,499730,501125,506371,507661,508352,508531,510705,517473,521451,521763,531020,535521,536548,538401,543120,545936,546904,551503,551845,552061,557919,565312,566269,568604,574239,574420,578570,579251,582167,587488,592161,594286,604994,619288,622829,629325,652728,657554,659113,659971,661630,664091,664280,667722,673155,674069,675252,680792,683874,685152,698652,701722,703282,708464,710121,710242,712200,718611,720934,732059,736885,739191,742494,750812,759987,772722,776392,782107,782131,783537,783996,785898,793147,799555,806418,807432,808677,831974,841540,844398,849513,849656,854080,855359,858674,865625,866262,870340,877863,886981,896266,898306,900880,903869,907452,914307,916336,916960,922084,923604,924431,926571,930085,935193,948240,948473,954648,957779,959463,960134,960965,975144,979240,997354,999899]\n[0,2,3,4,4,6,6,7,8,8,8,8,11,11,15,16,17,20,22,26,26,28,29,30,31,32,36,39,40,41,41,44,45,52,52,53,54,56,57,62,70,71,72,74,78,78,80,80,83,84,86,87,88,90,91,92,92,96,99,104,105,106,110,110,112,113,113,115,116,118,119,121,121,123,124,125,125,129,129,131,131,134,135,140,141,141,143,144,145,145,145,150,152,153,154,157,158,159,159,159,164,164,169,172,176,176,177,178,178,184,185,189,189,190,191,192,193,193,194,194,195,196,196,200,203,204,205,206,210,211,211,212,212,213,216,219,220,222,225,226,229,229,233,234,237,238,239,241,243,243,246,246,248,249,249,250,250,251,253,255,256,258,260,260,262,266,268,268,269,271,272,273,273,280,281,282,283,288,288,295,296,296,298,302,304,305,305,305,305,306,306,308,309,310,312,313,315,315,318,318,319,319,321,322,323,324,324,326,329,329,329,331,331,333,333,334,334,336,339,339,340,341,341,343,344,348,351,351,352,353,354,354,358,359,363,364,364,365,367,367,368,369,370,372,372,373,376,376,378,379,379,381,382,383,385,386,391,391,391,394,396,399,400,411,414,414,414,416,423,429,429,430,430,431,435,436,437,438,442,443,444,447,448,452,452,452,452,452,455,456,457,457,462,466,468,468,468,472,472,472,472,473,473,475,476,476,477,477,480,481,481,482,483,483,484,485,485,486,486,491,491,491,491,492,494,495,497,497,500,502,503,505,505,509,510,514,515,515,515,516,516,518,519,519,520,522,524,525,527,528,529,531,534,537,537,540,543,543,544,544,545,549,552,552,556,558,558,565,565,566,569,570,571,572,575,577,577,578,579,579,581,583,584,586,586,590,591,593,597,603,603,605,607,608,611,613,614,622,622,622,623,631,631,633,635,638,638,639,642,643,644,645,646,649,652,653,653,654,655,655,655,655,657,659,660,661,664,665,666,667,671,682,684,685,686,688,691,692,694,694,696,698,699,702,704,704,704,706,706,709,710,713,713,714,717,723,725,726,727,727,729,730,730,732,732,733,734,738,740,740,741,746,750,751,751,755,755,758,759,759,760,764,765,767,769,771,773,774,775,776,779,779,781,782,785,797,797,798,798,798,802,803,804,804,806,807,808,809,809,810,810,812,814,814,818,819,820,822,822,823,824,826,826,826,827,830,831,833,833,833,834,837,838,838,839,840,840,841,844,844,847,848,851,852,853,854,857,860,862,864,868,868,869,870,872,874,880,881,881,883,884,885,888,889,892,892,896,897,897,898,899,901,904,905,907,908,914,914,915,915,916,918,920,921,921,921,927,927,928,928,929,932,932,932,932,933,937,937,938,939,940,941,941,942,942,942,944,945,945,946,947,948,952,952,955,956,960,962,964,964,966,968,968,968,971,973,973,973,974,978,979,979,981,982,983,985,985,989,990,990,990,993,994,994,995,998,999,999,1000]\n[999,999,1002,1003,1003,1004,1007,1010,1016,1016,1016,1020,1020,1022,1022,1024,1024,1027,1035,1038,1038,1041,1043,1044,1054,1055,1060,1064,1066,1067,1069,1070,1070,1071,1074,1074,1075,1081,1081,1087,1090,1092,1092,1094,1095,1095,1096,1097,1097,1098,1099,1103,1103,1103,1104,1104,1104,1105,1105,1108,1109,1109,1112,1112,1113,1116,1117,1117,1117,1117,1119,1121,1122,1124,1124,1125,1129,1129,1130,1131,1133,1133,1133,1135,1139,1140,1142,1142,1143,1144,1145,1146,1146,1148,1149,1151,1151,1151,1151,1152,1153,1153,1158,1159,1161,1164,1167,1171,1172,1173,1174,1176,1178,1178,1179,1180,1181,1182,1182,1183,1183,1185,1185,1186,1188,1189,1191,1192,1195,1200,1201,1201,1203,1204,1206,1207,1208,1208,1209,1210,1212,1212,1215,1216,1217,1222,1224,1225,1226,1226,1229,1230,1232,1232,1239,1241,1241,1243,1243,1244,1249,1252,1255,1256,1257,1263,1266,1266,1266,1270,1272,1274,1274,1280,1281,1288,1288,1288,1291,1291,1292,1296,1299,1301,1304,1304,1305,1306,1307,1310,1311,1311,1311,1312,1313,1313,1315,1315,1315,1319,1320,1321,1321,1321,1324,1324,1326,1327,1328,1330,1335,1348,1350,1351,1353,1355,1357,1357,1361,1365,1367,1368,1372,1374,1377,1383,1385,1388,1390,1390,1393,1393,1397,1398,1398,1398,1401,1402,1404,1405,1406,1407,1410,1410,1412,1412,1413,1414,1416,1416,1416,1416,1417,1418,1419,1423,1423,1428,1430,1432,1432,1433,1435,1436,1437,1438,1441,1441,1444,1444,1445,1449,1449,1449,1453,1457,1464,1466,1467,1469,1472,1475,1475,1478,1480,1485,1488,1488,1488,1489,1491,1493,1499,1500,1500,1500,1504,1505,1507,1508,1509,1510,1512,1512,1516,1519,1522,1528,1530,1532,1532,1538,1540,1540,1543,1545,1546,1548,1551,1553,1554,1555,1555,1561,1562,1563,1564,1565,1565,1569,1570,1570,1571,1572,1572,1577,1580,1580,1589,1589,1596,1599,1600,1600,1600,1600,1601,1602,1603,1607,1609,1610,1617,1618,1623,1623,1624,1626,1628,1629,1629,1630,1634,1637,1637,1637,1642,1645,1646,1646,1647,1647,1652,1657,1660,1662,1663,1666,1666,1667,1669,1670,1673,1675,1675,1677,1678,1678,1684,1686,1691,1691,1692,1694,1694,1697,1700,1700,1703,1704,1706,1706,1714,1715,1720,1720,1720,1720,1721,1721,1723,1725,1726,1728,1730,1730,1732,1733,1736,1739,1742,1744,1744,1752,1758,1759,1760,1764,1765,1766,1767,1769,1769,1773,1773,1773,1774,1775,1775,1775,1780,1783,1785,1785,1790,1791,1792,1793,1793,1795,1800,1803,1805,1807,1808,1811,1811,1811,1812,1812,1815,1816,1818,1819,1820,1821,1822,1823,1827,1828,1829,1830,1832,1835,1835,1835,1837,1839,1843,1843,1846,1849,1849,1849,1849,1851,1853,1853,1853,1854,1855,1861,1863,1865,1868,1870,1873,1878,1879,1881,1881,1881,1883,1883,1884,1885,1887,1889,1890,1891,1891,1894,1895,1896,1898,1899,1899,1901,1902,1904,1906,1907,1912,1912,1914,1914,1915,1917,1920,1921,1924,1926,1928,1930,1930,1931,1932,1933,1934,1934,1935,1936,1942,1943,1944,1947,1947,1948,1950,1951,1952,1953,1954,1956,1956,1957,1963,1964,1965,1966,1968,1968,1970,1971,1973,1979,1979,1981,1982,1986,1986,1986,1989,1992,1992,1998,1998,1999,1999,1999,2000]\n[1,1,2,4,7,10,10,11,17,24,26,26,27,28,32,33,33,35,35,35,37,37,37,38,40,41,45,48,50,50,53,53,54,55,55,55,56,57,63,66,68,71,76,79,81,81,82,83,85,88,89,91,95,96,100,102,103,104,104,105,107,107,108,109,109,112,116,118,118,118,119,119,120,121,123,124,124,127,128,128,128,130,132,134,134,140,141,141,143,143,144,147,148,150,150,152,153,155,156,157,164,166,166,167,167,168,176,178,184,185,190,191,191,192,193,194,197,199,201,201,204,207,207,211,211,216,225,225,228,229,233,234,235,237,237,237,238,239,239,244,247,248,248,251,251,254,258,259,259,261,263,266,268,269,269,269,269,271,281,282,285,285,286,287,292,293,295,295,295,296,300,300,302,305,305,305,309,310,310,310,311,318,319,319,320,320,321,321,322,328,329,332,333,334,335,336,336,339,339,339,341,341,345,346,346,347,348,348,349,349,349,350,351,351,355,356,361,363,363,364,366,366,367,368,368,371,371,373,377,380,381,381,382,384,384,387,387,389,394,395,399,400,402,406,406,407,407,410,415,418,419,424,427,433,434,436,437,442,444,445,451,455,455,456,457,459,461,462,463,464,464,465,465,465,467,468,469,473,476,476,476,480,482,483,486,488,489,490,493,495,495,496,496,497,499,499,500,502,504,505,509,509,511,511,516,516,517,521,523,525,526,528,528,530,534,534,535,538,538,541,541,544,544,544,544,546,547,550,550,551,553,555,556,556,557,558,558,559,561,563,567,569,569,570,571,571,572,574,574,575,575,578,582,583,583,584,584,586,590,592,592,594,595,596,598,598,598,601,603,603,604,612,617,618,620,620,624,626,627,628,631,635,637,637,638,641,645,650,651,652,653,654,657,659,659,661,661,661,661,662,663,663,664,664,665,666,669,670,670,671,675,676,683,684,688,689,689,689,690,691,692,694,695,695,696,697,697,700,705,705,707,708,708,709,709,710,710,712,714,716,716,716,718,721,722,722,723,724,725,728,728,729,730,735,735,737,737,741,741,744,747,748,749,750,751,751,754,754,755,757,757,759,759,761,763,763,763,764,766,767,771,771,777,778,778,778,781,782,782,786,786,786,787,787,787,790,790,790,791,792,792,793,801,803,804,805,805,805,805,807,808,808,808,810,815,817,819,819,822,829,829,830,832,832,834,834,836,836,836,837,842,843,844,846,846,847,847,847,850,851,852,853,853,854,854,855,855,858,860,863,864,866,866,867,871,875,881,883,883,886,888,888,890,891,892,894,897,903,913,914,915,918,918,919,920,920,922,923,925,927,927,927,927,928,937,943,943,943,946,948,949,950,953,954,958,966,968,968,971,979,980,981,983,984,985,985,987,987,990,991,992,992,992,997,999]\n[999,1000,1001,1001,1002,1005,1006,1008,1009,1011,1014,1014,1018,1019,1021,1026,1027,1031,1031,1032,1033,1034,1037,1038,1039,1041,1042,1043,1043,1043,1046,1049,1054,1055,1055,1058,1060,1064,1065,1065,1067,1067,1068,1074,1076,1076,1082,1082,1083,1084,1085,1086,1087,1094,1094,1095,1098,1101,1104,1104,1105,1105,1106,1106,1106,1107,1108,1112,1112,1113,1117,1118,1118,1119,1124,1124,1126,1126,1126,1130,1130,1132,1132,1133,1133,1134,1134,1136,1137,1139,1139,1139,1139,1139,1140,1141,1141,1141,1143,1144,1145,1147,1147,1150,1152,1153,1155,1157,1158,1159,1160,1161,1162,1163,1163,1165,1167,1167,1167,1167,1168,1168,1168,1168,1169,1171,1171,1172,1172,1173,1176,1177,1178,1178,1180,1181,1183,1184,1184,1185,1186,1186,1187,1188,1188,1189,1190,1191,1195,1196,1199,1200,1200,1201,1202,1206,1207,1208,1209,1211,1211,1212,1217,1221,1221,1222,1222,1224,1225,1226,1230,1230,1231,1232,1237,1237,1240,1243,1243,1243,1243,1243,1245,1245,1248,1248,1248,1249,1249,1253,1254,1255,1257,1258,1260,1265,1266,1268,1269,1270,1271,1271,1273,1274,1275,1277,1278,1279,1280,1281,1281,1283,1283,1284,1284,1286,1286,1287,1288,1288,1289,1290,1291,1292,1292,1295,1297,1298,1298,1299,1301,1302,1304,1306,1306,1307,1308,1310,1311,1312,1316,1316,1317,1318,1319,1320,1320,1321,1322,1324,1324,1324,1325,1327,1329,1330,1331,1331,1331,1332,1333,1333,1334,1336,1342,1345,1346,1347,1347,1349,1349,1350,1351,1352,1355,1355,1356,1357,1357,1362,1363,1364,1364,1364,1365,1370,1370,1372,1372,1374,1374,1375,1375,1376,1376,1378,1379,1379,1381,1382,1383,1384,1385,1386,1389,1391,1391,1391,1393,1394,1395,1397,1397,1401,1403,1405,1405,1406,1407,1407,1408,1409,1410,1413,1413,1416,1418,1418,1421,1422,1422,1424,1424,1425,1426,1428,1428,1429,1430,1434,1436,1439,1439,1439,1439,1440,1440,1441,1441,1442,1442,1442,1444,1445,1447,1447,1451,1451,1452,1456,1460,1462,1463,1468,1469,1469,1470,1470,1471,1472,1472,1474,1476,1478,1478,1482,1484,1486,1486,1488,1489,1489,1493,1494,1495,1495,1497,1498,1502,1503,1505,1506,1507,1507,1508,1511,1512,1513,1514,1515,1516,1518,1520,1520,1520,1522,1523,1525,1525,1527,1527,1528,1531,1531,1532,1533,1534,1535,1537,1538,1540,1540,1541,1543,1543,1544,1545,1546,1548,1549,1551,1551,1552,1552,1552,1553,1556,1556,1557,1557,1557,1559,1559,1560,1561,1561,1562,1564,1564,1564,1564,1566,1566,1567,1571,1571,1572,1573,1573,1574,1574,1577,1577,1583,1584,1584,1588,1589,1590,1593,1593,1595,1596,1596,1596,1597,1598,1601,1604,1604,1606,1606,1607,1607,1610,1610,1611,1611,1612,1612,1614,1615,1616,1617,1621,1622,1622,1622,1623,1626,1627,1631,1632,1636,1637,1637,1638,1640,1642,1642,1644,1645,1647,1648,1650,1651,1652,1653,1655,1655,1656,1656,1656,1656,1658,1658,1658,1660,1660,1663,1664,1665,1666,1667,1667,1667,1669,1669,1670,1676,1678,1680,1681,1681,1682,1684,1684,1685,1686,1686,1687,1689,1689,1689,1690,1693,1694,1698,1700,1702,1703,1706,1708,1708,1708,1710,1712,1712,1712,1713,1715,1715,1717,1719,1719,1720,1720,1721,1722,1722,1724,1731,1732,1734,1734,1737,1737,1741,1743,1743,1749,1749,1751,1753,1754,1754,1756,1757,1757,1758,1759,1761,1761,1762,1764,1766,1766,1767,1769,1769,1771,1772,1772,1775,1775,1775,1777,1779,1779,1781,1782,1782,1783,1786,1788,1788,1788,1790,1793,1793,1793,1793,1794,1795,1795,1796,1796,1796,1797,1799,1800,1803,1810,1811,1814,1814,1814,1816,1817,1819,1820,1820,1822,1824,1826,1826,1826,1827,1828,1828,1831,1832,1834,1835,1836,1837,1838,1838,1841,1843,1849,1851,1851,1852,1852,1853,1853,1854,1854,1856,1858,1859,1863,1863,1863,1869,1871,1872,1872,1873,1874,1879,1880,1881,1881,1882,1883,1883,1883,1885,1885,1885,1886,1887,1887,1889,1894,1898,1899,1901,1902,1903,1904,1907,1908,1910,1911,1911,1911,1913,1914,1914,1915,1916,1917,1918,1921,1922,1923,1923,1924,1926,1926,1933,1933,1934,1934,1934,1936,1938,1938,1939,1939,1941,1941,1942,1942,1947,1947,1947,1947,1949,1949,1952,1954,1955,1957,1958,1959,1960,1960,1963,1964,1964,1964,1966,1968,1971,1973,1975,1977,1978,1978,1979,1979,1980,1981,1981,1982,1984,1985,1985,1987,1987,1987,1987,1987,1988,1989,1990,1991,1994,1994,1995,1996,1997,1997,1998]\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this help](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e)s and makes thinks clear\\nand do clap \\uD83D\\uDC4F to appreciate the article"
                    },
                    {
                        "username": "pwho",
                        "content": "If you\\'re going to share an article here, don\\'t hide it behind a paywall. =\\\\"
                    },
                    {
                        "username": "user5979vk",
                        "content": "Thanks (https://archive.is/E2agn)"
                    },
                    {
                        "username": "4alisha",
                        "content": "very helpful\\uD83D\\uDC4F"
                    },
                    {
                        "username": "thecodingkid",
                        "content": "Any help would be appreciated if you could explain why the solution in the O(log(min(m,n))) case requires a swap if the second array is smaller.\\n\\nIf you could specify any edge case that is failing , that would be of great help."
                    },
                    {
                        "username": "bparanj",
                        "content": "Swapping nums1 and nums2 if nums1 is larger than nums2 is a trick to simplify the problem by reducing it to a condition where we always binary search on the smaller array. This doesn\\'t change the result because the median of two arrays doesn\\'t depend on which array is longer, but it makes the code cleaner and easier to understand, and it also improves performance by minimizing the search space.\\n\\nMoreover, this technique ensures that we do not run into an index out of bounds error during our binary search process. \\n\\nLet\\'s consider an edge case where the swapping would be important:\\n\\nnums1 = [6, 7, 8, 9, 10]\\nnums2 = [1, 2, 3]\\n\\nIf we did not swap, and started the binary search on nums1, we would end up exploring unnecessary parts of nums1 that wouldn\\'t impact the final result, since we know that the median must be within the range covered by nums2 due to its smaller size and range of values. \\n\\nIf we swap and binary search on nums2, we can find the median more efficiently because we focus on the smaller range of values. We then only need to compare with a few specific elements of nums1.\\n\\nTo summarize, the swap is used to ensure efficiency and simplicity by always performing binary search on the smaller array."
                    }
                ]
            },
            {
                "id": 1565516,
                "content": [
                    {
                        "username": "yon",
                        "content": "Input:\\t[1,1], [1,2]\\nExpected:\\t1.00000\\n\\nMy solution way is merge [1,1] and [1,2] to [1,2], so the answer would be (1+2)/2 = 1.5\\nWhat did I made wrong?"
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "you first merge it (preserving duplicates).\\n[1, 1, 1, 2]\\n\\nWhats the middle element here?\\noh wait. there are two elements at the middle. 1 and 1.\\nso you average em. \\n(1 + 1) / 2 = 1"
                    },
                    {
                        "username": "RISHIKA_GANDHI",
                        "content": "change your (1+2)/2 to this (1+2)/2.0 you will get you result into float/double type"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "the merged array will we [1,1,1,2] ,\\nno of elements are even so median will we (1+1)/2=1.\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the hell nooo. median is 1 here"
                    },
                    {
                        "username": "hankIgoe",
                        "content": "the merged string is [1,1,1,2], so the median is (1+1)/2 = 1.0\\n"
                    },
                    {
                        "username": "vyshnusanthosh",
                        "content": "If you are using java, when two integers are divided the answer will also be an integer in order to get floating point you need to type cast the integers to double or float before division."
                    },
                    {
                        "username": "megazortti",
                        "content": "i\\'m facing the same problem..\\n"
                    },
                    {
                        "username": "khushal1201",
                        "content": "[@zwicky](/zwicky) the merged array should be [1,1,1,2]. Hence the median would be (1+1)/2 = 1."
                    },
                    {
                        "username": "zwicky",
                        "content": "you shouldn\\'t remove duplicates"
                    },
                    {
                        "username": "hing_liu",
                        "content": "Let try to interate the algorithm first:\\n\\nIt is basically a k-th smallest element problem between two sorted arrays, let assume we have the following two arrays:\\n\\n5,7,8,11\\n4,9,12,14\\n\\nk = 4 (expected ans = 8 because when it is sorted: 4,5,7,**8**,9,11,12,14)\\n\\nStep 1: Cut the two arrays into two pieces such that the left side will have total items of 4 (i.e. the **K=4**)\\n5,7 | 8, 11\\n4,9 | 12, 14\\n\\nStep 2: We remove [5,7] because its end index at the left side is smaller (7. v.s 9) and we update K = 2 (since we removed 2 item=> K - 2 = 4 - 2 = 2), it will becomes:\\n8,11 <-- removed [5,7]\\n4,9,12,14\\n\\n(basically the rest of the steps below is to repeat 1 and 2 until K = 1)\\n\\nStep 3: Repeat Step 1, Cut into two half base on **K = 2**\\n8 | 11\\n4 | 9 12 14\\n\\nStep 4: Repeat Step 2, that is remove 4 and update **K = 1** (since we removed 1 item=>K-1 = 2-1 1)\\n\\nStep 5: Repeat Step 1, Cut into two half base on K = 1, since K = 1 is not able to split (we have two arrays, don\\'t know how to split), we conclude the solution as the minimum of the first item of the two array, that is min(8,9) = 8\\n8,11\\n9,12,14\\n\\nWe are all done, how about K = 3 initially? Basically the point of \\'cut\\' is K/2 - 1, therefore when K = 3, the cutting point is index=0, let us go though this again quickly for this:\\n\\nK=3\\n5|7,8,11\\n4|9,12,14\\n\\nK=2\\n5|7,8,11\\n9|12,14\\n\\nK=1\\n7|8,11\\n9|12,14 \\nAns=min(7,9) = 7\\n\\nThere is some edge case not tell here, this is just a general idea. We want to have the first K-th item, so, the first target is to collect the first K item from the two array, so we fairly cut them at K/2 - 1 and remove the smaller list until K = 1.\\n\\nThis might be still hard to understand, consider we are not greedy, we do it one by one (we don\\'t cut base on K, but always cut by two):\\n\\nK=4\\n5 | 7 8 11\\n4 | 9 12 14\\n\\nAt this point, we remove the smaller one and have:\\nK=3\\n5 | 7 8 11\\n9 | 12 14\\n\\nKeep doing this until K = 1\\nK=2\\n7 | 8 11\\n9 | 12 14\\n\\nK = 1\\n8 | 11\\n9 | 12 14\\n(at this point, all done)\\n\\nWe are now reaching the answer = 8 by doing this in one-by-one manner, the cutting point at this \\'slow-version\\' is always [0], and the faster version is doing the cutting point at [k/2 - 1], that still work because they are sorted, it is safe to jump further and remove the whole preceding items rather than doing this one-by-one manner.\\n\\nAgain, this might still be hard to convince yourself why the \\'faster-version\\' has no issue, just hope this can help you understand more.\\n\\nGoing back to tell why it is a k-th minimum issue, consider when we have ths int kth(arr1, arr2, k) function, we can put k to be the middle of sizeof(arr1) and sizeof(arr2), if it is even number of size we just get the adjacent (run kth function two times) so we can get the middle two and divide it by 2, so the answer ..."
                    },
                    {
                        "username": "rds8rds",
                        "content": "thanks properly understand the concept!"
                    },
                    {
                        "username": "parismania",
                        "content": "That\\'s quite a good explanation. Thank you!"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I tried to avoid this question for as long as possible"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally solved this by merging the two arrays. I always intended to do the proper solution - one day. Today is the day."
                    },
                    {
                        "username": "raviTejaY",
                        "content": "\\tvar findMedianSortedArrays = function(nums1, nums2) {\\n  \\tlet mid;\\n\\t  let res = [...nums1, ...nums2].sort((a,b) => a-b);\\n\\t mid = (res.length-1)/2;\\n\\t  if(res.length % 2 === 1){\\n\\t\\treturn res[mid].toFixed(5);\\n\\t  } else {\\n\\t\\tlet median = (res[Math.floor(mid)] + res[Math.ceil(mid)]) / 2;\\n\\t\\treturn median.toFixed(5)\\n\\t  }\\n\\t};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, you use .sort(), which does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "hongbin2",
                        "content": "My naive solution is just merge two array and find the median. Obvious we can do better. But I just have no idea about it."
                    },
                    {
                        "username": "aneesfathimasaifudeen",
                        "content": "Input\\n[1,2]\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000\\n\\nThis test case always fails for me in leetcode, whereas it works for me in my machine\\'s python compiler with the same code.\\n\\nCan anyone tell, what would be the problem here?"
                    },
                    {
                        "username": "evenn",
                        "content": "choose Python3 rather than Python to execute code"
                    },
                    {
                        "username": "kapilkapuriya",
                        "content": "[@jeetu16](/jeetu16)  use type cast when you perform   ** ans = a/2 **  so do like this  **  ans = double(a)/2 ** "
                    },
                    {
                        "username": "doubleshab",
                        "content": "[@jeetu16](/jeetu16) I had a similar problem using Python3. For me, the issue was that the math I was using to generate my index values was producing float values. By forcing them to integer types using the int() builtin, I was able to get around it."
                    },
                    {
                        "username": "python_is_cheat_code",
                        "content": "Facing the same issue. Have no idea what to do."
                    },
                    {
                        "username": "AtrijPaul",
                        "content": "If you are coding in Java then division of two integers will be integer only , after performing the division it get stored as double. So instead of dividing by 2 , divide by 2.0 , it will work."
                    },
                    {
                        "username": "jeetu16",
                        "content": "have you found the solution till now?\\ni faced the same problem"
                    },
                    {
                        "username": "scott40",
                        "content": "The question states: \"There are two sorted arrays nums1 and nums2 of size m and n respectively.\" This does not tell me whether the sort order is largest to smallest, or smallest to largest. It would even be possible for nums1 to be sorted largest to smallest while nums2 is sorted from smallest to largest. So I thought we would need to be able to handle such cases, making no assumptions as to the direction of the sorts. As a test case of opposite sort directions in the inputs I tried:\\n[10,8,3]\\n[5,9,17]\\n\\nBoth input lists sorted as required, but in opposite directions. The median here should be 8.5, but when I ran the test case it gave me an expected answer of 6.5. So I think leetcode is making an assumption about the sort directions of the inputs that should not be made, and it is not designed to properly handle this case. What are we allowed to assume about the input sort direction?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement does not explicitly mention the sort order. However, it is conventionally assumed that, unless stated otherwise, a \"sorted\" array or list is in non-decreasing order, meaning from smallest to largest. This assumption is consistent with most problems and discussions involving sorted data in computer science and mathematics.\\n\\nTherefore, in the context of this problem, you can assume that both input arrays are sorted in non-decreasing order. This assumption informs the approach to solving the problem. If the arrays were sorted in non-increasing order or if one array was sorted in increasing order while the other in decreasing order, a different approach might be necessary.\\n\\nHowever, if the problem were to handle arrays sorted in either direction, a pre-processing step could be added to sort the arrays in the desired order before proceeding with the rest of the algorithm. This would increase the time complexity, though, because sorting is generally an O(n log n) operation."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit before validating your solution against a few edge cases, e.g.\n```\n[-932210,-932056,-922328,-917451,-913929,-907514,-883337,-802571,-739964,-709048,-692863,-690427,-679691,-666576,-643630,-638229,-585992,-574362,-571309,-541584,-538138,-497470,-480909,-459608,-444410,-426022,-403497,-393857,-363379,-359219,-347291,-330378,-314805,-303621,-291243,-251965,-244657,-243891,-236303,-234099,-217309,-210326,-199139,-197450,-177317,-172519,-170556,-137069,-128436,-113727,-95170,-79317,-52534,-4681,40199,89215,107649,109238,124507,157189,162498,180216,200111,228032,251189,262426,319119,323615,344264,345305,373566,399588,411387,427092,427955,456725,461974,468467,474372,476390,562956,577916,580839,591862,616385,638656,650816,653650,672517,753495,769837,779299,801738,809541,836250,872512,917419,949439,959386,979587]\n[]\n[]\n[-999311,-995487,-993598,-993127,-989482,-973229,-926998,-898485,-851725,-850712,-836433,-795269,-784476,-764197,-763427,-756479,-755190,-753600,-717158,-677976,-668634,-640052,-597569,-589282,-520481,-515063,-499955,-479622,-477302,-473002,-403966,-400582,-388037,-363473,-344547,-324788,-320701,-314920,-296000,-290463,-276432,-273513,-244152,-215671,-192226,-184426,-128230,-122297,-75423,-58001,-8481,2993,27765,54297,64282,81674,93781,96008,152144,154165,166583,169777,181118,191164,216155,263473,271293,308484,360932,380484,405656,413389,432913,436707,461128,530274,555172,576238,595665,608718,624952,644037,684003,697121,727400,730624,751135,768207,784915,792103,809755,831583,832823,844259,886508,913559,941025,950966,975298]\n[-999567,-997502,-997320,-997131,-995209,-993605,-991650,-991613,-991417,-990564,-989776,-987550,-985870,-985386,-982368,-981518,-979842,-979718,-978628,-976620,-974345,-973518,-972291,-967402,-967265,-966730,-965785,-962771,-961174,-960505,-959719,-955802,-955134,-953099,-948117,-944790,-941695,-941693,-939131,-938510,-937577,-937038,-935074,-933558,-933056,-930614,-929544,-924799,-922049,-920262,-919703,-917939,-916145,-915636,-914995,-913579,-896888,-894679,-894651,-891943,-891618,-891260,-888315,-886543,-884101,-883513,-872873,-872826,-872120,-871050,-870232,-869805,-868351,-867330,-866646,-866243,-863978,-863009,-859149,-858906,-858758,-854975,-852689,-852164,-851427,-850218,-847970,-845912,-845486,-844687,-844411,-843956,-843353,-839477,-837499,-836703,-833607,-831373,-830358,-827611,-827276,-827145,-827057,-825816,-823331,-822868,-822693,-821423,-820561,-819808,-815340,-814889,-814639,-814554,-813263,-811601,-810742,-810567,-808592,-807943,-805362,-805085,-803725,-798929,-792149,-789206,-785856,-783704,-783011,-781163,-775292,-772930,-769271,-764889,-764165,-763180,-758264,-756607,-755921,-752956,-752637,-751864,-751318,-750878,-750246,-749003,-746825,-744464,-744367,-743637,-741289,-738903,-736545,-732164,-731981,-731878,-730164,-727779,-725497,-725433,-720206,-715719,-714089,-707566,-705091,-705008,-705000,-699566,-696000,-694414,-689552,-688092,-683083,-681058,-680084,-676059,-675854,-675730,-672990,-671402,-669298,-669292,-667660,-667250,-662853,-660122,-658209,-657793,-657002,-656472,-653603,-647017,-643156,-642765,-642520,-638572,-637837,-636344,-635145,-629818,-628344,-624890,-622582,-621602,-619124,-617701,-616391,-613542,-609069,-605811,-604133,-603960,-602075,-601936,-601600,-599041,-598358,-597574,-597092,-596147,-594696,-592955,-592300,-591877,-591829,-591201,-589912,-584118,-583933,-574753,-567021,-566697,-565332,-564305,-562776,-561152,-557378,-553247,-551405,-541292,-536736,-533881,-533615,-532784,-531029,-530553,-527184,-526662,-525823,-525625,-525093,-520969,-520545,-515036,-510919,-507746,-504592,-504032,-503595,-501437,-499214,-496301,-494795,-490284,-486646,-485513,-484383,-480751,-476832,-476559,-474296,-469572,-469152,-468659,-466347,-462419,-460567,-458882,-457050,-454911,-453624,-452324,-450481,-449509,-440836,-439940,-436508,-434347,-431863,-426890,-422954,-422337,-419891,-419812,-419313,-415360,-413516,-410195,-409526,-409454,-408360,-408054,-406101,-404269,-401590,-400963,-394836,-385314,-375836,-374995,-374048,-368693,-368131,-367859,-361397,-360458,-356055,-354270,-354227,-346946,-346223,-346099,-345855,-344808,-344247,-343806,-342087,-339682,-338497,-335912,-334945,-330597,-328200,-327450,-323098,-320641,-319061,-316787,-314312,-314133,-313427,-313020,-311735,-311556,-308652,-307950,-307902,-305049,-304780,-304200,-301782,-301539,-296853,-296489,-293520,-285339,-284857,-284262,-283709,-282070,-281202,-281164,-277190,-276021,-274641,-273757,-273728,-270394,-269087,-265427,-265272,-264115,-263447,-262116,-259606,-257673,-257419,-257235,-257127,-257053,-256900,-256146,-255547,-253986,-249576,-249079,-245481,-239011,-235597,-230997,-228005,-227497,-227250,-226380,-225431,-216611,-210008,-208956,-208838,-201921,-199428,-196686,-191696,-190547,-189199,-188847,-188753,-186418,-185773,-185206,-182706,-180515,-179348,-178474,-175203,-174731,-173012,-173012,-171115,-170095,-168308,-168128,-166905,-166742,-164733,-164448,-158590,-157720,-156014,-155429,-153638,-149375,-148870,-148098,-147945,-145512,-145183,-141591,-139964,-137213,-134488,-133486,-132424,-131215,-130615,-125187,-124332,-117324,-113085,-112523,-111751,-111383,-104409,-104344,-102517,-102161,-98185,-97846,-91902,-89723,-84742,-84067,-83948,-82603,-82579,-78160,-76854,-75430,-75344,-74962,-71408,-69102,-66641,-65642,-64757,-61211,-60329,-57886,-53220,-52898,-49270,-49124,-48080,-45815,-44789,-37626,-34882,-34859,-32485,-31102,-29729,-24983,-22453,-20259,-16334,-16193,-15026,-12533,-11486,-9861,-4017,-404,704,6117,7576,8139,8688,16526,17499,22574,25852,26549,29362,30492,33676,37645,40152,43767,44242,46314,47444,50651,52396,53898,59922,60919,63930,68755,69424,70153,71709,73909,75531,75770,77643,78793,81457,83544,85477,89943,91011,91041,91192,94363,94670,95048,96537,98525,98539,104346,107800,108042,109819,110121,115691,117048,118363,118924,120311,125092,127555,127995,128168,135729,138889,140152,140261,140971,145327,145731,145860,152322,155692,159510,161250,163594,164930,166753,167883,168915,172982,173783,174795,175457,179314,180491,180628,189221,190490,190611,193586,195760,199322,201329,202231,202971,205732,206448,209484,210079,213383,213627,214223,215757,218866,223260,224593,225505,228101,229883,232562,234221,235355,236464,236563,238608,240104,242362,242959,245209,246122,246173,249953,255505,258524,260918,261968,262033,262830,263342,263665,265410,265772,266591,268471,270067,274107,276862,277801,277848,278505,278931,279516,285322,286378,293299,294255,296317,296787,297292,300002,302027,302121,302296,304390,304403,306514,311250,311643,316657,317008,319056,320827,322849,324605,326098,326173,326315,326588,328330,329876,330948,331341,331948,332124,341297,341942,343708,344436,344659,350897,351495,351893,352596,353479,355046,356056,357088,357742,358398,360172,365218,372048,375602,376611,382420,386919,389469,391011,392771,396046,403823,404843,407192,409690,410139,411497,418925,419472,419584,420171,421967,425637,428244,428593,429601,430662,431024,432899,434667,438639,438690,438839,441713,443399,449585,454891,459572,461567,464223,464977,468031,468216,468980,469952,471601,473590,476517,477804,478040,479232,481442,482516,487561,489198,493596,494509,498310,500634,502180,503663,504932,507455,511419,515818,517896,518474,520182,520335,520403,520452,523949,524745,525015,526693,531560,536815,536885,536922,537002,537675,541832,543158,547884,548488,549711,559134,559481,559820,560772,560870,561935,563399,563985,568956,569744,570203,573437,574202,574696,578813,579430,588576,588747,590647,604861,606852,606861,607746,608154,609468,609523,611937,611965,612112,614230,619688,620348,621041,621873,622766,633850,636410,645785,647203,647468,648663,651250,653354,655650,655736,656313,656473,660352,665886,668634,668889,668947,670032,670182,670412,673826,686025,686683,691645,692054,692284,695765,697395,697829,702166,708541,709011,711141,712520,714573,716618,721072,721706,721848,721884,722339,722954,724012,724181,726931,729781,730450,732815,734038,734313,735874,736725,737913,738002,740812,743047,744545,745638,746517,747495,747721,754971,755927,760296,760368,768237,770512,771998,772642,773928,775652,776009,776528,778433,784050,788493,788662,790251,794398,797252,797470,798288,800465,801126,806618,807774,810900,812412,812864,815004,819410,819576,821429,822144,828766,831814,834893,834987,838359,839232,839741,845812,846318,851048,851400,852080,856264,859668,861457,862611,863385,867019,872146,872332,877196,879288,879573,883230,888081,889012,889628,889844,890313,891004,891633,897234,900619,901180,901991,904976,905449,905491,905566,906218,906325,911636,912008,912597,917627,919382,921003,924181,925430,925724,925947,929266,934039,935863,937145,938405,941714,945193,946019,948295,950933,951602,951856,952469,953824,954207,954485,954748,959150,960644,962815,963477,963549,963815,964638,965098,967348,967682,969084,971079,973452,974228,976702,976910,978359,981049,982811,982859,987419,993386,994771,995167,996051,998221]\n[-987944,-969636,-969382,-963918,-960334,-957471,-955419,-954534,-949617,-948164,-941370,-934887,-933385,-933024,-925395,-920598,-914952,-912930,-910713,-898551,-897943,-895093,-883721,-881114,-868961,-862108,-859224,-844995,-843122,-841350,-839681,-837319,-833916,-832929,-824567,-821404,-817679,-816414,-815142,-814794,-814428,-812717,-803053,-800629,-791874,-784923,-776546,-772543,-770170,-769595,-767768,-764581,-760610,-755916,-750060,-738122,-734792,-733242,-728895,-725665,-725507,-718134,-717075,-715534,-715202,-713373,-712097,-708739,-707414,-706871,-703365,-702017,-693735,-683042,-672054,-669261,-668919,-664791,-661728,-660926,-656147,-645420,-643702,-643193,-641435,-638420,-634551,-628772,-615960,-603372,-601747,-598111,-594931,-589739,-582816,-582756,-578800,-578594,-573174,-567081,-559766,-559620,-556681,-554084,-553002,-549693,-548262,-545226,-544969,-537261,-533737,-528123,-520081,-506744,-504736,-499021,-496520,-496470,-495274,-493267,-486175,-485863,-484654,-482183,-481473,-479689,-476360,-474984,-474568,-470604,-469841,-458033,-456643,-456026,-449361,-448407,-447725,-446572,-444202,-444122,-438385,-438174,-436049,-433511,-429215,-428895,-423500,-419598,-414944,-413779,-413601,-413134,-395813,-386542,-386081,-384022,-383217,-377664,-375237,-370842,-368652,-368619,-367534,-360286,-359315,-356864,-346574,-344238,-342362,-338322,-337904,-317031,-315369,-311471,-307529,-291585,-288367,-282217,-273392,-268202,-266384,-262947,-261304,-259484,-253107,-253097,-247496,-240183,-238502,-232673,-225567,-225273,-220556,-218540,-217405,-209508,-209191,-198492,-196102,-194657,-187900,-187654,-187409,-183298,-183195,-178895,-172948,-164463,-150912,-150447,-147157,-146039,-142859,-142513,-141007,-140514,-133632,-121672,-120655,-111524,-106570,-104308,-101032,-100077,-99330,-98302,-93625,-88734,-88072,-87928,-84357,-71659,-69515,-67676,-63282,-58552,-56529,-55822,-52857,-49183,-49096,-36632,-35822,-22044,-15543,-13193,-11327,-8347,-5921,367,2667,4951,5292,12503,13977,16698,20683,21104,29329,29383,32131,36676,38796,38939,39209,47231,48354,58584,63004,67608,68400,79071,80602,81795,86542,94114,101023,103400,104656,104880,111548,112896,115766,121077,122734,127019,127444,132932,138051,140440,154194,158884,165068,166138,166908,169497,170785,171990,179699,180030,188999,195927,197727,215034,218444,219489,222687,224521,235464,235727,241470,243528,246904,258231,259122,260441,263591,265308,267313,269450,272354,272547,274104,276239,278349,282844,283153,284414,285344,292275,301326,301817,303601,305996,308758,308841,318258,318758,326276,328210,328413,329591,330688,335804,336586,338827,350724,353017,355893,356488,358137,367458,369246,373776,375814,388619,389665,391494,398826,410285,414310,434616,436368,437657,441921,442891,443722,445197,448982,449981,452442,455491,458606,458789,459482,459977,460011,467293,480680,484432,486822,491840,495107,498402,498655,499730,501125,506371,507661,508352,508531,510705,517473,521451,521763,531020,535521,536548,538401,543120,545936,546904,551503,551845,552061,557919,565312,566269,568604,574239,574420,578570,579251,582167,587488,592161,594286,604994,619288,622829,629325,652728,657554,659113,659971,661630,664091,664280,667722,673155,674069,675252,680792,683874,685152,698652,701722,703282,708464,710121,710242,712200,718611,720934,732059,736885,739191,742494,750812,759987,772722,776392,782107,782131,783537,783996,785898,793147,799555,806418,807432,808677,831974,841540,844398,849513,849656,854080,855359,858674,865625,866262,870340,877863,886981,896266,898306,900880,903869,907452,914307,916336,916960,922084,923604,924431,926571,930085,935193,948240,948473,954648,957779,959463,960134,960965,975144,979240,997354,999899]\n[0,2,3,4,4,6,6,7,8,8,8,8,11,11,15,16,17,20,22,26,26,28,29,30,31,32,36,39,40,41,41,44,45,52,52,53,54,56,57,62,70,71,72,74,78,78,80,80,83,84,86,87,88,90,91,92,92,96,99,104,105,106,110,110,112,113,113,115,116,118,119,121,121,123,124,125,125,129,129,131,131,134,135,140,141,141,143,144,145,145,145,150,152,153,154,157,158,159,159,159,164,164,169,172,176,176,177,178,178,184,185,189,189,190,191,192,193,193,194,194,195,196,196,200,203,204,205,206,210,211,211,212,212,213,216,219,220,222,225,226,229,229,233,234,237,238,239,241,243,243,246,246,248,249,249,250,250,251,253,255,256,258,260,260,262,266,268,268,269,271,272,273,273,280,281,282,283,288,288,295,296,296,298,302,304,305,305,305,305,306,306,308,309,310,312,313,315,315,318,318,319,319,321,322,323,324,324,326,329,329,329,331,331,333,333,334,334,336,339,339,340,341,341,343,344,348,351,351,352,353,354,354,358,359,363,364,364,365,367,367,368,369,370,372,372,373,376,376,378,379,379,381,382,383,385,386,391,391,391,394,396,399,400,411,414,414,414,416,423,429,429,430,430,431,435,436,437,438,442,443,444,447,448,452,452,452,452,452,455,456,457,457,462,466,468,468,468,472,472,472,472,473,473,475,476,476,477,477,480,481,481,482,483,483,484,485,485,486,486,491,491,491,491,492,494,495,497,497,500,502,503,505,505,509,510,514,515,515,515,516,516,518,519,519,520,522,524,525,527,528,529,531,534,537,537,540,543,543,544,544,545,549,552,552,556,558,558,565,565,566,569,570,571,572,575,577,577,578,579,579,581,583,584,586,586,590,591,593,597,603,603,605,607,608,611,613,614,622,622,622,623,631,631,633,635,638,638,639,642,643,644,645,646,649,652,653,653,654,655,655,655,655,657,659,660,661,664,665,666,667,671,682,684,685,686,688,691,692,694,694,696,698,699,702,704,704,704,706,706,709,710,713,713,714,717,723,725,726,727,727,729,730,730,732,732,733,734,738,740,740,741,746,750,751,751,755,755,758,759,759,760,764,765,767,769,771,773,774,775,776,779,779,781,782,785,797,797,798,798,798,802,803,804,804,806,807,808,809,809,810,810,812,814,814,818,819,820,822,822,823,824,826,826,826,827,830,831,833,833,833,834,837,838,838,839,840,840,841,844,844,847,848,851,852,853,854,857,860,862,864,868,868,869,870,872,874,880,881,881,883,884,885,888,889,892,892,896,897,897,898,899,901,904,905,907,908,914,914,915,915,916,918,920,921,921,921,927,927,928,928,929,932,932,932,932,933,937,937,938,939,940,941,941,942,942,942,944,945,945,946,947,948,952,952,955,956,960,962,964,964,966,968,968,968,971,973,973,973,974,978,979,979,981,982,983,985,985,989,990,990,990,993,994,994,995,998,999,999,1000]\n[999,999,1002,1003,1003,1004,1007,1010,1016,1016,1016,1020,1020,1022,1022,1024,1024,1027,1035,1038,1038,1041,1043,1044,1054,1055,1060,1064,1066,1067,1069,1070,1070,1071,1074,1074,1075,1081,1081,1087,1090,1092,1092,1094,1095,1095,1096,1097,1097,1098,1099,1103,1103,1103,1104,1104,1104,1105,1105,1108,1109,1109,1112,1112,1113,1116,1117,1117,1117,1117,1119,1121,1122,1124,1124,1125,1129,1129,1130,1131,1133,1133,1133,1135,1139,1140,1142,1142,1143,1144,1145,1146,1146,1148,1149,1151,1151,1151,1151,1152,1153,1153,1158,1159,1161,1164,1167,1171,1172,1173,1174,1176,1178,1178,1179,1180,1181,1182,1182,1183,1183,1185,1185,1186,1188,1189,1191,1192,1195,1200,1201,1201,1203,1204,1206,1207,1208,1208,1209,1210,1212,1212,1215,1216,1217,1222,1224,1225,1226,1226,1229,1230,1232,1232,1239,1241,1241,1243,1243,1244,1249,1252,1255,1256,1257,1263,1266,1266,1266,1270,1272,1274,1274,1280,1281,1288,1288,1288,1291,1291,1292,1296,1299,1301,1304,1304,1305,1306,1307,1310,1311,1311,1311,1312,1313,1313,1315,1315,1315,1319,1320,1321,1321,1321,1324,1324,1326,1327,1328,1330,1335,1348,1350,1351,1353,1355,1357,1357,1361,1365,1367,1368,1372,1374,1377,1383,1385,1388,1390,1390,1393,1393,1397,1398,1398,1398,1401,1402,1404,1405,1406,1407,1410,1410,1412,1412,1413,1414,1416,1416,1416,1416,1417,1418,1419,1423,1423,1428,1430,1432,1432,1433,1435,1436,1437,1438,1441,1441,1444,1444,1445,1449,1449,1449,1453,1457,1464,1466,1467,1469,1472,1475,1475,1478,1480,1485,1488,1488,1488,1489,1491,1493,1499,1500,1500,1500,1504,1505,1507,1508,1509,1510,1512,1512,1516,1519,1522,1528,1530,1532,1532,1538,1540,1540,1543,1545,1546,1548,1551,1553,1554,1555,1555,1561,1562,1563,1564,1565,1565,1569,1570,1570,1571,1572,1572,1577,1580,1580,1589,1589,1596,1599,1600,1600,1600,1600,1601,1602,1603,1607,1609,1610,1617,1618,1623,1623,1624,1626,1628,1629,1629,1630,1634,1637,1637,1637,1642,1645,1646,1646,1647,1647,1652,1657,1660,1662,1663,1666,1666,1667,1669,1670,1673,1675,1675,1677,1678,1678,1684,1686,1691,1691,1692,1694,1694,1697,1700,1700,1703,1704,1706,1706,1714,1715,1720,1720,1720,1720,1721,1721,1723,1725,1726,1728,1730,1730,1732,1733,1736,1739,1742,1744,1744,1752,1758,1759,1760,1764,1765,1766,1767,1769,1769,1773,1773,1773,1774,1775,1775,1775,1780,1783,1785,1785,1790,1791,1792,1793,1793,1795,1800,1803,1805,1807,1808,1811,1811,1811,1812,1812,1815,1816,1818,1819,1820,1821,1822,1823,1827,1828,1829,1830,1832,1835,1835,1835,1837,1839,1843,1843,1846,1849,1849,1849,1849,1851,1853,1853,1853,1854,1855,1861,1863,1865,1868,1870,1873,1878,1879,1881,1881,1881,1883,1883,1884,1885,1887,1889,1890,1891,1891,1894,1895,1896,1898,1899,1899,1901,1902,1904,1906,1907,1912,1912,1914,1914,1915,1917,1920,1921,1924,1926,1928,1930,1930,1931,1932,1933,1934,1934,1935,1936,1942,1943,1944,1947,1947,1948,1950,1951,1952,1953,1954,1956,1956,1957,1963,1964,1965,1966,1968,1968,1970,1971,1973,1979,1979,1981,1982,1986,1986,1986,1989,1992,1992,1998,1998,1999,1999,1999,2000]\n[1,1,2,4,7,10,10,11,17,24,26,26,27,28,32,33,33,35,35,35,37,37,37,38,40,41,45,48,50,50,53,53,54,55,55,55,56,57,63,66,68,71,76,79,81,81,82,83,85,88,89,91,95,96,100,102,103,104,104,105,107,107,108,109,109,112,116,118,118,118,119,119,120,121,123,124,124,127,128,128,128,130,132,134,134,140,141,141,143,143,144,147,148,150,150,152,153,155,156,157,164,166,166,167,167,168,176,178,184,185,190,191,191,192,193,194,197,199,201,201,204,207,207,211,211,216,225,225,228,229,233,234,235,237,237,237,238,239,239,244,247,248,248,251,251,254,258,259,259,261,263,266,268,269,269,269,269,271,281,282,285,285,286,287,292,293,295,295,295,296,300,300,302,305,305,305,309,310,310,310,311,318,319,319,320,320,321,321,322,328,329,332,333,334,335,336,336,339,339,339,341,341,345,346,346,347,348,348,349,349,349,350,351,351,355,356,361,363,363,364,366,366,367,368,368,371,371,373,377,380,381,381,382,384,384,387,387,389,394,395,399,400,402,406,406,407,407,410,415,418,419,424,427,433,434,436,437,442,444,445,451,455,455,456,457,459,461,462,463,464,464,465,465,465,467,468,469,473,476,476,476,480,482,483,486,488,489,490,493,495,495,496,496,497,499,499,500,502,504,505,509,509,511,511,516,516,517,521,523,525,526,528,528,530,534,534,535,538,538,541,541,544,544,544,544,546,547,550,550,551,553,555,556,556,557,558,558,559,561,563,567,569,569,570,571,571,572,574,574,575,575,578,582,583,583,584,584,586,590,592,592,594,595,596,598,598,598,601,603,603,604,612,617,618,620,620,624,626,627,628,631,635,637,637,638,641,645,650,651,652,653,654,657,659,659,661,661,661,661,662,663,663,664,664,665,666,669,670,670,671,675,676,683,684,688,689,689,689,690,691,692,694,695,695,696,697,697,700,705,705,707,708,708,709,709,710,710,712,714,716,716,716,718,721,722,722,723,724,725,728,728,729,730,735,735,737,737,741,741,744,747,748,749,750,751,751,754,754,755,757,757,759,759,761,763,763,763,764,766,767,771,771,777,778,778,778,781,782,782,786,786,786,787,787,787,790,790,790,791,792,792,793,801,803,804,805,805,805,805,807,808,808,808,810,815,817,819,819,822,829,829,830,832,832,834,834,836,836,836,837,842,843,844,846,846,847,847,847,850,851,852,853,853,854,854,855,855,858,860,863,864,866,866,867,871,875,881,883,883,886,888,888,890,891,892,894,897,903,913,914,915,918,918,919,920,920,922,923,925,927,927,927,927,928,937,943,943,943,946,948,949,950,953,954,958,966,968,968,971,979,980,981,983,984,985,985,987,987,990,991,992,992,992,997,999]\n[999,1000,1001,1001,1002,1005,1006,1008,1009,1011,1014,1014,1018,1019,1021,1026,1027,1031,1031,1032,1033,1034,1037,1038,1039,1041,1042,1043,1043,1043,1046,1049,1054,1055,1055,1058,1060,1064,1065,1065,1067,1067,1068,1074,1076,1076,1082,1082,1083,1084,1085,1086,1087,1094,1094,1095,1098,1101,1104,1104,1105,1105,1106,1106,1106,1107,1108,1112,1112,1113,1117,1118,1118,1119,1124,1124,1126,1126,1126,1130,1130,1132,1132,1133,1133,1134,1134,1136,1137,1139,1139,1139,1139,1139,1140,1141,1141,1141,1143,1144,1145,1147,1147,1150,1152,1153,1155,1157,1158,1159,1160,1161,1162,1163,1163,1165,1167,1167,1167,1167,1168,1168,1168,1168,1169,1171,1171,1172,1172,1173,1176,1177,1178,1178,1180,1181,1183,1184,1184,1185,1186,1186,1187,1188,1188,1189,1190,1191,1195,1196,1199,1200,1200,1201,1202,1206,1207,1208,1209,1211,1211,1212,1217,1221,1221,1222,1222,1224,1225,1226,1230,1230,1231,1232,1237,1237,1240,1243,1243,1243,1243,1243,1245,1245,1248,1248,1248,1249,1249,1253,1254,1255,1257,1258,1260,1265,1266,1268,1269,1270,1271,1271,1273,1274,1275,1277,1278,1279,1280,1281,1281,1283,1283,1284,1284,1286,1286,1287,1288,1288,1289,1290,1291,1292,1292,1295,1297,1298,1298,1299,1301,1302,1304,1306,1306,1307,1308,1310,1311,1312,1316,1316,1317,1318,1319,1320,1320,1321,1322,1324,1324,1324,1325,1327,1329,1330,1331,1331,1331,1332,1333,1333,1334,1336,1342,1345,1346,1347,1347,1349,1349,1350,1351,1352,1355,1355,1356,1357,1357,1362,1363,1364,1364,1364,1365,1370,1370,1372,1372,1374,1374,1375,1375,1376,1376,1378,1379,1379,1381,1382,1383,1384,1385,1386,1389,1391,1391,1391,1393,1394,1395,1397,1397,1401,1403,1405,1405,1406,1407,1407,1408,1409,1410,1413,1413,1416,1418,1418,1421,1422,1422,1424,1424,1425,1426,1428,1428,1429,1430,1434,1436,1439,1439,1439,1439,1440,1440,1441,1441,1442,1442,1442,1444,1445,1447,1447,1451,1451,1452,1456,1460,1462,1463,1468,1469,1469,1470,1470,1471,1472,1472,1474,1476,1478,1478,1482,1484,1486,1486,1488,1489,1489,1493,1494,1495,1495,1497,1498,1502,1503,1505,1506,1507,1507,1508,1511,1512,1513,1514,1515,1516,1518,1520,1520,1520,1522,1523,1525,1525,1527,1527,1528,1531,1531,1532,1533,1534,1535,1537,1538,1540,1540,1541,1543,1543,1544,1545,1546,1548,1549,1551,1551,1552,1552,1552,1553,1556,1556,1557,1557,1557,1559,1559,1560,1561,1561,1562,1564,1564,1564,1564,1566,1566,1567,1571,1571,1572,1573,1573,1574,1574,1577,1577,1583,1584,1584,1588,1589,1590,1593,1593,1595,1596,1596,1596,1597,1598,1601,1604,1604,1606,1606,1607,1607,1610,1610,1611,1611,1612,1612,1614,1615,1616,1617,1621,1622,1622,1622,1623,1626,1627,1631,1632,1636,1637,1637,1638,1640,1642,1642,1644,1645,1647,1648,1650,1651,1652,1653,1655,1655,1656,1656,1656,1656,1658,1658,1658,1660,1660,1663,1664,1665,1666,1667,1667,1667,1669,1669,1670,1676,1678,1680,1681,1681,1682,1684,1684,1685,1686,1686,1687,1689,1689,1689,1690,1693,1694,1698,1700,1702,1703,1706,1708,1708,1708,1710,1712,1712,1712,1713,1715,1715,1717,1719,1719,1720,1720,1721,1722,1722,1724,1731,1732,1734,1734,1737,1737,1741,1743,1743,1749,1749,1751,1753,1754,1754,1756,1757,1757,1758,1759,1761,1761,1762,1764,1766,1766,1767,1769,1769,1771,1772,1772,1775,1775,1775,1777,1779,1779,1781,1782,1782,1783,1786,1788,1788,1788,1790,1793,1793,1793,1793,1794,1795,1795,1796,1796,1796,1797,1799,1800,1803,1810,1811,1814,1814,1814,1816,1817,1819,1820,1820,1822,1824,1826,1826,1826,1827,1828,1828,1831,1832,1834,1835,1836,1837,1838,1838,1841,1843,1849,1851,1851,1852,1852,1853,1853,1854,1854,1856,1858,1859,1863,1863,1863,1869,1871,1872,1872,1873,1874,1879,1880,1881,1881,1882,1883,1883,1883,1885,1885,1885,1886,1887,1887,1889,1894,1898,1899,1901,1902,1903,1904,1907,1908,1910,1911,1911,1911,1913,1914,1914,1915,1916,1917,1918,1921,1922,1923,1923,1924,1926,1926,1933,1933,1934,1934,1934,1936,1938,1938,1939,1939,1941,1941,1942,1942,1947,1947,1947,1947,1949,1949,1952,1954,1955,1957,1958,1959,1960,1960,1963,1964,1964,1964,1966,1968,1971,1973,1975,1977,1978,1978,1979,1979,1980,1981,1981,1982,1984,1985,1985,1987,1987,1987,1987,1987,1988,1989,1990,1991,1994,1994,1995,1996,1997,1997,1998]\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this help](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e)s and makes thinks clear\\nand do clap \\uD83D\\uDC4F to appreciate the article"
                    },
                    {
                        "username": "pwho",
                        "content": "If you\\'re going to share an article here, don\\'t hide it behind a paywall. =\\\\"
                    },
                    {
                        "username": "user5979vk",
                        "content": "Thanks (https://archive.is/E2agn)"
                    },
                    {
                        "username": "4alisha",
                        "content": "very helpful\\uD83D\\uDC4F"
                    },
                    {
                        "username": "thecodingkid",
                        "content": "Any help would be appreciated if you could explain why the solution in the O(log(min(m,n))) case requires a swap if the second array is smaller.\\n\\nIf you could specify any edge case that is failing , that would be of great help."
                    },
                    {
                        "username": "bparanj",
                        "content": "Swapping nums1 and nums2 if nums1 is larger than nums2 is a trick to simplify the problem by reducing it to a condition where we always binary search on the smaller array. This doesn\\'t change the result because the median of two arrays doesn\\'t depend on which array is longer, but it makes the code cleaner and easier to understand, and it also improves performance by minimizing the search space.\\n\\nMoreover, this technique ensures that we do not run into an index out of bounds error during our binary search process. \\n\\nLet\\'s consider an edge case where the swapping would be important:\\n\\nnums1 = [6, 7, 8, 9, 10]\\nnums2 = [1, 2, 3]\\n\\nIf we did not swap, and started the binary search on nums1, we would end up exploring unnecessary parts of nums1 that wouldn\\'t impact the final result, since we know that the median must be within the range covered by nums2 due to its smaller size and range of values. \\n\\nIf we swap and binary search on nums2, we can find the median more efficiently because we focus on the smaller range of values. We then only need to compare with a few specific elements of nums1.\\n\\nTo summarize, the swap is used to ensure efficiency and simplicity by always performing binary search on the smaller array."
                    }
                ]
            },
            {
                "id": 1568453,
                "content": [
                    {
                        "username": "yon",
                        "content": "Input:\\t[1,1], [1,2]\\nExpected:\\t1.00000\\n\\nMy solution way is merge [1,1] and [1,2] to [1,2], so the answer would be (1+2)/2 = 1.5\\nWhat did I made wrong?"
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "you first merge it (preserving duplicates).\\n[1, 1, 1, 2]\\n\\nWhats the middle element here?\\noh wait. there are two elements at the middle. 1 and 1.\\nso you average em. \\n(1 + 1) / 2 = 1"
                    },
                    {
                        "username": "RISHIKA_GANDHI",
                        "content": "change your (1+2)/2 to this (1+2)/2.0 you will get you result into float/double type"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "the merged array will we [1,1,1,2] ,\\nno of elements are even so median will we (1+1)/2=1.\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the hell nooo. median is 1 here"
                    },
                    {
                        "username": "hankIgoe",
                        "content": "the merged string is [1,1,1,2], so the median is (1+1)/2 = 1.0\\n"
                    },
                    {
                        "username": "vyshnusanthosh",
                        "content": "If you are using java, when two integers are divided the answer will also be an integer in order to get floating point you need to type cast the integers to double or float before division."
                    },
                    {
                        "username": "megazortti",
                        "content": "i\\'m facing the same problem..\\n"
                    },
                    {
                        "username": "khushal1201",
                        "content": "[@zwicky](/zwicky) the merged array should be [1,1,1,2]. Hence the median would be (1+1)/2 = 1."
                    },
                    {
                        "username": "zwicky",
                        "content": "you shouldn\\'t remove duplicates"
                    },
                    {
                        "username": "hing_liu",
                        "content": "Let try to interate the algorithm first:\\n\\nIt is basically a k-th smallest element problem between two sorted arrays, let assume we have the following two arrays:\\n\\n5,7,8,11\\n4,9,12,14\\n\\nk = 4 (expected ans = 8 because when it is sorted: 4,5,7,**8**,9,11,12,14)\\n\\nStep 1: Cut the two arrays into two pieces such that the left side will have total items of 4 (i.e. the **K=4**)\\n5,7 | 8, 11\\n4,9 | 12, 14\\n\\nStep 2: We remove [5,7] because its end index at the left side is smaller (7. v.s 9) and we update K = 2 (since we removed 2 item=> K - 2 = 4 - 2 = 2), it will becomes:\\n8,11 <-- removed [5,7]\\n4,9,12,14\\n\\n(basically the rest of the steps below is to repeat 1 and 2 until K = 1)\\n\\nStep 3: Repeat Step 1, Cut into two half base on **K = 2**\\n8 | 11\\n4 | 9 12 14\\n\\nStep 4: Repeat Step 2, that is remove 4 and update **K = 1** (since we removed 1 item=>K-1 = 2-1 1)\\n\\nStep 5: Repeat Step 1, Cut into two half base on K = 1, since K = 1 is not able to split (we have two arrays, don\\'t know how to split), we conclude the solution as the minimum of the first item of the two array, that is min(8,9) = 8\\n8,11\\n9,12,14\\n\\nWe are all done, how about K = 3 initially? Basically the point of \\'cut\\' is K/2 - 1, therefore when K = 3, the cutting point is index=0, let us go though this again quickly for this:\\n\\nK=3\\n5|7,8,11\\n4|9,12,14\\n\\nK=2\\n5|7,8,11\\n9|12,14\\n\\nK=1\\n7|8,11\\n9|12,14 \\nAns=min(7,9) = 7\\n\\nThere is some edge case not tell here, this is just a general idea. We want to have the first K-th item, so, the first target is to collect the first K item from the two array, so we fairly cut them at K/2 - 1 and remove the smaller list until K = 1.\\n\\nThis might be still hard to understand, consider we are not greedy, we do it one by one (we don\\'t cut base on K, but always cut by two):\\n\\nK=4\\n5 | 7 8 11\\n4 | 9 12 14\\n\\nAt this point, we remove the smaller one and have:\\nK=3\\n5 | 7 8 11\\n9 | 12 14\\n\\nKeep doing this until K = 1\\nK=2\\n7 | 8 11\\n9 | 12 14\\n\\nK = 1\\n8 | 11\\n9 | 12 14\\n(at this point, all done)\\n\\nWe are now reaching the answer = 8 by doing this in one-by-one manner, the cutting point at this \\'slow-version\\' is always [0], and the faster version is doing the cutting point at [k/2 - 1], that still work because they are sorted, it is safe to jump further and remove the whole preceding items rather than doing this one-by-one manner.\\n\\nAgain, this might still be hard to convince yourself why the \\'faster-version\\' has no issue, just hope this can help you understand more.\\n\\nGoing back to tell why it is a k-th minimum issue, consider when we have ths int kth(arr1, arr2, k) function, we can put k to be the middle of sizeof(arr1) and sizeof(arr2), if it is even number of size we just get the adjacent (run kth function two times) so we can get the middle two and divide it by 2, so the answer ..."
                    },
                    {
                        "username": "rds8rds",
                        "content": "thanks properly understand the concept!"
                    },
                    {
                        "username": "parismania",
                        "content": "That\\'s quite a good explanation. Thank you!"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I tried to avoid this question for as long as possible"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally solved this by merging the two arrays. I always intended to do the proper solution - one day. Today is the day."
                    },
                    {
                        "username": "raviTejaY",
                        "content": "\\tvar findMedianSortedArrays = function(nums1, nums2) {\\n  \\tlet mid;\\n\\t  let res = [...nums1, ...nums2].sort((a,b) => a-b);\\n\\t mid = (res.length-1)/2;\\n\\t  if(res.length % 2 === 1){\\n\\t\\treturn res[mid].toFixed(5);\\n\\t  } else {\\n\\t\\tlet median = (res[Math.floor(mid)] + res[Math.ceil(mid)]) / 2;\\n\\t\\treturn median.toFixed(5)\\n\\t  }\\n\\t};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, you use .sort(), which does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "hongbin2",
                        "content": "My naive solution is just merge two array and find the median. Obvious we can do better. But I just have no idea about it."
                    },
                    {
                        "username": "aneesfathimasaifudeen",
                        "content": "Input\\n[1,2]\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000\\n\\nThis test case always fails for me in leetcode, whereas it works for me in my machine\\'s python compiler with the same code.\\n\\nCan anyone tell, what would be the problem here?"
                    },
                    {
                        "username": "evenn",
                        "content": "choose Python3 rather than Python to execute code"
                    },
                    {
                        "username": "kapilkapuriya",
                        "content": "[@jeetu16](/jeetu16)  use type cast when you perform   ** ans = a/2 **  so do like this  **  ans = double(a)/2 ** "
                    },
                    {
                        "username": "doubleshab",
                        "content": "[@jeetu16](/jeetu16) I had a similar problem using Python3. For me, the issue was that the math I was using to generate my index values was producing float values. By forcing them to integer types using the int() builtin, I was able to get around it."
                    },
                    {
                        "username": "python_is_cheat_code",
                        "content": "Facing the same issue. Have no idea what to do."
                    },
                    {
                        "username": "AtrijPaul",
                        "content": "If you are coding in Java then division of two integers will be integer only , after performing the division it get stored as double. So instead of dividing by 2 , divide by 2.0 , it will work."
                    },
                    {
                        "username": "jeetu16",
                        "content": "have you found the solution till now?\\ni faced the same problem"
                    },
                    {
                        "username": "scott40",
                        "content": "The question states: \"There are two sorted arrays nums1 and nums2 of size m and n respectively.\" This does not tell me whether the sort order is largest to smallest, or smallest to largest. It would even be possible for nums1 to be sorted largest to smallest while nums2 is sorted from smallest to largest. So I thought we would need to be able to handle such cases, making no assumptions as to the direction of the sorts. As a test case of opposite sort directions in the inputs I tried:\\n[10,8,3]\\n[5,9,17]\\n\\nBoth input lists sorted as required, but in opposite directions. The median here should be 8.5, but when I ran the test case it gave me an expected answer of 6.5. So I think leetcode is making an assumption about the sort directions of the inputs that should not be made, and it is not designed to properly handle this case. What are we allowed to assume about the input sort direction?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement does not explicitly mention the sort order. However, it is conventionally assumed that, unless stated otherwise, a \"sorted\" array or list is in non-decreasing order, meaning from smallest to largest. This assumption is consistent with most problems and discussions involving sorted data in computer science and mathematics.\\n\\nTherefore, in the context of this problem, you can assume that both input arrays are sorted in non-decreasing order. This assumption informs the approach to solving the problem. If the arrays were sorted in non-increasing order or if one array was sorted in increasing order while the other in decreasing order, a different approach might be necessary.\\n\\nHowever, if the problem were to handle arrays sorted in either direction, a pre-processing step could be added to sort the arrays in the desired order before proceeding with the rest of the algorithm. This would increase the time complexity, though, because sorting is generally an O(n log n) operation."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit before validating your solution against a few edge cases, e.g.\n```\n[-932210,-932056,-922328,-917451,-913929,-907514,-883337,-802571,-739964,-709048,-692863,-690427,-679691,-666576,-643630,-638229,-585992,-574362,-571309,-541584,-538138,-497470,-480909,-459608,-444410,-426022,-403497,-393857,-363379,-359219,-347291,-330378,-314805,-303621,-291243,-251965,-244657,-243891,-236303,-234099,-217309,-210326,-199139,-197450,-177317,-172519,-170556,-137069,-128436,-113727,-95170,-79317,-52534,-4681,40199,89215,107649,109238,124507,157189,162498,180216,200111,228032,251189,262426,319119,323615,344264,345305,373566,399588,411387,427092,427955,456725,461974,468467,474372,476390,562956,577916,580839,591862,616385,638656,650816,653650,672517,753495,769837,779299,801738,809541,836250,872512,917419,949439,959386,979587]\n[]\n[]\n[-999311,-995487,-993598,-993127,-989482,-973229,-926998,-898485,-851725,-850712,-836433,-795269,-784476,-764197,-763427,-756479,-755190,-753600,-717158,-677976,-668634,-640052,-597569,-589282,-520481,-515063,-499955,-479622,-477302,-473002,-403966,-400582,-388037,-363473,-344547,-324788,-320701,-314920,-296000,-290463,-276432,-273513,-244152,-215671,-192226,-184426,-128230,-122297,-75423,-58001,-8481,2993,27765,54297,64282,81674,93781,96008,152144,154165,166583,169777,181118,191164,216155,263473,271293,308484,360932,380484,405656,413389,432913,436707,461128,530274,555172,576238,595665,608718,624952,644037,684003,697121,727400,730624,751135,768207,784915,792103,809755,831583,832823,844259,886508,913559,941025,950966,975298]\n[-999567,-997502,-997320,-997131,-995209,-993605,-991650,-991613,-991417,-990564,-989776,-987550,-985870,-985386,-982368,-981518,-979842,-979718,-978628,-976620,-974345,-973518,-972291,-967402,-967265,-966730,-965785,-962771,-961174,-960505,-959719,-955802,-955134,-953099,-948117,-944790,-941695,-941693,-939131,-938510,-937577,-937038,-935074,-933558,-933056,-930614,-929544,-924799,-922049,-920262,-919703,-917939,-916145,-915636,-914995,-913579,-896888,-894679,-894651,-891943,-891618,-891260,-888315,-886543,-884101,-883513,-872873,-872826,-872120,-871050,-870232,-869805,-868351,-867330,-866646,-866243,-863978,-863009,-859149,-858906,-858758,-854975,-852689,-852164,-851427,-850218,-847970,-845912,-845486,-844687,-844411,-843956,-843353,-839477,-837499,-836703,-833607,-831373,-830358,-827611,-827276,-827145,-827057,-825816,-823331,-822868,-822693,-821423,-820561,-819808,-815340,-814889,-814639,-814554,-813263,-811601,-810742,-810567,-808592,-807943,-805362,-805085,-803725,-798929,-792149,-789206,-785856,-783704,-783011,-781163,-775292,-772930,-769271,-764889,-764165,-763180,-758264,-756607,-755921,-752956,-752637,-751864,-751318,-750878,-750246,-749003,-746825,-744464,-744367,-743637,-741289,-738903,-736545,-732164,-731981,-731878,-730164,-727779,-725497,-725433,-720206,-715719,-714089,-707566,-705091,-705008,-705000,-699566,-696000,-694414,-689552,-688092,-683083,-681058,-680084,-676059,-675854,-675730,-672990,-671402,-669298,-669292,-667660,-667250,-662853,-660122,-658209,-657793,-657002,-656472,-653603,-647017,-643156,-642765,-642520,-638572,-637837,-636344,-635145,-629818,-628344,-624890,-622582,-621602,-619124,-617701,-616391,-613542,-609069,-605811,-604133,-603960,-602075,-601936,-601600,-599041,-598358,-597574,-597092,-596147,-594696,-592955,-592300,-591877,-591829,-591201,-589912,-584118,-583933,-574753,-567021,-566697,-565332,-564305,-562776,-561152,-557378,-553247,-551405,-541292,-536736,-533881,-533615,-532784,-531029,-530553,-527184,-526662,-525823,-525625,-525093,-520969,-520545,-515036,-510919,-507746,-504592,-504032,-503595,-501437,-499214,-496301,-494795,-490284,-486646,-485513,-484383,-480751,-476832,-476559,-474296,-469572,-469152,-468659,-466347,-462419,-460567,-458882,-457050,-454911,-453624,-452324,-450481,-449509,-440836,-439940,-436508,-434347,-431863,-426890,-422954,-422337,-419891,-419812,-419313,-415360,-413516,-410195,-409526,-409454,-408360,-408054,-406101,-404269,-401590,-400963,-394836,-385314,-375836,-374995,-374048,-368693,-368131,-367859,-361397,-360458,-356055,-354270,-354227,-346946,-346223,-346099,-345855,-344808,-344247,-343806,-342087,-339682,-338497,-335912,-334945,-330597,-328200,-327450,-323098,-320641,-319061,-316787,-314312,-314133,-313427,-313020,-311735,-311556,-308652,-307950,-307902,-305049,-304780,-304200,-301782,-301539,-296853,-296489,-293520,-285339,-284857,-284262,-283709,-282070,-281202,-281164,-277190,-276021,-274641,-273757,-273728,-270394,-269087,-265427,-265272,-264115,-263447,-262116,-259606,-257673,-257419,-257235,-257127,-257053,-256900,-256146,-255547,-253986,-249576,-249079,-245481,-239011,-235597,-230997,-228005,-227497,-227250,-226380,-225431,-216611,-210008,-208956,-208838,-201921,-199428,-196686,-191696,-190547,-189199,-188847,-188753,-186418,-185773,-185206,-182706,-180515,-179348,-178474,-175203,-174731,-173012,-173012,-171115,-170095,-168308,-168128,-166905,-166742,-164733,-164448,-158590,-157720,-156014,-155429,-153638,-149375,-148870,-148098,-147945,-145512,-145183,-141591,-139964,-137213,-134488,-133486,-132424,-131215,-130615,-125187,-124332,-117324,-113085,-112523,-111751,-111383,-104409,-104344,-102517,-102161,-98185,-97846,-91902,-89723,-84742,-84067,-83948,-82603,-82579,-78160,-76854,-75430,-75344,-74962,-71408,-69102,-66641,-65642,-64757,-61211,-60329,-57886,-53220,-52898,-49270,-49124,-48080,-45815,-44789,-37626,-34882,-34859,-32485,-31102,-29729,-24983,-22453,-20259,-16334,-16193,-15026,-12533,-11486,-9861,-4017,-404,704,6117,7576,8139,8688,16526,17499,22574,25852,26549,29362,30492,33676,37645,40152,43767,44242,46314,47444,50651,52396,53898,59922,60919,63930,68755,69424,70153,71709,73909,75531,75770,77643,78793,81457,83544,85477,89943,91011,91041,91192,94363,94670,95048,96537,98525,98539,104346,107800,108042,109819,110121,115691,117048,118363,118924,120311,125092,127555,127995,128168,135729,138889,140152,140261,140971,145327,145731,145860,152322,155692,159510,161250,163594,164930,166753,167883,168915,172982,173783,174795,175457,179314,180491,180628,189221,190490,190611,193586,195760,199322,201329,202231,202971,205732,206448,209484,210079,213383,213627,214223,215757,218866,223260,224593,225505,228101,229883,232562,234221,235355,236464,236563,238608,240104,242362,242959,245209,246122,246173,249953,255505,258524,260918,261968,262033,262830,263342,263665,265410,265772,266591,268471,270067,274107,276862,277801,277848,278505,278931,279516,285322,286378,293299,294255,296317,296787,297292,300002,302027,302121,302296,304390,304403,306514,311250,311643,316657,317008,319056,320827,322849,324605,326098,326173,326315,326588,328330,329876,330948,331341,331948,332124,341297,341942,343708,344436,344659,350897,351495,351893,352596,353479,355046,356056,357088,357742,358398,360172,365218,372048,375602,376611,382420,386919,389469,391011,392771,396046,403823,404843,407192,409690,410139,411497,418925,419472,419584,420171,421967,425637,428244,428593,429601,430662,431024,432899,434667,438639,438690,438839,441713,443399,449585,454891,459572,461567,464223,464977,468031,468216,468980,469952,471601,473590,476517,477804,478040,479232,481442,482516,487561,489198,493596,494509,498310,500634,502180,503663,504932,507455,511419,515818,517896,518474,520182,520335,520403,520452,523949,524745,525015,526693,531560,536815,536885,536922,537002,537675,541832,543158,547884,548488,549711,559134,559481,559820,560772,560870,561935,563399,563985,568956,569744,570203,573437,574202,574696,578813,579430,588576,588747,590647,604861,606852,606861,607746,608154,609468,609523,611937,611965,612112,614230,619688,620348,621041,621873,622766,633850,636410,645785,647203,647468,648663,651250,653354,655650,655736,656313,656473,660352,665886,668634,668889,668947,670032,670182,670412,673826,686025,686683,691645,692054,692284,695765,697395,697829,702166,708541,709011,711141,712520,714573,716618,721072,721706,721848,721884,722339,722954,724012,724181,726931,729781,730450,732815,734038,734313,735874,736725,737913,738002,740812,743047,744545,745638,746517,747495,747721,754971,755927,760296,760368,768237,770512,771998,772642,773928,775652,776009,776528,778433,784050,788493,788662,790251,794398,797252,797470,798288,800465,801126,806618,807774,810900,812412,812864,815004,819410,819576,821429,822144,828766,831814,834893,834987,838359,839232,839741,845812,846318,851048,851400,852080,856264,859668,861457,862611,863385,867019,872146,872332,877196,879288,879573,883230,888081,889012,889628,889844,890313,891004,891633,897234,900619,901180,901991,904976,905449,905491,905566,906218,906325,911636,912008,912597,917627,919382,921003,924181,925430,925724,925947,929266,934039,935863,937145,938405,941714,945193,946019,948295,950933,951602,951856,952469,953824,954207,954485,954748,959150,960644,962815,963477,963549,963815,964638,965098,967348,967682,969084,971079,973452,974228,976702,976910,978359,981049,982811,982859,987419,993386,994771,995167,996051,998221]\n[-987944,-969636,-969382,-963918,-960334,-957471,-955419,-954534,-949617,-948164,-941370,-934887,-933385,-933024,-925395,-920598,-914952,-912930,-910713,-898551,-897943,-895093,-883721,-881114,-868961,-862108,-859224,-844995,-843122,-841350,-839681,-837319,-833916,-832929,-824567,-821404,-817679,-816414,-815142,-814794,-814428,-812717,-803053,-800629,-791874,-784923,-776546,-772543,-770170,-769595,-767768,-764581,-760610,-755916,-750060,-738122,-734792,-733242,-728895,-725665,-725507,-718134,-717075,-715534,-715202,-713373,-712097,-708739,-707414,-706871,-703365,-702017,-693735,-683042,-672054,-669261,-668919,-664791,-661728,-660926,-656147,-645420,-643702,-643193,-641435,-638420,-634551,-628772,-615960,-603372,-601747,-598111,-594931,-589739,-582816,-582756,-578800,-578594,-573174,-567081,-559766,-559620,-556681,-554084,-553002,-549693,-548262,-545226,-544969,-537261,-533737,-528123,-520081,-506744,-504736,-499021,-496520,-496470,-495274,-493267,-486175,-485863,-484654,-482183,-481473,-479689,-476360,-474984,-474568,-470604,-469841,-458033,-456643,-456026,-449361,-448407,-447725,-446572,-444202,-444122,-438385,-438174,-436049,-433511,-429215,-428895,-423500,-419598,-414944,-413779,-413601,-413134,-395813,-386542,-386081,-384022,-383217,-377664,-375237,-370842,-368652,-368619,-367534,-360286,-359315,-356864,-346574,-344238,-342362,-338322,-337904,-317031,-315369,-311471,-307529,-291585,-288367,-282217,-273392,-268202,-266384,-262947,-261304,-259484,-253107,-253097,-247496,-240183,-238502,-232673,-225567,-225273,-220556,-218540,-217405,-209508,-209191,-198492,-196102,-194657,-187900,-187654,-187409,-183298,-183195,-178895,-172948,-164463,-150912,-150447,-147157,-146039,-142859,-142513,-141007,-140514,-133632,-121672,-120655,-111524,-106570,-104308,-101032,-100077,-99330,-98302,-93625,-88734,-88072,-87928,-84357,-71659,-69515,-67676,-63282,-58552,-56529,-55822,-52857,-49183,-49096,-36632,-35822,-22044,-15543,-13193,-11327,-8347,-5921,367,2667,4951,5292,12503,13977,16698,20683,21104,29329,29383,32131,36676,38796,38939,39209,47231,48354,58584,63004,67608,68400,79071,80602,81795,86542,94114,101023,103400,104656,104880,111548,112896,115766,121077,122734,127019,127444,132932,138051,140440,154194,158884,165068,166138,166908,169497,170785,171990,179699,180030,188999,195927,197727,215034,218444,219489,222687,224521,235464,235727,241470,243528,246904,258231,259122,260441,263591,265308,267313,269450,272354,272547,274104,276239,278349,282844,283153,284414,285344,292275,301326,301817,303601,305996,308758,308841,318258,318758,326276,328210,328413,329591,330688,335804,336586,338827,350724,353017,355893,356488,358137,367458,369246,373776,375814,388619,389665,391494,398826,410285,414310,434616,436368,437657,441921,442891,443722,445197,448982,449981,452442,455491,458606,458789,459482,459977,460011,467293,480680,484432,486822,491840,495107,498402,498655,499730,501125,506371,507661,508352,508531,510705,517473,521451,521763,531020,535521,536548,538401,543120,545936,546904,551503,551845,552061,557919,565312,566269,568604,574239,574420,578570,579251,582167,587488,592161,594286,604994,619288,622829,629325,652728,657554,659113,659971,661630,664091,664280,667722,673155,674069,675252,680792,683874,685152,698652,701722,703282,708464,710121,710242,712200,718611,720934,732059,736885,739191,742494,750812,759987,772722,776392,782107,782131,783537,783996,785898,793147,799555,806418,807432,808677,831974,841540,844398,849513,849656,854080,855359,858674,865625,866262,870340,877863,886981,896266,898306,900880,903869,907452,914307,916336,916960,922084,923604,924431,926571,930085,935193,948240,948473,954648,957779,959463,960134,960965,975144,979240,997354,999899]\n[0,2,3,4,4,6,6,7,8,8,8,8,11,11,15,16,17,20,22,26,26,28,29,30,31,32,36,39,40,41,41,44,45,52,52,53,54,56,57,62,70,71,72,74,78,78,80,80,83,84,86,87,88,90,91,92,92,96,99,104,105,106,110,110,112,113,113,115,116,118,119,121,121,123,124,125,125,129,129,131,131,134,135,140,141,141,143,144,145,145,145,150,152,153,154,157,158,159,159,159,164,164,169,172,176,176,177,178,178,184,185,189,189,190,191,192,193,193,194,194,195,196,196,200,203,204,205,206,210,211,211,212,212,213,216,219,220,222,225,226,229,229,233,234,237,238,239,241,243,243,246,246,248,249,249,250,250,251,253,255,256,258,260,260,262,266,268,268,269,271,272,273,273,280,281,282,283,288,288,295,296,296,298,302,304,305,305,305,305,306,306,308,309,310,312,313,315,315,318,318,319,319,321,322,323,324,324,326,329,329,329,331,331,333,333,334,334,336,339,339,340,341,341,343,344,348,351,351,352,353,354,354,358,359,363,364,364,365,367,367,368,369,370,372,372,373,376,376,378,379,379,381,382,383,385,386,391,391,391,394,396,399,400,411,414,414,414,416,423,429,429,430,430,431,435,436,437,438,442,443,444,447,448,452,452,452,452,452,455,456,457,457,462,466,468,468,468,472,472,472,472,473,473,475,476,476,477,477,480,481,481,482,483,483,484,485,485,486,486,491,491,491,491,492,494,495,497,497,500,502,503,505,505,509,510,514,515,515,515,516,516,518,519,519,520,522,524,525,527,528,529,531,534,537,537,540,543,543,544,544,545,549,552,552,556,558,558,565,565,566,569,570,571,572,575,577,577,578,579,579,581,583,584,586,586,590,591,593,597,603,603,605,607,608,611,613,614,622,622,622,623,631,631,633,635,638,638,639,642,643,644,645,646,649,652,653,653,654,655,655,655,655,657,659,660,661,664,665,666,667,671,682,684,685,686,688,691,692,694,694,696,698,699,702,704,704,704,706,706,709,710,713,713,714,717,723,725,726,727,727,729,730,730,732,732,733,734,738,740,740,741,746,750,751,751,755,755,758,759,759,760,764,765,767,769,771,773,774,775,776,779,779,781,782,785,797,797,798,798,798,802,803,804,804,806,807,808,809,809,810,810,812,814,814,818,819,820,822,822,823,824,826,826,826,827,830,831,833,833,833,834,837,838,838,839,840,840,841,844,844,847,848,851,852,853,854,857,860,862,864,868,868,869,870,872,874,880,881,881,883,884,885,888,889,892,892,896,897,897,898,899,901,904,905,907,908,914,914,915,915,916,918,920,921,921,921,927,927,928,928,929,932,932,932,932,933,937,937,938,939,940,941,941,942,942,942,944,945,945,946,947,948,952,952,955,956,960,962,964,964,966,968,968,968,971,973,973,973,974,978,979,979,981,982,983,985,985,989,990,990,990,993,994,994,995,998,999,999,1000]\n[999,999,1002,1003,1003,1004,1007,1010,1016,1016,1016,1020,1020,1022,1022,1024,1024,1027,1035,1038,1038,1041,1043,1044,1054,1055,1060,1064,1066,1067,1069,1070,1070,1071,1074,1074,1075,1081,1081,1087,1090,1092,1092,1094,1095,1095,1096,1097,1097,1098,1099,1103,1103,1103,1104,1104,1104,1105,1105,1108,1109,1109,1112,1112,1113,1116,1117,1117,1117,1117,1119,1121,1122,1124,1124,1125,1129,1129,1130,1131,1133,1133,1133,1135,1139,1140,1142,1142,1143,1144,1145,1146,1146,1148,1149,1151,1151,1151,1151,1152,1153,1153,1158,1159,1161,1164,1167,1171,1172,1173,1174,1176,1178,1178,1179,1180,1181,1182,1182,1183,1183,1185,1185,1186,1188,1189,1191,1192,1195,1200,1201,1201,1203,1204,1206,1207,1208,1208,1209,1210,1212,1212,1215,1216,1217,1222,1224,1225,1226,1226,1229,1230,1232,1232,1239,1241,1241,1243,1243,1244,1249,1252,1255,1256,1257,1263,1266,1266,1266,1270,1272,1274,1274,1280,1281,1288,1288,1288,1291,1291,1292,1296,1299,1301,1304,1304,1305,1306,1307,1310,1311,1311,1311,1312,1313,1313,1315,1315,1315,1319,1320,1321,1321,1321,1324,1324,1326,1327,1328,1330,1335,1348,1350,1351,1353,1355,1357,1357,1361,1365,1367,1368,1372,1374,1377,1383,1385,1388,1390,1390,1393,1393,1397,1398,1398,1398,1401,1402,1404,1405,1406,1407,1410,1410,1412,1412,1413,1414,1416,1416,1416,1416,1417,1418,1419,1423,1423,1428,1430,1432,1432,1433,1435,1436,1437,1438,1441,1441,1444,1444,1445,1449,1449,1449,1453,1457,1464,1466,1467,1469,1472,1475,1475,1478,1480,1485,1488,1488,1488,1489,1491,1493,1499,1500,1500,1500,1504,1505,1507,1508,1509,1510,1512,1512,1516,1519,1522,1528,1530,1532,1532,1538,1540,1540,1543,1545,1546,1548,1551,1553,1554,1555,1555,1561,1562,1563,1564,1565,1565,1569,1570,1570,1571,1572,1572,1577,1580,1580,1589,1589,1596,1599,1600,1600,1600,1600,1601,1602,1603,1607,1609,1610,1617,1618,1623,1623,1624,1626,1628,1629,1629,1630,1634,1637,1637,1637,1642,1645,1646,1646,1647,1647,1652,1657,1660,1662,1663,1666,1666,1667,1669,1670,1673,1675,1675,1677,1678,1678,1684,1686,1691,1691,1692,1694,1694,1697,1700,1700,1703,1704,1706,1706,1714,1715,1720,1720,1720,1720,1721,1721,1723,1725,1726,1728,1730,1730,1732,1733,1736,1739,1742,1744,1744,1752,1758,1759,1760,1764,1765,1766,1767,1769,1769,1773,1773,1773,1774,1775,1775,1775,1780,1783,1785,1785,1790,1791,1792,1793,1793,1795,1800,1803,1805,1807,1808,1811,1811,1811,1812,1812,1815,1816,1818,1819,1820,1821,1822,1823,1827,1828,1829,1830,1832,1835,1835,1835,1837,1839,1843,1843,1846,1849,1849,1849,1849,1851,1853,1853,1853,1854,1855,1861,1863,1865,1868,1870,1873,1878,1879,1881,1881,1881,1883,1883,1884,1885,1887,1889,1890,1891,1891,1894,1895,1896,1898,1899,1899,1901,1902,1904,1906,1907,1912,1912,1914,1914,1915,1917,1920,1921,1924,1926,1928,1930,1930,1931,1932,1933,1934,1934,1935,1936,1942,1943,1944,1947,1947,1948,1950,1951,1952,1953,1954,1956,1956,1957,1963,1964,1965,1966,1968,1968,1970,1971,1973,1979,1979,1981,1982,1986,1986,1986,1989,1992,1992,1998,1998,1999,1999,1999,2000]\n[1,1,2,4,7,10,10,11,17,24,26,26,27,28,32,33,33,35,35,35,37,37,37,38,40,41,45,48,50,50,53,53,54,55,55,55,56,57,63,66,68,71,76,79,81,81,82,83,85,88,89,91,95,96,100,102,103,104,104,105,107,107,108,109,109,112,116,118,118,118,119,119,120,121,123,124,124,127,128,128,128,130,132,134,134,140,141,141,143,143,144,147,148,150,150,152,153,155,156,157,164,166,166,167,167,168,176,178,184,185,190,191,191,192,193,194,197,199,201,201,204,207,207,211,211,216,225,225,228,229,233,234,235,237,237,237,238,239,239,244,247,248,248,251,251,254,258,259,259,261,263,266,268,269,269,269,269,271,281,282,285,285,286,287,292,293,295,295,295,296,300,300,302,305,305,305,309,310,310,310,311,318,319,319,320,320,321,321,322,328,329,332,333,334,335,336,336,339,339,339,341,341,345,346,346,347,348,348,349,349,349,350,351,351,355,356,361,363,363,364,366,366,367,368,368,371,371,373,377,380,381,381,382,384,384,387,387,389,394,395,399,400,402,406,406,407,407,410,415,418,419,424,427,433,434,436,437,442,444,445,451,455,455,456,457,459,461,462,463,464,464,465,465,465,467,468,469,473,476,476,476,480,482,483,486,488,489,490,493,495,495,496,496,497,499,499,500,502,504,505,509,509,511,511,516,516,517,521,523,525,526,528,528,530,534,534,535,538,538,541,541,544,544,544,544,546,547,550,550,551,553,555,556,556,557,558,558,559,561,563,567,569,569,570,571,571,572,574,574,575,575,578,582,583,583,584,584,586,590,592,592,594,595,596,598,598,598,601,603,603,604,612,617,618,620,620,624,626,627,628,631,635,637,637,638,641,645,650,651,652,653,654,657,659,659,661,661,661,661,662,663,663,664,664,665,666,669,670,670,671,675,676,683,684,688,689,689,689,690,691,692,694,695,695,696,697,697,700,705,705,707,708,708,709,709,710,710,712,714,716,716,716,718,721,722,722,723,724,725,728,728,729,730,735,735,737,737,741,741,744,747,748,749,750,751,751,754,754,755,757,757,759,759,761,763,763,763,764,766,767,771,771,777,778,778,778,781,782,782,786,786,786,787,787,787,790,790,790,791,792,792,793,801,803,804,805,805,805,805,807,808,808,808,810,815,817,819,819,822,829,829,830,832,832,834,834,836,836,836,837,842,843,844,846,846,847,847,847,850,851,852,853,853,854,854,855,855,858,860,863,864,866,866,867,871,875,881,883,883,886,888,888,890,891,892,894,897,903,913,914,915,918,918,919,920,920,922,923,925,927,927,927,927,928,937,943,943,943,946,948,949,950,953,954,958,966,968,968,971,979,980,981,983,984,985,985,987,987,990,991,992,992,992,997,999]\n[999,1000,1001,1001,1002,1005,1006,1008,1009,1011,1014,1014,1018,1019,1021,1026,1027,1031,1031,1032,1033,1034,1037,1038,1039,1041,1042,1043,1043,1043,1046,1049,1054,1055,1055,1058,1060,1064,1065,1065,1067,1067,1068,1074,1076,1076,1082,1082,1083,1084,1085,1086,1087,1094,1094,1095,1098,1101,1104,1104,1105,1105,1106,1106,1106,1107,1108,1112,1112,1113,1117,1118,1118,1119,1124,1124,1126,1126,1126,1130,1130,1132,1132,1133,1133,1134,1134,1136,1137,1139,1139,1139,1139,1139,1140,1141,1141,1141,1143,1144,1145,1147,1147,1150,1152,1153,1155,1157,1158,1159,1160,1161,1162,1163,1163,1165,1167,1167,1167,1167,1168,1168,1168,1168,1169,1171,1171,1172,1172,1173,1176,1177,1178,1178,1180,1181,1183,1184,1184,1185,1186,1186,1187,1188,1188,1189,1190,1191,1195,1196,1199,1200,1200,1201,1202,1206,1207,1208,1209,1211,1211,1212,1217,1221,1221,1222,1222,1224,1225,1226,1230,1230,1231,1232,1237,1237,1240,1243,1243,1243,1243,1243,1245,1245,1248,1248,1248,1249,1249,1253,1254,1255,1257,1258,1260,1265,1266,1268,1269,1270,1271,1271,1273,1274,1275,1277,1278,1279,1280,1281,1281,1283,1283,1284,1284,1286,1286,1287,1288,1288,1289,1290,1291,1292,1292,1295,1297,1298,1298,1299,1301,1302,1304,1306,1306,1307,1308,1310,1311,1312,1316,1316,1317,1318,1319,1320,1320,1321,1322,1324,1324,1324,1325,1327,1329,1330,1331,1331,1331,1332,1333,1333,1334,1336,1342,1345,1346,1347,1347,1349,1349,1350,1351,1352,1355,1355,1356,1357,1357,1362,1363,1364,1364,1364,1365,1370,1370,1372,1372,1374,1374,1375,1375,1376,1376,1378,1379,1379,1381,1382,1383,1384,1385,1386,1389,1391,1391,1391,1393,1394,1395,1397,1397,1401,1403,1405,1405,1406,1407,1407,1408,1409,1410,1413,1413,1416,1418,1418,1421,1422,1422,1424,1424,1425,1426,1428,1428,1429,1430,1434,1436,1439,1439,1439,1439,1440,1440,1441,1441,1442,1442,1442,1444,1445,1447,1447,1451,1451,1452,1456,1460,1462,1463,1468,1469,1469,1470,1470,1471,1472,1472,1474,1476,1478,1478,1482,1484,1486,1486,1488,1489,1489,1493,1494,1495,1495,1497,1498,1502,1503,1505,1506,1507,1507,1508,1511,1512,1513,1514,1515,1516,1518,1520,1520,1520,1522,1523,1525,1525,1527,1527,1528,1531,1531,1532,1533,1534,1535,1537,1538,1540,1540,1541,1543,1543,1544,1545,1546,1548,1549,1551,1551,1552,1552,1552,1553,1556,1556,1557,1557,1557,1559,1559,1560,1561,1561,1562,1564,1564,1564,1564,1566,1566,1567,1571,1571,1572,1573,1573,1574,1574,1577,1577,1583,1584,1584,1588,1589,1590,1593,1593,1595,1596,1596,1596,1597,1598,1601,1604,1604,1606,1606,1607,1607,1610,1610,1611,1611,1612,1612,1614,1615,1616,1617,1621,1622,1622,1622,1623,1626,1627,1631,1632,1636,1637,1637,1638,1640,1642,1642,1644,1645,1647,1648,1650,1651,1652,1653,1655,1655,1656,1656,1656,1656,1658,1658,1658,1660,1660,1663,1664,1665,1666,1667,1667,1667,1669,1669,1670,1676,1678,1680,1681,1681,1682,1684,1684,1685,1686,1686,1687,1689,1689,1689,1690,1693,1694,1698,1700,1702,1703,1706,1708,1708,1708,1710,1712,1712,1712,1713,1715,1715,1717,1719,1719,1720,1720,1721,1722,1722,1724,1731,1732,1734,1734,1737,1737,1741,1743,1743,1749,1749,1751,1753,1754,1754,1756,1757,1757,1758,1759,1761,1761,1762,1764,1766,1766,1767,1769,1769,1771,1772,1772,1775,1775,1775,1777,1779,1779,1781,1782,1782,1783,1786,1788,1788,1788,1790,1793,1793,1793,1793,1794,1795,1795,1796,1796,1796,1797,1799,1800,1803,1810,1811,1814,1814,1814,1816,1817,1819,1820,1820,1822,1824,1826,1826,1826,1827,1828,1828,1831,1832,1834,1835,1836,1837,1838,1838,1841,1843,1849,1851,1851,1852,1852,1853,1853,1854,1854,1856,1858,1859,1863,1863,1863,1869,1871,1872,1872,1873,1874,1879,1880,1881,1881,1882,1883,1883,1883,1885,1885,1885,1886,1887,1887,1889,1894,1898,1899,1901,1902,1903,1904,1907,1908,1910,1911,1911,1911,1913,1914,1914,1915,1916,1917,1918,1921,1922,1923,1923,1924,1926,1926,1933,1933,1934,1934,1934,1936,1938,1938,1939,1939,1941,1941,1942,1942,1947,1947,1947,1947,1949,1949,1952,1954,1955,1957,1958,1959,1960,1960,1963,1964,1964,1964,1966,1968,1971,1973,1975,1977,1978,1978,1979,1979,1980,1981,1981,1982,1984,1985,1985,1987,1987,1987,1987,1987,1988,1989,1990,1991,1994,1994,1995,1996,1997,1997,1998]\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this help](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e)s and makes thinks clear\\nand do clap \\uD83D\\uDC4F to appreciate the article"
                    },
                    {
                        "username": "pwho",
                        "content": "If you\\'re going to share an article here, don\\'t hide it behind a paywall. =\\\\"
                    },
                    {
                        "username": "user5979vk",
                        "content": "Thanks (https://archive.is/E2agn)"
                    },
                    {
                        "username": "4alisha",
                        "content": "very helpful\\uD83D\\uDC4F"
                    },
                    {
                        "username": "thecodingkid",
                        "content": "Any help would be appreciated if you could explain why the solution in the O(log(min(m,n))) case requires a swap if the second array is smaller.\\n\\nIf you could specify any edge case that is failing , that would be of great help."
                    },
                    {
                        "username": "bparanj",
                        "content": "Swapping nums1 and nums2 if nums1 is larger than nums2 is a trick to simplify the problem by reducing it to a condition where we always binary search on the smaller array. This doesn\\'t change the result because the median of two arrays doesn\\'t depend on which array is longer, but it makes the code cleaner and easier to understand, and it also improves performance by minimizing the search space.\\n\\nMoreover, this technique ensures that we do not run into an index out of bounds error during our binary search process. \\n\\nLet\\'s consider an edge case where the swapping would be important:\\n\\nnums1 = [6, 7, 8, 9, 10]\\nnums2 = [1, 2, 3]\\n\\nIf we did not swap, and started the binary search on nums1, we would end up exploring unnecessary parts of nums1 that wouldn\\'t impact the final result, since we know that the median must be within the range covered by nums2 due to its smaller size and range of values. \\n\\nIf we swap and binary search on nums2, we can find the median more efficiently because we focus on the smaller range of values. We then only need to compare with a few specific elements of nums1.\\n\\nTo summarize, the swap is used to ensure efficiency and simplicity by always performing binary search on the smaller array."
                    }
                ]
            },
            {
                "id": 1570969,
                "content": [
                    {
                        "username": "lugiavn",
                        "content": "Thought I should share the hints here for people that are stuck but still want to solve this. This is my thought process:\\n\\n* Look up definition of median. You want to find the value that bigger than half and smaller than half. In the 1 sorted array, this is the value at index ~n/2, but we have 2 sorted arrays case here.\\n* My first idea is to look at median of the 1st array, and median of the second array, you can easily infer that the median of both must bigger than the min of them and smaller than the max of them, hence you can eliminate half of each array (i.e. left half of the array with smaller median).\\n* Now we are looking for a O(log(n+m)) solution, we want to eliminate half (or some fixed percentage) each iteration.\\n* So the goal is try to eliminate as many as possible while keeping track of what have been eliminated to balance the bigger half and the smaller half, I reached a dead end with this process.\\n\\nWhat works for me:\\n* 1st hint: from above, I came to realize to solve this, I should approach a more generalize problem: instead of finding the median, find the x-th position value (basically bigger than x other values and smaller than (n+m-x-1) other values). if that's solved, then the median will just be x=(n+m)/2; in case n+m is not even, use floor and ceiling, and then average.\\n* 2nd hint: no need trying to eliminate from both side, I only try to eliminate the left side. My recursive solution reduces x each time, till it reaches x = 0 (basic case)\\n* 3rd hint: inspired by the 1st elimination attempt, my solution is: pick the index i1 for 1st array and index i2 for 2nd array, in a clever way, such that when comparing these 2 values, you can eliminate 1st i1 values of 1st array or the 1st i2 values of 2nd array."
                    },
                    {
                        "username": "premish",
                        "content": "It would have been great of you would have given clear examples for median of 2 sorted arrays."
                    },
                    {
                        "username": "bparanj",
                        "content": "Some examples for clarity:\\n\\nExample 1:\\n\\nInput:\\nnums1 = [1, 3]\\nnums2 = [2]\\n\\nThe merged array would be [1, 2, 3], and the median is 2.\\n\\nExample 2:\\n\\nInput:\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\n\\nThe merged array would be [1, 2, 3, 4], and since it\\'s an even-sized array, we take the average of the two middle numbers. So, the median is (2 + 3) / 2 = 2.5.\\n\\nExample 3:\\n\\nInput:\\nnums1 = [1, 5, 9]\\nnums2 = [2, 6, 10]\\n\\nThe merged array would be [1, 2, 5, 6, 9, 10]. Since there are 6 elements, we take the average of the 3rd and 4th elements, which are 5 and 6. So, the median is (5 + 6) / 2 = 5.5.\\n\\nExample 4:\\n\\nInput:\\nnums1 = [1, 7, 9]\\nnums2 = [10, 11]\\n\\nThe merged array would be [1, 7, 9, 10, 11]. As there are 5 elements, the median is the middle element, which is 9.\\n\\nThese examples show how to find the median for two sorted arrays. They represent different scenarios, including even- and odd-sized merged arrays, and they demonstrate how to calculate the median in each scenario.\\n"
                    },
                    {
                        "username": "bloodytiger",
                        "content": "Why the test case with nums1=[3,4] and nums2=[] have median = 3.00000 whereas it should be 3.50000?"
                    },
                    {
                        "username": "pavan_kumar599",
                        "content": "nums=sort(nums1+nums2)/total no.of.elements i.e., 3+4/2==7/2==3.50000"
                    },
                    {
                        "username": "ap2107",
                        "content": "Why do we need to swap nums1 and nums2 if sizeof(nums1)<sizeof(nums2).\\nIf I don\\'t do that it gives runtime error for the case \\n[2]\\n[]\\nbut I am not getting why."
                    },
                    {
                        "username": "bparanj",
                        "content": "If the size of nums1 is smaller than the size of nums2, we swap them so that the binary search always happens on the smaller array (nums1). It is an optimization step that reduces the time complexity of the algorithm by reducing the search space. \\n\\nWhen dealing with the case nums1 = [2] and nums2 = [], if you didn\\'t perform the swap, you might be running into issues because your binary search or indexing might be trying to access elements of an empty array (nums2 in this case). This will cause a runtime error because you\\'re trying to access a location that doesn\\'t exist. \\n\\nBy ensuring nums1 is the smallest array, you ensure that binary search is always performed on a non-empty array, which avoids runtime errors. \\n\\nRemember, the core principle here is to conduct the binary search on the smaller array. This not only optimizes the algorithm but also prevents potential errors when one of the arrays is empty."
                    },
                    {
                        "username": "Krixen",
                        "content": "Hello, Can someone explain to me how this is the answer?\\n\\nInput\\n[3]\\n[-2,-1]\\nOutput\\n0.75\\nExpected\\n-1.0\\n\\nMy output is .75. the median of nums1 is 3, the median of nums2 is -1.5. Therefore (median 1 + mediant 2 / 2) = .75. How do they get -1?\\n\\nThanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your confusion seems to stem from a misunderstanding of the definition of the median for an aggregated set, rather than individual medians.\\n\\nIn this question, we\\'re looking for the median of the combined sorted array, not the average of the medians of the individual arrays. This is a key difference.\\n\\nLet\\'s see how it works with your example:\\n\\n- nums1 = [3]\\n- nums2 = [-2, -1]\\n\\nWhen you combine these arrays, you get: \\n\\ncombined = [-2, -1, 3]\\n\\nThe median of this combined array is the middle element, which is -1, not 0.75.\\n\\nSo, the expected output of -1 is correct because -1 is the median of the combined sorted array, not the average of the individual medians. The median is defined as the value separating the higher half from the lower half of a data sample. It does not mean averaging medians of individual sets. \\n"
                    },
                    {
                        "username": "neapasianle",
                        "content": "merge and sort the lists to `[-2,-1,3]` then see the middle value which is `-1`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "merged and sorted list for [3] and [-1, -2] is [-2, -1, 3] and the median is -1.0\\n"
                    },
                    {
                        "username": "jonj715",
                        "content": "Your equation for the median of the sorted array is wrong. You cannot average the separate medians to get the overall median."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "2700 different test cases and none of them challenge the good old `sorted(nums1 + nums2)`"
                    },
                    {
                        "username": "artursapek",
                        "content": "lmao"
                    },
                    {
                        "username": "bryanahusna",
                        "content": "So how do we solve it? Well, median is the element in the middle of sorted array. So we can just combine both of the two arrays and create one single array, and then call the sort method. The fastest sort algorithm is quicksort, and it takes O(n log(n)) time complexity, or O((m+n) log(m+n)) in this case.\\n\\n**Hold On...**\\n\\nThe question says that the time complexity should be O(m+n). With the previous method, it takes O((m+n) log (m+n)) which is slower than that. So this method is not feasible.\\n\\n**But...**\\n\\nWe can do better than that since the two arrays are sorted. If you have ever taken \"Algorithm Strategy\" course, you may have encountered the divide and conquer strategy. One of algorithms that uses this kind of strategy is merge sort. So merge sort takes 3 steps, that is:\\n1. Divide the input array into two subarrays\\n2. Sort each of them using recursion\\n3. Combine the two sorted subarrays\\n\\nThe given arrays in the problem are already sorted, so we can skip step 1 and 2. All we have to do is doing the third step, no recursion is needed since all we have to do is combining the arrays (recursion takes place in step 2). This combining step only cost O(m + n) in our case.\\n\\nLet arr1, arr2, and arr (our merged array). m is the arr1\\'s length, n is the arr2\\'s length, i j and k are index for arr1 arr2 and arr, respectively. You must allocate arr for size m+n (int arr[m+n] in C++). The combine step to sort ascendingly the two arrays is:\\n1. if arr1 already end, fill arr with arr2\\n\\telse if arr2 already end, fill arr with arr1\\n\\telse if element of the first array at index i is smaller than element of the second at index j, add arr1[i] to arr\\n\\telse add the elemen of the second at index j to arr.\\n2. repeat step 1 until the merged array is filled with all elements from arr1 and arr2\\n\\nThe pseudocode is:\\n1. if **i == m**, then **arr[k] = arr2[j]**. increment both j and k  (fill the rest with the second array)\\n\\telse if **j == m**, then **arr[k] = arr1[i]**. increment both i and k (fill the rest with the first array)\\n\\telse if **arr1[i] <= arr[2]**, then **arr[k] = arr1[i]**. increment both i and k\\n   else **arr[k] = arr2[j]**. increment both j and k\\n2. Repeat step 1 until k is equal to m+n (all elements already copied)\\n\\nCongratulation, you have a merged and sorted array. You can now just return the median of the sorted array, and I think you have already know how to do it (return the element in the middle of the array, or if it is even calculate the average of the two elements in the middle)."
                    },
                    {
                        "username": "parismania",
                        "content": "If you merge both arrays, your complexity is O(m+n). The description requires O(log(m+n)). Hence, your solution does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "lololololol"
                    },
                    {
                        "username": "selsel37",
                        "content": "I solved this problem as comparing and merge until it finds the mid. And time complexity should be O(m+n) by theory I think. \\nI submit multiple of times with same code, and my code is pretty faster (related to time that we can see when we submited, like percentage and time) than when I used binary search algorithm which time complexity should be O(min(log m, log n)) by the theory. I am not sure how this can be happen. Is it just happend by test cases or it\\'s just theory or am I misunderstanding about time complexited of bigO? I am not sure how this can be happend.  Colud someone please explain about this?"
                    },
                    {
                        "username": "gojedan98",
                        "content": "My intuition is that it could be easier to load cache lines for the linear solution as opposed to binary search which is a random access pattern :shrugh:"
                    },
                    {
                        "username": "huowa222",
                        "content": "I complaint..  so many edge cases..."
                    },
                    {
                        "username": "robyowen",
                        "content": "Isn't median of a sorted array the middle element (if odd number of elements), or the first of the middle 2 elements (if even number of elements)?\\n\\nI think the problem description should define what's the median first."
                    },
                    {
                        "username": "sofusl",
                        "content": "If there\\'s 2 middle elements then the median is the two added together and divided by 2. That\\'s the definition of median they shouldn\\'t include that in the problem description. "
                    }
                ]
            },
            {
                "id": 1567787,
                "content": [
                    {
                        "username": "lugiavn",
                        "content": "Thought I should share the hints here for people that are stuck but still want to solve this. This is my thought process:\\n\\n* Look up definition of median. You want to find the value that bigger than half and smaller than half. In the 1 sorted array, this is the value at index ~n/2, but we have 2 sorted arrays case here.\\n* My first idea is to look at median of the 1st array, and median of the second array, you can easily infer that the median of both must bigger than the min of them and smaller than the max of them, hence you can eliminate half of each array (i.e. left half of the array with smaller median).\\n* Now we are looking for a O(log(n+m)) solution, we want to eliminate half (or some fixed percentage) each iteration.\\n* So the goal is try to eliminate as many as possible while keeping track of what have been eliminated to balance the bigger half and the smaller half, I reached a dead end with this process.\\n\\nWhat works for me:\\n* 1st hint: from above, I came to realize to solve this, I should approach a more generalize problem: instead of finding the median, find the x-th position value (basically bigger than x other values and smaller than (n+m-x-1) other values). if that's solved, then the median will just be x=(n+m)/2; in case n+m is not even, use floor and ceiling, and then average.\\n* 2nd hint: no need trying to eliminate from both side, I only try to eliminate the left side. My recursive solution reduces x each time, till it reaches x = 0 (basic case)\\n* 3rd hint: inspired by the 1st elimination attempt, my solution is: pick the index i1 for 1st array and index i2 for 2nd array, in a clever way, such that when comparing these 2 values, you can eliminate 1st i1 values of 1st array or the 1st i2 values of 2nd array."
                    },
                    {
                        "username": "premish",
                        "content": "It would have been great of you would have given clear examples for median of 2 sorted arrays."
                    },
                    {
                        "username": "bparanj",
                        "content": "Some examples for clarity:\\n\\nExample 1:\\n\\nInput:\\nnums1 = [1, 3]\\nnums2 = [2]\\n\\nThe merged array would be [1, 2, 3], and the median is 2.\\n\\nExample 2:\\n\\nInput:\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\n\\nThe merged array would be [1, 2, 3, 4], and since it\\'s an even-sized array, we take the average of the two middle numbers. So, the median is (2 + 3) / 2 = 2.5.\\n\\nExample 3:\\n\\nInput:\\nnums1 = [1, 5, 9]\\nnums2 = [2, 6, 10]\\n\\nThe merged array would be [1, 2, 5, 6, 9, 10]. Since there are 6 elements, we take the average of the 3rd and 4th elements, which are 5 and 6. So, the median is (5 + 6) / 2 = 5.5.\\n\\nExample 4:\\n\\nInput:\\nnums1 = [1, 7, 9]\\nnums2 = [10, 11]\\n\\nThe merged array would be [1, 7, 9, 10, 11]. As there are 5 elements, the median is the middle element, which is 9.\\n\\nThese examples show how to find the median for two sorted arrays. They represent different scenarios, including even- and odd-sized merged arrays, and they demonstrate how to calculate the median in each scenario.\\n"
                    },
                    {
                        "username": "bloodytiger",
                        "content": "Why the test case with nums1=[3,4] and nums2=[] have median = 3.00000 whereas it should be 3.50000?"
                    },
                    {
                        "username": "pavan_kumar599",
                        "content": "nums=sort(nums1+nums2)/total no.of.elements i.e., 3+4/2==7/2==3.50000"
                    },
                    {
                        "username": "ap2107",
                        "content": "Why do we need to swap nums1 and nums2 if sizeof(nums1)<sizeof(nums2).\\nIf I don\\'t do that it gives runtime error for the case \\n[2]\\n[]\\nbut I am not getting why."
                    },
                    {
                        "username": "bparanj",
                        "content": "If the size of nums1 is smaller than the size of nums2, we swap them so that the binary search always happens on the smaller array (nums1). It is an optimization step that reduces the time complexity of the algorithm by reducing the search space. \\n\\nWhen dealing with the case nums1 = [2] and nums2 = [], if you didn\\'t perform the swap, you might be running into issues because your binary search or indexing might be trying to access elements of an empty array (nums2 in this case). This will cause a runtime error because you\\'re trying to access a location that doesn\\'t exist. \\n\\nBy ensuring nums1 is the smallest array, you ensure that binary search is always performed on a non-empty array, which avoids runtime errors. \\n\\nRemember, the core principle here is to conduct the binary search on the smaller array. This not only optimizes the algorithm but also prevents potential errors when one of the arrays is empty."
                    },
                    {
                        "username": "Krixen",
                        "content": "Hello, Can someone explain to me how this is the answer?\\n\\nInput\\n[3]\\n[-2,-1]\\nOutput\\n0.75\\nExpected\\n-1.0\\n\\nMy output is .75. the median of nums1 is 3, the median of nums2 is -1.5. Therefore (median 1 + mediant 2 / 2) = .75. How do they get -1?\\n\\nThanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your confusion seems to stem from a misunderstanding of the definition of the median for an aggregated set, rather than individual medians.\\n\\nIn this question, we\\'re looking for the median of the combined sorted array, not the average of the medians of the individual arrays. This is a key difference.\\n\\nLet\\'s see how it works with your example:\\n\\n- nums1 = [3]\\n- nums2 = [-2, -1]\\n\\nWhen you combine these arrays, you get: \\n\\ncombined = [-2, -1, 3]\\n\\nThe median of this combined array is the middle element, which is -1, not 0.75.\\n\\nSo, the expected output of -1 is correct because -1 is the median of the combined sorted array, not the average of the individual medians. The median is defined as the value separating the higher half from the lower half of a data sample. It does not mean averaging medians of individual sets. \\n"
                    },
                    {
                        "username": "neapasianle",
                        "content": "merge and sort the lists to `[-2,-1,3]` then see the middle value which is `-1`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "merged and sorted list for [3] and [-1, -2] is [-2, -1, 3] and the median is -1.0\\n"
                    },
                    {
                        "username": "jonj715",
                        "content": "Your equation for the median of the sorted array is wrong. You cannot average the separate medians to get the overall median."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "2700 different test cases and none of them challenge the good old `sorted(nums1 + nums2)`"
                    },
                    {
                        "username": "artursapek",
                        "content": "lmao"
                    },
                    {
                        "username": "bryanahusna",
                        "content": "So how do we solve it? Well, median is the element in the middle of sorted array. So we can just combine both of the two arrays and create one single array, and then call the sort method. The fastest sort algorithm is quicksort, and it takes O(n log(n)) time complexity, or O((m+n) log(m+n)) in this case.\\n\\n**Hold On...**\\n\\nThe question says that the time complexity should be O(m+n). With the previous method, it takes O((m+n) log (m+n)) which is slower than that. So this method is not feasible.\\n\\n**But...**\\n\\nWe can do better than that since the two arrays are sorted. If you have ever taken \"Algorithm Strategy\" course, you may have encountered the divide and conquer strategy. One of algorithms that uses this kind of strategy is merge sort. So merge sort takes 3 steps, that is:\\n1. Divide the input array into two subarrays\\n2. Sort each of them using recursion\\n3. Combine the two sorted subarrays\\n\\nThe given arrays in the problem are already sorted, so we can skip step 1 and 2. All we have to do is doing the third step, no recursion is needed since all we have to do is combining the arrays (recursion takes place in step 2). This combining step only cost O(m + n) in our case.\\n\\nLet arr1, arr2, and arr (our merged array). m is the arr1\\'s length, n is the arr2\\'s length, i j and k are index for arr1 arr2 and arr, respectively. You must allocate arr for size m+n (int arr[m+n] in C++). The combine step to sort ascendingly the two arrays is:\\n1. if arr1 already end, fill arr with arr2\\n\\telse if arr2 already end, fill arr with arr1\\n\\telse if element of the first array at index i is smaller than element of the second at index j, add arr1[i] to arr\\n\\telse add the elemen of the second at index j to arr.\\n2. repeat step 1 until the merged array is filled with all elements from arr1 and arr2\\n\\nThe pseudocode is:\\n1. if **i == m**, then **arr[k] = arr2[j]**. increment both j and k  (fill the rest with the second array)\\n\\telse if **j == m**, then **arr[k] = arr1[i]**. increment both i and k (fill the rest with the first array)\\n\\telse if **arr1[i] <= arr[2]**, then **arr[k] = arr1[i]**. increment both i and k\\n   else **arr[k] = arr2[j]**. increment both j and k\\n2. Repeat step 1 until k is equal to m+n (all elements already copied)\\n\\nCongratulation, you have a merged and sorted array. You can now just return the median of the sorted array, and I think you have already know how to do it (return the element in the middle of the array, or if it is even calculate the average of the two elements in the middle)."
                    },
                    {
                        "username": "parismania",
                        "content": "If you merge both arrays, your complexity is O(m+n). The description requires O(log(m+n)). Hence, your solution does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "lololololol"
                    },
                    {
                        "username": "selsel37",
                        "content": "I solved this problem as comparing and merge until it finds the mid. And time complexity should be O(m+n) by theory I think. \\nI submit multiple of times with same code, and my code is pretty faster (related to time that we can see when we submited, like percentage and time) than when I used binary search algorithm which time complexity should be O(min(log m, log n)) by the theory. I am not sure how this can be happen. Is it just happend by test cases or it\\'s just theory or am I misunderstanding about time complexited of bigO? I am not sure how this can be happend.  Colud someone please explain about this?"
                    },
                    {
                        "username": "gojedan98",
                        "content": "My intuition is that it could be easier to load cache lines for the linear solution as opposed to binary search which is a random access pattern :shrugh:"
                    },
                    {
                        "username": "huowa222",
                        "content": "I complaint..  so many edge cases..."
                    },
                    {
                        "username": "robyowen",
                        "content": "Isn't median of a sorted array the middle element (if odd number of elements), or the first of the middle 2 elements (if even number of elements)?\\n\\nI think the problem description should define what's the median first."
                    },
                    {
                        "username": "sofusl",
                        "content": "If there\\'s 2 middle elements then the median is the two added together and divided by 2. That\\'s the definition of median they shouldn\\'t include that in the problem description. "
                    }
                ]
            },
            {
                "id": 1574952,
                "content": [
                    {
                        "username": "lugiavn",
                        "content": "Thought I should share the hints here for people that are stuck but still want to solve this. This is my thought process:\\n\\n* Look up definition of median. You want to find the value that bigger than half and smaller than half. In the 1 sorted array, this is the value at index ~n/2, but we have 2 sorted arrays case here.\\n* My first idea is to look at median of the 1st array, and median of the second array, you can easily infer that the median of both must bigger than the min of them and smaller than the max of them, hence you can eliminate half of each array (i.e. left half of the array with smaller median).\\n* Now we are looking for a O(log(n+m)) solution, we want to eliminate half (or some fixed percentage) each iteration.\\n* So the goal is try to eliminate as many as possible while keeping track of what have been eliminated to balance the bigger half and the smaller half, I reached a dead end with this process.\\n\\nWhat works for me:\\n* 1st hint: from above, I came to realize to solve this, I should approach a more generalize problem: instead of finding the median, find the x-th position value (basically bigger than x other values and smaller than (n+m-x-1) other values). if that's solved, then the median will just be x=(n+m)/2; in case n+m is not even, use floor and ceiling, and then average.\\n* 2nd hint: no need trying to eliminate from both side, I only try to eliminate the left side. My recursive solution reduces x each time, till it reaches x = 0 (basic case)\\n* 3rd hint: inspired by the 1st elimination attempt, my solution is: pick the index i1 for 1st array and index i2 for 2nd array, in a clever way, such that when comparing these 2 values, you can eliminate 1st i1 values of 1st array or the 1st i2 values of 2nd array."
                    },
                    {
                        "username": "premish",
                        "content": "It would have been great of you would have given clear examples for median of 2 sorted arrays."
                    },
                    {
                        "username": "bparanj",
                        "content": "Some examples for clarity:\\n\\nExample 1:\\n\\nInput:\\nnums1 = [1, 3]\\nnums2 = [2]\\n\\nThe merged array would be [1, 2, 3], and the median is 2.\\n\\nExample 2:\\n\\nInput:\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\n\\nThe merged array would be [1, 2, 3, 4], and since it\\'s an even-sized array, we take the average of the two middle numbers. So, the median is (2 + 3) / 2 = 2.5.\\n\\nExample 3:\\n\\nInput:\\nnums1 = [1, 5, 9]\\nnums2 = [2, 6, 10]\\n\\nThe merged array would be [1, 2, 5, 6, 9, 10]. Since there are 6 elements, we take the average of the 3rd and 4th elements, which are 5 and 6. So, the median is (5 + 6) / 2 = 5.5.\\n\\nExample 4:\\n\\nInput:\\nnums1 = [1, 7, 9]\\nnums2 = [10, 11]\\n\\nThe merged array would be [1, 7, 9, 10, 11]. As there are 5 elements, the median is the middle element, which is 9.\\n\\nThese examples show how to find the median for two sorted arrays. They represent different scenarios, including even- and odd-sized merged arrays, and they demonstrate how to calculate the median in each scenario.\\n"
                    },
                    {
                        "username": "bloodytiger",
                        "content": "Why the test case with nums1=[3,4] and nums2=[] have median = 3.00000 whereas it should be 3.50000?"
                    },
                    {
                        "username": "pavan_kumar599",
                        "content": "nums=sort(nums1+nums2)/total no.of.elements i.e., 3+4/2==7/2==3.50000"
                    },
                    {
                        "username": "ap2107",
                        "content": "Why do we need to swap nums1 and nums2 if sizeof(nums1)<sizeof(nums2).\\nIf I don\\'t do that it gives runtime error for the case \\n[2]\\n[]\\nbut I am not getting why."
                    },
                    {
                        "username": "bparanj",
                        "content": "If the size of nums1 is smaller than the size of nums2, we swap them so that the binary search always happens on the smaller array (nums1). It is an optimization step that reduces the time complexity of the algorithm by reducing the search space. \\n\\nWhen dealing with the case nums1 = [2] and nums2 = [], if you didn\\'t perform the swap, you might be running into issues because your binary search or indexing might be trying to access elements of an empty array (nums2 in this case). This will cause a runtime error because you\\'re trying to access a location that doesn\\'t exist. \\n\\nBy ensuring nums1 is the smallest array, you ensure that binary search is always performed on a non-empty array, which avoids runtime errors. \\n\\nRemember, the core principle here is to conduct the binary search on the smaller array. This not only optimizes the algorithm but also prevents potential errors when one of the arrays is empty."
                    },
                    {
                        "username": "Krixen",
                        "content": "Hello, Can someone explain to me how this is the answer?\\n\\nInput\\n[3]\\n[-2,-1]\\nOutput\\n0.75\\nExpected\\n-1.0\\n\\nMy output is .75. the median of nums1 is 3, the median of nums2 is -1.5. Therefore (median 1 + mediant 2 / 2) = .75. How do they get -1?\\n\\nThanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your confusion seems to stem from a misunderstanding of the definition of the median for an aggregated set, rather than individual medians.\\n\\nIn this question, we\\'re looking for the median of the combined sorted array, not the average of the medians of the individual arrays. This is a key difference.\\n\\nLet\\'s see how it works with your example:\\n\\n- nums1 = [3]\\n- nums2 = [-2, -1]\\n\\nWhen you combine these arrays, you get: \\n\\ncombined = [-2, -1, 3]\\n\\nThe median of this combined array is the middle element, which is -1, not 0.75.\\n\\nSo, the expected output of -1 is correct because -1 is the median of the combined sorted array, not the average of the individual medians. The median is defined as the value separating the higher half from the lower half of a data sample. It does not mean averaging medians of individual sets. \\n"
                    },
                    {
                        "username": "neapasianle",
                        "content": "merge and sort the lists to `[-2,-1,3]` then see the middle value which is `-1`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "merged and sorted list for [3] and [-1, -2] is [-2, -1, 3] and the median is -1.0\\n"
                    },
                    {
                        "username": "jonj715",
                        "content": "Your equation for the median of the sorted array is wrong. You cannot average the separate medians to get the overall median."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "2700 different test cases and none of them challenge the good old `sorted(nums1 + nums2)`"
                    },
                    {
                        "username": "artursapek",
                        "content": "lmao"
                    },
                    {
                        "username": "bryanahusna",
                        "content": "So how do we solve it? Well, median is the element in the middle of sorted array. So we can just combine both of the two arrays and create one single array, and then call the sort method. The fastest sort algorithm is quicksort, and it takes O(n log(n)) time complexity, or O((m+n) log(m+n)) in this case.\\n\\n**Hold On...**\\n\\nThe question says that the time complexity should be O(m+n). With the previous method, it takes O((m+n) log (m+n)) which is slower than that. So this method is not feasible.\\n\\n**But...**\\n\\nWe can do better than that since the two arrays are sorted. If you have ever taken \"Algorithm Strategy\" course, you may have encountered the divide and conquer strategy. One of algorithms that uses this kind of strategy is merge sort. So merge sort takes 3 steps, that is:\\n1. Divide the input array into two subarrays\\n2. Sort each of them using recursion\\n3. Combine the two sorted subarrays\\n\\nThe given arrays in the problem are already sorted, so we can skip step 1 and 2. All we have to do is doing the third step, no recursion is needed since all we have to do is combining the arrays (recursion takes place in step 2). This combining step only cost O(m + n) in our case.\\n\\nLet arr1, arr2, and arr (our merged array). m is the arr1\\'s length, n is the arr2\\'s length, i j and k are index for arr1 arr2 and arr, respectively. You must allocate arr for size m+n (int arr[m+n] in C++). The combine step to sort ascendingly the two arrays is:\\n1. if arr1 already end, fill arr with arr2\\n\\telse if arr2 already end, fill arr with arr1\\n\\telse if element of the first array at index i is smaller than element of the second at index j, add arr1[i] to arr\\n\\telse add the elemen of the second at index j to arr.\\n2. repeat step 1 until the merged array is filled with all elements from arr1 and arr2\\n\\nThe pseudocode is:\\n1. if **i == m**, then **arr[k] = arr2[j]**. increment both j and k  (fill the rest with the second array)\\n\\telse if **j == m**, then **arr[k] = arr1[i]**. increment both i and k (fill the rest with the first array)\\n\\telse if **arr1[i] <= arr[2]**, then **arr[k] = arr1[i]**. increment both i and k\\n   else **arr[k] = arr2[j]**. increment both j and k\\n2. Repeat step 1 until k is equal to m+n (all elements already copied)\\n\\nCongratulation, you have a merged and sorted array. You can now just return the median of the sorted array, and I think you have already know how to do it (return the element in the middle of the array, or if it is even calculate the average of the two elements in the middle)."
                    },
                    {
                        "username": "parismania",
                        "content": "If you merge both arrays, your complexity is O(m+n). The description requires O(log(m+n)). Hence, your solution does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "lololololol"
                    },
                    {
                        "username": "selsel37",
                        "content": "I solved this problem as comparing and merge until it finds the mid. And time complexity should be O(m+n) by theory I think. \\nI submit multiple of times with same code, and my code is pretty faster (related to time that we can see when we submited, like percentage and time) than when I used binary search algorithm which time complexity should be O(min(log m, log n)) by the theory. I am not sure how this can be happen. Is it just happend by test cases or it\\'s just theory or am I misunderstanding about time complexited of bigO? I am not sure how this can be happend.  Colud someone please explain about this?"
                    },
                    {
                        "username": "gojedan98",
                        "content": "My intuition is that it could be easier to load cache lines for the linear solution as opposed to binary search which is a random access pattern :shrugh:"
                    },
                    {
                        "username": "huowa222",
                        "content": "I complaint..  so many edge cases..."
                    },
                    {
                        "username": "robyowen",
                        "content": "Isn't median of a sorted array the middle element (if odd number of elements), or the first of the middle 2 elements (if even number of elements)?\\n\\nI think the problem description should define what's the median first."
                    },
                    {
                        "username": "sofusl",
                        "content": "If there\\'s 2 middle elements then the median is the two added together and divided by 2. That\\'s the definition of median they shouldn\\'t include that in the problem description. "
                    }
                ]
            },
            {
                "id": 1574575,
                "content": [
                    {
                        "username": "lugiavn",
                        "content": "Thought I should share the hints here for people that are stuck but still want to solve this. This is my thought process:\\n\\n* Look up definition of median. You want to find the value that bigger than half and smaller than half. In the 1 sorted array, this is the value at index ~n/2, but we have 2 sorted arrays case here.\\n* My first idea is to look at median of the 1st array, and median of the second array, you can easily infer that the median of both must bigger than the min of them and smaller than the max of them, hence you can eliminate half of each array (i.e. left half of the array with smaller median).\\n* Now we are looking for a O(log(n+m)) solution, we want to eliminate half (or some fixed percentage) each iteration.\\n* So the goal is try to eliminate as many as possible while keeping track of what have been eliminated to balance the bigger half and the smaller half, I reached a dead end with this process.\\n\\nWhat works for me:\\n* 1st hint: from above, I came to realize to solve this, I should approach a more generalize problem: instead of finding the median, find the x-th position value (basically bigger than x other values and smaller than (n+m-x-1) other values). if that's solved, then the median will just be x=(n+m)/2; in case n+m is not even, use floor and ceiling, and then average.\\n* 2nd hint: no need trying to eliminate from both side, I only try to eliminate the left side. My recursive solution reduces x each time, till it reaches x = 0 (basic case)\\n* 3rd hint: inspired by the 1st elimination attempt, my solution is: pick the index i1 for 1st array and index i2 for 2nd array, in a clever way, such that when comparing these 2 values, you can eliminate 1st i1 values of 1st array or the 1st i2 values of 2nd array."
                    },
                    {
                        "username": "premish",
                        "content": "It would have been great of you would have given clear examples for median of 2 sorted arrays."
                    },
                    {
                        "username": "bparanj",
                        "content": "Some examples for clarity:\\n\\nExample 1:\\n\\nInput:\\nnums1 = [1, 3]\\nnums2 = [2]\\n\\nThe merged array would be [1, 2, 3], and the median is 2.\\n\\nExample 2:\\n\\nInput:\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\n\\nThe merged array would be [1, 2, 3, 4], and since it\\'s an even-sized array, we take the average of the two middle numbers. So, the median is (2 + 3) / 2 = 2.5.\\n\\nExample 3:\\n\\nInput:\\nnums1 = [1, 5, 9]\\nnums2 = [2, 6, 10]\\n\\nThe merged array would be [1, 2, 5, 6, 9, 10]. Since there are 6 elements, we take the average of the 3rd and 4th elements, which are 5 and 6. So, the median is (5 + 6) / 2 = 5.5.\\n\\nExample 4:\\n\\nInput:\\nnums1 = [1, 7, 9]\\nnums2 = [10, 11]\\n\\nThe merged array would be [1, 7, 9, 10, 11]. As there are 5 elements, the median is the middle element, which is 9.\\n\\nThese examples show how to find the median for two sorted arrays. They represent different scenarios, including even- and odd-sized merged arrays, and they demonstrate how to calculate the median in each scenario.\\n"
                    },
                    {
                        "username": "bloodytiger",
                        "content": "Why the test case with nums1=[3,4] and nums2=[] have median = 3.00000 whereas it should be 3.50000?"
                    },
                    {
                        "username": "pavan_kumar599",
                        "content": "nums=sort(nums1+nums2)/total no.of.elements i.e., 3+4/2==7/2==3.50000"
                    },
                    {
                        "username": "ap2107",
                        "content": "Why do we need to swap nums1 and nums2 if sizeof(nums1)<sizeof(nums2).\\nIf I don\\'t do that it gives runtime error for the case \\n[2]\\n[]\\nbut I am not getting why."
                    },
                    {
                        "username": "bparanj",
                        "content": "If the size of nums1 is smaller than the size of nums2, we swap them so that the binary search always happens on the smaller array (nums1). It is an optimization step that reduces the time complexity of the algorithm by reducing the search space. \\n\\nWhen dealing with the case nums1 = [2] and nums2 = [], if you didn\\'t perform the swap, you might be running into issues because your binary search or indexing might be trying to access elements of an empty array (nums2 in this case). This will cause a runtime error because you\\'re trying to access a location that doesn\\'t exist. \\n\\nBy ensuring nums1 is the smallest array, you ensure that binary search is always performed on a non-empty array, which avoids runtime errors. \\n\\nRemember, the core principle here is to conduct the binary search on the smaller array. This not only optimizes the algorithm but also prevents potential errors when one of the arrays is empty."
                    },
                    {
                        "username": "Krixen",
                        "content": "Hello, Can someone explain to me how this is the answer?\\n\\nInput\\n[3]\\n[-2,-1]\\nOutput\\n0.75\\nExpected\\n-1.0\\n\\nMy output is .75. the median of nums1 is 3, the median of nums2 is -1.5. Therefore (median 1 + mediant 2 / 2) = .75. How do they get -1?\\n\\nThanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your confusion seems to stem from a misunderstanding of the definition of the median for an aggregated set, rather than individual medians.\\n\\nIn this question, we\\'re looking for the median of the combined sorted array, not the average of the medians of the individual arrays. This is a key difference.\\n\\nLet\\'s see how it works with your example:\\n\\n- nums1 = [3]\\n- nums2 = [-2, -1]\\n\\nWhen you combine these arrays, you get: \\n\\ncombined = [-2, -1, 3]\\n\\nThe median of this combined array is the middle element, which is -1, not 0.75.\\n\\nSo, the expected output of -1 is correct because -1 is the median of the combined sorted array, not the average of the individual medians. The median is defined as the value separating the higher half from the lower half of a data sample. It does not mean averaging medians of individual sets. \\n"
                    },
                    {
                        "username": "neapasianle",
                        "content": "merge and sort the lists to `[-2,-1,3]` then see the middle value which is `-1`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "merged and sorted list for [3] and [-1, -2] is [-2, -1, 3] and the median is -1.0\\n"
                    },
                    {
                        "username": "jonj715",
                        "content": "Your equation for the median of the sorted array is wrong. You cannot average the separate medians to get the overall median."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "2700 different test cases and none of them challenge the good old `sorted(nums1 + nums2)`"
                    },
                    {
                        "username": "artursapek",
                        "content": "lmao"
                    },
                    {
                        "username": "bryanahusna",
                        "content": "So how do we solve it? Well, median is the element in the middle of sorted array. So we can just combine both of the two arrays and create one single array, and then call the sort method. The fastest sort algorithm is quicksort, and it takes O(n log(n)) time complexity, or O((m+n) log(m+n)) in this case.\\n\\n**Hold On...**\\n\\nThe question says that the time complexity should be O(m+n). With the previous method, it takes O((m+n) log (m+n)) which is slower than that. So this method is not feasible.\\n\\n**But...**\\n\\nWe can do better than that since the two arrays are sorted. If you have ever taken \"Algorithm Strategy\" course, you may have encountered the divide and conquer strategy. One of algorithms that uses this kind of strategy is merge sort. So merge sort takes 3 steps, that is:\\n1. Divide the input array into two subarrays\\n2. Sort each of them using recursion\\n3. Combine the two sorted subarrays\\n\\nThe given arrays in the problem are already sorted, so we can skip step 1 and 2. All we have to do is doing the third step, no recursion is needed since all we have to do is combining the arrays (recursion takes place in step 2). This combining step only cost O(m + n) in our case.\\n\\nLet arr1, arr2, and arr (our merged array). m is the arr1\\'s length, n is the arr2\\'s length, i j and k are index for arr1 arr2 and arr, respectively. You must allocate arr for size m+n (int arr[m+n] in C++). The combine step to sort ascendingly the two arrays is:\\n1. if arr1 already end, fill arr with arr2\\n\\telse if arr2 already end, fill arr with arr1\\n\\telse if element of the first array at index i is smaller than element of the second at index j, add arr1[i] to arr\\n\\telse add the elemen of the second at index j to arr.\\n2. repeat step 1 until the merged array is filled with all elements from arr1 and arr2\\n\\nThe pseudocode is:\\n1. if **i == m**, then **arr[k] = arr2[j]**. increment both j and k  (fill the rest with the second array)\\n\\telse if **j == m**, then **arr[k] = arr1[i]**. increment both i and k (fill the rest with the first array)\\n\\telse if **arr1[i] <= arr[2]**, then **arr[k] = arr1[i]**. increment both i and k\\n   else **arr[k] = arr2[j]**. increment both j and k\\n2. Repeat step 1 until k is equal to m+n (all elements already copied)\\n\\nCongratulation, you have a merged and sorted array. You can now just return the median of the sorted array, and I think you have already know how to do it (return the element in the middle of the array, or if it is even calculate the average of the two elements in the middle)."
                    },
                    {
                        "username": "parismania",
                        "content": "If you merge both arrays, your complexity is O(m+n). The description requires O(log(m+n)). Hence, your solution does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "lololololol"
                    },
                    {
                        "username": "selsel37",
                        "content": "I solved this problem as comparing and merge until it finds the mid. And time complexity should be O(m+n) by theory I think. \\nI submit multiple of times with same code, and my code is pretty faster (related to time that we can see when we submited, like percentage and time) than when I used binary search algorithm which time complexity should be O(min(log m, log n)) by the theory. I am not sure how this can be happen. Is it just happend by test cases or it\\'s just theory or am I misunderstanding about time complexited of bigO? I am not sure how this can be happend.  Colud someone please explain about this?"
                    },
                    {
                        "username": "gojedan98",
                        "content": "My intuition is that it could be easier to load cache lines for the linear solution as opposed to binary search which is a random access pattern :shrugh:"
                    },
                    {
                        "username": "huowa222",
                        "content": "I complaint..  so many edge cases..."
                    },
                    {
                        "username": "robyowen",
                        "content": "Isn't median of a sorted array the middle element (if odd number of elements), or the first of the middle 2 elements (if even number of elements)?\\n\\nI think the problem description should define what's the median first."
                    },
                    {
                        "username": "sofusl",
                        "content": "If there\\'s 2 middle elements then the median is the two added together and divided by 2. That\\'s the definition of median they shouldn\\'t include that in the problem description. "
                    }
                ]
            },
            {
                "id": 1569379,
                "content": [
                    {
                        "username": "lugiavn",
                        "content": "Thought I should share the hints here for people that are stuck but still want to solve this. This is my thought process:\\n\\n* Look up definition of median. You want to find the value that bigger than half and smaller than half. In the 1 sorted array, this is the value at index ~n/2, but we have 2 sorted arrays case here.\\n* My first idea is to look at median of the 1st array, and median of the second array, you can easily infer that the median of both must bigger than the min of them and smaller than the max of them, hence you can eliminate half of each array (i.e. left half of the array with smaller median).\\n* Now we are looking for a O(log(n+m)) solution, we want to eliminate half (or some fixed percentage) each iteration.\\n* So the goal is try to eliminate as many as possible while keeping track of what have been eliminated to balance the bigger half and the smaller half, I reached a dead end with this process.\\n\\nWhat works for me:\\n* 1st hint: from above, I came to realize to solve this, I should approach a more generalize problem: instead of finding the median, find the x-th position value (basically bigger than x other values and smaller than (n+m-x-1) other values). if that's solved, then the median will just be x=(n+m)/2; in case n+m is not even, use floor and ceiling, and then average.\\n* 2nd hint: no need trying to eliminate from both side, I only try to eliminate the left side. My recursive solution reduces x each time, till it reaches x = 0 (basic case)\\n* 3rd hint: inspired by the 1st elimination attempt, my solution is: pick the index i1 for 1st array and index i2 for 2nd array, in a clever way, such that when comparing these 2 values, you can eliminate 1st i1 values of 1st array or the 1st i2 values of 2nd array."
                    },
                    {
                        "username": "premish",
                        "content": "It would have been great of you would have given clear examples for median of 2 sorted arrays."
                    },
                    {
                        "username": "bparanj",
                        "content": "Some examples for clarity:\\n\\nExample 1:\\n\\nInput:\\nnums1 = [1, 3]\\nnums2 = [2]\\n\\nThe merged array would be [1, 2, 3], and the median is 2.\\n\\nExample 2:\\n\\nInput:\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\n\\nThe merged array would be [1, 2, 3, 4], and since it\\'s an even-sized array, we take the average of the two middle numbers. So, the median is (2 + 3) / 2 = 2.5.\\n\\nExample 3:\\n\\nInput:\\nnums1 = [1, 5, 9]\\nnums2 = [2, 6, 10]\\n\\nThe merged array would be [1, 2, 5, 6, 9, 10]. Since there are 6 elements, we take the average of the 3rd and 4th elements, which are 5 and 6. So, the median is (5 + 6) / 2 = 5.5.\\n\\nExample 4:\\n\\nInput:\\nnums1 = [1, 7, 9]\\nnums2 = [10, 11]\\n\\nThe merged array would be [1, 7, 9, 10, 11]. As there are 5 elements, the median is the middle element, which is 9.\\n\\nThese examples show how to find the median for two sorted arrays. They represent different scenarios, including even- and odd-sized merged arrays, and they demonstrate how to calculate the median in each scenario.\\n"
                    },
                    {
                        "username": "bloodytiger",
                        "content": "Why the test case with nums1=[3,4] and nums2=[] have median = 3.00000 whereas it should be 3.50000?"
                    },
                    {
                        "username": "pavan_kumar599",
                        "content": "nums=sort(nums1+nums2)/total no.of.elements i.e., 3+4/2==7/2==3.50000"
                    },
                    {
                        "username": "ap2107",
                        "content": "Why do we need to swap nums1 and nums2 if sizeof(nums1)<sizeof(nums2).\\nIf I don\\'t do that it gives runtime error for the case \\n[2]\\n[]\\nbut I am not getting why."
                    },
                    {
                        "username": "bparanj",
                        "content": "If the size of nums1 is smaller than the size of nums2, we swap them so that the binary search always happens on the smaller array (nums1). It is an optimization step that reduces the time complexity of the algorithm by reducing the search space. \\n\\nWhen dealing with the case nums1 = [2] and nums2 = [], if you didn\\'t perform the swap, you might be running into issues because your binary search or indexing might be trying to access elements of an empty array (nums2 in this case). This will cause a runtime error because you\\'re trying to access a location that doesn\\'t exist. \\n\\nBy ensuring nums1 is the smallest array, you ensure that binary search is always performed on a non-empty array, which avoids runtime errors. \\n\\nRemember, the core principle here is to conduct the binary search on the smaller array. This not only optimizes the algorithm but also prevents potential errors when one of the arrays is empty."
                    },
                    {
                        "username": "Krixen",
                        "content": "Hello, Can someone explain to me how this is the answer?\\n\\nInput\\n[3]\\n[-2,-1]\\nOutput\\n0.75\\nExpected\\n-1.0\\n\\nMy output is .75. the median of nums1 is 3, the median of nums2 is -1.5. Therefore (median 1 + mediant 2 / 2) = .75. How do they get -1?\\n\\nThanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your confusion seems to stem from a misunderstanding of the definition of the median for an aggregated set, rather than individual medians.\\n\\nIn this question, we\\'re looking for the median of the combined sorted array, not the average of the medians of the individual arrays. This is a key difference.\\n\\nLet\\'s see how it works with your example:\\n\\n- nums1 = [3]\\n- nums2 = [-2, -1]\\n\\nWhen you combine these arrays, you get: \\n\\ncombined = [-2, -1, 3]\\n\\nThe median of this combined array is the middle element, which is -1, not 0.75.\\n\\nSo, the expected output of -1 is correct because -1 is the median of the combined sorted array, not the average of the individual medians. The median is defined as the value separating the higher half from the lower half of a data sample. It does not mean averaging medians of individual sets. \\n"
                    },
                    {
                        "username": "neapasianle",
                        "content": "merge and sort the lists to `[-2,-1,3]` then see the middle value which is `-1`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "merged and sorted list for [3] and [-1, -2] is [-2, -1, 3] and the median is -1.0\\n"
                    },
                    {
                        "username": "jonj715",
                        "content": "Your equation for the median of the sorted array is wrong. You cannot average the separate medians to get the overall median."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "2700 different test cases and none of them challenge the good old `sorted(nums1 + nums2)`"
                    },
                    {
                        "username": "artursapek",
                        "content": "lmao"
                    },
                    {
                        "username": "bryanahusna",
                        "content": "So how do we solve it? Well, median is the element in the middle of sorted array. So we can just combine both of the two arrays and create one single array, and then call the sort method. The fastest sort algorithm is quicksort, and it takes O(n log(n)) time complexity, or O((m+n) log(m+n)) in this case.\\n\\n**Hold On...**\\n\\nThe question says that the time complexity should be O(m+n). With the previous method, it takes O((m+n) log (m+n)) which is slower than that. So this method is not feasible.\\n\\n**But...**\\n\\nWe can do better than that since the two arrays are sorted. If you have ever taken \"Algorithm Strategy\" course, you may have encountered the divide and conquer strategy. One of algorithms that uses this kind of strategy is merge sort. So merge sort takes 3 steps, that is:\\n1. Divide the input array into two subarrays\\n2. Sort each of them using recursion\\n3. Combine the two sorted subarrays\\n\\nThe given arrays in the problem are already sorted, so we can skip step 1 and 2. All we have to do is doing the third step, no recursion is needed since all we have to do is combining the arrays (recursion takes place in step 2). This combining step only cost O(m + n) in our case.\\n\\nLet arr1, arr2, and arr (our merged array). m is the arr1\\'s length, n is the arr2\\'s length, i j and k are index for arr1 arr2 and arr, respectively. You must allocate arr for size m+n (int arr[m+n] in C++). The combine step to sort ascendingly the two arrays is:\\n1. if arr1 already end, fill arr with arr2\\n\\telse if arr2 already end, fill arr with arr1\\n\\telse if element of the first array at index i is smaller than element of the second at index j, add arr1[i] to arr\\n\\telse add the elemen of the second at index j to arr.\\n2. repeat step 1 until the merged array is filled with all elements from arr1 and arr2\\n\\nThe pseudocode is:\\n1. if **i == m**, then **arr[k] = arr2[j]**. increment both j and k  (fill the rest with the second array)\\n\\telse if **j == m**, then **arr[k] = arr1[i]**. increment both i and k (fill the rest with the first array)\\n\\telse if **arr1[i] <= arr[2]**, then **arr[k] = arr1[i]**. increment both i and k\\n   else **arr[k] = arr2[j]**. increment both j and k\\n2. Repeat step 1 until k is equal to m+n (all elements already copied)\\n\\nCongratulation, you have a merged and sorted array. You can now just return the median of the sorted array, and I think you have already know how to do it (return the element in the middle of the array, or if it is even calculate the average of the two elements in the middle)."
                    },
                    {
                        "username": "parismania",
                        "content": "If you merge both arrays, your complexity is O(m+n). The description requires O(log(m+n)). Hence, your solution does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "lololololol"
                    },
                    {
                        "username": "selsel37",
                        "content": "I solved this problem as comparing and merge until it finds the mid. And time complexity should be O(m+n) by theory I think. \\nI submit multiple of times with same code, and my code is pretty faster (related to time that we can see when we submited, like percentage and time) than when I used binary search algorithm which time complexity should be O(min(log m, log n)) by the theory. I am not sure how this can be happen. Is it just happend by test cases or it\\'s just theory or am I misunderstanding about time complexited of bigO? I am not sure how this can be happend.  Colud someone please explain about this?"
                    },
                    {
                        "username": "gojedan98",
                        "content": "My intuition is that it could be easier to load cache lines for the linear solution as opposed to binary search which is a random access pattern :shrugh:"
                    },
                    {
                        "username": "huowa222",
                        "content": "I complaint..  so many edge cases..."
                    },
                    {
                        "username": "robyowen",
                        "content": "Isn't median of a sorted array the middle element (if odd number of elements), or the first of the middle 2 elements (if even number of elements)?\\n\\nI think the problem description should define what's the median first."
                    },
                    {
                        "username": "sofusl",
                        "content": "If there\\'s 2 middle elements then the median is the two added together and divided by 2. That\\'s the definition of median they shouldn\\'t include that in the problem description. "
                    }
                ]
            },
            {
                "id": 2034165,
                "content": [
                    {
                        "username": "lugiavn",
                        "content": "Thought I should share the hints here for people that are stuck but still want to solve this. This is my thought process:\\n\\n* Look up definition of median. You want to find the value that bigger than half and smaller than half. In the 1 sorted array, this is the value at index ~n/2, but we have 2 sorted arrays case here.\\n* My first idea is to look at median of the 1st array, and median of the second array, you can easily infer that the median of both must bigger than the min of them and smaller than the max of them, hence you can eliminate half of each array (i.e. left half of the array with smaller median).\\n* Now we are looking for a O(log(n+m)) solution, we want to eliminate half (or some fixed percentage) each iteration.\\n* So the goal is try to eliminate as many as possible while keeping track of what have been eliminated to balance the bigger half and the smaller half, I reached a dead end with this process.\\n\\nWhat works for me:\\n* 1st hint: from above, I came to realize to solve this, I should approach a more generalize problem: instead of finding the median, find the x-th position value (basically bigger than x other values and smaller than (n+m-x-1) other values). if that's solved, then the median will just be x=(n+m)/2; in case n+m is not even, use floor and ceiling, and then average.\\n* 2nd hint: no need trying to eliminate from both side, I only try to eliminate the left side. My recursive solution reduces x each time, till it reaches x = 0 (basic case)\\n* 3rd hint: inspired by the 1st elimination attempt, my solution is: pick the index i1 for 1st array and index i2 for 2nd array, in a clever way, such that when comparing these 2 values, you can eliminate 1st i1 values of 1st array or the 1st i2 values of 2nd array."
                    },
                    {
                        "username": "premish",
                        "content": "It would have been great of you would have given clear examples for median of 2 sorted arrays."
                    },
                    {
                        "username": "bparanj",
                        "content": "Some examples for clarity:\\n\\nExample 1:\\n\\nInput:\\nnums1 = [1, 3]\\nnums2 = [2]\\n\\nThe merged array would be [1, 2, 3], and the median is 2.\\n\\nExample 2:\\n\\nInput:\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\n\\nThe merged array would be [1, 2, 3, 4], and since it\\'s an even-sized array, we take the average of the two middle numbers. So, the median is (2 + 3) / 2 = 2.5.\\n\\nExample 3:\\n\\nInput:\\nnums1 = [1, 5, 9]\\nnums2 = [2, 6, 10]\\n\\nThe merged array would be [1, 2, 5, 6, 9, 10]. Since there are 6 elements, we take the average of the 3rd and 4th elements, which are 5 and 6. So, the median is (5 + 6) / 2 = 5.5.\\n\\nExample 4:\\n\\nInput:\\nnums1 = [1, 7, 9]\\nnums2 = [10, 11]\\n\\nThe merged array would be [1, 7, 9, 10, 11]. As there are 5 elements, the median is the middle element, which is 9.\\n\\nThese examples show how to find the median for two sorted arrays. They represent different scenarios, including even- and odd-sized merged arrays, and they demonstrate how to calculate the median in each scenario.\\n"
                    },
                    {
                        "username": "bloodytiger",
                        "content": "Why the test case with nums1=[3,4] and nums2=[] have median = 3.00000 whereas it should be 3.50000?"
                    },
                    {
                        "username": "pavan_kumar599",
                        "content": "nums=sort(nums1+nums2)/total no.of.elements i.e., 3+4/2==7/2==3.50000"
                    },
                    {
                        "username": "ap2107",
                        "content": "Why do we need to swap nums1 and nums2 if sizeof(nums1)<sizeof(nums2).\\nIf I don\\'t do that it gives runtime error for the case \\n[2]\\n[]\\nbut I am not getting why."
                    },
                    {
                        "username": "bparanj",
                        "content": "If the size of nums1 is smaller than the size of nums2, we swap them so that the binary search always happens on the smaller array (nums1). It is an optimization step that reduces the time complexity of the algorithm by reducing the search space. \\n\\nWhen dealing with the case nums1 = [2] and nums2 = [], if you didn\\'t perform the swap, you might be running into issues because your binary search or indexing might be trying to access elements of an empty array (nums2 in this case). This will cause a runtime error because you\\'re trying to access a location that doesn\\'t exist. \\n\\nBy ensuring nums1 is the smallest array, you ensure that binary search is always performed on a non-empty array, which avoids runtime errors. \\n\\nRemember, the core principle here is to conduct the binary search on the smaller array. This not only optimizes the algorithm but also prevents potential errors when one of the arrays is empty."
                    },
                    {
                        "username": "Krixen",
                        "content": "Hello, Can someone explain to me how this is the answer?\\n\\nInput\\n[3]\\n[-2,-1]\\nOutput\\n0.75\\nExpected\\n-1.0\\n\\nMy output is .75. the median of nums1 is 3, the median of nums2 is -1.5. Therefore (median 1 + mediant 2 / 2) = .75. How do they get -1?\\n\\nThanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your confusion seems to stem from a misunderstanding of the definition of the median for an aggregated set, rather than individual medians.\\n\\nIn this question, we\\'re looking for the median of the combined sorted array, not the average of the medians of the individual arrays. This is a key difference.\\n\\nLet\\'s see how it works with your example:\\n\\n- nums1 = [3]\\n- nums2 = [-2, -1]\\n\\nWhen you combine these arrays, you get: \\n\\ncombined = [-2, -1, 3]\\n\\nThe median of this combined array is the middle element, which is -1, not 0.75.\\n\\nSo, the expected output of -1 is correct because -1 is the median of the combined sorted array, not the average of the individual medians. The median is defined as the value separating the higher half from the lower half of a data sample. It does not mean averaging medians of individual sets. \\n"
                    },
                    {
                        "username": "neapasianle",
                        "content": "merge and sort the lists to `[-2,-1,3]` then see the middle value which is `-1`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "merged and sorted list for [3] and [-1, -2] is [-2, -1, 3] and the median is -1.0\\n"
                    },
                    {
                        "username": "jonj715",
                        "content": "Your equation for the median of the sorted array is wrong. You cannot average the separate medians to get the overall median."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "2700 different test cases and none of them challenge the good old `sorted(nums1 + nums2)`"
                    },
                    {
                        "username": "artursapek",
                        "content": "lmao"
                    },
                    {
                        "username": "bryanahusna",
                        "content": "So how do we solve it? Well, median is the element in the middle of sorted array. So we can just combine both of the two arrays and create one single array, and then call the sort method. The fastest sort algorithm is quicksort, and it takes O(n log(n)) time complexity, or O((m+n) log(m+n)) in this case.\\n\\n**Hold On...**\\n\\nThe question says that the time complexity should be O(m+n). With the previous method, it takes O((m+n) log (m+n)) which is slower than that. So this method is not feasible.\\n\\n**But...**\\n\\nWe can do better than that since the two arrays are sorted. If you have ever taken \"Algorithm Strategy\" course, you may have encountered the divide and conquer strategy. One of algorithms that uses this kind of strategy is merge sort. So merge sort takes 3 steps, that is:\\n1. Divide the input array into two subarrays\\n2. Sort each of them using recursion\\n3. Combine the two sorted subarrays\\n\\nThe given arrays in the problem are already sorted, so we can skip step 1 and 2. All we have to do is doing the third step, no recursion is needed since all we have to do is combining the arrays (recursion takes place in step 2). This combining step only cost O(m + n) in our case.\\n\\nLet arr1, arr2, and arr (our merged array). m is the arr1\\'s length, n is the arr2\\'s length, i j and k are index for arr1 arr2 and arr, respectively. You must allocate arr for size m+n (int arr[m+n] in C++). The combine step to sort ascendingly the two arrays is:\\n1. if arr1 already end, fill arr with arr2\\n\\telse if arr2 already end, fill arr with arr1\\n\\telse if element of the first array at index i is smaller than element of the second at index j, add arr1[i] to arr\\n\\telse add the elemen of the second at index j to arr.\\n2. repeat step 1 until the merged array is filled with all elements from arr1 and arr2\\n\\nThe pseudocode is:\\n1. if **i == m**, then **arr[k] = arr2[j]**. increment both j and k  (fill the rest with the second array)\\n\\telse if **j == m**, then **arr[k] = arr1[i]**. increment both i and k (fill the rest with the first array)\\n\\telse if **arr1[i] <= arr[2]**, then **arr[k] = arr1[i]**. increment both i and k\\n   else **arr[k] = arr2[j]**. increment both j and k\\n2. Repeat step 1 until k is equal to m+n (all elements already copied)\\n\\nCongratulation, you have a merged and sorted array. You can now just return the median of the sorted array, and I think you have already know how to do it (return the element in the middle of the array, or if it is even calculate the average of the two elements in the middle)."
                    },
                    {
                        "username": "parismania",
                        "content": "If you merge both arrays, your complexity is O(m+n). The description requires O(log(m+n)). Hence, your solution does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "lololololol"
                    },
                    {
                        "username": "selsel37",
                        "content": "I solved this problem as comparing and merge until it finds the mid. And time complexity should be O(m+n) by theory I think. \\nI submit multiple of times with same code, and my code is pretty faster (related to time that we can see when we submited, like percentage and time) than when I used binary search algorithm which time complexity should be O(min(log m, log n)) by the theory. I am not sure how this can be happen. Is it just happend by test cases or it\\'s just theory or am I misunderstanding about time complexited of bigO? I am not sure how this can be happend.  Colud someone please explain about this?"
                    },
                    {
                        "username": "gojedan98",
                        "content": "My intuition is that it could be easier to load cache lines for the linear solution as opposed to binary search which is a random access pattern :shrugh:"
                    },
                    {
                        "username": "huowa222",
                        "content": "I complaint..  so many edge cases..."
                    },
                    {
                        "username": "robyowen",
                        "content": "Isn't median of a sorted array the middle element (if odd number of elements), or the first of the middle 2 elements (if even number of elements)?\\n\\nI think the problem description should define what's the median first."
                    },
                    {
                        "username": "sofusl",
                        "content": "If there\\'s 2 middle elements then the median is the two added together and divided by 2. That\\'s the definition of median they shouldn\\'t include that in the problem description. "
                    }
                ]
            },
            {
                "id": 1576805,
                "content": [
                    {
                        "username": "lugiavn",
                        "content": "Thought I should share the hints here for people that are stuck but still want to solve this. This is my thought process:\\n\\n* Look up definition of median. You want to find the value that bigger than half and smaller than half. In the 1 sorted array, this is the value at index ~n/2, but we have 2 sorted arrays case here.\\n* My first idea is to look at median of the 1st array, and median of the second array, you can easily infer that the median of both must bigger than the min of them and smaller than the max of them, hence you can eliminate half of each array (i.e. left half of the array with smaller median).\\n* Now we are looking for a O(log(n+m)) solution, we want to eliminate half (or some fixed percentage) each iteration.\\n* So the goal is try to eliminate as many as possible while keeping track of what have been eliminated to balance the bigger half and the smaller half, I reached a dead end with this process.\\n\\nWhat works for me:\\n* 1st hint: from above, I came to realize to solve this, I should approach a more generalize problem: instead of finding the median, find the x-th position value (basically bigger than x other values and smaller than (n+m-x-1) other values). if that's solved, then the median will just be x=(n+m)/2; in case n+m is not even, use floor and ceiling, and then average.\\n* 2nd hint: no need trying to eliminate from both side, I only try to eliminate the left side. My recursive solution reduces x each time, till it reaches x = 0 (basic case)\\n* 3rd hint: inspired by the 1st elimination attempt, my solution is: pick the index i1 for 1st array and index i2 for 2nd array, in a clever way, such that when comparing these 2 values, you can eliminate 1st i1 values of 1st array or the 1st i2 values of 2nd array."
                    },
                    {
                        "username": "premish",
                        "content": "It would have been great of you would have given clear examples for median of 2 sorted arrays."
                    },
                    {
                        "username": "bparanj",
                        "content": "Some examples for clarity:\\n\\nExample 1:\\n\\nInput:\\nnums1 = [1, 3]\\nnums2 = [2]\\n\\nThe merged array would be [1, 2, 3], and the median is 2.\\n\\nExample 2:\\n\\nInput:\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\n\\nThe merged array would be [1, 2, 3, 4], and since it\\'s an even-sized array, we take the average of the two middle numbers. So, the median is (2 + 3) / 2 = 2.5.\\n\\nExample 3:\\n\\nInput:\\nnums1 = [1, 5, 9]\\nnums2 = [2, 6, 10]\\n\\nThe merged array would be [1, 2, 5, 6, 9, 10]. Since there are 6 elements, we take the average of the 3rd and 4th elements, which are 5 and 6. So, the median is (5 + 6) / 2 = 5.5.\\n\\nExample 4:\\n\\nInput:\\nnums1 = [1, 7, 9]\\nnums2 = [10, 11]\\n\\nThe merged array would be [1, 7, 9, 10, 11]. As there are 5 elements, the median is the middle element, which is 9.\\n\\nThese examples show how to find the median for two sorted arrays. They represent different scenarios, including even- and odd-sized merged arrays, and they demonstrate how to calculate the median in each scenario.\\n"
                    },
                    {
                        "username": "bloodytiger",
                        "content": "Why the test case with nums1=[3,4] and nums2=[] have median = 3.00000 whereas it should be 3.50000?"
                    },
                    {
                        "username": "pavan_kumar599",
                        "content": "nums=sort(nums1+nums2)/total no.of.elements i.e., 3+4/2==7/2==3.50000"
                    },
                    {
                        "username": "ap2107",
                        "content": "Why do we need to swap nums1 and nums2 if sizeof(nums1)<sizeof(nums2).\\nIf I don\\'t do that it gives runtime error for the case \\n[2]\\n[]\\nbut I am not getting why."
                    },
                    {
                        "username": "bparanj",
                        "content": "If the size of nums1 is smaller than the size of nums2, we swap them so that the binary search always happens on the smaller array (nums1). It is an optimization step that reduces the time complexity of the algorithm by reducing the search space. \\n\\nWhen dealing with the case nums1 = [2] and nums2 = [], if you didn\\'t perform the swap, you might be running into issues because your binary search or indexing might be trying to access elements of an empty array (nums2 in this case). This will cause a runtime error because you\\'re trying to access a location that doesn\\'t exist. \\n\\nBy ensuring nums1 is the smallest array, you ensure that binary search is always performed on a non-empty array, which avoids runtime errors. \\n\\nRemember, the core principle here is to conduct the binary search on the smaller array. This not only optimizes the algorithm but also prevents potential errors when one of the arrays is empty."
                    },
                    {
                        "username": "Krixen",
                        "content": "Hello, Can someone explain to me how this is the answer?\\n\\nInput\\n[3]\\n[-2,-1]\\nOutput\\n0.75\\nExpected\\n-1.0\\n\\nMy output is .75. the median of nums1 is 3, the median of nums2 is -1.5. Therefore (median 1 + mediant 2 / 2) = .75. How do they get -1?\\n\\nThanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your confusion seems to stem from a misunderstanding of the definition of the median for an aggregated set, rather than individual medians.\\n\\nIn this question, we\\'re looking for the median of the combined sorted array, not the average of the medians of the individual arrays. This is a key difference.\\n\\nLet\\'s see how it works with your example:\\n\\n- nums1 = [3]\\n- nums2 = [-2, -1]\\n\\nWhen you combine these arrays, you get: \\n\\ncombined = [-2, -1, 3]\\n\\nThe median of this combined array is the middle element, which is -1, not 0.75.\\n\\nSo, the expected output of -1 is correct because -1 is the median of the combined sorted array, not the average of the individual medians. The median is defined as the value separating the higher half from the lower half of a data sample. It does not mean averaging medians of individual sets. \\n"
                    },
                    {
                        "username": "neapasianle",
                        "content": "merge and sort the lists to `[-2,-1,3]` then see the middle value which is `-1`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "merged and sorted list for [3] and [-1, -2] is [-2, -1, 3] and the median is -1.0\\n"
                    },
                    {
                        "username": "jonj715",
                        "content": "Your equation for the median of the sorted array is wrong. You cannot average the separate medians to get the overall median."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "2700 different test cases and none of them challenge the good old `sorted(nums1 + nums2)`"
                    },
                    {
                        "username": "artursapek",
                        "content": "lmao"
                    },
                    {
                        "username": "bryanahusna",
                        "content": "So how do we solve it? Well, median is the element in the middle of sorted array. So we can just combine both of the two arrays and create one single array, and then call the sort method. The fastest sort algorithm is quicksort, and it takes O(n log(n)) time complexity, or O((m+n) log(m+n)) in this case.\\n\\n**Hold On...**\\n\\nThe question says that the time complexity should be O(m+n). With the previous method, it takes O((m+n) log (m+n)) which is slower than that. So this method is not feasible.\\n\\n**But...**\\n\\nWe can do better than that since the two arrays are sorted. If you have ever taken \"Algorithm Strategy\" course, you may have encountered the divide and conquer strategy. One of algorithms that uses this kind of strategy is merge sort. So merge sort takes 3 steps, that is:\\n1. Divide the input array into two subarrays\\n2. Sort each of them using recursion\\n3. Combine the two sorted subarrays\\n\\nThe given arrays in the problem are already sorted, so we can skip step 1 and 2. All we have to do is doing the third step, no recursion is needed since all we have to do is combining the arrays (recursion takes place in step 2). This combining step only cost O(m + n) in our case.\\n\\nLet arr1, arr2, and arr (our merged array). m is the arr1\\'s length, n is the arr2\\'s length, i j and k are index for arr1 arr2 and arr, respectively. You must allocate arr for size m+n (int arr[m+n] in C++). The combine step to sort ascendingly the two arrays is:\\n1. if arr1 already end, fill arr with arr2\\n\\telse if arr2 already end, fill arr with arr1\\n\\telse if element of the first array at index i is smaller than element of the second at index j, add arr1[i] to arr\\n\\telse add the elemen of the second at index j to arr.\\n2. repeat step 1 until the merged array is filled with all elements from arr1 and arr2\\n\\nThe pseudocode is:\\n1. if **i == m**, then **arr[k] = arr2[j]**. increment both j and k  (fill the rest with the second array)\\n\\telse if **j == m**, then **arr[k] = arr1[i]**. increment both i and k (fill the rest with the first array)\\n\\telse if **arr1[i] <= arr[2]**, then **arr[k] = arr1[i]**. increment both i and k\\n   else **arr[k] = arr2[j]**. increment both j and k\\n2. Repeat step 1 until k is equal to m+n (all elements already copied)\\n\\nCongratulation, you have a merged and sorted array. You can now just return the median of the sorted array, and I think you have already know how to do it (return the element in the middle of the array, or if it is even calculate the average of the two elements in the middle)."
                    },
                    {
                        "username": "parismania",
                        "content": "If you merge both arrays, your complexity is O(m+n). The description requires O(log(m+n)). Hence, your solution does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "lololololol"
                    },
                    {
                        "username": "selsel37",
                        "content": "I solved this problem as comparing and merge until it finds the mid. And time complexity should be O(m+n) by theory I think. \\nI submit multiple of times with same code, and my code is pretty faster (related to time that we can see when we submited, like percentage and time) than when I used binary search algorithm which time complexity should be O(min(log m, log n)) by the theory. I am not sure how this can be happen. Is it just happend by test cases or it\\'s just theory or am I misunderstanding about time complexited of bigO? I am not sure how this can be happend.  Colud someone please explain about this?"
                    },
                    {
                        "username": "gojedan98",
                        "content": "My intuition is that it could be easier to load cache lines for the linear solution as opposed to binary search which is a random access pattern :shrugh:"
                    },
                    {
                        "username": "huowa222",
                        "content": "I complaint..  so many edge cases..."
                    },
                    {
                        "username": "robyowen",
                        "content": "Isn't median of a sorted array the middle element (if odd number of elements), or the first of the middle 2 elements (if even number of elements)?\\n\\nI think the problem description should define what's the median first."
                    },
                    {
                        "username": "sofusl",
                        "content": "If there\\'s 2 middle elements then the median is the two added together and divided by 2. That\\'s the definition of median they shouldn\\'t include that in the problem description. "
                    }
                ]
            },
            {
                "id": 1576656,
                "content": [
                    {
                        "username": "lugiavn",
                        "content": "Thought I should share the hints here for people that are stuck but still want to solve this. This is my thought process:\\n\\n* Look up definition of median. You want to find the value that bigger than half and smaller than half. In the 1 sorted array, this is the value at index ~n/2, but we have 2 sorted arrays case here.\\n* My first idea is to look at median of the 1st array, and median of the second array, you can easily infer that the median of both must bigger than the min of them and smaller than the max of them, hence you can eliminate half of each array (i.e. left half of the array with smaller median).\\n* Now we are looking for a O(log(n+m)) solution, we want to eliminate half (or some fixed percentage) each iteration.\\n* So the goal is try to eliminate as many as possible while keeping track of what have been eliminated to balance the bigger half and the smaller half, I reached a dead end with this process.\\n\\nWhat works for me:\\n* 1st hint: from above, I came to realize to solve this, I should approach a more generalize problem: instead of finding the median, find the x-th position value (basically bigger than x other values and smaller than (n+m-x-1) other values). if that's solved, then the median will just be x=(n+m)/2; in case n+m is not even, use floor and ceiling, and then average.\\n* 2nd hint: no need trying to eliminate from both side, I only try to eliminate the left side. My recursive solution reduces x each time, till it reaches x = 0 (basic case)\\n* 3rd hint: inspired by the 1st elimination attempt, my solution is: pick the index i1 for 1st array and index i2 for 2nd array, in a clever way, such that when comparing these 2 values, you can eliminate 1st i1 values of 1st array or the 1st i2 values of 2nd array."
                    },
                    {
                        "username": "premish",
                        "content": "It would have been great of you would have given clear examples for median of 2 sorted arrays."
                    },
                    {
                        "username": "bparanj",
                        "content": "Some examples for clarity:\\n\\nExample 1:\\n\\nInput:\\nnums1 = [1, 3]\\nnums2 = [2]\\n\\nThe merged array would be [1, 2, 3], and the median is 2.\\n\\nExample 2:\\n\\nInput:\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\n\\nThe merged array would be [1, 2, 3, 4], and since it\\'s an even-sized array, we take the average of the two middle numbers. So, the median is (2 + 3) / 2 = 2.5.\\n\\nExample 3:\\n\\nInput:\\nnums1 = [1, 5, 9]\\nnums2 = [2, 6, 10]\\n\\nThe merged array would be [1, 2, 5, 6, 9, 10]. Since there are 6 elements, we take the average of the 3rd and 4th elements, which are 5 and 6. So, the median is (5 + 6) / 2 = 5.5.\\n\\nExample 4:\\n\\nInput:\\nnums1 = [1, 7, 9]\\nnums2 = [10, 11]\\n\\nThe merged array would be [1, 7, 9, 10, 11]. As there are 5 elements, the median is the middle element, which is 9.\\n\\nThese examples show how to find the median for two sorted arrays. They represent different scenarios, including even- and odd-sized merged arrays, and they demonstrate how to calculate the median in each scenario.\\n"
                    },
                    {
                        "username": "bloodytiger",
                        "content": "Why the test case with nums1=[3,4] and nums2=[] have median = 3.00000 whereas it should be 3.50000?"
                    },
                    {
                        "username": "pavan_kumar599",
                        "content": "nums=sort(nums1+nums2)/total no.of.elements i.e., 3+4/2==7/2==3.50000"
                    },
                    {
                        "username": "ap2107",
                        "content": "Why do we need to swap nums1 and nums2 if sizeof(nums1)<sizeof(nums2).\\nIf I don\\'t do that it gives runtime error for the case \\n[2]\\n[]\\nbut I am not getting why."
                    },
                    {
                        "username": "bparanj",
                        "content": "If the size of nums1 is smaller than the size of nums2, we swap them so that the binary search always happens on the smaller array (nums1). It is an optimization step that reduces the time complexity of the algorithm by reducing the search space. \\n\\nWhen dealing with the case nums1 = [2] and nums2 = [], if you didn\\'t perform the swap, you might be running into issues because your binary search or indexing might be trying to access elements of an empty array (nums2 in this case). This will cause a runtime error because you\\'re trying to access a location that doesn\\'t exist. \\n\\nBy ensuring nums1 is the smallest array, you ensure that binary search is always performed on a non-empty array, which avoids runtime errors. \\n\\nRemember, the core principle here is to conduct the binary search on the smaller array. This not only optimizes the algorithm but also prevents potential errors when one of the arrays is empty."
                    },
                    {
                        "username": "Krixen",
                        "content": "Hello, Can someone explain to me how this is the answer?\\n\\nInput\\n[3]\\n[-2,-1]\\nOutput\\n0.75\\nExpected\\n-1.0\\n\\nMy output is .75. the median of nums1 is 3, the median of nums2 is -1.5. Therefore (median 1 + mediant 2 / 2) = .75. How do they get -1?\\n\\nThanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your confusion seems to stem from a misunderstanding of the definition of the median for an aggregated set, rather than individual medians.\\n\\nIn this question, we\\'re looking for the median of the combined sorted array, not the average of the medians of the individual arrays. This is a key difference.\\n\\nLet\\'s see how it works with your example:\\n\\n- nums1 = [3]\\n- nums2 = [-2, -1]\\n\\nWhen you combine these arrays, you get: \\n\\ncombined = [-2, -1, 3]\\n\\nThe median of this combined array is the middle element, which is -1, not 0.75.\\n\\nSo, the expected output of -1 is correct because -1 is the median of the combined sorted array, not the average of the individual medians. The median is defined as the value separating the higher half from the lower half of a data sample. It does not mean averaging medians of individual sets. \\n"
                    },
                    {
                        "username": "neapasianle",
                        "content": "merge and sort the lists to `[-2,-1,3]` then see the middle value which is `-1`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "merged and sorted list for [3] and [-1, -2] is [-2, -1, 3] and the median is -1.0\\n"
                    },
                    {
                        "username": "jonj715",
                        "content": "Your equation for the median of the sorted array is wrong. You cannot average the separate medians to get the overall median."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "2700 different test cases and none of them challenge the good old `sorted(nums1 + nums2)`"
                    },
                    {
                        "username": "artursapek",
                        "content": "lmao"
                    },
                    {
                        "username": "bryanahusna",
                        "content": "So how do we solve it? Well, median is the element in the middle of sorted array. So we can just combine both of the two arrays and create one single array, and then call the sort method. The fastest sort algorithm is quicksort, and it takes O(n log(n)) time complexity, or O((m+n) log(m+n)) in this case.\\n\\n**Hold On...**\\n\\nThe question says that the time complexity should be O(m+n). With the previous method, it takes O((m+n) log (m+n)) which is slower than that. So this method is not feasible.\\n\\n**But...**\\n\\nWe can do better than that since the two arrays are sorted. If you have ever taken \"Algorithm Strategy\" course, you may have encountered the divide and conquer strategy. One of algorithms that uses this kind of strategy is merge sort. So merge sort takes 3 steps, that is:\\n1. Divide the input array into two subarrays\\n2. Sort each of them using recursion\\n3. Combine the two sorted subarrays\\n\\nThe given arrays in the problem are already sorted, so we can skip step 1 and 2. All we have to do is doing the third step, no recursion is needed since all we have to do is combining the arrays (recursion takes place in step 2). This combining step only cost O(m + n) in our case.\\n\\nLet arr1, arr2, and arr (our merged array). m is the arr1\\'s length, n is the arr2\\'s length, i j and k are index for arr1 arr2 and arr, respectively. You must allocate arr for size m+n (int arr[m+n] in C++). The combine step to sort ascendingly the two arrays is:\\n1. if arr1 already end, fill arr with arr2\\n\\telse if arr2 already end, fill arr with arr1\\n\\telse if element of the first array at index i is smaller than element of the second at index j, add arr1[i] to arr\\n\\telse add the elemen of the second at index j to arr.\\n2. repeat step 1 until the merged array is filled with all elements from arr1 and arr2\\n\\nThe pseudocode is:\\n1. if **i == m**, then **arr[k] = arr2[j]**. increment both j and k  (fill the rest with the second array)\\n\\telse if **j == m**, then **arr[k] = arr1[i]**. increment both i and k (fill the rest with the first array)\\n\\telse if **arr1[i] <= arr[2]**, then **arr[k] = arr1[i]**. increment both i and k\\n   else **arr[k] = arr2[j]**. increment both j and k\\n2. Repeat step 1 until k is equal to m+n (all elements already copied)\\n\\nCongratulation, you have a merged and sorted array. You can now just return the median of the sorted array, and I think you have already know how to do it (return the element in the middle of the array, or if it is even calculate the average of the two elements in the middle)."
                    },
                    {
                        "username": "parismania",
                        "content": "If you merge both arrays, your complexity is O(m+n). The description requires O(log(m+n)). Hence, your solution does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "lololololol"
                    },
                    {
                        "username": "selsel37",
                        "content": "I solved this problem as comparing and merge until it finds the mid. And time complexity should be O(m+n) by theory I think. \\nI submit multiple of times with same code, and my code is pretty faster (related to time that we can see when we submited, like percentage and time) than when I used binary search algorithm which time complexity should be O(min(log m, log n)) by the theory. I am not sure how this can be happen. Is it just happend by test cases or it\\'s just theory or am I misunderstanding about time complexited of bigO? I am not sure how this can be happend.  Colud someone please explain about this?"
                    },
                    {
                        "username": "gojedan98",
                        "content": "My intuition is that it could be easier to load cache lines for the linear solution as opposed to binary search which is a random access pattern :shrugh:"
                    },
                    {
                        "username": "huowa222",
                        "content": "I complaint..  so many edge cases..."
                    },
                    {
                        "username": "robyowen",
                        "content": "Isn't median of a sorted array the middle element (if odd number of elements), or the first of the middle 2 elements (if even number of elements)?\\n\\nI think the problem description should define what's the median first."
                    },
                    {
                        "username": "sofusl",
                        "content": "If there\\'s 2 middle elements then the median is the two added together and divided by 2. That\\'s the definition of median they shouldn\\'t include that in the problem description. "
                    }
                ]
            },
            {
                "id": 1572536,
                "content": [
                    {
                        "username": "lugiavn",
                        "content": "Thought I should share the hints here for people that are stuck but still want to solve this. This is my thought process:\\n\\n* Look up definition of median. You want to find the value that bigger than half and smaller than half. In the 1 sorted array, this is the value at index ~n/2, but we have 2 sorted arrays case here.\\n* My first idea is to look at median of the 1st array, and median of the second array, you can easily infer that the median of both must bigger than the min of them and smaller than the max of them, hence you can eliminate half of each array (i.e. left half of the array with smaller median).\\n* Now we are looking for a O(log(n+m)) solution, we want to eliminate half (or some fixed percentage) each iteration.\\n* So the goal is try to eliminate as many as possible while keeping track of what have been eliminated to balance the bigger half and the smaller half, I reached a dead end with this process.\\n\\nWhat works for me:\\n* 1st hint: from above, I came to realize to solve this, I should approach a more generalize problem: instead of finding the median, find the x-th position value (basically bigger than x other values and smaller than (n+m-x-1) other values). if that's solved, then the median will just be x=(n+m)/2; in case n+m is not even, use floor and ceiling, and then average.\\n* 2nd hint: no need trying to eliminate from both side, I only try to eliminate the left side. My recursive solution reduces x each time, till it reaches x = 0 (basic case)\\n* 3rd hint: inspired by the 1st elimination attempt, my solution is: pick the index i1 for 1st array and index i2 for 2nd array, in a clever way, such that when comparing these 2 values, you can eliminate 1st i1 values of 1st array or the 1st i2 values of 2nd array."
                    },
                    {
                        "username": "premish",
                        "content": "It would have been great of you would have given clear examples for median of 2 sorted arrays."
                    },
                    {
                        "username": "bparanj",
                        "content": "Some examples for clarity:\\n\\nExample 1:\\n\\nInput:\\nnums1 = [1, 3]\\nnums2 = [2]\\n\\nThe merged array would be [1, 2, 3], and the median is 2.\\n\\nExample 2:\\n\\nInput:\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\n\\nThe merged array would be [1, 2, 3, 4], and since it\\'s an even-sized array, we take the average of the two middle numbers. So, the median is (2 + 3) / 2 = 2.5.\\n\\nExample 3:\\n\\nInput:\\nnums1 = [1, 5, 9]\\nnums2 = [2, 6, 10]\\n\\nThe merged array would be [1, 2, 5, 6, 9, 10]. Since there are 6 elements, we take the average of the 3rd and 4th elements, which are 5 and 6. So, the median is (5 + 6) / 2 = 5.5.\\n\\nExample 4:\\n\\nInput:\\nnums1 = [1, 7, 9]\\nnums2 = [10, 11]\\n\\nThe merged array would be [1, 7, 9, 10, 11]. As there are 5 elements, the median is the middle element, which is 9.\\n\\nThese examples show how to find the median for two sorted arrays. They represent different scenarios, including even- and odd-sized merged arrays, and they demonstrate how to calculate the median in each scenario.\\n"
                    },
                    {
                        "username": "bloodytiger",
                        "content": "Why the test case with nums1=[3,4] and nums2=[] have median = 3.00000 whereas it should be 3.50000?"
                    },
                    {
                        "username": "pavan_kumar599",
                        "content": "nums=sort(nums1+nums2)/total no.of.elements i.e., 3+4/2==7/2==3.50000"
                    },
                    {
                        "username": "ap2107",
                        "content": "Why do we need to swap nums1 and nums2 if sizeof(nums1)<sizeof(nums2).\\nIf I don\\'t do that it gives runtime error for the case \\n[2]\\n[]\\nbut I am not getting why."
                    },
                    {
                        "username": "bparanj",
                        "content": "If the size of nums1 is smaller than the size of nums2, we swap them so that the binary search always happens on the smaller array (nums1). It is an optimization step that reduces the time complexity of the algorithm by reducing the search space. \\n\\nWhen dealing with the case nums1 = [2] and nums2 = [], if you didn\\'t perform the swap, you might be running into issues because your binary search or indexing might be trying to access elements of an empty array (nums2 in this case). This will cause a runtime error because you\\'re trying to access a location that doesn\\'t exist. \\n\\nBy ensuring nums1 is the smallest array, you ensure that binary search is always performed on a non-empty array, which avoids runtime errors. \\n\\nRemember, the core principle here is to conduct the binary search on the smaller array. This not only optimizes the algorithm but also prevents potential errors when one of the arrays is empty."
                    },
                    {
                        "username": "Krixen",
                        "content": "Hello, Can someone explain to me how this is the answer?\\n\\nInput\\n[3]\\n[-2,-1]\\nOutput\\n0.75\\nExpected\\n-1.0\\n\\nMy output is .75. the median of nums1 is 3, the median of nums2 is -1.5. Therefore (median 1 + mediant 2 / 2) = .75. How do they get -1?\\n\\nThanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your confusion seems to stem from a misunderstanding of the definition of the median for an aggregated set, rather than individual medians.\\n\\nIn this question, we\\'re looking for the median of the combined sorted array, not the average of the medians of the individual arrays. This is a key difference.\\n\\nLet\\'s see how it works with your example:\\n\\n- nums1 = [3]\\n- nums2 = [-2, -1]\\n\\nWhen you combine these arrays, you get: \\n\\ncombined = [-2, -1, 3]\\n\\nThe median of this combined array is the middle element, which is -1, not 0.75.\\n\\nSo, the expected output of -1 is correct because -1 is the median of the combined sorted array, not the average of the individual medians. The median is defined as the value separating the higher half from the lower half of a data sample. It does not mean averaging medians of individual sets. \\n"
                    },
                    {
                        "username": "neapasianle",
                        "content": "merge and sort the lists to `[-2,-1,3]` then see the middle value which is `-1`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "merged and sorted list for [3] and [-1, -2] is [-2, -1, 3] and the median is -1.0\\n"
                    },
                    {
                        "username": "jonj715",
                        "content": "Your equation for the median of the sorted array is wrong. You cannot average the separate medians to get the overall median."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "2700 different test cases and none of them challenge the good old `sorted(nums1 + nums2)`"
                    },
                    {
                        "username": "artursapek",
                        "content": "lmao"
                    },
                    {
                        "username": "bryanahusna",
                        "content": "So how do we solve it? Well, median is the element in the middle of sorted array. So we can just combine both of the two arrays and create one single array, and then call the sort method. The fastest sort algorithm is quicksort, and it takes O(n log(n)) time complexity, or O((m+n) log(m+n)) in this case.\\n\\n**Hold On...**\\n\\nThe question says that the time complexity should be O(m+n). With the previous method, it takes O((m+n) log (m+n)) which is slower than that. So this method is not feasible.\\n\\n**But...**\\n\\nWe can do better than that since the two arrays are sorted. If you have ever taken \"Algorithm Strategy\" course, you may have encountered the divide and conquer strategy. One of algorithms that uses this kind of strategy is merge sort. So merge sort takes 3 steps, that is:\\n1. Divide the input array into two subarrays\\n2. Sort each of them using recursion\\n3. Combine the two sorted subarrays\\n\\nThe given arrays in the problem are already sorted, so we can skip step 1 and 2. All we have to do is doing the third step, no recursion is needed since all we have to do is combining the arrays (recursion takes place in step 2). This combining step only cost O(m + n) in our case.\\n\\nLet arr1, arr2, and arr (our merged array). m is the arr1\\'s length, n is the arr2\\'s length, i j and k are index for arr1 arr2 and arr, respectively. You must allocate arr for size m+n (int arr[m+n] in C++). The combine step to sort ascendingly the two arrays is:\\n1. if arr1 already end, fill arr with arr2\\n\\telse if arr2 already end, fill arr with arr1\\n\\telse if element of the first array at index i is smaller than element of the second at index j, add arr1[i] to arr\\n\\telse add the elemen of the second at index j to arr.\\n2. repeat step 1 until the merged array is filled with all elements from arr1 and arr2\\n\\nThe pseudocode is:\\n1. if **i == m**, then **arr[k] = arr2[j]**. increment both j and k  (fill the rest with the second array)\\n\\telse if **j == m**, then **arr[k] = arr1[i]**. increment both i and k (fill the rest with the first array)\\n\\telse if **arr1[i] <= arr[2]**, then **arr[k] = arr1[i]**. increment both i and k\\n   else **arr[k] = arr2[j]**. increment both j and k\\n2. Repeat step 1 until k is equal to m+n (all elements already copied)\\n\\nCongratulation, you have a merged and sorted array. You can now just return the median of the sorted array, and I think you have already know how to do it (return the element in the middle of the array, or if it is even calculate the average of the two elements in the middle)."
                    },
                    {
                        "username": "parismania",
                        "content": "If you merge both arrays, your complexity is O(m+n). The description requires O(log(m+n)). Hence, your solution does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "lololololol"
                    },
                    {
                        "username": "selsel37",
                        "content": "I solved this problem as comparing and merge until it finds the mid. And time complexity should be O(m+n) by theory I think. \\nI submit multiple of times with same code, and my code is pretty faster (related to time that we can see when we submited, like percentage and time) than when I used binary search algorithm which time complexity should be O(min(log m, log n)) by the theory. I am not sure how this can be happen. Is it just happend by test cases or it\\'s just theory or am I misunderstanding about time complexited of bigO? I am not sure how this can be happend.  Colud someone please explain about this?"
                    },
                    {
                        "username": "gojedan98",
                        "content": "My intuition is that it could be easier to load cache lines for the linear solution as opposed to binary search which is a random access pattern :shrugh:"
                    },
                    {
                        "username": "huowa222",
                        "content": "I complaint..  so many edge cases..."
                    },
                    {
                        "username": "robyowen",
                        "content": "Isn't median of a sorted array the middle element (if odd number of elements), or the first of the middle 2 elements (if even number of elements)?\\n\\nI think the problem description should define what's the median first."
                    },
                    {
                        "username": "sofusl",
                        "content": "If there\\'s 2 middle elements then the median is the two added together and divided by 2. That\\'s the definition of median they shouldn\\'t include that in the problem description. "
                    }
                ]
            },
            {
                "id": 1570971,
                "content": [
                    {
                        "username": "lugiavn",
                        "content": "Thought I should share the hints here for people that are stuck but still want to solve this. This is my thought process:\\n\\n* Look up definition of median. You want to find the value that bigger than half and smaller than half. In the 1 sorted array, this is the value at index ~n/2, but we have 2 sorted arrays case here.\\n* My first idea is to look at median of the 1st array, and median of the second array, you can easily infer that the median of both must bigger than the min of them and smaller than the max of them, hence you can eliminate half of each array (i.e. left half of the array with smaller median).\\n* Now we are looking for a O(log(n+m)) solution, we want to eliminate half (or some fixed percentage) each iteration.\\n* So the goal is try to eliminate as many as possible while keeping track of what have been eliminated to balance the bigger half and the smaller half, I reached a dead end with this process.\\n\\nWhat works for me:\\n* 1st hint: from above, I came to realize to solve this, I should approach a more generalize problem: instead of finding the median, find the x-th position value (basically bigger than x other values and smaller than (n+m-x-1) other values). if that's solved, then the median will just be x=(n+m)/2; in case n+m is not even, use floor and ceiling, and then average.\\n* 2nd hint: no need trying to eliminate from both side, I only try to eliminate the left side. My recursive solution reduces x each time, till it reaches x = 0 (basic case)\\n* 3rd hint: inspired by the 1st elimination attempt, my solution is: pick the index i1 for 1st array and index i2 for 2nd array, in a clever way, such that when comparing these 2 values, you can eliminate 1st i1 values of 1st array or the 1st i2 values of 2nd array."
                    },
                    {
                        "username": "premish",
                        "content": "It would have been great of you would have given clear examples for median of 2 sorted arrays."
                    },
                    {
                        "username": "bparanj",
                        "content": "Some examples for clarity:\\n\\nExample 1:\\n\\nInput:\\nnums1 = [1, 3]\\nnums2 = [2]\\n\\nThe merged array would be [1, 2, 3], and the median is 2.\\n\\nExample 2:\\n\\nInput:\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\n\\nThe merged array would be [1, 2, 3, 4], and since it\\'s an even-sized array, we take the average of the two middle numbers. So, the median is (2 + 3) / 2 = 2.5.\\n\\nExample 3:\\n\\nInput:\\nnums1 = [1, 5, 9]\\nnums2 = [2, 6, 10]\\n\\nThe merged array would be [1, 2, 5, 6, 9, 10]. Since there are 6 elements, we take the average of the 3rd and 4th elements, which are 5 and 6. So, the median is (5 + 6) / 2 = 5.5.\\n\\nExample 4:\\n\\nInput:\\nnums1 = [1, 7, 9]\\nnums2 = [10, 11]\\n\\nThe merged array would be [1, 7, 9, 10, 11]. As there are 5 elements, the median is the middle element, which is 9.\\n\\nThese examples show how to find the median for two sorted arrays. They represent different scenarios, including even- and odd-sized merged arrays, and they demonstrate how to calculate the median in each scenario.\\n"
                    },
                    {
                        "username": "bloodytiger",
                        "content": "Why the test case with nums1=[3,4] and nums2=[] have median = 3.00000 whereas it should be 3.50000?"
                    },
                    {
                        "username": "pavan_kumar599",
                        "content": "nums=sort(nums1+nums2)/total no.of.elements i.e., 3+4/2==7/2==3.50000"
                    },
                    {
                        "username": "ap2107",
                        "content": "Why do we need to swap nums1 and nums2 if sizeof(nums1)<sizeof(nums2).\\nIf I don\\'t do that it gives runtime error for the case \\n[2]\\n[]\\nbut I am not getting why."
                    },
                    {
                        "username": "bparanj",
                        "content": "If the size of nums1 is smaller than the size of nums2, we swap them so that the binary search always happens on the smaller array (nums1). It is an optimization step that reduces the time complexity of the algorithm by reducing the search space. \\n\\nWhen dealing with the case nums1 = [2] and nums2 = [], if you didn\\'t perform the swap, you might be running into issues because your binary search or indexing might be trying to access elements of an empty array (nums2 in this case). This will cause a runtime error because you\\'re trying to access a location that doesn\\'t exist. \\n\\nBy ensuring nums1 is the smallest array, you ensure that binary search is always performed on a non-empty array, which avoids runtime errors. \\n\\nRemember, the core principle here is to conduct the binary search on the smaller array. This not only optimizes the algorithm but also prevents potential errors when one of the arrays is empty."
                    },
                    {
                        "username": "Krixen",
                        "content": "Hello, Can someone explain to me how this is the answer?\\n\\nInput\\n[3]\\n[-2,-1]\\nOutput\\n0.75\\nExpected\\n-1.0\\n\\nMy output is .75. the median of nums1 is 3, the median of nums2 is -1.5. Therefore (median 1 + mediant 2 / 2) = .75. How do they get -1?\\n\\nThanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your confusion seems to stem from a misunderstanding of the definition of the median for an aggregated set, rather than individual medians.\\n\\nIn this question, we\\'re looking for the median of the combined sorted array, not the average of the medians of the individual arrays. This is a key difference.\\n\\nLet\\'s see how it works with your example:\\n\\n- nums1 = [3]\\n- nums2 = [-2, -1]\\n\\nWhen you combine these arrays, you get: \\n\\ncombined = [-2, -1, 3]\\n\\nThe median of this combined array is the middle element, which is -1, not 0.75.\\n\\nSo, the expected output of -1 is correct because -1 is the median of the combined sorted array, not the average of the individual medians. The median is defined as the value separating the higher half from the lower half of a data sample. It does not mean averaging medians of individual sets. \\n"
                    },
                    {
                        "username": "neapasianle",
                        "content": "merge and sort the lists to `[-2,-1,3]` then see the middle value which is `-1`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "merged and sorted list for [3] and [-1, -2] is [-2, -1, 3] and the median is -1.0\\n"
                    },
                    {
                        "username": "jonj715",
                        "content": "Your equation for the median of the sorted array is wrong. You cannot average the separate medians to get the overall median."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "2700 different test cases and none of them challenge the good old `sorted(nums1 + nums2)`"
                    },
                    {
                        "username": "artursapek",
                        "content": "lmao"
                    },
                    {
                        "username": "bryanahusna",
                        "content": "So how do we solve it? Well, median is the element in the middle of sorted array. So we can just combine both of the two arrays and create one single array, and then call the sort method. The fastest sort algorithm is quicksort, and it takes O(n log(n)) time complexity, or O((m+n) log(m+n)) in this case.\\n\\n**Hold On...**\\n\\nThe question says that the time complexity should be O(m+n). With the previous method, it takes O((m+n) log (m+n)) which is slower than that. So this method is not feasible.\\n\\n**But...**\\n\\nWe can do better than that since the two arrays are sorted. If you have ever taken \"Algorithm Strategy\" course, you may have encountered the divide and conquer strategy. One of algorithms that uses this kind of strategy is merge sort. So merge sort takes 3 steps, that is:\\n1. Divide the input array into two subarrays\\n2. Sort each of them using recursion\\n3. Combine the two sorted subarrays\\n\\nThe given arrays in the problem are already sorted, so we can skip step 1 and 2. All we have to do is doing the third step, no recursion is needed since all we have to do is combining the arrays (recursion takes place in step 2). This combining step only cost O(m + n) in our case.\\n\\nLet arr1, arr2, and arr (our merged array). m is the arr1\\'s length, n is the arr2\\'s length, i j and k are index for arr1 arr2 and arr, respectively. You must allocate arr for size m+n (int arr[m+n] in C++). The combine step to sort ascendingly the two arrays is:\\n1. if arr1 already end, fill arr with arr2\\n\\telse if arr2 already end, fill arr with arr1\\n\\telse if element of the first array at index i is smaller than element of the second at index j, add arr1[i] to arr\\n\\telse add the elemen of the second at index j to arr.\\n2. repeat step 1 until the merged array is filled with all elements from arr1 and arr2\\n\\nThe pseudocode is:\\n1. if **i == m**, then **arr[k] = arr2[j]**. increment both j and k  (fill the rest with the second array)\\n\\telse if **j == m**, then **arr[k] = arr1[i]**. increment both i and k (fill the rest with the first array)\\n\\telse if **arr1[i] <= arr[2]**, then **arr[k] = arr1[i]**. increment both i and k\\n   else **arr[k] = arr2[j]**. increment both j and k\\n2. Repeat step 1 until k is equal to m+n (all elements already copied)\\n\\nCongratulation, you have a merged and sorted array. You can now just return the median of the sorted array, and I think you have already know how to do it (return the element in the middle of the array, or if it is even calculate the average of the two elements in the middle)."
                    },
                    {
                        "username": "parismania",
                        "content": "If you merge both arrays, your complexity is O(m+n). The description requires O(log(m+n)). Hence, your solution does not meet the required complexity."
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "lololololol"
                    },
                    {
                        "username": "selsel37",
                        "content": "I solved this problem as comparing and merge until it finds the mid. And time complexity should be O(m+n) by theory I think. \\nI submit multiple of times with same code, and my code is pretty faster (related to time that we can see when we submited, like percentage and time) than when I used binary search algorithm which time complexity should be O(min(log m, log n)) by the theory. I am not sure how this can be happen. Is it just happend by test cases or it\\'s just theory or am I misunderstanding about time complexited of bigO? I am not sure how this can be happend.  Colud someone please explain about this?"
                    },
                    {
                        "username": "gojedan98",
                        "content": "My intuition is that it could be easier to load cache lines for the linear solution as opposed to binary search which is a random access pattern :shrugh:"
                    },
                    {
                        "username": "huowa222",
                        "content": "I complaint..  so many edge cases..."
                    },
                    {
                        "username": "robyowen",
                        "content": "Isn't median of a sorted array the middle element (if odd number of elements), or the first of the middle 2 elements (if even number of elements)?\\n\\nI think the problem description should define what's the median first."
                    },
                    {
                        "username": "sofusl",
                        "content": "If there\\'s 2 middle elements then the median is the two added together and divided by 2. That\\'s the definition of median they shouldn\\'t include that in the problem description. "
                    }
                ]
            },
            {
                "id": 1568408,
                "content": [
                    {
                        "username": "shi_julie",
                        "content": "So I can theoretically solve this problem. But I ended up not able to solve it because there is a lot of conditions for odd and even lengths of both input and that\\'s killing me lol"
                    },
                    {
                        "username": "jonj715",
                        "content": "Don\\'t worry about the odd/evenness of the inputs, just the output"
                    },
                    {
                        "username": "ganesh227",
                        "content": "I wrote a medium article explaining every solution in simple terms... [read here](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) hope you like it."
                    },
                    {
                        "username": "whythis",
                        "content": "The only reason this question is \"hard\" is that it is so badly explained. Just write it like this. Find the median of the content of two list of numbers. Otherwise it can mean many things, such as ex the median of the amount of numbers in 2 lists."
                    },
                    {
                        "username": "leeheng86",
                        "content": "I play OJ with c++, but I got wrong answer show in OJ but the code outputs correct answer in my computer.\\nI simply compile with g++ (Debian 4.7.2-5) 4.7.2 without any flags.\\nI want know the OJ running environment(OS, compiler, version, flags) to repruduce the error.\\nThanks!!!"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why is it Hard?"
                    },
                    {
                        "username": "luanct",
                        "content": "Because of the O(log (m+n)) TC requirement"
                    },
                    {
                        "username": "gkpani97",
                        "content": "After avoiding this question through my whole life, finally, today I will look up its solution. "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "why is this Q\\'s hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Because of the O(log(m+n)) requirement."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "God save the person getting this question in an interview."
                    },
                    {
                        "username": "supertangx",
                        "content": "Recent interview\\nQuestion 1: find median in two sorted arrays\\nQuestion 2: find median in a BST  https://www.geeksforgeeks.org/find-median-bst-time-o1-space/"
                    },
                    {
                        "username": "Johnnius_",
                        "content": "There is a naive solution where you append two arrays together, sort it and find median of merged array. This has time complexity of `O((m+n) log(m+n))`. Unfortunately, this is much faster (at least in python) than intended solution (e.g. merge two arrays in `O(m+n)` or binary search in `O(log(m+n))`). If `m+n` would be bigger (such as `1 000 000`), runtime would better match theoretical time complexity."
                    }
                ]
            },
            {
                "id": 1570772,
                "content": [
                    {
                        "username": "shi_julie",
                        "content": "So I can theoretically solve this problem. But I ended up not able to solve it because there is a lot of conditions for odd and even lengths of both input and that\\'s killing me lol"
                    },
                    {
                        "username": "jonj715",
                        "content": "Don\\'t worry about the odd/evenness of the inputs, just the output"
                    },
                    {
                        "username": "ganesh227",
                        "content": "I wrote a medium article explaining every solution in simple terms... [read here](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) hope you like it."
                    },
                    {
                        "username": "whythis",
                        "content": "The only reason this question is \"hard\" is that it is so badly explained. Just write it like this. Find the median of the content of two list of numbers. Otherwise it can mean many things, such as ex the median of the amount of numbers in 2 lists."
                    },
                    {
                        "username": "leeheng86",
                        "content": "I play OJ with c++, but I got wrong answer show in OJ but the code outputs correct answer in my computer.\\nI simply compile with g++ (Debian 4.7.2-5) 4.7.2 without any flags.\\nI want know the OJ running environment(OS, compiler, version, flags) to repruduce the error.\\nThanks!!!"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why is it Hard?"
                    },
                    {
                        "username": "luanct",
                        "content": "Because of the O(log (m+n)) TC requirement"
                    },
                    {
                        "username": "gkpani97",
                        "content": "After avoiding this question through my whole life, finally, today I will look up its solution. "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "why is this Q\\'s hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Because of the O(log(m+n)) requirement."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "God save the person getting this question in an interview."
                    },
                    {
                        "username": "supertangx",
                        "content": "Recent interview\\nQuestion 1: find median in two sorted arrays\\nQuestion 2: find median in a BST  https://www.geeksforgeeks.org/find-median-bst-time-o1-space/"
                    },
                    {
                        "username": "Johnnius_",
                        "content": "There is a naive solution where you append two arrays together, sort it and find median of merged array. This has time complexity of `O((m+n) log(m+n))`. Unfortunately, this is much faster (at least in python) than intended solution (e.g. merge two arrays in `O(m+n)` or binary search in `O(log(m+n))`). If `m+n` would be bigger (such as `1 000 000`), runtime would better match theoretical time complexity."
                    }
                ]
            },
            {
                "id": 1567387,
                "content": [
                    {
                        "username": "shi_julie",
                        "content": "So I can theoretically solve this problem. But I ended up not able to solve it because there is a lot of conditions for odd and even lengths of both input and that\\'s killing me lol"
                    },
                    {
                        "username": "jonj715",
                        "content": "Don\\'t worry about the odd/evenness of the inputs, just the output"
                    },
                    {
                        "username": "ganesh227",
                        "content": "I wrote a medium article explaining every solution in simple terms... [read here](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) hope you like it."
                    },
                    {
                        "username": "whythis",
                        "content": "The only reason this question is \"hard\" is that it is so badly explained. Just write it like this. Find the median of the content of two list of numbers. Otherwise it can mean many things, such as ex the median of the amount of numbers in 2 lists."
                    },
                    {
                        "username": "leeheng86",
                        "content": "I play OJ with c++, but I got wrong answer show in OJ but the code outputs correct answer in my computer.\\nI simply compile with g++ (Debian 4.7.2-5) 4.7.2 without any flags.\\nI want know the OJ running environment(OS, compiler, version, flags) to repruduce the error.\\nThanks!!!"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why is it Hard?"
                    },
                    {
                        "username": "luanct",
                        "content": "Because of the O(log (m+n)) TC requirement"
                    },
                    {
                        "username": "gkpani97",
                        "content": "After avoiding this question through my whole life, finally, today I will look up its solution. "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "why is this Q\\'s hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Because of the O(log(m+n)) requirement."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "God save the person getting this question in an interview."
                    },
                    {
                        "username": "supertangx",
                        "content": "Recent interview\\nQuestion 1: find median in two sorted arrays\\nQuestion 2: find median in a BST  https://www.geeksforgeeks.org/find-median-bst-time-o1-space/"
                    },
                    {
                        "username": "Johnnius_",
                        "content": "There is a naive solution where you append two arrays together, sort it and find median of merged array. This has time complexity of `O((m+n) log(m+n))`. Unfortunately, this is much faster (at least in python) than intended solution (e.g. merge two arrays in `O(m+n)` or binary search in `O(log(m+n))`). If `m+n` would be bigger (such as `1 000 000`), runtime would better match theoretical time complexity."
                    }
                ]
            },
            {
                "id": 1567789,
                "content": [
                    {
                        "username": "shi_julie",
                        "content": "So I can theoretically solve this problem. But I ended up not able to solve it because there is a lot of conditions for odd and even lengths of both input and that\\'s killing me lol"
                    },
                    {
                        "username": "jonj715",
                        "content": "Don\\'t worry about the odd/evenness of the inputs, just the output"
                    },
                    {
                        "username": "ganesh227",
                        "content": "I wrote a medium article explaining every solution in simple terms... [read here](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) hope you like it."
                    },
                    {
                        "username": "whythis",
                        "content": "The only reason this question is \"hard\" is that it is so badly explained. Just write it like this. Find the median of the content of two list of numbers. Otherwise it can mean many things, such as ex the median of the amount of numbers in 2 lists."
                    },
                    {
                        "username": "leeheng86",
                        "content": "I play OJ with c++, but I got wrong answer show in OJ but the code outputs correct answer in my computer.\\nI simply compile with g++ (Debian 4.7.2-5) 4.7.2 without any flags.\\nI want know the OJ running environment(OS, compiler, version, flags) to repruduce the error.\\nThanks!!!"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why is it Hard?"
                    },
                    {
                        "username": "luanct",
                        "content": "Because of the O(log (m+n)) TC requirement"
                    },
                    {
                        "username": "gkpani97",
                        "content": "After avoiding this question through my whole life, finally, today I will look up its solution. "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "why is this Q\\'s hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Because of the O(log(m+n)) requirement."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "God save the person getting this question in an interview."
                    },
                    {
                        "username": "supertangx",
                        "content": "Recent interview\\nQuestion 1: find median in two sorted arrays\\nQuestion 2: find median in a BST  https://www.geeksforgeeks.org/find-median-bst-time-o1-space/"
                    },
                    {
                        "username": "Johnnius_",
                        "content": "There is a naive solution where you append two arrays together, sort it and find median of merged array. This has time complexity of `O((m+n) log(m+n))`. Unfortunately, this is much faster (at least in python) than intended solution (e.g. merge two arrays in `O(m+n)` or binary search in `O(log(m+n))`). If `m+n` would be bigger (such as `1 000 000`), runtime would better match theoretical time complexity."
                    }
                ]
            },
            {
                "id": 2066787,
                "content": [
                    {
                        "username": "shi_julie",
                        "content": "So I can theoretically solve this problem. But I ended up not able to solve it because there is a lot of conditions for odd and even lengths of both input and that\\'s killing me lol"
                    },
                    {
                        "username": "jonj715",
                        "content": "Don\\'t worry about the odd/evenness of the inputs, just the output"
                    },
                    {
                        "username": "ganesh227",
                        "content": "I wrote a medium article explaining every solution in simple terms... [read here](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) hope you like it."
                    },
                    {
                        "username": "whythis",
                        "content": "The only reason this question is \"hard\" is that it is so badly explained. Just write it like this. Find the median of the content of two list of numbers. Otherwise it can mean many things, such as ex the median of the amount of numbers in 2 lists."
                    },
                    {
                        "username": "leeheng86",
                        "content": "I play OJ with c++, but I got wrong answer show in OJ but the code outputs correct answer in my computer.\\nI simply compile with g++ (Debian 4.7.2-5) 4.7.2 without any flags.\\nI want know the OJ running environment(OS, compiler, version, flags) to repruduce the error.\\nThanks!!!"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why is it Hard?"
                    },
                    {
                        "username": "luanct",
                        "content": "Because of the O(log (m+n)) TC requirement"
                    },
                    {
                        "username": "gkpani97",
                        "content": "After avoiding this question through my whole life, finally, today I will look up its solution. "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "why is this Q\\'s hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Because of the O(log(m+n)) requirement."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "God save the person getting this question in an interview."
                    },
                    {
                        "username": "supertangx",
                        "content": "Recent interview\\nQuestion 1: find median in two sorted arrays\\nQuestion 2: find median in a BST  https://www.geeksforgeeks.org/find-median-bst-time-o1-space/"
                    },
                    {
                        "username": "Johnnius_",
                        "content": "There is a naive solution where you append two arrays together, sort it and find median of merged array. This has time complexity of `O((m+n) log(m+n))`. Unfortunately, this is much faster (at least in python) than intended solution (e.g. merge two arrays in `O(m+n)` or binary search in `O(log(m+n))`). If `m+n` would be bigger (such as `1 000 000`), runtime would better match theoretical time complexity."
                    }
                ]
            },
            {
                "id": 2066566,
                "content": [
                    {
                        "username": "shi_julie",
                        "content": "So I can theoretically solve this problem. But I ended up not able to solve it because there is a lot of conditions for odd and even lengths of both input and that\\'s killing me lol"
                    },
                    {
                        "username": "jonj715",
                        "content": "Don\\'t worry about the odd/evenness of the inputs, just the output"
                    },
                    {
                        "username": "ganesh227",
                        "content": "I wrote a medium article explaining every solution in simple terms... [read here](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) hope you like it."
                    },
                    {
                        "username": "whythis",
                        "content": "The only reason this question is \"hard\" is that it is so badly explained. Just write it like this. Find the median of the content of two list of numbers. Otherwise it can mean many things, such as ex the median of the amount of numbers in 2 lists."
                    },
                    {
                        "username": "leeheng86",
                        "content": "I play OJ with c++, but I got wrong answer show in OJ but the code outputs correct answer in my computer.\\nI simply compile with g++ (Debian 4.7.2-5) 4.7.2 without any flags.\\nI want know the OJ running environment(OS, compiler, version, flags) to repruduce the error.\\nThanks!!!"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why is it Hard?"
                    },
                    {
                        "username": "luanct",
                        "content": "Because of the O(log (m+n)) TC requirement"
                    },
                    {
                        "username": "gkpani97",
                        "content": "After avoiding this question through my whole life, finally, today I will look up its solution. "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "why is this Q\\'s hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Because of the O(log(m+n)) requirement."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "God save the person getting this question in an interview."
                    },
                    {
                        "username": "supertangx",
                        "content": "Recent interview\\nQuestion 1: find median in two sorted arrays\\nQuestion 2: find median in a BST  https://www.geeksforgeeks.org/find-median-bst-time-o1-space/"
                    },
                    {
                        "username": "Johnnius_",
                        "content": "There is a naive solution where you append two arrays together, sort it and find median of merged array. This has time complexity of `O((m+n) log(m+n))`. Unfortunately, this is much faster (at least in python) than intended solution (e.g. merge two arrays in `O(m+n)` or binary search in `O(log(m+n))`). If `m+n` would be bigger (such as `1 000 000`), runtime would better match theoretical time complexity."
                    }
                ]
            },
            {
                "id": 2066556,
                "content": [
                    {
                        "username": "shi_julie",
                        "content": "So I can theoretically solve this problem. But I ended up not able to solve it because there is a lot of conditions for odd and even lengths of both input and that\\'s killing me lol"
                    },
                    {
                        "username": "jonj715",
                        "content": "Don\\'t worry about the odd/evenness of the inputs, just the output"
                    },
                    {
                        "username": "ganesh227",
                        "content": "I wrote a medium article explaining every solution in simple terms... [read here](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) hope you like it."
                    },
                    {
                        "username": "whythis",
                        "content": "The only reason this question is \"hard\" is that it is so badly explained. Just write it like this. Find the median of the content of two list of numbers. Otherwise it can mean many things, such as ex the median of the amount of numbers in 2 lists."
                    },
                    {
                        "username": "leeheng86",
                        "content": "I play OJ with c++, but I got wrong answer show in OJ but the code outputs correct answer in my computer.\\nI simply compile with g++ (Debian 4.7.2-5) 4.7.2 without any flags.\\nI want know the OJ running environment(OS, compiler, version, flags) to repruduce the error.\\nThanks!!!"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why is it Hard?"
                    },
                    {
                        "username": "luanct",
                        "content": "Because of the O(log (m+n)) TC requirement"
                    },
                    {
                        "username": "gkpani97",
                        "content": "After avoiding this question through my whole life, finally, today I will look up its solution. "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "why is this Q\\'s hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Because of the O(log(m+n)) requirement."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "God save the person getting this question in an interview."
                    },
                    {
                        "username": "supertangx",
                        "content": "Recent interview\\nQuestion 1: find median in two sorted arrays\\nQuestion 2: find median in a BST  https://www.geeksforgeeks.org/find-median-bst-time-o1-space/"
                    },
                    {
                        "username": "Johnnius_",
                        "content": "There is a naive solution where you append two arrays together, sort it and find median of merged array. This has time complexity of `O((m+n) log(m+n))`. Unfortunately, this is much faster (at least in python) than intended solution (e.g. merge two arrays in `O(m+n)` or binary search in `O(log(m+n))`). If `m+n` would be bigger (such as `1 000 000`), runtime would better match theoretical time complexity."
                    }
                ]
            },
            {
                "id": 2066554,
                "content": [
                    {
                        "username": "shi_julie",
                        "content": "So I can theoretically solve this problem. But I ended up not able to solve it because there is a lot of conditions for odd and even lengths of both input and that\\'s killing me lol"
                    },
                    {
                        "username": "jonj715",
                        "content": "Don\\'t worry about the odd/evenness of the inputs, just the output"
                    },
                    {
                        "username": "ganesh227",
                        "content": "I wrote a medium article explaining every solution in simple terms... [read here](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) hope you like it."
                    },
                    {
                        "username": "whythis",
                        "content": "The only reason this question is \"hard\" is that it is so badly explained. Just write it like this. Find the median of the content of two list of numbers. Otherwise it can mean many things, such as ex the median of the amount of numbers in 2 lists."
                    },
                    {
                        "username": "leeheng86",
                        "content": "I play OJ with c++, but I got wrong answer show in OJ but the code outputs correct answer in my computer.\\nI simply compile with g++ (Debian 4.7.2-5) 4.7.2 without any flags.\\nI want know the OJ running environment(OS, compiler, version, flags) to repruduce the error.\\nThanks!!!"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why is it Hard?"
                    },
                    {
                        "username": "luanct",
                        "content": "Because of the O(log (m+n)) TC requirement"
                    },
                    {
                        "username": "gkpani97",
                        "content": "After avoiding this question through my whole life, finally, today I will look up its solution. "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "why is this Q\\'s hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Because of the O(log(m+n)) requirement."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "God save the person getting this question in an interview."
                    },
                    {
                        "username": "supertangx",
                        "content": "Recent interview\\nQuestion 1: find median in two sorted arrays\\nQuestion 2: find median in a BST  https://www.geeksforgeeks.org/find-median-bst-time-o1-space/"
                    },
                    {
                        "username": "Johnnius_",
                        "content": "There is a naive solution where you append two arrays together, sort it and find median of merged array. This has time complexity of `O((m+n) log(m+n))`. Unfortunately, this is much faster (at least in python) than intended solution (e.g. merge two arrays in `O(m+n)` or binary search in `O(log(m+n))`). If `m+n` would be bigger (such as `1 000 000`), runtime would better match theoretical time complexity."
                    }
                ]
            },
            {
                "id": 2045336,
                "content": [
                    {
                        "username": "shi_julie",
                        "content": "So I can theoretically solve this problem. But I ended up not able to solve it because there is a lot of conditions for odd and even lengths of both input and that\\'s killing me lol"
                    },
                    {
                        "username": "jonj715",
                        "content": "Don\\'t worry about the odd/evenness of the inputs, just the output"
                    },
                    {
                        "username": "ganesh227",
                        "content": "I wrote a medium article explaining every solution in simple terms... [read here](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) hope you like it."
                    },
                    {
                        "username": "whythis",
                        "content": "The only reason this question is \"hard\" is that it is so badly explained. Just write it like this. Find the median of the content of two list of numbers. Otherwise it can mean many things, such as ex the median of the amount of numbers in 2 lists."
                    },
                    {
                        "username": "leeheng86",
                        "content": "I play OJ with c++, but I got wrong answer show in OJ but the code outputs correct answer in my computer.\\nI simply compile with g++ (Debian 4.7.2-5) 4.7.2 without any flags.\\nI want know the OJ running environment(OS, compiler, version, flags) to repruduce the error.\\nThanks!!!"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why is it Hard?"
                    },
                    {
                        "username": "luanct",
                        "content": "Because of the O(log (m+n)) TC requirement"
                    },
                    {
                        "username": "gkpani97",
                        "content": "After avoiding this question through my whole life, finally, today I will look up its solution. "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "why is this Q\\'s hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Because of the O(log(m+n)) requirement."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "God save the person getting this question in an interview."
                    },
                    {
                        "username": "supertangx",
                        "content": "Recent interview\\nQuestion 1: find median in two sorted arrays\\nQuestion 2: find median in a BST  https://www.geeksforgeeks.org/find-median-bst-time-o1-space/"
                    },
                    {
                        "username": "Johnnius_",
                        "content": "There is a naive solution where you append two arrays together, sort it and find median of merged array. This has time complexity of `O((m+n) log(m+n))`. Unfortunately, this is much faster (at least in python) than intended solution (e.g. merge two arrays in `O(m+n)` or binary search in `O(log(m+n))`). If `m+n` would be bigger (such as `1 000 000`), runtime would better match theoretical time complexity."
                    }
                ]
            },
            {
                "id": 2034091,
                "content": [
                    {
                        "username": "shi_julie",
                        "content": "So I can theoretically solve this problem. But I ended up not able to solve it because there is a lot of conditions for odd and even lengths of both input and that\\'s killing me lol"
                    },
                    {
                        "username": "jonj715",
                        "content": "Don\\'t worry about the odd/evenness of the inputs, just the output"
                    },
                    {
                        "username": "ganesh227",
                        "content": "I wrote a medium article explaining every solution in simple terms... [read here](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) hope you like it."
                    },
                    {
                        "username": "whythis",
                        "content": "The only reason this question is \"hard\" is that it is so badly explained. Just write it like this. Find the median of the content of two list of numbers. Otherwise it can mean many things, such as ex the median of the amount of numbers in 2 lists."
                    },
                    {
                        "username": "leeheng86",
                        "content": "I play OJ with c++, but I got wrong answer show in OJ but the code outputs correct answer in my computer.\\nI simply compile with g++ (Debian 4.7.2-5) 4.7.2 without any flags.\\nI want know the OJ running environment(OS, compiler, version, flags) to repruduce the error.\\nThanks!!!"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why is it Hard?"
                    },
                    {
                        "username": "luanct",
                        "content": "Because of the O(log (m+n)) TC requirement"
                    },
                    {
                        "username": "gkpani97",
                        "content": "After avoiding this question through my whole life, finally, today I will look up its solution. "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "why is this Q\\'s hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Because of the O(log(m+n)) requirement."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "God save the person getting this question in an interview."
                    },
                    {
                        "username": "supertangx",
                        "content": "Recent interview\\nQuestion 1: find median in two sorted arrays\\nQuestion 2: find median in a BST  https://www.geeksforgeeks.org/find-median-bst-time-o1-space/"
                    },
                    {
                        "username": "Johnnius_",
                        "content": "There is a naive solution where you append two arrays together, sort it and find median of merged array. This has time complexity of `O((m+n) log(m+n))`. Unfortunately, this is much faster (at least in python) than intended solution (e.g. merge two arrays in `O(m+n)` or binary search in `O(log(m+n))`). If `m+n` would be bigger (such as `1 000 000`), runtime would better match theoretical time complexity."
                    }
                ]
            },
            {
                "id": 1908054,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "In regards to the logN+M binary search solution, I think I have reached my intellectual limit. Most other hards, after looking at the answer, all make sense. This one has left me scratching my head for days. \n\nAn interviewer asking this question is either looking for some kind of savant, or just trying to get rid of you while making the process look objective. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "from linked list i got an approach of sorting and merging the array so i went with it i just went for it i created an array with [m+n] length if the length is odd then return arr[len/2] and if the  len is even then arr[len/2] + arr[(len/2) - 1]) /2 "
                    },
                    {
                        "username": "dicriptor",
                        "content": "It doesn't look 'hard' really. Maybe 'medium' but not 'hard'. The solution is fairly straightforward and doesn't require knowing tricky algorithms or optimizations. For those who are just ready to solve this remember that to solve this task efficiently you shouldn't create new array, copy merged elements to it and so on. All you need is already here, just stop for some time and think. "
                    },
                    {
                        "username": "beypazari",
                        "content": "This is enough. I didnt used sort() function and my code works without any problem in vs code and returns the true values. When i copy and paste code in here somehow my code raises errors or returns wrong value. When i copy and wrong test case to VS and test my code it returns the true answer. This is just nonsense. I do not recommend this challenge."
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "should be rated as easy"
                    },
                    {
                        "username": "marshel__69",
                        "content": "this should be marked easy"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "for a better understanding to solve it in O(log(min(m, n)) you guys can refer this video https://www.youtube.com/watch?v=ySPX_wTIUQQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of the findMedianSortedArrays function is O(1), since it only uses constant space for variables and does not allocate any additional space for data structures.\\n\\nThe time complexity of the findMedianSortedArrays function is O(log(m+n)), where m and n are the lengths of the two input arrays. This is because the function uses a binary search approach to find the median, which has a time complexity of O(log(n)) for an array of length n. Since the function performs the binary search on one of the input arrays, which has a length of at most m+n, the overall time complexity is O(log(m+n)).\\n\\nIt\\'s worth noting that the time complexity of the findMedianSortedArrays function is optimal, as it\\'s not possible to find the median of two sorted arrays in less than O(log(m+n)) time.\\n"
                    },
                    {
                        "username": "hammoudddd",
                        "content": "I am getting addressSanitizer runtime error in most of my codes. I tried to do it in vs code any other compiler and it worked every time. can somebody tell me why i am getting this runtime error only here in leetcode. \\nthanks "
                    },
                    {
                        "username": "WennyXiong",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n  var nums = nums1.concat(nums2);\\n  var sortedNums = nums.sort((a,b) => a - b);\\n  var medianIndex = nums.length/2\\n  var median = 0;\\n**  //if medianIndex is an integer, meaning the count of number is even, need to calculate the average median**\\n  if (medianIndex === Math.floor(medianIndex)){\\n    median = (sortedNums[medianIndex] + sortedNums[medianIndex - 1]) / 2\\n  } else {\\n    medianIndex = Math.floor(medianIndex);\\n    median = sortedNums[medianIndex];\\n  }\\n  return median;\\n};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, your algorithm does not meet the required complexity, as you concat and sort the input arrays."
                    }
                ]
            },
            {
                "id": 1905605,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "In regards to the logN+M binary search solution, I think I have reached my intellectual limit. Most other hards, after looking at the answer, all make sense. This one has left me scratching my head for days. \n\nAn interviewer asking this question is either looking for some kind of savant, or just trying to get rid of you while making the process look objective. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "from linked list i got an approach of sorting and merging the array so i went with it i just went for it i created an array with [m+n] length if the length is odd then return arr[len/2] and if the  len is even then arr[len/2] + arr[(len/2) - 1]) /2 "
                    },
                    {
                        "username": "dicriptor",
                        "content": "It doesn't look 'hard' really. Maybe 'medium' but not 'hard'. The solution is fairly straightforward and doesn't require knowing tricky algorithms or optimizations. For those who are just ready to solve this remember that to solve this task efficiently you shouldn't create new array, copy merged elements to it and so on. All you need is already here, just stop for some time and think. "
                    },
                    {
                        "username": "beypazari",
                        "content": "This is enough. I didnt used sort() function and my code works without any problem in vs code and returns the true values. When i copy and paste code in here somehow my code raises errors or returns wrong value. When i copy and wrong test case to VS and test my code it returns the true answer. This is just nonsense. I do not recommend this challenge."
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "should be rated as easy"
                    },
                    {
                        "username": "marshel__69",
                        "content": "this should be marked easy"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "for a better understanding to solve it in O(log(min(m, n)) you guys can refer this video https://www.youtube.com/watch?v=ySPX_wTIUQQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of the findMedianSortedArrays function is O(1), since it only uses constant space for variables and does not allocate any additional space for data structures.\\n\\nThe time complexity of the findMedianSortedArrays function is O(log(m+n)), where m and n are the lengths of the two input arrays. This is because the function uses a binary search approach to find the median, which has a time complexity of O(log(n)) for an array of length n. Since the function performs the binary search on one of the input arrays, which has a length of at most m+n, the overall time complexity is O(log(m+n)).\\n\\nIt\\'s worth noting that the time complexity of the findMedianSortedArrays function is optimal, as it\\'s not possible to find the median of two sorted arrays in less than O(log(m+n)) time.\\n"
                    },
                    {
                        "username": "hammoudddd",
                        "content": "I am getting addressSanitizer runtime error in most of my codes. I tried to do it in vs code any other compiler and it worked every time. can somebody tell me why i am getting this runtime error only here in leetcode. \\nthanks "
                    },
                    {
                        "username": "WennyXiong",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n  var nums = nums1.concat(nums2);\\n  var sortedNums = nums.sort((a,b) => a - b);\\n  var medianIndex = nums.length/2\\n  var median = 0;\\n**  //if medianIndex is an integer, meaning the count of number is even, need to calculate the average median**\\n  if (medianIndex === Math.floor(medianIndex)){\\n    median = (sortedNums[medianIndex] + sortedNums[medianIndex - 1]) / 2\\n  } else {\\n    medianIndex = Math.floor(medianIndex);\\n    median = sortedNums[medianIndex];\\n  }\\n  return median;\\n};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, your algorithm does not meet the required complexity, as you concat and sort the input arrays."
                    }
                ]
            },
            {
                "id": 1856593,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "In regards to the logN+M binary search solution, I think I have reached my intellectual limit. Most other hards, after looking at the answer, all make sense. This one has left me scratching my head for days. \n\nAn interviewer asking this question is either looking for some kind of savant, or just trying to get rid of you while making the process look objective. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "from linked list i got an approach of sorting and merging the array so i went with it i just went for it i created an array with [m+n] length if the length is odd then return arr[len/2] and if the  len is even then arr[len/2] + arr[(len/2) - 1]) /2 "
                    },
                    {
                        "username": "dicriptor",
                        "content": "It doesn't look 'hard' really. Maybe 'medium' but not 'hard'. The solution is fairly straightforward and doesn't require knowing tricky algorithms or optimizations. For those who are just ready to solve this remember that to solve this task efficiently you shouldn't create new array, copy merged elements to it and so on. All you need is already here, just stop for some time and think. "
                    },
                    {
                        "username": "beypazari",
                        "content": "This is enough. I didnt used sort() function and my code works without any problem in vs code and returns the true values. When i copy and paste code in here somehow my code raises errors or returns wrong value. When i copy and wrong test case to VS and test my code it returns the true answer. This is just nonsense. I do not recommend this challenge."
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "should be rated as easy"
                    },
                    {
                        "username": "marshel__69",
                        "content": "this should be marked easy"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "for a better understanding to solve it in O(log(min(m, n)) you guys can refer this video https://www.youtube.com/watch?v=ySPX_wTIUQQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of the findMedianSortedArrays function is O(1), since it only uses constant space for variables and does not allocate any additional space for data structures.\\n\\nThe time complexity of the findMedianSortedArrays function is O(log(m+n)), where m and n are the lengths of the two input arrays. This is because the function uses a binary search approach to find the median, which has a time complexity of O(log(n)) for an array of length n. Since the function performs the binary search on one of the input arrays, which has a length of at most m+n, the overall time complexity is O(log(m+n)).\\n\\nIt\\'s worth noting that the time complexity of the findMedianSortedArrays function is optimal, as it\\'s not possible to find the median of two sorted arrays in less than O(log(m+n)) time.\\n"
                    },
                    {
                        "username": "hammoudddd",
                        "content": "I am getting addressSanitizer runtime error in most of my codes. I tried to do it in vs code any other compiler and it worked every time. can somebody tell me why i am getting this runtime error only here in leetcode. \\nthanks "
                    },
                    {
                        "username": "WennyXiong",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n  var nums = nums1.concat(nums2);\\n  var sortedNums = nums.sort((a,b) => a - b);\\n  var medianIndex = nums.length/2\\n  var median = 0;\\n**  //if medianIndex is an integer, meaning the count of number is even, need to calculate the average median**\\n  if (medianIndex === Math.floor(medianIndex)){\\n    median = (sortedNums[medianIndex] + sortedNums[medianIndex - 1]) / 2\\n  } else {\\n    medianIndex = Math.floor(medianIndex);\\n    median = sortedNums[medianIndex];\\n  }\\n  return median;\\n};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, your algorithm does not meet the required complexity, as you concat and sort the input arrays."
                    }
                ]
            },
            {
                "id": 1853619,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "In regards to the logN+M binary search solution, I think I have reached my intellectual limit. Most other hards, after looking at the answer, all make sense. This one has left me scratching my head for days. \n\nAn interviewer asking this question is either looking for some kind of savant, or just trying to get rid of you while making the process look objective. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "from linked list i got an approach of sorting and merging the array so i went with it i just went for it i created an array with [m+n] length if the length is odd then return arr[len/2] and if the  len is even then arr[len/2] + arr[(len/2) - 1]) /2 "
                    },
                    {
                        "username": "dicriptor",
                        "content": "It doesn't look 'hard' really. Maybe 'medium' but not 'hard'. The solution is fairly straightforward and doesn't require knowing tricky algorithms or optimizations. For those who are just ready to solve this remember that to solve this task efficiently you shouldn't create new array, copy merged elements to it and so on. All you need is already here, just stop for some time and think. "
                    },
                    {
                        "username": "beypazari",
                        "content": "This is enough. I didnt used sort() function and my code works without any problem in vs code and returns the true values. When i copy and paste code in here somehow my code raises errors or returns wrong value. When i copy and wrong test case to VS and test my code it returns the true answer. This is just nonsense. I do not recommend this challenge."
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "should be rated as easy"
                    },
                    {
                        "username": "marshel__69",
                        "content": "this should be marked easy"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "for a better understanding to solve it in O(log(min(m, n)) you guys can refer this video https://www.youtube.com/watch?v=ySPX_wTIUQQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of the findMedianSortedArrays function is O(1), since it only uses constant space for variables and does not allocate any additional space for data structures.\\n\\nThe time complexity of the findMedianSortedArrays function is O(log(m+n)), where m and n are the lengths of the two input arrays. This is because the function uses a binary search approach to find the median, which has a time complexity of O(log(n)) for an array of length n. Since the function performs the binary search on one of the input arrays, which has a length of at most m+n, the overall time complexity is O(log(m+n)).\\n\\nIt\\'s worth noting that the time complexity of the findMedianSortedArrays function is optimal, as it\\'s not possible to find the median of two sorted arrays in less than O(log(m+n)) time.\\n"
                    },
                    {
                        "username": "hammoudddd",
                        "content": "I am getting addressSanitizer runtime error in most of my codes. I tried to do it in vs code any other compiler and it worked every time. can somebody tell me why i am getting this runtime error only here in leetcode. \\nthanks "
                    },
                    {
                        "username": "WennyXiong",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n  var nums = nums1.concat(nums2);\\n  var sortedNums = nums.sort((a,b) => a - b);\\n  var medianIndex = nums.length/2\\n  var median = 0;\\n**  //if medianIndex is an integer, meaning the count of number is even, need to calculate the average median**\\n  if (medianIndex === Math.floor(medianIndex)){\\n    median = (sortedNums[medianIndex] + sortedNums[medianIndex - 1]) / 2\\n  } else {\\n    medianIndex = Math.floor(medianIndex);\\n    median = sortedNums[medianIndex];\\n  }\\n  return median;\\n};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, your algorithm does not meet the required complexity, as you concat and sort the input arrays."
                    }
                ]
            },
            {
                "id": 1848477,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "In regards to the logN+M binary search solution, I think I have reached my intellectual limit. Most other hards, after looking at the answer, all make sense. This one has left me scratching my head for days. \n\nAn interviewer asking this question is either looking for some kind of savant, or just trying to get rid of you while making the process look objective. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "from linked list i got an approach of sorting and merging the array so i went with it i just went for it i created an array with [m+n] length if the length is odd then return arr[len/2] and if the  len is even then arr[len/2] + arr[(len/2) - 1]) /2 "
                    },
                    {
                        "username": "dicriptor",
                        "content": "It doesn't look 'hard' really. Maybe 'medium' but not 'hard'. The solution is fairly straightforward and doesn't require knowing tricky algorithms or optimizations. For those who are just ready to solve this remember that to solve this task efficiently you shouldn't create new array, copy merged elements to it and so on. All you need is already here, just stop for some time and think. "
                    },
                    {
                        "username": "beypazari",
                        "content": "This is enough. I didnt used sort() function and my code works without any problem in vs code and returns the true values. When i copy and paste code in here somehow my code raises errors or returns wrong value. When i copy and wrong test case to VS and test my code it returns the true answer. This is just nonsense. I do not recommend this challenge."
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "should be rated as easy"
                    },
                    {
                        "username": "marshel__69",
                        "content": "this should be marked easy"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "for a better understanding to solve it in O(log(min(m, n)) you guys can refer this video https://www.youtube.com/watch?v=ySPX_wTIUQQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of the findMedianSortedArrays function is O(1), since it only uses constant space for variables and does not allocate any additional space for data structures.\\n\\nThe time complexity of the findMedianSortedArrays function is O(log(m+n)), where m and n are the lengths of the two input arrays. This is because the function uses a binary search approach to find the median, which has a time complexity of O(log(n)) for an array of length n. Since the function performs the binary search on one of the input arrays, which has a length of at most m+n, the overall time complexity is O(log(m+n)).\\n\\nIt\\'s worth noting that the time complexity of the findMedianSortedArrays function is optimal, as it\\'s not possible to find the median of two sorted arrays in less than O(log(m+n)) time.\\n"
                    },
                    {
                        "username": "hammoudddd",
                        "content": "I am getting addressSanitizer runtime error in most of my codes. I tried to do it in vs code any other compiler and it worked every time. can somebody tell me why i am getting this runtime error only here in leetcode. \\nthanks "
                    },
                    {
                        "username": "WennyXiong",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n  var nums = nums1.concat(nums2);\\n  var sortedNums = nums.sort((a,b) => a - b);\\n  var medianIndex = nums.length/2\\n  var median = 0;\\n**  //if medianIndex is an integer, meaning the count of number is even, need to calculate the average median**\\n  if (medianIndex === Math.floor(medianIndex)){\\n    median = (sortedNums[medianIndex] + sortedNums[medianIndex - 1]) / 2\\n  } else {\\n    medianIndex = Math.floor(medianIndex);\\n    median = sortedNums[medianIndex];\\n  }\\n  return median;\\n};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, your algorithm does not meet the required complexity, as you concat and sort the input arrays."
                    }
                ]
            },
            {
                "id": 1839335,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "In regards to the logN+M binary search solution, I think I have reached my intellectual limit. Most other hards, after looking at the answer, all make sense. This one has left me scratching my head for days. \n\nAn interviewer asking this question is either looking for some kind of savant, or just trying to get rid of you while making the process look objective. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "from linked list i got an approach of sorting and merging the array so i went with it i just went for it i created an array with [m+n] length if the length is odd then return arr[len/2] and if the  len is even then arr[len/2] + arr[(len/2) - 1]) /2 "
                    },
                    {
                        "username": "dicriptor",
                        "content": "It doesn't look 'hard' really. Maybe 'medium' but not 'hard'. The solution is fairly straightforward and doesn't require knowing tricky algorithms or optimizations. For those who are just ready to solve this remember that to solve this task efficiently you shouldn't create new array, copy merged elements to it and so on. All you need is already here, just stop for some time and think. "
                    },
                    {
                        "username": "beypazari",
                        "content": "This is enough. I didnt used sort() function and my code works without any problem in vs code and returns the true values. When i copy and paste code in here somehow my code raises errors or returns wrong value. When i copy and wrong test case to VS and test my code it returns the true answer. This is just nonsense. I do not recommend this challenge."
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "should be rated as easy"
                    },
                    {
                        "username": "marshel__69",
                        "content": "this should be marked easy"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "for a better understanding to solve it in O(log(min(m, n)) you guys can refer this video https://www.youtube.com/watch?v=ySPX_wTIUQQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of the findMedianSortedArrays function is O(1), since it only uses constant space for variables and does not allocate any additional space for data structures.\\n\\nThe time complexity of the findMedianSortedArrays function is O(log(m+n)), where m and n are the lengths of the two input arrays. This is because the function uses a binary search approach to find the median, which has a time complexity of O(log(n)) for an array of length n. Since the function performs the binary search on one of the input arrays, which has a length of at most m+n, the overall time complexity is O(log(m+n)).\\n\\nIt\\'s worth noting that the time complexity of the findMedianSortedArrays function is optimal, as it\\'s not possible to find the median of two sorted arrays in less than O(log(m+n)) time.\\n"
                    },
                    {
                        "username": "hammoudddd",
                        "content": "I am getting addressSanitizer runtime error in most of my codes. I tried to do it in vs code any other compiler and it worked every time. can somebody tell me why i am getting this runtime error only here in leetcode. \\nthanks "
                    },
                    {
                        "username": "WennyXiong",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n  var nums = nums1.concat(nums2);\\n  var sortedNums = nums.sort((a,b) => a - b);\\n  var medianIndex = nums.length/2\\n  var median = 0;\\n**  //if medianIndex is an integer, meaning the count of number is even, need to calculate the average median**\\n  if (medianIndex === Math.floor(medianIndex)){\\n    median = (sortedNums[medianIndex] + sortedNums[medianIndex - 1]) / 2\\n  } else {\\n    medianIndex = Math.floor(medianIndex);\\n    median = sortedNums[medianIndex];\\n  }\\n  return median;\\n};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, your algorithm does not meet the required complexity, as you concat and sort the input arrays."
                    }
                ]
            },
            {
                "id": 1753104,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "In regards to the logN+M binary search solution, I think I have reached my intellectual limit. Most other hards, after looking at the answer, all make sense. This one has left me scratching my head for days. \n\nAn interviewer asking this question is either looking for some kind of savant, or just trying to get rid of you while making the process look objective. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "from linked list i got an approach of sorting and merging the array so i went with it i just went for it i created an array with [m+n] length if the length is odd then return arr[len/2] and if the  len is even then arr[len/2] + arr[(len/2) - 1]) /2 "
                    },
                    {
                        "username": "dicriptor",
                        "content": "It doesn't look 'hard' really. Maybe 'medium' but not 'hard'. The solution is fairly straightforward and doesn't require knowing tricky algorithms or optimizations. For those who are just ready to solve this remember that to solve this task efficiently you shouldn't create new array, copy merged elements to it and so on. All you need is already here, just stop for some time and think. "
                    },
                    {
                        "username": "beypazari",
                        "content": "This is enough. I didnt used sort() function and my code works without any problem in vs code and returns the true values. When i copy and paste code in here somehow my code raises errors or returns wrong value. When i copy and wrong test case to VS and test my code it returns the true answer. This is just nonsense. I do not recommend this challenge."
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "should be rated as easy"
                    },
                    {
                        "username": "marshel__69",
                        "content": "this should be marked easy"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "for a better understanding to solve it in O(log(min(m, n)) you guys can refer this video https://www.youtube.com/watch?v=ySPX_wTIUQQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of the findMedianSortedArrays function is O(1), since it only uses constant space for variables and does not allocate any additional space for data structures.\\n\\nThe time complexity of the findMedianSortedArrays function is O(log(m+n)), where m and n are the lengths of the two input arrays. This is because the function uses a binary search approach to find the median, which has a time complexity of O(log(n)) for an array of length n. Since the function performs the binary search on one of the input arrays, which has a length of at most m+n, the overall time complexity is O(log(m+n)).\\n\\nIt\\'s worth noting that the time complexity of the findMedianSortedArrays function is optimal, as it\\'s not possible to find the median of two sorted arrays in less than O(log(m+n)) time.\\n"
                    },
                    {
                        "username": "hammoudddd",
                        "content": "I am getting addressSanitizer runtime error in most of my codes. I tried to do it in vs code any other compiler and it worked every time. can somebody tell me why i am getting this runtime error only here in leetcode. \\nthanks "
                    },
                    {
                        "username": "WennyXiong",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n  var nums = nums1.concat(nums2);\\n  var sortedNums = nums.sort((a,b) => a - b);\\n  var medianIndex = nums.length/2\\n  var median = 0;\\n**  //if medianIndex is an integer, meaning the count of number is even, need to calculate the average median**\\n  if (medianIndex === Math.floor(medianIndex)){\\n    median = (sortedNums[medianIndex] + sortedNums[medianIndex - 1]) / 2\\n  } else {\\n    medianIndex = Math.floor(medianIndex);\\n    median = sortedNums[medianIndex];\\n  }\\n  return median;\\n};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, your algorithm does not meet the required complexity, as you concat and sort the input arrays."
                    }
                ]
            },
            {
                "id": 1733522,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "In regards to the logN+M binary search solution, I think I have reached my intellectual limit. Most other hards, after looking at the answer, all make sense. This one has left me scratching my head for days. \n\nAn interviewer asking this question is either looking for some kind of savant, or just trying to get rid of you while making the process look objective. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "from linked list i got an approach of sorting and merging the array so i went with it i just went for it i created an array with [m+n] length if the length is odd then return arr[len/2] and if the  len is even then arr[len/2] + arr[(len/2) - 1]) /2 "
                    },
                    {
                        "username": "dicriptor",
                        "content": "It doesn't look 'hard' really. Maybe 'medium' but not 'hard'. The solution is fairly straightforward and doesn't require knowing tricky algorithms or optimizations. For those who are just ready to solve this remember that to solve this task efficiently you shouldn't create new array, copy merged elements to it and so on. All you need is already here, just stop for some time and think. "
                    },
                    {
                        "username": "beypazari",
                        "content": "This is enough. I didnt used sort() function and my code works without any problem in vs code and returns the true values. When i copy and paste code in here somehow my code raises errors or returns wrong value. When i copy and wrong test case to VS and test my code it returns the true answer. This is just nonsense. I do not recommend this challenge."
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "should be rated as easy"
                    },
                    {
                        "username": "marshel__69",
                        "content": "this should be marked easy"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "for a better understanding to solve it in O(log(min(m, n)) you guys can refer this video https://www.youtube.com/watch?v=ySPX_wTIUQQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of the findMedianSortedArrays function is O(1), since it only uses constant space for variables and does not allocate any additional space for data structures.\\n\\nThe time complexity of the findMedianSortedArrays function is O(log(m+n)), where m and n are the lengths of the two input arrays. This is because the function uses a binary search approach to find the median, which has a time complexity of O(log(n)) for an array of length n. Since the function performs the binary search on one of the input arrays, which has a length of at most m+n, the overall time complexity is O(log(m+n)).\\n\\nIt\\'s worth noting that the time complexity of the findMedianSortedArrays function is optimal, as it\\'s not possible to find the median of two sorted arrays in less than O(log(m+n)) time.\\n"
                    },
                    {
                        "username": "hammoudddd",
                        "content": "I am getting addressSanitizer runtime error in most of my codes. I tried to do it in vs code any other compiler and it worked every time. can somebody tell me why i am getting this runtime error only here in leetcode. \\nthanks "
                    },
                    {
                        "username": "WennyXiong",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n  var nums = nums1.concat(nums2);\\n  var sortedNums = nums.sort((a,b) => a - b);\\n  var medianIndex = nums.length/2\\n  var median = 0;\\n**  //if medianIndex is an integer, meaning the count of number is even, need to calculate the average median**\\n  if (medianIndex === Math.floor(medianIndex)){\\n    median = (sortedNums[medianIndex] + sortedNums[medianIndex - 1]) / 2\\n  } else {\\n    medianIndex = Math.floor(medianIndex);\\n    median = sortedNums[medianIndex];\\n  }\\n  return median;\\n};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, your algorithm does not meet the required complexity, as you concat and sort the input arrays."
                    }
                ]
            },
            {
                "id": 1676132,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "In regards to the logN+M binary search solution, I think I have reached my intellectual limit. Most other hards, after looking at the answer, all make sense. This one has left me scratching my head for days. \n\nAn interviewer asking this question is either looking for some kind of savant, or just trying to get rid of you while making the process look objective. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "from linked list i got an approach of sorting and merging the array so i went with it i just went for it i created an array with [m+n] length if the length is odd then return arr[len/2] and if the  len is even then arr[len/2] + arr[(len/2) - 1]) /2 "
                    },
                    {
                        "username": "dicriptor",
                        "content": "It doesn't look 'hard' really. Maybe 'medium' but not 'hard'. The solution is fairly straightforward and doesn't require knowing tricky algorithms or optimizations. For those who are just ready to solve this remember that to solve this task efficiently you shouldn't create new array, copy merged elements to it and so on. All you need is already here, just stop for some time and think. "
                    },
                    {
                        "username": "beypazari",
                        "content": "This is enough. I didnt used sort() function and my code works without any problem in vs code and returns the true values. When i copy and paste code in here somehow my code raises errors or returns wrong value. When i copy and wrong test case to VS and test my code it returns the true answer. This is just nonsense. I do not recommend this challenge."
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "should be rated as easy"
                    },
                    {
                        "username": "marshel__69",
                        "content": "this should be marked easy"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "for a better understanding to solve it in O(log(min(m, n)) you guys can refer this video https://www.youtube.com/watch?v=ySPX_wTIUQQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of the findMedianSortedArrays function is O(1), since it only uses constant space for variables and does not allocate any additional space for data structures.\\n\\nThe time complexity of the findMedianSortedArrays function is O(log(m+n)), where m and n are the lengths of the two input arrays. This is because the function uses a binary search approach to find the median, which has a time complexity of O(log(n)) for an array of length n. Since the function performs the binary search on one of the input arrays, which has a length of at most m+n, the overall time complexity is O(log(m+n)).\\n\\nIt\\'s worth noting that the time complexity of the findMedianSortedArrays function is optimal, as it\\'s not possible to find the median of two sorted arrays in less than O(log(m+n)) time.\\n"
                    },
                    {
                        "username": "hammoudddd",
                        "content": "I am getting addressSanitizer runtime error in most of my codes. I tried to do it in vs code any other compiler and it worked every time. can somebody tell me why i am getting this runtime error only here in leetcode. \\nthanks "
                    },
                    {
                        "username": "WennyXiong",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n  var nums = nums1.concat(nums2);\\n  var sortedNums = nums.sort((a,b) => a - b);\\n  var medianIndex = nums.length/2\\n  var median = 0;\\n**  //if medianIndex is an integer, meaning the count of number is even, need to calculate the average median**\\n  if (medianIndex === Math.floor(medianIndex)){\\n    median = (sortedNums[medianIndex] + sortedNums[medianIndex - 1]) / 2\\n  } else {\\n    medianIndex = Math.floor(medianIndex);\\n    median = sortedNums[medianIndex];\\n  }\\n  return median;\\n};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, your algorithm does not meet the required complexity, as you concat and sort the input arrays."
                    }
                ]
            },
            {
                "id": 1576583,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "In regards to the logN+M binary search solution, I think I have reached my intellectual limit. Most other hards, after looking at the answer, all make sense. This one has left me scratching my head for days. \n\nAn interviewer asking this question is either looking for some kind of savant, or just trying to get rid of you while making the process look objective. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "from linked list i got an approach of sorting and merging the array so i went with it i just went for it i created an array with [m+n] length if the length is odd then return arr[len/2] and if the  len is even then arr[len/2] + arr[(len/2) - 1]) /2 "
                    },
                    {
                        "username": "dicriptor",
                        "content": "It doesn't look 'hard' really. Maybe 'medium' but not 'hard'. The solution is fairly straightforward and doesn't require knowing tricky algorithms or optimizations. For those who are just ready to solve this remember that to solve this task efficiently you shouldn't create new array, copy merged elements to it and so on. All you need is already here, just stop for some time and think. "
                    },
                    {
                        "username": "beypazari",
                        "content": "This is enough. I didnt used sort() function and my code works without any problem in vs code and returns the true values. When i copy and paste code in here somehow my code raises errors or returns wrong value. When i copy and wrong test case to VS and test my code it returns the true answer. This is just nonsense. I do not recommend this challenge."
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "should be rated as easy"
                    },
                    {
                        "username": "marshel__69",
                        "content": "this should be marked easy"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "for a better understanding to solve it in O(log(min(m, n)) you guys can refer this video https://www.youtube.com/watch?v=ySPX_wTIUQQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of the findMedianSortedArrays function is O(1), since it only uses constant space for variables and does not allocate any additional space for data structures.\\n\\nThe time complexity of the findMedianSortedArrays function is O(log(m+n)), where m and n are the lengths of the two input arrays. This is because the function uses a binary search approach to find the median, which has a time complexity of O(log(n)) for an array of length n. Since the function performs the binary search on one of the input arrays, which has a length of at most m+n, the overall time complexity is O(log(m+n)).\\n\\nIt\\'s worth noting that the time complexity of the findMedianSortedArrays function is optimal, as it\\'s not possible to find the median of two sorted arrays in less than O(log(m+n)) time.\\n"
                    },
                    {
                        "username": "hammoudddd",
                        "content": "I am getting addressSanitizer runtime error in most of my codes. I tried to do it in vs code any other compiler and it worked every time. can somebody tell me why i am getting this runtime error only here in leetcode. \\nthanks "
                    },
                    {
                        "username": "WennyXiong",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n  var nums = nums1.concat(nums2);\\n  var sortedNums = nums.sort((a,b) => a - b);\\n  var medianIndex = nums.length/2\\n  var median = 0;\\n**  //if medianIndex is an integer, meaning the count of number is even, need to calculate the average median**\\n  if (medianIndex === Math.floor(medianIndex)){\\n    median = (sortedNums[medianIndex] + sortedNums[medianIndex - 1]) / 2\\n  } else {\\n    medianIndex = Math.floor(medianIndex);\\n    median = sortedNums[medianIndex];\\n  }\\n  return median;\\n};"
                    },
                    {
                        "username": "parismania",
                        "content": "Please don\\'t post solutions in the discussion tab. Also, your algorithm does not meet the required complexity, as you concat and sort the input arrays."
                    }
                ]
            },
            {
                "id": 1574987,
                "content": [
                    {
                        "username": "gulyaev_anton",
                        "content": "![image](https://assets.leetcode.com/users/images/fd9ffbd6-01d1-4d05-8c47-f028388da6ea_1614478733.1101887.png)\\n"
                    },
                    {
                        "username": "huu_nghia",
                        "content": "I wish I could do it better"
                    },
                    {
                        "username": "simalo",
                        "content": "Didn\\'t see any hint posted so here\\'s what worked for me.\\nFind median of each array and strip out the **same** number of elements from each array and recurse."
                    },
                    {
                        "username": "hoyon916oo",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/hoyon916oo/image_1526760056.png)\\n"
                    },
                    {
                        "username": "bmjxy",
                        "content": "If we have N sorted arrays more than 2 arrays, are there good ideas of finding the median?\\nWhat's the time/space complexity of your algorithm?"
                    },
                    {
                        "username": "neilbhutada",
                        "content": "The questions seemed pretty easy, then why was it a hard question?"
                    },
                    {
                        "username": "sampadah",
                        "content": "we can\\n\\'\\'\\'\\nimport statistics\\nstatistics.median(sorted(num1+num2))\\n\\'\\'\\'"
                    },
                    {
                        "username": "vrinne",
                        "content": "I don\\'t get it, why is this marked as hard? Seems easier than 99% of the problems here."
                    },
                    {
                        "username": "yezhangxiang",
                        "content": "But log(m)+log(n) < 2*log(m+n), so it's also O(log(m+n))?"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this helps](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) and makes thinks clear\\nand clap \\uD83D\\uDC4F for the article to appreciate the work \\u270C"
                    }
                ]
            },
            {
                "id": 1572849,
                "content": [
                    {
                        "username": "gulyaev_anton",
                        "content": "![image](https://assets.leetcode.com/users/images/fd9ffbd6-01d1-4d05-8c47-f028388da6ea_1614478733.1101887.png)\\n"
                    },
                    {
                        "username": "huu_nghia",
                        "content": "I wish I could do it better"
                    },
                    {
                        "username": "simalo",
                        "content": "Didn\\'t see any hint posted so here\\'s what worked for me.\\nFind median of each array and strip out the **same** number of elements from each array and recurse."
                    },
                    {
                        "username": "hoyon916oo",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/hoyon916oo/image_1526760056.png)\\n"
                    },
                    {
                        "username": "bmjxy",
                        "content": "If we have N sorted arrays more than 2 arrays, are there good ideas of finding the median?\\nWhat's the time/space complexity of your algorithm?"
                    },
                    {
                        "username": "neilbhutada",
                        "content": "The questions seemed pretty easy, then why was it a hard question?"
                    },
                    {
                        "username": "sampadah",
                        "content": "we can\\n\\'\\'\\'\\nimport statistics\\nstatistics.median(sorted(num1+num2))\\n\\'\\'\\'"
                    },
                    {
                        "username": "vrinne",
                        "content": "I don\\'t get it, why is this marked as hard? Seems easier than 99% of the problems here."
                    },
                    {
                        "username": "yezhangxiang",
                        "content": "But log(m)+log(n) < 2*log(m+n), so it's also O(log(m+n))?"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this helps](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) and makes thinks clear\\nand clap \\uD83D\\uDC4F for the article to appreciate the work \\u270C"
                    }
                ]
            },
            {
                "id": 1572154,
                "content": [
                    {
                        "username": "gulyaev_anton",
                        "content": "![image](https://assets.leetcode.com/users/images/fd9ffbd6-01d1-4d05-8c47-f028388da6ea_1614478733.1101887.png)\\n"
                    },
                    {
                        "username": "huu_nghia",
                        "content": "I wish I could do it better"
                    },
                    {
                        "username": "simalo",
                        "content": "Didn\\'t see any hint posted so here\\'s what worked for me.\\nFind median of each array and strip out the **same** number of elements from each array and recurse."
                    },
                    {
                        "username": "hoyon916oo",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/hoyon916oo/image_1526760056.png)\\n"
                    },
                    {
                        "username": "bmjxy",
                        "content": "If we have N sorted arrays more than 2 arrays, are there good ideas of finding the median?\\nWhat's the time/space complexity of your algorithm?"
                    },
                    {
                        "username": "neilbhutada",
                        "content": "The questions seemed pretty easy, then why was it a hard question?"
                    },
                    {
                        "username": "sampadah",
                        "content": "we can\\n\\'\\'\\'\\nimport statistics\\nstatistics.median(sorted(num1+num2))\\n\\'\\'\\'"
                    },
                    {
                        "username": "vrinne",
                        "content": "I don\\'t get it, why is this marked as hard? Seems easier than 99% of the problems here."
                    },
                    {
                        "username": "yezhangxiang",
                        "content": "But log(m)+log(n) < 2*log(m+n), so it's also O(log(m+n))?"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this helps](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) and makes thinks clear\\nand clap \\uD83D\\uDC4F for the article to appreciate the work \\u270C"
                    }
                ]
            },
            {
                "id": 1571949,
                "content": [
                    {
                        "username": "gulyaev_anton",
                        "content": "![image](https://assets.leetcode.com/users/images/fd9ffbd6-01d1-4d05-8c47-f028388da6ea_1614478733.1101887.png)\\n"
                    },
                    {
                        "username": "huu_nghia",
                        "content": "I wish I could do it better"
                    },
                    {
                        "username": "simalo",
                        "content": "Didn\\'t see any hint posted so here\\'s what worked for me.\\nFind median of each array and strip out the **same** number of elements from each array and recurse."
                    },
                    {
                        "username": "hoyon916oo",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/hoyon916oo/image_1526760056.png)\\n"
                    },
                    {
                        "username": "bmjxy",
                        "content": "If we have N sorted arrays more than 2 arrays, are there good ideas of finding the median?\\nWhat's the time/space complexity of your algorithm?"
                    },
                    {
                        "username": "neilbhutada",
                        "content": "The questions seemed pretty easy, then why was it a hard question?"
                    },
                    {
                        "username": "sampadah",
                        "content": "we can\\n\\'\\'\\'\\nimport statistics\\nstatistics.median(sorted(num1+num2))\\n\\'\\'\\'"
                    },
                    {
                        "username": "vrinne",
                        "content": "I don\\'t get it, why is this marked as hard? Seems easier than 99% of the problems here."
                    },
                    {
                        "username": "yezhangxiang",
                        "content": "But log(m)+log(n) < 2*log(m+n), so it's also O(log(m+n))?"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this helps](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) and makes thinks clear\\nand clap \\uD83D\\uDC4F for the article to appreciate the work \\u270C"
                    }
                ]
            },
            {
                "id": 1570970,
                "content": [
                    {
                        "username": "gulyaev_anton",
                        "content": "![image](https://assets.leetcode.com/users/images/fd9ffbd6-01d1-4d05-8c47-f028388da6ea_1614478733.1101887.png)\\n"
                    },
                    {
                        "username": "huu_nghia",
                        "content": "I wish I could do it better"
                    },
                    {
                        "username": "simalo",
                        "content": "Didn\\'t see any hint posted so here\\'s what worked for me.\\nFind median of each array and strip out the **same** number of elements from each array and recurse."
                    },
                    {
                        "username": "hoyon916oo",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/hoyon916oo/image_1526760056.png)\\n"
                    },
                    {
                        "username": "bmjxy",
                        "content": "If we have N sorted arrays more than 2 arrays, are there good ideas of finding the median?\\nWhat's the time/space complexity of your algorithm?"
                    },
                    {
                        "username": "neilbhutada",
                        "content": "The questions seemed pretty easy, then why was it a hard question?"
                    },
                    {
                        "username": "sampadah",
                        "content": "we can\\n\\'\\'\\'\\nimport statistics\\nstatistics.median(sorted(num1+num2))\\n\\'\\'\\'"
                    },
                    {
                        "username": "vrinne",
                        "content": "I don\\'t get it, why is this marked as hard? Seems easier than 99% of the problems here."
                    },
                    {
                        "username": "yezhangxiang",
                        "content": "But log(m)+log(n) < 2*log(m+n), so it's also O(log(m+n))?"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this helps](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) and makes thinks clear\\nand clap \\uD83D\\uDC4F for the article to appreciate the work \\u270C"
                    }
                ]
            },
            {
                "id": 1574929,
                "content": [
                    {
                        "username": "gulyaev_anton",
                        "content": "![image](https://assets.leetcode.com/users/images/fd9ffbd6-01d1-4d05-8c47-f028388da6ea_1614478733.1101887.png)\\n"
                    },
                    {
                        "username": "huu_nghia",
                        "content": "I wish I could do it better"
                    },
                    {
                        "username": "simalo",
                        "content": "Didn\\'t see any hint posted so here\\'s what worked for me.\\nFind median of each array and strip out the **same** number of elements from each array and recurse."
                    },
                    {
                        "username": "hoyon916oo",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/hoyon916oo/image_1526760056.png)\\n"
                    },
                    {
                        "username": "bmjxy",
                        "content": "If we have N sorted arrays more than 2 arrays, are there good ideas of finding the median?\\nWhat's the time/space complexity of your algorithm?"
                    },
                    {
                        "username": "neilbhutada",
                        "content": "The questions seemed pretty easy, then why was it a hard question?"
                    },
                    {
                        "username": "sampadah",
                        "content": "we can\\n\\'\\'\\'\\nimport statistics\\nstatistics.median(sorted(num1+num2))\\n\\'\\'\\'"
                    },
                    {
                        "username": "vrinne",
                        "content": "I don\\'t get it, why is this marked as hard? Seems easier than 99% of the problems here."
                    },
                    {
                        "username": "yezhangxiang",
                        "content": "But log(m)+log(n) < 2*log(m+n), so it's also O(log(m+n))?"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this helps](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) and makes thinks clear\\nand clap \\uD83D\\uDC4F for the article to appreciate the work \\u270C"
                    }
                ]
            },
            {
                "id": 1574246,
                "content": [
                    {
                        "username": "gulyaev_anton",
                        "content": "![image](https://assets.leetcode.com/users/images/fd9ffbd6-01d1-4d05-8c47-f028388da6ea_1614478733.1101887.png)\\n"
                    },
                    {
                        "username": "huu_nghia",
                        "content": "I wish I could do it better"
                    },
                    {
                        "username": "simalo",
                        "content": "Didn\\'t see any hint posted so here\\'s what worked for me.\\nFind median of each array and strip out the **same** number of elements from each array and recurse."
                    },
                    {
                        "username": "hoyon916oo",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/hoyon916oo/image_1526760056.png)\\n"
                    },
                    {
                        "username": "bmjxy",
                        "content": "If we have N sorted arrays more than 2 arrays, are there good ideas of finding the median?\\nWhat's the time/space complexity of your algorithm?"
                    },
                    {
                        "username": "neilbhutada",
                        "content": "The questions seemed pretty easy, then why was it a hard question?"
                    },
                    {
                        "username": "sampadah",
                        "content": "we can\\n\\'\\'\\'\\nimport statistics\\nstatistics.median(sorted(num1+num2))\\n\\'\\'\\'"
                    },
                    {
                        "username": "vrinne",
                        "content": "I don\\'t get it, why is this marked as hard? Seems easier than 99% of the problems here."
                    },
                    {
                        "username": "yezhangxiang",
                        "content": "But log(m)+log(n) < 2*log(m+n), so it's also O(log(m+n))?"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this helps](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) and makes thinks clear\\nand clap \\uD83D\\uDC4F for the article to appreciate the work \\u270C"
                    }
                ]
            },
            {
                "id": 1570531,
                "content": [
                    {
                        "username": "gulyaev_anton",
                        "content": "![image](https://assets.leetcode.com/users/images/fd9ffbd6-01d1-4d05-8c47-f028388da6ea_1614478733.1101887.png)\\n"
                    },
                    {
                        "username": "huu_nghia",
                        "content": "I wish I could do it better"
                    },
                    {
                        "username": "simalo",
                        "content": "Didn\\'t see any hint posted so here\\'s what worked for me.\\nFind median of each array and strip out the **same** number of elements from each array and recurse."
                    },
                    {
                        "username": "hoyon916oo",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/hoyon916oo/image_1526760056.png)\\n"
                    },
                    {
                        "username": "bmjxy",
                        "content": "If we have N sorted arrays more than 2 arrays, are there good ideas of finding the median?\\nWhat's the time/space complexity of your algorithm?"
                    },
                    {
                        "username": "neilbhutada",
                        "content": "The questions seemed pretty easy, then why was it a hard question?"
                    },
                    {
                        "username": "sampadah",
                        "content": "we can\\n\\'\\'\\'\\nimport statistics\\nstatistics.median(sorted(num1+num2))\\n\\'\\'\\'"
                    },
                    {
                        "username": "vrinne",
                        "content": "I don\\'t get it, why is this marked as hard? Seems easier than 99% of the problems here."
                    },
                    {
                        "username": "yezhangxiang",
                        "content": "But log(m)+log(n) < 2*log(m+n), so it's also O(log(m+n))?"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this helps](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) and makes thinks clear\\nand clap \\uD83D\\uDC4F for the article to appreciate the work \\u270C"
                    }
                ]
            },
            {
                "id": 1567788,
                "content": [
                    {
                        "username": "gulyaev_anton",
                        "content": "![image](https://assets.leetcode.com/users/images/fd9ffbd6-01d1-4d05-8c47-f028388da6ea_1614478733.1101887.png)\\n"
                    },
                    {
                        "username": "huu_nghia",
                        "content": "I wish I could do it better"
                    },
                    {
                        "username": "simalo",
                        "content": "Didn\\'t see any hint posted so here\\'s what worked for me.\\nFind median of each array and strip out the **same** number of elements from each array and recurse."
                    },
                    {
                        "username": "hoyon916oo",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/hoyon916oo/image_1526760056.png)\\n"
                    },
                    {
                        "username": "bmjxy",
                        "content": "If we have N sorted arrays more than 2 arrays, are there good ideas of finding the median?\\nWhat's the time/space complexity of your algorithm?"
                    },
                    {
                        "username": "neilbhutada",
                        "content": "The questions seemed pretty easy, then why was it a hard question?"
                    },
                    {
                        "username": "sampadah",
                        "content": "we can\\n\\'\\'\\'\\nimport statistics\\nstatistics.median(sorted(num1+num2))\\n\\'\\'\\'"
                    },
                    {
                        "username": "vrinne",
                        "content": "I don\\'t get it, why is this marked as hard? Seems easier than 99% of the problems here."
                    },
                    {
                        "username": "yezhangxiang",
                        "content": "But log(m)+log(n) < 2*log(m+n), so it's also O(log(m+n))?"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this helps](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) and makes thinks clear\\nand clap \\uD83D\\uDC4F for the article to appreciate the work \\u270C"
                    }
                ]
            },
            {
                "id": 1568711,
                "content": [
                    {
                        "username": "gulyaev_anton",
                        "content": "![image](https://assets.leetcode.com/users/images/fd9ffbd6-01d1-4d05-8c47-f028388da6ea_1614478733.1101887.png)\\n"
                    },
                    {
                        "username": "huu_nghia",
                        "content": "I wish I could do it better"
                    },
                    {
                        "username": "simalo",
                        "content": "Didn\\'t see any hint posted so here\\'s what worked for me.\\nFind median of each array and strip out the **same** number of elements from each array and recurse."
                    },
                    {
                        "username": "hoyon916oo",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/hoyon916oo/image_1526760056.png)\\n"
                    },
                    {
                        "username": "bmjxy",
                        "content": "If we have N sorted arrays more than 2 arrays, are there good ideas of finding the median?\\nWhat's the time/space complexity of your algorithm?"
                    },
                    {
                        "username": "neilbhutada",
                        "content": "The questions seemed pretty easy, then why was it a hard question?"
                    },
                    {
                        "username": "sampadah",
                        "content": "we can\\n\\'\\'\\'\\nimport statistics\\nstatistics.median(sorted(num1+num2))\\n\\'\\'\\'"
                    },
                    {
                        "username": "vrinne",
                        "content": "I don\\'t get it, why is this marked as hard? Seems easier than 99% of the problems here."
                    },
                    {
                        "username": "yezhangxiang",
                        "content": "But log(m)+log(n) < 2*log(m+n), so it's also O(log(m+n))?"
                    },
                    {
                        "username": "ganesh227",
                        "content": "[Hope this helps](https://ganeshpr227.medium.com/logarithmic-algorithm-for-finding-median-of-two-sorted-arrays-of-different-sizes-aaecf302057e) and makes thinks clear\\nand clap \\uD83D\\uDC4F for the article to appreciate the work \\u270C"
                    }
                ]
            },
            {
                "id": 1902625,
                "content": [
                    {
                        "username": "stephanlangeveld",
                        "content": "ur engrish is shitty,\\nknow the difference between mean and median. "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast c++ || Java || Python || JavaScript Solutions :\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/7b2ff572-03f8-4cbe-8fcd-7121964b3190_1645600047.26837.jpeg)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "mechinelearn",
                        "content": "Runtime: 24 ms, faster than 100.00% of C online submissions for Median of Two Sorted Arrays."
                    },
                    {
                        "username": "sachin-1401",
                        "content": "Input \\nnums1 =\\n[1,3]\\nnums2 =\\n[2,7]\\n\\n\\nOutput\\n3.25000\\n\\nExpected\\n2.50000\\n\\n `public class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double a=0;\\n         var arr=nums1.Concat(nums2).ToArray();\\n        double sum=(ReadArrayRecursively(arr,0));\\n    //    Console.WriteLine(sum);\\n    //    Console.WriteLine(arr.Length);\\n        double res=sum/arr.Length;\\n        return res;\\n\\n    }\\n     static double ReadArrayRecursively(int[] arr, int index)\\n    {\\n        \\n        // Base case: If the index is equal to the length of the array, stop recursion.\\n        if (index == arr.Length)\\n        {\\n            return 0;\\n        }\\n\\n        // Print the current element at the index.\\n        // Console.WriteLine(arr[index]);\\n\\n        // Recursively call the function with the next index.\\n        double count = arr[index] + ReadArrayRecursively(arr, index + 1);\\n        return count;\\n        \\n    }\\n}`\\n\\nWhat is wrong in this code"
                    },
                    {
                        "username": "InewsYuZinh",
                        "content": "why is there no case nums1: 1 2 2 3 4 4. Because the problem does not mention that the elements in the array are different\\n "
                    },
                    {
                        "username": "vinnie17",
                        "content": "can anyone tell why my code is wrong?\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int a[] = nums1;\\n        int b[] = nums2;\\n\\n        int total = nums1.length + nums2.length;\\n        int half = total / 2;\\n\\n        if(nums1.length > nums2.length){\\n            a = nums2;\\n            b = nums1;\\n        }\\n        System.out.println(a.length);\\n\\n        int l = 0;\\n        int r = a.length - 1;\\n        double ans = 0.0;\\n        boolean d = true;\\n\\n        while(true){\\n            int i = (l + r) / 2; // a array index\\n            int j = half - i - 2; // b array index (it is index that is why sub 2)\\n\\n            int aLeft = Integer.MIN_VALUE;\\n            int aRight = Integer.MAX_VALUE;\\n            int bLeft = Integer.MIN_VALUE;\\n            int bRight = Integer.MAX_VALUE;\\n            if(i >= 0){\\n                aLeft = a[i];\\n            }\\n            if(i + 1 < a.length){\\n                aRight = a[i + 1];\\n            }\\n\\n            if(j >= 0){\\n                bLeft = b[j];\\n            }\\n            if(j + 1 < b.length){\\n                bRight = b[j + 1];\\n            }\\n            // int aLeft = i >= 0 ? a[i] : Integer.MIN_VALUE;\\n            // int aRight = i + 1 < a.length ? a[i + 1] : Integer.MAX_VALUE;\\n            // int bLeft = j >= 0 ? b[j] : Integer.MIN_VALUE;\\n            // int bRight = j + 1 < b.length ? b[j + 1] : Integer.MAX_VALUE;\\n\\n            if(aLeft <= bRight && bLeft <= aRight){\\n                if(total % 2 != 0){\\n                    return (double)(Math.min(aRight, bRight));\\n                    // d = false;\\n                }else{\\n                    return (double)(Math.max(aLeft, bLeft) + Math.min(aRight, bRight) / 2.0);\\n                    // d = false;\\n                }\\n            }else if(aLeft > bRight){\\n                r = i - 1;\\n            }else{\\n                l = i + 1;\\n            }\\n        }\\n        // return ans;\\n    }\\n}"
                    },
                    {
                        "username": "yousaf_10",
                        "content": "hello everyone ! if there is any senior i need to discuss something\\nbasically i am a beginner i had the approach to solve the problem but was confused about implementation, is it fair to get an idea from solutions??"
                    }
                ]
            },
            {
                "id": 1576671,
                "content": [
                    {
                        "username": "stephanlangeveld",
                        "content": "ur engrish is shitty,\\nknow the difference between mean and median. "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast c++ || Java || Python || JavaScript Solutions :\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/7b2ff572-03f8-4cbe-8fcd-7121964b3190_1645600047.26837.jpeg)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "mechinelearn",
                        "content": "Runtime: 24 ms, faster than 100.00% of C online submissions for Median of Two Sorted Arrays."
                    },
                    {
                        "username": "sachin-1401",
                        "content": "Input \\nnums1 =\\n[1,3]\\nnums2 =\\n[2,7]\\n\\n\\nOutput\\n3.25000\\n\\nExpected\\n2.50000\\n\\n `public class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double a=0;\\n         var arr=nums1.Concat(nums2).ToArray();\\n        double sum=(ReadArrayRecursively(arr,0));\\n    //    Console.WriteLine(sum);\\n    //    Console.WriteLine(arr.Length);\\n        double res=sum/arr.Length;\\n        return res;\\n\\n    }\\n     static double ReadArrayRecursively(int[] arr, int index)\\n    {\\n        \\n        // Base case: If the index is equal to the length of the array, stop recursion.\\n        if (index == arr.Length)\\n        {\\n            return 0;\\n        }\\n\\n        // Print the current element at the index.\\n        // Console.WriteLine(arr[index]);\\n\\n        // Recursively call the function with the next index.\\n        double count = arr[index] + ReadArrayRecursively(arr, index + 1);\\n        return count;\\n        \\n    }\\n}`\\n\\nWhat is wrong in this code"
                    },
                    {
                        "username": "InewsYuZinh",
                        "content": "why is there no case nums1: 1 2 2 3 4 4. Because the problem does not mention that the elements in the array are different\\n "
                    },
                    {
                        "username": "vinnie17",
                        "content": "can anyone tell why my code is wrong?\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int a[] = nums1;\\n        int b[] = nums2;\\n\\n        int total = nums1.length + nums2.length;\\n        int half = total / 2;\\n\\n        if(nums1.length > nums2.length){\\n            a = nums2;\\n            b = nums1;\\n        }\\n        System.out.println(a.length);\\n\\n        int l = 0;\\n        int r = a.length - 1;\\n        double ans = 0.0;\\n        boolean d = true;\\n\\n        while(true){\\n            int i = (l + r) / 2; // a array index\\n            int j = half - i - 2; // b array index (it is index that is why sub 2)\\n\\n            int aLeft = Integer.MIN_VALUE;\\n            int aRight = Integer.MAX_VALUE;\\n            int bLeft = Integer.MIN_VALUE;\\n            int bRight = Integer.MAX_VALUE;\\n            if(i >= 0){\\n                aLeft = a[i];\\n            }\\n            if(i + 1 < a.length){\\n                aRight = a[i + 1];\\n            }\\n\\n            if(j >= 0){\\n                bLeft = b[j];\\n            }\\n            if(j + 1 < b.length){\\n                bRight = b[j + 1];\\n            }\\n            // int aLeft = i >= 0 ? a[i] : Integer.MIN_VALUE;\\n            // int aRight = i + 1 < a.length ? a[i + 1] : Integer.MAX_VALUE;\\n            // int bLeft = j >= 0 ? b[j] : Integer.MIN_VALUE;\\n            // int bRight = j + 1 < b.length ? b[j + 1] : Integer.MAX_VALUE;\\n\\n            if(aLeft <= bRight && bLeft <= aRight){\\n                if(total % 2 != 0){\\n                    return (double)(Math.min(aRight, bRight));\\n                    // d = false;\\n                }else{\\n                    return (double)(Math.max(aLeft, bLeft) + Math.min(aRight, bRight) / 2.0);\\n                    // d = false;\\n                }\\n            }else if(aLeft > bRight){\\n                r = i - 1;\\n            }else{\\n                l = i + 1;\\n            }\\n        }\\n        // return ans;\\n    }\\n}"
                    },
                    {
                        "username": "yousaf_10",
                        "content": "hello everyone ! if there is any senior i need to discuss something\\nbasically i am a beginner i had the approach to solve the problem but was confused about implementation, is it fair to get an idea from solutions??"
                    }
                ]
            },
            {
                "id": 1576649,
                "content": [
                    {
                        "username": "stephanlangeveld",
                        "content": "ur engrish is shitty,\\nknow the difference between mean and median. "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast c++ || Java || Python || JavaScript Solutions :\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/7b2ff572-03f8-4cbe-8fcd-7121964b3190_1645600047.26837.jpeg)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "mechinelearn",
                        "content": "Runtime: 24 ms, faster than 100.00% of C online submissions for Median of Two Sorted Arrays."
                    },
                    {
                        "username": "sachin-1401",
                        "content": "Input \\nnums1 =\\n[1,3]\\nnums2 =\\n[2,7]\\n\\n\\nOutput\\n3.25000\\n\\nExpected\\n2.50000\\n\\n `public class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double a=0;\\n         var arr=nums1.Concat(nums2).ToArray();\\n        double sum=(ReadArrayRecursively(arr,0));\\n    //    Console.WriteLine(sum);\\n    //    Console.WriteLine(arr.Length);\\n        double res=sum/arr.Length;\\n        return res;\\n\\n    }\\n     static double ReadArrayRecursively(int[] arr, int index)\\n    {\\n        \\n        // Base case: If the index is equal to the length of the array, stop recursion.\\n        if (index == arr.Length)\\n        {\\n            return 0;\\n        }\\n\\n        // Print the current element at the index.\\n        // Console.WriteLine(arr[index]);\\n\\n        // Recursively call the function with the next index.\\n        double count = arr[index] + ReadArrayRecursively(arr, index + 1);\\n        return count;\\n        \\n    }\\n}`\\n\\nWhat is wrong in this code"
                    },
                    {
                        "username": "InewsYuZinh",
                        "content": "why is there no case nums1: 1 2 2 3 4 4. Because the problem does not mention that the elements in the array are different\\n "
                    },
                    {
                        "username": "vinnie17",
                        "content": "can anyone tell why my code is wrong?\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int a[] = nums1;\\n        int b[] = nums2;\\n\\n        int total = nums1.length + nums2.length;\\n        int half = total / 2;\\n\\n        if(nums1.length > nums2.length){\\n            a = nums2;\\n            b = nums1;\\n        }\\n        System.out.println(a.length);\\n\\n        int l = 0;\\n        int r = a.length - 1;\\n        double ans = 0.0;\\n        boolean d = true;\\n\\n        while(true){\\n            int i = (l + r) / 2; // a array index\\n            int j = half - i - 2; // b array index (it is index that is why sub 2)\\n\\n            int aLeft = Integer.MIN_VALUE;\\n            int aRight = Integer.MAX_VALUE;\\n            int bLeft = Integer.MIN_VALUE;\\n            int bRight = Integer.MAX_VALUE;\\n            if(i >= 0){\\n                aLeft = a[i];\\n            }\\n            if(i + 1 < a.length){\\n                aRight = a[i + 1];\\n            }\\n\\n            if(j >= 0){\\n                bLeft = b[j];\\n            }\\n            if(j + 1 < b.length){\\n                bRight = b[j + 1];\\n            }\\n            // int aLeft = i >= 0 ? a[i] : Integer.MIN_VALUE;\\n            // int aRight = i + 1 < a.length ? a[i + 1] : Integer.MAX_VALUE;\\n            // int bLeft = j >= 0 ? b[j] : Integer.MIN_VALUE;\\n            // int bRight = j + 1 < b.length ? b[j + 1] : Integer.MAX_VALUE;\\n\\n            if(aLeft <= bRight && bLeft <= aRight){\\n                if(total % 2 != 0){\\n                    return (double)(Math.min(aRight, bRight));\\n                    // d = false;\\n                }else{\\n                    return (double)(Math.max(aLeft, bLeft) + Math.min(aRight, bRight) / 2.0);\\n                    // d = false;\\n                }\\n            }else if(aLeft > bRight){\\n                r = i - 1;\\n            }else{\\n                l = i + 1;\\n            }\\n        }\\n        // return ans;\\n    }\\n}"
                    },
                    {
                        "username": "yousaf_10",
                        "content": "hello everyone ! if there is any senior i need to discuss something\\nbasically i am a beginner i had the approach to solve the problem but was confused about implementation, is it fair to get an idea from solutions??"
                    }
                ]
            },
            {
                "id": 1576434,
                "content": [
                    {
                        "username": "stephanlangeveld",
                        "content": "ur engrish is shitty,\\nknow the difference between mean and median. "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast c++ || Java || Python || JavaScript Solutions :\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/7b2ff572-03f8-4cbe-8fcd-7121964b3190_1645600047.26837.jpeg)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "mechinelearn",
                        "content": "Runtime: 24 ms, faster than 100.00% of C online submissions for Median of Two Sorted Arrays."
                    },
                    {
                        "username": "sachin-1401",
                        "content": "Input \\nnums1 =\\n[1,3]\\nnums2 =\\n[2,7]\\n\\n\\nOutput\\n3.25000\\n\\nExpected\\n2.50000\\n\\n `public class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double a=0;\\n         var arr=nums1.Concat(nums2).ToArray();\\n        double sum=(ReadArrayRecursively(arr,0));\\n    //    Console.WriteLine(sum);\\n    //    Console.WriteLine(arr.Length);\\n        double res=sum/arr.Length;\\n        return res;\\n\\n    }\\n     static double ReadArrayRecursively(int[] arr, int index)\\n    {\\n        \\n        // Base case: If the index is equal to the length of the array, stop recursion.\\n        if (index == arr.Length)\\n        {\\n            return 0;\\n        }\\n\\n        // Print the current element at the index.\\n        // Console.WriteLine(arr[index]);\\n\\n        // Recursively call the function with the next index.\\n        double count = arr[index] + ReadArrayRecursively(arr, index + 1);\\n        return count;\\n        \\n    }\\n}`\\n\\nWhat is wrong in this code"
                    },
                    {
                        "username": "InewsYuZinh",
                        "content": "why is there no case nums1: 1 2 2 3 4 4. Because the problem does not mention that the elements in the array are different\\n "
                    },
                    {
                        "username": "vinnie17",
                        "content": "can anyone tell why my code is wrong?\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int a[] = nums1;\\n        int b[] = nums2;\\n\\n        int total = nums1.length + nums2.length;\\n        int half = total / 2;\\n\\n        if(nums1.length > nums2.length){\\n            a = nums2;\\n            b = nums1;\\n        }\\n        System.out.println(a.length);\\n\\n        int l = 0;\\n        int r = a.length - 1;\\n        double ans = 0.0;\\n        boolean d = true;\\n\\n        while(true){\\n            int i = (l + r) / 2; // a array index\\n            int j = half - i - 2; // b array index (it is index that is why sub 2)\\n\\n            int aLeft = Integer.MIN_VALUE;\\n            int aRight = Integer.MAX_VALUE;\\n            int bLeft = Integer.MIN_VALUE;\\n            int bRight = Integer.MAX_VALUE;\\n            if(i >= 0){\\n                aLeft = a[i];\\n            }\\n            if(i + 1 < a.length){\\n                aRight = a[i + 1];\\n            }\\n\\n            if(j >= 0){\\n                bLeft = b[j];\\n            }\\n            if(j + 1 < b.length){\\n                bRight = b[j + 1];\\n            }\\n            // int aLeft = i >= 0 ? a[i] : Integer.MIN_VALUE;\\n            // int aRight = i + 1 < a.length ? a[i + 1] : Integer.MAX_VALUE;\\n            // int bLeft = j >= 0 ? b[j] : Integer.MIN_VALUE;\\n            // int bRight = j + 1 < b.length ? b[j + 1] : Integer.MAX_VALUE;\\n\\n            if(aLeft <= bRight && bLeft <= aRight){\\n                if(total % 2 != 0){\\n                    return (double)(Math.min(aRight, bRight));\\n                    // d = false;\\n                }else{\\n                    return (double)(Math.max(aLeft, bLeft) + Math.min(aRight, bRight) / 2.0);\\n                    // d = false;\\n                }\\n            }else if(aLeft > bRight){\\n                r = i - 1;\\n            }else{\\n                l = i + 1;\\n            }\\n        }\\n        // return ans;\\n    }\\n}"
                    },
                    {
                        "username": "yousaf_10",
                        "content": "hello everyone ! if there is any senior i need to discuss something\\nbasically i am a beginner i had the approach to solve the problem but was confused about implementation, is it fair to get an idea from solutions??"
                    }
                ]
            },
            {
                "id": 1576348,
                "content": [
                    {
                        "username": "stephanlangeveld",
                        "content": "ur engrish is shitty,\\nknow the difference between mean and median. "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast c++ || Java || Python || JavaScript Solutions :\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/7b2ff572-03f8-4cbe-8fcd-7121964b3190_1645600047.26837.jpeg)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "mechinelearn",
                        "content": "Runtime: 24 ms, faster than 100.00% of C online submissions for Median of Two Sorted Arrays."
                    },
                    {
                        "username": "sachin-1401",
                        "content": "Input \\nnums1 =\\n[1,3]\\nnums2 =\\n[2,7]\\n\\n\\nOutput\\n3.25000\\n\\nExpected\\n2.50000\\n\\n `public class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double a=0;\\n         var arr=nums1.Concat(nums2).ToArray();\\n        double sum=(ReadArrayRecursively(arr,0));\\n    //    Console.WriteLine(sum);\\n    //    Console.WriteLine(arr.Length);\\n        double res=sum/arr.Length;\\n        return res;\\n\\n    }\\n     static double ReadArrayRecursively(int[] arr, int index)\\n    {\\n        \\n        // Base case: If the index is equal to the length of the array, stop recursion.\\n        if (index == arr.Length)\\n        {\\n            return 0;\\n        }\\n\\n        // Print the current element at the index.\\n        // Console.WriteLine(arr[index]);\\n\\n        // Recursively call the function with the next index.\\n        double count = arr[index] + ReadArrayRecursively(arr, index + 1);\\n        return count;\\n        \\n    }\\n}`\\n\\nWhat is wrong in this code"
                    },
                    {
                        "username": "InewsYuZinh",
                        "content": "why is there no case nums1: 1 2 2 3 4 4. Because the problem does not mention that the elements in the array are different\\n "
                    },
                    {
                        "username": "vinnie17",
                        "content": "can anyone tell why my code is wrong?\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int a[] = nums1;\\n        int b[] = nums2;\\n\\n        int total = nums1.length + nums2.length;\\n        int half = total / 2;\\n\\n        if(nums1.length > nums2.length){\\n            a = nums2;\\n            b = nums1;\\n        }\\n        System.out.println(a.length);\\n\\n        int l = 0;\\n        int r = a.length - 1;\\n        double ans = 0.0;\\n        boolean d = true;\\n\\n        while(true){\\n            int i = (l + r) / 2; // a array index\\n            int j = half - i - 2; // b array index (it is index that is why sub 2)\\n\\n            int aLeft = Integer.MIN_VALUE;\\n            int aRight = Integer.MAX_VALUE;\\n            int bLeft = Integer.MIN_VALUE;\\n            int bRight = Integer.MAX_VALUE;\\n            if(i >= 0){\\n                aLeft = a[i];\\n            }\\n            if(i + 1 < a.length){\\n                aRight = a[i + 1];\\n            }\\n\\n            if(j >= 0){\\n                bLeft = b[j];\\n            }\\n            if(j + 1 < b.length){\\n                bRight = b[j + 1];\\n            }\\n            // int aLeft = i >= 0 ? a[i] : Integer.MIN_VALUE;\\n            // int aRight = i + 1 < a.length ? a[i + 1] : Integer.MAX_VALUE;\\n            // int bLeft = j >= 0 ? b[j] : Integer.MIN_VALUE;\\n            // int bRight = j + 1 < b.length ? b[j + 1] : Integer.MAX_VALUE;\\n\\n            if(aLeft <= bRight && bLeft <= aRight){\\n                if(total % 2 != 0){\\n                    return (double)(Math.min(aRight, bRight));\\n                    // d = false;\\n                }else{\\n                    return (double)(Math.max(aLeft, bLeft) + Math.min(aRight, bRight) / 2.0);\\n                    // d = false;\\n                }\\n            }else if(aLeft > bRight){\\n                r = i - 1;\\n            }else{\\n                l = i + 1;\\n            }\\n        }\\n        // return ans;\\n    }\\n}"
                    },
                    {
                        "username": "yousaf_10",
                        "content": "hello everyone ! if there is any senior i need to discuss something\\nbasically i am a beginner i had the approach to solve the problem but was confused about implementation, is it fair to get an idea from solutions??"
                    }
                ]
            },
            {
                "id": 1572329,
                "content": [
                    {
                        "username": "stephanlangeveld",
                        "content": "ur engrish is shitty,\\nknow the difference between mean and median. "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast c++ || Java || Python || JavaScript Solutions :\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/7b2ff572-03f8-4cbe-8fcd-7121964b3190_1645600047.26837.jpeg)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "mechinelearn",
                        "content": "Runtime: 24 ms, faster than 100.00% of C online submissions for Median of Two Sorted Arrays."
                    },
                    {
                        "username": "sachin-1401",
                        "content": "Input \\nnums1 =\\n[1,3]\\nnums2 =\\n[2,7]\\n\\n\\nOutput\\n3.25000\\n\\nExpected\\n2.50000\\n\\n `public class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double a=0;\\n         var arr=nums1.Concat(nums2).ToArray();\\n        double sum=(ReadArrayRecursively(arr,0));\\n    //    Console.WriteLine(sum);\\n    //    Console.WriteLine(arr.Length);\\n        double res=sum/arr.Length;\\n        return res;\\n\\n    }\\n     static double ReadArrayRecursively(int[] arr, int index)\\n    {\\n        \\n        // Base case: If the index is equal to the length of the array, stop recursion.\\n        if (index == arr.Length)\\n        {\\n            return 0;\\n        }\\n\\n        // Print the current element at the index.\\n        // Console.WriteLine(arr[index]);\\n\\n        // Recursively call the function with the next index.\\n        double count = arr[index] + ReadArrayRecursively(arr, index + 1);\\n        return count;\\n        \\n    }\\n}`\\n\\nWhat is wrong in this code"
                    },
                    {
                        "username": "InewsYuZinh",
                        "content": "why is there no case nums1: 1 2 2 3 4 4. Because the problem does not mention that the elements in the array are different\\n "
                    },
                    {
                        "username": "vinnie17",
                        "content": "can anyone tell why my code is wrong?\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int a[] = nums1;\\n        int b[] = nums2;\\n\\n        int total = nums1.length + nums2.length;\\n        int half = total / 2;\\n\\n        if(nums1.length > nums2.length){\\n            a = nums2;\\n            b = nums1;\\n        }\\n        System.out.println(a.length);\\n\\n        int l = 0;\\n        int r = a.length - 1;\\n        double ans = 0.0;\\n        boolean d = true;\\n\\n        while(true){\\n            int i = (l + r) / 2; // a array index\\n            int j = half - i - 2; // b array index (it is index that is why sub 2)\\n\\n            int aLeft = Integer.MIN_VALUE;\\n            int aRight = Integer.MAX_VALUE;\\n            int bLeft = Integer.MIN_VALUE;\\n            int bRight = Integer.MAX_VALUE;\\n            if(i >= 0){\\n                aLeft = a[i];\\n            }\\n            if(i + 1 < a.length){\\n                aRight = a[i + 1];\\n            }\\n\\n            if(j >= 0){\\n                bLeft = b[j];\\n            }\\n            if(j + 1 < b.length){\\n                bRight = b[j + 1];\\n            }\\n            // int aLeft = i >= 0 ? a[i] : Integer.MIN_VALUE;\\n            // int aRight = i + 1 < a.length ? a[i + 1] : Integer.MAX_VALUE;\\n            // int bLeft = j >= 0 ? b[j] : Integer.MIN_VALUE;\\n            // int bRight = j + 1 < b.length ? b[j + 1] : Integer.MAX_VALUE;\\n\\n            if(aLeft <= bRight && bLeft <= aRight){\\n                if(total % 2 != 0){\\n                    return (double)(Math.min(aRight, bRight));\\n                    // d = false;\\n                }else{\\n                    return (double)(Math.max(aLeft, bLeft) + Math.min(aRight, bRight) / 2.0);\\n                    // d = false;\\n                }\\n            }else if(aLeft > bRight){\\n                r = i - 1;\\n            }else{\\n                l = i + 1;\\n            }\\n        }\\n        // return ans;\\n    }\\n}"
                    },
                    {
                        "username": "yousaf_10",
                        "content": "hello everyone ! if there is any senior i need to discuss something\\nbasically i am a beginner i had the approach to solve the problem but was confused about implementation, is it fair to get an idea from solutions??"
                    }
                ]
            },
            {
                "id": 2071889,
                "content": [
                    {
                        "username": "stephanlangeveld",
                        "content": "ur engrish is shitty,\\nknow the difference between mean and median. "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast c++ || Java || Python || JavaScript Solutions :\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/7b2ff572-03f8-4cbe-8fcd-7121964b3190_1645600047.26837.jpeg)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "mechinelearn",
                        "content": "Runtime: 24 ms, faster than 100.00% of C online submissions for Median of Two Sorted Arrays."
                    },
                    {
                        "username": "sachin-1401",
                        "content": "Input \\nnums1 =\\n[1,3]\\nnums2 =\\n[2,7]\\n\\n\\nOutput\\n3.25000\\n\\nExpected\\n2.50000\\n\\n `public class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double a=0;\\n         var arr=nums1.Concat(nums2).ToArray();\\n        double sum=(ReadArrayRecursively(arr,0));\\n    //    Console.WriteLine(sum);\\n    //    Console.WriteLine(arr.Length);\\n        double res=sum/arr.Length;\\n        return res;\\n\\n    }\\n     static double ReadArrayRecursively(int[] arr, int index)\\n    {\\n        \\n        // Base case: If the index is equal to the length of the array, stop recursion.\\n        if (index == arr.Length)\\n        {\\n            return 0;\\n        }\\n\\n        // Print the current element at the index.\\n        // Console.WriteLine(arr[index]);\\n\\n        // Recursively call the function with the next index.\\n        double count = arr[index] + ReadArrayRecursively(arr, index + 1);\\n        return count;\\n        \\n    }\\n}`\\n\\nWhat is wrong in this code"
                    },
                    {
                        "username": "InewsYuZinh",
                        "content": "why is there no case nums1: 1 2 2 3 4 4. Because the problem does not mention that the elements in the array are different\\n "
                    },
                    {
                        "username": "vinnie17",
                        "content": "can anyone tell why my code is wrong?\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int a[] = nums1;\\n        int b[] = nums2;\\n\\n        int total = nums1.length + nums2.length;\\n        int half = total / 2;\\n\\n        if(nums1.length > nums2.length){\\n            a = nums2;\\n            b = nums1;\\n        }\\n        System.out.println(a.length);\\n\\n        int l = 0;\\n        int r = a.length - 1;\\n        double ans = 0.0;\\n        boolean d = true;\\n\\n        while(true){\\n            int i = (l + r) / 2; // a array index\\n            int j = half - i - 2; // b array index (it is index that is why sub 2)\\n\\n            int aLeft = Integer.MIN_VALUE;\\n            int aRight = Integer.MAX_VALUE;\\n            int bLeft = Integer.MIN_VALUE;\\n            int bRight = Integer.MAX_VALUE;\\n            if(i >= 0){\\n                aLeft = a[i];\\n            }\\n            if(i + 1 < a.length){\\n                aRight = a[i + 1];\\n            }\\n\\n            if(j >= 0){\\n                bLeft = b[j];\\n            }\\n            if(j + 1 < b.length){\\n                bRight = b[j + 1];\\n            }\\n            // int aLeft = i >= 0 ? a[i] : Integer.MIN_VALUE;\\n            // int aRight = i + 1 < a.length ? a[i + 1] : Integer.MAX_VALUE;\\n            // int bLeft = j >= 0 ? b[j] : Integer.MIN_VALUE;\\n            // int bRight = j + 1 < b.length ? b[j + 1] : Integer.MAX_VALUE;\\n\\n            if(aLeft <= bRight && bLeft <= aRight){\\n                if(total % 2 != 0){\\n                    return (double)(Math.min(aRight, bRight));\\n                    // d = false;\\n                }else{\\n                    return (double)(Math.max(aLeft, bLeft) + Math.min(aRight, bRight) / 2.0);\\n                    // d = false;\\n                }\\n            }else if(aLeft > bRight){\\n                r = i - 1;\\n            }else{\\n                l = i + 1;\\n            }\\n        }\\n        // return ans;\\n    }\\n}"
                    },
                    {
                        "username": "yousaf_10",
                        "content": "hello everyone ! if there is any senior i need to discuss something\\nbasically i am a beginner i had the approach to solve the problem but was confused about implementation, is it fair to get an idea from solutions??"
                    }
                ]
            },
            {
                "id": 2067943,
                "content": [
                    {
                        "username": "stephanlangeveld",
                        "content": "ur engrish is shitty,\\nknow the difference between mean and median. "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast c++ || Java || Python || JavaScript Solutions :\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/7b2ff572-03f8-4cbe-8fcd-7121964b3190_1645600047.26837.jpeg)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "mechinelearn",
                        "content": "Runtime: 24 ms, faster than 100.00% of C online submissions for Median of Two Sorted Arrays."
                    },
                    {
                        "username": "sachin-1401",
                        "content": "Input \\nnums1 =\\n[1,3]\\nnums2 =\\n[2,7]\\n\\n\\nOutput\\n3.25000\\n\\nExpected\\n2.50000\\n\\n `public class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double a=0;\\n         var arr=nums1.Concat(nums2).ToArray();\\n        double sum=(ReadArrayRecursively(arr,0));\\n    //    Console.WriteLine(sum);\\n    //    Console.WriteLine(arr.Length);\\n        double res=sum/arr.Length;\\n        return res;\\n\\n    }\\n     static double ReadArrayRecursively(int[] arr, int index)\\n    {\\n        \\n        // Base case: If the index is equal to the length of the array, stop recursion.\\n        if (index == arr.Length)\\n        {\\n            return 0;\\n        }\\n\\n        // Print the current element at the index.\\n        // Console.WriteLine(arr[index]);\\n\\n        // Recursively call the function with the next index.\\n        double count = arr[index] + ReadArrayRecursively(arr, index + 1);\\n        return count;\\n        \\n    }\\n}`\\n\\nWhat is wrong in this code"
                    },
                    {
                        "username": "InewsYuZinh",
                        "content": "why is there no case nums1: 1 2 2 3 4 4. Because the problem does not mention that the elements in the array are different\\n "
                    },
                    {
                        "username": "vinnie17",
                        "content": "can anyone tell why my code is wrong?\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int a[] = nums1;\\n        int b[] = nums2;\\n\\n        int total = nums1.length + nums2.length;\\n        int half = total / 2;\\n\\n        if(nums1.length > nums2.length){\\n            a = nums2;\\n            b = nums1;\\n        }\\n        System.out.println(a.length);\\n\\n        int l = 0;\\n        int r = a.length - 1;\\n        double ans = 0.0;\\n        boolean d = true;\\n\\n        while(true){\\n            int i = (l + r) / 2; // a array index\\n            int j = half - i - 2; // b array index (it is index that is why sub 2)\\n\\n            int aLeft = Integer.MIN_VALUE;\\n            int aRight = Integer.MAX_VALUE;\\n            int bLeft = Integer.MIN_VALUE;\\n            int bRight = Integer.MAX_VALUE;\\n            if(i >= 0){\\n                aLeft = a[i];\\n            }\\n            if(i + 1 < a.length){\\n                aRight = a[i + 1];\\n            }\\n\\n            if(j >= 0){\\n                bLeft = b[j];\\n            }\\n            if(j + 1 < b.length){\\n                bRight = b[j + 1];\\n            }\\n            // int aLeft = i >= 0 ? a[i] : Integer.MIN_VALUE;\\n            // int aRight = i + 1 < a.length ? a[i + 1] : Integer.MAX_VALUE;\\n            // int bLeft = j >= 0 ? b[j] : Integer.MIN_VALUE;\\n            // int bRight = j + 1 < b.length ? b[j + 1] : Integer.MAX_VALUE;\\n\\n            if(aLeft <= bRight && bLeft <= aRight){\\n                if(total % 2 != 0){\\n                    return (double)(Math.min(aRight, bRight));\\n                    // d = false;\\n                }else{\\n                    return (double)(Math.max(aLeft, bLeft) + Math.min(aRight, bRight) / 2.0);\\n                    // d = false;\\n                }\\n            }else if(aLeft > bRight){\\n                r = i - 1;\\n            }else{\\n                l = i + 1;\\n            }\\n        }\\n        // return ans;\\n    }\\n}"
                    },
                    {
                        "username": "yousaf_10",
                        "content": "hello everyone ! if there is any senior i need to discuss something\\nbasically i am a beginner i had the approach to solve the problem but was confused about implementation, is it fair to get an idea from solutions??"
                    }
                ]
            },
            {
                "id": 2067498,
                "content": [
                    {
                        "username": "stephanlangeveld",
                        "content": "ur engrish is shitty,\\nknow the difference between mean and median. "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast c++ || Java || Python || JavaScript Solutions :\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/7b2ff572-03f8-4cbe-8fcd-7121964b3190_1645600047.26837.jpeg)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "mechinelearn",
                        "content": "Runtime: 24 ms, faster than 100.00% of C online submissions for Median of Two Sorted Arrays."
                    },
                    {
                        "username": "sachin-1401",
                        "content": "Input \\nnums1 =\\n[1,3]\\nnums2 =\\n[2,7]\\n\\n\\nOutput\\n3.25000\\n\\nExpected\\n2.50000\\n\\n `public class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double a=0;\\n         var arr=nums1.Concat(nums2).ToArray();\\n        double sum=(ReadArrayRecursively(arr,0));\\n    //    Console.WriteLine(sum);\\n    //    Console.WriteLine(arr.Length);\\n        double res=sum/arr.Length;\\n        return res;\\n\\n    }\\n     static double ReadArrayRecursively(int[] arr, int index)\\n    {\\n        \\n        // Base case: If the index is equal to the length of the array, stop recursion.\\n        if (index == arr.Length)\\n        {\\n            return 0;\\n        }\\n\\n        // Print the current element at the index.\\n        // Console.WriteLine(arr[index]);\\n\\n        // Recursively call the function with the next index.\\n        double count = arr[index] + ReadArrayRecursively(arr, index + 1);\\n        return count;\\n        \\n    }\\n}`\\n\\nWhat is wrong in this code"
                    },
                    {
                        "username": "InewsYuZinh",
                        "content": "why is there no case nums1: 1 2 2 3 4 4. Because the problem does not mention that the elements in the array are different\\n "
                    },
                    {
                        "username": "vinnie17",
                        "content": "can anyone tell why my code is wrong?\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int a[] = nums1;\\n        int b[] = nums2;\\n\\n        int total = nums1.length + nums2.length;\\n        int half = total / 2;\\n\\n        if(nums1.length > nums2.length){\\n            a = nums2;\\n            b = nums1;\\n        }\\n        System.out.println(a.length);\\n\\n        int l = 0;\\n        int r = a.length - 1;\\n        double ans = 0.0;\\n        boolean d = true;\\n\\n        while(true){\\n            int i = (l + r) / 2; // a array index\\n            int j = half - i - 2; // b array index (it is index that is why sub 2)\\n\\n            int aLeft = Integer.MIN_VALUE;\\n            int aRight = Integer.MAX_VALUE;\\n            int bLeft = Integer.MIN_VALUE;\\n            int bRight = Integer.MAX_VALUE;\\n            if(i >= 0){\\n                aLeft = a[i];\\n            }\\n            if(i + 1 < a.length){\\n                aRight = a[i + 1];\\n            }\\n\\n            if(j >= 0){\\n                bLeft = b[j];\\n            }\\n            if(j + 1 < b.length){\\n                bRight = b[j + 1];\\n            }\\n            // int aLeft = i >= 0 ? a[i] : Integer.MIN_VALUE;\\n            // int aRight = i + 1 < a.length ? a[i + 1] : Integer.MAX_VALUE;\\n            // int bLeft = j >= 0 ? b[j] : Integer.MIN_VALUE;\\n            // int bRight = j + 1 < b.length ? b[j + 1] : Integer.MAX_VALUE;\\n\\n            if(aLeft <= bRight && bLeft <= aRight){\\n                if(total % 2 != 0){\\n                    return (double)(Math.min(aRight, bRight));\\n                    // d = false;\\n                }else{\\n                    return (double)(Math.max(aLeft, bLeft) + Math.min(aRight, bRight) / 2.0);\\n                    // d = false;\\n                }\\n            }else if(aLeft > bRight){\\n                r = i - 1;\\n            }else{\\n                l = i + 1;\\n            }\\n        }\\n        // return ans;\\n    }\\n}"
                    },
                    {
                        "username": "yousaf_10",
                        "content": "hello everyone ! if there is any senior i need to discuss something\\nbasically i am a beginner i had the approach to solve the problem but was confused about implementation, is it fair to get an idea from solutions??"
                    }
                ]
            },
            {
                "id": 2067408,
                "content": [
                    {
                        "username": "stephanlangeveld",
                        "content": "ur engrish is shitty,\\nknow the difference between mean and median. "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast c++ || Java || Python || JavaScript Solutions :\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "\\nFast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/7b2ff572-03f8-4cbe-8fcd-7121964b3190_1645600047.26837.jpeg)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "mechinelearn",
                        "content": "Runtime: 24 ms, faster than 100.00% of C online submissions for Median of Two Sorted Arrays."
                    },
                    {
                        "username": "sachin-1401",
                        "content": "Input \\nnums1 =\\n[1,3]\\nnums2 =\\n[2,7]\\n\\n\\nOutput\\n3.25000\\n\\nExpected\\n2.50000\\n\\n `public class Solution {\\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double a=0;\\n         var arr=nums1.Concat(nums2).ToArray();\\n        double sum=(ReadArrayRecursively(arr,0));\\n    //    Console.WriteLine(sum);\\n    //    Console.WriteLine(arr.Length);\\n        double res=sum/arr.Length;\\n        return res;\\n\\n    }\\n     static double ReadArrayRecursively(int[] arr, int index)\\n    {\\n        \\n        // Base case: If the index is equal to the length of the array, stop recursion.\\n        if (index == arr.Length)\\n        {\\n            return 0;\\n        }\\n\\n        // Print the current element at the index.\\n        // Console.WriteLine(arr[index]);\\n\\n        // Recursively call the function with the next index.\\n        double count = arr[index] + ReadArrayRecursively(arr, index + 1);\\n        return count;\\n        \\n    }\\n}`\\n\\nWhat is wrong in this code"
                    },
                    {
                        "username": "InewsYuZinh",
                        "content": "why is there no case nums1: 1 2 2 3 4 4. Because the problem does not mention that the elements in the array are different\\n "
                    },
                    {
                        "username": "vinnie17",
                        "content": "can anyone tell why my code is wrong?\\n```\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int a[] = nums1;\\n        int b[] = nums2;\\n\\n        int total = nums1.length + nums2.length;\\n        int half = total / 2;\\n\\n        if(nums1.length > nums2.length){\\n            a = nums2;\\n            b = nums1;\\n        }\\n        System.out.println(a.length);\\n\\n        int l = 0;\\n        int r = a.length - 1;\\n        double ans = 0.0;\\n        boolean d = true;\\n\\n        while(true){\\n            int i = (l + r) / 2; // a array index\\n            int j = half - i - 2; // b array index (it is index that is why sub 2)\\n\\n            int aLeft = Integer.MIN_VALUE;\\n            int aRight = Integer.MAX_VALUE;\\n            int bLeft = Integer.MIN_VALUE;\\n            int bRight = Integer.MAX_VALUE;\\n            if(i >= 0){\\n                aLeft = a[i];\\n            }\\n            if(i + 1 < a.length){\\n                aRight = a[i + 1];\\n            }\\n\\n            if(j >= 0){\\n                bLeft = b[j];\\n            }\\n            if(j + 1 < b.length){\\n                bRight = b[j + 1];\\n            }\\n            // int aLeft = i >= 0 ? a[i] : Integer.MIN_VALUE;\\n            // int aRight = i + 1 < a.length ? a[i + 1] : Integer.MAX_VALUE;\\n            // int bLeft = j >= 0 ? b[j] : Integer.MIN_VALUE;\\n            // int bRight = j + 1 < b.length ? b[j + 1] : Integer.MAX_VALUE;\\n\\n            if(aLeft <= bRight && bLeft <= aRight){\\n                if(total % 2 != 0){\\n                    return (double)(Math.min(aRight, bRight));\\n                    // d = false;\\n                }else{\\n                    return (double)(Math.max(aLeft, bLeft) + Math.min(aRight, bRight) / 2.0);\\n                    // d = false;\\n                }\\n            }else if(aLeft > bRight){\\n                r = i - 1;\\n            }else{\\n                l = i + 1;\\n            }\\n        }\\n        // return ans;\\n    }\\n}"
                    },
                    {
                        "username": "yousaf_10",
                        "content": "hello everyone ! if there is any senior i need to discuss something\\nbasically i am a beginner i had the approach to solve the problem but was confused about implementation, is it fair to get an idea from solutions??"
                    }
                ]
            },
            {
                "id": 2067347,
                "content": [
                    {
                        "username": "ExPLICIT_27",
                        "content": "the interpreter doesn\\'t know math I suppose cause my code is giving me a proper answer in all other environments except here."
                    },
                    {
                        "username": "kyxap",
                        "content": "it\\'s medium like if u do not want to try to do it with O(log (m+n))"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its easy with no log. Just merging two sorted arrays"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I don\\'t think that someone can solve this problem in an interview with O(ln(n+m)) time complexity... "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "like one of the most liked comments stated, this is something most will need to remember first not come up with it new."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "I solved this in $O((n + m)log(n + m))$ time complexity, which implies merging the two arrays, sorting them, and finding the median in constant time. This should not be an accepted solution to the problem. The test cases should throw a TLE."
                    },
                    {
                        "username": "Zefick",
                        "content": "You can merge two sorted arrays in linear time (it\\'s literally the merge phase in the Merge sort). So the final complexity would be O(n + m).\\nProblems on this site often rely on your honesty. In addition, sometimes it\\'s just not possible to make adequate test cases to prevent cheating. You can cheat here, but it will not help you in a real interview."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Solving The Solved one is So much fun"
                    },
                    {
                        "username": "user1326Ds",
                        "content": "Python3 code;\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1=sorted(nums1)\\n        n= len(nums1)\\n        if n%2==0:\\n            mid1= nums1[n//2]\\n            mid2= nums1[n//2 - 1]\\n            mid=(mid1+mid2)/2\\n        else:\\n            mid= nums1[n//2]\\n        return mid"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    static int[] merge(int[] arr1 , int[] arr2){\\n        int[] ans = new int[arr1.length+arr2.length];\\n        int i=0,j=0;\\n        for(;i<arr1.length && j<arr2.length;){\\n            if(arr1[i]<=arr2[j]){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }else{\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        if(j==arr2.length){\\n            while(i!=arr1.length){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }else{\\n            while(j!=arr2.length){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] arr = merge(nums1,nums2);\\n        if(arr.length%2==0){\\n            return (double)(arr[arr.length/2] + arr[(arr.length/2)-1])/2;\\n        }\\n        return arr[arr.length/2];\\n    }\\n}"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Funny tip: using 2 pointers nums1Pointer and nums2Pointer and advancing them based on the smaller value (so O (n+m) / 2 complexity) still beats 100% with 1ms."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you ignored a constraint and will fail the interview youre preparing for. not fun."
                    },
                    {
                        "username": "chenon",
                        "content": "Medium question for O(n) solution not a Hard one.\\nIt made my day.\\n\\nThe key thing to note to calculate the median is the value in the middle of a sorted list, array\\n\\nTo calculate the median :\\n- if the array length is even, the median is the average the 2 values at the middle\\n- if the array length is odd, the median is value in the middle `nums[mid]`\\n\\nYou have 2 sorted arrays, it is a matter to find the elements in the middle. \\nOK my solution is only O(n).\\n\\nAt least, I didn\\'t memorize anything."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "the interview still is failed, because you ignored a constraint for O(log(n+m)).\nok maybe the other ones do far worse than that."
                    },
                    {
                        "username": "s3stan",
                        "content": "The O(m+n) algorithm doesn\\'t look too bad: `Beats 41.02%of users with JavaScript`"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@lucasscodes](/lucasscodes) \\nI absolutely agree with you. We have not gathered here to look for simple solutions. And develop your algorithmic skills. And if the problem requires solving O(log(m + n)), then it needs to be solved that way.\\nAnd my remark was with some degree of sarcasm. In the sense that a solution with a certain efficiency is required. And an ineffective solution works quite well."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "ignore a failed implementation for runtime checks, its just impossible for the general case!\n\n-Assume that a machine exists that can determine the time complexity of any arbitrary algorithm.\n-This would imply that the algorithm halts, because time complexity is only defined for algorithms that eventually halt.\n-Therefore, this machine could solve the Halting Problem by determining whether any arbitrary algorithm halts.\n-But we know from Turing’s proof that the Halting Problem is undecidable - there’s no machine that can solve it for all possible inputs.\n-This leads to a contradiction, so our original assumption (that a machine exists that can determine the time complexity of any arbitrary algorithm) must be false.\n\nfollow the constraint to learn and answere this question well in a interview."
                    }
                ]
            },
            {
                "id": 2067344,
                "content": [
                    {
                        "username": "ExPLICIT_27",
                        "content": "the interpreter doesn\\'t know math I suppose cause my code is giving me a proper answer in all other environments except here."
                    },
                    {
                        "username": "kyxap",
                        "content": "it\\'s medium like if u do not want to try to do it with O(log (m+n))"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its easy with no log. Just merging two sorted arrays"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I don\\'t think that someone can solve this problem in an interview with O(ln(n+m)) time complexity... "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "like one of the most liked comments stated, this is something most will need to remember first not come up with it new."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "I solved this in $O((n + m)log(n + m))$ time complexity, which implies merging the two arrays, sorting them, and finding the median in constant time. This should not be an accepted solution to the problem. The test cases should throw a TLE."
                    },
                    {
                        "username": "Zefick",
                        "content": "You can merge two sorted arrays in linear time (it\\'s literally the merge phase in the Merge sort). So the final complexity would be O(n + m).\\nProblems on this site often rely on your honesty. In addition, sometimes it\\'s just not possible to make adequate test cases to prevent cheating. You can cheat here, but it will not help you in a real interview."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Solving The Solved one is So much fun"
                    },
                    {
                        "username": "user1326Ds",
                        "content": "Python3 code;\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1=sorted(nums1)\\n        n= len(nums1)\\n        if n%2==0:\\n            mid1= nums1[n//2]\\n            mid2= nums1[n//2 - 1]\\n            mid=(mid1+mid2)/2\\n        else:\\n            mid= nums1[n//2]\\n        return mid"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    static int[] merge(int[] arr1 , int[] arr2){\\n        int[] ans = new int[arr1.length+arr2.length];\\n        int i=0,j=0;\\n        for(;i<arr1.length && j<arr2.length;){\\n            if(arr1[i]<=arr2[j]){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }else{\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        if(j==arr2.length){\\n            while(i!=arr1.length){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }else{\\n            while(j!=arr2.length){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] arr = merge(nums1,nums2);\\n        if(arr.length%2==0){\\n            return (double)(arr[arr.length/2] + arr[(arr.length/2)-1])/2;\\n        }\\n        return arr[arr.length/2];\\n    }\\n}"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Funny tip: using 2 pointers nums1Pointer and nums2Pointer and advancing them based on the smaller value (so O (n+m) / 2 complexity) still beats 100% with 1ms."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you ignored a constraint and will fail the interview youre preparing for. not fun."
                    },
                    {
                        "username": "chenon",
                        "content": "Medium question for O(n) solution not a Hard one.\\nIt made my day.\\n\\nThe key thing to note to calculate the median is the value in the middle of a sorted list, array\\n\\nTo calculate the median :\\n- if the array length is even, the median is the average the 2 values at the middle\\n- if the array length is odd, the median is value in the middle `nums[mid]`\\n\\nYou have 2 sorted arrays, it is a matter to find the elements in the middle. \\nOK my solution is only O(n).\\n\\nAt least, I didn\\'t memorize anything."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "the interview still is failed, because you ignored a constraint for O(log(n+m)).\nok maybe the other ones do far worse than that."
                    },
                    {
                        "username": "s3stan",
                        "content": "The O(m+n) algorithm doesn\\'t look too bad: `Beats 41.02%of users with JavaScript`"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@lucasscodes](/lucasscodes) \\nI absolutely agree with you. We have not gathered here to look for simple solutions. And develop your algorithmic skills. And if the problem requires solving O(log(m + n)), then it needs to be solved that way.\\nAnd my remark was with some degree of sarcasm. In the sense that a solution with a certain efficiency is required. And an ineffective solution works quite well."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "ignore a failed implementation for runtime checks, its just impossible for the general case!\n\n-Assume that a machine exists that can determine the time complexity of any arbitrary algorithm.\n-This would imply that the algorithm halts, because time complexity is only defined for algorithms that eventually halt.\n-Therefore, this machine could solve the Halting Problem by determining whether any arbitrary algorithm halts.\n-But we know from Turing’s proof that the Halting Problem is undecidable - there’s no machine that can solve it for all possible inputs.\n-This leads to a contradiction, so our original assumption (that a machine exists that can determine the time complexity of any arbitrary algorithm) must be false.\n\nfollow the constraint to learn and answere this question well in a interview."
                    }
                ]
            },
            {
                "id": 2067207,
                "content": [
                    {
                        "username": "ExPLICIT_27",
                        "content": "the interpreter doesn\\'t know math I suppose cause my code is giving me a proper answer in all other environments except here."
                    },
                    {
                        "username": "kyxap",
                        "content": "it\\'s medium like if u do not want to try to do it with O(log (m+n))"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its easy with no log. Just merging two sorted arrays"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I don\\'t think that someone can solve this problem in an interview with O(ln(n+m)) time complexity... "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "like one of the most liked comments stated, this is something most will need to remember first not come up with it new."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "I solved this in $O((n + m)log(n + m))$ time complexity, which implies merging the two arrays, sorting them, and finding the median in constant time. This should not be an accepted solution to the problem. The test cases should throw a TLE."
                    },
                    {
                        "username": "Zefick",
                        "content": "You can merge two sorted arrays in linear time (it\\'s literally the merge phase in the Merge sort). So the final complexity would be O(n + m).\\nProblems on this site often rely on your honesty. In addition, sometimes it\\'s just not possible to make adequate test cases to prevent cheating. You can cheat here, but it will not help you in a real interview."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Solving The Solved one is So much fun"
                    },
                    {
                        "username": "user1326Ds",
                        "content": "Python3 code;\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1=sorted(nums1)\\n        n= len(nums1)\\n        if n%2==0:\\n            mid1= nums1[n//2]\\n            mid2= nums1[n//2 - 1]\\n            mid=(mid1+mid2)/2\\n        else:\\n            mid= nums1[n//2]\\n        return mid"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    static int[] merge(int[] arr1 , int[] arr2){\\n        int[] ans = new int[arr1.length+arr2.length];\\n        int i=0,j=0;\\n        for(;i<arr1.length && j<arr2.length;){\\n            if(arr1[i]<=arr2[j]){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }else{\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        if(j==arr2.length){\\n            while(i!=arr1.length){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }else{\\n            while(j!=arr2.length){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] arr = merge(nums1,nums2);\\n        if(arr.length%2==0){\\n            return (double)(arr[arr.length/2] + arr[(arr.length/2)-1])/2;\\n        }\\n        return arr[arr.length/2];\\n    }\\n}"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Funny tip: using 2 pointers nums1Pointer and nums2Pointer and advancing them based on the smaller value (so O (n+m) / 2 complexity) still beats 100% with 1ms."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you ignored a constraint and will fail the interview youre preparing for. not fun."
                    },
                    {
                        "username": "chenon",
                        "content": "Medium question for O(n) solution not a Hard one.\\nIt made my day.\\n\\nThe key thing to note to calculate the median is the value in the middle of a sorted list, array\\n\\nTo calculate the median :\\n- if the array length is even, the median is the average the 2 values at the middle\\n- if the array length is odd, the median is value in the middle `nums[mid]`\\n\\nYou have 2 sorted arrays, it is a matter to find the elements in the middle. \\nOK my solution is only O(n).\\n\\nAt least, I didn\\'t memorize anything."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "the interview still is failed, because you ignored a constraint for O(log(n+m)).\nok maybe the other ones do far worse than that."
                    },
                    {
                        "username": "s3stan",
                        "content": "The O(m+n) algorithm doesn\\'t look too bad: `Beats 41.02%of users with JavaScript`"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@lucasscodes](/lucasscodes) \\nI absolutely agree with you. We have not gathered here to look for simple solutions. And develop your algorithmic skills. And if the problem requires solving O(log(m + n)), then it needs to be solved that way.\\nAnd my remark was with some degree of sarcasm. In the sense that a solution with a certain efficiency is required. And an ineffective solution works quite well."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "ignore a failed implementation for runtime checks, its just impossible for the general case!\n\n-Assume that a machine exists that can determine the time complexity of any arbitrary algorithm.\n-This would imply that the algorithm halts, because time complexity is only defined for algorithms that eventually halt.\n-Therefore, this machine could solve the Halting Problem by determining whether any arbitrary algorithm halts.\n-But we know from Turing’s proof that the Halting Problem is undecidable - there’s no machine that can solve it for all possible inputs.\n-This leads to a contradiction, so our original assumption (that a machine exists that can determine the time complexity of any arbitrary algorithm) must be false.\n\nfollow the constraint to learn and answere this question well in a interview."
                    }
                ]
            },
            {
                "id": 2067204,
                "content": [
                    {
                        "username": "ExPLICIT_27",
                        "content": "the interpreter doesn\\'t know math I suppose cause my code is giving me a proper answer in all other environments except here."
                    },
                    {
                        "username": "kyxap",
                        "content": "it\\'s medium like if u do not want to try to do it with O(log (m+n))"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its easy with no log. Just merging two sorted arrays"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I don\\'t think that someone can solve this problem in an interview with O(ln(n+m)) time complexity... "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "like one of the most liked comments stated, this is something most will need to remember first not come up with it new."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "I solved this in $O((n + m)log(n + m))$ time complexity, which implies merging the two arrays, sorting them, and finding the median in constant time. This should not be an accepted solution to the problem. The test cases should throw a TLE."
                    },
                    {
                        "username": "Zefick",
                        "content": "You can merge two sorted arrays in linear time (it\\'s literally the merge phase in the Merge sort). So the final complexity would be O(n + m).\\nProblems on this site often rely on your honesty. In addition, sometimes it\\'s just not possible to make adequate test cases to prevent cheating. You can cheat here, but it will not help you in a real interview."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Solving The Solved one is So much fun"
                    },
                    {
                        "username": "user1326Ds",
                        "content": "Python3 code;\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1=sorted(nums1)\\n        n= len(nums1)\\n        if n%2==0:\\n            mid1= nums1[n//2]\\n            mid2= nums1[n//2 - 1]\\n            mid=(mid1+mid2)/2\\n        else:\\n            mid= nums1[n//2]\\n        return mid"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    static int[] merge(int[] arr1 , int[] arr2){\\n        int[] ans = new int[arr1.length+arr2.length];\\n        int i=0,j=0;\\n        for(;i<arr1.length && j<arr2.length;){\\n            if(arr1[i]<=arr2[j]){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }else{\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        if(j==arr2.length){\\n            while(i!=arr1.length){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }else{\\n            while(j!=arr2.length){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] arr = merge(nums1,nums2);\\n        if(arr.length%2==0){\\n            return (double)(arr[arr.length/2] + arr[(arr.length/2)-1])/2;\\n        }\\n        return arr[arr.length/2];\\n    }\\n}"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Funny tip: using 2 pointers nums1Pointer and nums2Pointer and advancing them based on the smaller value (so O (n+m) / 2 complexity) still beats 100% with 1ms."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you ignored a constraint and will fail the interview youre preparing for. not fun."
                    },
                    {
                        "username": "chenon",
                        "content": "Medium question for O(n) solution not a Hard one.\\nIt made my day.\\n\\nThe key thing to note to calculate the median is the value in the middle of a sorted list, array\\n\\nTo calculate the median :\\n- if the array length is even, the median is the average the 2 values at the middle\\n- if the array length is odd, the median is value in the middle `nums[mid]`\\n\\nYou have 2 sorted arrays, it is a matter to find the elements in the middle. \\nOK my solution is only O(n).\\n\\nAt least, I didn\\'t memorize anything."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "the interview still is failed, because you ignored a constraint for O(log(n+m)).\nok maybe the other ones do far worse than that."
                    },
                    {
                        "username": "s3stan",
                        "content": "The O(m+n) algorithm doesn\\'t look too bad: `Beats 41.02%of users with JavaScript`"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@lucasscodes](/lucasscodes) \\nI absolutely agree with you. We have not gathered here to look for simple solutions. And develop your algorithmic skills. And if the problem requires solving O(log(m + n)), then it needs to be solved that way.\\nAnd my remark was with some degree of sarcasm. In the sense that a solution with a certain efficiency is required. And an ineffective solution works quite well."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "ignore a failed implementation for runtime checks, its just impossible for the general case!\n\n-Assume that a machine exists that can determine the time complexity of any arbitrary algorithm.\n-This would imply that the algorithm halts, because time complexity is only defined for algorithms that eventually halt.\n-Therefore, this machine could solve the Halting Problem by determining whether any arbitrary algorithm halts.\n-But we know from Turing’s proof that the Halting Problem is undecidable - there’s no machine that can solve it for all possible inputs.\n-This leads to a contradiction, so our original assumption (that a machine exists that can determine the time complexity of any arbitrary algorithm) must be false.\n\nfollow the constraint to learn and answere this question well in a interview."
                    }
                ]
            },
            {
                "id": 2067203,
                "content": [
                    {
                        "username": "ExPLICIT_27",
                        "content": "the interpreter doesn\\'t know math I suppose cause my code is giving me a proper answer in all other environments except here."
                    },
                    {
                        "username": "kyxap",
                        "content": "it\\'s medium like if u do not want to try to do it with O(log (m+n))"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its easy with no log. Just merging two sorted arrays"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I don\\'t think that someone can solve this problem in an interview with O(ln(n+m)) time complexity... "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "like one of the most liked comments stated, this is something most will need to remember first not come up with it new."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "I solved this in $O((n + m)log(n + m))$ time complexity, which implies merging the two arrays, sorting them, and finding the median in constant time. This should not be an accepted solution to the problem. The test cases should throw a TLE."
                    },
                    {
                        "username": "Zefick",
                        "content": "You can merge two sorted arrays in linear time (it\\'s literally the merge phase in the Merge sort). So the final complexity would be O(n + m).\\nProblems on this site often rely on your honesty. In addition, sometimes it\\'s just not possible to make adequate test cases to prevent cheating. You can cheat here, but it will not help you in a real interview."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Solving The Solved one is So much fun"
                    },
                    {
                        "username": "user1326Ds",
                        "content": "Python3 code;\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1=sorted(nums1)\\n        n= len(nums1)\\n        if n%2==0:\\n            mid1= nums1[n//2]\\n            mid2= nums1[n//2 - 1]\\n            mid=(mid1+mid2)/2\\n        else:\\n            mid= nums1[n//2]\\n        return mid"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    static int[] merge(int[] arr1 , int[] arr2){\\n        int[] ans = new int[arr1.length+arr2.length];\\n        int i=0,j=0;\\n        for(;i<arr1.length && j<arr2.length;){\\n            if(arr1[i]<=arr2[j]){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }else{\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        if(j==arr2.length){\\n            while(i!=arr1.length){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }else{\\n            while(j!=arr2.length){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] arr = merge(nums1,nums2);\\n        if(arr.length%2==0){\\n            return (double)(arr[arr.length/2] + arr[(arr.length/2)-1])/2;\\n        }\\n        return arr[arr.length/2];\\n    }\\n}"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Funny tip: using 2 pointers nums1Pointer and nums2Pointer and advancing them based on the smaller value (so O (n+m) / 2 complexity) still beats 100% with 1ms."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you ignored a constraint and will fail the interview youre preparing for. not fun."
                    },
                    {
                        "username": "chenon",
                        "content": "Medium question for O(n) solution not a Hard one.\\nIt made my day.\\n\\nThe key thing to note to calculate the median is the value in the middle of a sorted list, array\\n\\nTo calculate the median :\\n- if the array length is even, the median is the average the 2 values at the middle\\n- if the array length is odd, the median is value in the middle `nums[mid]`\\n\\nYou have 2 sorted arrays, it is a matter to find the elements in the middle. \\nOK my solution is only O(n).\\n\\nAt least, I didn\\'t memorize anything."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "the interview still is failed, because you ignored a constraint for O(log(n+m)).\nok maybe the other ones do far worse than that."
                    },
                    {
                        "username": "s3stan",
                        "content": "The O(m+n) algorithm doesn\\'t look too bad: `Beats 41.02%of users with JavaScript`"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@lucasscodes](/lucasscodes) \\nI absolutely agree with you. We have not gathered here to look for simple solutions. And develop your algorithmic skills. And if the problem requires solving O(log(m + n)), then it needs to be solved that way.\\nAnd my remark was with some degree of sarcasm. In the sense that a solution with a certain efficiency is required. And an ineffective solution works quite well."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "ignore a failed implementation for runtime checks, its just impossible for the general case!\n\n-Assume that a machine exists that can determine the time complexity of any arbitrary algorithm.\n-This would imply that the algorithm halts, because time complexity is only defined for algorithms that eventually halt.\n-Therefore, this machine could solve the Halting Problem by determining whether any arbitrary algorithm halts.\n-But we know from Turing’s proof that the Halting Problem is undecidable - there’s no machine that can solve it for all possible inputs.\n-This leads to a contradiction, so our original assumption (that a machine exists that can determine the time complexity of any arbitrary algorithm) must be false.\n\nfollow the constraint to learn and answere this question well in a interview."
                    }
                ]
            },
            {
                "id": 2067192,
                "content": [
                    {
                        "username": "ExPLICIT_27",
                        "content": "the interpreter doesn\\'t know math I suppose cause my code is giving me a proper answer in all other environments except here."
                    },
                    {
                        "username": "kyxap",
                        "content": "it\\'s medium like if u do not want to try to do it with O(log (m+n))"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its easy with no log. Just merging two sorted arrays"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I don\\'t think that someone can solve this problem in an interview with O(ln(n+m)) time complexity... "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "like one of the most liked comments stated, this is something most will need to remember first not come up with it new."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "I solved this in $O((n + m)log(n + m))$ time complexity, which implies merging the two arrays, sorting them, and finding the median in constant time. This should not be an accepted solution to the problem. The test cases should throw a TLE."
                    },
                    {
                        "username": "Zefick",
                        "content": "You can merge two sorted arrays in linear time (it\\'s literally the merge phase in the Merge sort). So the final complexity would be O(n + m).\\nProblems on this site often rely on your honesty. In addition, sometimes it\\'s just not possible to make adequate test cases to prevent cheating. You can cheat here, but it will not help you in a real interview."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Solving The Solved one is So much fun"
                    },
                    {
                        "username": "user1326Ds",
                        "content": "Python3 code;\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1=sorted(nums1)\\n        n= len(nums1)\\n        if n%2==0:\\n            mid1= nums1[n//2]\\n            mid2= nums1[n//2 - 1]\\n            mid=(mid1+mid2)/2\\n        else:\\n            mid= nums1[n//2]\\n        return mid"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    static int[] merge(int[] arr1 , int[] arr2){\\n        int[] ans = new int[arr1.length+arr2.length];\\n        int i=0,j=0;\\n        for(;i<arr1.length && j<arr2.length;){\\n            if(arr1[i]<=arr2[j]){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }else{\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        if(j==arr2.length){\\n            while(i!=arr1.length){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }else{\\n            while(j!=arr2.length){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] arr = merge(nums1,nums2);\\n        if(arr.length%2==0){\\n            return (double)(arr[arr.length/2] + arr[(arr.length/2)-1])/2;\\n        }\\n        return arr[arr.length/2];\\n    }\\n}"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Funny tip: using 2 pointers nums1Pointer and nums2Pointer and advancing them based on the smaller value (so O (n+m) / 2 complexity) still beats 100% with 1ms."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you ignored a constraint and will fail the interview youre preparing for. not fun."
                    },
                    {
                        "username": "chenon",
                        "content": "Medium question for O(n) solution not a Hard one.\\nIt made my day.\\n\\nThe key thing to note to calculate the median is the value in the middle of a sorted list, array\\n\\nTo calculate the median :\\n- if the array length is even, the median is the average the 2 values at the middle\\n- if the array length is odd, the median is value in the middle `nums[mid]`\\n\\nYou have 2 sorted arrays, it is a matter to find the elements in the middle. \\nOK my solution is only O(n).\\n\\nAt least, I didn\\'t memorize anything."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "the interview still is failed, because you ignored a constraint for O(log(n+m)).\nok maybe the other ones do far worse than that."
                    },
                    {
                        "username": "s3stan",
                        "content": "The O(m+n) algorithm doesn\\'t look too bad: `Beats 41.02%of users with JavaScript`"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@lucasscodes](/lucasscodes) \\nI absolutely agree with you. We have not gathered here to look for simple solutions. And develop your algorithmic skills. And if the problem requires solving O(log(m + n)), then it needs to be solved that way.\\nAnd my remark was with some degree of sarcasm. In the sense that a solution with a certain efficiency is required. And an ineffective solution works quite well."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "ignore a failed implementation for runtime checks, its just impossible for the general case!\n\n-Assume that a machine exists that can determine the time complexity of any arbitrary algorithm.\n-This would imply that the algorithm halts, because time complexity is only defined for algorithms that eventually halt.\n-Therefore, this machine could solve the Halting Problem by determining whether any arbitrary algorithm halts.\n-But we know from Turing’s proof that the Halting Problem is undecidable - there’s no machine that can solve it for all possible inputs.\n-This leads to a contradiction, so our original assumption (that a machine exists that can determine the time complexity of any arbitrary algorithm) must be false.\n\nfollow the constraint to learn and answere this question well in a interview."
                    }
                ]
            },
            {
                "id": 2067152,
                "content": [
                    {
                        "username": "ExPLICIT_27",
                        "content": "the interpreter doesn\\'t know math I suppose cause my code is giving me a proper answer in all other environments except here."
                    },
                    {
                        "username": "kyxap",
                        "content": "it\\'s medium like if u do not want to try to do it with O(log (m+n))"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its easy with no log. Just merging two sorted arrays"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I don\\'t think that someone can solve this problem in an interview with O(ln(n+m)) time complexity... "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "like one of the most liked comments stated, this is something most will need to remember first not come up with it new."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "I solved this in $O((n + m)log(n + m))$ time complexity, which implies merging the two arrays, sorting them, and finding the median in constant time. This should not be an accepted solution to the problem. The test cases should throw a TLE."
                    },
                    {
                        "username": "Zefick",
                        "content": "You can merge two sorted arrays in linear time (it\\'s literally the merge phase in the Merge sort). So the final complexity would be O(n + m).\\nProblems on this site often rely on your honesty. In addition, sometimes it\\'s just not possible to make adequate test cases to prevent cheating. You can cheat here, but it will not help you in a real interview."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Solving The Solved one is So much fun"
                    },
                    {
                        "username": "user1326Ds",
                        "content": "Python3 code;\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1=sorted(nums1)\\n        n= len(nums1)\\n        if n%2==0:\\n            mid1= nums1[n//2]\\n            mid2= nums1[n//2 - 1]\\n            mid=(mid1+mid2)/2\\n        else:\\n            mid= nums1[n//2]\\n        return mid"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    static int[] merge(int[] arr1 , int[] arr2){\\n        int[] ans = new int[arr1.length+arr2.length];\\n        int i=0,j=0;\\n        for(;i<arr1.length && j<arr2.length;){\\n            if(arr1[i]<=arr2[j]){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }else{\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        if(j==arr2.length){\\n            while(i!=arr1.length){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }else{\\n            while(j!=arr2.length){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] arr = merge(nums1,nums2);\\n        if(arr.length%2==0){\\n            return (double)(arr[arr.length/2] + arr[(arr.length/2)-1])/2;\\n        }\\n        return arr[arr.length/2];\\n    }\\n}"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Funny tip: using 2 pointers nums1Pointer and nums2Pointer and advancing them based on the smaller value (so O (n+m) / 2 complexity) still beats 100% with 1ms."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you ignored a constraint and will fail the interview youre preparing for. not fun."
                    },
                    {
                        "username": "chenon",
                        "content": "Medium question for O(n) solution not a Hard one.\\nIt made my day.\\n\\nThe key thing to note to calculate the median is the value in the middle of a sorted list, array\\n\\nTo calculate the median :\\n- if the array length is even, the median is the average the 2 values at the middle\\n- if the array length is odd, the median is value in the middle `nums[mid]`\\n\\nYou have 2 sorted arrays, it is a matter to find the elements in the middle. \\nOK my solution is only O(n).\\n\\nAt least, I didn\\'t memorize anything."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "the interview still is failed, because you ignored a constraint for O(log(n+m)).\nok maybe the other ones do far worse than that."
                    },
                    {
                        "username": "s3stan",
                        "content": "The O(m+n) algorithm doesn\\'t look too bad: `Beats 41.02%of users with JavaScript`"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@lucasscodes](/lucasscodes) \\nI absolutely agree with you. We have not gathered here to look for simple solutions. And develop your algorithmic skills. And if the problem requires solving O(log(m + n)), then it needs to be solved that way.\\nAnd my remark was with some degree of sarcasm. In the sense that a solution with a certain efficiency is required. And an ineffective solution works quite well."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "ignore a failed implementation for runtime checks, its just impossible for the general case!\n\n-Assume that a machine exists that can determine the time complexity of any arbitrary algorithm.\n-This would imply that the algorithm halts, because time complexity is only defined for algorithms that eventually halt.\n-Therefore, this machine could solve the Halting Problem by determining whether any arbitrary algorithm halts.\n-But we know from Turing’s proof that the Halting Problem is undecidable - there’s no machine that can solve it for all possible inputs.\n-This leads to a contradiction, so our original assumption (that a machine exists that can determine the time complexity of any arbitrary algorithm) must be false.\n\nfollow the constraint to learn and answere this question well in a interview."
                    }
                ]
            },
            {
                "id": 2067150,
                "content": [
                    {
                        "username": "ExPLICIT_27",
                        "content": "the interpreter doesn\\'t know math I suppose cause my code is giving me a proper answer in all other environments except here."
                    },
                    {
                        "username": "kyxap",
                        "content": "it\\'s medium like if u do not want to try to do it with O(log (m+n))"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its easy with no log. Just merging two sorted arrays"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I don\\'t think that someone can solve this problem in an interview with O(ln(n+m)) time complexity... "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "like one of the most liked comments stated, this is something most will need to remember first not come up with it new."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "I solved this in $O((n + m)log(n + m))$ time complexity, which implies merging the two arrays, sorting them, and finding the median in constant time. This should not be an accepted solution to the problem. The test cases should throw a TLE."
                    },
                    {
                        "username": "Zefick",
                        "content": "You can merge two sorted arrays in linear time (it\\'s literally the merge phase in the Merge sort). So the final complexity would be O(n + m).\\nProblems on this site often rely on your honesty. In addition, sometimes it\\'s just not possible to make adequate test cases to prevent cheating. You can cheat here, but it will not help you in a real interview."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Solving The Solved one is So much fun"
                    },
                    {
                        "username": "user1326Ds",
                        "content": "Python3 code;\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1=sorted(nums1)\\n        n= len(nums1)\\n        if n%2==0:\\n            mid1= nums1[n//2]\\n            mid2= nums1[n//2 - 1]\\n            mid=(mid1+mid2)/2\\n        else:\\n            mid= nums1[n//2]\\n        return mid"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    static int[] merge(int[] arr1 , int[] arr2){\\n        int[] ans = new int[arr1.length+arr2.length];\\n        int i=0,j=0;\\n        for(;i<arr1.length && j<arr2.length;){\\n            if(arr1[i]<=arr2[j]){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }else{\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        if(j==arr2.length){\\n            while(i!=arr1.length){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }else{\\n            while(j!=arr2.length){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] arr = merge(nums1,nums2);\\n        if(arr.length%2==0){\\n            return (double)(arr[arr.length/2] + arr[(arr.length/2)-1])/2;\\n        }\\n        return arr[arr.length/2];\\n    }\\n}"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Funny tip: using 2 pointers nums1Pointer and nums2Pointer and advancing them based on the smaller value (so O (n+m) / 2 complexity) still beats 100% with 1ms."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you ignored a constraint and will fail the interview youre preparing for. not fun."
                    },
                    {
                        "username": "chenon",
                        "content": "Medium question for O(n) solution not a Hard one.\\nIt made my day.\\n\\nThe key thing to note to calculate the median is the value in the middle of a sorted list, array\\n\\nTo calculate the median :\\n- if the array length is even, the median is the average the 2 values at the middle\\n- if the array length is odd, the median is value in the middle `nums[mid]`\\n\\nYou have 2 sorted arrays, it is a matter to find the elements in the middle. \\nOK my solution is only O(n).\\n\\nAt least, I didn\\'t memorize anything."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "the interview still is failed, because you ignored a constraint for O(log(n+m)).\nok maybe the other ones do far worse than that."
                    },
                    {
                        "username": "s3stan",
                        "content": "The O(m+n) algorithm doesn\\'t look too bad: `Beats 41.02%of users with JavaScript`"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@lucasscodes](/lucasscodes) \\nI absolutely agree with you. We have not gathered here to look for simple solutions. And develop your algorithmic skills. And if the problem requires solving O(log(m + n)), then it needs to be solved that way.\\nAnd my remark was with some degree of sarcasm. In the sense that a solution with a certain efficiency is required. And an ineffective solution works quite well."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "ignore a failed implementation for runtime checks, its just impossible for the general case!\n\n-Assume that a machine exists that can determine the time complexity of any arbitrary algorithm.\n-This would imply that the algorithm halts, because time complexity is only defined for algorithms that eventually halt.\n-Therefore, this machine could solve the Halting Problem by determining whether any arbitrary algorithm halts.\n-But we know from Turing’s proof that the Halting Problem is undecidable - there’s no machine that can solve it for all possible inputs.\n-This leads to a contradiction, so our original assumption (that a machine exists that can determine the time complexity of any arbitrary algorithm) must be false.\n\nfollow the constraint to learn and answere this question well in a interview."
                    }
                ]
            },
            {
                "id": 2067115,
                "content": [
                    {
                        "username": "ExPLICIT_27",
                        "content": "the interpreter doesn\\'t know math I suppose cause my code is giving me a proper answer in all other environments except here."
                    },
                    {
                        "username": "kyxap",
                        "content": "it\\'s medium like if u do not want to try to do it with O(log (m+n))"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its easy with no log. Just merging two sorted arrays"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I don\\'t think that someone can solve this problem in an interview with O(ln(n+m)) time complexity... "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "like one of the most liked comments stated, this is something most will need to remember first not come up with it new."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "I solved this in $O((n + m)log(n + m))$ time complexity, which implies merging the two arrays, sorting them, and finding the median in constant time. This should not be an accepted solution to the problem. The test cases should throw a TLE."
                    },
                    {
                        "username": "Zefick",
                        "content": "You can merge two sorted arrays in linear time (it\\'s literally the merge phase in the Merge sort). So the final complexity would be O(n + m).\\nProblems on this site often rely on your honesty. In addition, sometimes it\\'s just not possible to make adequate test cases to prevent cheating. You can cheat here, but it will not help you in a real interview."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Solving The Solved one is So much fun"
                    },
                    {
                        "username": "user1326Ds",
                        "content": "Python3 code;\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1=sorted(nums1)\\n        n= len(nums1)\\n        if n%2==0:\\n            mid1= nums1[n//2]\\n            mid2= nums1[n//2 - 1]\\n            mid=(mid1+mid2)/2\\n        else:\\n            mid= nums1[n//2]\\n        return mid"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    static int[] merge(int[] arr1 , int[] arr2){\\n        int[] ans = new int[arr1.length+arr2.length];\\n        int i=0,j=0;\\n        for(;i<arr1.length && j<arr2.length;){\\n            if(arr1[i]<=arr2[j]){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }else{\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        if(j==arr2.length){\\n            while(i!=arr1.length){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }else{\\n            while(j!=arr2.length){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] arr = merge(nums1,nums2);\\n        if(arr.length%2==0){\\n            return (double)(arr[arr.length/2] + arr[(arr.length/2)-1])/2;\\n        }\\n        return arr[arr.length/2];\\n    }\\n}"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Funny tip: using 2 pointers nums1Pointer and nums2Pointer and advancing them based on the smaller value (so O (n+m) / 2 complexity) still beats 100% with 1ms."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you ignored a constraint and will fail the interview youre preparing for. not fun."
                    },
                    {
                        "username": "chenon",
                        "content": "Medium question for O(n) solution not a Hard one.\\nIt made my day.\\n\\nThe key thing to note to calculate the median is the value in the middle of a sorted list, array\\n\\nTo calculate the median :\\n- if the array length is even, the median is the average the 2 values at the middle\\n- if the array length is odd, the median is value in the middle `nums[mid]`\\n\\nYou have 2 sorted arrays, it is a matter to find the elements in the middle. \\nOK my solution is only O(n).\\n\\nAt least, I didn\\'t memorize anything."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "the interview still is failed, because you ignored a constraint for O(log(n+m)).\nok maybe the other ones do far worse than that."
                    },
                    {
                        "username": "s3stan",
                        "content": "The O(m+n) algorithm doesn\\'t look too bad: `Beats 41.02%of users with JavaScript`"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@lucasscodes](/lucasscodes) \\nI absolutely agree with you. We have not gathered here to look for simple solutions. And develop your algorithmic skills. And if the problem requires solving O(log(m + n)), then it needs to be solved that way.\\nAnd my remark was with some degree of sarcasm. In the sense that a solution with a certain efficiency is required. And an ineffective solution works quite well."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "ignore a failed implementation for runtime checks, its just impossible for the general case!\n\n-Assume that a machine exists that can determine the time complexity of any arbitrary algorithm.\n-This would imply that the algorithm halts, because time complexity is only defined for algorithms that eventually halt.\n-Therefore, this machine could solve the Halting Problem by determining whether any arbitrary algorithm halts.\n-But we know from Turing’s proof that the Halting Problem is undecidable - there’s no machine that can solve it for all possible inputs.\n-This leads to a contradiction, so our original assumption (that a machine exists that can determine the time complexity of any arbitrary algorithm) must be false.\n\nfollow the constraint to learn and answere this question well in a interview."
                    }
                ]
            },
            {
                "id": 2066962,
                "content": [
                    {
                        "username": "ExPLICIT_27",
                        "content": "the interpreter doesn\\'t know math I suppose cause my code is giving me a proper answer in all other environments except here."
                    },
                    {
                        "username": "kyxap",
                        "content": "it\\'s medium like if u do not want to try to do it with O(log (m+n))"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its easy with no log. Just merging two sorted arrays"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I don\\'t think that someone can solve this problem in an interview with O(ln(n+m)) time complexity... "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "like one of the most liked comments stated, this is something most will need to remember first not come up with it new."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "I solved this in $O((n + m)log(n + m))$ time complexity, which implies merging the two arrays, sorting them, and finding the median in constant time. This should not be an accepted solution to the problem. The test cases should throw a TLE."
                    },
                    {
                        "username": "Zefick",
                        "content": "You can merge two sorted arrays in linear time (it\\'s literally the merge phase in the Merge sort). So the final complexity would be O(n + m).\\nProblems on this site often rely on your honesty. In addition, sometimes it\\'s just not possible to make adequate test cases to prevent cheating. You can cheat here, but it will not help you in a real interview."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Solving The Solved one is So much fun"
                    },
                    {
                        "username": "user1326Ds",
                        "content": "Python3 code;\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1=sorted(nums1)\\n        n= len(nums1)\\n        if n%2==0:\\n            mid1= nums1[n//2]\\n            mid2= nums1[n//2 - 1]\\n            mid=(mid1+mid2)/2\\n        else:\\n            mid= nums1[n//2]\\n        return mid"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    static int[] merge(int[] arr1 , int[] arr2){\\n        int[] ans = new int[arr1.length+arr2.length];\\n        int i=0,j=0;\\n        for(;i<arr1.length && j<arr2.length;){\\n            if(arr1[i]<=arr2[j]){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }else{\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        if(j==arr2.length){\\n            while(i!=arr1.length){\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }else{\\n            while(j!=arr2.length){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] arr = merge(nums1,nums2);\\n        if(arr.length%2==0){\\n            return (double)(arr[arr.length/2] + arr[(arr.length/2)-1])/2;\\n        }\\n        return arr[arr.length/2];\\n    }\\n}"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you got O((n+m)*log(m+n)) with the sort.\\nEven O(n+m) would be better, just start at both fronts and until you reached the result move over the smaller element.\\nAnd then have fun reaching (log(m+n)), really hard stuff"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Funny tip: using 2 pointers nums1Pointer and nums2Pointer and advancing them based on the smaller value (so O (n+m) / 2 complexity) still beats 100% with 1ms."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you ignored a constraint and will fail the interview youre preparing for. not fun."
                    },
                    {
                        "username": "chenon",
                        "content": "Medium question for O(n) solution not a Hard one.\\nIt made my day.\\n\\nThe key thing to note to calculate the median is the value in the middle of a sorted list, array\\n\\nTo calculate the median :\\n- if the array length is even, the median is the average the 2 values at the middle\\n- if the array length is odd, the median is value in the middle `nums[mid]`\\n\\nYou have 2 sorted arrays, it is a matter to find the elements in the middle. \\nOK my solution is only O(n).\\n\\nAt least, I didn\\'t memorize anything."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "the interview still is failed, because you ignored a constraint for O(log(n+m)).\nok maybe the other ones do far worse than that."
                    },
                    {
                        "username": "s3stan",
                        "content": "The O(m+n) algorithm doesn\\'t look too bad: `Beats 41.02%of users with JavaScript`"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@lucasscodes](/lucasscodes) \\nI absolutely agree with you. We have not gathered here to look for simple solutions. And develop your algorithmic skills. And if the problem requires solving O(log(m + n)), then it needs to be solved that way.\\nAnd my remark was with some degree of sarcasm. In the sense that a solution with a certain efficiency is required. And an ineffective solution works quite well."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "ignore a failed implementation for runtime checks, its just impossible for the general case!\n\n-Assume that a machine exists that can determine the time complexity of any arbitrary algorithm.\n-This would imply that the algorithm halts, because time complexity is only defined for algorithms that eventually halt.\n-Therefore, this machine could solve the Halting Problem by determining whether any arbitrary algorithm halts.\n-But we know from Turing’s proof that the Halting Problem is undecidable - there’s no machine that can solve it for all possible inputs.\n-This leads to a contradiction, so our original assumption (that a machine exists that can determine the time complexity of any arbitrary algorithm) must be false.\n\nfollow the constraint to learn and answere this question well in a interview."
                    }
                ]
            },
            {
                "id": 2066877,
                "content": [
                    {
                        "username": "iamkuldeep",
                        "content": "FOR EASY APPORACH:- https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "shabha2004",
                        "content": "python vazgha"
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "So can Someone tell  why this is happening?.......\nI was using Priority Queue  'pq' (min-heap), In which I offer 'pq.offer(element)' each element one by one from both arrays to pq.  So what should happen is element should get stored in ascending order. Bur for\n nums1 =[3]\nnums2 =[-2,-1]\nOn Adding nums1 and nums2 to priority queue ,it is not getting stored in ascending order i.e.,  It sould be -2,-1,3 but instead it is -2,3,-1.\nStdout:-\n-2\n3\n-1   \n"
                    },
                    {
                        "username": "psionl0",
                        "content": "-2, 3, -1 is in min-heap order. A priority queue guarantees only that the minimum number will be at the top of the heap. To access the next highest number in the heap, you need to pop the top number off.\\nIncidentally, this won\\'t produce a O(log(m+n)) solution."
                    },
                    {
                        "username": "aitachii",
                        "content": " `O(log(...))` solutions aside...\n\nCan you solve these testcases in `O(1)` time complexity?\n\n\n    [2,3]\n    [1,2]\n    []\n    [1,2,3,4,5]\n    [1,2,3]\n    [4,5,6]\n    [0,0]\n    [0,0]\n    [1,1,1,1,2,2,2,2,3,3,3,3]\n    [4,4,4,5,5,5]\n    [999,999,999,999,999,999,999,999,999,999,999,999,999,999,999]\n    [1,2,3,4,5,6,7,8,9,10]"
                    },
                    {
                        "username": "SG-C",
                        "content": "seems easy but not "
                    },
                    {
                        "username": "rajkumar_vanjaku",
                        "content": "First of all merge two lists and sort the new list\\nThere are two approaches in this problem :\\n1. One is to do it in the traditional way of finding median like: \\n    using formulas like n/2 for even no of terms and (n/2)+1 is the median for \\n    odd.\\n2. second is to do in indexing method as finding the indexing element and then \\n    finding its median "
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Merge both arrays efficiently using two pointers and return the mid value. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess you can\\'t be blamed for recommending this since the editorial suggests largely the same thing but this is not an O(log(m+n)) solution."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This question is the first Leetcode hard I dealt with (It\\'s #4, I first finished all the easys and dealt with medium and hard in numeric order). I was stunned back then how on Earth people thought of a log (m + n) solution. Now after ~ 1 year I appreciate the beauty of this question and the spirit of algorithm questions: figure out the conditions given (in this case, nums1 and nums2 are sorted), and think of the correct logic behind to solve the problem. This theme will appear over and over again in your tech career."
                    },
                    {
                        "username": "psionl0",
                        "content": "This YouTube video give the clearest explanation of the O(log(m+n)) solution that I know of.\\nhttps://www.youtube.com/watch?v=F9c7LpRZWVQ"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Explained [concisely with easy approach here](https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/4070924/98-33-easy-solution-with-explanation/)"
                    }
                ]
            },
            {
                "id": 2066824,
                "content": [
                    {
                        "username": "iamkuldeep",
                        "content": "FOR EASY APPORACH:- https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "shabha2004",
                        "content": "python vazgha"
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "So can Someone tell  why this is happening?.......\nI was using Priority Queue  'pq' (min-heap), In which I offer 'pq.offer(element)' each element one by one from both arrays to pq.  So what should happen is element should get stored in ascending order. Bur for\n nums1 =[3]\nnums2 =[-2,-1]\nOn Adding nums1 and nums2 to priority queue ,it is not getting stored in ascending order i.e.,  It sould be -2,-1,3 but instead it is -2,3,-1.\nStdout:-\n-2\n3\n-1   \n"
                    },
                    {
                        "username": "psionl0",
                        "content": "-2, 3, -1 is in min-heap order. A priority queue guarantees only that the minimum number will be at the top of the heap. To access the next highest number in the heap, you need to pop the top number off.\\nIncidentally, this won\\'t produce a O(log(m+n)) solution."
                    },
                    {
                        "username": "aitachii",
                        "content": " `O(log(...))` solutions aside...\n\nCan you solve these testcases in `O(1)` time complexity?\n\n\n    [2,3]\n    [1,2]\n    []\n    [1,2,3,4,5]\n    [1,2,3]\n    [4,5,6]\n    [0,0]\n    [0,0]\n    [1,1,1,1,2,2,2,2,3,3,3,3]\n    [4,4,4,5,5,5]\n    [999,999,999,999,999,999,999,999,999,999,999,999,999,999,999]\n    [1,2,3,4,5,6,7,8,9,10]"
                    },
                    {
                        "username": "SG-C",
                        "content": "seems easy but not "
                    },
                    {
                        "username": "rajkumar_vanjaku",
                        "content": "First of all merge two lists and sort the new list\\nThere are two approaches in this problem :\\n1. One is to do it in the traditional way of finding median like: \\n    using formulas like n/2 for even no of terms and (n/2)+1 is the median for \\n    odd.\\n2. second is to do in indexing method as finding the indexing element and then \\n    finding its median "
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Merge both arrays efficiently using two pointers and return the mid value. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess you can\\'t be blamed for recommending this since the editorial suggests largely the same thing but this is not an O(log(m+n)) solution."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This question is the first Leetcode hard I dealt with (It\\'s #4, I first finished all the easys and dealt with medium and hard in numeric order). I was stunned back then how on Earth people thought of a log (m + n) solution. Now after ~ 1 year I appreciate the beauty of this question and the spirit of algorithm questions: figure out the conditions given (in this case, nums1 and nums2 are sorted), and think of the correct logic behind to solve the problem. This theme will appear over and over again in your tech career."
                    },
                    {
                        "username": "psionl0",
                        "content": "This YouTube video give the clearest explanation of the O(log(m+n)) solution that I know of.\\nhttps://www.youtube.com/watch?v=F9c7LpRZWVQ"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Explained [concisely with easy approach here](https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/4070924/98-33-easy-solution-with-explanation/)"
                    }
                ]
            },
            {
                "id": 2066814,
                "content": [
                    {
                        "username": "iamkuldeep",
                        "content": "FOR EASY APPORACH:- https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "shabha2004",
                        "content": "python vazgha"
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "So can Someone tell  why this is happening?.......\nI was using Priority Queue  'pq' (min-heap), In which I offer 'pq.offer(element)' each element one by one from both arrays to pq.  So what should happen is element should get stored in ascending order. Bur for\n nums1 =[3]\nnums2 =[-2,-1]\nOn Adding nums1 and nums2 to priority queue ,it is not getting stored in ascending order i.e.,  It sould be -2,-1,3 but instead it is -2,3,-1.\nStdout:-\n-2\n3\n-1   \n"
                    },
                    {
                        "username": "psionl0",
                        "content": "-2, 3, -1 is in min-heap order. A priority queue guarantees only that the minimum number will be at the top of the heap. To access the next highest number in the heap, you need to pop the top number off.\\nIncidentally, this won\\'t produce a O(log(m+n)) solution."
                    },
                    {
                        "username": "aitachii",
                        "content": " `O(log(...))` solutions aside...\n\nCan you solve these testcases in `O(1)` time complexity?\n\n\n    [2,3]\n    [1,2]\n    []\n    [1,2,3,4,5]\n    [1,2,3]\n    [4,5,6]\n    [0,0]\n    [0,0]\n    [1,1,1,1,2,2,2,2,3,3,3,3]\n    [4,4,4,5,5,5]\n    [999,999,999,999,999,999,999,999,999,999,999,999,999,999,999]\n    [1,2,3,4,5,6,7,8,9,10]"
                    },
                    {
                        "username": "SG-C",
                        "content": "seems easy but not "
                    },
                    {
                        "username": "rajkumar_vanjaku",
                        "content": "First of all merge two lists and sort the new list\\nThere are two approaches in this problem :\\n1. One is to do it in the traditional way of finding median like: \\n    using formulas like n/2 for even no of terms and (n/2)+1 is the median for \\n    odd.\\n2. second is to do in indexing method as finding the indexing element and then \\n    finding its median "
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Merge both arrays efficiently using two pointers and return the mid value. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess you can\\'t be blamed for recommending this since the editorial suggests largely the same thing but this is not an O(log(m+n)) solution."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This question is the first Leetcode hard I dealt with (It\\'s #4, I first finished all the easys and dealt with medium and hard in numeric order). I was stunned back then how on Earth people thought of a log (m + n) solution. Now after ~ 1 year I appreciate the beauty of this question and the spirit of algorithm questions: figure out the conditions given (in this case, nums1 and nums2 are sorted), and think of the correct logic behind to solve the problem. This theme will appear over and over again in your tech career."
                    },
                    {
                        "username": "psionl0",
                        "content": "This YouTube video give the clearest explanation of the O(log(m+n)) solution that I know of.\\nhttps://www.youtube.com/watch?v=F9c7LpRZWVQ"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Explained [concisely with easy approach here](https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/4070924/98-33-easy-solution-with-explanation/)"
                    }
                ]
            },
            {
                "id": 2066806,
                "content": [
                    {
                        "username": "iamkuldeep",
                        "content": "FOR EASY APPORACH:- https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "shabha2004",
                        "content": "python vazgha"
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "So can Someone tell  why this is happening?.......\nI was using Priority Queue  'pq' (min-heap), In which I offer 'pq.offer(element)' each element one by one from both arrays to pq.  So what should happen is element should get stored in ascending order. Bur for\n nums1 =[3]\nnums2 =[-2,-1]\nOn Adding nums1 and nums2 to priority queue ,it is not getting stored in ascending order i.e.,  It sould be -2,-1,3 but instead it is -2,3,-1.\nStdout:-\n-2\n3\n-1   \n"
                    },
                    {
                        "username": "psionl0",
                        "content": "-2, 3, -1 is in min-heap order. A priority queue guarantees only that the minimum number will be at the top of the heap. To access the next highest number in the heap, you need to pop the top number off.\\nIncidentally, this won\\'t produce a O(log(m+n)) solution."
                    },
                    {
                        "username": "aitachii",
                        "content": " `O(log(...))` solutions aside...\n\nCan you solve these testcases in `O(1)` time complexity?\n\n\n    [2,3]\n    [1,2]\n    []\n    [1,2,3,4,5]\n    [1,2,3]\n    [4,5,6]\n    [0,0]\n    [0,0]\n    [1,1,1,1,2,2,2,2,3,3,3,3]\n    [4,4,4,5,5,5]\n    [999,999,999,999,999,999,999,999,999,999,999,999,999,999,999]\n    [1,2,3,4,5,6,7,8,9,10]"
                    },
                    {
                        "username": "SG-C",
                        "content": "seems easy but not "
                    },
                    {
                        "username": "rajkumar_vanjaku",
                        "content": "First of all merge two lists and sort the new list\\nThere are two approaches in this problem :\\n1. One is to do it in the traditional way of finding median like: \\n    using formulas like n/2 for even no of terms and (n/2)+1 is the median for \\n    odd.\\n2. second is to do in indexing method as finding the indexing element and then \\n    finding its median "
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Merge both arrays efficiently using two pointers and return the mid value. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess you can\\'t be blamed for recommending this since the editorial suggests largely the same thing but this is not an O(log(m+n)) solution."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This question is the first Leetcode hard I dealt with (It\\'s #4, I first finished all the easys and dealt with medium and hard in numeric order). I was stunned back then how on Earth people thought of a log (m + n) solution. Now after ~ 1 year I appreciate the beauty of this question and the spirit of algorithm questions: figure out the conditions given (in this case, nums1 and nums2 are sorted), and think of the correct logic behind to solve the problem. This theme will appear over and over again in your tech career."
                    },
                    {
                        "username": "psionl0",
                        "content": "This YouTube video give the clearest explanation of the O(log(m+n)) solution that I know of.\\nhttps://www.youtube.com/watch?v=F9c7LpRZWVQ"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Explained [concisely with easy approach here](https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/4070924/98-33-easy-solution-with-explanation/)"
                    }
                ]
            },
            {
                "id": 2066804,
                "content": [
                    {
                        "username": "iamkuldeep",
                        "content": "FOR EASY APPORACH:- https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "shabha2004",
                        "content": "python vazgha"
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "So can Someone tell  why this is happening?.......\nI was using Priority Queue  'pq' (min-heap), In which I offer 'pq.offer(element)' each element one by one from both arrays to pq.  So what should happen is element should get stored in ascending order. Bur for\n nums1 =[3]\nnums2 =[-2,-1]\nOn Adding nums1 and nums2 to priority queue ,it is not getting stored in ascending order i.e.,  It sould be -2,-1,3 but instead it is -2,3,-1.\nStdout:-\n-2\n3\n-1   \n"
                    },
                    {
                        "username": "psionl0",
                        "content": "-2, 3, -1 is in min-heap order. A priority queue guarantees only that the minimum number will be at the top of the heap. To access the next highest number in the heap, you need to pop the top number off.\\nIncidentally, this won\\'t produce a O(log(m+n)) solution."
                    },
                    {
                        "username": "aitachii",
                        "content": " `O(log(...))` solutions aside...\n\nCan you solve these testcases in `O(1)` time complexity?\n\n\n    [2,3]\n    [1,2]\n    []\n    [1,2,3,4,5]\n    [1,2,3]\n    [4,5,6]\n    [0,0]\n    [0,0]\n    [1,1,1,1,2,2,2,2,3,3,3,3]\n    [4,4,4,5,5,5]\n    [999,999,999,999,999,999,999,999,999,999,999,999,999,999,999]\n    [1,2,3,4,5,6,7,8,9,10]"
                    },
                    {
                        "username": "SG-C",
                        "content": "seems easy but not "
                    },
                    {
                        "username": "rajkumar_vanjaku",
                        "content": "First of all merge two lists and sort the new list\\nThere are two approaches in this problem :\\n1. One is to do it in the traditional way of finding median like: \\n    using formulas like n/2 for even no of terms and (n/2)+1 is the median for \\n    odd.\\n2. second is to do in indexing method as finding the indexing element and then \\n    finding its median "
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Merge both arrays efficiently using two pointers and return the mid value. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess you can\\'t be blamed for recommending this since the editorial suggests largely the same thing but this is not an O(log(m+n)) solution."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This question is the first Leetcode hard I dealt with (It\\'s #4, I first finished all the easys and dealt with medium and hard in numeric order). I was stunned back then how on Earth people thought of a log (m + n) solution. Now after ~ 1 year I appreciate the beauty of this question and the spirit of algorithm questions: figure out the conditions given (in this case, nums1 and nums2 are sorted), and think of the correct logic behind to solve the problem. This theme will appear over and over again in your tech career."
                    },
                    {
                        "username": "psionl0",
                        "content": "This YouTube video give the clearest explanation of the O(log(m+n)) solution that I know of.\\nhttps://www.youtube.com/watch?v=F9c7LpRZWVQ"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Explained [concisely with easy approach here](https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/4070924/98-33-easy-solution-with-explanation/)"
                    }
                ]
            },
            {
                "id": 2066771,
                "content": [
                    {
                        "username": "iamkuldeep",
                        "content": "FOR EASY APPORACH:- https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "shabha2004",
                        "content": "python vazgha"
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "So can Someone tell  why this is happening?.......\nI was using Priority Queue  'pq' (min-heap), In which I offer 'pq.offer(element)' each element one by one from both arrays to pq.  So what should happen is element should get stored in ascending order. Bur for\n nums1 =[3]\nnums2 =[-2,-1]\nOn Adding nums1 and nums2 to priority queue ,it is not getting stored in ascending order i.e.,  It sould be -2,-1,3 but instead it is -2,3,-1.\nStdout:-\n-2\n3\n-1   \n"
                    },
                    {
                        "username": "psionl0",
                        "content": "-2, 3, -1 is in min-heap order. A priority queue guarantees only that the minimum number will be at the top of the heap. To access the next highest number in the heap, you need to pop the top number off.\\nIncidentally, this won\\'t produce a O(log(m+n)) solution."
                    },
                    {
                        "username": "aitachii",
                        "content": " `O(log(...))` solutions aside...\n\nCan you solve these testcases in `O(1)` time complexity?\n\n\n    [2,3]\n    [1,2]\n    []\n    [1,2,3,4,5]\n    [1,2,3]\n    [4,5,6]\n    [0,0]\n    [0,0]\n    [1,1,1,1,2,2,2,2,3,3,3,3]\n    [4,4,4,5,5,5]\n    [999,999,999,999,999,999,999,999,999,999,999,999,999,999,999]\n    [1,2,3,4,5,6,7,8,9,10]"
                    },
                    {
                        "username": "SG-C",
                        "content": "seems easy but not "
                    },
                    {
                        "username": "rajkumar_vanjaku",
                        "content": "First of all merge two lists and sort the new list\\nThere are two approaches in this problem :\\n1. One is to do it in the traditional way of finding median like: \\n    using formulas like n/2 for even no of terms and (n/2)+1 is the median for \\n    odd.\\n2. second is to do in indexing method as finding the indexing element and then \\n    finding its median "
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Merge both arrays efficiently using two pointers and return the mid value. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess you can\\'t be blamed for recommending this since the editorial suggests largely the same thing but this is not an O(log(m+n)) solution."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This question is the first Leetcode hard I dealt with (It\\'s #4, I first finished all the easys and dealt with medium and hard in numeric order). I was stunned back then how on Earth people thought of a log (m + n) solution. Now after ~ 1 year I appreciate the beauty of this question and the spirit of algorithm questions: figure out the conditions given (in this case, nums1 and nums2 are sorted), and think of the correct logic behind to solve the problem. This theme will appear over and over again in your tech career."
                    },
                    {
                        "username": "psionl0",
                        "content": "This YouTube video give the clearest explanation of the O(log(m+n)) solution that I know of.\\nhttps://www.youtube.com/watch?v=F9c7LpRZWVQ"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Explained [concisely with easy approach here](https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/4070924/98-33-easy-solution-with-explanation/)"
                    }
                ]
            },
            {
                "id": 2066712,
                "content": [
                    {
                        "username": "iamkuldeep",
                        "content": "FOR EASY APPORACH:- https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "shabha2004",
                        "content": "python vazgha"
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "So can Someone tell  why this is happening?.......\nI was using Priority Queue  'pq' (min-heap), In which I offer 'pq.offer(element)' each element one by one from both arrays to pq.  So what should happen is element should get stored in ascending order. Bur for\n nums1 =[3]\nnums2 =[-2,-1]\nOn Adding nums1 and nums2 to priority queue ,it is not getting stored in ascending order i.e.,  It sould be -2,-1,3 but instead it is -2,3,-1.\nStdout:-\n-2\n3\n-1   \n"
                    },
                    {
                        "username": "psionl0",
                        "content": "-2, 3, -1 is in min-heap order. A priority queue guarantees only that the minimum number will be at the top of the heap. To access the next highest number in the heap, you need to pop the top number off.\\nIncidentally, this won\\'t produce a O(log(m+n)) solution."
                    },
                    {
                        "username": "aitachii",
                        "content": " `O(log(...))` solutions aside...\n\nCan you solve these testcases in `O(1)` time complexity?\n\n\n    [2,3]\n    [1,2]\n    []\n    [1,2,3,4,5]\n    [1,2,3]\n    [4,5,6]\n    [0,0]\n    [0,0]\n    [1,1,1,1,2,2,2,2,3,3,3,3]\n    [4,4,4,5,5,5]\n    [999,999,999,999,999,999,999,999,999,999,999,999,999,999,999]\n    [1,2,3,4,5,6,7,8,9,10]"
                    },
                    {
                        "username": "SG-C",
                        "content": "seems easy but not "
                    },
                    {
                        "username": "rajkumar_vanjaku",
                        "content": "First of all merge two lists and sort the new list\\nThere are two approaches in this problem :\\n1. One is to do it in the traditional way of finding median like: \\n    using formulas like n/2 for even no of terms and (n/2)+1 is the median for \\n    odd.\\n2. second is to do in indexing method as finding the indexing element and then \\n    finding its median "
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Merge both arrays efficiently using two pointers and return the mid value. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess you can\\'t be blamed for recommending this since the editorial suggests largely the same thing but this is not an O(log(m+n)) solution."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This question is the first Leetcode hard I dealt with (It\\'s #4, I first finished all the easys and dealt with medium and hard in numeric order). I was stunned back then how on Earth people thought of a log (m + n) solution. Now after ~ 1 year I appreciate the beauty of this question and the spirit of algorithm questions: figure out the conditions given (in this case, nums1 and nums2 are sorted), and think of the correct logic behind to solve the problem. This theme will appear over and over again in your tech career."
                    },
                    {
                        "username": "psionl0",
                        "content": "This YouTube video give the clearest explanation of the O(log(m+n)) solution that I know of.\\nhttps://www.youtube.com/watch?v=F9c7LpRZWVQ"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Explained [concisely with easy approach here](https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/4070924/98-33-easy-solution-with-explanation/)"
                    }
                ]
            },
            {
                "id": 2066678,
                "content": [
                    {
                        "username": "iamkuldeep",
                        "content": "FOR EASY APPORACH:- https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "shabha2004",
                        "content": "python vazgha"
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "So can Someone tell  why this is happening?.......\nI was using Priority Queue  'pq' (min-heap), In which I offer 'pq.offer(element)' each element one by one from both arrays to pq.  So what should happen is element should get stored in ascending order. Bur for\n nums1 =[3]\nnums2 =[-2,-1]\nOn Adding nums1 and nums2 to priority queue ,it is not getting stored in ascending order i.e.,  It sould be -2,-1,3 but instead it is -2,3,-1.\nStdout:-\n-2\n3\n-1   \n"
                    },
                    {
                        "username": "psionl0",
                        "content": "-2, 3, -1 is in min-heap order. A priority queue guarantees only that the minimum number will be at the top of the heap. To access the next highest number in the heap, you need to pop the top number off.\\nIncidentally, this won\\'t produce a O(log(m+n)) solution."
                    },
                    {
                        "username": "aitachii",
                        "content": " `O(log(...))` solutions aside...\n\nCan you solve these testcases in `O(1)` time complexity?\n\n\n    [2,3]\n    [1,2]\n    []\n    [1,2,3,4,5]\n    [1,2,3]\n    [4,5,6]\n    [0,0]\n    [0,0]\n    [1,1,1,1,2,2,2,2,3,3,3,3]\n    [4,4,4,5,5,5]\n    [999,999,999,999,999,999,999,999,999,999,999,999,999,999,999]\n    [1,2,3,4,5,6,7,8,9,10]"
                    },
                    {
                        "username": "SG-C",
                        "content": "seems easy but not "
                    },
                    {
                        "username": "rajkumar_vanjaku",
                        "content": "First of all merge two lists and sort the new list\\nThere are two approaches in this problem :\\n1. One is to do it in the traditional way of finding median like: \\n    using formulas like n/2 for even no of terms and (n/2)+1 is the median for \\n    odd.\\n2. second is to do in indexing method as finding the indexing element and then \\n    finding its median "
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Merge both arrays efficiently using two pointers and return the mid value. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess you can\\'t be blamed for recommending this since the editorial suggests largely the same thing but this is not an O(log(m+n)) solution."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This question is the first Leetcode hard I dealt with (It\\'s #4, I first finished all the easys and dealt with medium and hard in numeric order). I was stunned back then how on Earth people thought of a log (m + n) solution. Now after ~ 1 year I appreciate the beauty of this question and the spirit of algorithm questions: figure out the conditions given (in this case, nums1 and nums2 are sorted), and think of the correct logic behind to solve the problem. This theme will appear over and over again in your tech career."
                    },
                    {
                        "username": "psionl0",
                        "content": "This YouTube video give the clearest explanation of the O(log(m+n)) solution that I know of.\\nhttps://www.youtube.com/watch?v=F9c7LpRZWVQ"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Explained [concisely with easy approach here](https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/4070924/98-33-easy-solution-with-explanation/)"
                    }
                ]
            },
            {
                "id": 2066646,
                "content": [
                    {
                        "username": "iamkuldeep",
                        "content": "FOR EASY APPORACH:- https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "shabha2004",
                        "content": "python vazgha"
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "So can Someone tell  why this is happening?.......\nI was using Priority Queue  'pq' (min-heap), In which I offer 'pq.offer(element)' each element one by one from both arrays to pq.  So what should happen is element should get stored in ascending order. Bur for\n nums1 =[3]\nnums2 =[-2,-1]\nOn Adding nums1 and nums2 to priority queue ,it is not getting stored in ascending order i.e.,  It sould be -2,-1,3 but instead it is -2,3,-1.\nStdout:-\n-2\n3\n-1   \n"
                    },
                    {
                        "username": "psionl0",
                        "content": "-2, 3, -1 is in min-heap order. A priority queue guarantees only that the minimum number will be at the top of the heap. To access the next highest number in the heap, you need to pop the top number off.\\nIncidentally, this won\\'t produce a O(log(m+n)) solution."
                    },
                    {
                        "username": "aitachii",
                        "content": " `O(log(...))` solutions aside...\n\nCan you solve these testcases in `O(1)` time complexity?\n\n\n    [2,3]\n    [1,2]\n    []\n    [1,2,3,4,5]\n    [1,2,3]\n    [4,5,6]\n    [0,0]\n    [0,0]\n    [1,1,1,1,2,2,2,2,3,3,3,3]\n    [4,4,4,5,5,5]\n    [999,999,999,999,999,999,999,999,999,999,999,999,999,999,999]\n    [1,2,3,4,5,6,7,8,9,10]"
                    },
                    {
                        "username": "SG-C",
                        "content": "seems easy but not "
                    },
                    {
                        "username": "rajkumar_vanjaku",
                        "content": "First of all merge two lists and sort the new list\\nThere are two approaches in this problem :\\n1. One is to do it in the traditional way of finding median like: \\n    using formulas like n/2 for even no of terms and (n/2)+1 is the median for \\n    odd.\\n2. second is to do in indexing method as finding the indexing element and then \\n    finding its median "
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Merge both arrays efficiently using two pointers and return the mid value. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess you can\\'t be blamed for recommending this since the editorial suggests largely the same thing but this is not an O(log(m+n)) solution."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This question is the first Leetcode hard I dealt with (It\\'s #4, I first finished all the easys and dealt with medium and hard in numeric order). I was stunned back then how on Earth people thought of a log (m + n) solution. Now after ~ 1 year I appreciate the beauty of this question and the spirit of algorithm questions: figure out the conditions given (in this case, nums1 and nums2 are sorted), and think of the correct logic behind to solve the problem. This theme will appear over and over again in your tech career."
                    },
                    {
                        "username": "psionl0",
                        "content": "This YouTube video give the clearest explanation of the O(log(m+n)) solution that I know of.\\nhttps://www.youtube.com/watch?v=F9c7LpRZWVQ"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Explained [concisely with easy approach here](https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/4070924/98-33-easy-solution-with-explanation/)"
                    }
                ]
            },
            {
                "id": 2066611,
                "content": [
                    {
                        "username": "iamkuldeep",
                        "content": "FOR EASY APPORACH:- https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "shabha2004",
                        "content": "python vazgha"
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "So can Someone tell  why this is happening?.......\nI was using Priority Queue  'pq' (min-heap), In which I offer 'pq.offer(element)' each element one by one from both arrays to pq.  So what should happen is element should get stored in ascending order. Bur for\n nums1 =[3]\nnums2 =[-2,-1]\nOn Adding nums1 and nums2 to priority queue ,it is not getting stored in ascending order i.e.,  It sould be -2,-1,3 but instead it is -2,3,-1.\nStdout:-\n-2\n3\n-1   \n"
                    },
                    {
                        "username": "psionl0",
                        "content": "-2, 3, -1 is in min-heap order. A priority queue guarantees only that the minimum number will be at the top of the heap. To access the next highest number in the heap, you need to pop the top number off.\\nIncidentally, this won\\'t produce a O(log(m+n)) solution."
                    },
                    {
                        "username": "aitachii",
                        "content": " `O(log(...))` solutions aside...\n\nCan you solve these testcases in `O(1)` time complexity?\n\n\n    [2,3]\n    [1,2]\n    []\n    [1,2,3,4,5]\n    [1,2,3]\n    [4,5,6]\n    [0,0]\n    [0,0]\n    [1,1,1,1,2,2,2,2,3,3,3,3]\n    [4,4,4,5,5,5]\n    [999,999,999,999,999,999,999,999,999,999,999,999,999,999,999]\n    [1,2,3,4,5,6,7,8,9,10]"
                    },
                    {
                        "username": "SG-C",
                        "content": "seems easy but not "
                    },
                    {
                        "username": "rajkumar_vanjaku",
                        "content": "First of all merge two lists and sort the new list\\nThere are two approaches in this problem :\\n1. One is to do it in the traditional way of finding median like: \\n    using formulas like n/2 for even no of terms and (n/2)+1 is the median for \\n    odd.\\n2. second is to do in indexing method as finding the indexing element and then \\n    finding its median "
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Merge both arrays efficiently using two pointers and return the mid value. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess you can\\'t be blamed for recommending this since the editorial suggests largely the same thing but this is not an O(log(m+n)) solution."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This question is the first Leetcode hard I dealt with (It\\'s #4, I first finished all the easys and dealt with medium and hard in numeric order). I was stunned back then how on Earth people thought of a log (m + n) solution. Now after ~ 1 year I appreciate the beauty of this question and the spirit of algorithm questions: figure out the conditions given (in this case, nums1 and nums2 are sorted), and think of the correct logic behind to solve the problem. This theme will appear over and over again in your tech career."
                    },
                    {
                        "username": "psionl0",
                        "content": "This YouTube video give the clearest explanation of the O(log(m+n)) solution that I know of.\\nhttps://www.youtube.com/watch?v=F9c7LpRZWVQ"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Explained [concisely with easy approach here](https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/4070924/98-33-easy-solution-with-explanation/)"
                    }
                ]
            },
            {
                "id": 2066568,
                "content": [
                    {
                        "username": "justinleung0204",
                        "content": "try \\n[-994655, -993994, -991967, -991325, -990398, -988095, -985751, -979217, -978192, -978011, -977429, -976673, -975247, -974516, -972815, -972128, -969579, -968714, -966498, -965804, -965649, -965398, -964406, -959276, -957464, -957387, -955598, -955414, -954591, -954093, -954030, -954026, -953568, -951586, -949720, -948620, -948067, -947702, -944747, -939522, -939390, -938770, -936821, -935171, -934261, -932485, -930539, -927942, -927441, -927304, -925848, -924409, -922636, -921691, -921180, -920983, -920322, -916773, -916293, -914806, -914595, -913674, -911815, -911371, -910861, -909825, -909148, -907716, -907408, -906773, -905247, -904944, -904001, -902721, -898131, -894932, -894560, -894204, -890932, -890586, -890069, -888310, -885313, -882692, -881456, -880824, -878763, -878112, -876247, -875654, -870390, -867532, -867324, -867058, -866471, -865559, -861404, -861074, -858880, -858287, -857419, -852828, -851970, -850887, -850781, -847064, -845959, -844400, -843865, -842229, -841504, -838420, -837661, -832341, -830491, -825293, -825170, -824615, -820676, -820657, -812263, -811178, -809320, -807655, -806194, -804182, -800065, -798525, -797897, -797674, -796210, -794011, -793851, -792819, -792074, -790951, -785779, -783652, -780803, -780429, -777118, -775053, -772694, -771726, -770114, -769735, -769420, -767702, -767674, -767478, -767208, -766647, -766326, -766171, -762990, -762262, -760950, -759882, -758089, -754901, -753444, -752476, -749957, -749006, -748946, -744097, -744040, -743806, -742040, -739358, -738506, -737332, -736316, -733828, -732416, -732205, -730920, -729686, -729326, -729138, -728690, -728587, -725291, -721993, -721992, -720924, -719181, -718985, -717776, -714652, -708778, -706347, -703008, -701329, -698849, -697626, -697226, -697030, -694863, -687971, -687615, -687424, -685428, -684993, -682056, -667871, -666917, -666776, -665524, -658872, -658109, -656999, -655860, -654585, -654567, -651017, -649888, -647590, -646763, -645638, -638225, -637214, -636529, -633272, -633041, -628082, -628074, -625948, -625778, -622448, -622326, -621929, -620161, -617798, -616576, -611212, -610377, -609261, -608425, -606242, -603468, -603394, -601744, -595969, -594421, -594310, -592685, -590529, -589111, -584672, -583224, -582511, -580883, -580187, -578709, -577674, -571825, -568085, -566554, -561892, -560889, -560243, -558453, -558272, -557250, -556808, -555477, -553500, -549913, -549122, -546769, -544973, -544931, -543612, -542175, -538884, -536964, -533928, -531674, -530917, -530560, -528123, -527672, -525811, -524895, -521574, -516255, -513441, -512365, -511052, -510908, -510079, -504485, -502724, -502713, -500985, -496529, -493674, -493237, -492219, -489936, -487103, -484436, -482849, -482574, -482438, -482307, -481959, -481755, -481499, -481119, -477835, -471451, -465684, -464144, -461270, -458708, -458164, -457157, -454667, -454446, -453810, -452722, -450750, -444975, -440175, -436952, -433585, -431811, -431720, -425111, -423881, -421194, -417870, -413472, -409253, -406580, -404742, -398875, -396025, -395996, -392462, -390019, -389063, -388162, -387957, -384367, -384027, -383828, -382868, -382548, -381340, -381173, -376972, -373184, -370443, -369784, -369455, -367706, -362942, -361908, -360373, -356580, -344963, -344933, -344512, -344413, -340781, -335776, -335511, -332496, -332446, -332409, -332143, -326673, -326193, -324660, -322211, -321050, -318489, -317015, -316691, -312615, -309925, -305811, -303248, -302524, -301475, -299453, -298686, -291993, -287894, -284511, -278832, -274460, -269894, -265159, -264165, -263392, -261037, -258641, -255496, -255178, -254565, -252402, -250505, -246222, -244617, -239476, -237763, -235060, -233619, -231114, -228848, -228656, -228578, -228226, -226331, -223722, -221392, -220245, -214583, -208621, -208343, -205857, -204617, -204304, -204285, -200047, -198543, -196234, -195210, -192665, -191287, -190204, -187869, -180022, -175780, -169961, -165183, -163516, -162511, -159937, -159803, -157580, -155940, -154326, -153617, -151366, -150658, -149895, -143392, -142415, -141753, -140801, -140080, -138421, -137027, -136051, -135650, -132303, -131807, -130982, -130351, -126965, -124889, -120330, -115763, -115533, -115175, -114069, -113806, -105748, -104513, -103830, -103764, -103087, -102295, -98578, -97385, -93806, -92518, -90790, -89187, -88063, -86842, -86501, -85210, -82344, -80068, -76951, -72564, -71907, -68477, -67744, -65798, -65780, -62141, -61154, -58960, -58115, -55704, -48527, -47225, -44349, -44029, -35038, -34583, -34362, -33071, -30648, -27662, -24982, -24466, -24397, -22420, -22009, -20987, -18291, -15623, -14045, -12181, -8728, -6981, -5731, -2950, 1367, 1818, 2401, 2938, 4264, 4584, 11242, 12709, 14171, 18698, 19038, 19599, 25362, 27010, 27929, 28395, 32259, 32665, 33468, 39762, 40127, 41189, 48605, 50424, 50906, 53805, 54014, 54624, 55043, 55794, 56943, 57003, 58277, 58831, 59986, 62496, 63300, 63605, 63676, 66787, 72481, 74582, 81305, 85419, 86260, 88773, 89468, 89893, 91087, 93138, 98928, 99485, 101867, 103182, 103643, 108080, 110424, 112405, 115488, 118543, 119684, 120157, 121520, 123015, 123924, 124286, 125825, 127501, 128321, 128666, 129072, 129364, 130767, 135733, 136137, 136842, 137411, 140242, 141253, 143452, 145059, 145544, 146265, 146279, 150295, 150670, 156025, 156460, 157376, 158128, 161217, 161807, 163218, 164005, 164019, 165078, 167877, 173294, 174293, 175499, 180190, 192118, 202050, 203337, 203624, 203848, 204865, 205804, 206171, 208552, 209042, 213388, 219026, 219326, 220237, 220523, 220764, 221011, 222353, 223547, 224087, 225137, 226694, 226946, 229949, 234630, 235166, 237063, 240044, 241984, 245391, 251124, 255354, 255617, 264578, 268464, 268874, 273129, 276470, 276947, 281221, 281464, 282559, 282670, 283776, 287452, 296062, 296337, 297368, 299522, 300248, 300477, 301826, 302041, 303045, 307342, 310186, 310775, 315405, 315655, 316020, 317199, 320681, 322423, 324207, 325763, 325947, 327388, 328055, 330375, 331369, 336117, 337601, 337922, 338413, 339689, 344223, 345602, 347266, 349666, 354635, 357004, 359434, 364032, 365612, 366258, 368356, 371959, 374211, 376232, 381889, 383873, 384773, 387686, 387740, 388208, 389155, 393759, 394337, 394868, 395326, 395421, 397150, 404334, 404733, 407893, 408870, 413736, 415400, 423697, 424224, 424265, 425890, 427506, 427704, 431231, 431344, 432838, 432923, 436850, 438152, 438400, 445828, 447957, 448944, 452475, 454037, 454042, 461568, 465456, 467202, 467621, 468330, 470674, 476464, 477326, 477762, 480008, 485465, 486033, 491446, 498300, 501100, 501423, 504302, 505800, 506539, 506676, 508254, 508725, 510582, 515056, 517777, 520579, 521061, 524719, 529371, 534703, 539864, 541871, 544689, 544989, 548490, 551646, 552914, 552916, 554936, 555192, 557279, 557586, 557842, 558356, 558545, 559741, 561964, 565092, 566614, 568317, 571816, 572954, 577836, 578284, 578288, 582481, 585000, 587923, 594589, 595497, 596243, 596553, 600481, 601999, 605611, 605625, 605898, 606984, 610671, 611329, 614007, 615026, 616123, 616465, 616695, 619115, 620944, 621183, 621238, 622624, 623709, 626170, 631512, 633734, 633897, 642285, 643515, 644487, 645569, 648469, 649319, 651622, 652349, 652471, 652656, 653350, 654672, 657564, 658798, 659881, 660364, 668169, 673024, 674223, 674379, 676960, 678797, 684346, 684844, 685550, 685896, 687722, 689208, 691097, 696537, 701992, 707493, 710182, 714908, 717494, 724297, 727641, 728373, 729877, 731508, 734590, 735305, 735317, 739140, 746284, 752465, 753806, 758884, 760396, 762874, 764092, 765117, 765790, 766725, 768602, 776053, 778383, 779166, 780941, 781907, 785696, 790021, 792947, 794668, 796450, 800590, 804655, 805756, 808165, 813998, 814743, 815376, 815601, 816512, 816963, 817371, 821429, 828465, 830397, 830745, 832817, 834284, 835718, 838315, 838606, 839502, 840290, 840523, 845697, 847854, 848272, 849574, 853478, 860115, 863716, 865873, 866963, 867234, 867719, 868116, 868662, 870298, 874510, 874747, 875141, 875616, 875673, 876231, 876818, 877363, 877878, 884584, 889654, 892550, 892839, 894332, 894848, 895292, 903528, 909968, 918085, 918731, 923542, 925517, 925993, 927445, 930221, 932594, 934728, 934944, 944427, 944811, 950539, 951356, 951819, 952739, 954583, 957900, 957933, 958923, 964744, 965862, 965989, 966665, 971239, 972730, 974831, 975587, 975977, 977660, 978787, 983506, 988173, 989550, 990686, 991667, 992009, 994375, 995734, 997675, 999532]\\n[-999976, -998102, -996399, -990171, -987077, -985460, -977325, -973944, -973755, -970843, -970712, -969253, -968809, -967953, -964787, -964159, -963370, -962146, -961939, -961865, -961002, -959225, -955032, -951432, -950628, -950501, -949979, -949052, -948579, -948255, -948180, -947382, -946831, -943856, -943265, -941884, -939367, -934655, -933594, -933267, -933150, -931941, -931355, -929961, -928950, -926385, -925900, -922392, -921349, -917159, -915852, -913868, -913177, -912126, -911650, -906208, -904331, -900631, -900396, -900260, -898073, -894053, -892157, -888801, -885113, -884606, -876379, -876182, -874294, -873461, -873375, -866686, -864153, -861753, -859036, -858613, -855308, -853122, -849717, -849038, -847682, -847591, -847548, -847493, -843804, -842136, -841126, -840560, -838206, -837475, -832635, -831851, -829506, -821825, -821604, -821416, -819921, -818596, -814728, -812401, -802668, -802341, -801782, -798938, -797448, -795949, -795454, -788062, -785374, -779662, -776140, -773108, -772295, -771332, -768511, -768076, -757824, -754387, -753336, -752899, -752558, -748895, -748119, -745007, -744380, -740142, -740131, -736554, -725489, -724056, -719290, -719000, -715614, -715389, -712866, -710062, -708992, -708858, -708503, -708327, -708107, -703165, -703070, -698491, -698408, -696183, -691396, -689170, -683602, -681016, -681004, -679423, -678710, -678110, -675747, -672764, -672183, -671318, -669036, -666682, -663882, -658444, -652812, -652570, -651282, -650117, -647445, -647032, -645400, -643448, -643032, -641211, -640966, -639180, -638644, -631017, -629124, -628266, -627326, -626751, -622803, -621997, -617267, -614916, -611545, -610235, -608265, -606528, -605394, -604643, -602724, -601137, -600904, -599893, -595128, -595110, -595051, -589778, -588397, -585457, -583924, -582449, -577489, -574917, -573052, -570235, -570057, -568734, -567691, -566107, -566005, -565292, -565044, -562667, -561943, -557920, -557165, -556696, -551209, -550725, -548397, -546962, -545405, -544513, -542856, -539916, -539036, -539033, -538421, -537103, -537096, -535937, -531820, -531799, -531219, -529665, -524228, -520413, -517994, -513147, -511694, -503901, -498984, -498918, -498417, -495330, -494970, -494675, -490099, -488750, -488027, -486632, -483819, -483353, -480105, -479694, -475572, -471747, -471260, -470615, -469126, -469091, -467435, -465038, -464180, -457106, -456851, -456315, -454742, -454265, -448588, -447441, -441802, -441523, -440304, -439990, -437237, -435428, -433858, -430596, -430320, -419534, -417665, -417593, -415612, -415410, -413884, -413485, -412445, -412039, -409117, -404157, -403104, -402214, -399297, -398009, -394662, -394400, -387068, -382956, -377479, -376780, -376732, -373809, -369876, -369250, -366798, -364205, -362359, -361703, -360946, -356672, -356301, -354579, -350532, -344807, -343006, -341940, -340847, -334305, -333283, -331280, -329095, -322367, -321737, -320405, -319271, -318683, -318148, -312601, -312402, -311172, -308093, -303657, -301896, -301585, -300840, -299090, -290587, -290405, -288264, -286310, -285260, -283203, -281602, -280554, -277719, -277367, -273499, -273444, -266670, -266440, -266149, -263766, -263213, -258359, -258188, -257967, -256143, -254244, -254129, -253986, -252380, -250078, -248068, -241806, -234082, -231422, -226961, -226726, -224936, -220543, -218730, -217704, -216979, -212839, -212231, -209975, -209144, -208686, -206761, -204086, -203947, -203596, -200865, -198871, -196137, -193656, -192660, -191771, -190406, -190224, -189580, -183656, -182032, -181673, -179539, -178558, -178466, -171235, -169035, -168139, -163334, -162513, -159760, -153352, -151430, -149200, -148617, -147789, -146917, -143520, -141685, -140765, -138541, -137192, -136378, -136121, -135248, -126620, -126018, -124977, -124810, -124358, -123734, -123261, -120319, -117462, -116511, -113094, -111945, -107280, -107221, -103278, -99794, -99775, -97702, -96349, -93791, -93493, -92391, -89145, -88439, -85669, -81817, -78682, -71833, -68860, -68714, -66797, -66115, -65327, -63854, -63614, -62880, -61941, -58666, -55315, -54143, -54070, -50608, -50453, -50025, -49444, -47389, -46445, -42733, -38631, -28209, -23554, -22756, -21808, -21461, -19811, -17204, -15400, -15043, -14099, -10116, -4103, 4761, 7511, 8026, 8217, 8284, 9484, 10304, 10433, 15501, 23625, 24668, 26630, 27875, 29371, 32597, 33292, 33711, 33835, 38629, 41433, 42645, 45027, 48184, 49370, 49737, 51485, 53558, 56863, 57782, 58214, 58573, 59943, 60158, 61095, 64861, 68094, 69967, 72210, 84911, 88369, 89569, 91175, 93323, 94736, 95731, 96867, 101547, 101593, 105577, 105915, 108291, 109642, 110430, 111261, 114242, 115015, 115784, 116059, 117074, 119086, 124427, 124811, 125783, 129934, 130169, 132333, 132585, 133603, 134202, 137590, 138376, 140572, 143242, 143832, 149286, 153069, 154031, 156120, 156799, 156803, 159725, 161308, 162138, 168290, 171154, 171905, 173061, 174367, 175790, 177101, 177608, 179283, 179832, 181354, 182163, 183845, 184610, 187399, 190545, 194968, 196332, 196439, 196946, 197373, 197625, 199136, 200717, 204007, 209721, 211050, 212345, 214558, 215817, 217076, 219635, 220292, 222193, 224098, 229558, 234550, 240765, 243016, 244080, 248669, 254163, 255187, 256021, 258150, 264040, 269104, 272968, 273359, 273622, 275264, 277058, 278050, 278906, 281780, 282628, 282720, 283114, 283439, 284020, 288098, 290080, 293982, 295723, 300918, 302834, 303035, 306573, 310242, 311126, 311338, 312957, 313208, 318327, 319716, 320445, 322223, 326356, 326844, 333589, 341789, 343809, 344774, 345112, 347326, 347896, 348278, 348841, 351778, 352444, 354028, 354953, 356061, 357611, 359826, 362735, 362877, 370417, 377109, 380674, 382971, 383186, 383211, 383859, 386344, 386397, 389923, 391672, 394574, 396502, 396879, 396945, 399865, 401285, 406208, 406977, 412249, 413024, 419364, 419428, 424013, 424713, 426389, 429151, 430049, 432057, 433879, 433953, 437055, 437699, 438636, 438642, 440257, 440688, 441524, 441968, 442003, 444787, 444843, 447109, 450702, 450703, 451700, 453368, 453389, 453417, 453440, 454547, 461876, 465340, 465460, 468459, 470522, 473262, 475745, 481459, 483851, 484724, 485927, 486314, 487541, 488382, 491649, 492365, 492761, 497716, 497953, 499773, 500839, 503845, 504141, 506154, 508253, 508544, 509945, 511637, 514963, 516434, 516681, 516931, 529764, 530524, 536303, 536933, 539344, 542245, 542892, 543252, 545202, 552352, 552610, 554833, 555222, 555540, 556950, 556951, 562806, 563245, 564036, 565833, 567567, 567771, 568748, 569404, 571150, 571839, 573065, 573324, 573473, 574913, 578939, 586068, 587628, 588939, 589801, 590664, 591492, 599686, 602288, 604390, 610124, 614532, 617774, 626243, 628318, 629894, 634198, 634418, 634735, 640547, 641173, 645439, 645595, 646370, 649042, 649956, 651031, 651237, 655060, 656329, 656960, 657035, 657601, 659421, 660262, 662337, 662428, 663337, 664290, 665674, 666263, 666601, 667893, 671527, 673865, 674923, 675394, 679169, 680930, 683013, 685720, 686089, 686494, 690082, 690321, 690619, 691996, 695204, 698064, 699115, 705381, 709639, 712137, 712366, 713867, 713909, 714648, 714905, 716657, 718347, 719072, 719292, 719437, 721477, 722108, 722586, 726743, 730006, 732031, 732487, 734262, 734575, 736410, 738892, 739745, 742763, 745439, 750432, 752823, 753119, 754063, 754449, 754559, 756807, 759050, 762380, 763211, 765016, 766971, 767664, 768995, 769780, 770541, 770615, 772130, 773032, 774493, 775283, 776640, 777953, 779428, 780696, 788321, 789897, 795699, 801007, 801087, 801097, 804984, 807159, 807678, 808151, 812311, 812962, 813002, 814512, 814593, 816861, 819471, 819664, 820689, 823510, 824399, 824650, 825381, 826986, 826997, 828200, 831273, 833409, 833690, 835405, 842094, 842655, 844201, 844883, 848760, 850573, 851037, 852353, 853756, 854762, 855014, 857050, 857749, 858984, 860710, 862800, 863655, 866425, 866556, 868331, 868475, 869176, 869789, 870317, 881520, 883667, 885141, 885246, 885718, 886755, 887107, 887112, 889343, 895548, 898611, 899482, 902793, 906288, 908715, 909938, 912501, 914477, 915301, 916209, 916213, 920617, 921592, 928058, 930278, 931949, 931964, 932707, 935617, 938378, 939591, 940801, 943139, 943984, 945433, 945527, 949018, 949399, 949761, 952476, 960915, 961052, 961920, 962740, 963348, 964522, 965677, 966087, 967130, 969531, 971091, 974509, 975654, 978955, 980370, 985598, 992742, 993415, 994578, 997743, 999337]"
                    },
                    {
                        "username": "luanct",
                        "content": "O(m+n) approach is an easy problem when all of us know how to implement merge sort.\nBut when the description says that we should implement in O(log(m+n)) runtime complexity then here the binary search comes, no merge 2 array anymore. That's kinda hard question, but not too hard."
                    },
                    {
                        "username": "aitachii",
                        "content": "Use 4 pointers\n\nHonestly, you're better off learning the `O(log(m+n))` and  `O(log(min(m,n)))` solution from the Editorial or any other place but you can still try doing the intuitive `O(m+n)` solution."
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'m getting the correct answer in my IDLE, however, it is showing wrong here. 2.5 is the answer i got on my IDE and it was correct logic, it\\'s showing 2.0 here. Why so ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you cast your integers into double before dividing by 2.0?"
                    },
                    {
                        "username": "jkkjofaxiu",
                        "content": "The online python version might cause test case fails. In example, `sum([2, 3]) / 2` returns `2.5` in my local python interpreter (3.10), but it returns  `2` in the online interpreter. I have to add type convert before doing division `float(sum([2, 3])) / 2`. reference [pep-0238](https://peps.python.org/pep-0238/)"
                    },
                    {
                        "username": "Zefick",
                        "content": "Select \"Python 3\" language. \"Python\" is actually the Python 2.x and it has different division rules."
                    },
                    {
                        "username": "jingminzhou",
                        "content": "The binary search solution can be solved in O(log(MIN(m, n))) time frame, but it took me countless hours to debug my code for all corner cases. Meanwhile, a O(m+n) solution is much cleaner, more readable, more maintainable, and took way less time to get the code correct. Asking you to code such problems in a 20-45 interview session only shows how *incompetent* the interviewer is - he/she obviously weights more on \"clever\" tricks than better code."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "if an interviewer asks you this question and then asks for O(log (m+n)) solution... they do not want you to get the job"
                    },
                    {
                        "username": "piyush9242kumar",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            int n = nums1.size(), m = nums2.size();\\n    if( n > m)\\n    {\\n        swap(n, m);\\n        swap(nums1, nums2);\\n    }    \\n\\n    int s = 0, e = n;\\n    while(s <= e)\\n    {\\n        int i = (s+e)/2;\\n        int j = (m+n+1)/2 - i;\\n        \\n        if(i < n and nums2[j - 1] > nums1[i])\\n            s = i+1;\\n        else if(i > 0 and nums1[i-1] > nums2[j])\\n            e = i-1;\\n        else\\n        {\\n            int left = 0;\\n            if(i == 0)\\n                left = nums2[j-1];\\n            else if(j == 0)\\n                left = nums1[i-1];\\n            else\\n                left = max(nums1[i-1], nums2[j-1]);\\n            \\n            if((m+n) % 2 & 1ll)\\n                return left;\\n\\n            int right = 0;\\n            if(i == n)\\n                right = nums2[j];\\n            if(j == n)\\n                right = nums1[i];\\n            else\\n                right = min(nums1[i], nums2[j]);\\n\\n            return (right+left)/2.0;\\n        }\\n    }\\n        return 0;\\n    }\\n};\\nyour inline code...`\\n\\nwhy is this code not working in leetcode it is working fine when I run it on my pc"
                    },
                    {
                        "username": "ghOst-vedant",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> merged;\\n        int s1=nums1.size();\\n        int s2=nums2.size();\\n        int i=0,j=0;\\n        double median=0;\\n        int mid=0,total=s1+s2;\\n        while(i<s1 && j<s2){\\n            if(nums1[i]<nums2[j]){\\n                merged.push_back(nums1[i++]);\\n            }\\n            else if(nums2[j]<nums1[i]){\\n                merged.push_back(nums2[j++]);\\n            }\\n            else{\\n                merged.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        while(i<s1){\\n            merged.push_back(nums1[i++]);\\n        }\\n        while(j<s2){\\n            merged.push_back(nums2[j++]);\\n        }\\n        if((total)%2==1){\\n            median=(merged[total/2]);\\n        }\\n        else{\\n            mid=(total)/2;\\n            median=(merged[mid]+merged[mid+1])/2.0;\\n        }\\n        return median;\\n    }\\n};\\n\\nhelp please I\\'m notr getting expected output for:\\n[1,1,1,1,1,1,1,1,1,1,4,4]\\n[1,3,4,4,4,4,4,4,4,4,4]\\n it need to be 3 but mine is 4"
                    },
                    {
                        "username": "HiltonUniverse",
                        "content": "We need a new difficult level called: God mode. Learning this was one crazy journey."
                    }
                ]
            },
            {
                "id": 2066501,
                "content": [
                    {
                        "username": "justinleung0204",
                        "content": "try \\n[-994655, -993994, -991967, -991325, -990398, -988095, -985751, -979217, -978192, -978011, -977429, -976673, -975247, -974516, -972815, -972128, -969579, -968714, -966498, -965804, -965649, -965398, -964406, -959276, -957464, -957387, -955598, -955414, -954591, -954093, -954030, -954026, -953568, -951586, -949720, -948620, -948067, -947702, -944747, -939522, -939390, -938770, -936821, -935171, -934261, -932485, -930539, -927942, -927441, -927304, -925848, -924409, -922636, -921691, -921180, -920983, -920322, -916773, -916293, -914806, -914595, -913674, -911815, -911371, -910861, -909825, -909148, -907716, -907408, -906773, -905247, -904944, -904001, -902721, -898131, -894932, -894560, -894204, -890932, -890586, -890069, -888310, -885313, -882692, -881456, -880824, -878763, -878112, -876247, -875654, -870390, -867532, -867324, -867058, -866471, -865559, -861404, -861074, -858880, -858287, -857419, -852828, -851970, -850887, -850781, -847064, -845959, -844400, -843865, -842229, -841504, -838420, -837661, -832341, -830491, -825293, -825170, -824615, -820676, -820657, -812263, -811178, -809320, -807655, -806194, -804182, -800065, -798525, -797897, -797674, -796210, -794011, -793851, -792819, -792074, -790951, -785779, -783652, -780803, -780429, -777118, -775053, -772694, -771726, -770114, -769735, -769420, -767702, -767674, -767478, -767208, -766647, -766326, -766171, -762990, -762262, -760950, -759882, -758089, -754901, -753444, -752476, -749957, -749006, -748946, -744097, -744040, -743806, -742040, -739358, -738506, -737332, -736316, -733828, -732416, -732205, -730920, -729686, -729326, -729138, -728690, -728587, -725291, -721993, -721992, -720924, -719181, -718985, -717776, -714652, -708778, -706347, -703008, -701329, -698849, -697626, -697226, -697030, -694863, -687971, -687615, -687424, -685428, -684993, -682056, -667871, -666917, -666776, -665524, -658872, -658109, -656999, -655860, -654585, -654567, -651017, -649888, -647590, -646763, -645638, -638225, -637214, -636529, -633272, -633041, -628082, -628074, -625948, -625778, -622448, -622326, -621929, -620161, -617798, -616576, -611212, -610377, -609261, -608425, -606242, -603468, -603394, -601744, -595969, -594421, -594310, -592685, -590529, -589111, -584672, -583224, -582511, -580883, -580187, -578709, -577674, -571825, -568085, -566554, -561892, -560889, -560243, -558453, -558272, -557250, -556808, -555477, -553500, -549913, -549122, -546769, -544973, -544931, -543612, -542175, -538884, -536964, -533928, -531674, -530917, -530560, -528123, -527672, -525811, -524895, -521574, -516255, -513441, -512365, -511052, -510908, -510079, -504485, -502724, -502713, -500985, -496529, -493674, -493237, -492219, -489936, -487103, -484436, -482849, -482574, -482438, -482307, -481959, -481755, -481499, -481119, -477835, -471451, -465684, -464144, -461270, -458708, -458164, -457157, -454667, -454446, -453810, -452722, -450750, -444975, -440175, -436952, -433585, -431811, -431720, -425111, -423881, -421194, -417870, -413472, -409253, -406580, -404742, -398875, -396025, -395996, -392462, -390019, -389063, -388162, -387957, -384367, -384027, -383828, -382868, -382548, -381340, -381173, -376972, -373184, -370443, -369784, -369455, -367706, -362942, -361908, -360373, -356580, -344963, -344933, -344512, -344413, -340781, -335776, -335511, -332496, -332446, -332409, -332143, -326673, -326193, -324660, -322211, -321050, -318489, -317015, -316691, -312615, -309925, -305811, -303248, -302524, -301475, -299453, -298686, -291993, -287894, -284511, -278832, -274460, -269894, -265159, -264165, -263392, -261037, -258641, -255496, -255178, -254565, -252402, -250505, -246222, -244617, -239476, -237763, -235060, -233619, -231114, -228848, -228656, -228578, -228226, -226331, -223722, -221392, -220245, -214583, -208621, -208343, -205857, -204617, -204304, -204285, -200047, -198543, -196234, -195210, -192665, -191287, -190204, -187869, -180022, -175780, -169961, -165183, -163516, -162511, -159937, -159803, -157580, -155940, -154326, -153617, -151366, -150658, -149895, -143392, -142415, -141753, -140801, -140080, -138421, -137027, -136051, -135650, -132303, -131807, -130982, -130351, -126965, -124889, -120330, -115763, -115533, -115175, -114069, -113806, -105748, -104513, -103830, -103764, -103087, -102295, -98578, -97385, -93806, -92518, -90790, -89187, -88063, -86842, -86501, -85210, -82344, -80068, -76951, -72564, -71907, -68477, -67744, -65798, -65780, -62141, -61154, -58960, -58115, -55704, -48527, -47225, -44349, -44029, -35038, -34583, -34362, -33071, -30648, -27662, -24982, -24466, -24397, -22420, -22009, -20987, -18291, -15623, -14045, -12181, -8728, -6981, -5731, -2950, 1367, 1818, 2401, 2938, 4264, 4584, 11242, 12709, 14171, 18698, 19038, 19599, 25362, 27010, 27929, 28395, 32259, 32665, 33468, 39762, 40127, 41189, 48605, 50424, 50906, 53805, 54014, 54624, 55043, 55794, 56943, 57003, 58277, 58831, 59986, 62496, 63300, 63605, 63676, 66787, 72481, 74582, 81305, 85419, 86260, 88773, 89468, 89893, 91087, 93138, 98928, 99485, 101867, 103182, 103643, 108080, 110424, 112405, 115488, 118543, 119684, 120157, 121520, 123015, 123924, 124286, 125825, 127501, 128321, 128666, 129072, 129364, 130767, 135733, 136137, 136842, 137411, 140242, 141253, 143452, 145059, 145544, 146265, 146279, 150295, 150670, 156025, 156460, 157376, 158128, 161217, 161807, 163218, 164005, 164019, 165078, 167877, 173294, 174293, 175499, 180190, 192118, 202050, 203337, 203624, 203848, 204865, 205804, 206171, 208552, 209042, 213388, 219026, 219326, 220237, 220523, 220764, 221011, 222353, 223547, 224087, 225137, 226694, 226946, 229949, 234630, 235166, 237063, 240044, 241984, 245391, 251124, 255354, 255617, 264578, 268464, 268874, 273129, 276470, 276947, 281221, 281464, 282559, 282670, 283776, 287452, 296062, 296337, 297368, 299522, 300248, 300477, 301826, 302041, 303045, 307342, 310186, 310775, 315405, 315655, 316020, 317199, 320681, 322423, 324207, 325763, 325947, 327388, 328055, 330375, 331369, 336117, 337601, 337922, 338413, 339689, 344223, 345602, 347266, 349666, 354635, 357004, 359434, 364032, 365612, 366258, 368356, 371959, 374211, 376232, 381889, 383873, 384773, 387686, 387740, 388208, 389155, 393759, 394337, 394868, 395326, 395421, 397150, 404334, 404733, 407893, 408870, 413736, 415400, 423697, 424224, 424265, 425890, 427506, 427704, 431231, 431344, 432838, 432923, 436850, 438152, 438400, 445828, 447957, 448944, 452475, 454037, 454042, 461568, 465456, 467202, 467621, 468330, 470674, 476464, 477326, 477762, 480008, 485465, 486033, 491446, 498300, 501100, 501423, 504302, 505800, 506539, 506676, 508254, 508725, 510582, 515056, 517777, 520579, 521061, 524719, 529371, 534703, 539864, 541871, 544689, 544989, 548490, 551646, 552914, 552916, 554936, 555192, 557279, 557586, 557842, 558356, 558545, 559741, 561964, 565092, 566614, 568317, 571816, 572954, 577836, 578284, 578288, 582481, 585000, 587923, 594589, 595497, 596243, 596553, 600481, 601999, 605611, 605625, 605898, 606984, 610671, 611329, 614007, 615026, 616123, 616465, 616695, 619115, 620944, 621183, 621238, 622624, 623709, 626170, 631512, 633734, 633897, 642285, 643515, 644487, 645569, 648469, 649319, 651622, 652349, 652471, 652656, 653350, 654672, 657564, 658798, 659881, 660364, 668169, 673024, 674223, 674379, 676960, 678797, 684346, 684844, 685550, 685896, 687722, 689208, 691097, 696537, 701992, 707493, 710182, 714908, 717494, 724297, 727641, 728373, 729877, 731508, 734590, 735305, 735317, 739140, 746284, 752465, 753806, 758884, 760396, 762874, 764092, 765117, 765790, 766725, 768602, 776053, 778383, 779166, 780941, 781907, 785696, 790021, 792947, 794668, 796450, 800590, 804655, 805756, 808165, 813998, 814743, 815376, 815601, 816512, 816963, 817371, 821429, 828465, 830397, 830745, 832817, 834284, 835718, 838315, 838606, 839502, 840290, 840523, 845697, 847854, 848272, 849574, 853478, 860115, 863716, 865873, 866963, 867234, 867719, 868116, 868662, 870298, 874510, 874747, 875141, 875616, 875673, 876231, 876818, 877363, 877878, 884584, 889654, 892550, 892839, 894332, 894848, 895292, 903528, 909968, 918085, 918731, 923542, 925517, 925993, 927445, 930221, 932594, 934728, 934944, 944427, 944811, 950539, 951356, 951819, 952739, 954583, 957900, 957933, 958923, 964744, 965862, 965989, 966665, 971239, 972730, 974831, 975587, 975977, 977660, 978787, 983506, 988173, 989550, 990686, 991667, 992009, 994375, 995734, 997675, 999532]\\n[-999976, -998102, -996399, -990171, -987077, -985460, -977325, -973944, -973755, -970843, -970712, -969253, -968809, -967953, -964787, -964159, -963370, -962146, -961939, -961865, -961002, -959225, -955032, -951432, -950628, -950501, -949979, -949052, -948579, -948255, -948180, -947382, -946831, -943856, -943265, -941884, -939367, -934655, -933594, -933267, -933150, -931941, -931355, -929961, -928950, -926385, -925900, -922392, -921349, -917159, -915852, -913868, -913177, -912126, -911650, -906208, -904331, -900631, -900396, -900260, -898073, -894053, -892157, -888801, -885113, -884606, -876379, -876182, -874294, -873461, -873375, -866686, -864153, -861753, -859036, -858613, -855308, -853122, -849717, -849038, -847682, -847591, -847548, -847493, -843804, -842136, -841126, -840560, -838206, -837475, -832635, -831851, -829506, -821825, -821604, -821416, -819921, -818596, -814728, -812401, -802668, -802341, -801782, -798938, -797448, -795949, -795454, -788062, -785374, -779662, -776140, -773108, -772295, -771332, -768511, -768076, -757824, -754387, -753336, -752899, -752558, -748895, -748119, -745007, -744380, -740142, -740131, -736554, -725489, -724056, -719290, -719000, -715614, -715389, -712866, -710062, -708992, -708858, -708503, -708327, -708107, -703165, -703070, -698491, -698408, -696183, -691396, -689170, -683602, -681016, -681004, -679423, -678710, -678110, -675747, -672764, -672183, -671318, -669036, -666682, -663882, -658444, -652812, -652570, -651282, -650117, -647445, -647032, -645400, -643448, -643032, -641211, -640966, -639180, -638644, -631017, -629124, -628266, -627326, -626751, -622803, -621997, -617267, -614916, -611545, -610235, -608265, -606528, -605394, -604643, -602724, -601137, -600904, -599893, -595128, -595110, -595051, -589778, -588397, -585457, -583924, -582449, -577489, -574917, -573052, -570235, -570057, -568734, -567691, -566107, -566005, -565292, -565044, -562667, -561943, -557920, -557165, -556696, -551209, -550725, -548397, -546962, -545405, -544513, -542856, -539916, -539036, -539033, -538421, -537103, -537096, -535937, -531820, -531799, -531219, -529665, -524228, -520413, -517994, -513147, -511694, -503901, -498984, -498918, -498417, -495330, -494970, -494675, -490099, -488750, -488027, -486632, -483819, -483353, -480105, -479694, -475572, -471747, -471260, -470615, -469126, -469091, -467435, -465038, -464180, -457106, -456851, -456315, -454742, -454265, -448588, -447441, -441802, -441523, -440304, -439990, -437237, -435428, -433858, -430596, -430320, -419534, -417665, -417593, -415612, -415410, -413884, -413485, -412445, -412039, -409117, -404157, -403104, -402214, -399297, -398009, -394662, -394400, -387068, -382956, -377479, -376780, -376732, -373809, -369876, -369250, -366798, -364205, -362359, -361703, -360946, -356672, -356301, -354579, -350532, -344807, -343006, -341940, -340847, -334305, -333283, -331280, -329095, -322367, -321737, -320405, -319271, -318683, -318148, -312601, -312402, -311172, -308093, -303657, -301896, -301585, -300840, -299090, -290587, -290405, -288264, -286310, -285260, -283203, -281602, -280554, -277719, -277367, -273499, -273444, -266670, -266440, -266149, -263766, -263213, -258359, -258188, -257967, -256143, -254244, -254129, -253986, -252380, -250078, -248068, -241806, -234082, -231422, -226961, -226726, -224936, -220543, -218730, -217704, -216979, -212839, -212231, -209975, -209144, -208686, -206761, -204086, -203947, -203596, -200865, -198871, -196137, -193656, -192660, -191771, -190406, -190224, -189580, -183656, -182032, -181673, -179539, -178558, -178466, -171235, -169035, -168139, -163334, -162513, -159760, -153352, -151430, -149200, -148617, -147789, -146917, -143520, -141685, -140765, -138541, -137192, -136378, -136121, -135248, -126620, -126018, -124977, -124810, -124358, -123734, -123261, -120319, -117462, -116511, -113094, -111945, -107280, -107221, -103278, -99794, -99775, -97702, -96349, -93791, -93493, -92391, -89145, -88439, -85669, -81817, -78682, -71833, -68860, -68714, -66797, -66115, -65327, -63854, -63614, -62880, -61941, -58666, -55315, -54143, -54070, -50608, -50453, -50025, -49444, -47389, -46445, -42733, -38631, -28209, -23554, -22756, -21808, -21461, -19811, -17204, -15400, -15043, -14099, -10116, -4103, 4761, 7511, 8026, 8217, 8284, 9484, 10304, 10433, 15501, 23625, 24668, 26630, 27875, 29371, 32597, 33292, 33711, 33835, 38629, 41433, 42645, 45027, 48184, 49370, 49737, 51485, 53558, 56863, 57782, 58214, 58573, 59943, 60158, 61095, 64861, 68094, 69967, 72210, 84911, 88369, 89569, 91175, 93323, 94736, 95731, 96867, 101547, 101593, 105577, 105915, 108291, 109642, 110430, 111261, 114242, 115015, 115784, 116059, 117074, 119086, 124427, 124811, 125783, 129934, 130169, 132333, 132585, 133603, 134202, 137590, 138376, 140572, 143242, 143832, 149286, 153069, 154031, 156120, 156799, 156803, 159725, 161308, 162138, 168290, 171154, 171905, 173061, 174367, 175790, 177101, 177608, 179283, 179832, 181354, 182163, 183845, 184610, 187399, 190545, 194968, 196332, 196439, 196946, 197373, 197625, 199136, 200717, 204007, 209721, 211050, 212345, 214558, 215817, 217076, 219635, 220292, 222193, 224098, 229558, 234550, 240765, 243016, 244080, 248669, 254163, 255187, 256021, 258150, 264040, 269104, 272968, 273359, 273622, 275264, 277058, 278050, 278906, 281780, 282628, 282720, 283114, 283439, 284020, 288098, 290080, 293982, 295723, 300918, 302834, 303035, 306573, 310242, 311126, 311338, 312957, 313208, 318327, 319716, 320445, 322223, 326356, 326844, 333589, 341789, 343809, 344774, 345112, 347326, 347896, 348278, 348841, 351778, 352444, 354028, 354953, 356061, 357611, 359826, 362735, 362877, 370417, 377109, 380674, 382971, 383186, 383211, 383859, 386344, 386397, 389923, 391672, 394574, 396502, 396879, 396945, 399865, 401285, 406208, 406977, 412249, 413024, 419364, 419428, 424013, 424713, 426389, 429151, 430049, 432057, 433879, 433953, 437055, 437699, 438636, 438642, 440257, 440688, 441524, 441968, 442003, 444787, 444843, 447109, 450702, 450703, 451700, 453368, 453389, 453417, 453440, 454547, 461876, 465340, 465460, 468459, 470522, 473262, 475745, 481459, 483851, 484724, 485927, 486314, 487541, 488382, 491649, 492365, 492761, 497716, 497953, 499773, 500839, 503845, 504141, 506154, 508253, 508544, 509945, 511637, 514963, 516434, 516681, 516931, 529764, 530524, 536303, 536933, 539344, 542245, 542892, 543252, 545202, 552352, 552610, 554833, 555222, 555540, 556950, 556951, 562806, 563245, 564036, 565833, 567567, 567771, 568748, 569404, 571150, 571839, 573065, 573324, 573473, 574913, 578939, 586068, 587628, 588939, 589801, 590664, 591492, 599686, 602288, 604390, 610124, 614532, 617774, 626243, 628318, 629894, 634198, 634418, 634735, 640547, 641173, 645439, 645595, 646370, 649042, 649956, 651031, 651237, 655060, 656329, 656960, 657035, 657601, 659421, 660262, 662337, 662428, 663337, 664290, 665674, 666263, 666601, 667893, 671527, 673865, 674923, 675394, 679169, 680930, 683013, 685720, 686089, 686494, 690082, 690321, 690619, 691996, 695204, 698064, 699115, 705381, 709639, 712137, 712366, 713867, 713909, 714648, 714905, 716657, 718347, 719072, 719292, 719437, 721477, 722108, 722586, 726743, 730006, 732031, 732487, 734262, 734575, 736410, 738892, 739745, 742763, 745439, 750432, 752823, 753119, 754063, 754449, 754559, 756807, 759050, 762380, 763211, 765016, 766971, 767664, 768995, 769780, 770541, 770615, 772130, 773032, 774493, 775283, 776640, 777953, 779428, 780696, 788321, 789897, 795699, 801007, 801087, 801097, 804984, 807159, 807678, 808151, 812311, 812962, 813002, 814512, 814593, 816861, 819471, 819664, 820689, 823510, 824399, 824650, 825381, 826986, 826997, 828200, 831273, 833409, 833690, 835405, 842094, 842655, 844201, 844883, 848760, 850573, 851037, 852353, 853756, 854762, 855014, 857050, 857749, 858984, 860710, 862800, 863655, 866425, 866556, 868331, 868475, 869176, 869789, 870317, 881520, 883667, 885141, 885246, 885718, 886755, 887107, 887112, 889343, 895548, 898611, 899482, 902793, 906288, 908715, 909938, 912501, 914477, 915301, 916209, 916213, 920617, 921592, 928058, 930278, 931949, 931964, 932707, 935617, 938378, 939591, 940801, 943139, 943984, 945433, 945527, 949018, 949399, 949761, 952476, 960915, 961052, 961920, 962740, 963348, 964522, 965677, 966087, 967130, 969531, 971091, 974509, 975654, 978955, 980370, 985598, 992742, 993415, 994578, 997743, 999337]"
                    },
                    {
                        "username": "luanct",
                        "content": "O(m+n) approach is an easy problem when all of us know how to implement merge sort.\nBut when the description says that we should implement in O(log(m+n)) runtime complexity then here the binary search comes, no merge 2 array anymore. That's kinda hard question, but not too hard."
                    },
                    {
                        "username": "aitachii",
                        "content": "Use 4 pointers\n\nHonestly, you're better off learning the `O(log(m+n))` and  `O(log(min(m,n)))` solution from the Editorial or any other place but you can still try doing the intuitive `O(m+n)` solution."
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'m getting the correct answer in my IDLE, however, it is showing wrong here. 2.5 is the answer i got on my IDE and it was correct logic, it\\'s showing 2.0 here. Why so ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you cast your integers into double before dividing by 2.0?"
                    },
                    {
                        "username": "jkkjofaxiu",
                        "content": "The online python version might cause test case fails. In example, `sum([2, 3]) / 2` returns `2.5` in my local python interpreter (3.10), but it returns  `2` in the online interpreter. I have to add type convert before doing division `float(sum([2, 3])) / 2`. reference [pep-0238](https://peps.python.org/pep-0238/)"
                    },
                    {
                        "username": "Zefick",
                        "content": "Select \"Python 3\" language. \"Python\" is actually the Python 2.x and it has different division rules."
                    },
                    {
                        "username": "jingminzhou",
                        "content": "The binary search solution can be solved in O(log(MIN(m, n))) time frame, but it took me countless hours to debug my code for all corner cases. Meanwhile, a O(m+n) solution is much cleaner, more readable, more maintainable, and took way less time to get the code correct. Asking you to code such problems in a 20-45 interview session only shows how *incompetent* the interviewer is - he/she obviously weights more on \"clever\" tricks than better code."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "if an interviewer asks you this question and then asks for O(log (m+n)) solution... they do not want you to get the job"
                    },
                    {
                        "username": "piyush9242kumar",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            int n = nums1.size(), m = nums2.size();\\n    if( n > m)\\n    {\\n        swap(n, m);\\n        swap(nums1, nums2);\\n    }    \\n\\n    int s = 0, e = n;\\n    while(s <= e)\\n    {\\n        int i = (s+e)/2;\\n        int j = (m+n+1)/2 - i;\\n        \\n        if(i < n and nums2[j - 1] > nums1[i])\\n            s = i+1;\\n        else if(i > 0 and nums1[i-1] > nums2[j])\\n            e = i-1;\\n        else\\n        {\\n            int left = 0;\\n            if(i == 0)\\n                left = nums2[j-1];\\n            else if(j == 0)\\n                left = nums1[i-1];\\n            else\\n                left = max(nums1[i-1], nums2[j-1]);\\n            \\n            if((m+n) % 2 & 1ll)\\n                return left;\\n\\n            int right = 0;\\n            if(i == n)\\n                right = nums2[j];\\n            if(j == n)\\n                right = nums1[i];\\n            else\\n                right = min(nums1[i], nums2[j]);\\n\\n            return (right+left)/2.0;\\n        }\\n    }\\n        return 0;\\n    }\\n};\\nyour inline code...`\\n\\nwhy is this code not working in leetcode it is working fine when I run it on my pc"
                    },
                    {
                        "username": "ghOst-vedant",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> merged;\\n        int s1=nums1.size();\\n        int s2=nums2.size();\\n        int i=0,j=0;\\n        double median=0;\\n        int mid=0,total=s1+s2;\\n        while(i<s1 && j<s2){\\n            if(nums1[i]<nums2[j]){\\n                merged.push_back(nums1[i++]);\\n            }\\n            else if(nums2[j]<nums1[i]){\\n                merged.push_back(nums2[j++]);\\n            }\\n            else{\\n                merged.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        while(i<s1){\\n            merged.push_back(nums1[i++]);\\n        }\\n        while(j<s2){\\n            merged.push_back(nums2[j++]);\\n        }\\n        if((total)%2==1){\\n            median=(merged[total/2]);\\n        }\\n        else{\\n            mid=(total)/2;\\n            median=(merged[mid]+merged[mid+1])/2.0;\\n        }\\n        return median;\\n    }\\n};\\n\\nhelp please I\\'m notr getting expected output for:\\n[1,1,1,1,1,1,1,1,1,1,4,4]\\n[1,3,4,4,4,4,4,4,4,4,4]\\n it need to be 3 but mine is 4"
                    },
                    {
                        "username": "HiltonUniverse",
                        "content": "We need a new difficult level called: God mode. Learning this was one crazy journey."
                    }
                ]
            },
            {
                "id": 2066459,
                "content": [
                    {
                        "username": "justinleung0204",
                        "content": "try \\n[-994655, -993994, -991967, -991325, -990398, -988095, -985751, -979217, -978192, -978011, -977429, -976673, -975247, -974516, -972815, -972128, -969579, -968714, -966498, -965804, -965649, -965398, -964406, -959276, -957464, -957387, -955598, -955414, -954591, -954093, -954030, -954026, -953568, -951586, -949720, -948620, -948067, -947702, -944747, -939522, -939390, -938770, -936821, -935171, -934261, -932485, -930539, -927942, -927441, -927304, -925848, -924409, -922636, -921691, -921180, -920983, -920322, -916773, -916293, -914806, -914595, -913674, -911815, -911371, -910861, -909825, -909148, -907716, -907408, -906773, -905247, -904944, -904001, -902721, -898131, -894932, -894560, -894204, -890932, -890586, -890069, -888310, -885313, -882692, -881456, -880824, -878763, -878112, -876247, -875654, -870390, -867532, -867324, -867058, -866471, -865559, -861404, -861074, -858880, -858287, -857419, -852828, -851970, -850887, -850781, -847064, -845959, -844400, -843865, -842229, -841504, -838420, -837661, -832341, -830491, -825293, -825170, -824615, -820676, -820657, -812263, -811178, -809320, -807655, -806194, -804182, -800065, -798525, -797897, -797674, -796210, -794011, -793851, -792819, -792074, -790951, -785779, -783652, -780803, -780429, -777118, -775053, -772694, -771726, -770114, -769735, -769420, -767702, -767674, -767478, -767208, -766647, -766326, -766171, -762990, -762262, -760950, -759882, -758089, -754901, -753444, -752476, -749957, -749006, -748946, -744097, -744040, -743806, -742040, -739358, -738506, -737332, -736316, -733828, -732416, -732205, -730920, -729686, -729326, -729138, -728690, -728587, -725291, -721993, -721992, -720924, -719181, -718985, -717776, -714652, -708778, -706347, -703008, -701329, -698849, -697626, -697226, -697030, -694863, -687971, -687615, -687424, -685428, -684993, -682056, -667871, -666917, -666776, -665524, -658872, -658109, -656999, -655860, -654585, -654567, -651017, -649888, -647590, -646763, -645638, -638225, -637214, -636529, -633272, -633041, -628082, -628074, -625948, -625778, -622448, -622326, -621929, -620161, -617798, -616576, -611212, -610377, -609261, -608425, -606242, -603468, -603394, -601744, -595969, -594421, -594310, -592685, -590529, -589111, -584672, -583224, -582511, -580883, -580187, -578709, -577674, -571825, -568085, -566554, -561892, -560889, -560243, -558453, -558272, -557250, -556808, -555477, -553500, -549913, -549122, -546769, -544973, -544931, -543612, -542175, -538884, -536964, -533928, -531674, -530917, -530560, -528123, -527672, -525811, -524895, -521574, -516255, -513441, -512365, -511052, -510908, -510079, -504485, -502724, -502713, -500985, -496529, -493674, -493237, -492219, -489936, -487103, -484436, -482849, -482574, -482438, -482307, -481959, -481755, -481499, -481119, -477835, -471451, -465684, -464144, -461270, -458708, -458164, -457157, -454667, -454446, -453810, -452722, -450750, -444975, -440175, -436952, -433585, -431811, -431720, -425111, -423881, -421194, -417870, -413472, -409253, -406580, -404742, -398875, -396025, -395996, -392462, -390019, -389063, -388162, -387957, -384367, -384027, -383828, -382868, -382548, -381340, -381173, -376972, -373184, -370443, -369784, -369455, -367706, -362942, -361908, -360373, -356580, -344963, -344933, -344512, -344413, -340781, -335776, -335511, -332496, -332446, -332409, -332143, -326673, -326193, -324660, -322211, -321050, -318489, -317015, -316691, -312615, -309925, -305811, -303248, -302524, -301475, -299453, -298686, -291993, -287894, -284511, -278832, -274460, -269894, -265159, -264165, -263392, -261037, -258641, -255496, -255178, -254565, -252402, -250505, -246222, -244617, -239476, -237763, -235060, -233619, -231114, -228848, -228656, -228578, -228226, -226331, -223722, -221392, -220245, -214583, -208621, -208343, -205857, -204617, -204304, -204285, -200047, -198543, -196234, -195210, -192665, -191287, -190204, -187869, -180022, -175780, -169961, -165183, -163516, -162511, -159937, -159803, -157580, -155940, -154326, -153617, -151366, -150658, -149895, -143392, -142415, -141753, -140801, -140080, -138421, -137027, -136051, -135650, -132303, -131807, -130982, -130351, -126965, -124889, -120330, -115763, -115533, -115175, -114069, -113806, -105748, -104513, -103830, -103764, -103087, -102295, -98578, -97385, -93806, -92518, -90790, -89187, -88063, -86842, -86501, -85210, -82344, -80068, -76951, -72564, -71907, -68477, -67744, -65798, -65780, -62141, -61154, -58960, -58115, -55704, -48527, -47225, -44349, -44029, -35038, -34583, -34362, -33071, -30648, -27662, -24982, -24466, -24397, -22420, -22009, -20987, -18291, -15623, -14045, -12181, -8728, -6981, -5731, -2950, 1367, 1818, 2401, 2938, 4264, 4584, 11242, 12709, 14171, 18698, 19038, 19599, 25362, 27010, 27929, 28395, 32259, 32665, 33468, 39762, 40127, 41189, 48605, 50424, 50906, 53805, 54014, 54624, 55043, 55794, 56943, 57003, 58277, 58831, 59986, 62496, 63300, 63605, 63676, 66787, 72481, 74582, 81305, 85419, 86260, 88773, 89468, 89893, 91087, 93138, 98928, 99485, 101867, 103182, 103643, 108080, 110424, 112405, 115488, 118543, 119684, 120157, 121520, 123015, 123924, 124286, 125825, 127501, 128321, 128666, 129072, 129364, 130767, 135733, 136137, 136842, 137411, 140242, 141253, 143452, 145059, 145544, 146265, 146279, 150295, 150670, 156025, 156460, 157376, 158128, 161217, 161807, 163218, 164005, 164019, 165078, 167877, 173294, 174293, 175499, 180190, 192118, 202050, 203337, 203624, 203848, 204865, 205804, 206171, 208552, 209042, 213388, 219026, 219326, 220237, 220523, 220764, 221011, 222353, 223547, 224087, 225137, 226694, 226946, 229949, 234630, 235166, 237063, 240044, 241984, 245391, 251124, 255354, 255617, 264578, 268464, 268874, 273129, 276470, 276947, 281221, 281464, 282559, 282670, 283776, 287452, 296062, 296337, 297368, 299522, 300248, 300477, 301826, 302041, 303045, 307342, 310186, 310775, 315405, 315655, 316020, 317199, 320681, 322423, 324207, 325763, 325947, 327388, 328055, 330375, 331369, 336117, 337601, 337922, 338413, 339689, 344223, 345602, 347266, 349666, 354635, 357004, 359434, 364032, 365612, 366258, 368356, 371959, 374211, 376232, 381889, 383873, 384773, 387686, 387740, 388208, 389155, 393759, 394337, 394868, 395326, 395421, 397150, 404334, 404733, 407893, 408870, 413736, 415400, 423697, 424224, 424265, 425890, 427506, 427704, 431231, 431344, 432838, 432923, 436850, 438152, 438400, 445828, 447957, 448944, 452475, 454037, 454042, 461568, 465456, 467202, 467621, 468330, 470674, 476464, 477326, 477762, 480008, 485465, 486033, 491446, 498300, 501100, 501423, 504302, 505800, 506539, 506676, 508254, 508725, 510582, 515056, 517777, 520579, 521061, 524719, 529371, 534703, 539864, 541871, 544689, 544989, 548490, 551646, 552914, 552916, 554936, 555192, 557279, 557586, 557842, 558356, 558545, 559741, 561964, 565092, 566614, 568317, 571816, 572954, 577836, 578284, 578288, 582481, 585000, 587923, 594589, 595497, 596243, 596553, 600481, 601999, 605611, 605625, 605898, 606984, 610671, 611329, 614007, 615026, 616123, 616465, 616695, 619115, 620944, 621183, 621238, 622624, 623709, 626170, 631512, 633734, 633897, 642285, 643515, 644487, 645569, 648469, 649319, 651622, 652349, 652471, 652656, 653350, 654672, 657564, 658798, 659881, 660364, 668169, 673024, 674223, 674379, 676960, 678797, 684346, 684844, 685550, 685896, 687722, 689208, 691097, 696537, 701992, 707493, 710182, 714908, 717494, 724297, 727641, 728373, 729877, 731508, 734590, 735305, 735317, 739140, 746284, 752465, 753806, 758884, 760396, 762874, 764092, 765117, 765790, 766725, 768602, 776053, 778383, 779166, 780941, 781907, 785696, 790021, 792947, 794668, 796450, 800590, 804655, 805756, 808165, 813998, 814743, 815376, 815601, 816512, 816963, 817371, 821429, 828465, 830397, 830745, 832817, 834284, 835718, 838315, 838606, 839502, 840290, 840523, 845697, 847854, 848272, 849574, 853478, 860115, 863716, 865873, 866963, 867234, 867719, 868116, 868662, 870298, 874510, 874747, 875141, 875616, 875673, 876231, 876818, 877363, 877878, 884584, 889654, 892550, 892839, 894332, 894848, 895292, 903528, 909968, 918085, 918731, 923542, 925517, 925993, 927445, 930221, 932594, 934728, 934944, 944427, 944811, 950539, 951356, 951819, 952739, 954583, 957900, 957933, 958923, 964744, 965862, 965989, 966665, 971239, 972730, 974831, 975587, 975977, 977660, 978787, 983506, 988173, 989550, 990686, 991667, 992009, 994375, 995734, 997675, 999532]\\n[-999976, -998102, -996399, -990171, -987077, -985460, -977325, -973944, -973755, -970843, -970712, -969253, -968809, -967953, -964787, -964159, -963370, -962146, -961939, -961865, -961002, -959225, -955032, -951432, -950628, -950501, -949979, -949052, -948579, -948255, -948180, -947382, -946831, -943856, -943265, -941884, -939367, -934655, -933594, -933267, -933150, -931941, -931355, -929961, -928950, -926385, -925900, -922392, -921349, -917159, -915852, -913868, -913177, -912126, -911650, -906208, -904331, -900631, -900396, -900260, -898073, -894053, -892157, -888801, -885113, -884606, -876379, -876182, -874294, -873461, -873375, -866686, -864153, -861753, -859036, -858613, -855308, -853122, -849717, -849038, -847682, -847591, -847548, -847493, -843804, -842136, -841126, -840560, -838206, -837475, -832635, -831851, -829506, -821825, -821604, -821416, -819921, -818596, -814728, -812401, -802668, -802341, -801782, -798938, -797448, -795949, -795454, -788062, -785374, -779662, -776140, -773108, -772295, -771332, -768511, -768076, -757824, -754387, -753336, -752899, -752558, -748895, -748119, -745007, -744380, -740142, -740131, -736554, -725489, -724056, -719290, -719000, -715614, -715389, -712866, -710062, -708992, -708858, -708503, -708327, -708107, -703165, -703070, -698491, -698408, -696183, -691396, -689170, -683602, -681016, -681004, -679423, -678710, -678110, -675747, -672764, -672183, -671318, -669036, -666682, -663882, -658444, -652812, -652570, -651282, -650117, -647445, -647032, -645400, -643448, -643032, -641211, -640966, -639180, -638644, -631017, -629124, -628266, -627326, -626751, -622803, -621997, -617267, -614916, -611545, -610235, -608265, -606528, -605394, -604643, -602724, -601137, -600904, -599893, -595128, -595110, -595051, -589778, -588397, -585457, -583924, -582449, -577489, -574917, -573052, -570235, -570057, -568734, -567691, -566107, -566005, -565292, -565044, -562667, -561943, -557920, -557165, -556696, -551209, -550725, -548397, -546962, -545405, -544513, -542856, -539916, -539036, -539033, -538421, -537103, -537096, -535937, -531820, -531799, -531219, -529665, -524228, -520413, -517994, -513147, -511694, -503901, -498984, -498918, -498417, -495330, -494970, -494675, -490099, -488750, -488027, -486632, -483819, -483353, -480105, -479694, -475572, -471747, -471260, -470615, -469126, -469091, -467435, -465038, -464180, -457106, -456851, -456315, -454742, -454265, -448588, -447441, -441802, -441523, -440304, -439990, -437237, -435428, -433858, -430596, -430320, -419534, -417665, -417593, -415612, -415410, -413884, -413485, -412445, -412039, -409117, -404157, -403104, -402214, -399297, -398009, -394662, -394400, -387068, -382956, -377479, -376780, -376732, -373809, -369876, -369250, -366798, -364205, -362359, -361703, -360946, -356672, -356301, -354579, -350532, -344807, -343006, -341940, -340847, -334305, -333283, -331280, -329095, -322367, -321737, -320405, -319271, -318683, -318148, -312601, -312402, -311172, -308093, -303657, -301896, -301585, -300840, -299090, -290587, -290405, -288264, -286310, -285260, -283203, -281602, -280554, -277719, -277367, -273499, -273444, -266670, -266440, -266149, -263766, -263213, -258359, -258188, -257967, -256143, -254244, -254129, -253986, -252380, -250078, -248068, -241806, -234082, -231422, -226961, -226726, -224936, -220543, -218730, -217704, -216979, -212839, -212231, -209975, -209144, -208686, -206761, -204086, -203947, -203596, -200865, -198871, -196137, -193656, -192660, -191771, -190406, -190224, -189580, -183656, -182032, -181673, -179539, -178558, -178466, -171235, -169035, -168139, -163334, -162513, -159760, -153352, -151430, -149200, -148617, -147789, -146917, -143520, -141685, -140765, -138541, -137192, -136378, -136121, -135248, -126620, -126018, -124977, -124810, -124358, -123734, -123261, -120319, -117462, -116511, -113094, -111945, -107280, -107221, -103278, -99794, -99775, -97702, -96349, -93791, -93493, -92391, -89145, -88439, -85669, -81817, -78682, -71833, -68860, -68714, -66797, -66115, -65327, -63854, -63614, -62880, -61941, -58666, -55315, -54143, -54070, -50608, -50453, -50025, -49444, -47389, -46445, -42733, -38631, -28209, -23554, -22756, -21808, -21461, -19811, -17204, -15400, -15043, -14099, -10116, -4103, 4761, 7511, 8026, 8217, 8284, 9484, 10304, 10433, 15501, 23625, 24668, 26630, 27875, 29371, 32597, 33292, 33711, 33835, 38629, 41433, 42645, 45027, 48184, 49370, 49737, 51485, 53558, 56863, 57782, 58214, 58573, 59943, 60158, 61095, 64861, 68094, 69967, 72210, 84911, 88369, 89569, 91175, 93323, 94736, 95731, 96867, 101547, 101593, 105577, 105915, 108291, 109642, 110430, 111261, 114242, 115015, 115784, 116059, 117074, 119086, 124427, 124811, 125783, 129934, 130169, 132333, 132585, 133603, 134202, 137590, 138376, 140572, 143242, 143832, 149286, 153069, 154031, 156120, 156799, 156803, 159725, 161308, 162138, 168290, 171154, 171905, 173061, 174367, 175790, 177101, 177608, 179283, 179832, 181354, 182163, 183845, 184610, 187399, 190545, 194968, 196332, 196439, 196946, 197373, 197625, 199136, 200717, 204007, 209721, 211050, 212345, 214558, 215817, 217076, 219635, 220292, 222193, 224098, 229558, 234550, 240765, 243016, 244080, 248669, 254163, 255187, 256021, 258150, 264040, 269104, 272968, 273359, 273622, 275264, 277058, 278050, 278906, 281780, 282628, 282720, 283114, 283439, 284020, 288098, 290080, 293982, 295723, 300918, 302834, 303035, 306573, 310242, 311126, 311338, 312957, 313208, 318327, 319716, 320445, 322223, 326356, 326844, 333589, 341789, 343809, 344774, 345112, 347326, 347896, 348278, 348841, 351778, 352444, 354028, 354953, 356061, 357611, 359826, 362735, 362877, 370417, 377109, 380674, 382971, 383186, 383211, 383859, 386344, 386397, 389923, 391672, 394574, 396502, 396879, 396945, 399865, 401285, 406208, 406977, 412249, 413024, 419364, 419428, 424013, 424713, 426389, 429151, 430049, 432057, 433879, 433953, 437055, 437699, 438636, 438642, 440257, 440688, 441524, 441968, 442003, 444787, 444843, 447109, 450702, 450703, 451700, 453368, 453389, 453417, 453440, 454547, 461876, 465340, 465460, 468459, 470522, 473262, 475745, 481459, 483851, 484724, 485927, 486314, 487541, 488382, 491649, 492365, 492761, 497716, 497953, 499773, 500839, 503845, 504141, 506154, 508253, 508544, 509945, 511637, 514963, 516434, 516681, 516931, 529764, 530524, 536303, 536933, 539344, 542245, 542892, 543252, 545202, 552352, 552610, 554833, 555222, 555540, 556950, 556951, 562806, 563245, 564036, 565833, 567567, 567771, 568748, 569404, 571150, 571839, 573065, 573324, 573473, 574913, 578939, 586068, 587628, 588939, 589801, 590664, 591492, 599686, 602288, 604390, 610124, 614532, 617774, 626243, 628318, 629894, 634198, 634418, 634735, 640547, 641173, 645439, 645595, 646370, 649042, 649956, 651031, 651237, 655060, 656329, 656960, 657035, 657601, 659421, 660262, 662337, 662428, 663337, 664290, 665674, 666263, 666601, 667893, 671527, 673865, 674923, 675394, 679169, 680930, 683013, 685720, 686089, 686494, 690082, 690321, 690619, 691996, 695204, 698064, 699115, 705381, 709639, 712137, 712366, 713867, 713909, 714648, 714905, 716657, 718347, 719072, 719292, 719437, 721477, 722108, 722586, 726743, 730006, 732031, 732487, 734262, 734575, 736410, 738892, 739745, 742763, 745439, 750432, 752823, 753119, 754063, 754449, 754559, 756807, 759050, 762380, 763211, 765016, 766971, 767664, 768995, 769780, 770541, 770615, 772130, 773032, 774493, 775283, 776640, 777953, 779428, 780696, 788321, 789897, 795699, 801007, 801087, 801097, 804984, 807159, 807678, 808151, 812311, 812962, 813002, 814512, 814593, 816861, 819471, 819664, 820689, 823510, 824399, 824650, 825381, 826986, 826997, 828200, 831273, 833409, 833690, 835405, 842094, 842655, 844201, 844883, 848760, 850573, 851037, 852353, 853756, 854762, 855014, 857050, 857749, 858984, 860710, 862800, 863655, 866425, 866556, 868331, 868475, 869176, 869789, 870317, 881520, 883667, 885141, 885246, 885718, 886755, 887107, 887112, 889343, 895548, 898611, 899482, 902793, 906288, 908715, 909938, 912501, 914477, 915301, 916209, 916213, 920617, 921592, 928058, 930278, 931949, 931964, 932707, 935617, 938378, 939591, 940801, 943139, 943984, 945433, 945527, 949018, 949399, 949761, 952476, 960915, 961052, 961920, 962740, 963348, 964522, 965677, 966087, 967130, 969531, 971091, 974509, 975654, 978955, 980370, 985598, 992742, 993415, 994578, 997743, 999337]"
                    },
                    {
                        "username": "luanct",
                        "content": "O(m+n) approach is an easy problem when all of us know how to implement merge sort.\nBut when the description says that we should implement in O(log(m+n)) runtime complexity then here the binary search comes, no merge 2 array anymore. That's kinda hard question, but not too hard."
                    },
                    {
                        "username": "aitachii",
                        "content": "Use 4 pointers\n\nHonestly, you're better off learning the `O(log(m+n))` and  `O(log(min(m,n)))` solution from the Editorial or any other place but you can still try doing the intuitive `O(m+n)` solution."
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'m getting the correct answer in my IDLE, however, it is showing wrong here. 2.5 is the answer i got on my IDE and it was correct logic, it\\'s showing 2.0 here. Why so ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you cast your integers into double before dividing by 2.0?"
                    },
                    {
                        "username": "jkkjofaxiu",
                        "content": "The online python version might cause test case fails. In example, `sum([2, 3]) / 2` returns `2.5` in my local python interpreter (3.10), but it returns  `2` in the online interpreter. I have to add type convert before doing division `float(sum([2, 3])) / 2`. reference [pep-0238](https://peps.python.org/pep-0238/)"
                    },
                    {
                        "username": "Zefick",
                        "content": "Select \"Python 3\" language. \"Python\" is actually the Python 2.x and it has different division rules."
                    },
                    {
                        "username": "jingminzhou",
                        "content": "The binary search solution can be solved in O(log(MIN(m, n))) time frame, but it took me countless hours to debug my code for all corner cases. Meanwhile, a O(m+n) solution is much cleaner, more readable, more maintainable, and took way less time to get the code correct. Asking you to code such problems in a 20-45 interview session only shows how *incompetent* the interviewer is - he/she obviously weights more on \"clever\" tricks than better code."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "if an interviewer asks you this question and then asks for O(log (m+n)) solution... they do not want you to get the job"
                    },
                    {
                        "username": "piyush9242kumar",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            int n = nums1.size(), m = nums2.size();\\n    if( n > m)\\n    {\\n        swap(n, m);\\n        swap(nums1, nums2);\\n    }    \\n\\n    int s = 0, e = n;\\n    while(s <= e)\\n    {\\n        int i = (s+e)/2;\\n        int j = (m+n+1)/2 - i;\\n        \\n        if(i < n and nums2[j - 1] > nums1[i])\\n            s = i+1;\\n        else if(i > 0 and nums1[i-1] > nums2[j])\\n            e = i-1;\\n        else\\n        {\\n            int left = 0;\\n            if(i == 0)\\n                left = nums2[j-1];\\n            else if(j == 0)\\n                left = nums1[i-1];\\n            else\\n                left = max(nums1[i-1], nums2[j-1]);\\n            \\n            if((m+n) % 2 & 1ll)\\n                return left;\\n\\n            int right = 0;\\n            if(i == n)\\n                right = nums2[j];\\n            if(j == n)\\n                right = nums1[i];\\n            else\\n                right = min(nums1[i], nums2[j]);\\n\\n            return (right+left)/2.0;\\n        }\\n    }\\n        return 0;\\n    }\\n};\\nyour inline code...`\\n\\nwhy is this code not working in leetcode it is working fine when I run it on my pc"
                    },
                    {
                        "username": "ghOst-vedant",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> merged;\\n        int s1=nums1.size();\\n        int s2=nums2.size();\\n        int i=0,j=0;\\n        double median=0;\\n        int mid=0,total=s1+s2;\\n        while(i<s1 && j<s2){\\n            if(nums1[i]<nums2[j]){\\n                merged.push_back(nums1[i++]);\\n            }\\n            else if(nums2[j]<nums1[i]){\\n                merged.push_back(nums2[j++]);\\n            }\\n            else{\\n                merged.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        while(i<s1){\\n            merged.push_back(nums1[i++]);\\n        }\\n        while(j<s2){\\n            merged.push_back(nums2[j++]);\\n        }\\n        if((total)%2==1){\\n            median=(merged[total/2]);\\n        }\\n        else{\\n            mid=(total)/2;\\n            median=(merged[mid]+merged[mid+1])/2.0;\\n        }\\n        return median;\\n    }\\n};\\n\\nhelp please I\\'m notr getting expected output for:\\n[1,1,1,1,1,1,1,1,1,1,4,4]\\n[1,3,4,4,4,4,4,4,4,4,4]\\n it need to be 3 but mine is 4"
                    },
                    {
                        "username": "HiltonUniverse",
                        "content": "We need a new difficult level called: God mode. Learning this was one crazy journey."
                    }
                ]
            },
            {
                "id": 2064261,
                "content": [
                    {
                        "username": "justinleung0204",
                        "content": "try \\n[-994655, -993994, -991967, -991325, -990398, -988095, -985751, -979217, -978192, -978011, -977429, -976673, -975247, -974516, -972815, -972128, -969579, -968714, -966498, -965804, -965649, -965398, -964406, -959276, -957464, -957387, -955598, -955414, -954591, -954093, -954030, -954026, -953568, -951586, -949720, -948620, -948067, -947702, -944747, -939522, -939390, -938770, -936821, -935171, -934261, -932485, -930539, -927942, -927441, -927304, -925848, -924409, -922636, -921691, -921180, -920983, -920322, -916773, -916293, -914806, -914595, -913674, -911815, -911371, -910861, -909825, -909148, -907716, -907408, -906773, -905247, -904944, -904001, -902721, -898131, -894932, -894560, -894204, -890932, -890586, -890069, -888310, -885313, -882692, -881456, -880824, -878763, -878112, -876247, -875654, -870390, -867532, -867324, -867058, -866471, -865559, -861404, -861074, -858880, -858287, -857419, -852828, -851970, -850887, -850781, -847064, -845959, -844400, -843865, -842229, -841504, -838420, -837661, -832341, -830491, -825293, -825170, -824615, -820676, -820657, -812263, -811178, -809320, -807655, -806194, -804182, -800065, -798525, -797897, -797674, -796210, -794011, -793851, -792819, -792074, -790951, -785779, -783652, -780803, -780429, -777118, -775053, -772694, -771726, -770114, -769735, -769420, -767702, -767674, -767478, -767208, -766647, -766326, -766171, -762990, -762262, -760950, -759882, -758089, -754901, -753444, -752476, -749957, -749006, -748946, -744097, -744040, -743806, -742040, -739358, -738506, -737332, -736316, -733828, -732416, -732205, -730920, -729686, -729326, -729138, -728690, -728587, -725291, -721993, -721992, -720924, -719181, -718985, -717776, -714652, -708778, -706347, -703008, -701329, -698849, -697626, -697226, -697030, -694863, -687971, -687615, -687424, -685428, -684993, -682056, -667871, -666917, -666776, -665524, -658872, -658109, -656999, -655860, -654585, -654567, -651017, -649888, -647590, -646763, -645638, -638225, -637214, -636529, -633272, -633041, -628082, -628074, -625948, -625778, -622448, -622326, -621929, -620161, -617798, -616576, -611212, -610377, -609261, -608425, -606242, -603468, -603394, -601744, -595969, -594421, -594310, -592685, -590529, -589111, -584672, -583224, -582511, -580883, -580187, -578709, -577674, -571825, -568085, -566554, -561892, -560889, -560243, -558453, -558272, -557250, -556808, -555477, -553500, -549913, -549122, -546769, -544973, -544931, -543612, -542175, -538884, -536964, -533928, -531674, -530917, -530560, -528123, -527672, -525811, -524895, -521574, -516255, -513441, -512365, -511052, -510908, -510079, -504485, -502724, -502713, -500985, -496529, -493674, -493237, -492219, -489936, -487103, -484436, -482849, -482574, -482438, -482307, -481959, -481755, -481499, -481119, -477835, -471451, -465684, -464144, -461270, -458708, -458164, -457157, -454667, -454446, -453810, -452722, -450750, -444975, -440175, -436952, -433585, -431811, -431720, -425111, -423881, -421194, -417870, -413472, -409253, -406580, -404742, -398875, -396025, -395996, -392462, -390019, -389063, -388162, -387957, -384367, -384027, -383828, -382868, -382548, -381340, -381173, -376972, -373184, -370443, -369784, -369455, -367706, -362942, -361908, -360373, -356580, -344963, -344933, -344512, -344413, -340781, -335776, -335511, -332496, -332446, -332409, -332143, -326673, -326193, -324660, -322211, -321050, -318489, -317015, -316691, -312615, -309925, -305811, -303248, -302524, -301475, -299453, -298686, -291993, -287894, -284511, -278832, -274460, -269894, -265159, -264165, -263392, -261037, -258641, -255496, -255178, -254565, -252402, -250505, -246222, -244617, -239476, -237763, -235060, -233619, -231114, -228848, -228656, -228578, -228226, -226331, -223722, -221392, -220245, -214583, -208621, -208343, -205857, -204617, -204304, -204285, -200047, -198543, -196234, -195210, -192665, -191287, -190204, -187869, -180022, -175780, -169961, -165183, -163516, -162511, -159937, -159803, -157580, -155940, -154326, -153617, -151366, -150658, -149895, -143392, -142415, -141753, -140801, -140080, -138421, -137027, -136051, -135650, -132303, -131807, -130982, -130351, -126965, -124889, -120330, -115763, -115533, -115175, -114069, -113806, -105748, -104513, -103830, -103764, -103087, -102295, -98578, -97385, -93806, -92518, -90790, -89187, -88063, -86842, -86501, -85210, -82344, -80068, -76951, -72564, -71907, -68477, -67744, -65798, -65780, -62141, -61154, -58960, -58115, -55704, -48527, -47225, -44349, -44029, -35038, -34583, -34362, -33071, -30648, -27662, -24982, -24466, -24397, -22420, -22009, -20987, -18291, -15623, -14045, -12181, -8728, -6981, -5731, -2950, 1367, 1818, 2401, 2938, 4264, 4584, 11242, 12709, 14171, 18698, 19038, 19599, 25362, 27010, 27929, 28395, 32259, 32665, 33468, 39762, 40127, 41189, 48605, 50424, 50906, 53805, 54014, 54624, 55043, 55794, 56943, 57003, 58277, 58831, 59986, 62496, 63300, 63605, 63676, 66787, 72481, 74582, 81305, 85419, 86260, 88773, 89468, 89893, 91087, 93138, 98928, 99485, 101867, 103182, 103643, 108080, 110424, 112405, 115488, 118543, 119684, 120157, 121520, 123015, 123924, 124286, 125825, 127501, 128321, 128666, 129072, 129364, 130767, 135733, 136137, 136842, 137411, 140242, 141253, 143452, 145059, 145544, 146265, 146279, 150295, 150670, 156025, 156460, 157376, 158128, 161217, 161807, 163218, 164005, 164019, 165078, 167877, 173294, 174293, 175499, 180190, 192118, 202050, 203337, 203624, 203848, 204865, 205804, 206171, 208552, 209042, 213388, 219026, 219326, 220237, 220523, 220764, 221011, 222353, 223547, 224087, 225137, 226694, 226946, 229949, 234630, 235166, 237063, 240044, 241984, 245391, 251124, 255354, 255617, 264578, 268464, 268874, 273129, 276470, 276947, 281221, 281464, 282559, 282670, 283776, 287452, 296062, 296337, 297368, 299522, 300248, 300477, 301826, 302041, 303045, 307342, 310186, 310775, 315405, 315655, 316020, 317199, 320681, 322423, 324207, 325763, 325947, 327388, 328055, 330375, 331369, 336117, 337601, 337922, 338413, 339689, 344223, 345602, 347266, 349666, 354635, 357004, 359434, 364032, 365612, 366258, 368356, 371959, 374211, 376232, 381889, 383873, 384773, 387686, 387740, 388208, 389155, 393759, 394337, 394868, 395326, 395421, 397150, 404334, 404733, 407893, 408870, 413736, 415400, 423697, 424224, 424265, 425890, 427506, 427704, 431231, 431344, 432838, 432923, 436850, 438152, 438400, 445828, 447957, 448944, 452475, 454037, 454042, 461568, 465456, 467202, 467621, 468330, 470674, 476464, 477326, 477762, 480008, 485465, 486033, 491446, 498300, 501100, 501423, 504302, 505800, 506539, 506676, 508254, 508725, 510582, 515056, 517777, 520579, 521061, 524719, 529371, 534703, 539864, 541871, 544689, 544989, 548490, 551646, 552914, 552916, 554936, 555192, 557279, 557586, 557842, 558356, 558545, 559741, 561964, 565092, 566614, 568317, 571816, 572954, 577836, 578284, 578288, 582481, 585000, 587923, 594589, 595497, 596243, 596553, 600481, 601999, 605611, 605625, 605898, 606984, 610671, 611329, 614007, 615026, 616123, 616465, 616695, 619115, 620944, 621183, 621238, 622624, 623709, 626170, 631512, 633734, 633897, 642285, 643515, 644487, 645569, 648469, 649319, 651622, 652349, 652471, 652656, 653350, 654672, 657564, 658798, 659881, 660364, 668169, 673024, 674223, 674379, 676960, 678797, 684346, 684844, 685550, 685896, 687722, 689208, 691097, 696537, 701992, 707493, 710182, 714908, 717494, 724297, 727641, 728373, 729877, 731508, 734590, 735305, 735317, 739140, 746284, 752465, 753806, 758884, 760396, 762874, 764092, 765117, 765790, 766725, 768602, 776053, 778383, 779166, 780941, 781907, 785696, 790021, 792947, 794668, 796450, 800590, 804655, 805756, 808165, 813998, 814743, 815376, 815601, 816512, 816963, 817371, 821429, 828465, 830397, 830745, 832817, 834284, 835718, 838315, 838606, 839502, 840290, 840523, 845697, 847854, 848272, 849574, 853478, 860115, 863716, 865873, 866963, 867234, 867719, 868116, 868662, 870298, 874510, 874747, 875141, 875616, 875673, 876231, 876818, 877363, 877878, 884584, 889654, 892550, 892839, 894332, 894848, 895292, 903528, 909968, 918085, 918731, 923542, 925517, 925993, 927445, 930221, 932594, 934728, 934944, 944427, 944811, 950539, 951356, 951819, 952739, 954583, 957900, 957933, 958923, 964744, 965862, 965989, 966665, 971239, 972730, 974831, 975587, 975977, 977660, 978787, 983506, 988173, 989550, 990686, 991667, 992009, 994375, 995734, 997675, 999532]\\n[-999976, -998102, -996399, -990171, -987077, -985460, -977325, -973944, -973755, -970843, -970712, -969253, -968809, -967953, -964787, -964159, -963370, -962146, -961939, -961865, -961002, -959225, -955032, -951432, -950628, -950501, -949979, -949052, -948579, -948255, -948180, -947382, -946831, -943856, -943265, -941884, -939367, -934655, -933594, -933267, -933150, -931941, -931355, -929961, -928950, -926385, -925900, -922392, -921349, -917159, -915852, -913868, -913177, -912126, -911650, -906208, -904331, -900631, -900396, -900260, -898073, -894053, -892157, -888801, -885113, -884606, -876379, -876182, -874294, -873461, -873375, -866686, -864153, -861753, -859036, -858613, -855308, -853122, -849717, -849038, -847682, -847591, -847548, -847493, -843804, -842136, -841126, -840560, -838206, -837475, -832635, -831851, -829506, -821825, -821604, -821416, -819921, -818596, -814728, -812401, -802668, -802341, -801782, -798938, -797448, -795949, -795454, -788062, -785374, -779662, -776140, -773108, -772295, -771332, -768511, -768076, -757824, -754387, -753336, -752899, -752558, -748895, -748119, -745007, -744380, -740142, -740131, -736554, -725489, -724056, -719290, -719000, -715614, -715389, -712866, -710062, -708992, -708858, -708503, -708327, -708107, -703165, -703070, -698491, -698408, -696183, -691396, -689170, -683602, -681016, -681004, -679423, -678710, -678110, -675747, -672764, -672183, -671318, -669036, -666682, -663882, -658444, -652812, -652570, -651282, -650117, -647445, -647032, -645400, -643448, -643032, -641211, -640966, -639180, -638644, -631017, -629124, -628266, -627326, -626751, -622803, -621997, -617267, -614916, -611545, -610235, -608265, -606528, -605394, -604643, -602724, -601137, -600904, -599893, -595128, -595110, -595051, -589778, -588397, -585457, -583924, -582449, -577489, -574917, -573052, -570235, -570057, -568734, -567691, -566107, -566005, -565292, -565044, -562667, -561943, -557920, -557165, -556696, -551209, -550725, -548397, -546962, -545405, -544513, -542856, -539916, -539036, -539033, -538421, -537103, -537096, -535937, -531820, -531799, -531219, -529665, -524228, -520413, -517994, -513147, -511694, -503901, -498984, -498918, -498417, -495330, -494970, -494675, -490099, -488750, -488027, -486632, -483819, -483353, -480105, -479694, -475572, -471747, -471260, -470615, -469126, -469091, -467435, -465038, -464180, -457106, -456851, -456315, -454742, -454265, -448588, -447441, -441802, -441523, -440304, -439990, -437237, -435428, -433858, -430596, -430320, -419534, -417665, -417593, -415612, -415410, -413884, -413485, -412445, -412039, -409117, -404157, -403104, -402214, -399297, -398009, -394662, -394400, -387068, -382956, -377479, -376780, -376732, -373809, -369876, -369250, -366798, -364205, -362359, -361703, -360946, -356672, -356301, -354579, -350532, -344807, -343006, -341940, -340847, -334305, -333283, -331280, -329095, -322367, -321737, -320405, -319271, -318683, -318148, -312601, -312402, -311172, -308093, -303657, -301896, -301585, -300840, -299090, -290587, -290405, -288264, -286310, -285260, -283203, -281602, -280554, -277719, -277367, -273499, -273444, -266670, -266440, -266149, -263766, -263213, -258359, -258188, -257967, -256143, -254244, -254129, -253986, -252380, -250078, -248068, -241806, -234082, -231422, -226961, -226726, -224936, -220543, -218730, -217704, -216979, -212839, -212231, -209975, -209144, -208686, -206761, -204086, -203947, -203596, -200865, -198871, -196137, -193656, -192660, -191771, -190406, -190224, -189580, -183656, -182032, -181673, -179539, -178558, -178466, -171235, -169035, -168139, -163334, -162513, -159760, -153352, -151430, -149200, -148617, -147789, -146917, -143520, -141685, -140765, -138541, -137192, -136378, -136121, -135248, -126620, -126018, -124977, -124810, -124358, -123734, -123261, -120319, -117462, -116511, -113094, -111945, -107280, -107221, -103278, -99794, -99775, -97702, -96349, -93791, -93493, -92391, -89145, -88439, -85669, -81817, -78682, -71833, -68860, -68714, -66797, -66115, -65327, -63854, -63614, -62880, -61941, -58666, -55315, -54143, -54070, -50608, -50453, -50025, -49444, -47389, -46445, -42733, -38631, -28209, -23554, -22756, -21808, -21461, -19811, -17204, -15400, -15043, -14099, -10116, -4103, 4761, 7511, 8026, 8217, 8284, 9484, 10304, 10433, 15501, 23625, 24668, 26630, 27875, 29371, 32597, 33292, 33711, 33835, 38629, 41433, 42645, 45027, 48184, 49370, 49737, 51485, 53558, 56863, 57782, 58214, 58573, 59943, 60158, 61095, 64861, 68094, 69967, 72210, 84911, 88369, 89569, 91175, 93323, 94736, 95731, 96867, 101547, 101593, 105577, 105915, 108291, 109642, 110430, 111261, 114242, 115015, 115784, 116059, 117074, 119086, 124427, 124811, 125783, 129934, 130169, 132333, 132585, 133603, 134202, 137590, 138376, 140572, 143242, 143832, 149286, 153069, 154031, 156120, 156799, 156803, 159725, 161308, 162138, 168290, 171154, 171905, 173061, 174367, 175790, 177101, 177608, 179283, 179832, 181354, 182163, 183845, 184610, 187399, 190545, 194968, 196332, 196439, 196946, 197373, 197625, 199136, 200717, 204007, 209721, 211050, 212345, 214558, 215817, 217076, 219635, 220292, 222193, 224098, 229558, 234550, 240765, 243016, 244080, 248669, 254163, 255187, 256021, 258150, 264040, 269104, 272968, 273359, 273622, 275264, 277058, 278050, 278906, 281780, 282628, 282720, 283114, 283439, 284020, 288098, 290080, 293982, 295723, 300918, 302834, 303035, 306573, 310242, 311126, 311338, 312957, 313208, 318327, 319716, 320445, 322223, 326356, 326844, 333589, 341789, 343809, 344774, 345112, 347326, 347896, 348278, 348841, 351778, 352444, 354028, 354953, 356061, 357611, 359826, 362735, 362877, 370417, 377109, 380674, 382971, 383186, 383211, 383859, 386344, 386397, 389923, 391672, 394574, 396502, 396879, 396945, 399865, 401285, 406208, 406977, 412249, 413024, 419364, 419428, 424013, 424713, 426389, 429151, 430049, 432057, 433879, 433953, 437055, 437699, 438636, 438642, 440257, 440688, 441524, 441968, 442003, 444787, 444843, 447109, 450702, 450703, 451700, 453368, 453389, 453417, 453440, 454547, 461876, 465340, 465460, 468459, 470522, 473262, 475745, 481459, 483851, 484724, 485927, 486314, 487541, 488382, 491649, 492365, 492761, 497716, 497953, 499773, 500839, 503845, 504141, 506154, 508253, 508544, 509945, 511637, 514963, 516434, 516681, 516931, 529764, 530524, 536303, 536933, 539344, 542245, 542892, 543252, 545202, 552352, 552610, 554833, 555222, 555540, 556950, 556951, 562806, 563245, 564036, 565833, 567567, 567771, 568748, 569404, 571150, 571839, 573065, 573324, 573473, 574913, 578939, 586068, 587628, 588939, 589801, 590664, 591492, 599686, 602288, 604390, 610124, 614532, 617774, 626243, 628318, 629894, 634198, 634418, 634735, 640547, 641173, 645439, 645595, 646370, 649042, 649956, 651031, 651237, 655060, 656329, 656960, 657035, 657601, 659421, 660262, 662337, 662428, 663337, 664290, 665674, 666263, 666601, 667893, 671527, 673865, 674923, 675394, 679169, 680930, 683013, 685720, 686089, 686494, 690082, 690321, 690619, 691996, 695204, 698064, 699115, 705381, 709639, 712137, 712366, 713867, 713909, 714648, 714905, 716657, 718347, 719072, 719292, 719437, 721477, 722108, 722586, 726743, 730006, 732031, 732487, 734262, 734575, 736410, 738892, 739745, 742763, 745439, 750432, 752823, 753119, 754063, 754449, 754559, 756807, 759050, 762380, 763211, 765016, 766971, 767664, 768995, 769780, 770541, 770615, 772130, 773032, 774493, 775283, 776640, 777953, 779428, 780696, 788321, 789897, 795699, 801007, 801087, 801097, 804984, 807159, 807678, 808151, 812311, 812962, 813002, 814512, 814593, 816861, 819471, 819664, 820689, 823510, 824399, 824650, 825381, 826986, 826997, 828200, 831273, 833409, 833690, 835405, 842094, 842655, 844201, 844883, 848760, 850573, 851037, 852353, 853756, 854762, 855014, 857050, 857749, 858984, 860710, 862800, 863655, 866425, 866556, 868331, 868475, 869176, 869789, 870317, 881520, 883667, 885141, 885246, 885718, 886755, 887107, 887112, 889343, 895548, 898611, 899482, 902793, 906288, 908715, 909938, 912501, 914477, 915301, 916209, 916213, 920617, 921592, 928058, 930278, 931949, 931964, 932707, 935617, 938378, 939591, 940801, 943139, 943984, 945433, 945527, 949018, 949399, 949761, 952476, 960915, 961052, 961920, 962740, 963348, 964522, 965677, 966087, 967130, 969531, 971091, 974509, 975654, 978955, 980370, 985598, 992742, 993415, 994578, 997743, 999337]"
                    },
                    {
                        "username": "luanct",
                        "content": "O(m+n) approach is an easy problem when all of us know how to implement merge sort.\nBut when the description says that we should implement in O(log(m+n)) runtime complexity then here the binary search comes, no merge 2 array anymore. That's kinda hard question, but not too hard."
                    },
                    {
                        "username": "aitachii",
                        "content": "Use 4 pointers\n\nHonestly, you're better off learning the `O(log(m+n))` and  `O(log(min(m,n)))` solution from the Editorial or any other place but you can still try doing the intuitive `O(m+n)` solution."
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'m getting the correct answer in my IDLE, however, it is showing wrong here. 2.5 is the answer i got on my IDE and it was correct logic, it\\'s showing 2.0 here. Why so ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you cast your integers into double before dividing by 2.0?"
                    },
                    {
                        "username": "jkkjofaxiu",
                        "content": "The online python version might cause test case fails. In example, `sum([2, 3]) / 2` returns `2.5` in my local python interpreter (3.10), but it returns  `2` in the online interpreter. I have to add type convert before doing division `float(sum([2, 3])) / 2`. reference [pep-0238](https://peps.python.org/pep-0238/)"
                    },
                    {
                        "username": "Zefick",
                        "content": "Select \"Python 3\" language. \"Python\" is actually the Python 2.x and it has different division rules."
                    },
                    {
                        "username": "jingminzhou",
                        "content": "The binary search solution can be solved in O(log(MIN(m, n))) time frame, but it took me countless hours to debug my code for all corner cases. Meanwhile, a O(m+n) solution is much cleaner, more readable, more maintainable, and took way less time to get the code correct. Asking you to code such problems in a 20-45 interview session only shows how *incompetent* the interviewer is - he/she obviously weights more on \"clever\" tricks than better code."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "if an interviewer asks you this question and then asks for O(log (m+n)) solution... they do not want you to get the job"
                    },
                    {
                        "username": "piyush9242kumar",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            int n = nums1.size(), m = nums2.size();\\n    if( n > m)\\n    {\\n        swap(n, m);\\n        swap(nums1, nums2);\\n    }    \\n\\n    int s = 0, e = n;\\n    while(s <= e)\\n    {\\n        int i = (s+e)/2;\\n        int j = (m+n+1)/2 - i;\\n        \\n        if(i < n and nums2[j - 1] > nums1[i])\\n            s = i+1;\\n        else if(i > 0 and nums1[i-1] > nums2[j])\\n            e = i-1;\\n        else\\n        {\\n            int left = 0;\\n            if(i == 0)\\n                left = nums2[j-1];\\n            else if(j == 0)\\n                left = nums1[i-1];\\n            else\\n                left = max(nums1[i-1], nums2[j-1]);\\n            \\n            if((m+n) % 2 & 1ll)\\n                return left;\\n\\n            int right = 0;\\n            if(i == n)\\n                right = nums2[j];\\n            if(j == n)\\n                right = nums1[i];\\n            else\\n                right = min(nums1[i], nums2[j]);\\n\\n            return (right+left)/2.0;\\n        }\\n    }\\n        return 0;\\n    }\\n};\\nyour inline code...`\\n\\nwhy is this code not working in leetcode it is working fine when I run it on my pc"
                    },
                    {
                        "username": "ghOst-vedant",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> merged;\\n        int s1=nums1.size();\\n        int s2=nums2.size();\\n        int i=0,j=0;\\n        double median=0;\\n        int mid=0,total=s1+s2;\\n        while(i<s1 && j<s2){\\n            if(nums1[i]<nums2[j]){\\n                merged.push_back(nums1[i++]);\\n            }\\n            else if(nums2[j]<nums1[i]){\\n                merged.push_back(nums2[j++]);\\n            }\\n            else{\\n                merged.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        while(i<s1){\\n            merged.push_back(nums1[i++]);\\n        }\\n        while(j<s2){\\n            merged.push_back(nums2[j++]);\\n        }\\n        if((total)%2==1){\\n            median=(merged[total/2]);\\n        }\\n        else{\\n            mid=(total)/2;\\n            median=(merged[mid]+merged[mid+1])/2.0;\\n        }\\n        return median;\\n    }\\n};\\n\\nhelp please I\\'m notr getting expected output for:\\n[1,1,1,1,1,1,1,1,1,1,4,4]\\n[1,3,4,4,4,4,4,4,4,4,4]\\n it need to be 3 but mine is 4"
                    },
                    {
                        "username": "HiltonUniverse",
                        "content": "We need a new difficult level called: God mode. Learning this was one crazy journey."
                    }
                ]
            },
            {
                "id": 2064085,
                "content": [
                    {
                        "username": "justinleung0204",
                        "content": "try \\n[-994655, -993994, -991967, -991325, -990398, -988095, -985751, -979217, -978192, -978011, -977429, -976673, -975247, -974516, -972815, -972128, -969579, -968714, -966498, -965804, -965649, -965398, -964406, -959276, -957464, -957387, -955598, -955414, -954591, -954093, -954030, -954026, -953568, -951586, -949720, -948620, -948067, -947702, -944747, -939522, -939390, -938770, -936821, -935171, -934261, -932485, -930539, -927942, -927441, -927304, -925848, -924409, -922636, -921691, -921180, -920983, -920322, -916773, -916293, -914806, -914595, -913674, -911815, -911371, -910861, -909825, -909148, -907716, -907408, -906773, -905247, -904944, -904001, -902721, -898131, -894932, -894560, -894204, -890932, -890586, -890069, -888310, -885313, -882692, -881456, -880824, -878763, -878112, -876247, -875654, -870390, -867532, -867324, -867058, -866471, -865559, -861404, -861074, -858880, -858287, -857419, -852828, -851970, -850887, -850781, -847064, -845959, -844400, -843865, -842229, -841504, -838420, -837661, -832341, -830491, -825293, -825170, -824615, -820676, -820657, -812263, -811178, -809320, -807655, -806194, -804182, -800065, -798525, -797897, -797674, -796210, -794011, -793851, -792819, -792074, -790951, -785779, -783652, -780803, -780429, -777118, -775053, -772694, -771726, -770114, -769735, -769420, -767702, -767674, -767478, -767208, -766647, -766326, -766171, -762990, -762262, -760950, -759882, -758089, -754901, -753444, -752476, -749957, -749006, -748946, -744097, -744040, -743806, -742040, -739358, -738506, -737332, -736316, -733828, -732416, -732205, -730920, -729686, -729326, -729138, -728690, -728587, -725291, -721993, -721992, -720924, -719181, -718985, -717776, -714652, -708778, -706347, -703008, -701329, -698849, -697626, -697226, -697030, -694863, -687971, -687615, -687424, -685428, -684993, -682056, -667871, -666917, -666776, -665524, -658872, -658109, -656999, -655860, -654585, -654567, -651017, -649888, -647590, -646763, -645638, -638225, -637214, -636529, -633272, -633041, -628082, -628074, -625948, -625778, -622448, -622326, -621929, -620161, -617798, -616576, -611212, -610377, -609261, -608425, -606242, -603468, -603394, -601744, -595969, -594421, -594310, -592685, -590529, -589111, -584672, -583224, -582511, -580883, -580187, -578709, -577674, -571825, -568085, -566554, -561892, -560889, -560243, -558453, -558272, -557250, -556808, -555477, -553500, -549913, -549122, -546769, -544973, -544931, -543612, -542175, -538884, -536964, -533928, -531674, -530917, -530560, -528123, -527672, -525811, -524895, -521574, -516255, -513441, -512365, -511052, -510908, -510079, -504485, -502724, -502713, -500985, -496529, -493674, -493237, -492219, -489936, -487103, -484436, -482849, -482574, -482438, -482307, -481959, -481755, -481499, -481119, -477835, -471451, -465684, -464144, -461270, -458708, -458164, -457157, -454667, -454446, -453810, -452722, -450750, -444975, -440175, -436952, -433585, -431811, -431720, -425111, -423881, -421194, -417870, -413472, -409253, -406580, -404742, -398875, -396025, -395996, -392462, -390019, -389063, -388162, -387957, -384367, -384027, -383828, -382868, -382548, -381340, -381173, -376972, -373184, -370443, -369784, -369455, -367706, -362942, -361908, -360373, -356580, -344963, -344933, -344512, -344413, -340781, -335776, -335511, -332496, -332446, -332409, -332143, -326673, -326193, -324660, -322211, -321050, -318489, -317015, -316691, -312615, -309925, -305811, -303248, -302524, -301475, -299453, -298686, -291993, -287894, -284511, -278832, -274460, -269894, -265159, -264165, -263392, -261037, -258641, -255496, -255178, -254565, -252402, -250505, -246222, -244617, -239476, -237763, -235060, -233619, -231114, -228848, -228656, -228578, -228226, -226331, -223722, -221392, -220245, -214583, -208621, -208343, -205857, -204617, -204304, -204285, -200047, -198543, -196234, -195210, -192665, -191287, -190204, -187869, -180022, -175780, -169961, -165183, -163516, -162511, -159937, -159803, -157580, -155940, -154326, -153617, -151366, -150658, -149895, -143392, -142415, -141753, -140801, -140080, -138421, -137027, -136051, -135650, -132303, -131807, -130982, -130351, -126965, -124889, -120330, -115763, -115533, -115175, -114069, -113806, -105748, -104513, -103830, -103764, -103087, -102295, -98578, -97385, -93806, -92518, -90790, -89187, -88063, -86842, -86501, -85210, -82344, -80068, -76951, -72564, -71907, -68477, -67744, -65798, -65780, -62141, -61154, -58960, -58115, -55704, -48527, -47225, -44349, -44029, -35038, -34583, -34362, -33071, -30648, -27662, -24982, -24466, -24397, -22420, -22009, -20987, -18291, -15623, -14045, -12181, -8728, -6981, -5731, -2950, 1367, 1818, 2401, 2938, 4264, 4584, 11242, 12709, 14171, 18698, 19038, 19599, 25362, 27010, 27929, 28395, 32259, 32665, 33468, 39762, 40127, 41189, 48605, 50424, 50906, 53805, 54014, 54624, 55043, 55794, 56943, 57003, 58277, 58831, 59986, 62496, 63300, 63605, 63676, 66787, 72481, 74582, 81305, 85419, 86260, 88773, 89468, 89893, 91087, 93138, 98928, 99485, 101867, 103182, 103643, 108080, 110424, 112405, 115488, 118543, 119684, 120157, 121520, 123015, 123924, 124286, 125825, 127501, 128321, 128666, 129072, 129364, 130767, 135733, 136137, 136842, 137411, 140242, 141253, 143452, 145059, 145544, 146265, 146279, 150295, 150670, 156025, 156460, 157376, 158128, 161217, 161807, 163218, 164005, 164019, 165078, 167877, 173294, 174293, 175499, 180190, 192118, 202050, 203337, 203624, 203848, 204865, 205804, 206171, 208552, 209042, 213388, 219026, 219326, 220237, 220523, 220764, 221011, 222353, 223547, 224087, 225137, 226694, 226946, 229949, 234630, 235166, 237063, 240044, 241984, 245391, 251124, 255354, 255617, 264578, 268464, 268874, 273129, 276470, 276947, 281221, 281464, 282559, 282670, 283776, 287452, 296062, 296337, 297368, 299522, 300248, 300477, 301826, 302041, 303045, 307342, 310186, 310775, 315405, 315655, 316020, 317199, 320681, 322423, 324207, 325763, 325947, 327388, 328055, 330375, 331369, 336117, 337601, 337922, 338413, 339689, 344223, 345602, 347266, 349666, 354635, 357004, 359434, 364032, 365612, 366258, 368356, 371959, 374211, 376232, 381889, 383873, 384773, 387686, 387740, 388208, 389155, 393759, 394337, 394868, 395326, 395421, 397150, 404334, 404733, 407893, 408870, 413736, 415400, 423697, 424224, 424265, 425890, 427506, 427704, 431231, 431344, 432838, 432923, 436850, 438152, 438400, 445828, 447957, 448944, 452475, 454037, 454042, 461568, 465456, 467202, 467621, 468330, 470674, 476464, 477326, 477762, 480008, 485465, 486033, 491446, 498300, 501100, 501423, 504302, 505800, 506539, 506676, 508254, 508725, 510582, 515056, 517777, 520579, 521061, 524719, 529371, 534703, 539864, 541871, 544689, 544989, 548490, 551646, 552914, 552916, 554936, 555192, 557279, 557586, 557842, 558356, 558545, 559741, 561964, 565092, 566614, 568317, 571816, 572954, 577836, 578284, 578288, 582481, 585000, 587923, 594589, 595497, 596243, 596553, 600481, 601999, 605611, 605625, 605898, 606984, 610671, 611329, 614007, 615026, 616123, 616465, 616695, 619115, 620944, 621183, 621238, 622624, 623709, 626170, 631512, 633734, 633897, 642285, 643515, 644487, 645569, 648469, 649319, 651622, 652349, 652471, 652656, 653350, 654672, 657564, 658798, 659881, 660364, 668169, 673024, 674223, 674379, 676960, 678797, 684346, 684844, 685550, 685896, 687722, 689208, 691097, 696537, 701992, 707493, 710182, 714908, 717494, 724297, 727641, 728373, 729877, 731508, 734590, 735305, 735317, 739140, 746284, 752465, 753806, 758884, 760396, 762874, 764092, 765117, 765790, 766725, 768602, 776053, 778383, 779166, 780941, 781907, 785696, 790021, 792947, 794668, 796450, 800590, 804655, 805756, 808165, 813998, 814743, 815376, 815601, 816512, 816963, 817371, 821429, 828465, 830397, 830745, 832817, 834284, 835718, 838315, 838606, 839502, 840290, 840523, 845697, 847854, 848272, 849574, 853478, 860115, 863716, 865873, 866963, 867234, 867719, 868116, 868662, 870298, 874510, 874747, 875141, 875616, 875673, 876231, 876818, 877363, 877878, 884584, 889654, 892550, 892839, 894332, 894848, 895292, 903528, 909968, 918085, 918731, 923542, 925517, 925993, 927445, 930221, 932594, 934728, 934944, 944427, 944811, 950539, 951356, 951819, 952739, 954583, 957900, 957933, 958923, 964744, 965862, 965989, 966665, 971239, 972730, 974831, 975587, 975977, 977660, 978787, 983506, 988173, 989550, 990686, 991667, 992009, 994375, 995734, 997675, 999532]\\n[-999976, -998102, -996399, -990171, -987077, -985460, -977325, -973944, -973755, -970843, -970712, -969253, -968809, -967953, -964787, -964159, -963370, -962146, -961939, -961865, -961002, -959225, -955032, -951432, -950628, -950501, -949979, -949052, -948579, -948255, -948180, -947382, -946831, -943856, -943265, -941884, -939367, -934655, -933594, -933267, -933150, -931941, -931355, -929961, -928950, -926385, -925900, -922392, -921349, -917159, -915852, -913868, -913177, -912126, -911650, -906208, -904331, -900631, -900396, -900260, -898073, -894053, -892157, -888801, -885113, -884606, -876379, -876182, -874294, -873461, -873375, -866686, -864153, -861753, -859036, -858613, -855308, -853122, -849717, -849038, -847682, -847591, -847548, -847493, -843804, -842136, -841126, -840560, -838206, -837475, -832635, -831851, -829506, -821825, -821604, -821416, -819921, -818596, -814728, -812401, -802668, -802341, -801782, -798938, -797448, -795949, -795454, -788062, -785374, -779662, -776140, -773108, -772295, -771332, -768511, -768076, -757824, -754387, -753336, -752899, -752558, -748895, -748119, -745007, -744380, -740142, -740131, -736554, -725489, -724056, -719290, -719000, -715614, -715389, -712866, -710062, -708992, -708858, -708503, -708327, -708107, -703165, -703070, -698491, -698408, -696183, -691396, -689170, -683602, -681016, -681004, -679423, -678710, -678110, -675747, -672764, -672183, -671318, -669036, -666682, -663882, -658444, -652812, -652570, -651282, -650117, -647445, -647032, -645400, -643448, -643032, -641211, -640966, -639180, -638644, -631017, -629124, -628266, -627326, -626751, -622803, -621997, -617267, -614916, -611545, -610235, -608265, -606528, -605394, -604643, -602724, -601137, -600904, -599893, -595128, -595110, -595051, -589778, -588397, -585457, -583924, -582449, -577489, -574917, -573052, -570235, -570057, -568734, -567691, -566107, -566005, -565292, -565044, -562667, -561943, -557920, -557165, -556696, -551209, -550725, -548397, -546962, -545405, -544513, -542856, -539916, -539036, -539033, -538421, -537103, -537096, -535937, -531820, -531799, -531219, -529665, -524228, -520413, -517994, -513147, -511694, -503901, -498984, -498918, -498417, -495330, -494970, -494675, -490099, -488750, -488027, -486632, -483819, -483353, -480105, -479694, -475572, -471747, -471260, -470615, -469126, -469091, -467435, -465038, -464180, -457106, -456851, -456315, -454742, -454265, -448588, -447441, -441802, -441523, -440304, -439990, -437237, -435428, -433858, -430596, -430320, -419534, -417665, -417593, -415612, -415410, -413884, -413485, -412445, -412039, -409117, -404157, -403104, -402214, -399297, -398009, -394662, -394400, -387068, -382956, -377479, -376780, -376732, -373809, -369876, -369250, -366798, -364205, -362359, -361703, -360946, -356672, -356301, -354579, -350532, -344807, -343006, -341940, -340847, -334305, -333283, -331280, -329095, -322367, -321737, -320405, -319271, -318683, -318148, -312601, -312402, -311172, -308093, -303657, -301896, -301585, -300840, -299090, -290587, -290405, -288264, -286310, -285260, -283203, -281602, -280554, -277719, -277367, -273499, -273444, -266670, -266440, -266149, -263766, -263213, -258359, -258188, -257967, -256143, -254244, -254129, -253986, -252380, -250078, -248068, -241806, -234082, -231422, -226961, -226726, -224936, -220543, -218730, -217704, -216979, -212839, -212231, -209975, -209144, -208686, -206761, -204086, -203947, -203596, -200865, -198871, -196137, -193656, -192660, -191771, -190406, -190224, -189580, -183656, -182032, -181673, -179539, -178558, -178466, -171235, -169035, -168139, -163334, -162513, -159760, -153352, -151430, -149200, -148617, -147789, -146917, -143520, -141685, -140765, -138541, -137192, -136378, -136121, -135248, -126620, -126018, -124977, -124810, -124358, -123734, -123261, -120319, -117462, -116511, -113094, -111945, -107280, -107221, -103278, -99794, -99775, -97702, -96349, -93791, -93493, -92391, -89145, -88439, -85669, -81817, -78682, -71833, -68860, -68714, -66797, -66115, -65327, -63854, -63614, -62880, -61941, -58666, -55315, -54143, -54070, -50608, -50453, -50025, -49444, -47389, -46445, -42733, -38631, -28209, -23554, -22756, -21808, -21461, -19811, -17204, -15400, -15043, -14099, -10116, -4103, 4761, 7511, 8026, 8217, 8284, 9484, 10304, 10433, 15501, 23625, 24668, 26630, 27875, 29371, 32597, 33292, 33711, 33835, 38629, 41433, 42645, 45027, 48184, 49370, 49737, 51485, 53558, 56863, 57782, 58214, 58573, 59943, 60158, 61095, 64861, 68094, 69967, 72210, 84911, 88369, 89569, 91175, 93323, 94736, 95731, 96867, 101547, 101593, 105577, 105915, 108291, 109642, 110430, 111261, 114242, 115015, 115784, 116059, 117074, 119086, 124427, 124811, 125783, 129934, 130169, 132333, 132585, 133603, 134202, 137590, 138376, 140572, 143242, 143832, 149286, 153069, 154031, 156120, 156799, 156803, 159725, 161308, 162138, 168290, 171154, 171905, 173061, 174367, 175790, 177101, 177608, 179283, 179832, 181354, 182163, 183845, 184610, 187399, 190545, 194968, 196332, 196439, 196946, 197373, 197625, 199136, 200717, 204007, 209721, 211050, 212345, 214558, 215817, 217076, 219635, 220292, 222193, 224098, 229558, 234550, 240765, 243016, 244080, 248669, 254163, 255187, 256021, 258150, 264040, 269104, 272968, 273359, 273622, 275264, 277058, 278050, 278906, 281780, 282628, 282720, 283114, 283439, 284020, 288098, 290080, 293982, 295723, 300918, 302834, 303035, 306573, 310242, 311126, 311338, 312957, 313208, 318327, 319716, 320445, 322223, 326356, 326844, 333589, 341789, 343809, 344774, 345112, 347326, 347896, 348278, 348841, 351778, 352444, 354028, 354953, 356061, 357611, 359826, 362735, 362877, 370417, 377109, 380674, 382971, 383186, 383211, 383859, 386344, 386397, 389923, 391672, 394574, 396502, 396879, 396945, 399865, 401285, 406208, 406977, 412249, 413024, 419364, 419428, 424013, 424713, 426389, 429151, 430049, 432057, 433879, 433953, 437055, 437699, 438636, 438642, 440257, 440688, 441524, 441968, 442003, 444787, 444843, 447109, 450702, 450703, 451700, 453368, 453389, 453417, 453440, 454547, 461876, 465340, 465460, 468459, 470522, 473262, 475745, 481459, 483851, 484724, 485927, 486314, 487541, 488382, 491649, 492365, 492761, 497716, 497953, 499773, 500839, 503845, 504141, 506154, 508253, 508544, 509945, 511637, 514963, 516434, 516681, 516931, 529764, 530524, 536303, 536933, 539344, 542245, 542892, 543252, 545202, 552352, 552610, 554833, 555222, 555540, 556950, 556951, 562806, 563245, 564036, 565833, 567567, 567771, 568748, 569404, 571150, 571839, 573065, 573324, 573473, 574913, 578939, 586068, 587628, 588939, 589801, 590664, 591492, 599686, 602288, 604390, 610124, 614532, 617774, 626243, 628318, 629894, 634198, 634418, 634735, 640547, 641173, 645439, 645595, 646370, 649042, 649956, 651031, 651237, 655060, 656329, 656960, 657035, 657601, 659421, 660262, 662337, 662428, 663337, 664290, 665674, 666263, 666601, 667893, 671527, 673865, 674923, 675394, 679169, 680930, 683013, 685720, 686089, 686494, 690082, 690321, 690619, 691996, 695204, 698064, 699115, 705381, 709639, 712137, 712366, 713867, 713909, 714648, 714905, 716657, 718347, 719072, 719292, 719437, 721477, 722108, 722586, 726743, 730006, 732031, 732487, 734262, 734575, 736410, 738892, 739745, 742763, 745439, 750432, 752823, 753119, 754063, 754449, 754559, 756807, 759050, 762380, 763211, 765016, 766971, 767664, 768995, 769780, 770541, 770615, 772130, 773032, 774493, 775283, 776640, 777953, 779428, 780696, 788321, 789897, 795699, 801007, 801087, 801097, 804984, 807159, 807678, 808151, 812311, 812962, 813002, 814512, 814593, 816861, 819471, 819664, 820689, 823510, 824399, 824650, 825381, 826986, 826997, 828200, 831273, 833409, 833690, 835405, 842094, 842655, 844201, 844883, 848760, 850573, 851037, 852353, 853756, 854762, 855014, 857050, 857749, 858984, 860710, 862800, 863655, 866425, 866556, 868331, 868475, 869176, 869789, 870317, 881520, 883667, 885141, 885246, 885718, 886755, 887107, 887112, 889343, 895548, 898611, 899482, 902793, 906288, 908715, 909938, 912501, 914477, 915301, 916209, 916213, 920617, 921592, 928058, 930278, 931949, 931964, 932707, 935617, 938378, 939591, 940801, 943139, 943984, 945433, 945527, 949018, 949399, 949761, 952476, 960915, 961052, 961920, 962740, 963348, 964522, 965677, 966087, 967130, 969531, 971091, 974509, 975654, 978955, 980370, 985598, 992742, 993415, 994578, 997743, 999337]"
                    },
                    {
                        "username": "luanct",
                        "content": "O(m+n) approach is an easy problem when all of us know how to implement merge sort.\nBut when the description says that we should implement in O(log(m+n)) runtime complexity then here the binary search comes, no merge 2 array anymore. That's kinda hard question, but not too hard."
                    },
                    {
                        "username": "aitachii",
                        "content": "Use 4 pointers\n\nHonestly, you're better off learning the `O(log(m+n))` and  `O(log(min(m,n)))` solution from the Editorial or any other place but you can still try doing the intuitive `O(m+n)` solution."
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'m getting the correct answer in my IDLE, however, it is showing wrong here. 2.5 is the answer i got on my IDE and it was correct logic, it\\'s showing 2.0 here. Why so ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you cast your integers into double before dividing by 2.0?"
                    },
                    {
                        "username": "jkkjofaxiu",
                        "content": "The online python version might cause test case fails. In example, `sum([2, 3]) / 2` returns `2.5` in my local python interpreter (3.10), but it returns  `2` in the online interpreter. I have to add type convert before doing division `float(sum([2, 3])) / 2`. reference [pep-0238](https://peps.python.org/pep-0238/)"
                    },
                    {
                        "username": "Zefick",
                        "content": "Select \"Python 3\" language. \"Python\" is actually the Python 2.x and it has different division rules."
                    },
                    {
                        "username": "jingminzhou",
                        "content": "The binary search solution can be solved in O(log(MIN(m, n))) time frame, but it took me countless hours to debug my code for all corner cases. Meanwhile, a O(m+n) solution is much cleaner, more readable, more maintainable, and took way less time to get the code correct. Asking you to code such problems in a 20-45 interview session only shows how *incompetent* the interviewer is - he/she obviously weights more on \"clever\" tricks than better code."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "if an interviewer asks you this question and then asks for O(log (m+n)) solution... they do not want you to get the job"
                    },
                    {
                        "username": "piyush9242kumar",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            int n = nums1.size(), m = nums2.size();\\n    if( n > m)\\n    {\\n        swap(n, m);\\n        swap(nums1, nums2);\\n    }    \\n\\n    int s = 0, e = n;\\n    while(s <= e)\\n    {\\n        int i = (s+e)/2;\\n        int j = (m+n+1)/2 - i;\\n        \\n        if(i < n and nums2[j - 1] > nums1[i])\\n            s = i+1;\\n        else if(i > 0 and nums1[i-1] > nums2[j])\\n            e = i-1;\\n        else\\n        {\\n            int left = 0;\\n            if(i == 0)\\n                left = nums2[j-1];\\n            else if(j == 0)\\n                left = nums1[i-1];\\n            else\\n                left = max(nums1[i-1], nums2[j-1]);\\n            \\n            if((m+n) % 2 & 1ll)\\n                return left;\\n\\n            int right = 0;\\n            if(i == n)\\n                right = nums2[j];\\n            if(j == n)\\n                right = nums1[i];\\n            else\\n                right = min(nums1[i], nums2[j]);\\n\\n            return (right+left)/2.0;\\n        }\\n    }\\n        return 0;\\n    }\\n};\\nyour inline code...`\\n\\nwhy is this code not working in leetcode it is working fine when I run it on my pc"
                    },
                    {
                        "username": "ghOst-vedant",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> merged;\\n        int s1=nums1.size();\\n        int s2=nums2.size();\\n        int i=0,j=0;\\n        double median=0;\\n        int mid=0,total=s1+s2;\\n        while(i<s1 && j<s2){\\n            if(nums1[i]<nums2[j]){\\n                merged.push_back(nums1[i++]);\\n            }\\n            else if(nums2[j]<nums1[i]){\\n                merged.push_back(nums2[j++]);\\n            }\\n            else{\\n                merged.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        while(i<s1){\\n            merged.push_back(nums1[i++]);\\n        }\\n        while(j<s2){\\n            merged.push_back(nums2[j++]);\\n        }\\n        if((total)%2==1){\\n            median=(merged[total/2]);\\n        }\\n        else{\\n            mid=(total)/2;\\n            median=(merged[mid]+merged[mid+1])/2.0;\\n        }\\n        return median;\\n    }\\n};\\n\\nhelp please I\\'m notr getting expected output for:\\n[1,1,1,1,1,1,1,1,1,1,4,4]\\n[1,3,4,4,4,4,4,4,4,4,4]\\n it need to be 3 but mine is 4"
                    },
                    {
                        "username": "HiltonUniverse",
                        "content": "We need a new difficult level called: God mode. Learning this was one crazy journey."
                    }
                ]
            },
            {
                "id": 2053695,
                "content": [
                    {
                        "username": "justinleung0204",
                        "content": "try \\n[-994655, -993994, -991967, -991325, -990398, -988095, -985751, -979217, -978192, -978011, -977429, -976673, -975247, -974516, -972815, -972128, -969579, -968714, -966498, -965804, -965649, -965398, -964406, -959276, -957464, -957387, -955598, -955414, -954591, -954093, -954030, -954026, -953568, -951586, -949720, -948620, -948067, -947702, -944747, -939522, -939390, -938770, -936821, -935171, -934261, -932485, -930539, -927942, -927441, -927304, -925848, -924409, -922636, -921691, -921180, -920983, -920322, -916773, -916293, -914806, -914595, -913674, -911815, -911371, -910861, -909825, -909148, -907716, -907408, -906773, -905247, -904944, -904001, -902721, -898131, -894932, -894560, -894204, -890932, -890586, -890069, -888310, -885313, -882692, -881456, -880824, -878763, -878112, -876247, -875654, -870390, -867532, -867324, -867058, -866471, -865559, -861404, -861074, -858880, -858287, -857419, -852828, -851970, -850887, -850781, -847064, -845959, -844400, -843865, -842229, -841504, -838420, -837661, -832341, -830491, -825293, -825170, -824615, -820676, -820657, -812263, -811178, -809320, -807655, -806194, -804182, -800065, -798525, -797897, -797674, -796210, -794011, -793851, -792819, -792074, -790951, -785779, -783652, -780803, -780429, -777118, -775053, -772694, -771726, -770114, -769735, -769420, -767702, -767674, -767478, -767208, -766647, -766326, -766171, -762990, -762262, -760950, -759882, -758089, -754901, -753444, -752476, -749957, -749006, -748946, -744097, -744040, -743806, -742040, -739358, -738506, -737332, -736316, -733828, -732416, -732205, -730920, -729686, -729326, -729138, -728690, -728587, -725291, -721993, -721992, -720924, -719181, -718985, -717776, -714652, -708778, -706347, -703008, -701329, -698849, -697626, -697226, -697030, -694863, -687971, -687615, -687424, -685428, -684993, -682056, -667871, -666917, -666776, -665524, -658872, -658109, -656999, -655860, -654585, -654567, -651017, -649888, -647590, -646763, -645638, -638225, -637214, -636529, -633272, -633041, -628082, -628074, -625948, -625778, -622448, -622326, -621929, -620161, -617798, -616576, -611212, -610377, -609261, -608425, -606242, -603468, -603394, -601744, -595969, -594421, -594310, -592685, -590529, -589111, -584672, -583224, -582511, -580883, -580187, -578709, -577674, -571825, -568085, -566554, -561892, -560889, -560243, -558453, -558272, -557250, -556808, -555477, -553500, -549913, -549122, -546769, -544973, -544931, -543612, -542175, -538884, -536964, -533928, -531674, -530917, -530560, -528123, -527672, -525811, -524895, -521574, -516255, -513441, -512365, -511052, -510908, -510079, -504485, -502724, -502713, -500985, -496529, -493674, -493237, -492219, -489936, -487103, -484436, -482849, -482574, -482438, -482307, -481959, -481755, -481499, -481119, -477835, -471451, -465684, -464144, -461270, -458708, -458164, -457157, -454667, -454446, -453810, -452722, -450750, -444975, -440175, -436952, -433585, -431811, -431720, -425111, -423881, -421194, -417870, -413472, -409253, -406580, -404742, -398875, -396025, -395996, -392462, -390019, -389063, -388162, -387957, -384367, -384027, -383828, -382868, -382548, -381340, -381173, -376972, -373184, -370443, -369784, -369455, -367706, -362942, -361908, -360373, -356580, -344963, -344933, -344512, -344413, -340781, -335776, -335511, -332496, -332446, -332409, -332143, -326673, -326193, -324660, -322211, -321050, -318489, -317015, -316691, -312615, -309925, -305811, -303248, -302524, -301475, -299453, -298686, -291993, -287894, -284511, -278832, -274460, -269894, -265159, -264165, -263392, -261037, -258641, -255496, -255178, -254565, -252402, -250505, -246222, -244617, -239476, -237763, -235060, -233619, -231114, -228848, -228656, -228578, -228226, -226331, -223722, -221392, -220245, -214583, -208621, -208343, -205857, -204617, -204304, -204285, -200047, -198543, -196234, -195210, -192665, -191287, -190204, -187869, -180022, -175780, -169961, -165183, -163516, -162511, -159937, -159803, -157580, -155940, -154326, -153617, -151366, -150658, -149895, -143392, -142415, -141753, -140801, -140080, -138421, -137027, -136051, -135650, -132303, -131807, -130982, -130351, -126965, -124889, -120330, -115763, -115533, -115175, -114069, -113806, -105748, -104513, -103830, -103764, -103087, -102295, -98578, -97385, -93806, -92518, -90790, -89187, -88063, -86842, -86501, -85210, -82344, -80068, -76951, -72564, -71907, -68477, -67744, -65798, -65780, -62141, -61154, -58960, -58115, -55704, -48527, -47225, -44349, -44029, -35038, -34583, -34362, -33071, -30648, -27662, -24982, -24466, -24397, -22420, -22009, -20987, -18291, -15623, -14045, -12181, -8728, -6981, -5731, -2950, 1367, 1818, 2401, 2938, 4264, 4584, 11242, 12709, 14171, 18698, 19038, 19599, 25362, 27010, 27929, 28395, 32259, 32665, 33468, 39762, 40127, 41189, 48605, 50424, 50906, 53805, 54014, 54624, 55043, 55794, 56943, 57003, 58277, 58831, 59986, 62496, 63300, 63605, 63676, 66787, 72481, 74582, 81305, 85419, 86260, 88773, 89468, 89893, 91087, 93138, 98928, 99485, 101867, 103182, 103643, 108080, 110424, 112405, 115488, 118543, 119684, 120157, 121520, 123015, 123924, 124286, 125825, 127501, 128321, 128666, 129072, 129364, 130767, 135733, 136137, 136842, 137411, 140242, 141253, 143452, 145059, 145544, 146265, 146279, 150295, 150670, 156025, 156460, 157376, 158128, 161217, 161807, 163218, 164005, 164019, 165078, 167877, 173294, 174293, 175499, 180190, 192118, 202050, 203337, 203624, 203848, 204865, 205804, 206171, 208552, 209042, 213388, 219026, 219326, 220237, 220523, 220764, 221011, 222353, 223547, 224087, 225137, 226694, 226946, 229949, 234630, 235166, 237063, 240044, 241984, 245391, 251124, 255354, 255617, 264578, 268464, 268874, 273129, 276470, 276947, 281221, 281464, 282559, 282670, 283776, 287452, 296062, 296337, 297368, 299522, 300248, 300477, 301826, 302041, 303045, 307342, 310186, 310775, 315405, 315655, 316020, 317199, 320681, 322423, 324207, 325763, 325947, 327388, 328055, 330375, 331369, 336117, 337601, 337922, 338413, 339689, 344223, 345602, 347266, 349666, 354635, 357004, 359434, 364032, 365612, 366258, 368356, 371959, 374211, 376232, 381889, 383873, 384773, 387686, 387740, 388208, 389155, 393759, 394337, 394868, 395326, 395421, 397150, 404334, 404733, 407893, 408870, 413736, 415400, 423697, 424224, 424265, 425890, 427506, 427704, 431231, 431344, 432838, 432923, 436850, 438152, 438400, 445828, 447957, 448944, 452475, 454037, 454042, 461568, 465456, 467202, 467621, 468330, 470674, 476464, 477326, 477762, 480008, 485465, 486033, 491446, 498300, 501100, 501423, 504302, 505800, 506539, 506676, 508254, 508725, 510582, 515056, 517777, 520579, 521061, 524719, 529371, 534703, 539864, 541871, 544689, 544989, 548490, 551646, 552914, 552916, 554936, 555192, 557279, 557586, 557842, 558356, 558545, 559741, 561964, 565092, 566614, 568317, 571816, 572954, 577836, 578284, 578288, 582481, 585000, 587923, 594589, 595497, 596243, 596553, 600481, 601999, 605611, 605625, 605898, 606984, 610671, 611329, 614007, 615026, 616123, 616465, 616695, 619115, 620944, 621183, 621238, 622624, 623709, 626170, 631512, 633734, 633897, 642285, 643515, 644487, 645569, 648469, 649319, 651622, 652349, 652471, 652656, 653350, 654672, 657564, 658798, 659881, 660364, 668169, 673024, 674223, 674379, 676960, 678797, 684346, 684844, 685550, 685896, 687722, 689208, 691097, 696537, 701992, 707493, 710182, 714908, 717494, 724297, 727641, 728373, 729877, 731508, 734590, 735305, 735317, 739140, 746284, 752465, 753806, 758884, 760396, 762874, 764092, 765117, 765790, 766725, 768602, 776053, 778383, 779166, 780941, 781907, 785696, 790021, 792947, 794668, 796450, 800590, 804655, 805756, 808165, 813998, 814743, 815376, 815601, 816512, 816963, 817371, 821429, 828465, 830397, 830745, 832817, 834284, 835718, 838315, 838606, 839502, 840290, 840523, 845697, 847854, 848272, 849574, 853478, 860115, 863716, 865873, 866963, 867234, 867719, 868116, 868662, 870298, 874510, 874747, 875141, 875616, 875673, 876231, 876818, 877363, 877878, 884584, 889654, 892550, 892839, 894332, 894848, 895292, 903528, 909968, 918085, 918731, 923542, 925517, 925993, 927445, 930221, 932594, 934728, 934944, 944427, 944811, 950539, 951356, 951819, 952739, 954583, 957900, 957933, 958923, 964744, 965862, 965989, 966665, 971239, 972730, 974831, 975587, 975977, 977660, 978787, 983506, 988173, 989550, 990686, 991667, 992009, 994375, 995734, 997675, 999532]\\n[-999976, -998102, -996399, -990171, -987077, -985460, -977325, -973944, -973755, -970843, -970712, -969253, -968809, -967953, -964787, -964159, -963370, -962146, -961939, -961865, -961002, -959225, -955032, -951432, -950628, -950501, -949979, -949052, -948579, -948255, -948180, -947382, -946831, -943856, -943265, -941884, -939367, -934655, -933594, -933267, -933150, -931941, -931355, -929961, -928950, -926385, -925900, -922392, -921349, -917159, -915852, -913868, -913177, -912126, -911650, -906208, -904331, -900631, -900396, -900260, -898073, -894053, -892157, -888801, -885113, -884606, -876379, -876182, -874294, -873461, -873375, -866686, -864153, -861753, -859036, -858613, -855308, -853122, -849717, -849038, -847682, -847591, -847548, -847493, -843804, -842136, -841126, -840560, -838206, -837475, -832635, -831851, -829506, -821825, -821604, -821416, -819921, -818596, -814728, -812401, -802668, -802341, -801782, -798938, -797448, -795949, -795454, -788062, -785374, -779662, -776140, -773108, -772295, -771332, -768511, -768076, -757824, -754387, -753336, -752899, -752558, -748895, -748119, -745007, -744380, -740142, -740131, -736554, -725489, -724056, -719290, -719000, -715614, -715389, -712866, -710062, -708992, -708858, -708503, -708327, -708107, -703165, -703070, -698491, -698408, -696183, -691396, -689170, -683602, -681016, -681004, -679423, -678710, -678110, -675747, -672764, -672183, -671318, -669036, -666682, -663882, -658444, -652812, -652570, -651282, -650117, -647445, -647032, -645400, -643448, -643032, -641211, -640966, -639180, -638644, -631017, -629124, -628266, -627326, -626751, -622803, -621997, -617267, -614916, -611545, -610235, -608265, -606528, -605394, -604643, -602724, -601137, -600904, -599893, -595128, -595110, -595051, -589778, -588397, -585457, -583924, -582449, -577489, -574917, -573052, -570235, -570057, -568734, -567691, -566107, -566005, -565292, -565044, -562667, -561943, -557920, -557165, -556696, -551209, -550725, -548397, -546962, -545405, -544513, -542856, -539916, -539036, -539033, -538421, -537103, -537096, -535937, -531820, -531799, -531219, -529665, -524228, -520413, -517994, -513147, -511694, -503901, -498984, -498918, -498417, -495330, -494970, -494675, -490099, -488750, -488027, -486632, -483819, -483353, -480105, -479694, -475572, -471747, -471260, -470615, -469126, -469091, -467435, -465038, -464180, -457106, -456851, -456315, -454742, -454265, -448588, -447441, -441802, -441523, -440304, -439990, -437237, -435428, -433858, -430596, -430320, -419534, -417665, -417593, -415612, -415410, -413884, -413485, -412445, -412039, -409117, -404157, -403104, -402214, -399297, -398009, -394662, -394400, -387068, -382956, -377479, -376780, -376732, -373809, -369876, -369250, -366798, -364205, -362359, -361703, -360946, -356672, -356301, -354579, -350532, -344807, -343006, -341940, -340847, -334305, -333283, -331280, -329095, -322367, -321737, -320405, -319271, -318683, -318148, -312601, -312402, -311172, -308093, -303657, -301896, -301585, -300840, -299090, -290587, -290405, -288264, -286310, -285260, -283203, -281602, -280554, -277719, -277367, -273499, -273444, -266670, -266440, -266149, -263766, -263213, -258359, -258188, -257967, -256143, -254244, -254129, -253986, -252380, -250078, -248068, -241806, -234082, -231422, -226961, -226726, -224936, -220543, -218730, -217704, -216979, -212839, -212231, -209975, -209144, -208686, -206761, -204086, -203947, -203596, -200865, -198871, -196137, -193656, -192660, -191771, -190406, -190224, -189580, -183656, -182032, -181673, -179539, -178558, -178466, -171235, -169035, -168139, -163334, -162513, -159760, -153352, -151430, -149200, -148617, -147789, -146917, -143520, -141685, -140765, -138541, -137192, -136378, -136121, -135248, -126620, -126018, -124977, -124810, -124358, -123734, -123261, -120319, -117462, -116511, -113094, -111945, -107280, -107221, -103278, -99794, -99775, -97702, -96349, -93791, -93493, -92391, -89145, -88439, -85669, -81817, -78682, -71833, -68860, -68714, -66797, -66115, -65327, -63854, -63614, -62880, -61941, -58666, -55315, -54143, -54070, -50608, -50453, -50025, -49444, -47389, -46445, -42733, -38631, -28209, -23554, -22756, -21808, -21461, -19811, -17204, -15400, -15043, -14099, -10116, -4103, 4761, 7511, 8026, 8217, 8284, 9484, 10304, 10433, 15501, 23625, 24668, 26630, 27875, 29371, 32597, 33292, 33711, 33835, 38629, 41433, 42645, 45027, 48184, 49370, 49737, 51485, 53558, 56863, 57782, 58214, 58573, 59943, 60158, 61095, 64861, 68094, 69967, 72210, 84911, 88369, 89569, 91175, 93323, 94736, 95731, 96867, 101547, 101593, 105577, 105915, 108291, 109642, 110430, 111261, 114242, 115015, 115784, 116059, 117074, 119086, 124427, 124811, 125783, 129934, 130169, 132333, 132585, 133603, 134202, 137590, 138376, 140572, 143242, 143832, 149286, 153069, 154031, 156120, 156799, 156803, 159725, 161308, 162138, 168290, 171154, 171905, 173061, 174367, 175790, 177101, 177608, 179283, 179832, 181354, 182163, 183845, 184610, 187399, 190545, 194968, 196332, 196439, 196946, 197373, 197625, 199136, 200717, 204007, 209721, 211050, 212345, 214558, 215817, 217076, 219635, 220292, 222193, 224098, 229558, 234550, 240765, 243016, 244080, 248669, 254163, 255187, 256021, 258150, 264040, 269104, 272968, 273359, 273622, 275264, 277058, 278050, 278906, 281780, 282628, 282720, 283114, 283439, 284020, 288098, 290080, 293982, 295723, 300918, 302834, 303035, 306573, 310242, 311126, 311338, 312957, 313208, 318327, 319716, 320445, 322223, 326356, 326844, 333589, 341789, 343809, 344774, 345112, 347326, 347896, 348278, 348841, 351778, 352444, 354028, 354953, 356061, 357611, 359826, 362735, 362877, 370417, 377109, 380674, 382971, 383186, 383211, 383859, 386344, 386397, 389923, 391672, 394574, 396502, 396879, 396945, 399865, 401285, 406208, 406977, 412249, 413024, 419364, 419428, 424013, 424713, 426389, 429151, 430049, 432057, 433879, 433953, 437055, 437699, 438636, 438642, 440257, 440688, 441524, 441968, 442003, 444787, 444843, 447109, 450702, 450703, 451700, 453368, 453389, 453417, 453440, 454547, 461876, 465340, 465460, 468459, 470522, 473262, 475745, 481459, 483851, 484724, 485927, 486314, 487541, 488382, 491649, 492365, 492761, 497716, 497953, 499773, 500839, 503845, 504141, 506154, 508253, 508544, 509945, 511637, 514963, 516434, 516681, 516931, 529764, 530524, 536303, 536933, 539344, 542245, 542892, 543252, 545202, 552352, 552610, 554833, 555222, 555540, 556950, 556951, 562806, 563245, 564036, 565833, 567567, 567771, 568748, 569404, 571150, 571839, 573065, 573324, 573473, 574913, 578939, 586068, 587628, 588939, 589801, 590664, 591492, 599686, 602288, 604390, 610124, 614532, 617774, 626243, 628318, 629894, 634198, 634418, 634735, 640547, 641173, 645439, 645595, 646370, 649042, 649956, 651031, 651237, 655060, 656329, 656960, 657035, 657601, 659421, 660262, 662337, 662428, 663337, 664290, 665674, 666263, 666601, 667893, 671527, 673865, 674923, 675394, 679169, 680930, 683013, 685720, 686089, 686494, 690082, 690321, 690619, 691996, 695204, 698064, 699115, 705381, 709639, 712137, 712366, 713867, 713909, 714648, 714905, 716657, 718347, 719072, 719292, 719437, 721477, 722108, 722586, 726743, 730006, 732031, 732487, 734262, 734575, 736410, 738892, 739745, 742763, 745439, 750432, 752823, 753119, 754063, 754449, 754559, 756807, 759050, 762380, 763211, 765016, 766971, 767664, 768995, 769780, 770541, 770615, 772130, 773032, 774493, 775283, 776640, 777953, 779428, 780696, 788321, 789897, 795699, 801007, 801087, 801097, 804984, 807159, 807678, 808151, 812311, 812962, 813002, 814512, 814593, 816861, 819471, 819664, 820689, 823510, 824399, 824650, 825381, 826986, 826997, 828200, 831273, 833409, 833690, 835405, 842094, 842655, 844201, 844883, 848760, 850573, 851037, 852353, 853756, 854762, 855014, 857050, 857749, 858984, 860710, 862800, 863655, 866425, 866556, 868331, 868475, 869176, 869789, 870317, 881520, 883667, 885141, 885246, 885718, 886755, 887107, 887112, 889343, 895548, 898611, 899482, 902793, 906288, 908715, 909938, 912501, 914477, 915301, 916209, 916213, 920617, 921592, 928058, 930278, 931949, 931964, 932707, 935617, 938378, 939591, 940801, 943139, 943984, 945433, 945527, 949018, 949399, 949761, 952476, 960915, 961052, 961920, 962740, 963348, 964522, 965677, 966087, 967130, 969531, 971091, 974509, 975654, 978955, 980370, 985598, 992742, 993415, 994578, 997743, 999337]"
                    },
                    {
                        "username": "luanct",
                        "content": "O(m+n) approach is an easy problem when all of us know how to implement merge sort.\nBut when the description says that we should implement in O(log(m+n)) runtime complexity then here the binary search comes, no merge 2 array anymore. That's kinda hard question, but not too hard."
                    },
                    {
                        "username": "aitachii",
                        "content": "Use 4 pointers\n\nHonestly, you're better off learning the `O(log(m+n))` and  `O(log(min(m,n)))` solution from the Editorial or any other place but you can still try doing the intuitive `O(m+n)` solution."
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'m getting the correct answer in my IDLE, however, it is showing wrong here. 2.5 is the answer i got on my IDE and it was correct logic, it\\'s showing 2.0 here. Why so ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you cast your integers into double before dividing by 2.0?"
                    },
                    {
                        "username": "jkkjofaxiu",
                        "content": "The online python version might cause test case fails. In example, `sum([2, 3]) / 2` returns `2.5` in my local python interpreter (3.10), but it returns  `2` in the online interpreter. I have to add type convert before doing division `float(sum([2, 3])) / 2`. reference [pep-0238](https://peps.python.org/pep-0238/)"
                    },
                    {
                        "username": "Zefick",
                        "content": "Select \"Python 3\" language. \"Python\" is actually the Python 2.x and it has different division rules."
                    },
                    {
                        "username": "jingminzhou",
                        "content": "The binary search solution can be solved in O(log(MIN(m, n))) time frame, but it took me countless hours to debug my code for all corner cases. Meanwhile, a O(m+n) solution is much cleaner, more readable, more maintainable, and took way less time to get the code correct. Asking you to code such problems in a 20-45 interview session only shows how *incompetent* the interviewer is - he/she obviously weights more on \"clever\" tricks than better code."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "if an interviewer asks you this question and then asks for O(log (m+n)) solution... they do not want you to get the job"
                    },
                    {
                        "username": "piyush9242kumar",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            int n = nums1.size(), m = nums2.size();\\n    if( n > m)\\n    {\\n        swap(n, m);\\n        swap(nums1, nums2);\\n    }    \\n\\n    int s = 0, e = n;\\n    while(s <= e)\\n    {\\n        int i = (s+e)/2;\\n        int j = (m+n+1)/2 - i;\\n        \\n        if(i < n and nums2[j - 1] > nums1[i])\\n            s = i+1;\\n        else if(i > 0 and nums1[i-1] > nums2[j])\\n            e = i-1;\\n        else\\n        {\\n            int left = 0;\\n            if(i == 0)\\n                left = nums2[j-1];\\n            else if(j == 0)\\n                left = nums1[i-1];\\n            else\\n                left = max(nums1[i-1], nums2[j-1]);\\n            \\n            if((m+n) % 2 & 1ll)\\n                return left;\\n\\n            int right = 0;\\n            if(i == n)\\n                right = nums2[j];\\n            if(j == n)\\n                right = nums1[i];\\n            else\\n                right = min(nums1[i], nums2[j]);\\n\\n            return (right+left)/2.0;\\n        }\\n    }\\n        return 0;\\n    }\\n};\\nyour inline code...`\\n\\nwhy is this code not working in leetcode it is working fine when I run it on my pc"
                    },
                    {
                        "username": "ghOst-vedant",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> merged;\\n        int s1=nums1.size();\\n        int s2=nums2.size();\\n        int i=0,j=0;\\n        double median=0;\\n        int mid=0,total=s1+s2;\\n        while(i<s1 && j<s2){\\n            if(nums1[i]<nums2[j]){\\n                merged.push_back(nums1[i++]);\\n            }\\n            else if(nums2[j]<nums1[i]){\\n                merged.push_back(nums2[j++]);\\n            }\\n            else{\\n                merged.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        while(i<s1){\\n            merged.push_back(nums1[i++]);\\n        }\\n        while(j<s2){\\n            merged.push_back(nums2[j++]);\\n        }\\n        if((total)%2==1){\\n            median=(merged[total/2]);\\n        }\\n        else{\\n            mid=(total)/2;\\n            median=(merged[mid]+merged[mid+1])/2.0;\\n        }\\n        return median;\\n    }\\n};\\n\\nhelp please I\\'m notr getting expected output for:\\n[1,1,1,1,1,1,1,1,1,1,4,4]\\n[1,3,4,4,4,4,4,4,4,4,4]\\n it need to be 3 but mine is 4"
                    },
                    {
                        "username": "HiltonUniverse",
                        "content": "We need a new difficult level called: God mode. Learning this was one crazy journey."
                    }
                ]
            },
            {
                "id": 2050788,
                "content": [
                    {
                        "username": "justinleung0204",
                        "content": "try \\n[-994655, -993994, -991967, -991325, -990398, -988095, -985751, -979217, -978192, -978011, -977429, -976673, -975247, -974516, -972815, -972128, -969579, -968714, -966498, -965804, -965649, -965398, -964406, -959276, -957464, -957387, -955598, -955414, -954591, -954093, -954030, -954026, -953568, -951586, -949720, -948620, -948067, -947702, -944747, -939522, -939390, -938770, -936821, -935171, -934261, -932485, -930539, -927942, -927441, -927304, -925848, -924409, -922636, -921691, -921180, -920983, -920322, -916773, -916293, -914806, -914595, -913674, -911815, -911371, -910861, -909825, -909148, -907716, -907408, -906773, -905247, -904944, -904001, -902721, -898131, -894932, -894560, -894204, -890932, -890586, -890069, -888310, -885313, -882692, -881456, -880824, -878763, -878112, -876247, -875654, -870390, -867532, -867324, -867058, -866471, -865559, -861404, -861074, -858880, -858287, -857419, -852828, -851970, -850887, -850781, -847064, -845959, -844400, -843865, -842229, -841504, -838420, -837661, -832341, -830491, -825293, -825170, -824615, -820676, -820657, -812263, -811178, -809320, -807655, -806194, -804182, -800065, -798525, -797897, -797674, -796210, -794011, -793851, -792819, -792074, -790951, -785779, -783652, -780803, -780429, -777118, -775053, -772694, -771726, -770114, -769735, -769420, -767702, -767674, -767478, -767208, -766647, -766326, -766171, -762990, -762262, -760950, -759882, -758089, -754901, -753444, -752476, -749957, -749006, -748946, -744097, -744040, -743806, -742040, -739358, -738506, -737332, -736316, -733828, -732416, -732205, -730920, -729686, -729326, -729138, -728690, -728587, -725291, -721993, -721992, -720924, -719181, -718985, -717776, -714652, -708778, -706347, -703008, -701329, -698849, -697626, -697226, -697030, -694863, -687971, -687615, -687424, -685428, -684993, -682056, -667871, -666917, -666776, -665524, -658872, -658109, -656999, -655860, -654585, -654567, -651017, -649888, -647590, -646763, -645638, -638225, -637214, -636529, -633272, -633041, -628082, -628074, -625948, -625778, -622448, -622326, -621929, -620161, -617798, -616576, -611212, -610377, -609261, -608425, -606242, -603468, -603394, -601744, -595969, -594421, -594310, -592685, -590529, -589111, -584672, -583224, -582511, -580883, -580187, -578709, -577674, -571825, -568085, -566554, -561892, -560889, -560243, -558453, -558272, -557250, -556808, -555477, -553500, -549913, -549122, -546769, -544973, -544931, -543612, -542175, -538884, -536964, -533928, -531674, -530917, -530560, -528123, -527672, -525811, -524895, -521574, -516255, -513441, -512365, -511052, -510908, -510079, -504485, -502724, -502713, -500985, -496529, -493674, -493237, -492219, -489936, -487103, -484436, -482849, -482574, -482438, -482307, -481959, -481755, -481499, -481119, -477835, -471451, -465684, -464144, -461270, -458708, -458164, -457157, -454667, -454446, -453810, -452722, -450750, -444975, -440175, -436952, -433585, -431811, -431720, -425111, -423881, -421194, -417870, -413472, -409253, -406580, -404742, -398875, -396025, -395996, -392462, -390019, -389063, -388162, -387957, -384367, -384027, -383828, -382868, -382548, -381340, -381173, -376972, -373184, -370443, -369784, -369455, -367706, -362942, -361908, -360373, -356580, -344963, -344933, -344512, -344413, -340781, -335776, -335511, -332496, -332446, -332409, -332143, -326673, -326193, -324660, -322211, -321050, -318489, -317015, -316691, -312615, -309925, -305811, -303248, -302524, -301475, -299453, -298686, -291993, -287894, -284511, -278832, -274460, -269894, -265159, -264165, -263392, -261037, -258641, -255496, -255178, -254565, -252402, -250505, -246222, -244617, -239476, -237763, -235060, -233619, -231114, -228848, -228656, -228578, -228226, -226331, -223722, -221392, -220245, -214583, -208621, -208343, -205857, -204617, -204304, -204285, -200047, -198543, -196234, -195210, -192665, -191287, -190204, -187869, -180022, -175780, -169961, -165183, -163516, -162511, -159937, -159803, -157580, -155940, -154326, -153617, -151366, -150658, -149895, -143392, -142415, -141753, -140801, -140080, -138421, -137027, -136051, -135650, -132303, -131807, -130982, -130351, -126965, -124889, -120330, -115763, -115533, -115175, -114069, -113806, -105748, -104513, -103830, -103764, -103087, -102295, -98578, -97385, -93806, -92518, -90790, -89187, -88063, -86842, -86501, -85210, -82344, -80068, -76951, -72564, -71907, -68477, -67744, -65798, -65780, -62141, -61154, -58960, -58115, -55704, -48527, -47225, -44349, -44029, -35038, -34583, -34362, -33071, -30648, -27662, -24982, -24466, -24397, -22420, -22009, -20987, -18291, -15623, -14045, -12181, -8728, -6981, -5731, -2950, 1367, 1818, 2401, 2938, 4264, 4584, 11242, 12709, 14171, 18698, 19038, 19599, 25362, 27010, 27929, 28395, 32259, 32665, 33468, 39762, 40127, 41189, 48605, 50424, 50906, 53805, 54014, 54624, 55043, 55794, 56943, 57003, 58277, 58831, 59986, 62496, 63300, 63605, 63676, 66787, 72481, 74582, 81305, 85419, 86260, 88773, 89468, 89893, 91087, 93138, 98928, 99485, 101867, 103182, 103643, 108080, 110424, 112405, 115488, 118543, 119684, 120157, 121520, 123015, 123924, 124286, 125825, 127501, 128321, 128666, 129072, 129364, 130767, 135733, 136137, 136842, 137411, 140242, 141253, 143452, 145059, 145544, 146265, 146279, 150295, 150670, 156025, 156460, 157376, 158128, 161217, 161807, 163218, 164005, 164019, 165078, 167877, 173294, 174293, 175499, 180190, 192118, 202050, 203337, 203624, 203848, 204865, 205804, 206171, 208552, 209042, 213388, 219026, 219326, 220237, 220523, 220764, 221011, 222353, 223547, 224087, 225137, 226694, 226946, 229949, 234630, 235166, 237063, 240044, 241984, 245391, 251124, 255354, 255617, 264578, 268464, 268874, 273129, 276470, 276947, 281221, 281464, 282559, 282670, 283776, 287452, 296062, 296337, 297368, 299522, 300248, 300477, 301826, 302041, 303045, 307342, 310186, 310775, 315405, 315655, 316020, 317199, 320681, 322423, 324207, 325763, 325947, 327388, 328055, 330375, 331369, 336117, 337601, 337922, 338413, 339689, 344223, 345602, 347266, 349666, 354635, 357004, 359434, 364032, 365612, 366258, 368356, 371959, 374211, 376232, 381889, 383873, 384773, 387686, 387740, 388208, 389155, 393759, 394337, 394868, 395326, 395421, 397150, 404334, 404733, 407893, 408870, 413736, 415400, 423697, 424224, 424265, 425890, 427506, 427704, 431231, 431344, 432838, 432923, 436850, 438152, 438400, 445828, 447957, 448944, 452475, 454037, 454042, 461568, 465456, 467202, 467621, 468330, 470674, 476464, 477326, 477762, 480008, 485465, 486033, 491446, 498300, 501100, 501423, 504302, 505800, 506539, 506676, 508254, 508725, 510582, 515056, 517777, 520579, 521061, 524719, 529371, 534703, 539864, 541871, 544689, 544989, 548490, 551646, 552914, 552916, 554936, 555192, 557279, 557586, 557842, 558356, 558545, 559741, 561964, 565092, 566614, 568317, 571816, 572954, 577836, 578284, 578288, 582481, 585000, 587923, 594589, 595497, 596243, 596553, 600481, 601999, 605611, 605625, 605898, 606984, 610671, 611329, 614007, 615026, 616123, 616465, 616695, 619115, 620944, 621183, 621238, 622624, 623709, 626170, 631512, 633734, 633897, 642285, 643515, 644487, 645569, 648469, 649319, 651622, 652349, 652471, 652656, 653350, 654672, 657564, 658798, 659881, 660364, 668169, 673024, 674223, 674379, 676960, 678797, 684346, 684844, 685550, 685896, 687722, 689208, 691097, 696537, 701992, 707493, 710182, 714908, 717494, 724297, 727641, 728373, 729877, 731508, 734590, 735305, 735317, 739140, 746284, 752465, 753806, 758884, 760396, 762874, 764092, 765117, 765790, 766725, 768602, 776053, 778383, 779166, 780941, 781907, 785696, 790021, 792947, 794668, 796450, 800590, 804655, 805756, 808165, 813998, 814743, 815376, 815601, 816512, 816963, 817371, 821429, 828465, 830397, 830745, 832817, 834284, 835718, 838315, 838606, 839502, 840290, 840523, 845697, 847854, 848272, 849574, 853478, 860115, 863716, 865873, 866963, 867234, 867719, 868116, 868662, 870298, 874510, 874747, 875141, 875616, 875673, 876231, 876818, 877363, 877878, 884584, 889654, 892550, 892839, 894332, 894848, 895292, 903528, 909968, 918085, 918731, 923542, 925517, 925993, 927445, 930221, 932594, 934728, 934944, 944427, 944811, 950539, 951356, 951819, 952739, 954583, 957900, 957933, 958923, 964744, 965862, 965989, 966665, 971239, 972730, 974831, 975587, 975977, 977660, 978787, 983506, 988173, 989550, 990686, 991667, 992009, 994375, 995734, 997675, 999532]\\n[-999976, -998102, -996399, -990171, -987077, -985460, -977325, -973944, -973755, -970843, -970712, -969253, -968809, -967953, -964787, -964159, -963370, -962146, -961939, -961865, -961002, -959225, -955032, -951432, -950628, -950501, -949979, -949052, -948579, -948255, -948180, -947382, -946831, -943856, -943265, -941884, -939367, -934655, -933594, -933267, -933150, -931941, -931355, -929961, -928950, -926385, -925900, -922392, -921349, -917159, -915852, -913868, -913177, -912126, -911650, -906208, -904331, -900631, -900396, -900260, -898073, -894053, -892157, -888801, -885113, -884606, -876379, -876182, -874294, -873461, -873375, -866686, -864153, -861753, -859036, -858613, -855308, -853122, -849717, -849038, -847682, -847591, -847548, -847493, -843804, -842136, -841126, -840560, -838206, -837475, -832635, -831851, -829506, -821825, -821604, -821416, -819921, -818596, -814728, -812401, -802668, -802341, -801782, -798938, -797448, -795949, -795454, -788062, -785374, -779662, -776140, -773108, -772295, -771332, -768511, -768076, -757824, -754387, -753336, -752899, -752558, -748895, -748119, -745007, -744380, -740142, -740131, -736554, -725489, -724056, -719290, -719000, -715614, -715389, -712866, -710062, -708992, -708858, -708503, -708327, -708107, -703165, -703070, -698491, -698408, -696183, -691396, -689170, -683602, -681016, -681004, -679423, -678710, -678110, -675747, -672764, -672183, -671318, -669036, -666682, -663882, -658444, -652812, -652570, -651282, -650117, -647445, -647032, -645400, -643448, -643032, -641211, -640966, -639180, -638644, -631017, -629124, -628266, -627326, -626751, -622803, -621997, -617267, -614916, -611545, -610235, -608265, -606528, -605394, -604643, -602724, -601137, -600904, -599893, -595128, -595110, -595051, -589778, -588397, -585457, -583924, -582449, -577489, -574917, -573052, -570235, -570057, -568734, -567691, -566107, -566005, -565292, -565044, -562667, -561943, -557920, -557165, -556696, -551209, -550725, -548397, -546962, -545405, -544513, -542856, -539916, -539036, -539033, -538421, -537103, -537096, -535937, -531820, -531799, -531219, -529665, -524228, -520413, -517994, -513147, -511694, -503901, -498984, -498918, -498417, -495330, -494970, -494675, -490099, -488750, -488027, -486632, -483819, -483353, -480105, -479694, -475572, -471747, -471260, -470615, -469126, -469091, -467435, -465038, -464180, -457106, -456851, -456315, -454742, -454265, -448588, -447441, -441802, -441523, -440304, -439990, -437237, -435428, -433858, -430596, -430320, -419534, -417665, -417593, -415612, -415410, -413884, -413485, -412445, -412039, -409117, -404157, -403104, -402214, -399297, -398009, -394662, -394400, -387068, -382956, -377479, -376780, -376732, -373809, -369876, -369250, -366798, -364205, -362359, -361703, -360946, -356672, -356301, -354579, -350532, -344807, -343006, -341940, -340847, -334305, -333283, -331280, -329095, -322367, -321737, -320405, -319271, -318683, -318148, -312601, -312402, -311172, -308093, -303657, -301896, -301585, -300840, -299090, -290587, -290405, -288264, -286310, -285260, -283203, -281602, -280554, -277719, -277367, -273499, -273444, -266670, -266440, -266149, -263766, -263213, -258359, -258188, -257967, -256143, -254244, -254129, -253986, -252380, -250078, -248068, -241806, -234082, -231422, -226961, -226726, -224936, -220543, -218730, -217704, -216979, -212839, -212231, -209975, -209144, -208686, -206761, -204086, -203947, -203596, -200865, -198871, -196137, -193656, -192660, -191771, -190406, -190224, -189580, -183656, -182032, -181673, -179539, -178558, -178466, -171235, -169035, -168139, -163334, -162513, -159760, -153352, -151430, -149200, -148617, -147789, -146917, -143520, -141685, -140765, -138541, -137192, -136378, -136121, -135248, -126620, -126018, -124977, -124810, -124358, -123734, -123261, -120319, -117462, -116511, -113094, -111945, -107280, -107221, -103278, -99794, -99775, -97702, -96349, -93791, -93493, -92391, -89145, -88439, -85669, -81817, -78682, -71833, -68860, -68714, -66797, -66115, -65327, -63854, -63614, -62880, -61941, -58666, -55315, -54143, -54070, -50608, -50453, -50025, -49444, -47389, -46445, -42733, -38631, -28209, -23554, -22756, -21808, -21461, -19811, -17204, -15400, -15043, -14099, -10116, -4103, 4761, 7511, 8026, 8217, 8284, 9484, 10304, 10433, 15501, 23625, 24668, 26630, 27875, 29371, 32597, 33292, 33711, 33835, 38629, 41433, 42645, 45027, 48184, 49370, 49737, 51485, 53558, 56863, 57782, 58214, 58573, 59943, 60158, 61095, 64861, 68094, 69967, 72210, 84911, 88369, 89569, 91175, 93323, 94736, 95731, 96867, 101547, 101593, 105577, 105915, 108291, 109642, 110430, 111261, 114242, 115015, 115784, 116059, 117074, 119086, 124427, 124811, 125783, 129934, 130169, 132333, 132585, 133603, 134202, 137590, 138376, 140572, 143242, 143832, 149286, 153069, 154031, 156120, 156799, 156803, 159725, 161308, 162138, 168290, 171154, 171905, 173061, 174367, 175790, 177101, 177608, 179283, 179832, 181354, 182163, 183845, 184610, 187399, 190545, 194968, 196332, 196439, 196946, 197373, 197625, 199136, 200717, 204007, 209721, 211050, 212345, 214558, 215817, 217076, 219635, 220292, 222193, 224098, 229558, 234550, 240765, 243016, 244080, 248669, 254163, 255187, 256021, 258150, 264040, 269104, 272968, 273359, 273622, 275264, 277058, 278050, 278906, 281780, 282628, 282720, 283114, 283439, 284020, 288098, 290080, 293982, 295723, 300918, 302834, 303035, 306573, 310242, 311126, 311338, 312957, 313208, 318327, 319716, 320445, 322223, 326356, 326844, 333589, 341789, 343809, 344774, 345112, 347326, 347896, 348278, 348841, 351778, 352444, 354028, 354953, 356061, 357611, 359826, 362735, 362877, 370417, 377109, 380674, 382971, 383186, 383211, 383859, 386344, 386397, 389923, 391672, 394574, 396502, 396879, 396945, 399865, 401285, 406208, 406977, 412249, 413024, 419364, 419428, 424013, 424713, 426389, 429151, 430049, 432057, 433879, 433953, 437055, 437699, 438636, 438642, 440257, 440688, 441524, 441968, 442003, 444787, 444843, 447109, 450702, 450703, 451700, 453368, 453389, 453417, 453440, 454547, 461876, 465340, 465460, 468459, 470522, 473262, 475745, 481459, 483851, 484724, 485927, 486314, 487541, 488382, 491649, 492365, 492761, 497716, 497953, 499773, 500839, 503845, 504141, 506154, 508253, 508544, 509945, 511637, 514963, 516434, 516681, 516931, 529764, 530524, 536303, 536933, 539344, 542245, 542892, 543252, 545202, 552352, 552610, 554833, 555222, 555540, 556950, 556951, 562806, 563245, 564036, 565833, 567567, 567771, 568748, 569404, 571150, 571839, 573065, 573324, 573473, 574913, 578939, 586068, 587628, 588939, 589801, 590664, 591492, 599686, 602288, 604390, 610124, 614532, 617774, 626243, 628318, 629894, 634198, 634418, 634735, 640547, 641173, 645439, 645595, 646370, 649042, 649956, 651031, 651237, 655060, 656329, 656960, 657035, 657601, 659421, 660262, 662337, 662428, 663337, 664290, 665674, 666263, 666601, 667893, 671527, 673865, 674923, 675394, 679169, 680930, 683013, 685720, 686089, 686494, 690082, 690321, 690619, 691996, 695204, 698064, 699115, 705381, 709639, 712137, 712366, 713867, 713909, 714648, 714905, 716657, 718347, 719072, 719292, 719437, 721477, 722108, 722586, 726743, 730006, 732031, 732487, 734262, 734575, 736410, 738892, 739745, 742763, 745439, 750432, 752823, 753119, 754063, 754449, 754559, 756807, 759050, 762380, 763211, 765016, 766971, 767664, 768995, 769780, 770541, 770615, 772130, 773032, 774493, 775283, 776640, 777953, 779428, 780696, 788321, 789897, 795699, 801007, 801087, 801097, 804984, 807159, 807678, 808151, 812311, 812962, 813002, 814512, 814593, 816861, 819471, 819664, 820689, 823510, 824399, 824650, 825381, 826986, 826997, 828200, 831273, 833409, 833690, 835405, 842094, 842655, 844201, 844883, 848760, 850573, 851037, 852353, 853756, 854762, 855014, 857050, 857749, 858984, 860710, 862800, 863655, 866425, 866556, 868331, 868475, 869176, 869789, 870317, 881520, 883667, 885141, 885246, 885718, 886755, 887107, 887112, 889343, 895548, 898611, 899482, 902793, 906288, 908715, 909938, 912501, 914477, 915301, 916209, 916213, 920617, 921592, 928058, 930278, 931949, 931964, 932707, 935617, 938378, 939591, 940801, 943139, 943984, 945433, 945527, 949018, 949399, 949761, 952476, 960915, 961052, 961920, 962740, 963348, 964522, 965677, 966087, 967130, 969531, 971091, 974509, 975654, 978955, 980370, 985598, 992742, 993415, 994578, 997743, 999337]"
                    },
                    {
                        "username": "luanct",
                        "content": "O(m+n) approach is an easy problem when all of us know how to implement merge sort.\nBut when the description says that we should implement in O(log(m+n)) runtime complexity then here the binary search comes, no merge 2 array anymore. That's kinda hard question, but not too hard."
                    },
                    {
                        "username": "aitachii",
                        "content": "Use 4 pointers\n\nHonestly, you're better off learning the `O(log(m+n))` and  `O(log(min(m,n)))` solution from the Editorial or any other place but you can still try doing the intuitive `O(m+n)` solution."
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'m getting the correct answer in my IDLE, however, it is showing wrong here. 2.5 is the answer i got on my IDE and it was correct logic, it\\'s showing 2.0 here. Why so ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you cast your integers into double before dividing by 2.0?"
                    },
                    {
                        "username": "jkkjofaxiu",
                        "content": "The online python version might cause test case fails. In example, `sum([2, 3]) / 2` returns `2.5` in my local python interpreter (3.10), but it returns  `2` in the online interpreter. I have to add type convert before doing division `float(sum([2, 3])) / 2`. reference [pep-0238](https://peps.python.org/pep-0238/)"
                    },
                    {
                        "username": "Zefick",
                        "content": "Select \"Python 3\" language. \"Python\" is actually the Python 2.x and it has different division rules."
                    },
                    {
                        "username": "jingminzhou",
                        "content": "The binary search solution can be solved in O(log(MIN(m, n))) time frame, but it took me countless hours to debug my code for all corner cases. Meanwhile, a O(m+n) solution is much cleaner, more readable, more maintainable, and took way less time to get the code correct. Asking you to code such problems in a 20-45 interview session only shows how *incompetent* the interviewer is - he/she obviously weights more on \"clever\" tricks than better code."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "if an interviewer asks you this question and then asks for O(log (m+n)) solution... they do not want you to get the job"
                    },
                    {
                        "username": "piyush9242kumar",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            int n = nums1.size(), m = nums2.size();\\n    if( n > m)\\n    {\\n        swap(n, m);\\n        swap(nums1, nums2);\\n    }    \\n\\n    int s = 0, e = n;\\n    while(s <= e)\\n    {\\n        int i = (s+e)/2;\\n        int j = (m+n+1)/2 - i;\\n        \\n        if(i < n and nums2[j - 1] > nums1[i])\\n            s = i+1;\\n        else if(i > 0 and nums1[i-1] > nums2[j])\\n            e = i-1;\\n        else\\n        {\\n            int left = 0;\\n            if(i == 0)\\n                left = nums2[j-1];\\n            else if(j == 0)\\n                left = nums1[i-1];\\n            else\\n                left = max(nums1[i-1], nums2[j-1]);\\n            \\n            if((m+n) % 2 & 1ll)\\n                return left;\\n\\n            int right = 0;\\n            if(i == n)\\n                right = nums2[j];\\n            if(j == n)\\n                right = nums1[i];\\n            else\\n                right = min(nums1[i], nums2[j]);\\n\\n            return (right+left)/2.0;\\n        }\\n    }\\n        return 0;\\n    }\\n};\\nyour inline code...`\\n\\nwhy is this code not working in leetcode it is working fine when I run it on my pc"
                    },
                    {
                        "username": "ghOst-vedant",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> merged;\\n        int s1=nums1.size();\\n        int s2=nums2.size();\\n        int i=0,j=0;\\n        double median=0;\\n        int mid=0,total=s1+s2;\\n        while(i<s1 && j<s2){\\n            if(nums1[i]<nums2[j]){\\n                merged.push_back(nums1[i++]);\\n            }\\n            else if(nums2[j]<nums1[i]){\\n                merged.push_back(nums2[j++]);\\n            }\\n            else{\\n                merged.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        while(i<s1){\\n            merged.push_back(nums1[i++]);\\n        }\\n        while(j<s2){\\n            merged.push_back(nums2[j++]);\\n        }\\n        if((total)%2==1){\\n            median=(merged[total/2]);\\n        }\\n        else{\\n            mid=(total)/2;\\n            median=(merged[mid]+merged[mid+1])/2.0;\\n        }\\n        return median;\\n    }\\n};\\n\\nhelp please I\\'m notr getting expected output for:\\n[1,1,1,1,1,1,1,1,1,1,4,4]\\n[1,3,4,4,4,4,4,4,4,4,4]\\n it need to be 3 but mine is 4"
                    },
                    {
                        "username": "HiltonUniverse",
                        "content": "We need a new difficult level called: God mode. Learning this was one crazy journey."
                    }
                ]
            },
            {
                "id": 2050609,
                "content": [
                    {
                        "username": "justinleung0204",
                        "content": "try \\n[-994655, -993994, -991967, -991325, -990398, -988095, -985751, -979217, -978192, -978011, -977429, -976673, -975247, -974516, -972815, -972128, -969579, -968714, -966498, -965804, -965649, -965398, -964406, -959276, -957464, -957387, -955598, -955414, -954591, -954093, -954030, -954026, -953568, -951586, -949720, -948620, -948067, -947702, -944747, -939522, -939390, -938770, -936821, -935171, -934261, -932485, -930539, -927942, -927441, -927304, -925848, -924409, -922636, -921691, -921180, -920983, -920322, -916773, -916293, -914806, -914595, -913674, -911815, -911371, -910861, -909825, -909148, -907716, -907408, -906773, -905247, -904944, -904001, -902721, -898131, -894932, -894560, -894204, -890932, -890586, -890069, -888310, -885313, -882692, -881456, -880824, -878763, -878112, -876247, -875654, -870390, -867532, -867324, -867058, -866471, -865559, -861404, -861074, -858880, -858287, -857419, -852828, -851970, -850887, -850781, -847064, -845959, -844400, -843865, -842229, -841504, -838420, -837661, -832341, -830491, -825293, -825170, -824615, -820676, -820657, -812263, -811178, -809320, -807655, -806194, -804182, -800065, -798525, -797897, -797674, -796210, -794011, -793851, -792819, -792074, -790951, -785779, -783652, -780803, -780429, -777118, -775053, -772694, -771726, -770114, -769735, -769420, -767702, -767674, -767478, -767208, -766647, -766326, -766171, -762990, -762262, -760950, -759882, -758089, -754901, -753444, -752476, -749957, -749006, -748946, -744097, -744040, -743806, -742040, -739358, -738506, -737332, -736316, -733828, -732416, -732205, -730920, -729686, -729326, -729138, -728690, -728587, -725291, -721993, -721992, -720924, -719181, -718985, -717776, -714652, -708778, -706347, -703008, -701329, -698849, -697626, -697226, -697030, -694863, -687971, -687615, -687424, -685428, -684993, -682056, -667871, -666917, -666776, -665524, -658872, -658109, -656999, -655860, -654585, -654567, -651017, -649888, -647590, -646763, -645638, -638225, -637214, -636529, -633272, -633041, -628082, -628074, -625948, -625778, -622448, -622326, -621929, -620161, -617798, -616576, -611212, -610377, -609261, -608425, -606242, -603468, -603394, -601744, -595969, -594421, -594310, -592685, -590529, -589111, -584672, -583224, -582511, -580883, -580187, -578709, -577674, -571825, -568085, -566554, -561892, -560889, -560243, -558453, -558272, -557250, -556808, -555477, -553500, -549913, -549122, -546769, -544973, -544931, -543612, -542175, -538884, -536964, -533928, -531674, -530917, -530560, -528123, -527672, -525811, -524895, -521574, -516255, -513441, -512365, -511052, -510908, -510079, -504485, -502724, -502713, -500985, -496529, -493674, -493237, -492219, -489936, -487103, -484436, -482849, -482574, -482438, -482307, -481959, -481755, -481499, -481119, -477835, -471451, -465684, -464144, -461270, -458708, -458164, -457157, -454667, -454446, -453810, -452722, -450750, -444975, -440175, -436952, -433585, -431811, -431720, -425111, -423881, -421194, -417870, -413472, -409253, -406580, -404742, -398875, -396025, -395996, -392462, -390019, -389063, -388162, -387957, -384367, -384027, -383828, -382868, -382548, -381340, -381173, -376972, -373184, -370443, -369784, -369455, -367706, -362942, -361908, -360373, -356580, -344963, -344933, -344512, -344413, -340781, -335776, -335511, -332496, -332446, -332409, -332143, -326673, -326193, -324660, -322211, -321050, -318489, -317015, -316691, -312615, -309925, -305811, -303248, -302524, -301475, -299453, -298686, -291993, -287894, -284511, -278832, -274460, -269894, -265159, -264165, -263392, -261037, -258641, -255496, -255178, -254565, -252402, -250505, -246222, -244617, -239476, -237763, -235060, -233619, -231114, -228848, -228656, -228578, -228226, -226331, -223722, -221392, -220245, -214583, -208621, -208343, -205857, -204617, -204304, -204285, -200047, -198543, -196234, -195210, -192665, -191287, -190204, -187869, -180022, -175780, -169961, -165183, -163516, -162511, -159937, -159803, -157580, -155940, -154326, -153617, -151366, -150658, -149895, -143392, -142415, -141753, -140801, -140080, -138421, -137027, -136051, -135650, -132303, -131807, -130982, -130351, -126965, -124889, -120330, -115763, -115533, -115175, -114069, -113806, -105748, -104513, -103830, -103764, -103087, -102295, -98578, -97385, -93806, -92518, -90790, -89187, -88063, -86842, -86501, -85210, -82344, -80068, -76951, -72564, -71907, -68477, -67744, -65798, -65780, -62141, -61154, -58960, -58115, -55704, -48527, -47225, -44349, -44029, -35038, -34583, -34362, -33071, -30648, -27662, -24982, -24466, -24397, -22420, -22009, -20987, -18291, -15623, -14045, -12181, -8728, -6981, -5731, -2950, 1367, 1818, 2401, 2938, 4264, 4584, 11242, 12709, 14171, 18698, 19038, 19599, 25362, 27010, 27929, 28395, 32259, 32665, 33468, 39762, 40127, 41189, 48605, 50424, 50906, 53805, 54014, 54624, 55043, 55794, 56943, 57003, 58277, 58831, 59986, 62496, 63300, 63605, 63676, 66787, 72481, 74582, 81305, 85419, 86260, 88773, 89468, 89893, 91087, 93138, 98928, 99485, 101867, 103182, 103643, 108080, 110424, 112405, 115488, 118543, 119684, 120157, 121520, 123015, 123924, 124286, 125825, 127501, 128321, 128666, 129072, 129364, 130767, 135733, 136137, 136842, 137411, 140242, 141253, 143452, 145059, 145544, 146265, 146279, 150295, 150670, 156025, 156460, 157376, 158128, 161217, 161807, 163218, 164005, 164019, 165078, 167877, 173294, 174293, 175499, 180190, 192118, 202050, 203337, 203624, 203848, 204865, 205804, 206171, 208552, 209042, 213388, 219026, 219326, 220237, 220523, 220764, 221011, 222353, 223547, 224087, 225137, 226694, 226946, 229949, 234630, 235166, 237063, 240044, 241984, 245391, 251124, 255354, 255617, 264578, 268464, 268874, 273129, 276470, 276947, 281221, 281464, 282559, 282670, 283776, 287452, 296062, 296337, 297368, 299522, 300248, 300477, 301826, 302041, 303045, 307342, 310186, 310775, 315405, 315655, 316020, 317199, 320681, 322423, 324207, 325763, 325947, 327388, 328055, 330375, 331369, 336117, 337601, 337922, 338413, 339689, 344223, 345602, 347266, 349666, 354635, 357004, 359434, 364032, 365612, 366258, 368356, 371959, 374211, 376232, 381889, 383873, 384773, 387686, 387740, 388208, 389155, 393759, 394337, 394868, 395326, 395421, 397150, 404334, 404733, 407893, 408870, 413736, 415400, 423697, 424224, 424265, 425890, 427506, 427704, 431231, 431344, 432838, 432923, 436850, 438152, 438400, 445828, 447957, 448944, 452475, 454037, 454042, 461568, 465456, 467202, 467621, 468330, 470674, 476464, 477326, 477762, 480008, 485465, 486033, 491446, 498300, 501100, 501423, 504302, 505800, 506539, 506676, 508254, 508725, 510582, 515056, 517777, 520579, 521061, 524719, 529371, 534703, 539864, 541871, 544689, 544989, 548490, 551646, 552914, 552916, 554936, 555192, 557279, 557586, 557842, 558356, 558545, 559741, 561964, 565092, 566614, 568317, 571816, 572954, 577836, 578284, 578288, 582481, 585000, 587923, 594589, 595497, 596243, 596553, 600481, 601999, 605611, 605625, 605898, 606984, 610671, 611329, 614007, 615026, 616123, 616465, 616695, 619115, 620944, 621183, 621238, 622624, 623709, 626170, 631512, 633734, 633897, 642285, 643515, 644487, 645569, 648469, 649319, 651622, 652349, 652471, 652656, 653350, 654672, 657564, 658798, 659881, 660364, 668169, 673024, 674223, 674379, 676960, 678797, 684346, 684844, 685550, 685896, 687722, 689208, 691097, 696537, 701992, 707493, 710182, 714908, 717494, 724297, 727641, 728373, 729877, 731508, 734590, 735305, 735317, 739140, 746284, 752465, 753806, 758884, 760396, 762874, 764092, 765117, 765790, 766725, 768602, 776053, 778383, 779166, 780941, 781907, 785696, 790021, 792947, 794668, 796450, 800590, 804655, 805756, 808165, 813998, 814743, 815376, 815601, 816512, 816963, 817371, 821429, 828465, 830397, 830745, 832817, 834284, 835718, 838315, 838606, 839502, 840290, 840523, 845697, 847854, 848272, 849574, 853478, 860115, 863716, 865873, 866963, 867234, 867719, 868116, 868662, 870298, 874510, 874747, 875141, 875616, 875673, 876231, 876818, 877363, 877878, 884584, 889654, 892550, 892839, 894332, 894848, 895292, 903528, 909968, 918085, 918731, 923542, 925517, 925993, 927445, 930221, 932594, 934728, 934944, 944427, 944811, 950539, 951356, 951819, 952739, 954583, 957900, 957933, 958923, 964744, 965862, 965989, 966665, 971239, 972730, 974831, 975587, 975977, 977660, 978787, 983506, 988173, 989550, 990686, 991667, 992009, 994375, 995734, 997675, 999532]\\n[-999976, -998102, -996399, -990171, -987077, -985460, -977325, -973944, -973755, -970843, -970712, -969253, -968809, -967953, -964787, -964159, -963370, -962146, -961939, -961865, -961002, -959225, -955032, -951432, -950628, -950501, -949979, -949052, -948579, -948255, -948180, -947382, -946831, -943856, -943265, -941884, -939367, -934655, -933594, -933267, -933150, -931941, -931355, -929961, -928950, -926385, -925900, -922392, -921349, -917159, -915852, -913868, -913177, -912126, -911650, -906208, -904331, -900631, -900396, -900260, -898073, -894053, -892157, -888801, -885113, -884606, -876379, -876182, -874294, -873461, -873375, -866686, -864153, -861753, -859036, -858613, -855308, -853122, -849717, -849038, -847682, -847591, -847548, -847493, -843804, -842136, -841126, -840560, -838206, -837475, -832635, -831851, -829506, -821825, -821604, -821416, -819921, -818596, -814728, -812401, -802668, -802341, -801782, -798938, -797448, -795949, -795454, -788062, -785374, -779662, -776140, -773108, -772295, -771332, -768511, -768076, -757824, -754387, -753336, -752899, -752558, -748895, -748119, -745007, -744380, -740142, -740131, -736554, -725489, -724056, -719290, -719000, -715614, -715389, -712866, -710062, -708992, -708858, -708503, -708327, -708107, -703165, -703070, -698491, -698408, -696183, -691396, -689170, -683602, -681016, -681004, -679423, -678710, -678110, -675747, -672764, -672183, -671318, -669036, -666682, -663882, -658444, -652812, -652570, -651282, -650117, -647445, -647032, -645400, -643448, -643032, -641211, -640966, -639180, -638644, -631017, -629124, -628266, -627326, -626751, -622803, -621997, -617267, -614916, -611545, -610235, -608265, -606528, -605394, -604643, -602724, -601137, -600904, -599893, -595128, -595110, -595051, -589778, -588397, -585457, -583924, -582449, -577489, -574917, -573052, -570235, -570057, -568734, -567691, -566107, -566005, -565292, -565044, -562667, -561943, -557920, -557165, -556696, -551209, -550725, -548397, -546962, -545405, -544513, -542856, -539916, -539036, -539033, -538421, -537103, -537096, -535937, -531820, -531799, -531219, -529665, -524228, -520413, -517994, -513147, -511694, -503901, -498984, -498918, -498417, -495330, -494970, -494675, -490099, -488750, -488027, -486632, -483819, -483353, -480105, -479694, -475572, -471747, -471260, -470615, -469126, -469091, -467435, -465038, -464180, -457106, -456851, -456315, -454742, -454265, -448588, -447441, -441802, -441523, -440304, -439990, -437237, -435428, -433858, -430596, -430320, -419534, -417665, -417593, -415612, -415410, -413884, -413485, -412445, -412039, -409117, -404157, -403104, -402214, -399297, -398009, -394662, -394400, -387068, -382956, -377479, -376780, -376732, -373809, -369876, -369250, -366798, -364205, -362359, -361703, -360946, -356672, -356301, -354579, -350532, -344807, -343006, -341940, -340847, -334305, -333283, -331280, -329095, -322367, -321737, -320405, -319271, -318683, -318148, -312601, -312402, -311172, -308093, -303657, -301896, -301585, -300840, -299090, -290587, -290405, -288264, -286310, -285260, -283203, -281602, -280554, -277719, -277367, -273499, -273444, -266670, -266440, -266149, -263766, -263213, -258359, -258188, -257967, -256143, -254244, -254129, -253986, -252380, -250078, -248068, -241806, -234082, -231422, -226961, -226726, -224936, -220543, -218730, -217704, -216979, -212839, -212231, -209975, -209144, -208686, -206761, -204086, -203947, -203596, -200865, -198871, -196137, -193656, -192660, -191771, -190406, -190224, -189580, -183656, -182032, -181673, -179539, -178558, -178466, -171235, -169035, -168139, -163334, -162513, -159760, -153352, -151430, -149200, -148617, -147789, -146917, -143520, -141685, -140765, -138541, -137192, -136378, -136121, -135248, -126620, -126018, -124977, -124810, -124358, -123734, -123261, -120319, -117462, -116511, -113094, -111945, -107280, -107221, -103278, -99794, -99775, -97702, -96349, -93791, -93493, -92391, -89145, -88439, -85669, -81817, -78682, -71833, -68860, -68714, -66797, -66115, -65327, -63854, -63614, -62880, -61941, -58666, -55315, -54143, -54070, -50608, -50453, -50025, -49444, -47389, -46445, -42733, -38631, -28209, -23554, -22756, -21808, -21461, -19811, -17204, -15400, -15043, -14099, -10116, -4103, 4761, 7511, 8026, 8217, 8284, 9484, 10304, 10433, 15501, 23625, 24668, 26630, 27875, 29371, 32597, 33292, 33711, 33835, 38629, 41433, 42645, 45027, 48184, 49370, 49737, 51485, 53558, 56863, 57782, 58214, 58573, 59943, 60158, 61095, 64861, 68094, 69967, 72210, 84911, 88369, 89569, 91175, 93323, 94736, 95731, 96867, 101547, 101593, 105577, 105915, 108291, 109642, 110430, 111261, 114242, 115015, 115784, 116059, 117074, 119086, 124427, 124811, 125783, 129934, 130169, 132333, 132585, 133603, 134202, 137590, 138376, 140572, 143242, 143832, 149286, 153069, 154031, 156120, 156799, 156803, 159725, 161308, 162138, 168290, 171154, 171905, 173061, 174367, 175790, 177101, 177608, 179283, 179832, 181354, 182163, 183845, 184610, 187399, 190545, 194968, 196332, 196439, 196946, 197373, 197625, 199136, 200717, 204007, 209721, 211050, 212345, 214558, 215817, 217076, 219635, 220292, 222193, 224098, 229558, 234550, 240765, 243016, 244080, 248669, 254163, 255187, 256021, 258150, 264040, 269104, 272968, 273359, 273622, 275264, 277058, 278050, 278906, 281780, 282628, 282720, 283114, 283439, 284020, 288098, 290080, 293982, 295723, 300918, 302834, 303035, 306573, 310242, 311126, 311338, 312957, 313208, 318327, 319716, 320445, 322223, 326356, 326844, 333589, 341789, 343809, 344774, 345112, 347326, 347896, 348278, 348841, 351778, 352444, 354028, 354953, 356061, 357611, 359826, 362735, 362877, 370417, 377109, 380674, 382971, 383186, 383211, 383859, 386344, 386397, 389923, 391672, 394574, 396502, 396879, 396945, 399865, 401285, 406208, 406977, 412249, 413024, 419364, 419428, 424013, 424713, 426389, 429151, 430049, 432057, 433879, 433953, 437055, 437699, 438636, 438642, 440257, 440688, 441524, 441968, 442003, 444787, 444843, 447109, 450702, 450703, 451700, 453368, 453389, 453417, 453440, 454547, 461876, 465340, 465460, 468459, 470522, 473262, 475745, 481459, 483851, 484724, 485927, 486314, 487541, 488382, 491649, 492365, 492761, 497716, 497953, 499773, 500839, 503845, 504141, 506154, 508253, 508544, 509945, 511637, 514963, 516434, 516681, 516931, 529764, 530524, 536303, 536933, 539344, 542245, 542892, 543252, 545202, 552352, 552610, 554833, 555222, 555540, 556950, 556951, 562806, 563245, 564036, 565833, 567567, 567771, 568748, 569404, 571150, 571839, 573065, 573324, 573473, 574913, 578939, 586068, 587628, 588939, 589801, 590664, 591492, 599686, 602288, 604390, 610124, 614532, 617774, 626243, 628318, 629894, 634198, 634418, 634735, 640547, 641173, 645439, 645595, 646370, 649042, 649956, 651031, 651237, 655060, 656329, 656960, 657035, 657601, 659421, 660262, 662337, 662428, 663337, 664290, 665674, 666263, 666601, 667893, 671527, 673865, 674923, 675394, 679169, 680930, 683013, 685720, 686089, 686494, 690082, 690321, 690619, 691996, 695204, 698064, 699115, 705381, 709639, 712137, 712366, 713867, 713909, 714648, 714905, 716657, 718347, 719072, 719292, 719437, 721477, 722108, 722586, 726743, 730006, 732031, 732487, 734262, 734575, 736410, 738892, 739745, 742763, 745439, 750432, 752823, 753119, 754063, 754449, 754559, 756807, 759050, 762380, 763211, 765016, 766971, 767664, 768995, 769780, 770541, 770615, 772130, 773032, 774493, 775283, 776640, 777953, 779428, 780696, 788321, 789897, 795699, 801007, 801087, 801097, 804984, 807159, 807678, 808151, 812311, 812962, 813002, 814512, 814593, 816861, 819471, 819664, 820689, 823510, 824399, 824650, 825381, 826986, 826997, 828200, 831273, 833409, 833690, 835405, 842094, 842655, 844201, 844883, 848760, 850573, 851037, 852353, 853756, 854762, 855014, 857050, 857749, 858984, 860710, 862800, 863655, 866425, 866556, 868331, 868475, 869176, 869789, 870317, 881520, 883667, 885141, 885246, 885718, 886755, 887107, 887112, 889343, 895548, 898611, 899482, 902793, 906288, 908715, 909938, 912501, 914477, 915301, 916209, 916213, 920617, 921592, 928058, 930278, 931949, 931964, 932707, 935617, 938378, 939591, 940801, 943139, 943984, 945433, 945527, 949018, 949399, 949761, 952476, 960915, 961052, 961920, 962740, 963348, 964522, 965677, 966087, 967130, 969531, 971091, 974509, 975654, 978955, 980370, 985598, 992742, 993415, 994578, 997743, 999337]"
                    },
                    {
                        "username": "luanct",
                        "content": "O(m+n) approach is an easy problem when all of us know how to implement merge sort.\nBut when the description says that we should implement in O(log(m+n)) runtime complexity then here the binary search comes, no merge 2 array anymore. That's kinda hard question, but not too hard."
                    },
                    {
                        "username": "aitachii",
                        "content": "Use 4 pointers\n\nHonestly, you're better off learning the `O(log(m+n))` and  `O(log(min(m,n)))` solution from the Editorial or any other place but you can still try doing the intuitive `O(m+n)` solution."
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'m getting the correct answer in my IDLE, however, it is showing wrong here. 2.5 is the answer i got on my IDE and it was correct logic, it\\'s showing 2.0 here. Why so ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you cast your integers into double before dividing by 2.0?"
                    },
                    {
                        "username": "jkkjofaxiu",
                        "content": "The online python version might cause test case fails. In example, `sum([2, 3]) / 2` returns `2.5` in my local python interpreter (3.10), but it returns  `2` in the online interpreter. I have to add type convert before doing division `float(sum([2, 3])) / 2`. reference [pep-0238](https://peps.python.org/pep-0238/)"
                    },
                    {
                        "username": "Zefick",
                        "content": "Select \"Python 3\" language. \"Python\" is actually the Python 2.x and it has different division rules."
                    },
                    {
                        "username": "jingminzhou",
                        "content": "The binary search solution can be solved in O(log(MIN(m, n))) time frame, but it took me countless hours to debug my code for all corner cases. Meanwhile, a O(m+n) solution is much cleaner, more readable, more maintainable, and took way less time to get the code correct. Asking you to code such problems in a 20-45 interview session only shows how *incompetent* the interviewer is - he/she obviously weights more on \"clever\" tricks than better code."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "if an interviewer asks you this question and then asks for O(log (m+n)) solution... they do not want you to get the job"
                    },
                    {
                        "username": "piyush9242kumar",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            int n = nums1.size(), m = nums2.size();\\n    if( n > m)\\n    {\\n        swap(n, m);\\n        swap(nums1, nums2);\\n    }    \\n\\n    int s = 0, e = n;\\n    while(s <= e)\\n    {\\n        int i = (s+e)/2;\\n        int j = (m+n+1)/2 - i;\\n        \\n        if(i < n and nums2[j - 1] > nums1[i])\\n            s = i+1;\\n        else if(i > 0 and nums1[i-1] > nums2[j])\\n            e = i-1;\\n        else\\n        {\\n            int left = 0;\\n            if(i == 0)\\n                left = nums2[j-1];\\n            else if(j == 0)\\n                left = nums1[i-1];\\n            else\\n                left = max(nums1[i-1], nums2[j-1]);\\n            \\n            if((m+n) % 2 & 1ll)\\n                return left;\\n\\n            int right = 0;\\n            if(i == n)\\n                right = nums2[j];\\n            if(j == n)\\n                right = nums1[i];\\n            else\\n                right = min(nums1[i], nums2[j]);\\n\\n            return (right+left)/2.0;\\n        }\\n    }\\n        return 0;\\n    }\\n};\\nyour inline code...`\\n\\nwhy is this code not working in leetcode it is working fine when I run it on my pc"
                    },
                    {
                        "username": "ghOst-vedant",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> merged;\\n        int s1=nums1.size();\\n        int s2=nums2.size();\\n        int i=0,j=0;\\n        double median=0;\\n        int mid=0,total=s1+s2;\\n        while(i<s1 && j<s2){\\n            if(nums1[i]<nums2[j]){\\n                merged.push_back(nums1[i++]);\\n            }\\n            else if(nums2[j]<nums1[i]){\\n                merged.push_back(nums2[j++]);\\n            }\\n            else{\\n                merged.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        while(i<s1){\\n            merged.push_back(nums1[i++]);\\n        }\\n        while(j<s2){\\n            merged.push_back(nums2[j++]);\\n        }\\n        if((total)%2==1){\\n            median=(merged[total/2]);\\n        }\\n        else{\\n            mid=(total)/2;\\n            median=(merged[mid]+merged[mid+1])/2.0;\\n        }\\n        return median;\\n    }\\n};\\n\\nhelp please I\\'m notr getting expected output for:\\n[1,1,1,1,1,1,1,1,1,1,4,4]\\n[1,3,4,4,4,4,4,4,4,4,4]\\n it need to be 3 but mine is 4"
                    },
                    {
                        "username": "HiltonUniverse",
                        "content": "We need a new difficult level called: God mode. Learning this was one crazy journey."
                    }
                ]
            },
            {
                "id": 2046965,
                "content": [
                    {
                        "username": "justinleung0204",
                        "content": "try \\n[-994655, -993994, -991967, -991325, -990398, -988095, -985751, -979217, -978192, -978011, -977429, -976673, -975247, -974516, -972815, -972128, -969579, -968714, -966498, -965804, -965649, -965398, -964406, -959276, -957464, -957387, -955598, -955414, -954591, -954093, -954030, -954026, -953568, -951586, -949720, -948620, -948067, -947702, -944747, -939522, -939390, -938770, -936821, -935171, -934261, -932485, -930539, -927942, -927441, -927304, -925848, -924409, -922636, -921691, -921180, -920983, -920322, -916773, -916293, -914806, -914595, -913674, -911815, -911371, -910861, -909825, -909148, -907716, -907408, -906773, -905247, -904944, -904001, -902721, -898131, -894932, -894560, -894204, -890932, -890586, -890069, -888310, -885313, -882692, -881456, -880824, -878763, -878112, -876247, -875654, -870390, -867532, -867324, -867058, -866471, -865559, -861404, -861074, -858880, -858287, -857419, -852828, -851970, -850887, -850781, -847064, -845959, -844400, -843865, -842229, -841504, -838420, -837661, -832341, -830491, -825293, -825170, -824615, -820676, -820657, -812263, -811178, -809320, -807655, -806194, -804182, -800065, -798525, -797897, -797674, -796210, -794011, -793851, -792819, -792074, -790951, -785779, -783652, -780803, -780429, -777118, -775053, -772694, -771726, -770114, -769735, -769420, -767702, -767674, -767478, -767208, -766647, -766326, -766171, -762990, -762262, -760950, -759882, -758089, -754901, -753444, -752476, -749957, -749006, -748946, -744097, -744040, -743806, -742040, -739358, -738506, -737332, -736316, -733828, -732416, -732205, -730920, -729686, -729326, -729138, -728690, -728587, -725291, -721993, -721992, -720924, -719181, -718985, -717776, -714652, -708778, -706347, -703008, -701329, -698849, -697626, -697226, -697030, -694863, -687971, -687615, -687424, -685428, -684993, -682056, -667871, -666917, -666776, -665524, -658872, -658109, -656999, -655860, -654585, -654567, -651017, -649888, -647590, -646763, -645638, -638225, -637214, -636529, -633272, -633041, -628082, -628074, -625948, -625778, -622448, -622326, -621929, -620161, -617798, -616576, -611212, -610377, -609261, -608425, -606242, -603468, -603394, -601744, -595969, -594421, -594310, -592685, -590529, -589111, -584672, -583224, -582511, -580883, -580187, -578709, -577674, -571825, -568085, -566554, -561892, -560889, -560243, -558453, -558272, -557250, -556808, -555477, -553500, -549913, -549122, -546769, -544973, -544931, -543612, -542175, -538884, -536964, -533928, -531674, -530917, -530560, -528123, -527672, -525811, -524895, -521574, -516255, -513441, -512365, -511052, -510908, -510079, -504485, -502724, -502713, -500985, -496529, -493674, -493237, -492219, -489936, -487103, -484436, -482849, -482574, -482438, -482307, -481959, -481755, -481499, -481119, -477835, -471451, -465684, -464144, -461270, -458708, -458164, -457157, -454667, -454446, -453810, -452722, -450750, -444975, -440175, -436952, -433585, -431811, -431720, -425111, -423881, -421194, -417870, -413472, -409253, -406580, -404742, -398875, -396025, -395996, -392462, -390019, -389063, -388162, -387957, -384367, -384027, -383828, -382868, -382548, -381340, -381173, -376972, -373184, -370443, -369784, -369455, -367706, -362942, -361908, -360373, -356580, -344963, -344933, -344512, -344413, -340781, -335776, -335511, -332496, -332446, -332409, -332143, -326673, -326193, -324660, -322211, -321050, -318489, -317015, -316691, -312615, -309925, -305811, -303248, -302524, -301475, -299453, -298686, -291993, -287894, -284511, -278832, -274460, -269894, -265159, -264165, -263392, -261037, -258641, -255496, -255178, -254565, -252402, -250505, -246222, -244617, -239476, -237763, -235060, -233619, -231114, -228848, -228656, -228578, -228226, -226331, -223722, -221392, -220245, -214583, -208621, -208343, -205857, -204617, -204304, -204285, -200047, -198543, -196234, -195210, -192665, -191287, -190204, -187869, -180022, -175780, -169961, -165183, -163516, -162511, -159937, -159803, -157580, -155940, -154326, -153617, -151366, -150658, -149895, -143392, -142415, -141753, -140801, -140080, -138421, -137027, -136051, -135650, -132303, -131807, -130982, -130351, -126965, -124889, -120330, -115763, -115533, -115175, -114069, -113806, -105748, -104513, -103830, -103764, -103087, -102295, -98578, -97385, -93806, -92518, -90790, -89187, -88063, -86842, -86501, -85210, -82344, -80068, -76951, -72564, -71907, -68477, -67744, -65798, -65780, -62141, -61154, -58960, -58115, -55704, -48527, -47225, -44349, -44029, -35038, -34583, -34362, -33071, -30648, -27662, -24982, -24466, -24397, -22420, -22009, -20987, -18291, -15623, -14045, -12181, -8728, -6981, -5731, -2950, 1367, 1818, 2401, 2938, 4264, 4584, 11242, 12709, 14171, 18698, 19038, 19599, 25362, 27010, 27929, 28395, 32259, 32665, 33468, 39762, 40127, 41189, 48605, 50424, 50906, 53805, 54014, 54624, 55043, 55794, 56943, 57003, 58277, 58831, 59986, 62496, 63300, 63605, 63676, 66787, 72481, 74582, 81305, 85419, 86260, 88773, 89468, 89893, 91087, 93138, 98928, 99485, 101867, 103182, 103643, 108080, 110424, 112405, 115488, 118543, 119684, 120157, 121520, 123015, 123924, 124286, 125825, 127501, 128321, 128666, 129072, 129364, 130767, 135733, 136137, 136842, 137411, 140242, 141253, 143452, 145059, 145544, 146265, 146279, 150295, 150670, 156025, 156460, 157376, 158128, 161217, 161807, 163218, 164005, 164019, 165078, 167877, 173294, 174293, 175499, 180190, 192118, 202050, 203337, 203624, 203848, 204865, 205804, 206171, 208552, 209042, 213388, 219026, 219326, 220237, 220523, 220764, 221011, 222353, 223547, 224087, 225137, 226694, 226946, 229949, 234630, 235166, 237063, 240044, 241984, 245391, 251124, 255354, 255617, 264578, 268464, 268874, 273129, 276470, 276947, 281221, 281464, 282559, 282670, 283776, 287452, 296062, 296337, 297368, 299522, 300248, 300477, 301826, 302041, 303045, 307342, 310186, 310775, 315405, 315655, 316020, 317199, 320681, 322423, 324207, 325763, 325947, 327388, 328055, 330375, 331369, 336117, 337601, 337922, 338413, 339689, 344223, 345602, 347266, 349666, 354635, 357004, 359434, 364032, 365612, 366258, 368356, 371959, 374211, 376232, 381889, 383873, 384773, 387686, 387740, 388208, 389155, 393759, 394337, 394868, 395326, 395421, 397150, 404334, 404733, 407893, 408870, 413736, 415400, 423697, 424224, 424265, 425890, 427506, 427704, 431231, 431344, 432838, 432923, 436850, 438152, 438400, 445828, 447957, 448944, 452475, 454037, 454042, 461568, 465456, 467202, 467621, 468330, 470674, 476464, 477326, 477762, 480008, 485465, 486033, 491446, 498300, 501100, 501423, 504302, 505800, 506539, 506676, 508254, 508725, 510582, 515056, 517777, 520579, 521061, 524719, 529371, 534703, 539864, 541871, 544689, 544989, 548490, 551646, 552914, 552916, 554936, 555192, 557279, 557586, 557842, 558356, 558545, 559741, 561964, 565092, 566614, 568317, 571816, 572954, 577836, 578284, 578288, 582481, 585000, 587923, 594589, 595497, 596243, 596553, 600481, 601999, 605611, 605625, 605898, 606984, 610671, 611329, 614007, 615026, 616123, 616465, 616695, 619115, 620944, 621183, 621238, 622624, 623709, 626170, 631512, 633734, 633897, 642285, 643515, 644487, 645569, 648469, 649319, 651622, 652349, 652471, 652656, 653350, 654672, 657564, 658798, 659881, 660364, 668169, 673024, 674223, 674379, 676960, 678797, 684346, 684844, 685550, 685896, 687722, 689208, 691097, 696537, 701992, 707493, 710182, 714908, 717494, 724297, 727641, 728373, 729877, 731508, 734590, 735305, 735317, 739140, 746284, 752465, 753806, 758884, 760396, 762874, 764092, 765117, 765790, 766725, 768602, 776053, 778383, 779166, 780941, 781907, 785696, 790021, 792947, 794668, 796450, 800590, 804655, 805756, 808165, 813998, 814743, 815376, 815601, 816512, 816963, 817371, 821429, 828465, 830397, 830745, 832817, 834284, 835718, 838315, 838606, 839502, 840290, 840523, 845697, 847854, 848272, 849574, 853478, 860115, 863716, 865873, 866963, 867234, 867719, 868116, 868662, 870298, 874510, 874747, 875141, 875616, 875673, 876231, 876818, 877363, 877878, 884584, 889654, 892550, 892839, 894332, 894848, 895292, 903528, 909968, 918085, 918731, 923542, 925517, 925993, 927445, 930221, 932594, 934728, 934944, 944427, 944811, 950539, 951356, 951819, 952739, 954583, 957900, 957933, 958923, 964744, 965862, 965989, 966665, 971239, 972730, 974831, 975587, 975977, 977660, 978787, 983506, 988173, 989550, 990686, 991667, 992009, 994375, 995734, 997675, 999532]\\n[-999976, -998102, -996399, -990171, -987077, -985460, -977325, -973944, -973755, -970843, -970712, -969253, -968809, -967953, -964787, -964159, -963370, -962146, -961939, -961865, -961002, -959225, -955032, -951432, -950628, -950501, -949979, -949052, -948579, -948255, -948180, -947382, -946831, -943856, -943265, -941884, -939367, -934655, -933594, -933267, -933150, -931941, -931355, -929961, -928950, -926385, -925900, -922392, -921349, -917159, -915852, -913868, -913177, -912126, -911650, -906208, -904331, -900631, -900396, -900260, -898073, -894053, -892157, -888801, -885113, -884606, -876379, -876182, -874294, -873461, -873375, -866686, -864153, -861753, -859036, -858613, -855308, -853122, -849717, -849038, -847682, -847591, -847548, -847493, -843804, -842136, -841126, -840560, -838206, -837475, -832635, -831851, -829506, -821825, -821604, -821416, -819921, -818596, -814728, -812401, -802668, -802341, -801782, -798938, -797448, -795949, -795454, -788062, -785374, -779662, -776140, -773108, -772295, -771332, -768511, -768076, -757824, -754387, -753336, -752899, -752558, -748895, -748119, -745007, -744380, -740142, -740131, -736554, -725489, -724056, -719290, -719000, -715614, -715389, -712866, -710062, -708992, -708858, -708503, -708327, -708107, -703165, -703070, -698491, -698408, -696183, -691396, -689170, -683602, -681016, -681004, -679423, -678710, -678110, -675747, -672764, -672183, -671318, -669036, -666682, -663882, -658444, -652812, -652570, -651282, -650117, -647445, -647032, -645400, -643448, -643032, -641211, -640966, -639180, -638644, -631017, -629124, -628266, -627326, -626751, -622803, -621997, -617267, -614916, -611545, -610235, -608265, -606528, -605394, -604643, -602724, -601137, -600904, -599893, -595128, -595110, -595051, -589778, -588397, -585457, -583924, -582449, -577489, -574917, -573052, -570235, -570057, -568734, -567691, -566107, -566005, -565292, -565044, -562667, -561943, -557920, -557165, -556696, -551209, -550725, -548397, -546962, -545405, -544513, -542856, -539916, -539036, -539033, -538421, -537103, -537096, -535937, -531820, -531799, -531219, -529665, -524228, -520413, -517994, -513147, -511694, -503901, -498984, -498918, -498417, -495330, -494970, -494675, -490099, -488750, -488027, -486632, -483819, -483353, -480105, -479694, -475572, -471747, -471260, -470615, -469126, -469091, -467435, -465038, -464180, -457106, -456851, -456315, -454742, -454265, -448588, -447441, -441802, -441523, -440304, -439990, -437237, -435428, -433858, -430596, -430320, -419534, -417665, -417593, -415612, -415410, -413884, -413485, -412445, -412039, -409117, -404157, -403104, -402214, -399297, -398009, -394662, -394400, -387068, -382956, -377479, -376780, -376732, -373809, -369876, -369250, -366798, -364205, -362359, -361703, -360946, -356672, -356301, -354579, -350532, -344807, -343006, -341940, -340847, -334305, -333283, -331280, -329095, -322367, -321737, -320405, -319271, -318683, -318148, -312601, -312402, -311172, -308093, -303657, -301896, -301585, -300840, -299090, -290587, -290405, -288264, -286310, -285260, -283203, -281602, -280554, -277719, -277367, -273499, -273444, -266670, -266440, -266149, -263766, -263213, -258359, -258188, -257967, -256143, -254244, -254129, -253986, -252380, -250078, -248068, -241806, -234082, -231422, -226961, -226726, -224936, -220543, -218730, -217704, -216979, -212839, -212231, -209975, -209144, -208686, -206761, -204086, -203947, -203596, -200865, -198871, -196137, -193656, -192660, -191771, -190406, -190224, -189580, -183656, -182032, -181673, -179539, -178558, -178466, -171235, -169035, -168139, -163334, -162513, -159760, -153352, -151430, -149200, -148617, -147789, -146917, -143520, -141685, -140765, -138541, -137192, -136378, -136121, -135248, -126620, -126018, -124977, -124810, -124358, -123734, -123261, -120319, -117462, -116511, -113094, -111945, -107280, -107221, -103278, -99794, -99775, -97702, -96349, -93791, -93493, -92391, -89145, -88439, -85669, -81817, -78682, -71833, -68860, -68714, -66797, -66115, -65327, -63854, -63614, -62880, -61941, -58666, -55315, -54143, -54070, -50608, -50453, -50025, -49444, -47389, -46445, -42733, -38631, -28209, -23554, -22756, -21808, -21461, -19811, -17204, -15400, -15043, -14099, -10116, -4103, 4761, 7511, 8026, 8217, 8284, 9484, 10304, 10433, 15501, 23625, 24668, 26630, 27875, 29371, 32597, 33292, 33711, 33835, 38629, 41433, 42645, 45027, 48184, 49370, 49737, 51485, 53558, 56863, 57782, 58214, 58573, 59943, 60158, 61095, 64861, 68094, 69967, 72210, 84911, 88369, 89569, 91175, 93323, 94736, 95731, 96867, 101547, 101593, 105577, 105915, 108291, 109642, 110430, 111261, 114242, 115015, 115784, 116059, 117074, 119086, 124427, 124811, 125783, 129934, 130169, 132333, 132585, 133603, 134202, 137590, 138376, 140572, 143242, 143832, 149286, 153069, 154031, 156120, 156799, 156803, 159725, 161308, 162138, 168290, 171154, 171905, 173061, 174367, 175790, 177101, 177608, 179283, 179832, 181354, 182163, 183845, 184610, 187399, 190545, 194968, 196332, 196439, 196946, 197373, 197625, 199136, 200717, 204007, 209721, 211050, 212345, 214558, 215817, 217076, 219635, 220292, 222193, 224098, 229558, 234550, 240765, 243016, 244080, 248669, 254163, 255187, 256021, 258150, 264040, 269104, 272968, 273359, 273622, 275264, 277058, 278050, 278906, 281780, 282628, 282720, 283114, 283439, 284020, 288098, 290080, 293982, 295723, 300918, 302834, 303035, 306573, 310242, 311126, 311338, 312957, 313208, 318327, 319716, 320445, 322223, 326356, 326844, 333589, 341789, 343809, 344774, 345112, 347326, 347896, 348278, 348841, 351778, 352444, 354028, 354953, 356061, 357611, 359826, 362735, 362877, 370417, 377109, 380674, 382971, 383186, 383211, 383859, 386344, 386397, 389923, 391672, 394574, 396502, 396879, 396945, 399865, 401285, 406208, 406977, 412249, 413024, 419364, 419428, 424013, 424713, 426389, 429151, 430049, 432057, 433879, 433953, 437055, 437699, 438636, 438642, 440257, 440688, 441524, 441968, 442003, 444787, 444843, 447109, 450702, 450703, 451700, 453368, 453389, 453417, 453440, 454547, 461876, 465340, 465460, 468459, 470522, 473262, 475745, 481459, 483851, 484724, 485927, 486314, 487541, 488382, 491649, 492365, 492761, 497716, 497953, 499773, 500839, 503845, 504141, 506154, 508253, 508544, 509945, 511637, 514963, 516434, 516681, 516931, 529764, 530524, 536303, 536933, 539344, 542245, 542892, 543252, 545202, 552352, 552610, 554833, 555222, 555540, 556950, 556951, 562806, 563245, 564036, 565833, 567567, 567771, 568748, 569404, 571150, 571839, 573065, 573324, 573473, 574913, 578939, 586068, 587628, 588939, 589801, 590664, 591492, 599686, 602288, 604390, 610124, 614532, 617774, 626243, 628318, 629894, 634198, 634418, 634735, 640547, 641173, 645439, 645595, 646370, 649042, 649956, 651031, 651237, 655060, 656329, 656960, 657035, 657601, 659421, 660262, 662337, 662428, 663337, 664290, 665674, 666263, 666601, 667893, 671527, 673865, 674923, 675394, 679169, 680930, 683013, 685720, 686089, 686494, 690082, 690321, 690619, 691996, 695204, 698064, 699115, 705381, 709639, 712137, 712366, 713867, 713909, 714648, 714905, 716657, 718347, 719072, 719292, 719437, 721477, 722108, 722586, 726743, 730006, 732031, 732487, 734262, 734575, 736410, 738892, 739745, 742763, 745439, 750432, 752823, 753119, 754063, 754449, 754559, 756807, 759050, 762380, 763211, 765016, 766971, 767664, 768995, 769780, 770541, 770615, 772130, 773032, 774493, 775283, 776640, 777953, 779428, 780696, 788321, 789897, 795699, 801007, 801087, 801097, 804984, 807159, 807678, 808151, 812311, 812962, 813002, 814512, 814593, 816861, 819471, 819664, 820689, 823510, 824399, 824650, 825381, 826986, 826997, 828200, 831273, 833409, 833690, 835405, 842094, 842655, 844201, 844883, 848760, 850573, 851037, 852353, 853756, 854762, 855014, 857050, 857749, 858984, 860710, 862800, 863655, 866425, 866556, 868331, 868475, 869176, 869789, 870317, 881520, 883667, 885141, 885246, 885718, 886755, 887107, 887112, 889343, 895548, 898611, 899482, 902793, 906288, 908715, 909938, 912501, 914477, 915301, 916209, 916213, 920617, 921592, 928058, 930278, 931949, 931964, 932707, 935617, 938378, 939591, 940801, 943139, 943984, 945433, 945527, 949018, 949399, 949761, 952476, 960915, 961052, 961920, 962740, 963348, 964522, 965677, 966087, 967130, 969531, 971091, 974509, 975654, 978955, 980370, 985598, 992742, 993415, 994578, 997743, 999337]"
                    },
                    {
                        "username": "luanct",
                        "content": "O(m+n) approach is an easy problem when all of us know how to implement merge sort.\nBut when the description says that we should implement in O(log(m+n)) runtime complexity then here the binary search comes, no merge 2 array anymore. That's kinda hard question, but not too hard."
                    },
                    {
                        "username": "aitachii",
                        "content": "Use 4 pointers\n\nHonestly, you're better off learning the `O(log(m+n))` and  `O(log(min(m,n)))` solution from the Editorial or any other place but you can still try doing the intuitive `O(m+n)` solution."
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'m getting the correct answer in my IDLE, however, it is showing wrong here. 2.5 is the answer i got on my IDE and it was correct logic, it\\'s showing 2.0 here. Why so ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you cast your integers into double before dividing by 2.0?"
                    },
                    {
                        "username": "jkkjofaxiu",
                        "content": "The online python version might cause test case fails. In example, `sum([2, 3]) / 2` returns `2.5` in my local python interpreter (3.10), but it returns  `2` in the online interpreter. I have to add type convert before doing division `float(sum([2, 3])) / 2`. reference [pep-0238](https://peps.python.org/pep-0238/)"
                    },
                    {
                        "username": "Zefick",
                        "content": "Select \"Python 3\" language. \"Python\" is actually the Python 2.x and it has different division rules."
                    },
                    {
                        "username": "jingminzhou",
                        "content": "The binary search solution can be solved in O(log(MIN(m, n))) time frame, but it took me countless hours to debug my code for all corner cases. Meanwhile, a O(m+n) solution is much cleaner, more readable, more maintainable, and took way less time to get the code correct. Asking you to code such problems in a 20-45 interview session only shows how *incompetent* the interviewer is - he/she obviously weights more on \"clever\" tricks than better code."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "if an interviewer asks you this question and then asks for O(log (m+n)) solution... they do not want you to get the job"
                    },
                    {
                        "username": "piyush9242kumar",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            int n = nums1.size(), m = nums2.size();\\n    if( n > m)\\n    {\\n        swap(n, m);\\n        swap(nums1, nums2);\\n    }    \\n\\n    int s = 0, e = n;\\n    while(s <= e)\\n    {\\n        int i = (s+e)/2;\\n        int j = (m+n+1)/2 - i;\\n        \\n        if(i < n and nums2[j - 1] > nums1[i])\\n            s = i+1;\\n        else if(i > 0 and nums1[i-1] > nums2[j])\\n            e = i-1;\\n        else\\n        {\\n            int left = 0;\\n            if(i == 0)\\n                left = nums2[j-1];\\n            else if(j == 0)\\n                left = nums1[i-1];\\n            else\\n                left = max(nums1[i-1], nums2[j-1]);\\n            \\n            if((m+n) % 2 & 1ll)\\n                return left;\\n\\n            int right = 0;\\n            if(i == n)\\n                right = nums2[j];\\n            if(j == n)\\n                right = nums1[i];\\n            else\\n                right = min(nums1[i], nums2[j]);\\n\\n            return (right+left)/2.0;\\n        }\\n    }\\n        return 0;\\n    }\\n};\\nyour inline code...`\\n\\nwhy is this code not working in leetcode it is working fine when I run it on my pc"
                    },
                    {
                        "username": "ghOst-vedant",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> merged;\\n        int s1=nums1.size();\\n        int s2=nums2.size();\\n        int i=0,j=0;\\n        double median=0;\\n        int mid=0,total=s1+s2;\\n        while(i<s1 && j<s2){\\n            if(nums1[i]<nums2[j]){\\n                merged.push_back(nums1[i++]);\\n            }\\n            else if(nums2[j]<nums1[i]){\\n                merged.push_back(nums2[j++]);\\n            }\\n            else{\\n                merged.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        while(i<s1){\\n            merged.push_back(nums1[i++]);\\n        }\\n        while(j<s2){\\n            merged.push_back(nums2[j++]);\\n        }\\n        if((total)%2==1){\\n            median=(merged[total/2]);\\n        }\\n        else{\\n            mid=(total)/2;\\n            median=(merged[mid]+merged[mid+1])/2.0;\\n        }\\n        return median;\\n    }\\n};\\n\\nhelp please I\\'m notr getting expected output for:\\n[1,1,1,1,1,1,1,1,1,1,4,4]\\n[1,3,4,4,4,4,4,4,4,4,4]\\n it need to be 3 but mine is 4"
                    },
                    {
                        "username": "HiltonUniverse",
                        "content": "We need a new difficult level called: God mode. Learning this was one crazy journey."
                    }
                ]
            },
            {
                "id": 2037897,
                "content": [
                    {
                        "username": "justinleung0204",
                        "content": "try \\n[-994655, -993994, -991967, -991325, -990398, -988095, -985751, -979217, -978192, -978011, -977429, -976673, -975247, -974516, -972815, -972128, -969579, -968714, -966498, -965804, -965649, -965398, -964406, -959276, -957464, -957387, -955598, -955414, -954591, -954093, -954030, -954026, -953568, -951586, -949720, -948620, -948067, -947702, -944747, -939522, -939390, -938770, -936821, -935171, -934261, -932485, -930539, -927942, -927441, -927304, -925848, -924409, -922636, -921691, -921180, -920983, -920322, -916773, -916293, -914806, -914595, -913674, -911815, -911371, -910861, -909825, -909148, -907716, -907408, -906773, -905247, -904944, -904001, -902721, -898131, -894932, -894560, -894204, -890932, -890586, -890069, -888310, -885313, -882692, -881456, -880824, -878763, -878112, -876247, -875654, -870390, -867532, -867324, -867058, -866471, -865559, -861404, -861074, -858880, -858287, -857419, -852828, -851970, -850887, -850781, -847064, -845959, -844400, -843865, -842229, -841504, -838420, -837661, -832341, -830491, -825293, -825170, -824615, -820676, -820657, -812263, -811178, -809320, -807655, -806194, -804182, -800065, -798525, -797897, -797674, -796210, -794011, -793851, -792819, -792074, -790951, -785779, -783652, -780803, -780429, -777118, -775053, -772694, -771726, -770114, -769735, -769420, -767702, -767674, -767478, -767208, -766647, -766326, -766171, -762990, -762262, -760950, -759882, -758089, -754901, -753444, -752476, -749957, -749006, -748946, -744097, -744040, -743806, -742040, -739358, -738506, -737332, -736316, -733828, -732416, -732205, -730920, -729686, -729326, -729138, -728690, -728587, -725291, -721993, -721992, -720924, -719181, -718985, -717776, -714652, -708778, -706347, -703008, -701329, -698849, -697626, -697226, -697030, -694863, -687971, -687615, -687424, -685428, -684993, -682056, -667871, -666917, -666776, -665524, -658872, -658109, -656999, -655860, -654585, -654567, -651017, -649888, -647590, -646763, -645638, -638225, -637214, -636529, -633272, -633041, -628082, -628074, -625948, -625778, -622448, -622326, -621929, -620161, -617798, -616576, -611212, -610377, -609261, -608425, -606242, -603468, -603394, -601744, -595969, -594421, -594310, -592685, -590529, -589111, -584672, -583224, -582511, -580883, -580187, -578709, -577674, -571825, -568085, -566554, -561892, -560889, -560243, -558453, -558272, -557250, -556808, -555477, -553500, -549913, -549122, -546769, -544973, -544931, -543612, -542175, -538884, -536964, -533928, -531674, -530917, -530560, -528123, -527672, -525811, -524895, -521574, -516255, -513441, -512365, -511052, -510908, -510079, -504485, -502724, -502713, -500985, -496529, -493674, -493237, -492219, -489936, -487103, -484436, -482849, -482574, -482438, -482307, -481959, -481755, -481499, -481119, -477835, -471451, -465684, -464144, -461270, -458708, -458164, -457157, -454667, -454446, -453810, -452722, -450750, -444975, -440175, -436952, -433585, -431811, -431720, -425111, -423881, -421194, -417870, -413472, -409253, -406580, -404742, -398875, -396025, -395996, -392462, -390019, -389063, -388162, -387957, -384367, -384027, -383828, -382868, -382548, -381340, -381173, -376972, -373184, -370443, -369784, -369455, -367706, -362942, -361908, -360373, -356580, -344963, -344933, -344512, -344413, -340781, -335776, -335511, -332496, -332446, -332409, -332143, -326673, -326193, -324660, -322211, -321050, -318489, -317015, -316691, -312615, -309925, -305811, -303248, -302524, -301475, -299453, -298686, -291993, -287894, -284511, -278832, -274460, -269894, -265159, -264165, -263392, -261037, -258641, -255496, -255178, -254565, -252402, -250505, -246222, -244617, -239476, -237763, -235060, -233619, -231114, -228848, -228656, -228578, -228226, -226331, -223722, -221392, -220245, -214583, -208621, -208343, -205857, -204617, -204304, -204285, -200047, -198543, -196234, -195210, -192665, -191287, -190204, -187869, -180022, -175780, -169961, -165183, -163516, -162511, -159937, -159803, -157580, -155940, -154326, -153617, -151366, -150658, -149895, -143392, -142415, -141753, -140801, -140080, -138421, -137027, -136051, -135650, -132303, -131807, -130982, -130351, -126965, -124889, -120330, -115763, -115533, -115175, -114069, -113806, -105748, -104513, -103830, -103764, -103087, -102295, -98578, -97385, -93806, -92518, -90790, -89187, -88063, -86842, -86501, -85210, -82344, -80068, -76951, -72564, -71907, -68477, -67744, -65798, -65780, -62141, -61154, -58960, -58115, -55704, -48527, -47225, -44349, -44029, -35038, -34583, -34362, -33071, -30648, -27662, -24982, -24466, -24397, -22420, -22009, -20987, -18291, -15623, -14045, -12181, -8728, -6981, -5731, -2950, 1367, 1818, 2401, 2938, 4264, 4584, 11242, 12709, 14171, 18698, 19038, 19599, 25362, 27010, 27929, 28395, 32259, 32665, 33468, 39762, 40127, 41189, 48605, 50424, 50906, 53805, 54014, 54624, 55043, 55794, 56943, 57003, 58277, 58831, 59986, 62496, 63300, 63605, 63676, 66787, 72481, 74582, 81305, 85419, 86260, 88773, 89468, 89893, 91087, 93138, 98928, 99485, 101867, 103182, 103643, 108080, 110424, 112405, 115488, 118543, 119684, 120157, 121520, 123015, 123924, 124286, 125825, 127501, 128321, 128666, 129072, 129364, 130767, 135733, 136137, 136842, 137411, 140242, 141253, 143452, 145059, 145544, 146265, 146279, 150295, 150670, 156025, 156460, 157376, 158128, 161217, 161807, 163218, 164005, 164019, 165078, 167877, 173294, 174293, 175499, 180190, 192118, 202050, 203337, 203624, 203848, 204865, 205804, 206171, 208552, 209042, 213388, 219026, 219326, 220237, 220523, 220764, 221011, 222353, 223547, 224087, 225137, 226694, 226946, 229949, 234630, 235166, 237063, 240044, 241984, 245391, 251124, 255354, 255617, 264578, 268464, 268874, 273129, 276470, 276947, 281221, 281464, 282559, 282670, 283776, 287452, 296062, 296337, 297368, 299522, 300248, 300477, 301826, 302041, 303045, 307342, 310186, 310775, 315405, 315655, 316020, 317199, 320681, 322423, 324207, 325763, 325947, 327388, 328055, 330375, 331369, 336117, 337601, 337922, 338413, 339689, 344223, 345602, 347266, 349666, 354635, 357004, 359434, 364032, 365612, 366258, 368356, 371959, 374211, 376232, 381889, 383873, 384773, 387686, 387740, 388208, 389155, 393759, 394337, 394868, 395326, 395421, 397150, 404334, 404733, 407893, 408870, 413736, 415400, 423697, 424224, 424265, 425890, 427506, 427704, 431231, 431344, 432838, 432923, 436850, 438152, 438400, 445828, 447957, 448944, 452475, 454037, 454042, 461568, 465456, 467202, 467621, 468330, 470674, 476464, 477326, 477762, 480008, 485465, 486033, 491446, 498300, 501100, 501423, 504302, 505800, 506539, 506676, 508254, 508725, 510582, 515056, 517777, 520579, 521061, 524719, 529371, 534703, 539864, 541871, 544689, 544989, 548490, 551646, 552914, 552916, 554936, 555192, 557279, 557586, 557842, 558356, 558545, 559741, 561964, 565092, 566614, 568317, 571816, 572954, 577836, 578284, 578288, 582481, 585000, 587923, 594589, 595497, 596243, 596553, 600481, 601999, 605611, 605625, 605898, 606984, 610671, 611329, 614007, 615026, 616123, 616465, 616695, 619115, 620944, 621183, 621238, 622624, 623709, 626170, 631512, 633734, 633897, 642285, 643515, 644487, 645569, 648469, 649319, 651622, 652349, 652471, 652656, 653350, 654672, 657564, 658798, 659881, 660364, 668169, 673024, 674223, 674379, 676960, 678797, 684346, 684844, 685550, 685896, 687722, 689208, 691097, 696537, 701992, 707493, 710182, 714908, 717494, 724297, 727641, 728373, 729877, 731508, 734590, 735305, 735317, 739140, 746284, 752465, 753806, 758884, 760396, 762874, 764092, 765117, 765790, 766725, 768602, 776053, 778383, 779166, 780941, 781907, 785696, 790021, 792947, 794668, 796450, 800590, 804655, 805756, 808165, 813998, 814743, 815376, 815601, 816512, 816963, 817371, 821429, 828465, 830397, 830745, 832817, 834284, 835718, 838315, 838606, 839502, 840290, 840523, 845697, 847854, 848272, 849574, 853478, 860115, 863716, 865873, 866963, 867234, 867719, 868116, 868662, 870298, 874510, 874747, 875141, 875616, 875673, 876231, 876818, 877363, 877878, 884584, 889654, 892550, 892839, 894332, 894848, 895292, 903528, 909968, 918085, 918731, 923542, 925517, 925993, 927445, 930221, 932594, 934728, 934944, 944427, 944811, 950539, 951356, 951819, 952739, 954583, 957900, 957933, 958923, 964744, 965862, 965989, 966665, 971239, 972730, 974831, 975587, 975977, 977660, 978787, 983506, 988173, 989550, 990686, 991667, 992009, 994375, 995734, 997675, 999532]\\n[-999976, -998102, -996399, -990171, -987077, -985460, -977325, -973944, -973755, -970843, -970712, -969253, -968809, -967953, -964787, -964159, -963370, -962146, -961939, -961865, -961002, -959225, -955032, -951432, -950628, -950501, -949979, -949052, -948579, -948255, -948180, -947382, -946831, -943856, -943265, -941884, -939367, -934655, -933594, -933267, -933150, -931941, -931355, -929961, -928950, -926385, -925900, -922392, -921349, -917159, -915852, -913868, -913177, -912126, -911650, -906208, -904331, -900631, -900396, -900260, -898073, -894053, -892157, -888801, -885113, -884606, -876379, -876182, -874294, -873461, -873375, -866686, -864153, -861753, -859036, -858613, -855308, -853122, -849717, -849038, -847682, -847591, -847548, -847493, -843804, -842136, -841126, -840560, -838206, -837475, -832635, -831851, -829506, -821825, -821604, -821416, -819921, -818596, -814728, -812401, -802668, -802341, -801782, -798938, -797448, -795949, -795454, -788062, -785374, -779662, -776140, -773108, -772295, -771332, -768511, -768076, -757824, -754387, -753336, -752899, -752558, -748895, -748119, -745007, -744380, -740142, -740131, -736554, -725489, -724056, -719290, -719000, -715614, -715389, -712866, -710062, -708992, -708858, -708503, -708327, -708107, -703165, -703070, -698491, -698408, -696183, -691396, -689170, -683602, -681016, -681004, -679423, -678710, -678110, -675747, -672764, -672183, -671318, -669036, -666682, -663882, -658444, -652812, -652570, -651282, -650117, -647445, -647032, -645400, -643448, -643032, -641211, -640966, -639180, -638644, -631017, -629124, -628266, -627326, -626751, -622803, -621997, -617267, -614916, -611545, -610235, -608265, -606528, -605394, -604643, -602724, -601137, -600904, -599893, -595128, -595110, -595051, -589778, -588397, -585457, -583924, -582449, -577489, -574917, -573052, -570235, -570057, -568734, -567691, -566107, -566005, -565292, -565044, -562667, -561943, -557920, -557165, -556696, -551209, -550725, -548397, -546962, -545405, -544513, -542856, -539916, -539036, -539033, -538421, -537103, -537096, -535937, -531820, -531799, -531219, -529665, -524228, -520413, -517994, -513147, -511694, -503901, -498984, -498918, -498417, -495330, -494970, -494675, -490099, -488750, -488027, -486632, -483819, -483353, -480105, -479694, -475572, -471747, -471260, -470615, -469126, -469091, -467435, -465038, -464180, -457106, -456851, -456315, -454742, -454265, -448588, -447441, -441802, -441523, -440304, -439990, -437237, -435428, -433858, -430596, -430320, -419534, -417665, -417593, -415612, -415410, -413884, -413485, -412445, -412039, -409117, -404157, -403104, -402214, -399297, -398009, -394662, -394400, -387068, -382956, -377479, -376780, -376732, -373809, -369876, -369250, -366798, -364205, -362359, -361703, -360946, -356672, -356301, -354579, -350532, -344807, -343006, -341940, -340847, -334305, -333283, -331280, -329095, -322367, -321737, -320405, -319271, -318683, -318148, -312601, -312402, -311172, -308093, -303657, -301896, -301585, -300840, -299090, -290587, -290405, -288264, -286310, -285260, -283203, -281602, -280554, -277719, -277367, -273499, -273444, -266670, -266440, -266149, -263766, -263213, -258359, -258188, -257967, -256143, -254244, -254129, -253986, -252380, -250078, -248068, -241806, -234082, -231422, -226961, -226726, -224936, -220543, -218730, -217704, -216979, -212839, -212231, -209975, -209144, -208686, -206761, -204086, -203947, -203596, -200865, -198871, -196137, -193656, -192660, -191771, -190406, -190224, -189580, -183656, -182032, -181673, -179539, -178558, -178466, -171235, -169035, -168139, -163334, -162513, -159760, -153352, -151430, -149200, -148617, -147789, -146917, -143520, -141685, -140765, -138541, -137192, -136378, -136121, -135248, -126620, -126018, -124977, -124810, -124358, -123734, -123261, -120319, -117462, -116511, -113094, -111945, -107280, -107221, -103278, -99794, -99775, -97702, -96349, -93791, -93493, -92391, -89145, -88439, -85669, -81817, -78682, -71833, -68860, -68714, -66797, -66115, -65327, -63854, -63614, -62880, -61941, -58666, -55315, -54143, -54070, -50608, -50453, -50025, -49444, -47389, -46445, -42733, -38631, -28209, -23554, -22756, -21808, -21461, -19811, -17204, -15400, -15043, -14099, -10116, -4103, 4761, 7511, 8026, 8217, 8284, 9484, 10304, 10433, 15501, 23625, 24668, 26630, 27875, 29371, 32597, 33292, 33711, 33835, 38629, 41433, 42645, 45027, 48184, 49370, 49737, 51485, 53558, 56863, 57782, 58214, 58573, 59943, 60158, 61095, 64861, 68094, 69967, 72210, 84911, 88369, 89569, 91175, 93323, 94736, 95731, 96867, 101547, 101593, 105577, 105915, 108291, 109642, 110430, 111261, 114242, 115015, 115784, 116059, 117074, 119086, 124427, 124811, 125783, 129934, 130169, 132333, 132585, 133603, 134202, 137590, 138376, 140572, 143242, 143832, 149286, 153069, 154031, 156120, 156799, 156803, 159725, 161308, 162138, 168290, 171154, 171905, 173061, 174367, 175790, 177101, 177608, 179283, 179832, 181354, 182163, 183845, 184610, 187399, 190545, 194968, 196332, 196439, 196946, 197373, 197625, 199136, 200717, 204007, 209721, 211050, 212345, 214558, 215817, 217076, 219635, 220292, 222193, 224098, 229558, 234550, 240765, 243016, 244080, 248669, 254163, 255187, 256021, 258150, 264040, 269104, 272968, 273359, 273622, 275264, 277058, 278050, 278906, 281780, 282628, 282720, 283114, 283439, 284020, 288098, 290080, 293982, 295723, 300918, 302834, 303035, 306573, 310242, 311126, 311338, 312957, 313208, 318327, 319716, 320445, 322223, 326356, 326844, 333589, 341789, 343809, 344774, 345112, 347326, 347896, 348278, 348841, 351778, 352444, 354028, 354953, 356061, 357611, 359826, 362735, 362877, 370417, 377109, 380674, 382971, 383186, 383211, 383859, 386344, 386397, 389923, 391672, 394574, 396502, 396879, 396945, 399865, 401285, 406208, 406977, 412249, 413024, 419364, 419428, 424013, 424713, 426389, 429151, 430049, 432057, 433879, 433953, 437055, 437699, 438636, 438642, 440257, 440688, 441524, 441968, 442003, 444787, 444843, 447109, 450702, 450703, 451700, 453368, 453389, 453417, 453440, 454547, 461876, 465340, 465460, 468459, 470522, 473262, 475745, 481459, 483851, 484724, 485927, 486314, 487541, 488382, 491649, 492365, 492761, 497716, 497953, 499773, 500839, 503845, 504141, 506154, 508253, 508544, 509945, 511637, 514963, 516434, 516681, 516931, 529764, 530524, 536303, 536933, 539344, 542245, 542892, 543252, 545202, 552352, 552610, 554833, 555222, 555540, 556950, 556951, 562806, 563245, 564036, 565833, 567567, 567771, 568748, 569404, 571150, 571839, 573065, 573324, 573473, 574913, 578939, 586068, 587628, 588939, 589801, 590664, 591492, 599686, 602288, 604390, 610124, 614532, 617774, 626243, 628318, 629894, 634198, 634418, 634735, 640547, 641173, 645439, 645595, 646370, 649042, 649956, 651031, 651237, 655060, 656329, 656960, 657035, 657601, 659421, 660262, 662337, 662428, 663337, 664290, 665674, 666263, 666601, 667893, 671527, 673865, 674923, 675394, 679169, 680930, 683013, 685720, 686089, 686494, 690082, 690321, 690619, 691996, 695204, 698064, 699115, 705381, 709639, 712137, 712366, 713867, 713909, 714648, 714905, 716657, 718347, 719072, 719292, 719437, 721477, 722108, 722586, 726743, 730006, 732031, 732487, 734262, 734575, 736410, 738892, 739745, 742763, 745439, 750432, 752823, 753119, 754063, 754449, 754559, 756807, 759050, 762380, 763211, 765016, 766971, 767664, 768995, 769780, 770541, 770615, 772130, 773032, 774493, 775283, 776640, 777953, 779428, 780696, 788321, 789897, 795699, 801007, 801087, 801097, 804984, 807159, 807678, 808151, 812311, 812962, 813002, 814512, 814593, 816861, 819471, 819664, 820689, 823510, 824399, 824650, 825381, 826986, 826997, 828200, 831273, 833409, 833690, 835405, 842094, 842655, 844201, 844883, 848760, 850573, 851037, 852353, 853756, 854762, 855014, 857050, 857749, 858984, 860710, 862800, 863655, 866425, 866556, 868331, 868475, 869176, 869789, 870317, 881520, 883667, 885141, 885246, 885718, 886755, 887107, 887112, 889343, 895548, 898611, 899482, 902793, 906288, 908715, 909938, 912501, 914477, 915301, 916209, 916213, 920617, 921592, 928058, 930278, 931949, 931964, 932707, 935617, 938378, 939591, 940801, 943139, 943984, 945433, 945527, 949018, 949399, 949761, 952476, 960915, 961052, 961920, 962740, 963348, 964522, 965677, 966087, 967130, 969531, 971091, 974509, 975654, 978955, 980370, 985598, 992742, 993415, 994578, 997743, 999337]"
                    },
                    {
                        "username": "luanct",
                        "content": "O(m+n) approach is an easy problem when all of us know how to implement merge sort.\nBut when the description says that we should implement in O(log(m+n)) runtime complexity then here the binary search comes, no merge 2 array anymore. That's kinda hard question, but not too hard."
                    },
                    {
                        "username": "aitachii",
                        "content": "Use 4 pointers\n\nHonestly, you're better off learning the `O(log(m+n))` and  `O(log(min(m,n)))` solution from the Editorial or any other place but you can still try doing the intuitive `O(m+n)` solution."
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'m getting the correct answer in my IDLE, however, it is showing wrong here. 2.5 is the answer i got on my IDE and it was correct logic, it\\'s showing 2.0 here. Why so ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you cast your integers into double before dividing by 2.0?"
                    },
                    {
                        "username": "jkkjofaxiu",
                        "content": "The online python version might cause test case fails. In example, `sum([2, 3]) / 2` returns `2.5` in my local python interpreter (3.10), but it returns  `2` in the online interpreter. I have to add type convert before doing division `float(sum([2, 3])) / 2`. reference [pep-0238](https://peps.python.org/pep-0238/)"
                    },
                    {
                        "username": "Zefick",
                        "content": "Select \"Python 3\" language. \"Python\" is actually the Python 2.x and it has different division rules."
                    },
                    {
                        "username": "jingminzhou",
                        "content": "The binary search solution can be solved in O(log(MIN(m, n))) time frame, but it took me countless hours to debug my code for all corner cases. Meanwhile, a O(m+n) solution is much cleaner, more readable, more maintainable, and took way less time to get the code correct. Asking you to code such problems in a 20-45 interview session only shows how *incompetent* the interviewer is - he/she obviously weights more on \"clever\" tricks than better code."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "if an interviewer asks you this question and then asks for O(log (m+n)) solution... they do not want you to get the job"
                    },
                    {
                        "username": "piyush9242kumar",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n            int n = nums1.size(), m = nums2.size();\\n    if( n > m)\\n    {\\n        swap(n, m);\\n        swap(nums1, nums2);\\n    }    \\n\\n    int s = 0, e = n;\\n    while(s <= e)\\n    {\\n        int i = (s+e)/2;\\n        int j = (m+n+1)/2 - i;\\n        \\n        if(i < n and nums2[j - 1] > nums1[i])\\n            s = i+1;\\n        else if(i > 0 and nums1[i-1] > nums2[j])\\n            e = i-1;\\n        else\\n        {\\n            int left = 0;\\n            if(i == 0)\\n                left = nums2[j-1];\\n            else if(j == 0)\\n                left = nums1[i-1];\\n            else\\n                left = max(nums1[i-1], nums2[j-1]);\\n            \\n            if((m+n) % 2 & 1ll)\\n                return left;\\n\\n            int right = 0;\\n            if(i == n)\\n                right = nums2[j];\\n            if(j == n)\\n                right = nums1[i];\\n            else\\n                right = min(nums1[i], nums2[j]);\\n\\n            return (right+left)/2.0;\\n        }\\n    }\\n        return 0;\\n    }\\n};\\nyour inline code...`\\n\\nwhy is this code not working in leetcode it is working fine when I run it on my pc"
                    },
                    {
                        "username": "ghOst-vedant",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> merged;\\n        int s1=nums1.size();\\n        int s2=nums2.size();\\n        int i=0,j=0;\\n        double median=0;\\n        int mid=0,total=s1+s2;\\n        while(i<s1 && j<s2){\\n            if(nums1[i]<nums2[j]){\\n                merged.push_back(nums1[i++]);\\n            }\\n            else if(nums2[j]<nums1[i]){\\n                merged.push_back(nums2[j++]);\\n            }\\n            else{\\n                merged.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        while(i<s1){\\n            merged.push_back(nums1[i++]);\\n        }\\n        while(j<s2){\\n            merged.push_back(nums2[j++]);\\n        }\\n        if((total)%2==1){\\n            median=(merged[total/2]);\\n        }\\n        else{\\n            mid=(total)/2;\\n            median=(merged[mid]+merged[mid+1])/2.0;\\n        }\\n        return median;\\n    }\\n};\\n\\nhelp please I\\'m notr getting expected output for:\\n[1,1,1,1,1,1,1,1,1,1,4,4]\\n[1,3,4,4,4,4,4,4,4,4,4]\\n it need to be 3 but mine is 4"
                    },
                    {
                        "username": "HiltonUniverse",
                        "content": "We need a new difficult level called: God mode. Learning this was one crazy journey."
                    }
                ]
            },
            {
                "id": 2034803,
                "content": [
                    {
                        "username": "Food_king",
                        "content": "Hello everyone, can anyone help me, I\\'m failing a test where nums 1 [4,5,6,8,9] and nums 2 [].\\n\\nMy program outputs 6.33333, while exactly 6.00000 is expected. I don\\'T understand why this is so. \\n5 + 6 + 8 = 19/3 = 6.33333. What\\'s wrong?"
                    },
                    {
                        "username": "reassurance",
                        "content": "Hey bro.\\nAs the length of the array is odd, we take the middle element.  If the length is even then we take the mean of the 2 middle elements. What you are doing does not make sense. Hope you understand.\\nEnjoy Solving!"
                    },
                    {
                        "username": "KrisChill",
                        "content": "I am a complete beginner... But is it normal to get different return values in Pycharm and here?"
                    },
                    {
                        "username": "pothamsettisairam123",
                        "content": "what is the worng in this code\\nl1=list(map(int,input()))\\nl2=list(map(int,input()))\\nl1=l1+l2\\ns=l1[len(l1)//2]\\ni=l1.index(s)\\nif(len(l1)%2!=0):\\n    print(\\'{a:.5f}\\'.format(a=l1[i]))\\nelse:\\n    k=l1[i]+l1[i-1]\\n    print(\\'{k:.5f}\\'.format(k=k/2))"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I somehow managed to kind of understand the approach #3 and can do it on paper, but still it\\'s so hard to code it. Especially if you have limited time"
                    },
                    {
                        "username": "WAECZK",
                        "content": "I think this is one of those question that you have the remember the solution. I can tell this is a binary search problem as soon as I read the question description, but I found it difficult to solve the question even if it is my second time doing this question."
                    },
                    {
                        "username": "richardwencu92",
                        "content": "wow just coded out the optimal solution after watching a video on the logic, still a huge pain in the ass to get the indexes and corner cases taken care off"
                    },
                    {
                        "username": "Kamali_Kevin",
                        "content": "The constraints mention that none of the arrays should be empty, but the testcases actually use empty arrays..."
                    },
                    {
                        "username": "Igor_Victor",
                        "content": "For those who may not be familiar with Python: Pyhton integer division // behaves different than languages like C/C++ and many others. In Python, if you type -1//2 you get -1 whereas in other languages you\\'d get 0. In Java use Math.floorDiv"
                    },
                    {
                        "username": "Skirnir",
                        "content": "Managed to get together a logarithmic time solution by myself. The basic idea is pretty simple, but implementing and debugging is pure torture."
                    },
                    {
                        "username": "ckuhn222",
                        "content": "the median of 1 2 3 7 is 2.5 ????????????????"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "It\\'s an even sized array so there is no middle element thats why median is (2 + 3)/2;"
                    }
                ]
            },
            {
                "id": 2033705,
                "content": [
                    {
                        "username": "Food_king",
                        "content": "Hello everyone, can anyone help me, I\\'m failing a test where nums 1 [4,5,6,8,9] and nums 2 [].\\n\\nMy program outputs 6.33333, while exactly 6.00000 is expected. I don\\'T understand why this is so. \\n5 + 6 + 8 = 19/3 = 6.33333. What\\'s wrong?"
                    },
                    {
                        "username": "reassurance",
                        "content": "Hey bro.\\nAs the length of the array is odd, we take the middle element.  If the length is even then we take the mean of the 2 middle elements. What you are doing does not make sense. Hope you understand.\\nEnjoy Solving!"
                    },
                    {
                        "username": "KrisChill",
                        "content": "I am a complete beginner... But is it normal to get different return values in Pycharm and here?"
                    },
                    {
                        "username": "pothamsettisairam123",
                        "content": "what is the worng in this code\\nl1=list(map(int,input()))\\nl2=list(map(int,input()))\\nl1=l1+l2\\ns=l1[len(l1)//2]\\ni=l1.index(s)\\nif(len(l1)%2!=0):\\n    print(\\'{a:.5f}\\'.format(a=l1[i]))\\nelse:\\n    k=l1[i]+l1[i-1]\\n    print(\\'{k:.5f}\\'.format(k=k/2))"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I somehow managed to kind of understand the approach #3 and can do it on paper, but still it\\'s so hard to code it. Especially if you have limited time"
                    },
                    {
                        "username": "WAECZK",
                        "content": "I think this is one of those question that you have the remember the solution. I can tell this is a binary search problem as soon as I read the question description, but I found it difficult to solve the question even if it is my second time doing this question."
                    },
                    {
                        "username": "richardwencu92",
                        "content": "wow just coded out the optimal solution after watching a video on the logic, still a huge pain in the ass to get the indexes and corner cases taken care off"
                    },
                    {
                        "username": "Kamali_Kevin",
                        "content": "The constraints mention that none of the arrays should be empty, but the testcases actually use empty arrays..."
                    },
                    {
                        "username": "Igor_Victor",
                        "content": "For those who may not be familiar with Python: Pyhton integer division // behaves different than languages like C/C++ and many others. In Python, if you type -1//2 you get -1 whereas in other languages you\\'d get 0. In Java use Math.floorDiv"
                    },
                    {
                        "username": "Skirnir",
                        "content": "Managed to get together a logarithmic time solution by myself. The basic idea is pretty simple, but implementing and debugging is pure torture."
                    },
                    {
                        "username": "ckuhn222",
                        "content": "the median of 1 2 3 7 is 2.5 ????????????????"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "It\\'s an even sized array so there is no middle element thats why median is (2 + 3)/2;"
                    }
                ]
            },
            {
                "id": 2028066,
                "content": [
                    {
                        "username": "Food_king",
                        "content": "Hello everyone, can anyone help me, I\\'m failing a test where nums 1 [4,5,6,8,9] and nums 2 [].\\n\\nMy program outputs 6.33333, while exactly 6.00000 is expected. I don\\'T understand why this is so. \\n5 + 6 + 8 = 19/3 = 6.33333. What\\'s wrong?"
                    },
                    {
                        "username": "reassurance",
                        "content": "Hey bro.\\nAs the length of the array is odd, we take the middle element.  If the length is even then we take the mean of the 2 middle elements. What you are doing does not make sense. Hope you understand.\\nEnjoy Solving!"
                    },
                    {
                        "username": "KrisChill",
                        "content": "I am a complete beginner... But is it normal to get different return values in Pycharm and here?"
                    },
                    {
                        "username": "pothamsettisairam123",
                        "content": "what is the worng in this code\\nl1=list(map(int,input()))\\nl2=list(map(int,input()))\\nl1=l1+l2\\ns=l1[len(l1)//2]\\ni=l1.index(s)\\nif(len(l1)%2!=0):\\n    print(\\'{a:.5f}\\'.format(a=l1[i]))\\nelse:\\n    k=l1[i]+l1[i-1]\\n    print(\\'{k:.5f}\\'.format(k=k/2))"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I somehow managed to kind of understand the approach #3 and can do it on paper, but still it\\'s so hard to code it. Especially if you have limited time"
                    },
                    {
                        "username": "WAECZK",
                        "content": "I think this is one of those question that you have the remember the solution. I can tell this is a binary search problem as soon as I read the question description, but I found it difficult to solve the question even if it is my second time doing this question."
                    },
                    {
                        "username": "richardwencu92",
                        "content": "wow just coded out the optimal solution after watching a video on the logic, still a huge pain in the ass to get the indexes and corner cases taken care off"
                    },
                    {
                        "username": "Kamali_Kevin",
                        "content": "The constraints mention that none of the arrays should be empty, but the testcases actually use empty arrays..."
                    },
                    {
                        "username": "Igor_Victor",
                        "content": "For those who may not be familiar with Python: Pyhton integer division // behaves different than languages like C/C++ and many others. In Python, if you type -1//2 you get -1 whereas in other languages you\\'d get 0. In Java use Math.floorDiv"
                    },
                    {
                        "username": "Skirnir",
                        "content": "Managed to get together a logarithmic time solution by myself. The basic idea is pretty simple, but implementing and debugging is pure torture."
                    },
                    {
                        "username": "ckuhn222",
                        "content": "the median of 1 2 3 7 is 2.5 ????????????????"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "It\\'s an even sized array so there is no middle element thats why median is (2 + 3)/2;"
                    }
                ]
            },
            {
                "id": 2026880,
                "content": [
                    {
                        "username": "Food_king",
                        "content": "Hello everyone, can anyone help me, I\\'m failing a test where nums 1 [4,5,6,8,9] and nums 2 [].\\n\\nMy program outputs 6.33333, while exactly 6.00000 is expected. I don\\'T understand why this is so. \\n5 + 6 + 8 = 19/3 = 6.33333. What\\'s wrong?"
                    },
                    {
                        "username": "reassurance",
                        "content": "Hey bro.\\nAs the length of the array is odd, we take the middle element.  If the length is even then we take the mean of the 2 middle elements. What you are doing does not make sense. Hope you understand.\\nEnjoy Solving!"
                    },
                    {
                        "username": "KrisChill",
                        "content": "I am a complete beginner... But is it normal to get different return values in Pycharm and here?"
                    },
                    {
                        "username": "pothamsettisairam123",
                        "content": "what is the worng in this code\\nl1=list(map(int,input()))\\nl2=list(map(int,input()))\\nl1=l1+l2\\ns=l1[len(l1)//2]\\ni=l1.index(s)\\nif(len(l1)%2!=0):\\n    print(\\'{a:.5f}\\'.format(a=l1[i]))\\nelse:\\n    k=l1[i]+l1[i-1]\\n    print(\\'{k:.5f}\\'.format(k=k/2))"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I somehow managed to kind of understand the approach #3 and can do it on paper, but still it\\'s so hard to code it. Especially if you have limited time"
                    },
                    {
                        "username": "WAECZK",
                        "content": "I think this is one of those question that you have the remember the solution. I can tell this is a binary search problem as soon as I read the question description, but I found it difficult to solve the question even if it is my second time doing this question."
                    },
                    {
                        "username": "richardwencu92",
                        "content": "wow just coded out the optimal solution after watching a video on the logic, still a huge pain in the ass to get the indexes and corner cases taken care off"
                    },
                    {
                        "username": "Kamali_Kevin",
                        "content": "The constraints mention that none of the arrays should be empty, but the testcases actually use empty arrays..."
                    },
                    {
                        "username": "Igor_Victor",
                        "content": "For those who may not be familiar with Python: Pyhton integer division // behaves different than languages like C/C++ and many others. In Python, if you type -1//2 you get -1 whereas in other languages you\\'d get 0. In Java use Math.floorDiv"
                    },
                    {
                        "username": "Skirnir",
                        "content": "Managed to get together a logarithmic time solution by myself. The basic idea is pretty simple, but implementing and debugging is pure torture."
                    },
                    {
                        "username": "ckuhn222",
                        "content": "the median of 1 2 3 7 is 2.5 ????????????????"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "It\\'s an even sized array so there is no middle element thats why median is (2 + 3)/2;"
                    }
                ]
            },
            {
                "id": 2025271,
                "content": [
                    {
                        "username": "Food_king",
                        "content": "Hello everyone, can anyone help me, I\\'m failing a test where nums 1 [4,5,6,8,9] and nums 2 [].\\n\\nMy program outputs 6.33333, while exactly 6.00000 is expected. I don\\'T understand why this is so. \\n5 + 6 + 8 = 19/3 = 6.33333. What\\'s wrong?"
                    },
                    {
                        "username": "reassurance",
                        "content": "Hey bro.\\nAs the length of the array is odd, we take the middle element.  If the length is even then we take the mean of the 2 middle elements. What you are doing does not make sense. Hope you understand.\\nEnjoy Solving!"
                    },
                    {
                        "username": "KrisChill",
                        "content": "I am a complete beginner... But is it normal to get different return values in Pycharm and here?"
                    },
                    {
                        "username": "pothamsettisairam123",
                        "content": "what is the worng in this code\\nl1=list(map(int,input()))\\nl2=list(map(int,input()))\\nl1=l1+l2\\ns=l1[len(l1)//2]\\ni=l1.index(s)\\nif(len(l1)%2!=0):\\n    print(\\'{a:.5f}\\'.format(a=l1[i]))\\nelse:\\n    k=l1[i]+l1[i-1]\\n    print(\\'{k:.5f}\\'.format(k=k/2))"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I somehow managed to kind of understand the approach #3 and can do it on paper, but still it\\'s so hard to code it. Especially if you have limited time"
                    },
                    {
                        "username": "WAECZK",
                        "content": "I think this is one of those question that you have the remember the solution. I can tell this is a binary search problem as soon as I read the question description, but I found it difficult to solve the question even if it is my second time doing this question."
                    },
                    {
                        "username": "richardwencu92",
                        "content": "wow just coded out the optimal solution after watching a video on the logic, still a huge pain in the ass to get the indexes and corner cases taken care off"
                    },
                    {
                        "username": "Kamali_Kevin",
                        "content": "The constraints mention that none of the arrays should be empty, but the testcases actually use empty arrays..."
                    },
                    {
                        "username": "Igor_Victor",
                        "content": "For those who may not be familiar with Python: Pyhton integer division // behaves different than languages like C/C++ and many others. In Python, if you type -1//2 you get -1 whereas in other languages you\\'d get 0. In Java use Math.floorDiv"
                    },
                    {
                        "username": "Skirnir",
                        "content": "Managed to get together a logarithmic time solution by myself. The basic idea is pretty simple, but implementing and debugging is pure torture."
                    },
                    {
                        "username": "ckuhn222",
                        "content": "the median of 1 2 3 7 is 2.5 ????????????????"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "It\\'s an even sized array so there is no middle element thats why median is (2 + 3)/2;"
                    }
                ]
            },
            {
                "id": 2024964,
                "content": [
                    {
                        "username": "Food_king",
                        "content": "Hello everyone, can anyone help me, I\\'m failing a test where nums 1 [4,5,6,8,9] and nums 2 [].\\n\\nMy program outputs 6.33333, while exactly 6.00000 is expected. I don\\'T understand why this is so. \\n5 + 6 + 8 = 19/3 = 6.33333. What\\'s wrong?"
                    },
                    {
                        "username": "reassurance",
                        "content": "Hey bro.\\nAs the length of the array is odd, we take the middle element.  If the length is even then we take the mean of the 2 middle elements. What you are doing does not make sense. Hope you understand.\\nEnjoy Solving!"
                    },
                    {
                        "username": "KrisChill",
                        "content": "I am a complete beginner... But is it normal to get different return values in Pycharm and here?"
                    },
                    {
                        "username": "pothamsettisairam123",
                        "content": "what is the worng in this code\\nl1=list(map(int,input()))\\nl2=list(map(int,input()))\\nl1=l1+l2\\ns=l1[len(l1)//2]\\ni=l1.index(s)\\nif(len(l1)%2!=0):\\n    print(\\'{a:.5f}\\'.format(a=l1[i]))\\nelse:\\n    k=l1[i]+l1[i-1]\\n    print(\\'{k:.5f}\\'.format(k=k/2))"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I somehow managed to kind of understand the approach #3 and can do it on paper, but still it\\'s so hard to code it. Especially if you have limited time"
                    },
                    {
                        "username": "WAECZK",
                        "content": "I think this is one of those question that you have the remember the solution. I can tell this is a binary search problem as soon as I read the question description, but I found it difficult to solve the question even if it is my second time doing this question."
                    },
                    {
                        "username": "richardwencu92",
                        "content": "wow just coded out the optimal solution after watching a video on the logic, still a huge pain in the ass to get the indexes and corner cases taken care off"
                    },
                    {
                        "username": "Kamali_Kevin",
                        "content": "The constraints mention that none of the arrays should be empty, but the testcases actually use empty arrays..."
                    },
                    {
                        "username": "Igor_Victor",
                        "content": "For those who may not be familiar with Python: Pyhton integer division // behaves different than languages like C/C++ and many others. In Python, if you type -1//2 you get -1 whereas in other languages you\\'d get 0. In Java use Math.floorDiv"
                    },
                    {
                        "username": "Skirnir",
                        "content": "Managed to get together a logarithmic time solution by myself. The basic idea is pretty simple, but implementing and debugging is pure torture."
                    },
                    {
                        "username": "ckuhn222",
                        "content": "the median of 1 2 3 7 is 2.5 ????????????????"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "It\\'s an even sized array so there is no middle element thats why median is (2 + 3)/2;"
                    }
                ]
            },
            {
                "id": 2016901,
                "content": [
                    {
                        "username": "Food_king",
                        "content": "Hello everyone, can anyone help me, I\\'m failing a test where nums 1 [4,5,6,8,9] and nums 2 [].\\n\\nMy program outputs 6.33333, while exactly 6.00000 is expected. I don\\'T understand why this is so. \\n5 + 6 + 8 = 19/3 = 6.33333. What\\'s wrong?"
                    },
                    {
                        "username": "reassurance",
                        "content": "Hey bro.\\nAs the length of the array is odd, we take the middle element.  If the length is even then we take the mean of the 2 middle elements. What you are doing does not make sense. Hope you understand.\\nEnjoy Solving!"
                    },
                    {
                        "username": "KrisChill",
                        "content": "I am a complete beginner... But is it normal to get different return values in Pycharm and here?"
                    },
                    {
                        "username": "pothamsettisairam123",
                        "content": "what is the worng in this code\\nl1=list(map(int,input()))\\nl2=list(map(int,input()))\\nl1=l1+l2\\ns=l1[len(l1)//2]\\ni=l1.index(s)\\nif(len(l1)%2!=0):\\n    print(\\'{a:.5f}\\'.format(a=l1[i]))\\nelse:\\n    k=l1[i]+l1[i-1]\\n    print(\\'{k:.5f}\\'.format(k=k/2))"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I somehow managed to kind of understand the approach #3 and can do it on paper, but still it\\'s so hard to code it. Especially if you have limited time"
                    },
                    {
                        "username": "WAECZK",
                        "content": "I think this is one of those question that you have the remember the solution. I can tell this is a binary search problem as soon as I read the question description, but I found it difficult to solve the question even if it is my second time doing this question."
                    },
                    {
                        "username": "richardwencu92",
                        "content": "wow just coded out the optimal solution after watching a video on the logic, still a huge pain in the ass to get the indexes and corner cases taken care off"
                    },
                    {
                        "username": "Kamali_Kevin",
                        "content": "The constraints mention that none of the arrays should be empty, but the testcases actually use empty arrays..."
                    },
                    {
                        "username": "Igor_Victor",
                        "content": "For those who may not be familiar with Python: Pyhton integer division // behaves different than languages like C/C++ and many others. In Python, if you type -1//2 you get -1 whereas in other languages you\\'d get 0. In Java use Math.floorDiv"
                    },
                    {
                        "username": "Skirnir",
                        "content": "Managed to get together a logarithmic time solution by myself. The basic idea is pretty simple, but implementing and debugging is pure torture."
                    },
                    {
                        "username": "ckuhn222",
                        "content": "the median of 1 2 3 7 is 2.5 ????????????????"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "It\\'s an even sized array so there is no middle element thats why median is (2 + 3)/2;"
                    }
                ]
            },
            {
                "id": 2015833,
                "content": [
                    {
                        "username": "Food_king",
                        "content": "Hello everyone, can anyone help me, I\\'m failing a test where nums 1 [4,5,6,8,9] and nums 2 [].\\n\\nMy program outputs 6.33333, while exactly 6.00000 is expected. I don\\'T understand why this is so. \\n5 + 6 + 8 = 19/3 = 6.33333. What\\'s wrong?"
                    },
                    {
                        "username": "reassurance",
                        "content": "Hey bro.\\nAs the length of the array is odd, we take the middle element.  If the length is even then we take the mean of the 2 middle elements. What you are doing does not make sense. Hope you understand.\\nEnjoy Solving!"
                    },
                    {
                        "username": "KrisChill",
                        "content": "I am a complete beginner... But is it normal to get different return values in Pycharm and here?"
                    },
                    {
                        "username": "pothamsettisairam123",
                        "content": "what is the worng in this code\\nl1=list(map(int,input()))\\nl2=list(map(int,input()))\\nl1=l1+l2\\ns=l1[len(l1)//2]\\ni=l1.index(s)\\nif(len(l1)%2!=0):\\n    print(\\'{a:.5f}\\'.format(a=l1[i]))\\nelse:\\n    k=l1[i]+l1[i-1]\\n    print(\\'{k:.5f}\\'.format(k=k/2))"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I somehow managed to kind of understand the approach #3 and can do it on paper, but still it\\'s so hard to code it. Especially if you have limited time"
                    },
                    {
                        "username": "WAECZK",
                        "content": "I think this is one of those question that you have the remember the solution. I can tell this is a binary search problem as soon as I read the question description, but I found it difficult to solve the question even if it is my second time doing this question."
                    },
                    {
                        "username": "richardwencu92",
                        "content": "wow just coded out the optimal solution after watching a video on the logic, still a huge pain in the ass to get the indexes and corner cases taken care off"
                    },
                    {
                        "username": "Kamali_Kevin",
                        "content": "The constraints mention that none of the arrays should be empty, but the testcases actually use empty arrays..."
                    },
                    {
                        "username": "Igor_Victor",
                        "content": "For those who may not be familiar with Python: Pyhton integer division // behaves different than languages like C/C++ and many others. In Python, if you type -1//2 you get -1 whereas in other languages you\\'d get 0. In Java use Math.floorDiv"
                    },
                    {
                        "username": "Skirnir",
                        "content": "Managed to get together a logarithmic time solution by myself. The basic idea is pretty simple, but implementing and debugging is pure torture."
                    },
                    {
                        "username": "ckuhn222",
                        "content": "the median of 1 2 3 7 is 2.5 ????????????????"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "It\\'s an even sized array so there is no middle element thats why median is (2 + 3)/2;"
                    }
                ]
            },
            {
                "id": 2014224,
                "content": [
                    {
                        "username": "Food_king",
                        "content": "Hello everyone, can anyone help me, I\\'m failing a test where nums 1 [4,5,6,8,9] and nums 2 [].\\n\\nMy program outputs 6.33333, while exactly 6.00000 is expected. I don\\'T understand why this is so. \\n5 + 6 + 8 = 19/3 = 6.33333. What\\'s wrong?"
                    },
                    {
                        "username": "reassurance",
                        "content": "Hey bro.\\nAs the length of the array is odd, we take the middle element.  If the length is even then we take the mean of the 2 middle elements. What you are doing does not make sense. Hope you understand.\\nEnjoy Solving!"
                    },
                    {
                        "username": "KrisChill",
                        "content": "I am a complete beginner... But is it normal to get different return values in Pycharm and here?"
                    },
                    {
                        "username": "pothamsettisairam123",
                        "content": "what is the worng in this code\\nl1=list(map(int,input()))\\nl2=list(map(int,input()))\\nl1=l1+l2\\ns=l1[len(l1)//2]\\ni=l1.index(s)\\nif(len(l1)%2!=0):\\n    print(\\'{a:.5f}\\'.format(a=l1[i]))\\nelse:\\n    k=l1[i]+l1[i-1]\\n    print(\\'{k:.5f}\\'.format(k=k/2))"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I somehow managed to kind of understand the approach #3 and can do it on paper, but still it\\'s so hard to code it. Especially if you have limited time"
                    },
                    {
                        "username": "WAECZK",
                        "content": "I think this is one of those question that you have the remember the solution. I can tell this is a binary search problem as soon as I read the question description, but I found it difficult to solve the question even if it is my second time doing this question."
                    },
                    {
                        "username": "richardwencu92",
                        "content": "wow just coded out the optimal solution after watching a video on the logic, still a huge pain in the ass to get the indexes and corner cases taken care off"
                    },
                    {
                        "username": "Kamali_Kevin",
                        "content": "The constraints mention that none of the arrays should be empty, but the testcases actually use empty arrays..."
                    },
                    {
                        "username": "Igor_Victor",
                        "content": "For those who may not be familiar with Python: Pyhton integer division // behaves different than languages like C/C++ and many others. In Python, if you type -1//2 you get -1 whereas in other languages you\\'d get 0. In Java use Math.floorDiv"
                    },
                    {
                        "username": "Skirnir",
                        "content": "Managed to get together a logarithmic time solution by myself. The basic idea is pretty simple, but implementing and debugging is pure torture."
                    },
                    {
                        "username": "ckuhn222",
                        "content": "the median of 1 2 3 7 is 2.5 ????????????????"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "It\\'s an even sized array so there is no middle element thats why median is (2 + 3)/2;"
                    }
                ]
            },
            {
                "id": 2010895,
                "content": [
                    {
                        "username": "Food_king",
                        "content": "Hello everyone, can anyone help me, I\\'m failing a test where nums 1 [4,5,6,8,9] and nums 2 [].\\n\\nMy program outputs 6.33333, while exactly 6.00000 is expected. I don\\'T understand why this is so. \\n5 + 6 + 8 = 19/3 = 6.33333. What\\'s wrong?"
                    },
                    {
                        "username": "reassurance",
                        "content": "Hey bro.\\nAs the length of the array is odd, we take the middle element.  If the length is even then we take the mean of the 2 middle elements. What you are doing does not make sense. Hope you understand.\\nEnjoy Solving!"
                    },
                    {
                        "username": "KrisChill",
                        "content": "I am a complete beginner... But is it normal to get different return values in Pycharm and here?"
                    },
                    {
                        "username": "pothamsettisairam123",
                        "content": "what is the worng in this code\\nl1=list(map(int,input()))\\nl2=list(map(int,input()))\\nl1=l1+l2\\ns=l1[len(l1)//2]\\ni=l1.index(s)\\nif(len(l1)%2!=0):\\n    print(\\'{a:.5f}\\'.format(a=l1[i]))\\nelse:\\n    k=l1[i]+l1[i-1]\\n    print(\\'{k:.5f}\\'.format(k=k/2))"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I somehow managed to kind of understand the approach #3 and can do it on paper, but still it\\'s so hard to code it. Especially if you have limited time"
                    },
                    {
                        "username": "WAECZK",
                        "content": "I think this is one of those question that you have the remember the solution. I can tell this is a binary search problem as soon as I read the question description, but I found it difficult to solve the question even if it is my second time doing this question."
                    },
                    {
                        "username": "richardwencu92",
                        "content": "wow just coded out the optimal solution after watching a video on the logic, still a huge pain in the ass to get the indexes and corner cases taken care off"
                    },
                    {
                        "username": "Kamali_Kevin",
                        "content": "The constraints mention that none of the arrays should be empty, but the testcases actually use empty arrays..."
                    },
                    {
                        "username": "Igor_Victor",
                        "content": "For those who may not be familiar with Python: Pyhton integer division // behaves different than languages like C/C++ and many others. In Python, if you type -1//2 you get -1 whereas in other languages you\\'d get 0. In Java use Math.floorDiv"
                    },
                    {
                        "username": "Skirnir",
                        "content": "Managed to get together a logarithmic time solution by myself. The basic idea is pretty simple, but implementing and debugging is pure torture."
                    },
                    {
                        "username": "ckuhn222",
                        "content": "the median of 1 2 3 7 is 2.5 ????????????????"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "It\\'s an even sized array so there is no middle element thats why median is (2 + 3)/2;"
                    }
                ]
            },
            {
                "id": 2006045,
                "content": [
                    {
                        "username": "BajuMcBites",
                        "content": "This question made me want to quit computer science and switch to a communications major."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Create two pointers, i and j, initialized to 0, to traverse nums1 and nums2, respectively.\\n- Create an array mergedArr of size n1 + n2 to store the merged and sorted elements from both arrays.\\n- Iterate through nums1 and nums2 using the pointers i and j until either of them reaches the end of its respective array.\\n- Compare the current elements at nums1[i] and nums2[j], and add the smaller one to mergedArr. Increment the corresponding pointer (i or j) to move to the next element.\\n- After the loop ends, if there are any remaining elements in nums1 or nums2, add them to mergedArr.\\n- Calculate the median based on the length of mergedArr. If the total number of elements in mergedArr is odd, return the middle element; otherwise, return the average of the two middle elements."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can follow a similar approach of merging the arrays and then calculating the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.50000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3, 4]` is obtained from merging `nums1` and `nums2`, and the median is `(2 + 3) / 2 = 2.5`."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can merge both arrays into one sorted array and then calculate the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 3]\\nnums2 = [2]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.00000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3]` is obtained from merging `nums1` and `nums2`, and the median is `2.00000`."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "aint no way its a hard problem"
                    },
                    {
                        "username": "VAImanu",
                        "content": "so the ques I am solving is  **Median of Two Sorted Arrays**\\n\\nI have written a c code. My approach being:\\n\\nsort the arrays using same method as sort and merge 2 linked list; i.e take 2 indices for both arrays\\nthen move the indices in a preferable method.\\n\\nC code:\\n    double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int p1=nums1[0];\\n    int p2=nums2[0];\\n    int k=nums1Size+nums2Size;\\n    int size=0;\\n    int *nums3=(int *)malloc(k*sizeof(int));\\n    for(int i=0;i<k;i++){\\n      nums3[k]=0;\\n  }\\n  while(p1<nums1Size && p2<nums2Size){\\n    if(nums1[p1]<=nums2[p2]){\\n      nums3[size++]=nums1[p1];\\n      p1++;\\n    }\\n    else if(nums1[p1]>nums2[p2]){\\n      nums3[size++]=nums1[p2];\\n      p2++;\\n    }\\n  }\\n  while(p1<nums1Size){\\n    nums3[size++]=nums1[p1];\\n    p1++;\\n  }\\n  while(p2<nums2Size){\\n    nums3[size++]=nums2[p2];\\n    p2++;\\n  }\\n\\n  //find median:\\n  int l=sizeof(nums3)/sizeof(int);\\n  if(l%2!=0){\\n    return nums3[(l/2)];\\n  }\\n  else{\\n    int res=(nums3[(l/2)-1]+nums3[(l/2)])/2;\\n    return res;\\n  }\\n}`\\n\\nerror i got:\\n=================================================================\\n==22==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000005c at pc 0x55e14680b405 bp 0x7ffe10458290 sp 0x7ffe10458280\\nWRITE of size 4 at 0x60200000005c thread T0\\n    #2 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x60200000005c is located 0 bytes to the right of 12-byte region [0x602000000050,0x60200000005c)\\nallocated by thread T0 here:\\n    #0 0x7f532f8a8808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00 fa fa fa 04 fa fa fa 00[04]fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==22==ABORTING\\n\\nWhy am i getting this error?`"
                    },
                    {
                        "username": "reassurance",
                        "content": "Petition to move it to Medium category"
                    },
                    {
                        "username": "Zefick",
                        "content": "[@psionl0](/psionl0) I think this is just trolling, because many of the problems on Leetcode have wrong/inaccurate difficulty."
                    },
                    {
                        "username": "psionl0",
                        "content": "Why? You couldn\\'t come up with the O(log(m+n)) solution."
                    },
                    {
                        "username": "mindgspl",
                        "content": "Do the array values might be duplicated ? Like for example :\\nn = [-3,-1,0,0,1]\\nm = [-6,-4,-2,0,0,0,1,1,1]\\nIf so, what is the median value we are looking for , -3 ?  as in :\\nnm_sorted = [-6,-4,-3,-2,-1,0,1]"
                    },
                    {
                        "username": "zeinhg",
                        "content": "You don\\'t need to remove the duplications.\\nnm_sorted = [-6,-4,-3,-2,-1,0,0,0,0,0,1,1,1,1], and median = 0"
                    },
                    {
                        "username": "kirubeltekle1422",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        if len(nums1)==0 and len(nums2)==0:\\n            return None\\n        else:\\n            for i in nums1:\\n                nums2.append(i)\\n            nums2.sort()\\n            if len(nums2) % 2 == 0:\\n                i = int(len(nums2)/2)\\n                return (nums2[i] + nums2[i - 1])/2\\n            else:\\n                j = int((len(nums2) - 1))\\n                return float(nums2[j-1])\\n\\nwhy the output for [1,2] and [3,4] 2.0 for the above code as provided by the result tab\\n"
                    },
                    {
                        "username": "Dee0586",
                        "content": "list index out of range"
                    }
                ]
            },
            {
                "id": 2004021,
                "content": [
                    {
                        "username": "BajuMcBites",
                        "content": "This question made me want to quit computer science and switch to a communications major."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Create two pointers, i and j, initialized to 0, to traverse nums1 and nums2, respectively.\\n- Create an array mergedArr of size n1 + n2 to store the merged and sorted elements from both arrays.\\n- Iterate through nums1 and nums2 using the pointers i and j until either of them reaches the end of its respective array.\\n- Compare the current elements at nums1[i] and nums2[j], and add the smaller one to mergedArr. Increment the corresponding pointer (i or j) to move to the next element.\\n- After the loop ends, if there are any remaining elements in nums1 or nums2, add them to mergedArr.\\n- Calculate the median based on the length of mergedArr. If the total number of elements in mergedArr is odd, return the middle element; otherwise, return the average of the two middle elements."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can follow a similar approach of merging the arrays and then calculating the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.50000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3, 4]` is obtained from merging `nums1` and `nums2`, and the median is `(2 + 3) / 2 = 2.5`."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can merge both arrays into one sorted array and then calculate the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 3]\\nnums2 = [2]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.00000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3]` is obtained from merging `nums1` and `nums2`, and the median is `2.00000`."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "aint no way its a hard problem"
                    },
                    {
                        "username": "VAImanu",
                        "content": "so the ques I am solving is  **Median of Two Sorted Arrays**\\n\\nI have written a c code. My approach being:\\n\\nsort the arrays using same method as sort and merge 2 linked list; i.e take 2 indices for both arrays\\nthen move the indices in a preferable method.\\n\\nC code:\\n    double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int p1=nums1[0];\\n    int p2=nums2[0];\\n    int k=nums1Size+nums2Size;\\n    int size=0;\\n    int *nums3=(int *)malloc(k*sizeof(int));\\n    for(int i=0;i<k;i++){\\n      nums3[k]=0;\\n  }\\n  while(p1<nums1Size && p2<nums2Size){\\n    if(nums1[p1]<=nums2[p2]){\\n      nums3[size++]=nums1[p1];\\n      p1++;\\n    }\\n    else if(nums1[p1]>nums2[p2]){\\n      nums3[size++]=nums1[p2];\\n      p2++;\\n    }\\n  }\\n  while(p1<nums1Size){\\n    nums3[size++]=nums1[p1];\\n    p1++;\\n  }\\n  while(p2<nums2Size){\\n    nums3[size++]=nums2[p2];\\n    p2++;\\n  }\\n\\n  //find median:\\n  int l=sizeof(nums3)/sizeof(int);\\n  if(l%2!=0){\\n    return nums3[(l/2)];\\n  }\\n  else{\\n    int res=(nums3[(l/2)-1]+nums3[(l/2)])/2;\\n    return res;\\n  }\\n}`\\n\\nerror i got:\\n=================================================================\\n==22==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000005c at pc 0x55e14680b405 bp 0x7ffe10458290 sp 0x7ffe10458280\\nWRITE of size 4 at 0x60200000005c thread T0\\n    #2 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x60200000005c is located 0 bytes to the right of 12-byte region [0x602000000050,0x60200000005c)\\nallocated by thread T0 here:\\n    #0 0x7f532f8a8808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00 fa fa fa 04 fa fa fa 00[04]fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==22==ABORTING\\n\\nWhy am i getting this error?`"
                    },
                    {
                        "username": "reassurance",
                        "content": "Petition to move it to Medium category"
                    },
                    {
                        "username": "Zefick",
                        "content": "[@psionl0](/psionl0) I think this is just trolling, because many of the problems on Leetcode have wrong/inaccurate difficulty."
                    },
                    {
                        "username": "psionl0",
                        "content": "Why? You couldn\\'t come up with the O(log(m+n)) solution."
                    },
                    {
                        "username": "mindgspl",
                        "content": "Do the array values might be duplicated ? Like for example :\\nn = [-3,-1,0,0,1]\\nm = [-6,-4,-2,0,0,0,1,1,1]\\nIf so, what is the median value we are looking for , -3 ?  as in :\\nnm_sorted = [-6,-4,-3,-2,-1,0,1]"
                    },
                    {
                        "username": "zeinhg",
                        "content": "You don\\'t need to remove the duplications.\\nnm_sorted = [-6,-4,-3,-2,-1,0,0,0,0,0,1,1,1,1], and median = 0"
                    },
                    {
                        "username": "kirubeltekle1422",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        if len(nums1)==0 and len(nums2)==0:\\n            return None\\n        else:\\n            for i in nums1:\\n                nums2.append(i)\\n            nums2.sort()\\n            if len(nums2) % 2 == 0:\\n                i = int(len(nums2)/2)\\n                return (nums2[i] + nums2[i - 1])/2\\n            else:\\n                j = int((len(nums2) - 1))\\n                return float(nums2[j-1])\\n\\nwhy the output for [1,2] and [3,4] 2.0 for the above code as provided by the result tab\\n"
                    },
                    {
                        "username": "Dee0586",
                        "content": "list index out of range"
                    }
                ]
            },
            {
                "id": 1995201,
                "content": [
                    {
                        "username": "BajuMcBites",
                        "content": "This question made me want to quit computer science and switch to a communications major."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Create two pointers, i and j, initialized to 0, to traverse nums1 and nums2, respectively.\\n- Create an array mergedArr of size n1 + n2 to store the merged and sorted elements from both arrays.\\n- Iterate through nums1 and nums2 using the pointers i and j until either of them reaches the end of its respective array.\\n- Compare the current elements at nums1[i] and nums2[j], and add the smaller one to mergedArr. Increment the corresponding pointer (i or j) to move to the next element.\\n- After the loop ends, if there are any remaining elements in nums1 or nums2, add them to mergedArr.\\n- Calculate the median based on the length of mergedArr. If the total number of elements in mergedArr is odd, return the middle element; otherwise, return the average of the two middle elements."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can follow a similar approach of merging the arrays and then calculating the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.50000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3, 4]` is obtained from merging `nums1` and `nums2`, and the median is `(2 + 3) / 2 = 2.5`."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can merge both arrays into one sorted array and then calculate the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 3]\\nnums2 = [2]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.00000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3]` is obtained from merging `nums1` and `nums2`, and the median is `2.00000`."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "aint no way its a hard problem"
                    },
                    {
                        "username": "VAImanu",
                        "content": "so the ques I am solving is  **Median of Two Sorted Arrays**\\n\\nI have written a c code. My approach being:\\n\\nsort the arrays using same method as sort and merge 2 linked list; i.e take 2 indices for both arrays\\nthen move the indices in a preferable method.\\n\\nC code:\\n    double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int p1=nums1[0];\\n    int p2=nums2[0];\\n    int k=nums1Size+nums2Size;\\n    int size=0;\\n    int *nums3=(int *)malloc(k*sizeof(int));\\n    for(int i=0;i<k;i++){\\n      nums3[k]=0;\\n  }\\n  while(p1<nums1Size && p2<nums2Size){\\n    if(nums1[p1]<=nums2[p2]){\\n      nums3[size++]=nums1[p1];\\n      p1++;\\n    }\\n    else if(nums1[p1]>nums2[p2]){\\n      nums3[size++]=nums1[p2];\\n      p2++;\\n    }\\n  }\\n  while(p1<nums1Size){\\n    nums3[size++]=nums1[p1];\\n    p1++;\\n  }\\n  while(p2<nums2Size){\\n    nums3[size++]=nums2[p2];\\n    p2++;\\n  }\\n\\n  //find median:\\n  int l=sizeof(nums3)/sizeof(int);\\n  if(l%2!=0){\\n    return nums3[(l/2)];\\n  }\\n  else{\\n    int res=(nums3[(l/2)-1]+nums3[(l/2)])/2;\\n    return res;\\n  }\\n}`\\n\\nerror i got:\\n=================================================================\\n==22==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000005c at pc 0x55e14680b405 bp 0x7ffe10458290 sp 0x7ffe10458280\\nWRITE of size 4 at 0x60200000005c thread T0\\n    #2 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x60200000005c is located 0 bytes to the right of 12-byte region [0x602000000050,0x60200000005c)\\nallocated by thread T0 here:\\n    #0 0x7f532f8a8808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00 fa fa fa 04 fa fa fa 00[04]fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==22==ABORTING\\n\\nWhy am i getting this error?`"
                    },
                    {
                        "username": "reassurance",
                        "content": "Petition to move it to Medium category"
                    },
                    {
                        "username": "Zefick",
                        "content": "[@psionl0](/psionl0) I think this is just trolling, because many of the problems on Leetcode have wrong/inaccurate difficulty."
                    },
                    {
                        "username": "psionl0",
                        "content": "Why? You couldn\\'t come up with the O(log(m+n)) solution."
                    },
                    {
                        "username": "mindgspl",
                        "content": "Do the array values might be duplicated ? Like for example :\\nn = [-3,-1,0,0,1]\\nm = [-6,-4,-2,0,0,0,1,1,1]\\nIf so, what is the median value we are looking for , -3 ?  as in :\\nnm_sorted = [-6,-4,-3,-2,-1,0,1]"
                    },
                    {
                        "username": "zeinhg",
                        "content": "You don\\'t need to remove the duplications.\\nnm_sorted = [-6,-4,-3,-2,-1,0,0,0,0,0,1,1,1,1], and median = 0"
                    },
                    {
                        "username": "kirubeltekle1422",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        if len(nums1)==0 and len(nums2)==0:\\n            return None\\n        else:\\n            for i in nums1:\\n                nums2.append(i)\\n            nums2.sort()\\n            if len(nums2) % 2 == 0:\\n                i = int(len(nums2)/2)\\n                return (nums2[i] + nums2[i - 1])/2\\n            else:\\n                j = int((len(nums2) - 1))\\n                return float(nums2[j-1])\\n\\nwhy the output for [1,2] and [3,4] 2.0 for the above code as provided by the result tab\\n"
                    },
                    {
                        "username": "Dee0586",
                        "content": "list index out of range"
                    }
                ]
            },
            {
                "id": 1995200,
                "content": [
                    {
                        "username": "BajuMcBites",
                        "content": "This question made me want to quit computer science and switch to a communications major."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Create two pointers, i and j, initialized to 0, to traverse nums1 and nums2, respectively.\\n- Create an array mergedArr of size n1 + n2 to store the merged and sorted elements from both arrays.\\n- Iterate through nums1 and nums2 using the pointers i and j until either of them reaches the end of its respective array.\\n- Compare the current elements at nums1[i] and nums2[j], and add the smaller one to mergedArr. Increment the corresponding pointer (i or j) to move to the next element.\\n- After the loop ends, if there are any remaining elements in nums1 or nums2, add them to mergedArr.\\n- Calculate the median based on the length of mergedArr. If the total number of elements in mergedArr is odd, return the middle element; otherwise, return the average of the two middle elements."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can follow a similar approach of merging the arrays and then calculating the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.50000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3, 4]` is obtained from merging `nums1` and `nums2`, and the median is `(2 + 3) / 2 = 2.5`."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can merge both arrays into one sorted array and then calculate the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 3]\\nnums2 = [2]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.00000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3]` is obtained from merging `nums1` and `nums2`, and the median is `2.00000`."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "aint no way its a hard problem"
                    },
                    {
                        "username": "VAImanu",
                        "content": "so the ques I am solving is  **Median of Two Sorted Arrays**\\n\\nI have written a c code. My approach being:\\n\\nsort the arrays using same method as sort and merge 2 linked list; i.e take 2 indices for both arrays\\nthen move the indices in a preferable method.\\n\\nC code:\\n    double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int p1=nums1[0];\\n    int p2=nums2[0];\\n    int k=nums1Size+nums2Size;\\n    int size=0;\\n    int *nums3=(int *)malloc(k*sizeof(int));\\n    for(int i=0;i<k;i++){\\n      nums3[k]=0;\\n  }\\n  while(p1<nums1Size && p2<nums2Size){\\n    if(nums1[p1]<=nums2[p2]){\\n      nums3[size++]=nums1[p1];\\n      p1++;\\n    }\\n    else if(nums1[p1]>nums2[p2]){\\n      nums3[size++]=nums1[p2];\\n      p2++;\\n    }\\n  }\\n  while(p1<nums1Size){\\n    nums3[size++]=nums1[p1];\\n    p1++;\\n  }\\n  while(p2<nums2Size){\\n    nums3[size++]=nums2[p2];\\n    p2++;\\n  }\\n\\n  //find median:\\n  int l=sizeof(nums3)/sizeof(int);\\n  if(l%2!=0){\\n    return nums3[(l/2)];\\n  }\\n  else{\\n    int res=(nums3[(l/2)-1]+nums3[(l/2)])/2;\\n    return res;\\n  }\\n}`\\n\\nerror i got:\\n=================================================================\\n==22==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000005c at pc 0x55e14680b405 bp 0x7ffe10458290 sp 0x7ffe10458280\\nWRITE of size 4 at 0x60200000005c thread T0\\n    #2 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x60200000005c is located 0 bytes to the right of 12-byte region [0x602000000050,0x60200000005c)\\nallocated by thread T0 here:\\n    #0 0x7f532f8a8808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00 fa fa fa 04 fa fa fa 00[04]fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==22==ABORTING\\n\\nWhy am i getting this error?`"
                    },
                    {
                        "username": "reassurance",
                        "content": "Petition to move it to Medium category"
                    },
                    {
                        "username": "Zefick",
                        "content": "[@psionl0](/psionl0) I think this is just trolling, because many of the problems on Leetcode have wrong/inaccurate difficulty."
                    },
                    {
                        "username": "psionl0",
                        "content": "Why? You couldn\\'t come up with the O(log(m+n)) solution."
                    },
                    {
                        "username": "mindgspl",
                        "content": "Do the array values might be duplicated ? Like for example :\\nn = [-3,-1,0,0,1]\\nm = [-6,-4,-2,0,0,0,1,1,1]\\nIf so, what is the median value we are looking for , -3 ?  as in :\\nnm_sorted = [-6,-4,-3,-2,-1,0,1]"
                    },
                    {
                        "username": "zeinhg",
                        "content": "You don\\'t need to remove the duplications.\\nnm_sorted = [-6,-4,-3,-2,-1,0,0,0,0,0,1,1,1,1], and median = 0"
                    },
                    {
                        "username": "kirubeltekle1422",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        if len(nums1)==0 and len(nums2)==0:\\n            return None\\n        else:\\n            for i in nums1:\\n                nums2.append(i)\\n            nums2.sort()\\n            if len(nums2) % 2 == 0:\\n                i = int(len(nums2)/2)\\n                return (nums2[i] + nums2[i - 1])/2\\n            else:\\n                j = int((len(nums2) - 1))\\n                return float(nums2[j-1])\\n\\nwhy the output for [1,2] and [3,4] 2.0 for the above code as provided by the result tab\\n"
                    },
                    {
                        "username": "Dee0586",
                        "content": "list index out of range"
                    }
                ]
            },
            {
                "id": 1991144,
                "content": [
                    {
                        "username": "BajuMcBites",
                        "content": "This question made me want to quit computer science and switch to a communications major."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Create two pointers, i and j, initialized to 0, to traverse nums1 and nums2, respectively.\\n- Create an array mergedArr of size n1 + n2 to store the merged and sorted elements from both arrays.\\n- Iterate through nums1 and nums2 using the pointers i and j until either of them reaches the end of its respective array.\\n- Compare the current elements at nums1[i] and nums2[j], and add the smaller one to mergedArr. Increment the corresponding pointer (i or j) to move to the next element.\\n- After the loop ends, if there are any remaining elements in nums1 or nums2, add them to mergedArr.\\n- Calculate the median based on the length of mergedArr. If the total number of elements in mergedArr is odd, return the middle element; otherwise, return the average of the two middle elements."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can follow a similar approach of merging the arrays and then calculating the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.50000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3, 4]` is obtained from merging `nums1` and `nums2`, and the median is `(2 + 3) / 2 = 2.5`."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can merge both arrays into one sorted array and then calculate the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 3]\\nnums2 = [2]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.00000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3]` is obtained from merging `nums1` and `nums2`, and the median is `2.00000`."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "aint no way its a hard problem"
                    },
                    {
                        "username": "VAImanu",
                        "content": "so the ques I am solving is  **Median of Two Sorted Arrays**\\n\\nI have written a c code. My approach being:\\n\\nsort the arrays using same method as sort and merge 2 linked list; i.e take 2 indices for both arrays\\nthen move the indices in a preferable method.\\n\\nC code:\\n    double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int p1=nums1[0];\\n    int p2=nums2[0];\\n    int k=nums1Size+nums2Size;\\n    int size=0;\\n    int *nums3=(int *)malloc(k*sizeof(int));\\n    for(int i=0;i<k;i++){\\n      nums3[k]=0;\\n  }\\n  while(p1<nums1Size && p2<nums2Size){\\n    if(nums1[p1]<=nums2[p2]){\\n      nums3[size++]=nums1[p1];\\n      p1++;\\n    }\\n    else if(nums1[p1]>nums2[p2]){\\n      nums3[size++]=nums1[p2];\\n      p2++;\\n    }\\n  }\\n  while(p1<nums1Size){\\n    nums3[size++]=nums1[p1];\\n    p1++;\\n  }\\n  while(p2<nums2Size){\\n    nums3[size++]=nums2[p2];\\n    p2++;\\n  }\\n\\n  //find median:\\n  int l=sizeof(nums3)/sizeof(int);\\n  if(l%2!=0){\\n    return nums3[(l/2)];\\n  }\\n  else{\\n    int res=(nums3[(l/2)-1]+nums3[(l/2)])/2;\\n    return res;\\n  }\\n}`\\n\\nerror i got:\\n=================================================================\\n==22==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000005c at pc 0x55e14680b405 bp 0x7ffe10458290 sp 0x7ffe10458280\\nWRITE of size 4 at 0x60200000005c thread T0\\n    #2 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x60200000005c is located 0 bytes to the right of 12-byte region [0x602000000050,0x60200000005c)\\nallocated by thread T0 here:\\n    #0 0x7f532f8a8808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00 fa fa fa 04 fa fa fa 00[04]fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==22==ABORTING\\n\\nWhy am i getting this error?`"
                    },
                    {
                        "username": "reassurance",
                        "content": "Petition to move it to Medium category"
                    },
                    {
                        "username": "Zefick",
                        "content": "[@psionl0](/psionl0) I think this is just trolling, because many of the problems on Leetcode have wrong/inaccurate difficulty."
                    },
                    {
                        "username": "psionl0",
                        "content": "Why? You couldn\\'t come up with the O(log(m+n)) solution."
                    },
                    {
                        "username": "mindgspl",
                        "content": "Do the array values might be duplicated ? Like for example :\\nn = [-3,-1,0,0,1]\\nm = [-6,-4,-2,0,0,0,1,1,1]\\nIf so, what is the median value we are looking for , -3 ?  as in :\\nnm_sorted = [-6,-4,-3,-2,-1,0,1]"
                    },
                    {
                        "username": "zeinhg",
                        "content": "You don\\'t need to remove the duplications.\\nnm_sorted = [-6,-4,-3,-2,-1,0,0,0,0,0,1,1,1,1], and median = 0"
                    },
                    {
                        "username": "kirubeltekle1422",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        if len(nums1)==0 and len(nums2)==0:\\n            return None\\n        else:\\n            for i in nums1:\\n                nums2.append(i)\\n            nums2.sort()\\n            if len(nums2) % 2 == 0:\\n                i = int(len(nums2)/2)\\n                return (nums2[i] + nums2[i - 1])/2\\n            else:\\n                j = int((len(nums2) - 1))\\n                return float(nums2[j-1])\\n\\nwhy the output for [1,2] and [3,4] 2.0 for the above code as provided by the result tab\\n"
                    },
                    {
                        "username": "Dee0586",
                        "content": "list index out of range"
                    }
                ]
            },
            {
                "id": 1988727,
                "content": [
                    {
                        "username": "BajuMcBites",
                        "content": "This question made me want to quit computer science and switch to a communications major."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Create two pointers, i and j, initialized to 0, to traverse nums1 and nums2, respectively.\\n- Create an array mergedArr of size n1 + n2 to store the merged and sorted elements from both arrays.\\n- Iterate through nums1 and nums2 using the pointers i and j until either of them reaches the end of its respective array.\\n- Compare the current elements at nums1[i] and nums2[j], and add the smaller one to mergedArr. Increment the corresponding pointer (i or j) to move to the next element.\\n- After the loop ends, if there are any remaining elements in nums1 or nums2, add them to mergedArr.\\n- Calculate the median based on the length of mergedArr. If the total number of elements in mergedArr is odd, return the middle element; otherwise, return the average of the two middle elements."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can follow a similar approach of merging the arrays and then calculating the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.50000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3, 4]` is obtained from merging `nums1` and `nums2`, and the median is `(2 + 3) / 2 = 2.5`."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can merge both arrays into one sorted array and then calculate the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 3]\\nnums2 = [2]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.00000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3]` is obtained from merging `nums1` and `nums2`, and the median is `2.00000`."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "aint no way its a hard problem"
                    },
                    {
                        "username": "VAImanu",
                        "content": "so the ques I am solving is  **Median of Two Sorted Arrays**\\n\\nI have written a c code. My approach being:\\n\\nsort the arrays using same method as sort and merge 2 linked list; i.e take 2 indices for both arrays\\nthen move the indices in a preferable method.\\n\\nC code:\\n    double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int p1=nums1[0];\\n    int p2=nums2[0];\\n    int k=nums1Size+nums2Size;\\n    int size=0;\\n    int *nums3=(int *)malloc(k*sizeof(int));\\n    for(int i=0;i<k;i++){\\n      nums3[k]=0;\\n  }\\n  while(p1<nums1Size && p2<nums2Size){\\n    if(nums1[p1]<=nums2[p2]){\\n      nums3[size++]=nums1[p1];\\n      p1++;\\n    }\\n    else if(nums1[p1]>nums2[p2]){\\n      nums3[size++]=nums1[p2];\\n      p2++;\\n    }\\n  }\\n  while(p1<nums1Size){\\n    nums3[size++]=nums1[p1];\\n    p1++;\\n  }\\n  while(p2<nums2Size){\\n    nums3[size++]=nums2[p2];\\n    p2++;\\n  }\\n\\n  //find median:\\n  int l=sizeof(nums3)/sizeof(int);\\n  if(l%2!=0){\\n    return nums3[(l/2)];\\n  }\\n  else{\\n    int res=(nums3[(l/2)-1]+nums3[(l/2)])/2;\\n    return res;\\n  }\\n}`\\n\\nerror i got:\\n=================================================================\\n==22==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000005c at pc 0x55e14680b405 bp 0x7ffe10458290 sp 0x7ffe10458280\\nWRITE of size 4 at 0x60200000005c thread T0\\n    #2 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x60200000005c is located 0 bytes to the right of 12-byte region [0x602000000050,0x60200000005c)\\nallocated by thread T0 here:\\n    #0 0x7f532f8a8808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00 fa fa fa 04 fa fa fa 00[04]fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==22==ABORTING\\n\\nWhy am i getting this error?`"
                    },
                    {
                        "username": "reassurance",
                        "content": "Petition to move it to Medium category"
                    },
                    {
                        "username": "Zefick",
                        "content": "[@psionl0](/psionl0) I think this is just trolling, because many of the problems on Leetcode have wrong/inaccurate difficulty."
                    },
                    {
                        "username": "psionl0",
                        "content": "Why? You couldn\\'t come up with the O(log(m+n)) solution."
                    },
                    {
                        "username": "mindgspl",
                        "content": "Do the array values might be duplicated ? Like for example :\\nn = [-3,-1,0,0,1]\\nm = [-6,-4,-2,0,0,0,1,1,1]\\nIf so, what is the median value we are looking for , -3 ?  as in :\\nnm_sorted = [-6,-4,-3,-2,-1,0,1]"
                    },
                    {
                        "username": "zeinhg",
                        "content": "You don\\'t need to remove the duplications.\\nnm_sorted = [-6,-4,-3,-2,-1,0,0,0,0,0,1,1,1,1], and median = 0"
                    },
                    {
                        "username": "kirubeltekle1422",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        if len(nums1)==0 and len(nums2)==0:\\n            return None\\n        else:\\n            for i in nums1:\\n                nums2.append(i)\\n            nums2.sort()\\n            if len(nums2) % 2 == 0:\\n                i = int(len(nums2)/2)\\n                return (nums2[i] + nums2[i - 1])/2\\n            else:\\n                j = int((len(nums2) - 1))\\n                return float(nums2[j-1])\\n\\nwhy the output for [1,2] and [3,4] 2.0 for the above code as provided by the result tab\\n"
                    },
                    {
                        "username": "Dee0586",
                        "content": "list index out of range"
                    }
                ]
            },
            {
                "id": 1980127,
                "content": [
                    {
                        "username": "BajuMcBites",
                        "content": "This question made me want to quit computer science and switch to a communications major."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Create two pointers, i and j, initialized to 0, to traverse nums1 and nums2, respectively.\\n- Create an array mergedArr of size n1 + n2 to store the merged and sorted elements from both arrays.\\n- Iterate through nums1 and nums2 using the pointers i and j until either of them reaches the end of its respective array.\\n- Compare the current elements at nums1[i] and nums2[j], and add the smaller one to mergedArr. Increment the corresponding pointer (i or j) to move to the next element.\\n- After the loop ends, if there are any remaining elements in nums1 or nums2, add them to mergedArr.\\n- Calculate the median based on the length of mergedArr. If the total number of elements in mergedArr is odd, return the middle element; otherwise, return the average of the two middle elements."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can follow a similar approach of merging the arrays and then calculating the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.50000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3, 4]` is obtained from merging `nums1` and `nums2`, and the median is `(2 + 3) / 2 = 2.5`."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can merge both arrays into one sorted array and then calculate the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 3]\\nnums2 = [2]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.00000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3]` is obtained from merging `nums1` and `nums2`, and the median is `2.00000`."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "aint no way its a hard problem"
                    },
                    {
                        "username": "VAImanu",
                        "content": "so the ques I am solving is  **Median of Two Sorted Arrays**\\n\\nI have written a c code. My approach being:\\n\\nsort the arrays using same method as sort and merge 2 linked list; i.e take 2 indices for both arrays\\nthen move the indices in a preferable method.\\n\\nC code:\\n    double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int p1=nums1[0];\\n    int p2=nums2[0];\\n    int k=nums1Size+nums2Size;\\n    int size=0;\\n    int *nums3=(int *)malloc(k*sizeof(int));\\n    for(int i=0;i<k;i++){\\n      nums3[k]=0;\\n  }\\n  while(p1<nums1Size && p2<nums2Size){\\n    if(nums1[p1]<=nums2[p2]){\\n      nums3[size++]=nums1[p1];\\n      p1++;\\n    }\\n    else if(nums1[p1]>nums2[p2]){\\n      nums3[size++]=nums1[p2];\\n      p2++;\\n    }\\n  }\\n  while(p1<nums1Size){\\n    nums3[size++]=nums1[p1];\\n    p1++;\\n  }\\n  while(p2<nums2Size){\\n    nums3[size++]=nums2[p2];\\n    p2++;\\n  }\\n\\n  //find median:\\n  int l=sizeof(nums3)/sizeof(int);\\n  if(l%2!=0){\\n    return nums3[(l/2)];\\n  }\\n  else{\\n    int res=(nums3[(l/2)-1]+nums3[(l/2)])/2;\\n    return res;\\n  }\\n}`\\n\\nerror i got:\\n=================================================================\\n==22==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000005c at pc 0x55e14680b405 bp 0x7ffe10458290 sp 0x7ffe10458280\\nWRITE of size 4 at 0x60200000005c thread T0\\n    #2 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x60200000005c is located 0 bytes to the right of 12-byte region [0x602000000050,0x60200000005c)\\nallocated by thread T0 here:\\n    #0 0x7f532f8a8808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00 fa fa fa 04 fa fa fa 00[04]fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==22==ABORTING\\n\\nWhy am i getting this error?`"
                    },
                    {
                        "username": "reassurance",
                        "content": "Petition to move it to Medium category"
                    },
                    {
                        "username": "Zefick",
                        "content": "[@psionl0](/psionl0) I think this is just trolling, because many of the problems on Leetcode have wrong/inaccurate difficulty."
                    },
                    {
                        "username": "psionl0",
                        "content": "Why? You couldn\\'t come up with the O(log(m+n)) solution."
                    },
                    {
                        "username": "mindgspl",
                        "content": "Do the array values might be duplicated ? Like for example :\\nn = [-3,-1,0,0,1]\\nm = [-6,-4,-2,0,0,0,1,1,1]\\nIf so, what is the median value we are looking for , -3 ?  as in :\\nnm_sorted = [-6,-4,-3,-2,-1,0,1]"
                    },
                    {
                        "username": "zeinhg",
                        "content": "You don\\'t need to remove the duplications.\\nnm_sorted = [-6,-4,-3,-2,-1,0,0,0,0,0,1,1,1,1], and median = 0"
                    },
                    {
                        "username": "kirubeltekle1422",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        if len(nums1)==0 and len(nums2)==0:\\n            return None\\n        else:\\n            for i in nums1:\\n                nums2.append(i)\\n            nums2.sort()\\n            if len(nums2) % 2 == 0:\\n                i = int(len(nums2)/2)\\n                return (nums2[i] + nums2[i - 1])/2\\n            else:\\n                j = int((len(nums2) - 1))\\n                return float(nums2[j-1])\\n\\nwhy the output for [1,2] and [3,4] 2.0 for the above code as provided by the result tab\\n"
                    },
                    {
                        "username": "Dee0586",
                        "content": "list index out of range"
                    }
                ]
            },
            {
                "id": 1979090,
                "content": [
                    {
                        "username": "BajuMcBites",
                        "content": "This question made me want to quit computer science and switch to a communications major."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Create two pointers, i and j, initialized to 0, to traverse nums1 and nums2, respectively.\\n- Create an array mergedArr of size n1 + n2 to store the merged and sorted elements from both arrays.\\n- Iterate through nums1 and nums2 using the pointers i and j until either of them reaches the end of its respective array.\\n- Compare the current elements at nums1[i] and nums2[j], and add the smaller one to mergedArr. Increment the corresponding pointer (i or j) to move to the next element.\\n- After the loop ends, if there are any remaining elements in nums1 or nums2, add them to mergedArr.\\n- Calculate the median based on the length of mergedArr. If the total number of elements in mergedArr is odd, return the middle element; otherwise, return the average of the two middle elements."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can follow a similar approach of merging the arrays and then calculating the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.50000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3, 4]` is obtained from merging `nums1` and `nums2`, and the median is `(2 + 3) / 2 = 2.5`."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can merge both arrays into one sorted array and then calculate the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 3]\\nnums2 = [2]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.00000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3]` is obtained from merging `nums1` and `nums2`, and the median is `2.00000`."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "aint no way its a hard problem"
                    },
                    {
                        "username": "VAImanu",
                        "content": "so the ques I am solving is  **Median of Two Sorted Arrays**\\n\\nI have written a c code. My approach being:\\n\\nsort the arrays using same method as sort and merge 2 linked list; i.e take 2 indices for both arrays\\nthen move the indices in a preferable method.\\n\\nC code:\\n    double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int p1=nums1[0];\\n    int p2=nums2[0];\\n    int k=nums1Size+nums2Size;\\n    int size=0;\\n    int *nums3=(int *)malloc(k*sizeof(int));\\n    for(int i=0;i<k;i++){\\n      nums3[k]=0;\\n  }\\n  while(p1<nums1Size && p2<nums2Size){\\n    if(nums1[p1]<=nums2[p2]){\\n      nums3[size++]=nums1[p1];\\n      p1++;\\n    }\\n    else if(nums1[p1]>nums2[p2]){\\n      nums3[size++]=nums1[p2];\\n      p2++;\\n    }\\n  }\\n  while(p1<nums1Size){\\n    nums3[size++]=nums1[p1];\\n    p1++;\\n  }\\n  while(p2<nums2Size){\\n    nums3[size++]=nums2[p2];\\n    p2++;\\n  }\\n\\n  //find median:\\n  int l=sizeof(nums3)/sizeof(int);\\n  if(l%2!=0){\\n    return nums3[(l/2)];\\n  }\\n  else{\\n    int res=(nums3[(l/2)-1]+nums3[(l/2)])/2;\\n    return res;\\n  }\\n}`\\n\\nerror i got:\\n=================================================================\\n==22==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000005c at pc 0x55e14680b405 bp 0x7ffe10458290 sp 0x7ffe10458280\\nWRITE of size 4 at 0x60200000005c thread T0\\n    #2 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x60200000005c is located 0 bytes to the right of 12-byte region [0x602000000050,0x60200000005c)\\nallocated by thread T0 here:\\n    #0 0x7f532f8a8808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00 fa fa fa 04 fa fa fa 00[04]fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==22==ABORTING\\n\\nWhy am i getting this error?`"
                    },
                    {
                        "username": "reassurance",
                        "content": "Petition to move it to Medium category"
                    },
                    {
                        "username": "Zefick",
                        "content": "[@psionl0](/psionl0) I think this is just trolling, because many of the problems on Leetcode have wrong/inaccurate difficulty."
                    },
                    {
                        "username": "psionl0",
                        "content": "Why? You couldn\\'t come up with the O(log(m+n)) solution."
                    },
                    {
                        "username": "mindgspl",
                        "content": "Do the array values might be duplicated ? Like for example :\\nn = [-3,-1,0,0,1]\\nm = [-6,-4,-2,0,0,0,1,1,1]\\nIf so, what is the median value we are looking for , -3 ?  as in :\\nnm_sorted = [-6,-4,-3,-2,-1,0,1]"
                    },
                    {
                        "username": "zeinhg",
                        "content": "You don\\'t need to remove the duplications.\\nnm_sorted = [-6,-4,-3,-2,-1,0,0,0,0,0,1,1,1,1], and median = 0"
                    },
                    {
                        "username": "kirubeltekle1422",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        if len(nums1)==0 and len(nums2)==0:\\n            return None\\n        else:\\n            for i in nums1:\\n                nums2.append(i)\\n            nums2.sort()\\n            if len(nums2) % 2 == 0:\\n                i = int(len(nums2)/2)\\n                return (nums2[i] + nums2[i - 1])/2\\n            else:\\n                j = int((len(nums2) - 1))\\n                return float(nums2[j-1])\\n\\nwhy the output for [1,2] and [3,4] 2.0 for the above code as provided by the result tab\\n"
                    },
                    {
                        "username": "Dee0586",
                        "content": "list index out of range"
                    }
                ]
            },
            {
                "id": 1975522,
                "content": [
                    {
                        "username": "BajuMcBites",
                        "content": "This question made me want to quit computer science and switch to a communications major."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Create two pointers, i and j, initialized to 0, to traverse nums1 and nums2, respectively.\\n- Create an array mergedArr of size n1 + n2 to store the merged and sorted elements from both arrays.\\n- Iterate through nums1 and nums2 using the pointers i and j until either of them reaches the end of its respective array.\\n- Compare the current elements at nums1[i] and nums2[j], and add the smaller one to mergedArr. Increment the corresponding pointer (i or j) to move to the next element.\\n- After the loop ends, if there are any remaining elements in nums1 or nums2, add them to mergedArr.\\n- Calculate the median based on the length of mergedArr. If the total number of elements in mergedArr is odd, return the middle element; otherwise, return the average of the two middle elements."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can follow a similar approach of merging the arrays and then calculating the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.50000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3, 4]` is obtained from merging `nums1` and `nums2`, and the median is `(2 + 3) / 2 = 2.5`."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can merge both arrays into one sorted array and then calculate the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 3]\\nnums2 = [2]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.00000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3]` is obtained from merging `nums1` and `nums2`, and the median is `2.00000`."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "aint no way its a hard problem"
                    },
                    {
                        "username": "VAImanu",
                        "content": "so the ques I am solving is  **Median of Two Sorted Arrays**\\n\\nI have written a c code. My approach being:\\n\\nsort the arrays using same method as sort and merge 2 linked list; i.e take 2 indices for both arrays\\nthen move the indices in a preferable method.\\n\\nC code:\\n    double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int p1=nums1[0];\\n    int p2=nums2[0];\\n    int k=nums1Size+nums2Size;\\n    int size=0;\\n    int *nums3=(int *)malloc(k*sizeof(int));\\n    for(int i=0;i<k;i++){\\n      nums3[k]=0;\\n  }\\n  while(p1<nums1Size && p2<nums2Size){\\n    if(nums1[p1]<=nums2[p2]){\\n      nums3[size++]=nums1[p1];\\n      p1++;\\n    }\\n    else if(nums1[p1]>nums2[p2]){\\n      nums3[size++]=nums1[p2];\\n      p2++;\\n    }\\n  }\\n  while(p1<nums1Size){\\n    nums3[size++]=nums1[p1];\\n    p1++;\\n  }\\n  while(p2<nums2Size){\\n    nums3[size++]=nums2[p2];\\n    p2++;\\n  }\\n\\n  //find median:\\n  int l=sizeof(nums3)/sizeof(int);\\n  if(l%2!=0){\\n    return nums3[(l/2)];\\n  }\\n  else{\\n    int res=(nums3[(l/2)-1]+nums3[(l/2)])/2;\\n    return res;\\n  }\\n}`\\n\\nerror i got:\\n=================================================================\\n==22==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000005c at pc 0x55e14680b405 bp 0x7ffe10458290 sp 0x7ffe10458280\\nWRITE of size 4 at 0x60200000005c thread T0\\n    #2 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x60200000005c is located 0 bytes to the right of 12-byte region [0x602000000050,0x60200000005c)\\nallocated by thread T0 here:\\n    #0 0x7f532f8a8808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00 fa fa fa 04 fa fa fa 00[04]fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==22==ABORTING\\n\\nWhy am i getting this error?`"
                    },
                    {
                        "username": "reassurance",
                        "content": "Petition to move it to Medium category"
                    },
                    {
                        "username": "Zefick",
                        "content": "[@psionl0](/psionl0) I think this is just trolling, because many of the problems on Leetcode have wrong/inaccurate difficulty."
                    },
                    {
                        "username": "psionl0",
                        "content": "Why? You couldn\\'t come up with the O(log(m+n)) solution."
                    },
                    {
                        "username": "mindgspl",
                        "content": "Do the array values might be duplicated ? Like for example :\\nn = [-3,-1,0,0,1]\\nm = [-6,-4,-2,0,0,0,1,1,1]\\nIf so, what is the median value we are looking for , -3 ?  as in :\\nnm_sorted = [-6,-4,-3,-2,-1,0,1]"
                    },
                    {
                        "username": "zeinhg",
                        "content": "You don\\'t need to remove the duplications.\\nnm_sorted = [-6,-4,-3,-2,-1,0,0,0,0,0,1,1,1,1], and median = 0"
                    },
                    {
                        "username": "kirubeltekle1422",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        if len(nums1)==0 and len(nums2)==0:\\n            return None\\n        else:\\n            for i in nums1:\\n                nums2.append(i)\\n            nums2.sort()\\n            if len(nums2) % 2 == 0:\\n                i = int(len(nums2)/2)\\n                return (nums2[i] + nums2[i - 1])/2\\n            else:\\n                j = int((len(nums2) - 1))\\n                return float(nums2[j-1])\\n\\nwhy the output for [1,2] and [3,4] 2.0 for the above code as provided by the result tab\\n"
                    },
                    {
                        "username": "Dee0586",
                        "content": "list index out of range"
                    }
                ]
            },
            {
                "id": 1969466,
                "content": [
                    {
                        "username": "BajuMcBites",
                        "content": "This question made me want to quit computer science and switch to a communications major."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Create two pointers, i and j, initialized to 0, to traverse nums1 and nums2, respectively.\\n- Create an array mergedArr of size n1 + n2 to store the merged and sorted elements from both arrays.\\n- Iterate through nums1 and nums2 using the pointers i and j until either of them reaches the end of its respective array.\\n- Compare the current elements at nums1[i] and nums2[j], and add the smaller one to mergedArr. Increment the corresponding pointer (i or j) to move to the next element.\\n- After the loop ends, if there are any remaining elements in nums1 or nums2, add them to mergedArr.\\n- Calculate the median based on the length of mergedArr. If the total number of elements in mergedArr is odd, return the middle element; otherwise, return the average of the two middle elements."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can follow a similar approach of merging the arrays and then calculating the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.50000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3, 4]` is obtained from merging `nums1` and `nums2`, and the median is `(2 + 3) / 2 = 2.5`."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To find the median of two sorted arrays `nums1` and `nums2`, we can merge both arrays into one sorted array and then calculate the median.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef findMedianSortedArrays(nums1, nums2):\\n    merged = []\\n    i, j = 0, 0\\n\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums2[j]:\\n            merged.append(nums1[i])\\n            i += 1\\n        else:\\n            merged.append(nums2[j])\\n            j += 1\\n\\n    # Add remaining elements from nums1, if any\\n    while i < len(nums1):\\n        merged.append(nums1[i])\\n        i += 1\\n\\n    # Add remaining elements from nums2, if any\\n    while j < len(nums2):\\n        merged.append(nums2[j])\\n        j += 1\\n\\n    # Calculate median\\n    mid = len(merged) // 2\\n    if len(merged) % 2 == 0:\\n        return (merged[mid - 1] + merged[mid]) / 2\\n    else:\\n        return merged[mid]\\n\\n# Example\\nnums1 = [1, 3]\\nnums2 = [2]\\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.00000\\n```\\n\\nIn the example provided, the merged array `[1, 2, 3]` is obtained from merging `nums1` and `nums2`, and the median is `2.00000`."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "aint no way its a hard problem"
                    },
                    {
                        "username": "VAImanu",
                        "content": "so the ques I am solving is  **Median of Two Sorted Arrays**\\n\\nI have written a c code. My approach being:\\n\\nsort the arrays using same method as sort and merge 2 linked list; i.e take 2 indices for both arrays\\nthen move the indices in a preferable method.\\n\\nC code:\\n    double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int p1=nums1[0];\\n    int p2=nums2[0];\\n    int k=nums1Size+nums2Size;\\n    int size=0;\\n    int *nums3=(int *)malloc(k*sizeof(int));\\n    for(int i=0;i<k;i++){\\n      nums3[k]=0;\\n  }\\n  while(p1<nums1Size && p2<nums2Size){\\n    if(nums1[p1]<=nums2[p2]){\\n      nums3[size++]=nums1[p1];\\n      p1++;\\n    }\\n    else if(nums1[p1]>nums2[p2]){\\n      nums3[size++]=nums1[p2];\\n      p2++;\\n    }\\n  }\\n  while(p1<nums1Size){\\n    nums3[size++]=nums1[p1];\\n    p1++;\\n  }\\n  while(p2<nums2Size){\\n    nums3[size++]=nums2[p2];\\n    p2++;\\n  }\\n\\n  //find median:\\n  int l=sizeof(nums3)/sizeof(int);\\n  if(l%2!=0){\\n    return nums3[(l/2)];\\n  }\\n  else{\\n    int res=(nums3[(l/2)-1]+nums3[(l/2)])/2;\\n    return res;\\n  }\\n}`\\n\\nerror i got:\\n=================================================================\\n==22==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000005c at pc 0x55e14680b405 bp 0x7ffe10458290 sp 0x7ffe10458280\\nWRITE of size 4 at 0x60200000005c thread T0\\n    #2 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x60200000005c is located 0 bytes to the right of 12-byte region [0x602000000050,0x60200000005c)\\nallocated by thread T0 here:\\n    #0 0x7f532f8a8808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7f532ec60082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00 fa fa fa 04 fa fa fa 00[04]fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==22==ABORTING\\n\\nWhy am i getting this error?`"
                    },
                    {
                        "username": "reassurance",
                        "content": "Petition to move it to Medium category"
                    },
                    {
                        "username": "Zefick",
                        "content": "[@psionl0](/psionl0) I think this is just trolling, because many of the problems on Leetcode have wrong/inaccurate difficulty."
                    },
                    {
                        "username": "psionl0",
                        "content": "Why? You couldn\\'t come up with the O(log(m+n)) solution."
                    },
                    {
                        "username": "mindgspl",
                        "content": "Do the array values might be duplicated ? Like for example :\\nn = [-3,-1,0,0,1]\\nm = [-6,-4,-2,0,0,0,1,1,1]\\nIf so, what is the median value we are looking for , -3 ?  as in :\\nnm_sorted = [-6,-4,-3,-2,-1,0,1]"
                    },
                    {
                        "username": "zeinhg",
                        "content": "You don\\'t need to remove the duplications.\\nnm_sorted = [-6,-4,-3,-2,-1,0,0,0,0,0,1,1,1,1], and median = 0"
                    },
                    {
                        "username": "kirubeltekle1422",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        if len(nums1)==0 and len(nums2)==0:\\n            return None\\n        else:\\n            for i in nums1:\\n                nums2.append(i)\\n            nums2.sort()\\n            if len(nums2) % 2 == 0:\\n                i = int(len(nums2)/2)\\n                return (nums2[i] + nums2[i - 1])/2\\n            else:\\n                j = int((len(nums2) - 1))\\n                return float(nums2[j-1])\\n\\nwhy the output for [1,2] and [3,4] 2.0 for the above code as provided by the result tab\\n"
                    },
                    {
                        "username": "Dee0586",
                        "content": "list index out of range"
                    }
                ]
            },
            {
                "id": 1966258,
                "content": [
                    {
                        "username": "drgIv",
                        "content": "2000 tests,god"
                    },
                    {
                        "username": "mavnith23",
                        "content": "this program is somthing different and easy"
                    },
                    {
                        "username": "mwoodgate",
                        "content": "Did anyone else notice that taking the average of the median of both arrays (with a defensive case for an empty array) solves 718/2094 test cases? Surprising that such a basic pattern works for so many cases despite being completely wrong haha back to the drawing board..."
                    },
                    {
                        "username": "Aum-2003",
                        "content": "i have done this code in  my IDE and it works perfectly fine but i haven\\'t used oop features in python3... can anyone rewrite my code using class methods? `your inline code...your inline code...`# import numpy;\\n# class Solution:\\n#     def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\nnums1 = [1,2]\\nnums2 = [3,4]\\nmerged = sorted(nums1 + nums2)\\nmedian = 0;\\nres = []\\nprint(merged)\\nif(len(merged) % 2 == 0):\\n    start_ind = (len(merged) // 2) - 1\\n    end_ind = len(merged) // 2\\n    for value in  range(len(merged)):\\n        if value >= start_ind and value <= end_ind:\\n            res.append(merged[value])\\n\\n    print(res)\\n    for i in range(len(res)):\\n        median += res[i]\\n    print(float(median / 2))\\nelse:\\n    median_ind = int(len(merged) / 2)\\n    # res.append(merged[median_ind])\\n    print(float(merged[median_ind]))[leetcode]"
                    },
                    {
                        "username": "Alan258IMP",
                        "content": "Is this question one of the easiest \"Hard\" question on Leetcode?"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Either make the constraints tight or mark it as an easy question."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My first hard which I solved on my OWN !! \\nVery happy :)"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "After giving some time I knew it was a Binary search and had a good idea how it would be solved but I was not able to implement it \\uD83D\\uDE2D"
                    },
                    {
                        "username": "whoopigoldfinger69",
                        "content": "\\n\\nimport math\\ndef woohoo(nums1,nums2):\\n        merged = sorted(nums1 + nums2)\\n        x = len((merged))\\n        y = x / 2\\n        if (x % 2) == 0:\\n            lower = merged[int(y - 1)]\\n            upper = merged[int(y)]\\n            return (upper + lower) / 2\\n        elif (x % 2) != 0:\\n            lower = merged[math.floor(y - 1)]\\n            upper = merged[math.ceil(y)]\\n            return float((upper + lower) / 2)"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "This is not a place for codes there\\'s different section for codes"
                    },
                    {
                        "username": "tanish69",
                        "content": "Solved in the traditional O((n+m)/2). Beats 100%. what even is going on"
                    }
                ]
            },
            {
                "id": 1957813,
                "content": [
                    {
                        "username": "drgIv",
                        "content": "2000 tests,god"
                    },
                    {
                        "username": "mavnith23",
                        "content": "this program is somthing different and easy"
                    },
                    {
                        "username": "mwoodgate",
                        "content": "Did anyone else notice that taking the average of the median of both arrays (with a defensive case for an empty array) solves 718/2094 test cases? Surprising that such a basic pattern works for so many cases despite being completely wrong haha back to the drawing board..."
                    },
                    {
                        "username": "Aum-2003",
                        "content": "i have done this code in  my IDE and it works perfectly fine but i haven\\'t used oop features in python3... can anyone rewrite my code using class methods? `your inline code...your inline code...`# import numpy;\\n# class Solution:\\n#     def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\nnums1 = [1,2]\\nnums2 = [3,4]\\nmerged = sorted(nums1 + nums2)\\nmedian = 0;\\nres = []\\nprint(merged)\\nif(len(merged) % 2 == 0):\\n    start_ind = (len(merged) // 2) - 1\\n    end_ind = len(merged) // 2\\n    for value in  range(len(merged)):\\n        if value >= start_ind and value <= end_ind:\\n            res.append(merged[value])\\n\\n    print(res)\\n    for i in range(len(res)):\\n        median += res[i]\\n    print(float(median / 2))\\nelse:\\n    median_ind = int(len(merged) / 2)\\n    # res.append(merged[median_ind])\\n    print(float(merged[median_ind]))[leetcode]"
                    },
                    {
                        "username": "Alan258IMP",
                        "content": "Is this question one of the easiest \"Hard\" question on Leetcode?"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Either make the constraints tight or mark it as an easy question."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My first hard which I solved on my OWN !! \\nVery happy :)"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "After giving some time I knew it was a Binary search and had a good idea how it would be solved but I was not able to implement it \\uD83D\\uDE2D"
                    },
                    {
                        "username": "whoopigoldfinger69",
                        "content": "\\n\\nimport math\\ndef woohoo(nums1,nums2):\\n        merged = sorted(nums1 + nums2)\\n        x = len((merged))\\n        y = x / 2\\n        if (x % 2) == 0:\\n            lower = merged[int(y - 1)]\\n            upper = merged[int(y)]\\n            return (upper + lower) / 2\\n        elif (x % 2) != 0:\\n            lower = merged[math.floor(y - 1)]\\n            upper = merged[math.ceil(y)]\\n            return float((upper + lower) / 2)"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "This is not a place for codes there\\'s different section for codes"
                    },
                    {
                        "username": "tanish69",
                        "content": "Solved in the traditional O((n+m)/2). Beats 100%. what even is going on"
                    }
                ]
            },
            {
                "id": 1953934,
                "content": [
                    {
                        "username": "drgIv",
                        "content": "2000 tests,god"
                    },
                    {
                        "username": "mavnith23",
                        "content": "this program is somthing different and easy"
                    },
                    {
                        "username": "mwoodgate",
                        "content": "Did anyone else notice that taking the average of the median of both arrays (with a defensive case for an empty array) solves 718/2094 test cases? Surprising that such a basic pattern works for so many cases despite being completely wrong haha back to the drawing board..."
                    },
                    {
                        "username": "Aum-2003",
                        "content": "i have done this code in  my IDE and it works perfectly fine but i haven\\'t used oop features in python3... can anyone rewrite my code using class methods? `your inline code...your inline code...`# import numpy;\\n# class Solution:\\n#     def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\nnums1 = [1,2]\\nnums2 = [3,4]\\nmerged = sorted(nums1 + nums2)\\nmedian = 0;\\nres = []\\nprint(merged)\\nif(len(merged) % 2 == 0):\\n    start_ind = (len(merged) // 2) - 1\\n    end_ind = len(merged) // 2\\n    for value in  range(len(merged)):\\n        if value >= start_ind and value <= end_ind:\\n            res.append(merged[value])\\n\\n    print(res)\\n    for i in range(len(res)):\\n        median += res[i]\\n    print(float(median / 2))\\nelse:\\n    median_ind = int(len(merged) / 2)\\n    # res.append(merged[median_ind])\\n    print(float(merged[median_ind]))[leetcode]"
                    },
                    {
                        "username": "Alan258IMP",
                        "content": "Is this question one of the easiest \"Hard\" question on Leetcode?"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Either make the constraints tight or mark it as an easy question."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My first hard which I solved on my OWN !! \\nVery happy :)"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "After giving some time I knew it was a Binary search and had a good idea how it would be solved but I was not able to implement it \\uD83D\\uDE2D"
                    },
                    {
                        "username": "whoopigoldfinger69",
                        "content": "\\n\\nimport math\\ndef woohoo(nums1,nums2):\\n        merged = sorted(nums1 + nums2)\\n        x = len((merged))\\n        y = x / 2\\n        if (x % 2) == 0:\\n            lower = merged[int(y - 1)]\\n            upper = merged[int(y)]\\n            return (upper + lower) / 2\\n        elif (x % 2) != 0:\\n            lower = merged[math.floor(y - 1)]\\n            upper = merged[math.ceil(y)]\\n            return float((upper + lower) / 2)"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "This is not a place for codes there\\'s different section for codes"
                    },
                    {
                        "username": "tanish69",
                        "content": "Solved in the traditional O((n+m)/2). Beats 100%. what even is going on"
                    }
                ]
            },
            {
                "id": 1951286,
                "content": [
                    {
                        "username": "drgIv",
                        "content": "2000 tests,god"
                    },
                    {
                        "username": "mavnith23",
                        "content": "this program is somthing different and easy"
                    },
                    {
                        "username": "mwoodgate",
                        "content": "Did anyone else notice that taking the average of the median of both arrays (with a defensive case for an empty array) solves 718/2094 test cases? Surprising that such a basic pattern works for so many cases despite being completely wrong haha back to the drawing board..."
                    },
                    {
                        "username": "Aum-2003",
                        "content": "i have done this code in  my IDE and it works perfectly fine but i haven\\'t used oop features in python3... can anyone rewrite my code using class methods? `your inline code...your inline code...`# import numpy;\\n# class Solution:\\n#     def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\nnums1 = [1,2]\\nnums2 = [3,4]\\nmerged = sorted(nums1 + nums2)\\nmedian = 0;\\nres = []\\nprint(merged)\\nif(len(merged) % 2 == 0):\\n    start_ind = (len(merged) // 2) - 1\\n    end_ind = len(merged) // 2\\n    for value in  range(len(merged)):\\n        if value >= start_ind and value <= end_ind:\\n            res.append(merged[value])\\n\\n    print(res)\\n    for i in range(len(res)):\\n        median += res[i]\\n    print(float(median / 2))\\nelse:\\n    median_ind = int(len(merged) / 2)\\n    # res.append(merged[median_ind])\\n    print(float(merged[median_ind]))[leetcode]"
                    },
                    {
                        "username": "Alan258IMP",
                        "content": "Is this question one of the easiest \"Hard\" question on Leetcode?"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Either make the constraints tight or mark it as an easy question."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My first hard which I solved on my OWN !! \\nVery happy :)"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "After giving some time I knew it was a Binary search and had a good idea how it would be solved but I was not able to implement it \\uD83D\\uDE2D"
                    },
                    {
                        "username": "whoopigoldfinger69",
                        "content": "\\n\\nimport math\\ndef woohoo(nums1,nums2):\\n        merged = sorted(nums1 + nums2)\\n        x = len((merged))\\n        y = x / 2\\n        if (x % 2) == 0:\\n            lower = merged[int(y - 1)]\\n            upper = merged[int(y)]\\n            return (upper + lower) / 2\\n        elif (x % 2) != 0:\\n            lower = merged[math.floor(y - 1)]\\n            upper = merged[math.ceil(y)]\\n            return float((upper + lower) / 2)"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "This is not a place for codes there\\'s different section for codes"
                    },
                    {
                        "username": "tanish69",
                        "content": "Solved in the traditional O((n+m)/2). Beats 100%. what even is going on"
                    }
                ]
            },
            {
                "id": 1947989,
                "content": [
                    {
                        "username": "drgIv",
                        "content": "2000 tests,god"
                    },
                    {
                        "username": "mavnith23",
                        "content": "this program is somthing different and easy"
                    },
                    {
                        "username": "mwoodgate",
                        "content": "Did anyone else notice that taking the average of the median of both arrays (with a defensive case for an empty array) solves 718/2094 test cases? Surprising that such a basic pattern works for so many cases despite being completely wrong haha back to the drawing board..."
                    },
                    {
                        "username": "Aum-2003",
                        "content": "i have done this code in  my IDE and it works perfectly fine but i haven\\'t used oop features in python3... can anyone rewrite my code using class methods? `your inline code...your inline code...`# import numpy;\\n# class Solution:\\n#     def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\nnums1 = [1,2]\\nnums2 = [3,4]\\nmerged = sorted(nums1 + nums2)\\nmedian = 0;\\nres = []\\nprint(merged)\\nif(len(merged) % 2 == 0):\\n    start_ind = (len(merged) // 2) - 1\\n    end_ind = len(merged) // 2\\n    for value in  range(len(merged)):\\n        if value >= start_ind and value <= end_ind:\\n            res.append(merged[value])\\n\\n    print(res)\\n    for i in range(len(res)):\\n        median += res[i]\\n    print(float(median / 2))\\nelse:\\n    median_ind = int(len(merged) / 2)\\n    # res.append(merged[median_ind])\\n    print(float(merged[median_ind]))[leetcode]"
                    },
                    {
                        "username": "Alan258IMP",
                        "content": "Is this question one of the easiest \"Hard\" question on Leetcode?"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Either make the constraints tight or mark it as an easy question."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My first hard which I solved on my OWN !! \\nVery happy :)"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "After giving some time I knew it was a Binary search and had a good idea how it would be solved but I was not able to implement it \\uD83D\\uDE2D"
                    },
                    {
                        "username": "whoopigoldfinger69",
                        "content": "\\n\\nimport math\\ndef woohoo(nums1,nums2):\\n        merged = sorted(nums1 + nums2)\\n        x = len((merged))\\n        y = x / 2\\n        if (x % 2) == 0:\\n            lower = merged[int(y - 1)]\\n            upper = merged[int(y)]\\n            return (upper + lower) / 2\\n        elif (x % 2) != 0:\\n            lower = merged[math.floor(y - 1)]\\n            upper = merged[math.ceil(y)]\\n            return float((upper + lower) / 2)"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "This is not a place for codes there\\'s different section for codes"
                    },
                    {
                        "username": "tanish69",
                        "content": "Solved in the traditional O((n+m)/2). Beats 100%. what even is going on"
                    }
                ]
            },
            {
                "id": 1946343,
                "content": [
                    {
                        "username": "drgIv",
                        "content": "2000 tests,god"
                    },
                    {
                        "username": "mavnith23",
                        "content": "this program is somthing different and easy"
                    },
                    {
                        "username": "mwoodgate",
                        "content": "Did anyone else notice that taking the average of the median of both arrays (with a defensive case for an empty array) solves 718/2094 test cases? Surprising that such a basic pattern works for so many cases despite being completely wrong haha back to the drawing board..."
                    },
                    {
                        "username": "Aum-2003",
                        "content": "i have done this code in  my IDE and it works perfectly fine but i haven\\'t used oop features in python3... can anyone rewrite my code using class methods? `your inline code...your inline code...`# import numpy;\\n# class Solution:\\n#     def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\nnums1 = [1,2]\\nnums2 = [3,4]\\nmerged = sorted(nums1 + nums2)\\nmedian = 0;\\nres = []\\nprint(merged)\\nif(len(merged) % 2 == 0):\\n    start_ind = (len(merged) // 2) - 1\\n    end_ind = len(merged) // 2\\n    for value in  range(len(merged)):\\n        if value >= start_ind and value <= end_ind:\\n            res.append(merged[value])\\n\\n    print(res)\\n    for i in range(len(res)):\\n        median += res[i]\\n    print(float(median / 2))\\nelse:\\n    median_ind = int(len(merged) / 2)\\n    # res.append(merged[median_ind])\\n    print(float(merged[median_ind]))[leetcode]"
                    },
                    {
                        "username": "Alan258IMP",
                        "content": "Is this question one of the easiest \"Hard\" question on Leetcode?"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Either make the constraints tight or mark it as an easy question."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My first hard which I solved on my OWN !! \\nVery happy :)"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "After giving some time I knew it was a Binary search and had a good idea how it would be solved but I was not able to implement it \\uD83D\\uDE2D"
                    },
                    {
                        "username": "whoopigoldfinger69",
                        "content": "\\n\\nimport math\\ndef woohoo(nums1,nums2):\\n        merged = sorted(nums1 + nums2)\\n        x = len((merged))\\n        y = x / 2\\n        if (x % 2) == 0:\\n            lower = merged[int(y - 1)]\\n            upper = merged[int(y)]\\n            return (upper + lower) / 2\\n        elif (x % 2) != 0:\\n            lower = merged[math.floor(y - 1)]\\n            upper = merged[math.ceil(y)]\\n            return float((upper + lower) / 2)"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "This is not a place for codes there\\'s different section for codes"
                    },
                    {
                        "username": "tanish69",
                        "content": "Solved in the traditional O((n+m)/2). Beats 100%. what even is going on"
                    }
                ]
            },
            {
                "id": 1939787,
                "content": [
                    {
                        "username": "drgIv",
                        "content": "2000 tests,god"
                    },
                    {
                        "username": "mavnith23",
                        "content": "this program is somthing different and easy"
                    },
                    {
                        "username": "mwoodgate",
                        "content": "Did anyone else notice that taking the average of the median of both arrays (with a defensive case for an empty array) solves 718/2094 test cases? Surprising that such a basic pattern works for so many cases despite being completely wrong haha back to the drawing board..."
                    },
                    {
                        "username": "Aum-2003",
                        "content": "i have done this code in  my IDE and it works perfectly fine but i haven\\'t used oop features in python3... can anyone rewrite my code using class methods? `your inline code...your inline code...`# import numpy;\\n# class Solution:\\n#     def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\nnums1 = [1,2]\\nnums2 = [3,4]\\nmerged = sorted(nums1 + nums2)\\nmedian = 0;\\nres = []\\nprint(merged)\\nif(len(merged) % 2 == 0):\\n    start_ind = (len(merged) // 2) - 1\\n    end_ind = len(merged) // 2\\n    for value in  range(len(merged)):\\n        if value >= start_ind and value <= end_ind:\\n            res.append(merged[value])\\n\\n    print(res)\\n    for i in range(len(res)):\\n        median += res[i]\\n    print(float(median / 2))\\nelse:\\n    median_ind = int(len(merged) / 2)\\n    # res.append(merged[median_ind])\\n    print(float(merged[median_ind]))[leetcode]"
                    },
                    {
                        "username": "Alan258IMP",
                        "content": "Is this question one of the easiest \"Hard\" question on Leetcode?"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Either make the constraints tight or mark it as an easy question."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My first hard which I solved on my OWN !! \\nVery happy :)"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "After giving some time I knew it was a Binary search and had a good idea how it would be solved but I was not able to implement it \\uD83D\\uDE2D"
                    },
                    {
                        "username": "whoopigoldfinger69",
                        "content": "\\n\\nimport math\\ndef woohoo(nums1,nums2):\\n        merged = sorted(nums1 + nums2)\\n        x = len((merged))\\n        y = x / 2\\n        if (x % 2) == 0:\\n            lower = merged[int(y - 1)]\\n            upper = merged[int(y)]\\n            return (upper + lower) / 2\\n        elif (x % 2) != 0:\\n            lower = merged[math.floor(y - 1)]\\n            upper = merged[math.ceil(y)]\\n            return float((upper + lower) / 2)"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "This is not a place for codes there\\'s different section for codes"
                    },
                    {
                        "username": "tanish69",
                        "content": "Solved in the traditional O((n+m)/2). Beats 100%. what even is going on"
                    }
                ]
            },
            {
                "id": 1939051,
                "content": [
                    {
                        "username": "drgIv",
                        "content": "2000 tests,god"
                    },
                    {
                        "username": "mavnith23",
                        "content": "this program is somthing different and easy"
                    },
                    {
                        "username": "mwoodgate",
                        "content": "Did anyone else notice that taking the average of the median of both arrays (with a defensive case for an empty array) solves 718/2094 test cases? Surprising that such a basic pattern works for so many cases despite being completely wrong haha back to the drawing board..."
                    },
                    {
                        "username": "Aum-2003",
                        "content": "i have done this code in  my IDE and it works perfectly fine but i haven\\'t used oop features in python3... can anyone rewrite my code using class methods? `your inline code...your inline code...`# import numpy;\\n# class Solution:\\n#     def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\nnums1 = [1,2]\\nnums2 = [3,4]\\nmerged = sorted(nums1 + nums2)\\nmedian = 0;\\nres = []\\nprint(merged)\\nif(len(merged) % 2 == 0):\\n    start_ind = (len(merged) // 2) - 1\\n    end_ind = len(merged) // 2\\n    for value in  range(len(merged)):\\n        if value >= start_ind and value <= end_ind:\\n            res.append(merged[value])\\n\\n    print(res)\\n    for i in range(len(res)):\\n        median += res[i]\\n    print(float(median / 2))\\nelse:\\n    median_ind = int(len(merged) / 2)\\n    # res.append(merged[median_ind])\\n    print(float(merged[median_ind]))[leetcode]"
                    },
                    {
                        "username": "Alan258IMP",
                        "content": "Is this question one of the easiest \"Hard\" question on Leetcode?"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Either make the constraints tight or mark it as an easy question."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My first hard which I solved on my OWN !! \\nVery happy :)"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "After giving some time I knew it was a Binary search and had a good idea how it would be solved but I was not able to implement it \\uD83D\\uDE2D"
                    },
                    {
                        "username": "whoopigoldfinger69",
                        "content": "\\n\\nimport math\\ndef woohoo(nums1,nums2):\\n        merged = sorted(nums1 + nums2)\\n        x = len((merged))\\n        y = x / 2\\n        if (x % 2) == 0:\\n            lower = merged[int(y - 1)]\\n            upper = merged[int(y)]\\n            return (upper + lower) / 2\\n        elif (x % 2) != 0:\\n            lower = merged[math.floor(y - 1)]\\n            upper = merged[math.ceil(y)]\\n            return float((upper + lower) / 2)"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "This is not a place for codes there\\'s different section for codes"
                    },
                    {
                        "username": "tanish69",
                        "content": "Solved in the traditional O((n+m)/2). Beats 100%. what even is going on"
                    }
                ]
            },
            {
                "id": 1937481,
                "content": [
                    {
                        "username": "drgIv",
                        "content": "2000 tests,god"
                    },
                    {
                        "username": "mavnith23",
                        "content": "this program is somthing different and easy"
                    },
                    {
                        "username": "mwoodgate",
                        "content": "Did anyone else notice that taking the average of the median of both arrays (with a defensive case for an empty array) solves 718/2094 test cases? Surprising that such a basic pattern works for so many cases despite being completely wrong haha back to the drawing board..."
                    },
                    {
                        "username": "Aum-2003",
                        "content": "i have done this code in  my IDE and it works perfectly fine but i haven\\'t used oop features in python3... can anyone rewrite my code using class methods? `your inline code...your inline code...`# import numpy;\\n# class Solution:\\n#     def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\nnums1 = [1,2]\\nnums2 = [3,4]\\nmerged = sorted(nums1 + nums2)\\nmedian = 0;\\nres = []\\nprint(merged)\\nif(len(merged) % 2 == 0):\\n    start_ind = (len(merged) // 2) - 1\\n    end_ind = len(merged) // 2\\n    for value in  range(len(merged)):\\n        if value >= start_ind and value <= end_ind:\\n            res.append(merged[value])\\n\\n    print(res)\\n    for i in range(len(res)):\\n        median += res[i]\\n    print(float(median / 2))\\nelse:\\n    median_ind = int(len(merged) / 2)\\n    # res.append(merged[median_ind])\\n    print(float(merged[median_ind]))[leetcode]"
                    },
                    {
                        "username": "Alan258IMP",
                        "content": "Is this question one of the easiest \"Hard\" question on Leetcode?"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Either make the constraints tight or mark it as an easy question."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My first hard which I solved on my OWN !! \\nVery happy :)"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "After giving some time I knew it was a Binary search and had a good idea how it would be solved but I was not able to implement it \\uD83D\\uDE2D"
                    },
                    {
                        "username": "whoopigoldfinger69",
                        "content": "\\n\\nimport math\\ndef woohoo(nums1,nums2):\\n        merged = sorted(nums1 + nums2)\\n        x = len((merged))\\n        y = x / 2\\n        if (x % 2) == 0:\\n            lower = merged[int(y - 1)]\\n            upper = merged[int(y)]\\n            return (upper + lower) / 2\\n        elif (x % 2) != 0:\\n            lower = merged[math.floor(y - 1)]\\n            upper = merged[math.ceil(y)]\\n            return float((upper + lower) / 2)"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "This is not a place for codes there\\'s different section for codes"
                    },
                    {
                        "username": "tanish69",
                        "content": "Solved in the traditional O((n+m)/2). Beats 100%. what even is going on"
                    }
                ]
            },
            {
                "id": 1935780,
                "content": [
                    {
                        "username": "drgIv",
                        "content": "2000 tests,god"
                    },
                    {
                        "username": "mavnith23",
                        "content": "this program is somthing different and easy"
                    },
                    {
                        "username": "mwoodgate",
                        "content": "Did anyone else notice that taking the average of the median of both arrays (with a defensive case for an empty array) solves 718/2094 test cases? Surprising that such a basic pattern works for so many cases despite being completely wrong haha back to the drawing board..."
                    },
                    {
                        "username": "Aum-2003",
                        "content": "i have done this code in  my IDE and it works perfectly fine but i haven\\'t used oop features in python3... can anyone rewrite my code using class methods? `your inline code...your inline code...`# import numpy;\\n# class Solution:\\n#     def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\nnums1 = [1,2]\\nnums2 = [3,4]\\nmerged = sorted(nums1 + nums2)\\nmedian = 0;\\nres = []\\nprint(merged)\\nif(len(merged) % 2 == 0):\\n    start_ind = (len(merged) // 2) - 1\\n    end_ind = len(merged) // 2\\n    for value in  range(len(merged)):\\n        if value >= start_ind and value <= end_ind:\\n            res.append(merged[value])\\n\\n    print(res)\\n    for i in range(len(res)):\\n        median += res[i]\\n    print(float(median / 2))\\nelse:\\n    median_ind = int(len(merged) / 2)\\n    # res.append(merged[median_ind])\\n    print(float(merged[median_ind]))[leetcode]"
                    },
                    {
                        "username": "Alan258IMP",
                        "content": "Is this question one of the easiest \"Hard\" question on Leetcode?"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Either make the constraints tight or mark it as an easy question."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My first hard which I solved on my OWN !! \\nVery happy :)"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "After giving some time I knew it was a Binary search and had a good idea how it would be solved but I was not able to implement it \\uD83D\\uDE2D"
                    },
                    {
                        "username": "whoopigoldfinger69",
                        "content": "\\n\\nimport math\\ndef woohoo(nums1,nums2):\\n        merged = sorted(nums1 + nums2)\\n        x = len((merged))\\n        y = x / 2\\n        if (x % 2) == 0:\\n            lower = merged[int(y - 1)]\\n            upper = merged[int(y)]\\n            return (upper + lower) / 2\\n        elif (x % 2) != 0:\\n            lower = merged[math.floor(y - 1)]\\n            upper = merged[math.ceil(y)]\\n            return float((upper + lower) / 2)"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "This is not a place for codes there\\'s different section for codes"
                    },
                    {
                        "username": "tanish69",
                        "content": "Solved in the traditional O((n+m)/2). Beats 100%. what even is going on"
                    }
                ]
            },
            {
                "id": 1933568,
                "content": [
                    {
                        "username": "ThoX",
                        "content": "That's my code in Python:  \n\n[class Solution(object):\n    |     def findMedianSortedArrays(self,nums1, nums2):\n    ||        L = sorted(nums1 + nums2)\n    ||        if len(L)%2 == 1:\n    |||           return L[int(len(L)/2)]\n    ||        else:\n    |||           return (L[int(len(L)/2) - 1] + L[int(len(L)/2)])/2]\n\nwith nums1 = [1,2] and nums = [3,4], I do not understand why the function gives me 2.0.\nI was expecting 2.5...\nI tested it in Spyder and it gives me 2.5 so the expected answer.\nI need help..."
                    },
                    {
                        "username": "mrunmayee0109",
                        "content": "Two approaches :\\n1) Use 2 pointer approach to find the middle elements of the two arrays and then find the median\\ncomplexity - O(m+n)\\n2) Simply merge the two arrays .extend(), use .sort() and then find the median\\ncomplexity - O((m+n)log(m+n))\\nEven if the complexity of this method is higher, surprisingly it satisfies all the test cases.\\nCannot be regarded as a hard question\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Many solutions are doing sort(merge(nums1 + nums2))    ;)\\nbut the reality is interviewer dig deep in such questions,, \\nfirst they will aloow you to use sort() function\\nthen they will say , you can not use inbuilt sort function.\\nthen they will say now do it without extra space and so on..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "why is this hard?\\n"
                    },
                    {
                        "username": "hiidracula",
                        "content": "while calculating cut2/mid2 = (n1+n2+1)/2-cut2/mid2. Why we we (+1) in total length?\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I haven\\'t solved this yet, but i want to know:\\n1. Are there repeats? e.g arr1 = [1,2,3,4] and arr2= [4,5,6,7] <= 4 appears n both arrays\\n2. If there are repeats, do we merge them or duplicate? that is [1,2,3,4,5,6,7] vs [1,2,3,4,4,5,6,7] \\nThey need to be more specific since we do not have an interviewer to ask these questions. \\n"
                    },
                    {
                        "username": "user2176B",
                        "content": "Brute force approach of simply adding the two arrays and sorting them and then returning the median value based on whether the length of array is even or odd is getting accepted . This approach has time complexity of (m+n)log(m+n) and space complexity O(m+n).\n\nNeeds harder test cases I suppose."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "This was the first thing that came to my mind, but when they said \"must run\" Ologn, i assumed it wouldn't be accepted. I am guessing they said that as a hint rather than a restriction. \nOr the test cases aren't doing their job well😂"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "A medium question in Hard list."
                    },
                    {
                        "username": "somendrajaat",
                        "content": "how the median of nums1=[2] and nums2 =[ ] is 2.0000     \\nit was supposed to be 1.00000 isn\\'t it?? "
                    },
                    {
                        "username": "alperkaya0",
                        "content": "No, combine nums1 and nums2, you get [2], n/2 because n is odd(n=1, length of the array). since n/2 = 0, 0th element is going to be returned."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "DON\\'T POST ANY SOLUTIONS HERE F****\\nTHERE IS A F*** DIFFERENT SECTION FOR SOLUTIONS"
                    }
                ]
            },
            {
                "id": 1932412,
                "content": [
                    {
                        "username": "ThoX",
                        "content": "That's my code in Python:  \n\n[class Solution(object):\n    |     def findMedianSortedArrays(self,nums1, nums2):\n    ||        L = sorted(nums1 + nums2)\n    ||        if len(L)%2 == 1:\n    |||           return L[int(len(L)/2)]\n    ||        else:\n    |||           return (L[int(len(L)/2) - 1] + L[int(len(L)/2)])/2]\n\nwith nums1 = [1,2] and nums = [3,4], I do not understand why the function gives me 2.0.\nI was expecting 2.5...\nI tested it in Spyder and it gives me 2.5 so the expected answer.\nI need help..."
                    },
                    {
                        "username": "mrunmayee0109",
                        "content": "Two approaches :\\n1) Use 2 pointer approach to find the middle elements of the two arrays and then find the median\\ncomplexity - O(m+n)\\n2) Simply merge the two arrays .extend(), use .sort() and then find the median\\ncomplexity - O((m+n)log(m+n))\\nEven if the complexity of this method is higher, surprisingly it satisfies all the test cases.\\nCannot be regarded as a hard question\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Many solutions are doing sort(merge(nums1 + nums2))    ;)\\nbut the reality is interviewer dig deep in such questions,, \\nfirst they will aloow you to use sort() function\\nthen they will say , you can not use inbuilt sort function.\\nthen they will say now do it without extra space and so on..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "why is this hard?\\n"
                    },
                    {
                        "username": "hiidracula",
                        "content": "while calculating cut2/mid2 = (n1+n2+1)/2-cut2/mid2. Why we we (+1) in total length?\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I haven\\'t solved this yet, but i want to know:\\n1. Are there repeats? e.g arr1 = [1,2,3,4] and arr2= [4,5,6,7] <= 4 appears n both arrays\\n2. If there are repeats, do we merge them or duplicate? that is [1,2,3,4,5,6,7] vs [1,2,3,4,4,5,6,7] \\nThey need to be more specific since we do not have an interviewer to ask these questions. \\n"
                    },
                    {
                        "username": "user2176B",
                        "content": "Brute force approach of simply adding the two arrays and sorting them and then returning the median value based on whether the length of array is even or odd is getting accepted . This approach has time complexity of (m+n)log(m+n) and space complexity O(m+n).\n\nNeeds harder test cases I suppose."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "This was the first thing that came to my mind, but when they said \"must run\" Ologn, i assumed it wouldn't be accepted. I am guessing they said that as a hint rather than a restriction. \nOr the test cases aren't doing their job well😂"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "A medium question in Hard list."
                    },
                    {
                        "username": "somendrajaat",
                        "content": "how the median of nums1=[2] and nums2 =[ ] is 2.0000     \\nit was supposed to be 1.00000 isn\\'t it?? "
                    },
                    {
                        "username": "alperkaya0",
                        "content": "No, combine nums1 and nums2, you get [2], n/2 because n is odd(n=1, length of the array). since n/2 = 0, 0th element is going to be returned."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "DON\\'T POST ANY SOLUTIONS HERE F****\\nTHERE IS A F*** DIFFERENT SECTION FOR SOLUTIONS"
                    }
                ]
            },
            {
                "id": 1931524,
                "content": [
                    {
                        "username": "ThoX",
                        "content": "That's my code in Python:  \n\n[class Solution(object):\n    |     def findMedianSortedArrays(self,nums1, nums2):\n    ||        L = sorted(nums1 + nums2)\n    ||        if len(L)%2 == 1:\n    |||           return L[int(len(L)/2)]\n    ||        else:\n    |||           return (L[int(len(L)/2) - 1] + L[int(len(L)/2)])/2]\n\nwith nums1 = [1,2] and nums = [3,4], I do not understand why the function gives me 2.0.\nI was expecting 2.5...\nI tested it in Spyder and it gives me 2.5 so the expected answer.\nI need help..."
                    },
                    {
                        "username": "mrunmayee0109",
                        "content": "Two approaches :\\n1) Use 2 pointer approach to find the middle elements of the two arrays and then find the median\\ncomplexity - O(m+n)\\n2) Simply merge the two arrays .extend(), use .sort() and then find the median\\ncomplexity - O((m+n)log(m+n))\\nEven if the complexity of this method is higher, surprisingly it satisfies all the test cases.\\nCannot be regarded as a hard question\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Many solutions are doing sort(merge(nums1 + nums2))    ;)\\nbut the reality is interviewer dig deep in such questions,, \\nfirst they will aloow you to use sort() function\\nthen they will say , you can not use inbuilt sort function.\\nthen they will say now do it without extra space and so on..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "why is this hard?\\n"
                    },
                    {
                        "username": "hiidracula",
                        "content": "while calculating cut2/mid2 = (n1+n2+1)/2-cut2/mid2. Why we we (+1) in total length?\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I haven\\'t solved this yet, but i want to know:\\n1. Are there repeats? e.g arr1 = [1,2,3,4] and arr2= [4,5,6,7] <= 4 appears n both arrays\\n2. If there are repeats, do we merge them or duplicate? that is [1,2,3,4,5,6,7] vs [1,2,3,4,4,5,6,7] \\nThey need to be more specific since we do not have an interviewer to ask these questions. \\n"
                    },
                    {
                        "username": "user2176B",
                        "content": "Brute force approach of simply adding the two arrays and sorting them and then returning the median value based on whether the length of array is even or odd is getting accepted . This approach has time complexity of (m+n)log(m+n) and space complexity O(m+n).\n\nNeeds harder test cases I suppose."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "This was the first thing that came to my mind, but when they said \"must run\" Ologn, i assumed it wouldn't be accepted. I am guessing they said that as a hint rather than a restriction. \nOr the test cases aren't doing their job well😂"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "A medium question in Hard list."
                    },
                    {
                        "username": "somendrajaat",
                        "content": "how the median of nums1=[2] and nums2 =[ ] is 2.0000     \\nit was supposed to be 1.00000 isn\\'t it?? "
                    },
                    {
                        "username": "alperkaya0",
                        "content": "No, combine nums1 and nums2, you get [2], n/2 because n is odd(n=1, length of the array). since n/2 = 0, 0th element is going to be returned."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "DON\\'T POST ANY SOLUTIONS HERE F****\\nTHERE IS A F*** DIFFERENT SECTION FOR SOLUTIONS"
                    }
                ]
            },
            {
                "id": 1930385,
                "content": [
                    {
                        "username": "ThoX",
                        "content": "That's my code in Python:  \n\n[class Solution(object):\n    |     def findMedianSortedArrays(self,nums1, nums2):\n    ||        L = sorted(nums1 + nums2)\n    ||        if len(L)%2 == 1:\n    |||           return L[int(len(L)/2)]\n    ||        else:\n    |||           return (L[int(len(L)/2) - 1] + L[int(len(L)/2)])/2]\n\nwith nums1 = [1,2] and nums = [3,4], I do not understand why the function gives me 2.0.\nI was expecting 2.5...\nI tested it in Spyder and it gives me 2.5 so the expected answer.\nI need help..."
                    },
                    {
                        "username": "mrunmayee0109",
                        "content": "Two approaches :\\n1) Use 2 pointer approach to find the middle elements of the two arrays and then find the median\\ncomplexity - O(m+n)\\n2) Simply merge the two arrays .extend(), use .sort() and then find the median\\ncomplexity - O((m+n)log(m+n))\\nEven if the complexity of this method is higher, surprisingly it satisfies all the test cases.\\nCannot be regarded as a hard question\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Many solutions are doing sort(merge(nums1 + nums2))    ;)\\nbut the reality is interviewer dig deep in such questions,, \\nfirst they will aloow you to use sort() function\\nthen they will say , you can not use inbuilt sort function.\\nthen they will say now do it without extra space and so on..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "why is this hard?\\n"
                    },
                    {
                        "username": "hiidracula",
                        "content": "while calculating cut2/mid2 = (n1+n2+1)/2-cut2/mid2. Why we we (+1) in total length?\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I haven\\'t solved this yet, but i want to know:\\n1. Are there repeats? e.g arr1 = [1,2,3,4] and arr2= [4,5,6,7] <= 4 appears n both arrays\\n2. If there are repeats, do we merge them or duplicate? that is [1,2,3,4,5,6,7] vs [1,2,3,4,4,5,6,7] \\nThey need to be more specific since we do not have an interviewer to ask these questions. \\n"
                    },
                    {
                        "username": "user2176B",
                        "content": "Brute force approach of simply adding the two arrays and sorting them and then returning the median value based on whether the length of array is even or odd is getting accepted . This approach has time complexity of (m+n)log(m+n) and space complexity O(m+n).\n\nNeeds harder test cases I suppose."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "This was the first thing that came to my mind, but when they said \"must run\" Ologn, i assumed it wouldn't be accepted. I am guessing they said that as a hint rather than a restriction. \nOr the test cases aren't doing their job well😂"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "A medium question in Hard list."
                    },
                    {
                        "username": "somendrajaat",
                        "content": "how the median of nums1=[2] and nums2 =[ ] is 2.0000     \\nit was supposed to be 1.00000 isn\\'t it?? "
                    },
                    {
                        "username": "alperkaya0",
                        "content": "No, combine nums1 and nums2, you get [2], n/2 because n is odd(n=1, length of the array). since n/2 = 0, 0th element is going to be returned."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "DON\\'T POST ANY SOLUTIONS HERE F****\\nTHERE IS A F*** DIFFERENT SECTION FOR SOLUTIONS"
                    }
                ]
            },
            {
                "id": 1930101,
                "content": [
                    {
                        "username": "ThoX",
                        "content": "That's my code in Python:  \n\n[class Solution(object):\n    |     def findMedianSortedArrays(self,nums1, nums2):\n    ||        L = sorted(nums1 + nums2)\n    ||        if len(L)%2 == 1:\n    |||           return L[int(len(L)/2)]\n    ||        else:\n    |||           return (L[int(len(L)/2) - 1] + L[int(len(L)/2)])/2]\n\nwith nums1 = [1,2] and nums = [3,4], I do not understand why the function gives me 2.0.\nI was expecting 2.5...\nI tested it in Spyder and it gives me 2.5 so the expected answer.\nI need help..."
                    },
                    {
                        "username": "mrunmayee0109",
                        "content": "Two approaches :\\n1) Use 2 pointer approach to find the middle elements of the two arrays and then find the median\\ncomplexity - O(m+n)\\n2) Simply merge the two arrays .extend(), use .sort() and then find the median\\ncomplexity - O((m+n)log(m+n))\\nEven if the complexity of this method is higher, surprisingly it satisfies all the test cases.\\nCannot be regarded as a hard question\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Many solutions are doing sort(merge(nums1 + nums2))    ;)\\nbut the reality is interviewer dig deep in such questions,, \\nfirst they will aloow you to use sort() function\\nthen they will say , you can not use inbuilt sort function.\\nthen they will say now do it without extra space and so on..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "why is this hard?\\n"
                    },
                    {
                        "username": "hiidracula",
                        "content": "while calculating cut2/mid2 = (n1+n2+1)/2-cut2/mid2. Why we we (+1) in total length?\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I haven\\'t solved this yet, but i want to know:\\n1. Are there repeats? e.g arr1 = [1,2,3,4] and arr2= [4,5,6,7] <= 4 appears n both arrays\\n2. If there are repeats, do we merge them or duplicate? that is [1,2,3,4,5,6,7] vs [1,2,3,4,4,5,6,7] \\nThey need to be more specific since we do not have an interviewer to ask these questions. \\n"
                    },
                    {
                        "username": "user2176B",
                        "content": "Brute force approach of simply adding the two arrays and sorting them and then returning the median value based on whether the length of array is even or odd is getting accepted . This approach has time complexity of (m+n)log(m+n) and space complexity O(m+n).\n\nNeeds harder test cases I suppose."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "This was the first thing that came to my mind, but when they said \"must run\" Ologn, i assumed it wouldn't be accepted. I am guessing they said that as a hint rather than a restriction. \nOr the test cases aren't doing their job well😂"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "A medium question in Hard list."
                    },
                    {
                        "username": "somendrajaat",
                        "content": "how the median of nums1=[2] and nums2 =[ ] is 2.0000     \\nit was supposed to be 1.00000 isn\\'t it?? "
                    },
                    {
                        "username": "alperkaya0",
                        "content": "No, combine nums1 and nums2, you get [2], n/2 because n is odd(n=1, length of the array). since n/2 = 0, 0th element is going to be returned."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "DON\\'T POST ANY SOLUTIONS HERE F****\\nTHERE IS A F*** DIFFERENT SECTION FOR SOLUTIONS"
                    }
                ]
            },
            {
                "id": 1929842,
                "content": [
                    {
                        "username": "ThoX",
                        "content": "That's my code in Python:  \n\n[class Solution(object):\n    |     def findMedianSortedArrays(self,nums1, nums2):\n    ||        L = sorted(nums1 + nums2)\n    ||        if len(L)%2 == 1:\n    |||           return L[int(len(L)/2)]\n    ||        else:\n    |||           return (L[int(len(L)/2) - 1] + L[int(len(L)/2)])/2]\n\nwith nums1 = [1,2] and nums = [3,4], I do not understand why the function gives me 2.0.\nI was expecting 2.5...\nI tested it in Spyder and it gives me 2.5 so the expected answer.\nI need help..."
                    },
                    {
                        "username": "mrunmayee0109",
                        "content": "Two approaches :\\n1) Use 2 pointer approach to find the middle elements of the two arrays and then find the median\\ncomplexity - O(m+n)\\n2) Simply merge the two arrays .extend(), use .sort() and then find the median\\ncomplexity - O((m+n)log(m+n))\\nEven if the complexity of this method is higher, surprisingly it satisfies all the test cases.\\nCannot be regarded as a hard question\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Many solutions are doing sort(merge(nums1 + nums2))    ;)\\nbut the reality is interviewer dig deep in such questions,, \\nfirst they will aloow you to use sort() function\\nthen they will say , you can not use inbuilt sort function.\\nthen they will say now do it without extra space and so on..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "why is this hard?\\n"
                    },
                    {
                        "username": "hiidracula",
                        "content": "while calculating cut2/mid2 = (n1+n2+1)/2-cut2/mid2. Why we we (+1) in total length?\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I haven\\'t solved this yet, but i want to know:\\n1. Are there repeats? e.g arr1 = [1,2,3,4] and arr2= [4,5,6,7] <= 4 appears n both arrays\\n2. If there are repeats, do we merge them or duplicate? that is [1,2,3,4,5,6,7] vs [1,2,3,4,4,5,6,7] \\nThey need to be more specific since we do not have an interviewer to ask these questions. \\n"
                    },
                    {
                        "username": "user2176B",
                        "content": "Brute force approach of simply adding the two arrays and sorting them and then returning the median value based on whether the length of array is even or odd is getting accepted . This approach has time complexity of (m+n)log(m+n) and space complexity O(m+n).\n\nNeeds harder test cases I suppose."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "This was the first thing that came to my mind, but when they said \"must run\" Ologn, i assumed it wouldn't be accepted. I am guessing they said that as a hint rather than a restriction. \nOr the test cases aren't doing their job well😂"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "A medium question in Hard list."
                    },
                    {
                        "username": "somendrajaat",
                        "content": "how the median of nums1=[2] and nums2 =[ ] is 2.0000     \\nit was supposed to be 1.00000 isn\\'t it?? "
                    },
                    {
                        "username": "alperkaya0",
                        "content": "No, combine nums1 and nums2, you get [2], n/2 because n is odd(n=1, length of the array). since n/2 = 0, 0th element is going to be returned."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "DON\\'T POST ANY SOLUTIONS HERE F****\\nTHERE IS A F*** DIFFERENT SECTION FOR SOLUTIONS"
                    }
                ]
            },
            {
                "id": 1923360,
                "content": [
                    {
                        "username": "ThoX",
                        "content": "That's my code in Python:  \n\n[class Solution(object):\n    |     def findMedianSortedArrays(self,nums1, nums2):\n    ||        L = sorted(nums1 + nums2)\n    ||        if len(L)%2 == 1:\n    |||           return L[int(len(L)/2)]\n    ||        else:\n    |||           return (L[int(len(L)/2) - 1] + L[int(len(L)/2)])/2]\n\nwith nums1 = [1,2] and nums = [3,4], I do not understand why the function gives me 2.0.\nI was expecting 2.5...\nI tested it in Spyder and it gives me 2.5 so the expected answer.\nI need help..."
                    },
                    {
                        "username": "mrunmayee0109",
                        "content": "Two approaches :\\n1) Use 2 pointer approach to find the middle elements of the two arrays and then find the median\\ncomplexity - O(m+n)\\n2) Simply merge the two arrays .extend(), use .sort() and then find the median\\ncomplexity - O((m+n)log(m+n))\\nEven if the complexity of this method is higher, surprisingly it satisfies all the test cases.\\nCannot be regarded as a hard question\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Many solutions are doing sort(merge(nums1 + nums2))    ;)\\nbut the reality is interviewer dig deep in such questions,, \\nfirst they will aloow you to use sort() function\\nthen they will say , you can not use inbuilt sort function.\\nthen they will say now do it without extra space and so on..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "why is this hard?\\n"
                    },
                    {
                        "username": "hiidracula",
                        "content": "while calculating cut2/mid2 = (n1+n2+1)/2-cut2/mid2. Why we we (+1) in total length?\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I haven\\'t solved this yet, but i want to know:\\n1. Are there repeats? e.g arr1 = [1,2,3,4] and arr2= [4,5,6,7] <= 4 appears n both arrays\\n2. If there are repeats, do we merge them or duplicate? that is [1,2,3,4,5,6,7] vs [1,2,3,4,4,5,6,7] \\nThey need to be more specific since we do not have an interviewer to ask these questions. \\n"
                    },
                    {
                        "username": "user2176B",
                        "content": "Brute force approach of simply adding the two arrays and sorting them and then returning the median value based on whether the length of array is even or odd is getting accepted . This approach has time complexity of (m+n)log(m+n) and space complexity O(m+n).\n\nNeeds harder test cases I suppose."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "This was the first thing that came to my mind, but when they said \"must run\" Ologn, i assumed it wouldn't be accepted. I am guessing they said that as a hint rather than a restriction. \nOr the test cases aren't doing their job well😂"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "A medium question in Hard list."
                    },
                    {
                        "username": "somendrajaat",
                        "content": "how the median of nums1=[2] and nums2 =[ ] is 2.0000     \\nit was supposed to be 1.00000 isn\\'t it?? "
                    },
                    {
                        "username": "alperkaya0",
                        "content": "No, combine nums1 and nums2, you get [2], n/2 because n is odd(n=1, length of the array). since n/2 = 0, 0th element is going to be returned."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "DON\\'T POST ANY SOLUTIONS HERE F****\\nTHERE IS A F*** DIFFERENT SECTION FOR SOLUTIONS"
                    }
                ]
            },
            {
                "id": 1919427,
                "content": [
                    {
                        "username": "ThoX",
                        "content": "That's my code in Python:  \n\n[class Solution(object):\n    |     def findMedianSortedArrays(self,nums1, nums2):\n    ||        L = sorted(nums1 + nums2)\n    ||        if len(L)%2 == 1:\n    |||           return L[int(len(L)/2)]\n    ||        else:\n    |||           return (L[int(len(L)/2) - 1] + L[int(len(L)/2)])/2]\n\nwith nums1 = [1,2] and nums = [3,4], I do not understand why the function gives me 2.0.\nI was expecting 2.5...\nI tested it in Spyder and it gives me 2.5 so the expected answer.\nI need help..."
                    },
                    {
                        "username": "mrunmayee0109",
                        "content": "Two approaches :\\n1) Use 2 pointer approach to find the middle elements of the two arrays and then find the median\\ncomplexity - O(m+n)\\n2) Simply merge the two arrays .extend(), use .sort() and then find the median\\ncomplexity - O((m+n)log(m+n))\\nEven if the complexity of this method is higher, surprisingly it satisfies all the test cases.\\nCannot be regarded as a hard question\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Many solutions are doing sort(merge(nums1 + nums2))    ;)\\nbut the reality is interviewer dig deep in such questions,, \\nfirst they will aloow you to use sort() function\\nthen they will say , you can not use inbuilt sort function.\\nthen they will say now do it without extra space and so on..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "why is this hard?\\n"
                    },
                    {
                        "username": "hiidracula",
                        "content": "while calculating cut2/mid2 = (n1+n2+1)/2-cut2/mid2. Why we we (+1) in total length?\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I haven\\'t solved this yet, but i want to know:\\n1. Are there repeats? e.g arr1 = [1,2,3,4] and arr2= [4,5,6,7] <= 4 appears n both arrays\\n2. If there are repeats, do we merge them or duplicate? that is [1,2,3,4,5,6,7] vs [1,2,3,4,4,5,6,7] \\nThey need to be more specific since we do not have an interviewer to ask these questions. \\n"
                    },
                    {
                        "username": "user2176B",
                        "content": "Brute force approach of simply adding the two arrays and sorting them and then returning the median value based on whether the length of array is even or odd is getting accepted . This approach has time complexity of (m+n)log(m+n) and space complexity O(m+n).\n\nNeeds harder test cases I suppose."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "This was the first thing that came to my mind, but when they said \"must run\" Ologn, i assumed it wouldn't be accepted. I am guessing they said that as a hint rather than a restriction. \nOr the test cases aren't doing their job well😂"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "A medium question in Hard list."
                    },
                    {
                        "username": "somendrajaat",
                        "content": "how the median of nums1=[2] and nums2 =[ ] is 2.0000     \\nit was supposed to be 1.00000 isn\\'t it?? "
                    },
                    {
                        "username": "alperkaya0",
                        "content": "No, combine nums1 and nums2, you get [2], n/2 because n is odd(n=1, length of the array). since n/2 = 0, 0th element is going to be returned."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "DON\\'T POST ANY SOLUTIONS HERE F****\\nTHERE IS A F*** DIFFERENT SECTION FOR SOLUTIONS"
                    }
                ]
            },
            {
                "id": 1915117,
                "content": [
                    {
                        "username": "ThoX",
                        "content": "That's my code in Python:  \n\n[class Solution(object):\n    |     def findMedianSortedArrays(self,nums1, nums2):\n    ||        L = sorted(nums1 + nums2)\n    ||        if len(L)%2 == 1:\n    |||           return L[int(len(L)/2)]\n    ||        else:\n    |||           return (L[int(len(L)/2) - 1] + L[int(len(L)/2)])/2]\n\nwith nums1 = [1,2] and nums = [3,4], I do not understand why the function gives me 2.0.\nI was expecting 2.5...\nI tested it in Spyder and it gives me 2.5 so the expected answer.\nI need help..."
                    },
                    {
                        "username": "mrunmayee0109",
                        "content": "Two approaches :\\n1) Use 2 pointer approach to find the middle elements of the two arrays and then find the median\\ncomplexity - O(m+n)\\n2) Simply merge the two arrays .extend(), use .sort() and then find the median\\ncomplexity - O((m+n)log(m+n))\\nEven if the complexity of this method is higher, surprisingly it satisfies all the test cases.\\nCannot be regarded as a hard question\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Many solutions are doing sort(merge(nums1 + nums2))    ;)\\nbut the reality is interviewer dig deep in such questions,, \\nfirst they will aloow you to use sort() function\\nthen they will say , you can not use inbuilt sort function.\\nthen they will say now do it without extra space and so on..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "why is this hard?\\n"
                    },
                    {
                        "username": "hiidracula",
                        "content": "while calculating cut2/mid2 = (n1+n2+1)/2-cut2/mid2. Why we we (+1) in total length?\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I haven\\'t solved this yet, but i want to know:\\n1. Are there repeats? e.g arr1 = [1,2,3,4] and arr2= [4,5,6,7] <= 4 appears n both arrays\\n2. If there are repeats, do we merge them or duplicate? that is [1,2,3,4,5,6,7] vs [1,2,3,4,4,5,6,7] \\nThey need to be more specific since we do not have an interviewer to ask these questions. \\n"
                    },
                    {
                        "username": "user2176B",
                        "content": "Brute force approach of simply adding the two arrays and sorting them and then returning the median value based on whether the length of array is even or odd is getting accepted . This approach has time complexity of (m+n)log(m+n) and space complexity O(m+n).\n\nNeeds harder test cases I suppose."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "This was the first thing that came to my mind, but when they said \"must run\" Ologn, i assumed it wouldn't be accepted. I am guessing they said that as a hint rather than a restriction. \nOr the test cases aren't doing their job well😂"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "A medium question in Hard list."
                    },
                    {
                        "username": "somendrajaat",
                        "content": "how the median of nums1=[2] and nums2 =[ ] is 2.0000     \\nit was supposed to be 1.00000 isn\\'t it?? "
                    },
                    {
                        "username": "alperkaya0",
                        "content": "No, combine nums1 and nums2, you get [2], n/2 because n is odd(n=1, length of the array). since n/2 = 0, 0th element is going to be returned."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "DON\\'T POST ANY SOLUTIONS HERE F****\\nTHERE IS A F*** DIFFERENT SECTION FOR SOLUTIONS"
                    }
                ]
            },
            {
                "id": 1912448,
                "content": [
                    {
                        "username": "ThoX",
                        "content": "That's my code in Python:  \n\n[class Solution(object):\n    |     def findMedianSortedArrays(self,nums1, nums2):\n    ||        L = sorted(nums1 + nums2)\n    ||        if len(L)%2 == 1:\n    |||           return L[int(len(L)/2)]\n    ||        else:\n    |||           return (L[int(len(L)/2) - 1] + L[int(len(L)/2)])/2]\n\nwith nums1 = [1,2] and nums = [3,4], I do not understand why the function gives me 2.0.\nI was expecting 2.5...\nI tested it in Spyder and it gives me 2.5 so the expected answer.\nI need help..."
                    },
                    {
                        "username": "mrunmayee0109",
                        "content": "Two approaches :\\n1) Use 2 pointer approach to find the middle elements of the two arrays and then find the median\\ncomplexity - O(m+n)\\n2) Simply merge the two arrays .extend(), use .sort() and then find the median\\ncomplexity - O((m+n)log(m+n))\\nEven if the complexity of this method is higher, surprisingly it satisfies all the test cases.\\nCannot be regarded as a hard question\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Many solutions are doing sort(merge(nums1 + nums2))    ;)\\nbut the reality is interviewer dig deep in such questions,, \\nfirst they will aloow you to use sort() function\\nthen they will say , you can not use inbuilt sort function.\\nthen they will say now do it without extra space and so on..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "why is this hard?\\n"
                    },
                    {
                        "username": "hiidracula",
                        "content": "while calculating cut2/mid2 = (n1+n2+1)/2-cut2/mid2. Why we we (+1) in total length?\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I haven\\'t solved this yet, but i want to know:\\n1. Are there repeats? e.g arr1 = [1,2,3,4] and arr2= [4,5,6,7] <= 4 appears n both arrays\\n2. If there are repeats, do we merge them or duplicate? that is [1,2,3,4,5,6,7] vs [1,2,3,4,4,5,6,7] \\nThey need to be more specific since we do not have an interviewer to ask these questions. \\n"
                    },
                    {
                        "username": "user2176B",
                        "content": "Brute force approach of simply adding the two arrays and sorting them and then returning the median value based on whether the length of array is even or odd is getting accepted . This approach has time complexity of (m+n)log(m+n) and space complexity O(m+n).\n\nNeeds harder test cases I suppose."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "This was the first thing that came to my mind, but when they said \"must run\" Ologn, i assumed it wouldn't be accepted. I am guessing they said that as a hint rather than a restriction. \nOr the test cases aren't doing their job well😂"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "A medium question in Hard list."
                    },
                    {
                        "username": "somendrajaat",
                        "content": "how the median of nums1=[2] and nums2 =[ ] is 2.0000     \\nit was supposed to be 1.00000 isn\\'t it?? "
                    },
                    {
                        "username": "alperkaya0",
                        "content": "No, combine nums1 and nums2, you get [2], n/2 because n is odd(n=1, length of the array). since n/2 = 0, 0th element is going to be returned."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "DON\\'T POST ANY SOLUTIONS HERE F****\\nTHERE IS A F*** DIFFERENT SECTION FOR SOLUTIONS"
                    }
                ]
            },
            {
                "id": 1912370,
                "content": [
                    {
                        "username": "s3xyincorporated",
                        "content": "for the [1,2] [3,4]  the expected answer is 2.5, my code produces 2.0. \\nbut if I run the same exact code in my editor I get 2.5 ..... so, what is going on?\\n\\nwith [1,3] [2] : it works fine\\n\\nbut\\n\\nwith custom [1,2,3] [4,5,6] : I get the same stuff. output : 3.0, expected : 3.5.\\nWhen I run the code in my editor : 3.5"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This question is broken."
                    },
                    {
                        "username": "_-Rac00n-_",
                        "content": "hello, I have a cod wich work in my IDE corectly, but on leetcode he doesn\\'t wok(((\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        for i in range(len(nums2)):\\n            nums1.append(nums2[i])\\n        nums1.sort()\\n        if(len(nums1)%2 == 0 ):\\n            first = int(len(nums1)/2)\\n            second = first-1\\n            res = (nums1[first]+nums1[second]) / 2\\n            return res\\n        else:\\n            b = int(len(nums1)/2)\\n            return nums1[b]\\nwhat I do uncorectly?("
                    },
                    {
                        "username": "krishrajpal03",
                        "content": "why is this question in the hard category?\\n"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "input=[1,3] [2,7]\\noutput=3.25\\nexpected=2.5\\n but  how?\\nplease help me\\n"
                    },
                    {
                        "username": "Harital",
                        "content": "Median is the element in the middle of vector. The merged vector would be [1, 2, 3, 7]. the element in the middle is the element between 2 and 3. Hence, 2,5. It\\xB4s easier in vectors with an odd number of elements."
                    },
                    {
                        "username": "sondidu",
                        "content": "I kind of hate it that I tried to build a solution that solves in O(log(m+n)) but is somehow slower to other\\'s solutions where they just join the two lists and find the median."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "the test cases is to small"
                    },
                    {
                        "username": "bnbnac",
                        "content": "omg would you share your solution?"
                    },
                    {
                        "username": "syvicpros18",
                        "content": "Oh?\\ndef Median(l1, l2):\\n    for item in l2:\\n        l1.append(item)\\n\\n    l1.sort()\\n\\n    if len(l1) % 2 == 0:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n    if len(l1) % 2 != 0:\\n        ans = float(l1[len(l1) // 2])\\n        return ans\\n    if len(l1) == 2:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n\\n\\nl1 = [1, 2]\\nl2 = [3, 4]\\nprint(Median(l1, l2))\\n\\nMy output: 2.50000\\nThis output: 2.00000\\n\\nWhat\\'s wrong?"
                    },
                    {
                        "username": "bnbnac",
                        "content": "yours:\\nans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n\\nmaybe:\\nans = (l1[len(l1) // 2] + l1[(len(l1) // 2) + 1]) / 2"
                    },
                    {
                        "username": "ADARSH_CODE_01",
                        "content": "axa\\'\\'c "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "why this task is marked as a \"hard\" one ?"
                    },
                    {
                        "username": "pbrubak",
                        "content": "After all, if in an interview a candidate was asked to implement an O(log(m+n)) solution, and they implemented a simple O(m+n) merge while protesting, \"but it passed the test cases\", it is unlikely the interviewer would find that answer acceptable."
                    },
                    {
                        "username": "pbrubak",
                        "content": "The hard ranking assumes the user will implement an actual O(log(m+n)) solution."
                    },
                    {
                        "username": "tori5",
                        "content": "My code and i have an error :\\nOutput Limit Exceeded\\n2094 / 2094 testcases passed\\nLast Executed Input\\nnums1 =\\n\\n\\nI cant understand why is not working so can someone help me understand \\n\\n\\n`var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++](var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++)\\n    }else{\\n        \\n        if(val1 < val2 && val1){\\n            console.log(\"cas 1\")\\n            let k = i\\n            while( k < nums1.length && nums1[k] < val2 ){\\n                temp.push(nums1[k])\\n                k++\\n            console.log(\"temp loop1\", temp)\\n            }\\n            i = k\\n            \\n        }\\n        else{\\n            console.log(\"cas 2\")\\n            let h = j\\n            while( h < nums2.length && nums2[h] < val1 ){\\n                temp.push(nums2[h])\\n                h++\\n                console.log(\"temp loop2\", temp ,\"index h\",h)\\n            }\\n            j = h\\n        }\\n    }\\n    \\n    }\\n    console.log(\"temp\", temp, \"indexs\" , i ,j ,\"len\", len, \"templen\", temp.length )\\n    \\n    const diff = parseInt(temp[temp.length / 2 - 1])\\n    if(temp.length % 2 == 0){\\n        return (parseInt(temp[temp.length / 2  -1 ] )+ parseInt(temp[temp.length / 2  ] )  ) / 2 \\n    }\\n    return temp[temp.length / 2 + 0.5 -1] \\n    \\n};`\\n\\n"
                    },
                    {
                        "username": "pbrubak",
                        "content": "'Output Limit Exceeded' most likely means you are trying to log too much to the console. Try removing (or commenting out) all your console logs and running again."
                    }
                ]
            },
            {
                "id": 1909890,
                "content": [
                    {
                        "username": "s3xyincorporated",
                        "content": "for the [1,2] [3,4]  the expected answer is 2.5, my code produces 2.0. \\nbut if I run the same exact code in my editor I get 2.5 ..... so, what is going on?\\n\\nwith [1,3] [2] : it works fine\\n\\nbut\\n\\nwith custom [1,2,3] [4,5,6] : I get the same stuff. output : 3.0, expected : 3.5.\\nWhen I run the code in my editor : 3.5"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This question is broken."
                    },
                    {
                        "username": "_-Rac00n-_",
                        "content": "hello, I have a cod wich work in my IDE corectly, but on leetcode he doesn\\'t wok(((\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        for i in range(len(nums2)):\\n            nums1.append(nums2[i])\\n        nums1.sort()\\n        if(len(nums1)%2 == 0 ):\\n            first = int(len(nums1)/2)\\n            second = first-1\\n            res = (nums1[first]+nums1[second]) / 2\\n            return res\\n        else:\\n            b = int(len(nums1)/2)\\n            return nums1[b]\\nwhat I do uncorectly?("
                    },
                    {
                        "username": "krishrajpal03",
                        "content": "why is this question in the hard category?\\n"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "input=[1,3] [2,7]\\noutput=3.25\\nexpected=2.5\\n but  how?\\nplease help me\\n"
                    },
                    {
                        "username": "Harital",
                        "content": "Median is the element in the middle of vector. The merged vector would be [1, 2, 3, 7]. the element in the middle is the element between 2 and 3. Hence, 2,5. It\\xB4s easier in vectors with an odd number of elements."
                    },
                    {
                        "username": "sondidu",
                        "content": "I kind of hate it that I tried to build a solution that solves in O(log(m+n)) but is somehow slower to other\\'s solutions where they just join the two lists and find the median."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "the test cases is to small"
                    },
                    {
                        "username": "bnbnac",
                        "content": "omg would you share your solution?"
                    },
                    {
                        "username": "syvicpros18",
                        "content": "Oh?\\ndef Median(l1, l2):\\n    for item in l2:\\n        l1.append(item)\\n\\n    l1.sort()\\n\\n    if len(l1) % 2 == 0:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n    if len(l1) % 2 != 0:\\n        ans = float(l1[len(l1) // 2])\\n        return ans\\n    if len(l1) == 2:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n\\n\\nl1 = [1, 2]\\nl2 = [3, 4]\\nprint(Median(l1, l2))\\n\\nMy output: 2.50000\\nThis output: 2.00000\\n\\nWhat\\'s wrong?"
                    },
                    {
                        "username": "bnbnac",
                        "content": "yours:\\nans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n\\nmaybe:\\nans = (l1[len(l1) // 2] + l1[(len(l1) // 2) + 1]) / 2"
                    },
                    {
                        "username": "ADARSH_CODE_01",
                        "content": "axa\\'\\'c "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "why this task is marked as a \"hard\" one ?"
                    },
                    {
                        "username": "pbrubak",
                        "content": "After all, if in an interview a candidate was asked to implement an O(log(m+n)) solution, and they implemented a simple O(m+n) merge while protesting, \"but it passed the test cases\", it is unlikely the interviewer would find that answer acceptable."
                    },
                    {
                        "username": "pbrubak",
                        "content": "The hard ranking assumes the user will implement an actual O(log(m+n)) solution."
                    },
                    {
                        "username": "tori5",
                        "content": "My code and i have an error :\\nOutput Limit Exceeded\\n2094 / 2094 testcases passed\\nLast Executed Input\\nnums1 =\\n\\n\\nI cant understand why is not working so can someone help me understand \\n\\n\\n`var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++](var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++)\\n    }else{\\n        \\n        if(val1 < val2 && val1){\\n            console.log(\"cas 1\")\\n            let k = i\\n            while( k < nums1.length && nums1[k] < val2 ){\\n                temp.push(nums1[k])\\n                k++\\n            console.log(\"temp loop1\", temp)\\n            }\\n            i = k\\n            \\n        }\\n        else{\\n            console.log(\"cas 2\")\\n            let h = j\\n            while( h < nums2.length && nums2[h] < val1 ){\\n                temp.push(nums2[h])\\n                h++\\n                console.log(\"temp loop2\", temp ,\"index h\",h)\\n            }\\n            j = h\\n        }\\n    }\\n    \\n    }\\n    console.log(\"temp\", temp, \"indexs\" , i ,j ,\"len\", len, \"templen\", temp.length )\\n    \\n    const diff = parseInt(temp[temp.length / 2 - 1])\\n    if(temp.length % 2 == 0){\\n        return (parseInt(temp[temp.length / 2  -1 ] )+ parseInt(temp[temp.length / 2  ] )  ) / 2 \\n    }\\n    return temp[temp.length / 2 + 0.5 -1] \\n    \\n};`\\n\\n"
                    },
                    {
                        "username": "pbrubak",
                        "content": "'Output Limit Exceeded' most likely means you are trying to log too much to the console. Try removing (or commenting out) all your console logs and running again."
                    }
                ]
            },
            {
                "id": 1909220,
                "content": [
                    {
                        "username": "s3xyincorporated",
                        "content": "for the [1,2] [3,4]  the expected answer is 2.5, my code produces 2.0. \\nbut if I run the same exact code in my editor I get 2.5 ..... so, what is going on?\\n\\nwith [1,3] [2] : it works fine\\n\\nbut\\n\\nwith custom [1,2,3] [4,5,6] : I get the same stuff. output : 3.0, expected : 3.5.\\nWhen I run the code in my editor : 3.5"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This question is broken."
                    },
                    {
                        "username": "_-Rac00n-_",
                        "content": "hello, I have a cod wich work in my IDE corectly, but on leetcode he doesn\\'t wok(((\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        for i in range(len(nums2)):\\n            nums1.append(nums2[i])\\n        nums1.sort()\\n        if(len(nums1)%2 == 0 ):\\n            first = int(len(nums1)/2)\\n            second = first-1\\n            res = (nums1[first]+nums1[second]) / 2\\n            return res\\n        else:\\n            b = int(len(nums1)/2)\\n            return nums1[b]\\nwhat I do uncorectly?("
                    },
                    {
                        "username": "krishrajpal03",
                        "content": "why is this question in the hard category?\\n"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "input=[1,3] [2,7]\\noutput=3.25\\nexpected=2.5\\n but  how?\\nplease help me\\n"
                    },
                    {
                        "username": "Harital",
                        "content": "Median is the element in the middle of vector. The merged vector would be [1, 2, 3, 7]. the element in the middle is the element between 2 and 3. Hence, 2,5. It\\xB4s easier in vectors with an odd number of elements."
                    },
                    {
                        "username": "sondidu",
                        "content": "I kind of hate it that I tried to build a solution that solves in O(log(m+n)) but is somehow slower to other\\'s solutions where they just join the two lists and find the median."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "the test cases is to small"
                    },
                    {
                        "username": "bnbnac",
                        "content": "omg would you share your solution?"
                    },
                    {
                        "username": "syvicpros18",
                        "content": "Oh?\\ndef Median(l1, l2):\\n    for item in l2:\\n        l1.append(item)\\n\\n    l1.sort()\\n\\n    if len(l1) % 2 == 0:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n    if len(l1) % 2 != 0:\\n        ans = float(l1[len(l1) // 2])\\n        return ans\\n    if len(l1) == 2:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n\\n\\nl1 = [1, 2]\\nl2 = [3, 4]\\nprint(Median(l1, l2))\\n\\nMy output: 2.50000\\nThis output: 2.00000\\n\\nWhat\\'s wrong?"
                    },
                    {
                        "username": "bnbnac",
                        "content": "yours:\\nans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n\\nmaybe:\\nans = (l1[len(l1) // 2] + l1[(len(l1) // 2) + 1]) / 2"
                    },
                    {
                        "username": "ADARSH_CODE_01",
                        "content": "axa\\'\\'c "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "why this task is marked as a \"hard\" one ?"
                    },
                    {
                        "username": "pbrubak",
                        "content": "After all, if in an interview a candidate was asked to implement an O(log(m+n)) solution, and they implemented a simple O(m+n) merge while protesting, \"but it passed the test cases\", it is unlikely the interviewer would find that answer acceptable."
                    },
                    {
                        "username": "pbrubak",
                        "content": "The hard ranking assumes the user will implement an actual O(log(m+n)) solution."
                    },
                    {
                        "username": "tori5",
                        "content": "My code and i have an error :\\nOutput Limit Exceeded\\n2094 / 2094 testcases passed\\nLast Executed Input\\nnums1 =\\n\\n\\nI cant understand why is not working so can someone help me understand \\n\\n\\n`var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++](var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++)\\n    }else{\\n        \\n        if(val1 < val2 && val1){\\n            console.log(\"cas 1\")\\n            let k = i\\n            while( k < nums1.length && nums1[k] < val2 ){\\n                temp.push(nums1[k])\\n                k++\\n            console.log(\"temp loop1\", temp)\\n            }\\n            i = k\\n            \\n        }\\n        else{\\n            console.log(\"cas 2\")\\n            let h = j\\n            while( h < nums2.length && nums2[h] < val1 ){\\n                temp.push(nums2[h])\\n                h++\\n                console.log(\"temp loop2\", temp ,\"index h\",h)\\n            }\\n            j = h\\n        }\\n    }\\n    \\n    }\\n    console.log(\"temp\", temp, \"indexs\" , i ,j ,\"len\", len, \"templen\", temp.length )\\n    \\n    const diff = parseInt(temp[temp.length / 2 - 1])\\n    if(temp.length % 2 == 0){\\n        return (parseInt(temp[temp.length / 2  -1 ] )+ parseInt(temp[temp.length / 2  ] )  ) / 2 \\n    }\\n    return temp[temp.length / 2 + 0.5 -1] \\n    \\n};`\\n\\n"
                    },
                    {
                        "username": "pbrubak",
                        "content": "'Output Limit Exceeded' most likely means you are trying to log too much to the console. Try removing (or commenting out) all your console logs and running again."
                    }
                ]
            },
            {
                "id": 1904719,
                "content": [
                    {
                        "username": "s3xyincorporated",
                        "content": "for the [1,2] [3,4]  the expected answer is 2.5, my code produces 2.0. \\nbut if I run the same exact code in my editor I get 2.5 ..... so, what is going on?\\n\\nwith [1,3] [2] : it works fine\\n\\nbut\\n\\nwith custom [1,2,3] [4,5,6] : I get the same stuff. output : 3.0, expected : 3.5.\\nWhen I run the code in my editor : 3.5"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This question is broken."
                    },
                    {
                        "username": "_-Rac00n-_",
                        "content": "hello, I have a cod wich work in my IDE corectly, but on leetcode he doesn\\'t wok(((\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        for i in range(len(nums2)):\\n            nums1.append(nums2[i])\\n        nums1.sort()\\n        if(len(nums1)%2 == 0 ):\\n            first = int(len(nums1)/2)\\n            second = first-1\\n            res = (nums1[first]+nums1[second]) / 2\\n            return res\\n        else:\\n            b = int(len(nums1)/2)\\n            return nums1[b]\\nwhat I do uncorectly?("
                    },
                    {
                        "username": "krishrajpal03",
                        "content": "why is this question in the hard category?\\n"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "input=[1,3] [2,7]\\noutput=3.25\\nexpected=2.5\\n but  how?\\nplease help me\\n"
                    },
                    {
                        "username": "Harital",
                        "content": "Median is the element in the middle of vector. The merged vector would be [1, 2, 3, 7]. the element in the middle is the element between 2 and 3. Hence, 2,5. It\\xB4s easier in vectors with an odd number of elements."
                    },
                    {
                        "username": "sondidu",
                        "content": "I kind of hate it that I tried to build a solution that solves in O(log(m+n)) but is somehow slower to other\\'s solutions where they just join the two lists and find the median."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "the test cases is to small"
                    },
                    {
                        "username": "bnbnac",
                        "content": "omg would you share your solution?"
                    },
                    {
                        "username": "syvicpros18",
                        "content": "Oh?\\ndef Median(l1, l2):\\n    for item in l2:\\n        l1.append(item)\\n\\n    l1.sort()\\n\\n    if len(l1) % 2 == 0:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n    if len(l1) % 2 != 0:\\n        ans = float(l1[len(l1) // 2])\\n        return ans\\n    if len(l1) == 2:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n\\n\\nl1 = [1, 2]\\nl2 = [3, 4]\\nprint(Median(l1, l2))\\n\\nMy output: 2.50000\\nThis output: 2.00000\\n\\nWhat\\'s wrong?"
                    },
                    {
                        "username": "bnbnac",
                        "content": "yours:\\nans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n\\nmaybe:\\nans = (l1[len(l1) // 2] + l1[(len(l1) // 2) + 1]) / 2"
                    },
                    {
                        "username": "ADARSH_CODE_01",
                        "content": "axa\\'\\'c "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "why this task is marked as a \"hard\" one ?"
                    },
                    {
                        "username": "pbrubak",
                        "content": "After all, if in an interview a candidate was asked to implement an O(log(m+n)) solution, and they implemented a simple O(m+n) merge while protesting, \"but it passed the test cases\", it is unlikely the interviewer would find that answer acceptable."
                    },
                    {
                        "username": "pbrubak",
                        "content": "The hard ranking assumes the user will implement an actual O(log(m+n)) solution."
                    },
                    {
                        "username": "tori5",
                        "content": "My code and i have an error :\\nOutput Limit Exceeded\\n2094 / 2094 testcases passed\\nLast Executed Input\\nnums1 =\\n\\n\\nI cant understand why is not working so can someone help me understand \\n\\n\\n`var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++](var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++)\\n    }else{\\n        \\n        if(val1 < val2 && val1){\\n            console.log(\"cas 1\")\\n            let k = i\\n            while( k < nums1.length && nums1[k] < val2 ){\\n                temp.push(nums1[k])\\n                k++\\n            console.log(\"temp loop1\", temp)\\n            }\\n            i = k\\n            \\n        }\\n        else{\\n            console.log(\"cas 2\")\\n            let h = j\\n            while( h < nums2.length && nums2[h] < val1 ){\\n                temp.push(nums2[h])\\n                h++\\n                console.log(\"temp loop2\", temp ,\"index h\",h)\\n            }\\n            j = h\\n        }\\n    }\\n    \\n    }\\n    console.log(\"temp\", temp, \"indexs\" , i ,j ,\"len\", len, \"templen\", temp.length )\\n    \\n    const diff = parseInt(temp[temp.length / 2 - 1])\\n    if(temp.length % 2 == 0){\\n        return (parseInt(temp[temp.length / 2  -1 ] )+ parseInt(temp[temp.length / 2  ] )  ) / 2 \\n    }\\n    return temp[temp.length / 2 + 0.5 -1] \\n    \\n};`\\n\\n"
                    },
                    {
                        "username": "pbrubak",
                        "content": "'Output Limit Exceeded' most likely means you are trying to log too much to the console. Try removing (or commenting out) all your console logs and running again."
                    }
                ]
            },
            {
                "id": 1897165,
                "content": [
                    {
                        "username": "s3xyincorporated",
                        "content": "for the [1,2] [3,4]  the expected answer is 2.5, my code produces 2.0. \\nbut if I run the same exact code in my editor I get 2.5 ..... so, what is going on?\\n\\nwith [1,3] [2] : it works fine\\n\\nbut\\n\\nwith custom [1,2,3] [4,5,6] : I get the same stuff. output : 3.0, expected : 3.5.\\nWhen I run the code in my editor : 3.5"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This question is broken."
                    },
                    {
                        "username": "_-Rac00n-_",
                        "content": "hello, I have a cod wich work in my IDE corectly, but on leetcode he doesn\\'t wok(((\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        for i in range(len(nums2)):\\n            nums1.append(nums2[i])\\n        nums1.sort()\\n        if(len(nums1)%2 == 0 ):\\n            first = int(len(nums1)/2)\\n            second = first-1\\n            res = (nums1[first]+nums1[second]) / 2\\n            return res\\n        else:\\n            b = int(len(nums1)/2)\\n            return nums1[b]\\nwhat I do uncorectly?("
                    },
                    {
                        "username": "krishrajpal03",
                        "content": "why is this question in the hard category?\\n"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "input=[1,3] [2,7]\\noutput=3.25\\nexpected=2.5\\n but  how?\\nplease help me\\n"
                    },
                    {
                        "username": "Harital",
                        "content": "Median is the element in the middle of vector. The merged vector would be [1, 2, 3, 7]. the element in the middle is the element between 2 and 3. Hence, 2,5. It\\xB4s easier in vectors with an odd number of elements."
                    },
                    {
                        "username": "sondidu",
                        "content": "I kind of hate it that I tried to build a solution that solves in O(log(m+n)) but is somehow slower to other\\'s solutions where they just join the two lists and find the median."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "the test cases is to small"
                    },
                    {
                        "username": "bnbnac",
                        "content": "omg would you share your solution?"
                    },
                    {
                        "username": "syvicpros18",
                        "content": "Oh?\\ndef Median(l1, l2):\\n    for item in l2:\\n        l1.append(item)\\n\\n    l1.sort()\\n\\n    if len(l1) % 2 == 0:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n    if len(l1) % 2 != 0:\\n        ans = float(l1[len(l1) // 2])\\n        return ans\\n    if len(l1) == 2:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n\\n\\nl1 = [1, 2]\\nl2 = [3, 4]\\nprint(Median(l1, l2))\\n\\nMy output: 2.50000\\nThis output: 2.00000\\n\\nWhat\\'s wrong?"
                    },
                    {
                        "username": "bnbnac",
                        "content": "yours:\\nans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n\\nmaybe:\\nans = (l1[len(l1) // 2] + l1[(len(l1) // 2) + 1]) / 2"
                    },
                    {
                        "username": "ADARSH_CODE_01",
                        "content": "axa\\'\\'c "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "why this task is marked as a \"hard\" one ?"
                    },
                    {
                        "username": "pbrubak",
                        "content": "After all, if in an interview a candidate was asked to implement an O(log(m+n)) solution, and they implemented a simple O(m+n) merge while protesting, \"but it passed the test cases\", it is unlikely the interviewer would find that answer acceptable."
                    },
                    {
                        "username": "pbrubak",
                        "content": "The hard ranking assumes the user will implement an actual O(log(m+n)) solution."
                    },
                    {
                        "username": "tori5",
                        "content": "My code and i have an error :\\nOutput Limit Exceeded\\n2094 / 2094 testcases passed\\nLast Executed Input\\nnums1 =\\n\\n\\nI cant understand why is not working so can someone help me understand \\n\\n\\n`var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++](var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++)\\n    }else{\\n        \\n        if(val1 < val2 && val1){\\n            console.log(\"cas 1\")\\n            let k = i\\n            while( k < nums1.length && nums1[k] < val2 ){\\n                temp.push(nums1[k])\\n                k++\\n            console.log(\"temp loop1\", temp)\\n            }\\n            i = k\\n            \\n        }\\n        else{\\n            console.log(\"cas 2\")\\n            let h = j\\n            while( h < nums2.length && nums2[h] < val1 ){\\n                temp.push(nums2[h])\\n                h++\\n                console.log(\"temp loop2\", temp ,\"index h\",h)\\n            }\\n            j = h\\n        }\\n    }\\n    \\n    }\\n    console.log(\"temp\", temp, \"indexs\" , i ,j ,\"len\", len, \"templen\", temp.length )\\n    \\n    const diff = parseInt(temp[temp.length / 2 - 1])\\n    if(temp.length % 2 == 0){\\n        return (parseInt(temp[temp.length / 2  -1 ] )+ parseInt(temp[temp.length / 2  ] )  ) / 2 \\n    }\\n    return temp[temp.length / 2 + 0.5 -1] \\n    \\n};`\\n\\n"
                    },
                    {
                        "username": "pbrubak",
                        "content": "'Output Limit Exceeded' most likely means you are trying to log too much to the console. Try removing (or commenting out) all your console logs and running again."
                    }
                ]
            },
            {
                "id": 1894000,
                "content": [
                    {
                        "username": "s3xyincorporated",
                        "content": "for the [1,2] [3,4]  the expected answer is 2.5, my code produces 2.0. \\nbut if I run the same exact code in my editor I get 2.5 ..... so, what is going on?\\n\\nwith [1,3] [2] : it works fine\\n\\nbut\\n\\nwith custom [1,2,3] [4,5,6] : I get the same stuff. output : 3.0, expected : 3.5.\\nWhen I run the code in my editor : 3.5"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This question is broken."
                    },
                    {
                        "username": "_-Rac00n-_",
                        "content": "hello, I have a cod wich work in my IDE corectly, but on leetcode he doesn\\'t wok(((\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        for i in range(len(nums2)):\\n            nums1.append(nums2[i])\\n        nums1.sort()\\n        if(len(nums1)%2 == 0 ):\\n            first = int(len(nums1)/2)\\n            second = first-1\\n            res = (nums1[first]+nums1[second]) / 2\\n            return res\\n        else:\\n            b = int(len(nums1)/2)\\n            return nums1[b]\\nwhat I do uncorectly?("
                    },
                    {
                        "username": "krishrajpal03",
                        "content": "why is this question in the hard category?\\n"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "input=[1,3] [2,7]\\noutput=3.25\\nexpected=2.5\\n but  how?\\nplease help me\\n"
                    },
                    {
                        "username": "Harital",
                        "content": "Median is the element in the middle of vector. The merged vector would be [1, 2, 3, 7]. the element in the middle is the element between 2 and 3. Hence, 2,5. It\\xB4s easier in vectors with an odd number of elements."
                    },
                    {
                        "username": "sondidu",
                        "content": "I kind of hate it that I tried to build a solution that solves in O(log(m+n)) but is somehow slower to other\\'s solutions where they just join the two lists and find the median."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "the test cases is to small"
                    },
                    {
                        "username": "bnbnac",
                        "content": "omg would you share your solution?"
                    },
                    {
                        "username": "syvicpros18",
                        "content": "Oh?\\ndef Median(l1, l2):\\n    for item in l2:\\n        l1.append(item)\\n\\n    l1.sort()\\n\\n    if len(l1) % 2 == 0:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n    if len(l1) % 2 != 0:\\n        ans = float(l1[len(l1) // 2])\\n        return ans\\n    if len(l1) == 2:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n\\n\\nl1 = [1, 2]\\nl2 = [3, 4]\\nprint(Median(l1, l2))\\n\\nMy output: 2.50000\\nThis output: 2.00000\\n\\nWhat\\'s wrong?"
                    },
                    {
                        "username": "bnbnac",
                        "content": "yours:\\nans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n\\nmaybe:\\nans = (l1[len(l1) // 2] + l1[(len(l1) // 2) + 1]) / 2"
                    },
                    {
                        "username": "ADARSH_CODE_01",
                        "content": "axa\\'\\'c "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "why this task is marked as a \"hard\" one ?"
                    },
                    {
                        "username": "pbrubak",
                        "content": "After all, if in an interview a candidate was asked to implement an O(log(m+n)) solution, and they implemented a simple O(m+n) merge while protesting, \"but it passed the test cases\", it is unlikely the interviewer would find that answer acceptable."
                    },
                    {
                        "username": "pbrubak",
                        "content": "The hard ranking assumes the user will implement an actual O(log(m+n)) solution."
                    },
                    {
                        "username": "tori5",
                        "content": "My code and i have an error :\\nOutput Limit Exceeded\\n2094 / 2094 testcases passed\\nLast Executed Input\\nnums1 =\\n\\n\\nI cant understand why is not working so can someone help me understand \\n\\n\\n`var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++](var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++)\\n    }else{\\n        \\n        if(val1 < val2 && val1){\\n            console.log(\"cas 1\")\\n            let k = i\\n            while( k < nums1.length && nums1[k] < val2 ){\\n                temp.push(nums1[k])\\n                k++\\n            console.log(\"temp loop1\", temp)\\n            }\\n            i = k\\n            \\n        }\\n        else{\\n            console.log(\"cas 2\")\\n            let h = j\\n            while( h < nums2.length && nums2[h] < val1 ){\\n                temp.push(nums2[h])\\n                h++\\n                console.log(\"temp loop2\", temp ,\"index h\",h)\\n            }\\n            j = h\\n        }\\n    }\\n    \\n    }\\n    console.log(\"temp\", temp, \"indexs\" , i ,j ,\"len\", len, \"templen\", temp.length )\\n    \\n    const diff = parseInt(temp[temp.length / 2 - 1])\\n    if(temp.length % 2 == 0){\\n        return (parseInt(temp[temp.length / 2  -1 ] )+ parseInt(temp[temp.length / 2  ] )  ) / 2 \\n    }\\n    return temp[temp.length / 2 + 0.5 -1] \\n    \\n};`\\n\\n"
                    },
                    {
                        "username": "pbrubak",
                        "content": "'Output Limit Exceeded' most likely means you are trying to log too much to the console. Try removing (or commenting out) all your console logs and running again."
                    }
                ]
            },
            {
                "id": 1891466,
                "content": [
                    {
                        "username": "s3xyincorporated",
                        "content": "for the [1,2] [3,4]  the expected answer is 2.5, my code produces 2.0. \\nbut if I run the same exact code in my editor I get 2.5 ..... so, what is going on?\\n\\nwith [1,3] [2] : it works fine\\n\\nbut\\n\\nwith custom [1,2,3] [4,5,6] : I get the same stuff. output : 3.0, expected : 3.5.\\nWhen I run the code in my editor : 3.5"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This question is broken."
                    },
                    {
                        "username": "_-Rac00n-_",
                        "content": "hello, I have a cod wich work in my IDE corectly, but on leetcode he doesn\\'t wok(((\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        for i in range(len(nums2)):\\n            nums1.append(nums2[i])\\n        nums1.sort()\\n        if(len(nums1)%2 == 0 ):\\n            first = int(len(nums1)/2)\\n            second = first-1\\n            res = (nums1[first]+nums1[second]) / 2\\n            return res\\n        else:\\n            b = int(len(nums1)/2)\\n            return nums1[b]\\nwhat I do uncorectly?("
                    },
                    {
                        "username": "krishrajpal03",
                        "content": "why is this question in the hard category?\\n"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "input=[1,3] [2,7]\\noutput=3.25\\nexpected=2.5\\n but  how?\\nplease help me\\n"
                    },
                    {
                        "username": "Harital",
                        "content": "Median is the element in the middle of vector. The merged vector would be [1, 2, 3, 7]. the element in the middle is the element between 2 and 3. Hence, 2,5. It\\xB4s easier in vectors with an odd number of elements."
                    },
                    {
                        "username": "sondidu",
                        "content": "I kind of hate it that I tried to build a solution that solves in O(log(m+n)) but is somehow slower to other\\'s solutions where they just join the two lists and find the median."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "the test cases is to small"
                    },
                    {
                        "username": "bnbnac",
                        "content": "omg would you share your solution?"
                    },
                    {
                        "username": "syvicpros18",
                        "content": "Oh?\\ndef Median(l1, l2):\\n    for item in l2:\\n        l1.append(item)\\n\\n    l1.sort()\\n\\n    if len(l1) % 2 == 0:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n    if len(l1) % 2 != 0:\\n        ans = float(l1[len(l1) // 2])\\n        return ans\\n    if len(l1) == 2:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n\\n\\nl1 = [1, 2]\\nl2 = [3, 4]\\nprint(Median(l1, l2))\\n\\nMy output: 2.50000\\nThis output: 2.00000\\n\\nWhat\\'s wrong?"
                    },
                    {
                        "username": "bnbnac",
                        "content": "yours:\\nans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n\\nmaybe:\\nans = (l1[len(l1) // 2] + l1[(len(l1) // 2) + 1]) / 2"
                    },
                    {
                        "username": "ADARSH_CODE_01",
                        "content": "axa\\'\\'c "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "why this task is marked as a \"hard\" one ?"
                    },
                    {
                        "username": "pbrubak",
                        "content": "After all, if in an interview a candidate was asked to implement an O(log(m+n)) solution, and they implemented a simple O(m+n) merge while protesting, \"but it passed the test cases\", it is unlikely the interviewer would find that answer acceptable."
                    },
                    {
                        "username": "pbrubak",
                        "content": "The hard ranking assumes the user will implement an actual O(log(m+n)) solution."
                    },
                    {
                        "username": "tori5",
                        "content": "My code and i have an error :\\nOutput Limit Exceeded\\n2094 / 2094 testcases passed\\nLast Executed Input\\nnums1 =\\n\\n\\nI cant understand why is not working so can someone help me understand \\n\\n\\n`var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++](var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++)\\n    }else{\\n        \\n        if(val1 < val2 && val1){\\n            console.log(\"cas 1\")\\n            let k = i\\n            while( k < nums1.length && nums1[k] < val2 ){\\n                temp.push(nums1[k])\\n                k++\\n            console.log(\"temp loop1\", temp)\\n            }\\n            i = k\\n            \\n        }\\n        else{\\n            console.log(\"cas 2\")\\n            let h = j\\n            while( h < nums2.length && nums2[h] < val1 ){\\n                temp.push(nums2[h])\\n                h++\\n                console.log(\"temp loop2\", temp ,\"index h\",h)\\n            }\\n            j = h\\n        }\\n    }\\n    \\n    }\\n    console.log(\"temp\", temp, \"indexs\" , i ,j ,\"len\", len, \"templen\", temp.length )\\n    \\n    const diff = parseInt(temp[temp.length / 2 - 1])\\n    if(temp.length % 2 == 0){\\n        return (parseInt(temp[temp.length / 2  -1 ] )+ parseInt(temp[temp.length / 2  ] )  ) / 2 \\n    }\\n    return temp[temp.length / 2 + 0.5 -1] \\n    \\n};`\\n\\n"
                    },
                    {
                        "username": "pbrubak",
                        "content": "'Output Limit Exceeded' most likely means you are trying to log too much to the console. Try removing (or commenting out) all your console logs and running again."
                    }
                ]
            },
            {
                "id": 1891353,
                "content": [
                    {
                        "username": "s3xyincorporated",
                        "content": "for the [1,2] [3,4]  the expected answer is 2.5, my code produces 2.0. \\nbut if I run the same exact code in my editor I get 2.5 ..... so, what is going on?\\n\\nwith [1,3] [2] : it works fine\\n\\nbut\\n\\nwith custom [1,2,3] [4,5,6] : I get the same stuff. output : 3.0, expected : 3.5.\\nWhen I run the code in my editor : 3.5"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This question is broken."
                    },
                    {
                        "username": "_-Rac00n-_",
                        "content": "hello, I have a cod wich work in my IDE corectly, but on leetcode he doesn\\'t wok(((\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        for i in range(len(nums2)):\\n            nums1.append(nums2[i])\\n        nums1.sort()\\n        if(len(nums1)%2 == 0 ):\\n            first = int(len(nums1)/2)\\n            second = first-1\\n            res = (nums1[first]+nums1[second]) / 2\\n            return res\\n        else:\\n            b = int(len(nums1)/2)\\n            return nums1[b]\\nwhat I do uncorectly?("
                    },
                    {
                        "username": "krishrajpal03",
                        "content": "why is this question in the hard category?\\n"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "input=[1,3] [2,7]\\noutput=3.25\\nexpected=2.5\\n but  how?\\nplease help me\\n"
                    },
                    {
                        "username": "Harital",
                        "content": "Median is the element in the middle of vector. The merged vector would be [1, 2, 3, 7]. the element in the middle is the element between 2 and 3. Hence, 2,5. It\\xB4s easier in vectors with an odd number of elements."
                    },
                    {
                        "username": "sondidu",
                        "content": "I kind of hate it that I tried to build a solution that solves in O(log(m+n)) but is somehow slower to other\\'s solutions where they just join the two lists and find the median."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "the test cases is to small"
                    },
                    {
                        "username": "bnbnac",
                        "content": "omg would you share your solution?"
                    },
                    {
                        "username": "syvicpros18",
                        "content": "Oh?\\ndef Median(l1, l2):\\n    for item in l2:\\n        l1.append(item)\\n\\n    l1.sort()\\n\\n    if len(l1) % 2 == 0:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n    if len(l1) % 2 != 0:\\n        ans = float(l1[len(l1) // 2])\\n        return ans\\n    if len(l1) == 2:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n\\n\\nl1 = [1, 2]\\nl2 = [3, 4]\\nprint(Median(l1, l2))\\n\\nMy output: 2.50000\\nThis output: 2.00000\\n\\nWhat\\'s wrong?"
                    },
                    {
                        "username": "bnbnac",
                        "content": "yours:\\nans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n\\nmaybe:\\nans = (l1[len(l1) // 2] + l1[(len(l1) // 2) + 1]) / 2"
                    },
                    {
                        "username": "ADARSH_CODE_01",
                        "content": "axa\\'\\'c "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "why this task is marked as a \"hard\" one ?"
                    },
                    {
                        "username": "pbrubak",
                        "content": "After all, if in an interview a candidate was asked to implement an O(log(m+n)) solution, and they implemented a simple O(m+n) merge while protesting, \"but it passed the test cases\", it is unlikely the interviewer would find that answer acceptable."
                    },
                    {
                        "username": "pbrubak",
                        "content": "The hard ranking assumes the user will implement an actual O(log(m+n)) solution."
                    },
                    {
                        "username": "tori5",
                        "content": "My code and i have an error :\\nOutput Limit Exceeded\\n2094 / 2094 testcases passed\\nLast Executed Input\\nnums1 =\\n\\n\\nI cant understand why is not working so can someone help me understand \\n\\n\\n`var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++](var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++)\\n    }else{\\n        \\n        if(val1 < val2 && val1){\\n            console.log(\"cas 1\")\\n            let k = i\\n            while( k < nums1.length && nums1[k] < val2 ){\\n                temp.push(nums1[k])\\n                k++\\n            console.log(\"temp loop1\", temp)\\n            }\\n            i = k\\n            \\n        }\\n        else{\\n            console.log(\"cas 2\")\\n            let h = j\\n            while( h < nums2.length && nums2[h] < val1 ){\\n                temp.push(nums2[h])\\n                h++\\n                console.log(\"temp loop2\", temp ,\"index h\",h)\\n            }\\n            j = h\\n        }\\n    }\\n    \\n    }\\n    console.log(\"temp\", temp, \"indexs\" , i ,j ,\"len\", len, \"templen\", temp.length )\\n    \\n    const diff = parseInt(temp[temp.length / 2 - 1])\\n    if(temp.length % 2 == 0){\\n        return (parseInt(temp[temp.length / 2  -1 ] )+ parseInt(temp[temp.length / 2  ] )  ) / 2 \\n    }\\n    return temp[temp.length / 2 + 0.5 -1] \\n    \\n};`\\n\\n"
                    },
                    {
                        "username": "pbrubak",
                        "content": "'Output Limit Exceeded' most likely means you are trying to log too much to the console. Try removing (or commenting out) all your console logs and running again."
                    }
                ]
            },
            {
                "id": 1890378,
                "content": [
                    {
                        "username": "s3xyincorporated",
                        "content": "for the [1,2] [3,4]  the expected answer is 2.5, my code produces 2.0. \\nbut if I run the same exact code in my editor I get 2.5 ..... so, what is going on?\\n\\nwith [1,3] [2] : it works fine\\n\\nbut\\n\\nwith custom [1,2,3] [4,5,6] : I get the same stuff. output : 3.0, expected : 3.5.\\nWhen I run the code in my editor : 3.5"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This question is broken."
                    },
                    {
                        "username": "_-Rac00n-_",
                        "content": "hello, I have a cod wich work in my IDE corectly, but on leetcode he doesn\\'t wok(((\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        for i in range(len(nums2)):\\n            nums1.append(nums2[i])\\n        nums1.sort()\\n        if(len(nums1)%2 == 0 ):\\n            first = int(len(nums1)/2)\\n            second = first-1\\n            res = (nums1[first]+nums1[second]) / 2\\n            return res\\n        else:\\n            b = int(len(nums1)/2)\\n            return nums1[b]\\nwhat I do uncorectly?("
                    },
                    {
                        "username": "krishrajpal03",
                        "content": "why is this question in the hard category?\\n"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "input=[1,3] [2,7]\\noutput=3.25\\nexpected=2.5\\n but  how?\\nplease help me\\n"
                    },
                    {
                        "username": "Harital",
                        "content": "Median is the element in the middle of vector. The merged vector would be [1, 2, 3, 7]. the element in the middle is the element between 2 and 3. Hence, 2,5. It\\xB4s easier in vectors with an odd number of elements."
                    },
                    {
                        "username": "sondidu",
                        "content": "I kind of hate it that I tried to build a solution that solves in O(log(m+n)) but is somehow slower to other\\'s solutions where they just join the two lists and find the median."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "the test cases is to small"
                    },
                    {
                        "username": "bnbnac",
                        "content": "omg would you share your solution?"
                    },
                    {
                        "username": "syvicpros18",
                        "content": "Oh?\\ndef Median(l1, l2):\\n    for item in l2:\\n        l1.append(item)\\n\\n    l1.sort()\\n\\n    if len(l1) % 2 == 0:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n    if len(l1) % 2 != 0:\\n        ans = float(l1[len(l1) // 2])\\n        return ans\\n    if len(l1) == 2:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n\\n\\nl1 = [1, 2]\\nl2 = [3, 4]\\nprint(Median(l1, l2))\\n\\nMy output: 2.50000\\nThis output: 2.00000\\n\\nWhat\\'s wrong?"
                    },
                    {
                        "username": "bnbnac",
                        "content": "yours:\\nans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n\\nmaybe:\\nans = (l1[len(l1) // 2] + l1[(len(l1) // 2) + 1]) / 2"
                    },
                    {
                        "username": "ADARSH_CODE_01",
                        "content": "axa\\'\\'c "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "why this task is marked as a \"hard\" one ?"
                    },
                    {
                        "username": "pbrubak",
                        "content": "After all, if in an interview a candidate was asked to implement an O(log(m+n)) solution, and they implemented a simple O(m+n) merge while protesting, \"but it passed the test cases\", it is unlikely the interviewer would find that answer acceptable."
                    },
                    {
                        "username": "pbrubak",
                        "content": "The hard ranking assumes the user will implement an actual O(log(m+n)) solution."
                    },
                    {
                        "username": "tori5",
                        "content": "My code and i have an error :\\nOutput Limit Exceeded\\n2094 / 2094 testcases passed\\nLast Executed Input\\nnums1 =\\n\\n\\nI cant understand why is not working so can someone help me understand \\n\\n\\n`var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++](var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++)\\n    }else{\\n        \\n        if(val1 < val2 && val1){\\n            console.log(\"cas 1\")\\n            let k = i\\n            while( k < nums1.length && nums1[k] < val2 ){\\n                temp.push(nums1[k])\\n                k++\\n            console.log(\"temp loop1\", temp)\\n            }\\n            i = k\\n            \\n        }\\n        else{\\n            console.log(\"cas 2\")\\n            let h = j\\n            while( h < nums2.length && nums2[h] < val1 ){\\n                temp.push(nums2[h])\\n                h++\\n                console.log(\"temp loop2\", temp ,\"index h\",h)\\n            }\\n            j = h\\n        }\\n    }\\n    \\n    }\\n    console.log(\"temp\", temp, \"indexs\" , i ,j ,\"len\", len, \"templen\", temp.length )\\n    \\n    const diff = parseInt(temp[temp.length / 2 - 1])\\n    if(temp.length % 2 == 0){\\n        return (parseInt(temp[temp.length / 2  -1 ] )+ parseInt(temp[temp.length / 2  ] )  ) / 2 \\n    }\\n    return temp[temp.length / 2 + 0.5 -1] \\n    \\n};`\\n\\n"
                    },
                    {
                        "username": "pbrubak",
                        "content": "'Output Limit Exceeded' most likely means you are trying to log too much to the console. Try removing (or commenting out) all your console logs and running again."
                    }
                ]
            },
            {
                "id": 1888382,
                "content": [
                    {
                        "username": "s3xyincorporated",
                        "content": "for the [1,2] [3,4]  the expected answer is 2.5, my code produces 2.0. \\nbut if I run the same exact code in my editor I get 2.5 ..... so, what is going on?\\n\\nwith [1,3] [2] : it works fine\\n\\nbut\\n\\nwith custom [1,2,3] [4,5,6] : I get the same stuff. output : 3.0, expected : 3.5.\\nWhen I run the code in my editor : 3.5"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This question is broken."
                    },
                    {
                        "username": "_-Rac00n-_",
                        "content": "hello, I have a cod wich work in my IDE corectly, but on leetcode he doesn\\'t wok(((\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        for i in range(len(nums2)):\\n            nums1.append(nums2[i])\\n        nums1.sort()\\n        if(len(nums1)%2 == 0 ):\\n            first = int(len(nums1)/2)\\n            second = first-1\\n            res = (nums1[first]+nums1[second]) / 2\\n            return res\\n        else:\\n            b = int(len(nums1)/2)\\n            return nums1[b]\\nwhat I do uncorectly?("
                    },
                    {
                        "username": "krishrajpal03",
                        "content": "why is this question in the hard category?\\n"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "input=[1,3] [2,7]\\noutput=3.25\\nexpected=2.5\\n but  how?\\nplease help me\\n"
                    },
                    {
                        "username": "Harital",
                        "content": "Median is the element in the middle of vector. The merged vector would be [1, 2, 3, 7]. the element in the middle is the element between 2 and 3. Hence, 2,5. It\\xB4s easier in vectors with an odd number of elements."
                    },
                    {
                        "username": "sondidu",
                        "content": "I kind of hate it that I tried to build a solution that solves in O(log(m+n)) but is somehow slower to other\\'s solutions where they just join the two lists and find the median."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "the test cases is to small"
                    },
                    {
                        "username": "bnbnac",
                        "content": "omg would you share your solution?"
                    },
                    {
                        "username": "syvicpros18",
                        "content": "Oh?\\ndef Median(l1, l2):\\n    for item in l2:\\n        l1.append(item)\\n\\n    l1.sort()\\n\\n    if len(l1) % 2 == 0:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n    if len(l1) % 2 != 0:\\n        ans = float(l1[len(l1) // 2])\\n        return ans\\n    if len(l1) == 2:\\n        ans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n        return ans\\n\\n\\nl1 = [1, 2]\\nl2 = [3, 4]\\nprint(Median(l1, l2))\\n\\nMy output: 2.50000\\nThis output: 2.00000\\n\\nWhat\\'s wrong?"
                    },
                    {
                        "username": "bnbnac",
                        "content": "yours:\\nans = (l1[len(l1) // 2] + l1[(len(l1) % 2) + 1]) / 2\\n\\nmaybe:\\nans = (l1[len(l1) // 2] + l1[(len(l1) // 2) + 1]) / 2"
                    },
                    {
                        "username": "ADARSH_CODE_01",
                        "content": "axa\\'\\'c "
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "why this task is marked as a \"hard\" one ?"
                    },
                    {
                        "username": "pbrubak",
                        "content": "After all, if in an interview a candidate was asked to implement an O(log(m+n)) solution, and they implemented a simple O(m+n) merge while protesting, \"but it passed the test cases\", it is unlikely the interviewer would find that answer acceptable."
                    },
                    {
                        "username": "pbrubak",
                        "content": "The hard ranking assumes the user will implement an actual O(log(m+n)) solution."
                    },
                    {
                        "username": "tori5",
                        "content": "My code and i have an error :\\nOutput Limit Exceeded\\n2094 / 2094 testcases passed\\nLast Executed Input\\nnums1 =\\n\\n\\nI cant understand why is not working so can someone help me understand \\n\\n\\n`var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++](var findMedianSortedArrays = function(nums1, nums2) {\\n    let temp=[]\\n    let len = nums1.length + nums2.length\\n\\n    if(!nums1 && !nums2 ){\\n        return 0\\n    }\\n\\n    if(!nums1.length ){\\n        temp == nums2\\n    }\\n    \\n\\n    if(!nums2.length ){\\n        temp == nums1\\n    }\\n\\n\\n    let i = 0\\n    let j = 0\\n    while( temp.length < len){\\n        console.log(\"start loop\")\\n        let val1= nums1[i] \\n        let val2= nums2[j] \\n        console.log()\\n        console.log(\"vals gen\", val1,val2 , \"index\",i , j, \"temp\" , temp)\\n        console.log(\"end?\" , i == nums1.length , j == nums2.length)\\n        console.log()\\n        \\n        if (val1 == undefined){\\n            temp=[...temp , ...nums2.slice(j)]\\n            \\n            console.log(\"val1 Nan\", temp)\\n            j = nums2.length\\n        }\\n        else if(val2 == undefined){\\n            temp=[...temp,...nums1.slice(i)]\\n            i = nums1.length\\n            console.log(\"val2 Nan\", temp)\\n    }else if(val1 == val2){\\n        console.log(\"equal val\")\\n        temp.push(val1)\\n        temp.push(val2)\\n        i++\\n        j++)\\n    }else{\\n        \\n        if(val1 < val2 && val1){\\n            console.log(\"cas 1\")\\n            let k = i\\n            while( k < nums1.length && nums1[k] < val2 ){\\n                temp.push(nums1[k])\\n                k++\\n            console.log(\"temp loop1\", temp)\\n            }\\n            i = k\\n            \\n        }\\n        else{\\n            console.log(\"cas 2\")\\n            let h = j\\n            while( h < nums2.length && nums2[h] < val1 ){\\n                temp.push(nums2[h])\\n                h++\\n                console.log(\"temp loop2\", temp ,\"index h\",h)\\n            }\\n            j = h\\n        }\\n    }\\n    \\n    }\\n    console.log(\"temp\", temp, \"indexs\" , i ,j ,\"len\", len, \"templen\", temp.length )\\n    \\n    const diff = parseInt(temp[temp.length / 2 - 1])\\n    if(temp.length % 2 == 0){\\n        return (parseInt(temp[temp.length / 2  -1 ] )+ parseInt(temp[temp.length / 2  ] )  ) / 2 \\n    }\\n    return temp[temp.length / 2 + 0.5 -1] \\n    \\n};`\\n\\n"
                    },
                    {
                        "username": "pbrubak",
                        "content": "'Output Limit Exceeded' most likely means you are trying to log too much to the console. Try removing (or commenting out) all your console logs and running again."
                    }
                ]
            },
            {
                "id": 1884999,
                "content": [
                    {
                        "username": "a_shish07",
                        "content": "we can use merge  function to directly merge the two array and then use the sort function to sort the array\\n "
                    },
                    {
                        "username": "PrashDev001",
                        "content": "To begin with, the method initializes a double variable \"a\" to zero and creates a new integer array \"ans\" of length (len1 + len2), where \"len1\" and \"len2\" are the lengths of \"nums1\" and \"nums2\", respectively. It also initializes three integer variables \"i\", \"j\", and \"k\" to zero.\\n\\nThe method then enters a while loop that compares the elements of \"nums1\" and \"nums2\" and adds the smaller value to the \"ans\" array until either \"nums1\" or \"nums2\" is exhausted. Once the first loop is finished, the method enters two more while loops that add any remaining elements of \"nums1\" or \"nums2\" to the \"ans\" array.\\n\\nNext, the method assigns the length of the \"ans\" array to the variable \"len2\". If the total number of elements in the \"ans\" array is odd, the method returns the value at index (len2 / 2) of the \"ans\" array as the median. If the total number of elements in the \"ans\" array is even, the method returns the average of the values at indices (len2 / 2 - 1) and (len2 / 2) of the \"ans\" array as the median."
                    },
                    {
                        "username": "xshiart",
                        "content": "Why the the answer for array [1,1,1,1,1,1,1,1,1,1,3,4,4,4,4,4,4,4,4,4] is 3 but not 2 ?\\n(1+3)/2 = 2 isn\\'t it?"
                    },
                    {
                        "username": "atmaram_kambli",
                        "content": "My First Hard Level Problem.\\nI have solved it with O(n + m) TC."
                    },
                    {
                        "username": "atultripathi589",
                        "content": "Even O(m+n) solutions are getting accepted. Setter, what is going on?"
                    },
                    {
                        "username": "MaksPy",
                        "content": "sorry, i am a beginner\\nbut very interesting why\\ndifferent results in my and leetcode editor \\n\\nreturn (sum(nums2) / len(nums2) + sum(nums1) / len(nums1)) / 2\\n\\nvalues (nums1=[1, 2], nums2=[3, 4])  return \\n         in my PyCharm 2,0 & 2,5\\n         in leetcode 2.00000 & 2.00000\\n\\n"
                    },
                    {
                        "username": "reera",
                        "content": "hey. just try float not int and ull get correct answer"
                    },
                    {
                        "username": "xsitedguylmao",
                        "content": " `class Solution:\n    def findMedianSortedArrays(self, l1: List[int], l2: List[int]) -> float:\n            for i in range(0,len(l2)):\n                l1.append(l2[i])\n            if len(l1) % 2 == 0:\n                return l1[int(len(l1)/2)]+l1[(int(len(l1)/2)+1)]\n            elif len(l1)%2 != 0:\n                return l1[int((1+len(l1))/2)]`\nI think my code is correct but It gives me a wrong answer in test case 2. I can't figure out why, help me please"
                    },
                    {
                        "username": "layman806",
                        "content": "Bad question for 2 reasons:\\n1. Never in an interview is this question gonna be asked - maybe only in the toughest, where low level optimisation is key\\n2. Simple solution of adding  the 2 lists and finding the median works in python - exec time beats 78% submissions @ 66ms"
                    },
                    {
                        "username": "enkvadrat",
                        "content": "My O(n+m) solution in java takes 2 ms and beats 100% of solutions lol."
                    },
                    {
                        "username": "AliDami",
                        "content": "my program works perfectly on pycharm , but it does not work here , my variable returns 3.000 here but it returns 3.500 on pycharm\nwhat should I do?"
                    },
                    {
                        "username": "iahamedsha",
                        "content": "This is a hard problem ? doesn\\'t feel like that to me\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3415798/easy-java-solution-beats-100/"
                    }
                ]
            },
            {
                "id": 1884746,
                "content": [
                    {
                        "username": "a_shish07",
                        "content": "we can use merge  function to directly merge the two array and then use the sort function to sort the array\\n "
                    },
                    {
                        "username": "PrashDev001",
                        "content": "To begin with, the method initializes a double variable \"a\" to zero and creates a new integer array \"ans\" of length (len1 + len2), where \"len1\" and \"len2\" are the lengths of \"nums1\" and \"nums2\", respectively. It also initializes three integer variables \"i\", \"j\", and \"k\" to zero.\\n\\nThe method then enters a while loop that compares the elements of \"nums1\" and \"nums2\" and adds the smaller value to the \"ans\" array until either \"nums1\" or \"nums2\" is exhausted. Once the first loop is finished, the method enters two more while loops that add any remaining elements of \"nums1\" or \"nums2\" to the \"ans\" array.\\n\\nNext, the method assigns the length of the \"ans\" array to the variable \"len2\". If the total number of elements in the \"ans\" array is odd, the method returns the value at index (len2 / 2) of the \"ans\" array as the median. If the total number of elements in the \"ans\" array is even, the method returns the average of the values at indices (len2 / 2 - 1) and (len2 / 2) of the \"ans\" array as the median."
                    },
                    {
                        "username": "xshiart",
                        "content": "Why the the answer for array [1,1,1,1,1,1,1,1,1,1,3,4,4,4,4,4,4,4,4,4] is 3 but not 2 ?\\n(1+3)/2 = 2 isn\\'t it?"
                    },
                    {
                        "username": "atmaram_kambli",
                        "content": "My First Hard Level Problem.\\nI have solved it with O(n + m) TC."
                    },
                    {
                        "username": "atultripathi589",
                        "content": "Even O(m+n) solutions are getting accepted. Setter, what is going on?"
                    },
                    {
                        "username": "MaksPy",
                        "content": "sorry, i am a beginner\\nbut very interesting why\\ndifferent results in my and leetcode editor \\n\\nreturn (sum(nums2) / len(nums2) + sum(nums1) / len(nums1)) / 2\\n\\nvalues (nums1=[1, 2], nums2=[3, 4])  return \\n         in my PyCharm 2,0 & 2,5\\n         in leetcode 2.00000 & 2.00000\\n\\n"
                    },
                    {
                        "username": "reera",
                        "content": "hey. just try float not int and ull get correct answer"
                    },
                    {
                        "username": "xsitedguylmao",
                        "content": " `class Solution:\n    def findMedianSortedArrays(self, l1: List[int], l2: List[int]) -> float:\n            for i in range(0,len(l2)):\n                l1.append(l2[i])\n            if len(l1) % 2 == 0:\n                return l1[int(len(l1)/2)]+l1[(int(len(l1)/2)+1)]\n            elif len(l1)%2 != 0:\n                return l1[int((1+len(l1))/2)]`\nI think my code is correct but It gives me a wrong answer in test case 2. I can't figure out why, help me please"
                    },
                    {
                        "username": "layman806",
                        "content": "Bad question for 2 reasons:\\n1. Never in an interview is this question gonna be asked - maybe only in the toughest, where low level optimisation is key\\n2. Simple solution of adding  the 2 lists and finding the median works in python - exec time beats 78% submissions @ 66ms"
                    },
                    {
                        "username": "enkvadrat",
                        "content": "My O(n+m) solution in java takes 2 ms and beats 100% of solutions lol."
                    },
                    {
                        "username": "AliDami",
                        "content": "my program works perfectly on pycharm , but it does not work here , my variable returns 3.000 here but it returns 3.500 on pycharm\nwhat should I do?"
                    },
                    {
                        "username": "iahamedsha",
                        "content": "This is a hard problem ? doesn\\'t feel like that to me\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3415798/easy-java-solution-beats-100/"
                    }
                ]
            },
            {
                "id": 1880336,
                "content": [
                    {
                        "username": "a_shish07",
                        "content": "we can use merge  function to directly merge the two array and then use the sort function to sort the array\\n "
                    },
                    {
                        "username": "PrashDev001",
                        "content": "To begin with, the method initializes a double variable \"a\" to zero and creates a new integer array \"ans\" of length (len1 + len2), where \"len1\" and \"len2\" are the lengths of \"nums1\" and \"nums2\", respectively. It also initializes three integer variables \"i\", \"j\", and \"k\" to zero.\\n\\nThe method then enters a while loop that compares the elements of \"nums1\" and \"nums2\" and adds the smaller value to the \"ans\" array until either \"nums1\" or \"nums2\" is exhausted. Once the first loop is finished, the method enters two more while loops that add any remaining elements of \"nums1\" or \"nums2\" to the \"ans\" array.\\n\\nNext, the method assigns the length of the \"ans\" array to the variable \"len2\". If the total number of elements in the \"ans\" array is odd, the method returns the value at index (len2 / 2) of the \"ans\" array as the median. If the total number of elements in the \"ans\" array is even, the method returns the average of the values at indices (len2 / 2 - 1) and (len2 / 2) of the \"ans\" array as the median."
                    },
                    {
                        "username": "xshiart",
                        "content": "Why the the answer for array [1,1,1,1,1,1,1,1,1,1,3,4,4,4,4,4,4,4,4,4] is 3 but not 2 ?\\n(1+3)/2 = 2 isn\\'t it?"
                    },
                    {
                        "username": "atmaram_kambli",
                        "content": "My First Hard Level Problem.\\nI have solved it with O(n + m) TC."
                    },
                    {
                        "username": "atultripathi589",
                        "content": "Even O(m+n) solutions are getting accepted. Setter, what is going on?"
                    },
                    {
                        "username": "MaksPy",
                        "content": "sorry, i am a beginner\\nbut very interesting why\\ndifferent results in my and leetcode editor \\n\\nreturn (sum(nums2) / len(nums2) + sum(nums1) / len(nums1)) / 2\\n\\nvalues (nums1=[1, 2], nums2=[3, 4])  return \\n         in my PyCharm 2,0 & 2,5\\n         in leetcode 2.00000 & 2.00000\\n\\n"
                    },
                    {
                        "username": "reera",
                        "content": "hey. just try float not int and ull get correct answer"
                    },
                    {
                        "username": "xsitedguylmao",
                        "content": " `class Solution:\n    def findMedianSortedArrays(self, l1: List[int], l2: List[int]) -> float:\n            for i in range(0,len(l2)):\n                l1.append(l2[i])\n            if len(l1) % 2 == 0:\n                return l1[int(len(l1)/2)]+l1[(int(len(l1)/2)+1)]\n            elif len(l1)%2 != 0:\n                return l1[int((1+len(l1))/2)]`\nI think my code is correct but It gives me a wrong answer in test case 2. I can't figure out why, help me please"
                    },
                    {
                        "username": "layman806",
                        "content": "Bad question for 2 reasons:\\n1. Never in an interview is this question gonna be asked - maybe only in the toughest, where low level optimisation is key\\n2. Simple solution of adding  the 2 lists and finding the median works in python - exec time beats 78% submissions @ 66ms"
                    },
                    {
                        "username": "enkvadrat",
                        "content": "My O(n+m) solution in java takes 2 ms and beats 100% of solutions lol."
                    },
                    {
                        "username": "AliDami",
                        "content": "my program works perfectly on pycharm , but it does not work here , my variable returns 3.000 here but it returns 3.500 on pycharm\nwhat should I do?"
                    },
                    {
                        "username": "iahamedsha",
                        "content": "This is a hard problem ? doesn\\'t feel like that to me\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3415798/easy-java-solution-beats-100/"
                    }
                ]
            },
            {
                "id": 1879604,
                "content": [
                    {
                        "username": "a_shish07",
                        "content": "we can use merge  function to directly merge the two array and then use the sort function to sort the array\\n "
                    },
                    {
                        "username": "PrashDev001",
                        "content": "To begin with, the method initializes a double variable \"a\" to zero and creates a new integer array \"ans\" of length (len1 + len2), where \"len1\" and \"len2\" are the lengths of \"nums1\" and \"nums2\", respectively. It also initializes three integer variables \"i\", \"j\", and \"k\" to zero.\\n\\nThe method then enters a while loop that compares the elements of \"nums1\" and \"nums2\" and adds the smaller value to the \"ans\" array until either \"nums1\" or \"nums2\" is exhausted. Once the first loop is finished, the method enters two more while loops that add any remaining elements of \"nums1\" or \"nums2\" to the \"ans\" array.\\n\\nNext, the method assigns the length of the \"ans\" array to the variable \"len2\". If the total number of elements in the \"ans\" array is odd, the method returns the value at index (len2 / 2) of the \"ans\" array as the median. If the total number of elements in the \"ans\" array is even, the method returns the average of the values at indices (len2 / 2 - 1) and (len2 / 2) of the \"ans\" array as the median."
                    },
                    {
                        "username": "xshiart",
                        "content": "Why the the answer for array [1,1,1,1,1,1,1,1,1,1,3,4,4,4,4,4,4,4,4,4] is 3 but not 2 ?\\n(1+3)/2 = 2 isn\\'t it?"
                    },
                    {
                        "username": "atmaram_kambli",
                        "content": "My First Hard Level Problem.\\nI have solved it with O(n + m) TC."
                    },
                    {
                        "username": "atultripathi589",
                        "content": "Even O(m+n) solutions are getting accepted. Setter, what is going on?"
                    },
                    {
                        "username": "MaksPy",
                        "content": "sorry, i am a beginner\\nbut very interesting why\\ndifferent results in my and leetcode editor \\n\\nreturn (sum(nums2) / len(nums2) + sum(nums1) / len(nums1)) / 2\\n\\nvalues (nums1=[1, 2], nums2=[3, 4])  return \\n         in my PyCharm 2,0 & 2,5\\n         in leetcode 2.00000 & 2.00000\\n\\n"
                    },
                    {
                        "username": "reera",
                        "content": "hey. just try float not int and ull get correct answer"
                    },
                    {
                        "username": "xsitedguylmao",
                        "content": " `class Solution:\n    def findMedianSortedArrays(self, l1: List[int], l2: List[int]) -> float:\n            for i in range(0,len(l2)):\n                l1.append(l2[i])\n            if len(l1) % 2 == 0:\n                return l1[int(len(l1)/2)]+l1[(int(len(l1)/2)+1)]\n            elif len(l1)%2 != 0:\n                return l1[int((1+len(l1))/2)]`\nI think my code is correct but It gives me a wrong answer in test case 2. I can't figure out why, help me please"
                    },
                    {
                        "username": "layman806",
                        "content": "Bad question for 2 reasons:\\n1. Never in an interview is this question gonna be asked - maybe only in the toughest, where low level optimisation is key\\n2. Simple solution of adding  the 2 lists and finding the median works in python - exec time beats 78% submissions @ 66ms"
                    },
                    {
                        "username": "enkvadrat",
                        "content": "My O(n+m) solution in java takes 2 ms and beats 100% of solutions lol."
                    },
                    {
                        "username": "AliDami",
                        "content": "my program works perfectly on pycharm , but it does not work here , my variable returns 3.000 here but it returns 3.500 on pycharm\nwhat should I do?"
                    },
                    {
                        "username": "iahamedsha",
                        "content": "This is a hard problem ? doesn\\'t feel like that to me\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3415798/easy-java-solution-beats-100/"
                    }
                ]
            },
            {
                "id": 1874460,
                "content": [
                    {
                        "username": "a_shish07",
                        "content": "we can use merge  function to directly merge the two array and then use the sort function to sort the array\\n "
                    },
                    {
                        "username": "PrashDev001",
                        "content": "To begin with, the method initializes a double variable \"a\" to zero and creates a new integer array \"ans\" of length (len1 + len2), where \"len1\" and \"len2\" are the lengths of \"nums1\" and \"nums2\", respectively. It also initializes three integer variables \"i\", \"j\", and \"k\" to zero.\\n\\nThe method then enters a while loop that compares the elements of \"nums1\" and \"nums2\" and adds the smaller value to the \"ans\" array until either \"nums1\" or \"nums2\" is exhausted. Once the first loop is finished, the method enters two more while loops that add any remaining elements of \"nums1\" or \"nums2\" to the \"ans\" array.\\n\\nNext, the method assigns the length of the \"ans\" array to the variable \"len2\". If the total number of elements in the \"ans\" array is odd, the method returns the value at index (len2 / 2) of the \"ans\" array as the median. If the total number of elements in the \"ans\" array is even, the method returns the average of the values at indices (len2 / 2 - 1) and (len2 / 2) of the \"ans\" array as the median."
                    },
                    {
                        "username": "xshiart",
                        "content": "Why the the answer for array [1,1,1,1,1,1,1,1,1,1,3,4,4,4,4,4,4,4,4,4] is 3 but not 2 ?\\n(1+3)/2 = 2 isn\\'t it?"
                    },
                    {
                        "username": "atmaram_kambli",
                        "content": "My First Hard Level Problem.\\nI have solved it with O(n + m) TC."
                    },
                    {
                        "username": "atultripathi589",
                        "content": "Even O(m+n) solutions are getting accepted. Setter, what is going on?"
                    },
                    {
                        "username": "MaksPy",
                        "content": "sorry, i am a beginner\\nbut very interesting why\\ndifferent results in my and leetcode editor \\n\\nreturn (sum(nums2) / len(nums2) + sum(nums1) / len(nums1)) / 2\\n\\nvalues (nums1=[1, 2], nums2=[3, 4])  return \\n         in my PyCharm 2,0 & 2,5\\n         in leetcode 2.00000 & 2.00000\\n\\n"
                    },
                    {
                        "username": "reera",
                        "content": "hey. just try float not int and ull get correct answer"
                    },
                    {
                        "username": "xsitedguylmao",
                        "content": " `class Solution:\n    def findMedianSortedArrays(self, l1: List[int], l2: List[int]) -> float:\n            for i in range(0,len(l2)):\n                l1.append(l2[i])\n            if len(l1) % 2 == 0:\n                return l1[int(len(l1)/2)]+l1[(int(len(l1)/2)+1)]\n            elif len(l1)%2 != 0:\n                return l1[int((1+len(l1))/2)]`\nI think my code is correct but It gives me a wrong answer in test case 2. I can't figure out why, help me please"
                    },
                    {
                        "username": "layman806",
                        "content": "Bad question for 2 reasons:\\n1. Never in an interview is this question gonna be asked - maybe only in the toughest, where low level optimisation is key\\n2. Simple solution of adding  the 2 lists and finding the median works in python - exec time beats 78% submissions @ 66ms"
                    },
                    {
                        "username": "enkvadrat",
                        "content": "My O(n+m) solution in java takes 2 ms and beats 100% of solutions lol."
                    },
                    {
                        "username": "AliDami",
                        "content": "my program works perfectly on pycharm , but it does not work here , my variable returns 3.000 here but it returns 3.500 on pycharm\nwhat should I do?"
                    },
                    {
                        "username": "iahamedsha",
                        "content": "This is a hard problem ? doesn\\'t feel like that to me\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3415798/easy-java-solution-beats-100/"
                    }
                ]
            },
            {
                "id": 1869271,
                "content": [
                    {
                        "username": "a_shish07",
                        "content": "we can use merge  function to directly merge the two array and then use the sort function to sort the array\\n "
                    },
                    {
                        "username": "PrashDev001",
                        "content": "To begin with, the method initializes a double variable \"a\" to zero and creates a new integer array \"ans\" of length (len1 + len2), where \"len1\" and \"len2\" are the lengths of \"nums1\" and \"nums2\", respectively. It also initializes three integer variables \"i\", \"j\", and \"k\" to zero.\\n\\nThe method then enters a while loop that compares the elements of \"nums1\" and \"nums2\" and adds the smaller value to the \"ans\" array until either \"nums1\" or \"nums2\" is exhausted. Once the first loop is finished, the method enters two more while loops that add any remaining elements of \"nums1\" or \"nums2\" to the \"ans\" array.\\n\\nNext, the method assigns the length of the \"ans\" array to the variable \"len2\". If the total number of elements in the \"ans\" array is odd, the method returns the value at index (len2 / 2) of the \"ans\" array as the median. If the total number of elements in the \"ans\" array is even, the method returns the average of the values at indices (len2 / 2 - 1) and (len2 / 2) of the \"ans\" array as the median."
                    },
                    {
                        "username": "xshiart",
                        "content": "Why the the answer for array [1,1,1,1,1,1,1,1,1,1,3,4,4,4,4,4,4,4,4,4] is 3 but not 2 ?\\n(1+3)/2 = 2 isn\\'t it?"
                    },
                    {
                        "username": "atmaram_kambli",
                        "content": "My First Hard Level Problem.\\nI have solved it with O(n + m) TC."
                    },
                    {
                        "username": "atultripathi589",
                        "content": "Even O(m+n) solutions are getting accepted. Setter, what is going on?"
                    },
                    {
                        "username": "MaksPy",
                        "content": "sorry, i am a beginner\\nbut very interesting why\\ndifferent results in my and leetcode editor \\n\\nreturn (sum(nums2) / len(nums2) + sum(nums1) / len(nums1)) / 2\\n\\nvalues (nums1=[1, 2], nums2=[3, 4])  return \\n         in my PyCharm 2,0 & 2,5\\n         in leetcode 2.00000 & 2.00000\\n\\n"
                    },
                    {
                        "username": "reera",
                        "content": "hey. just try float not int and ull get correct answer"
                    },
                    {
                        "username": "xsitedguylmao",
                        "content": " `class Solution:\n    def findMedianSortedArrays(self, l1: List[int], l2: List[int]) -> float:\n            for i in range(0,len(l2)):\n                l1.append(l2[i])\n            if len(l1) % 2 == 0:\n                return l1[int(len(l1)/2)]+l1[(int(len(l1)/2)+1)]\n            elif len(l1)%2 != 0:\n                return l1[int((1+len(l1))/2)]`\nI think my code is correct but It gives me a wrong answer in test case 2. I can't figure out why, help me please"
                    },
                    {
                        "username": "layman806",
                        "content": "Bad question for 2 reasons:\\n1. Never in an interview is this question gonna be asked - maybe only in the toughest, where low level optimisation is key\\n2. Simple solution of adding  the 2 lists and finding the median works in python - exec time beats 78% submissions @ 66ms"
                    },
                    {
                        "username": "enkvadrat",
                        "content": "My O(n+m) solution in java takes 2 ms and beats 100% of solutions lol."
                    },
                    {
                        "username": "AliDami",
                        "content": "my program works perfectly on pycharm , but it does not work here , my variable returns 3.000 here but it returns 3.500 on pycharm\nwhat should I do?"
                    },
                    {
                        "username": "iahamedsha",
                        "content": "This is a hard problem ? doesn\\'t feel like that to me\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3415798/easy-java-solution-beats-100/"
                    }
                ]
            },
            {
                "id": 1868590,
                "content": [
                    {
                        "username": "a_shish07",
                        "content": "we can use merge  function to directly merge the two array and then use the sort function to sort the array\\n "
                    },
                    {
                        "username": "PrashDev001",
                        "content": "To begin with, the method initializes a double variable \"a\" to zero and creates a new integer array \"ans\" of length (len1 + len2), where \"len1\" and \"len2\" are the lengths of \"nums1\" and \"nums2\", respectively. It also initializes three integer variables \"i\", \"j\", and \"k\" to zero.\\n\\nThe method then enters a while loop that compares the elements of \"nums1\" and \"nums2\" and adds the smaller value to the \"ans\" array until either \"nums1\" or \"nums2\" is exhausted. Once the first loop is finished, the method enters two more while loops that add any remaining elements of \"nums1\" or \"nums2\" to the \"ans\" array.\\n\\nNext, the method assigns the length of the \"ans\" array to the variable \"len2\". If the total number of elements in the \"ans\" array is odd, the method returns the value at index (len2 / 2) of the \"ans\" array as the median. If the total number of elements in the \"ans\" array is even, the method returns the average of the values at indices (len2 / 2 - 1) and (len2 / 2) of the \"ans\" array as the median."
                    },
                    {
                        "username": "xshiart",
                        "content": "Why the the answer for array [1,1,1,1,1,1,1,1,1,1,3,4,4,4,4,4,4,4,4,4] is 3 but not 2 ?\\n(1+3)/2 = 2 isn\\'t it?"
                    },
                    {
                        "username": "atmaram_kambli",
                        "content": "My First Hard Level Problem.\\nI have solved it with O(n + m) TC."
                    },
                    {
                        "username": "atultripathi589",
                        "content": "Even O(m+n) solutions are getting accepted. Setter, what is going on?"
                    },
                    {
                        "username": "MaksPy",
                        "content": "sorry, i am a beginner\\nbut very interesting why\\ndifferent results in my and leetcode editor \\n\\nreturn (sum(nums2) / len(nums2) + sum(nums1) / len(nums1)) / 2\\n\\nvalues (nums1=[1, 2], nums2=[3, 4])  return \\n         in my PyCharm 2,0 & 2,5\\n         in leetcode 2.00000 & 2.00000\\n\\n"
                    },
                    {
                        "username": "reera",
                        "content": "hey. just try float not int and ull get correct answer"
                    },
                    {
                        "username": "xsitedguylmao",
                        "content": " `class Solution:\n    def findMedianSortedArrays(self, l1: List[int], l2: List[int]) -> float:\n            for i in range(0,len(l2)):\n                l1.append(l2[i])\n            if len(l1) % 2 == 0:\n                return l1[int(len(l1)/2)]+l1[(int(len(l1)/2)+1)]\n            elif len(l1)%2 != 0:\n                return l1[int((1+len(l1))/2)]`\nI think my code is correct but It gives me a wrong answer in test case 2. I can't figure out why, help me please"
                    },
                    {
                        "username": "layman806",
                        "content": "Bad question for 2 reasons:\\n1. Never in an interview is this question gonna be asked - maybe only in the toughest, where low level optimisation is key\\n2. Simple solution of adding  the 2 lists and finding the median works in python - exec time beats 78% submissions @ 66ms"
                    },
                    {
                        "username": "enkvadrat",
                        "content": "My O(n+m) solution in java takes 2 ms and beats 100% of solutions lol."
                    },
                    {
                        "username": "AliDami",
                        "content": "my program works perfectly on pycharm , but it does not work here , my variable returns 3.000 here but it returns 3.500 on pycharm\nwhat should I do?"
                    },
                    {
                        "username": "iahamedsha",
                        "content": "This is a hard problem ? doesn\\'t feel like that to me\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3415798/easy-java-solution-beats-100/"
                    }
                ]
            },
            {
                "id": 1868348,
                "content": [
                    {
                        "username": "a_shish07",
                        "content": "we can use merge  function to directly merge the two array and then use the sort function to sort the array\\n "
                    },
                    {
                        "username": "PrashDev001",
                        "content": "To begin with, the method initializes a double variable \"a\" to zero and creates a new integer array \"ans\" of length (len1 + len2), where \"len1\" and \"len2\" are the lengths of \"nums1\" and \"nums2\", respectively. It also initializes three integer variables \"i\", \"j\", and \"k\" to zero.\\n\\nThe method then enters a while loop that compares the elements of \"nums1\" and \"nums2\" and adds the smaller value to the \"ans\" array until either \"nums1\" or \"nums2\" is exhausted. Once the first loop is finished, the method enters two more while loops that add any remaining elements of \"nums1\" or \"nums2\" to the \"ans\" array.\\n\\nNext, the method assigns the length of the \"ans\" array to the variable \"len2\". If the total number of elements in the \"ans\" array is odd, the method returns the value at index (len2 / 2) of the \"ans\" array as the median. If the total number of elements in the \"ans\" array is even, the method returns the average of the values at indices (len2 / 2 - 1) and (len2 / 2) of the \"ans\" array as the median."
                    },
                    {
                        "username": "xshiart",
                        "content": "Why the the answer for array [1,1,1,1,1,1,1,1,1,1,3,4,4,4,4,4,4,4,4,4] is 3 but not 2 ?\\n(1+3)/2 = 2 isn\\'t it?"
                    },
                    {
                        "username": "atmaram_kambli",
                        "content": "My First Hard Level Problem.\\nI have solved it with O(n + m) TC."
                    },
                    {
                        "username": "atultripathi589",
                        "content": "Even O(m+n) solutions are getting accepted. Setter, what is going on?"
                    },
                    {
                        "username": "MaksPy",
                        "content": "sorry, i am a beginner\\nbut very interesting why\\ndifferent results in my and leetcode editor \\n\\nreturn (sum(nums2) / len(nums2) + sum(nums1) / len(nums1)) / 2\\n\\nvalues (nums1=[1, 2], nums2=[3, 4])  return \\n         in my PyCharm 2,0 & 2,5\\n         in leetcode 2.00000 & 2.00000\\n\\n"
                    },
                    {
                        "username": "reera",
                        "content": "hey. just try float not int and ull get correct answer"
                    },
                    {
                        "username": "xsitedguylmao",
                        "content": " `class Solution:\n    def findMedianSortedArrays(self, l1: List[int], l2: List[int]) -> float:\n            for i in range(0,len(l2)):\n                l1.append(l2[i])\n            if len(l1) % 2 == 0:\n                return l1[int(len(l1)/2)]+l1[(int(len(l1)/2)+1)]\n            elif len(l1)%2 != 0:\n                return l1[int((1+len(l1))/2)]`\nI think my code is correct but It gives me a wrong answer in test case 2. I can't figure out why, help me please"
                    },
                    {
                        "username": "layman806",
                        "content": "Bad question for 2 reasons:\\n1. Never in an interview is this question gonna be asked - maybe only in the toughest, where low level optimisation is key\\n2. Simple solution of adding  the 2 lists and finding the median works in python - exec time beats 78% submissions @ 66ms"
                    },
                    {
                        "username": "enkvadrat",
                        "content": "My O(n+m) solution in java takes 2 ms and beats 100% of solutions lol."
                    },
                    {
                        "username": "AliDami",
                        "content": "my program works perfectly on pycharm , but it does not work here , my variable returns 3.000 here but it returns 3.500 on pycharm\nwhat should I do?"
                    },
                    {
                        "username": "iahamedsha",
                        "content": "This is a hard problem ? doesn\\'t feel like that to me\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3415798/easy-java-solution-beats-100/"
                    }
                ]
            },
            {
                "id": 1863021,
                "content": [
                    {
                        "username": "a_shish07",
                        "content": "we can use merge  function to directly merge the two array and then use the sort function to sort the array\\n "
                    },
                    {
                        "username": "PrashDev001",
                        "content": "To begin with, the method initializes a double variable \"a\" to zero and creates a new integer array \"ans\" of length (len1 + len2), where \"len1\" and \"len2\" are the lengths of \"nums1\" and \"nums2\", respectively. It also initializes three integer variables \"i\", \"j\", and \"k\" to zero.\\n\\nThe method then enters a while loop that compares the elements of \"nums1\" and \"nums2\" and adds the smaller value to the \"ans\" array until either \"nums1\" or \"nums2\" is exhausted. Once the first loop is finished, the method enters two more while loops that add any remaining elements of \"nums1\" or \"nums2\" to the \"ans\" array.\\n\\nNext, the method assigns the length of the \"ans\" array to the variable \"len2\". If the total number of elements in the \"ans\" array is odd, the method returns the value at index (len2 / 2) of the \"ans\" array as the median. If the total number of elements in the \"ans\" array is even, the method returns the average of the values at indices (len2 / 2 - 1) and (len2 / 2) of the \"ans\" array as the median."
                    },
                    {
                        "username": "xshiart",
                        "content": "Why the the answer for array [1,1,1,1,1,1,1,1,1,1,3,4,4,4,4,4,4,4,4,4] is 3 but not 2 ?\\n(1+3)/2 = 2 isn\\'t it?"
                    },
                    {
                        "username": "atmaram_kambli",
                        "content": "My First Hard Level Problem.\\nI have solved it with O(n + m) TC."
                    },
                    {
                        "username": "atultripathi589",
                        "content": "Even O(m+n) solutions are getting accepted. Setter, what is going on?"
                    },
                    {
                        "username": "MaksPy",
                        "content": "sorry, i am a beginner\\nbut very interesting why\\ndifferent results in my and leetcode editor \\n\\nreturn (sum(nums2) / len(nums2) + sum(nums1) / len(nums1)) / 2\\n\\nvalues (nums1=[1, 2], nums2=[3, 4])  return \\n         in my PyCharm 2,0 & 2,5\\n         in leetcode 2.00000 & 2.00000\\n\\n"
                    },
                    {
                        "username": "reera",
                        "content": "hey. just try float not int and ull get correct answer"
                    },
                    {
                        "username": "xsitedguylmao",
                        "content": " `class Solution:\n    def findMedianSortedArrays(self, l1: List[int], l2: List[int]) -> float:\n            for i in range(0,len(l2)):\n                l1.append(l2[i])\n            if len(l1) % 2 == 0:\n                return l1[int(len(l1)/2)]+l1[(int(len(l1)/2)+1)]\n            elif len(l1)%2 != 0:\n                return l1[int((1+len(l1))/2)]`\nI think my code is correct but It gives me a wrong answer in test case 2. I can't figure out why, help me please"
                    },
                    {
                        "username": "layman806",
                        "content": "Bad question for 2 reasons:\\n1. Never in an interview is this question gonna be asked - maybe only in the toughest, where low level optimisation is key\\n2. Simple solution of adding  the 2 lists and finding the median works in python - exec time beats 78% submissions @ 66ms"
                    },
                    {
                        "username": "enkvadrat",
                        "content": "My O(n+m) solution in java takes 2 ms and beats 100% of solutions lol."
                    },
                    {
                        "username": "AliDami",
                        "content": "my program works perfectly on pycharm , but it does not work here , my variable returns 3.000 here but it returns 3.500 on pycharm\nwhat should I do?"
                    },
                    {
                        "username": "iahamedsha",
                        "content": "This is a hard problem ? doesn\\'t feel like that to me\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3415798/easy-java-solution-beats-100/"
                    }
                ]
            },
            {
                "id": 1863012,
                "content": [
                    {
                        "username": "a_shish07",
                        "content": "we can use merge  function to directly merge the two array and then use the sort function to sort the array\\n "
                    },
                    {
                        "username": "PrashDev001",
                        "content": "To begin with, the method initializes a double variable \"a\" to zero and creates a new integer array \"ans\" of length (len1 + len2), where \"len1\" and \"len2\" are the lengths of \"nums1\" and \"nums2\", respectively. It also initializes three integer variables \"i\", \"j\", and \"k\" to zero.\\n\\nThe method then enters a while loop that compares the elements of \"nums1\" and \"nums2\" and adds the smaller value to the \"ans\" array until either \"nums1\" or \"nums2\" is exhausted. Once the first loop is finished, the method enters two more while loops that add any remaining elements of \"nums1\" or \"nums2\" to the \"ans\" array.\\n\\nNext, the method assigns the length of the \"ans\" array to the variable \"len2\". If the total number of elements in the \"ans\" array is odd, the method returns the value at index (len2 / 2) of the \"ans\" array as the median. If the total number of elements in the \"ans\" array is even, the method returns the average of the values at indices (len2 / 2 - 1) and (len2 / 2) of the \"ans\" array as the median."
                    },
                    {
                        "username": "xshiart",
                        "content": "Why the the answer for array [1,1,1,1,1,1,1,1,1,1,3,4,4,4,4,4,4,4,4,4] is 3 but not 2 ?\\n(1+3)/2 = 2 isn\\'t it?"
                    },
                    {
                        "username": "atmaram_kambli",
                        "content": "My First Hard Level Problem.\\nI have solved it with O(n + m) TC."
                    },
                    {
                        "username": "atultripathi589",
                        "content": "Even O(m+n) solutions are getting accepted. Setter, what is going on?"
                    },
                    {
                        "username": "MaksPy",
                        "content": "sorry, i am a beginner\\nbut very interesting why\\ndifferent results in my and leetcode editor \\n\\nreturn (sum(nums2) / len(nums2) + sum(nums1) / len(nums1)) / 2\\n\\nvalues (nums1=[1, 2], nums2=[3, 4])  return \\n         in my PyCharm 2,0 & 2,5\\n         in leetcode 2.00000 & 2.00000\\n\\n"
                    },
                    {
                        "username": "reera",
                        "content": "hey. just try float not int and ull get correct answer"
                    },
                    {
                        "username": "xsitedguylmao",
                        "content": " `class Solution:\n    def findMedianSortedArrays(self, l1: List[int], l2: List[int]) -> float:\n            for i in range(0,len(l2)):\n                l1.append(l2[i])\n            if len(l1) % 2 == 0:\n                return l1[int(len(l1)/2)]+l1[(int(len(l1)/2)+1)]\n            elif len(l1)%2 != 0:\n                return l1[int((1+len(l1))/2)]`\nI think my code is correct but It gives me a wrong answer in test case 2. I can't figure out why, help me please"
                    },
                    {
                        "username": "layman806",
                        "content": "Bad question for 2 reasons:\\n1. Never in an interview is this question gonna be asked - maybe only in the toughest, where low level optimisation is key\\n2. Simple solution of adding  the 2 lists and finding the median works in python - exec time beats 78% submissions @ 66ms"
                    },
                    {
                        "username": "enkvadrat",
                        "content": "My O(n+m) solution in java takes 2 ms and beats 100% of solutions lol."
                    },
                    {
                        "username": "AliDami",
                        "content": "my program works perfectly on pycharm , but it does not work here , my variable returns 3.000 here but it returns 3.500 on pycharm\nwhat should I do?"
                    },
                    {
                        "username": "iahamedsha",
                        "content": "This is a hard problem ? doesn\\'t feel like that to me\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3415798/easy-java-solution-beats-100/"
                    }
                ]
            },
            {
                "id": 1861942,
                "content": [
                    {
                        "username": "Coder_Mishra",
                        "content": "In second test case you add nums1 and nums2 in a right way but like first nums1 and second nums2 but in first test case you add nums 2 in the middle of nums 1 then how could we develop this globally like apart from these testcases and below I give my solution in Dart language.\\n\\nclass Solution {\\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\\n     double result;\\n  List<String> res=[];\\n  \\n  nums1.addAll(nums2);\\n  Set<int> set= Set();\\n  for(int i=0;i<nums1.length;i++){\\n     set.add(nums1[i]);\\n  }\\n  \\n  String s= set.join(\"\");\\n  print(s);\\n  res= s.split(\"\");\\n  if(res.length%2==0){\\n       result=  (int.parse(res[(res.length/2).toInt()-1])+int.parse(res[((res.length/2)+1).toInt()-1]))/2;\\n  }\\n  else{\\n    result=double.parse(res[(res.length/2).toInt()]);\\n  }\\n  print(result);\\n   return result;\\n  }\\n \\n}"
                    },
                    {
                        "username": "rafikrushanian",
                        "content": "[1,3][2,7] Output: 3.25000 Expected 2.50000 -- How? can somebody help me to understand why?"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "For some reason, I don't understand how some submissions are merging the arrays and getting away with it. The question clearly says that the solution should be O(log(m+n)) and merging the array will already take O(m+n). The test cases clearly do no justice to solution with complexity O(log(m+n))."
                    },
                    {
                        "username": "Pablitoz",
                        "content": "doesn\\'t seem like it should be a hard, i think this deserves a medium"
                    },
                    {
                        "username": "denisartemev228",
                        "content": "Good Morning, i have a problem with this questoins. in PyCharm i get 2.5 in test  nums1 = [1,2] nums2 = [3,4], BUT in leetcode i get 2.0. How?"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "smells like binary search"
                    },
                    {
                        "username": "beypazari",
                        "content": "My code returns the true answer on vs code but when i run the same code here its returning the wrong value. How??"
                    },
                    {
                        "username": "dmk978",
                        "content": "I believe a real problem definition have to be \"write a suite that checks the real complexity of supposed solution\". :)"
                    },
                    {
                        "username": "luckyempire",
                        "content": "l1=list(input().split())\\nl2=list(input().split())\\nl3=[]\\na=[]\\nl3=l1+l2\\nl3.sort()\\nif len(l3)%2!=0:\\n    print(l3[len(l3)//2])\\nelse:\\n    n=len(l3)\\n    print(((n//2)+((n//2)+1))/2)\\nWhy cant we use this type of approach ...I mean this is far way efficient code \\nAm I correct regarding this ????"
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "return Double(l3 [ (l3. count - 1) / 2 ]) something like this. "
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "You see the result of this is a floating point result print(l3[len(l3)//2]) but shouldn\\u2019t "
                    },
                    {
                        "username": "Kopiium",
                        "content": "okay maybe I\\'ve been asked this before haha"
                    }
                ]
            },
            {
                "id": 1859235,
                "content": [
                    {
                        "username": "Coder_Mishra",
                        "content": "In second test case you add nums1 and nums2 in a right way but like first nums1 and second nums2 but in first test case you add nums 2 in the middle of nums 1 then how could we develop this globally like apart from these testcases and below I give my solution in Dart language.\\n\\nclass Solution {\\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\\n     double result;\\n  List<String> res=[];\\n  \\n  nums1.addAll(nums2);\\n  Set<int> set= Set();\\n  for(int i=0;i<nums1.length;i++){\\n     set.add(nums1[i]);\\n  }\\n  \\n  String s= set.join(\"\");\\n  print(s);\\n  res= s.split(\"\");\\n  if(res.length%2==0){\\n       result=  (int.parse(res[(res.length/2).toInt()-1])+int.parse(res[((res.length/2)+1).toInt()-1]))/2;\\n  }\\n  else{\\n    result=double.parse(res[(res.length/2).toInt()]);\\n  }\\n  print(result);\\n   return result;\\n  }\\n \\n}"
                    },
                    {
                        "username": "rafikrushanian",
                        "content": "[1,3][2,7] Output: 3.25000 Expected 2.50000 -- How? can somebody help me to understand why?"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "For some reason, I don't understand how some submissions are merging the arrays and getting away with it. The question clearly says that the solution should be O(log(m+n)) and merging the array will already take O(m+n). The test cases clearly do no justice to solution with complexity O(log(m+n))."
                    },
                    {
                        "username": "Pablitoz",
                        "content": "doesn\\'t seem like it should be a hard, i think this deserves a medium"
                    },
                    {
                        "username": "denisartemev228",
                        "content": "Good Morning, i have a problem with this questoins. in PyCharm i get 2.5 in test  nums1 = [1,2] nums2 = [3,4], BUT in leetcode i get 2.0. How?"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "smells like binary search"
                    },
                    {
                        "username": "beypazari",
                        "content": "My code returns the true answer on vs code but when i run the same code here its returning the wrong value. How??"
                    },
                    {
                        "username": "dmk978",
                        "content": "I believe a real problem definition have to be \"write a suite that checks the real complexity of supposed solution\". :)"
                    },
                    {
                        "username": "luckyempire",
                        "content": "l1=list(input().split())\\nl2=list(input().split())\\nl3=[]\\na=[]\\nl3=l1+l2\\nl3.sort()\\nif len(l3)%2!=0:\\n    print(l3[len(l3)//2])\\nelse:\\n    n=len(l3)\\n    print(((n//2)+((n//2)+1))/2)\\nWhy cant we use this type of approach ...I mean this is far way efficient code \\nAm I correct regarding this ????"
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "return Double(l3 [ (l3. count - 1) / 2 ]) something like this. "
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "You see the result of this is a floating point result print(l3[len(l3)//2]) but shouldn\\u2019t "
                    },
                    {
                        "username": "Kopiium",
                        "content": "okay maybe I\\'ve been asked this before haha"
                    }
                ]
            },
            {
                "id": 1858144,
                "content": [
                    {
                        "username": "Coder_Mishra",
                        "content": "In second test case you add nums1 and nums2 in a right way but like first nums1 and second nums2 but in first test case you add nums 2 in the middle of nums 1 then how could we develop this globally like apart from these testcases and below I give my solution in Dart language.\\n\\nclass Solution {\\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\\n     double result;\\n  List<String> res=[];\\n  \\n  nums1.addAll(nums2);\\n  Set<int> set= Set();\\n  for(int i=0;i<nums1.length;i++){\\n     set.add(nums1[i]);\\n  }\\n  \\n  String s= set.join(\"\");\\n  print(s);\\n  res= s.split(\"\");\\n  if(res.length%2==0){\\n       result=  (int.parse(res[(res.length/2).toInt()-1])+int.parse(res[((res.length/2)+1).toInt()-1]))/2;\\n  }\\n  else{\\n    result=double.parse(res[(res.length/2).toInt()]);\\n  }\\n  print(result);\\n   return result;\\n  }\\n \\n}"
                    },
                    {
                        "username": "rafikrushanian",
                        "content": "[1,3][2,7] Output: 3.25000 Expected 2.50000 -- How? can somebody help me to understand why?"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "For some reason, I don't understand how some submissions are merging the arrays and getting away with it. The question clearly says that the solution should be O(log(m+n)) and merging the array will already take O(m+n). The test cases clearly do no justice to solution with complexity O(log(m+n))."
                    },
                    {
                        "username": "Pablitoz",
                        "content": "doesn\\'t seem like it should be a hard, i think this deserves a medium"
                    },
                    {
                        "username": "denisartemev228",
                        "content": "Good Morning, i have a problem with this questoins. in PyCharm i get 2.5 in test  nums1 = [1,2] nums2 = [3,4], BUT in leetcode i get 2.0. How?"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "smells like binary search"
                    },
                    {
                        "username": "beypazari",
                        "content": "My code returns the true answer on vs code but when i run the same code here its returning the wrong value. How??"
                    },
                    {
                        "username": "dmk978",
                        "content": "I believe a real problem definition have to be \"write a suite that checks the real complexity of supposed solution\". :)"
                    },
                    {
                        "username": "luckyempire",
                        "content": "l1=list(input().split())\\nl2=list(input().split())\\nl3=[]\\na=[]\\nl3=l1+l2\\nl3.sort()\\nif len(l3)%2!=0:\\n    print(l3[len(l3)//2])\\nelse:\\n    n=len(l3)\\n    print(((n//2)+((n//2)+1))/2)\\nWhy cant we use this type of approach ...I mean this is far way efficient code \\nAm I correct regarding this ????"
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "return Double(l3 [ (l3. count - 1) / 2 ]) something like this. "
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "You see the result of this is a floating point result print(l3[len(l3)//2]) but shouldn\\u2019t "
                    },
                    {
                        "username": "Kopiium",
                        "content": "okay maybe I\\'ve been asked this before haha"
                    }
                ]
            },
            {
                "id": 1855661,
                "content": [
                    {
                        "username": "Coder_Mishra",
                        "content": "In second test case you add nums1 and nums2 in a right way but like first nums1 and second nums2 but in first test case you add nums 2 in the middle of nums 1 then how could we develop this globally like apart from these testcases and below I give my solution in Dart language.\\n\\nclass Solution {\\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\\n     double result;\\n  List<String> res=[];\\n  \\n  nums1.addAll(nums2);\\n  Set<int> set= Set();\\n  for(int i=0;i<nums1.length;i++){\\n     set.add(nums1[i]);\\n  }\\n  \\n  String s= set.join(\"\");\\n  print(s);\\n  res= s.split(\"\");\\n  if(res.length%2==0){\\n       result=  (int.parse(res[(res.length/2).toInt()-1])+int.parse(res[((res.length/2)+1).toInt()-1]))/2;\\n  }\\n  else{\\n    result=double.parse(res[(res.length/2).toInt()]);\\n  }\\n  print(result);\\n   return result;\\n  }\\n \\n}"
                    },
                    {
                        "username": "rafikrushanian",
                        "content": "[1,3][2,7] Output: 3.25000 Expected 2.50000 -- How? can somebody help me to understand why?"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "For some reason, I don't understand how some submissions are merging the arrays and getting away with it. The question clearly says that the solution should be O(log(m+n)) and merging the array will already take O(m+n). The test cases clearly do no justice to solution with complexity O(log(m+n))."
                    },
                    {
                        "username": "Pablitoz",
                        "content": "doesn\\'t seem like it should be a hard, i think this deserves a medium"
                    },
                    {
                        "username": "denisartemev228",
                        "content": "Good Morning, i have a problem with this questoins. in PyCharm i get 2.5 in test  nums1 = [1,2] nums2 = [3,4], BUT in leetcode i get 2.0. How?"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "smells like binary search"
                    },
                    {
                        "username": "beypazari",
                        "content": "My code returns the true answer on vs code but when i run the same code here its returning the wrong value. How??"
                    },
                    {
                        "username": "dmk978",
                        "content": "I believe a real problem definition have to be \"write a suite that checks the real complexity of supposed solution\". :)"
                    },
                    {
                        "username": "luckyempire",
                        "content": "l1=list(input().split())\\nl2=list(input().split())\\nl3=[]\\na=[]\\nl3=l1+l2\\nl3.sort()\\nif len(l3)%2!=0:\\n    print(l3[len(l3)//2])\\nelse:\\n    n=len(l3)\\n    print(((n//2)+((n//2)+1))/2)\\nWhy cant we use this type of approach ...I mean this is far way efficient code \\nAm I correct regarding this ????"
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "return Double(l3 [ (l3. count - 1) / 2 ]) something like this. "
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "You see the result of this is a floating point result print(l3[len(l3)//2]) but shouldn\\u2019t "
                    },
                    {
                        "username": "Kopiium",
                        "content": "okay maybe I\\'ve been asked this before haha"
                    }
                ]
            },
            {
                "id": 1854188,
                "content": [
                    {
                        "username": "Coder_Mishra",
                        "content": "In second test case you add nums1 and nums2 in a right way but like first nums1 and second nums2 but in first test case you add nums 2 in the middle of nums 1 then how could we develop this globally like apart from these testcases and below I give my solution in Dart language.\\n\\nclass Solution {\\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\\n     double result;\\n  List<String> res=[];\\n  \\n  nums1.addAll(nums2);\\n  Set<int> set= Set();\\n  for(int i=0;i<nums1.length;i++){\\n     set.add(nums1[i]);\\n  }\\n  \\n  String s= set.join(\"\");\\n  print(s);\\n  res= s.split(\"\");\\n  if(res.length%2==0){\\n       result=  (int.parse(res[(res.length/2).toInt()-1])+int.parse(res[((res.length/2)+1).toInt()-1]))/2;\\n  }\\n  else{\\n    result=double.parse(res[(res.length/2).toInt()]);\\n  }\\n  print(result);\\n   return result;\\n  }\\n \\n}"
                    },
                    {
                        "username": "rafikrushanian",
                        "content": "[1,3][2,7] Output: 3.25000 Expected 2.50000 -- How? can somebody help me to understand why?"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "For some reason, I don't understand how some submissions are merging the arrays and getting away with it. The question clearly says that the solution should be O(log(m+n)) and merging the array will already take O(m+n). The test cases clearly do no justice to solution with complexity O(log(m+n))."
                    },
                    {
                        "username": "Pablitoz",
                        "content": "doesn\\'t seem like it should be a hard, i think this deserves a medium"
                    },
                    {
                        "username": "denisartemev228",
                        "content": "Good Morning, i have a problem with this questoins. in PyCharm i get 2.5 in test  nums1 = [1,2] nums2 = [3,4], BUT in leetcode i get 2.0. How?"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "smells like binary search"
                    },
                    {
                        "username": "beypazari",
                        "content": "My code returns the true answer on vs code but when i run the same code here its returning the wrong value. How??"
                    },
                    {
                        "username": "dmk978",
                        "content": "I believe a real problem definition have to be \"write a suite that checks the real complexity of supposed solution\". :)"
                    },
                    {
                        "username": "luckyempire",
                        "content": "l1=list(input().split())\\nl2=list(input().split())\\nl3=[]\\na=[]\\nl3=l1+l2\\nl3.sort()\\nif len(l3)%2!=0:\\n    print(l3[len(l3)//2])\\nelse:\\n    n=len(l3)\\n    print(((n//2)+((n//2)+1))/2)\\nWhy cant we use this type of approach ...I mean this is far way efficient code \\nAm I correct regarding this ????"
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "return Double(l3 [ (l3. count - 1) / 2 ]) something like this. "
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "You see the result of this is a floating point result print(l3[len(l3)//2]) but shouldn\\u2019t "
                    },
                    {
                        "username": "Kopiium",
                        "content": "okay maybe I\\'ve been asked this before haha"
                    }
                ]
            },
            {
                "id": 1854054,
                "content": [
                    {
                        "username": "Coder_Mishra",
                        "content": "In second test case you add nums1 and nums2 in a right way but like first nums1 and second nums2 but in first test case you add nums 2 in the middle of nums 1 then how could we develop this globally like apart from these testcases and below I give my solution in Dart language.\\n\\nclass Solution {\\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\\n     double result;\\n  List<String> res=[];\\n  \\n  nums1.addAll(nums2);\\n  Set<int> set= Set();\\n  for(int i=0;i<nums1.length;i++){\\n     set.add(nums1[i]);\\n  }\\n  \\n  String s= set.join(\"\");\\n  print(s);\\n  res= s.split(\"\");\\n  if(res.length%2==0){\\n       result=  (int.parse(res[(res.length/2).toInt()-1])+int.parse(res[((res.length/2)+1).toInt()-1]))/2;\\n  }\\n  else{\\n    result=double.parse(res[(res.length/2).toInt()]);\\n  }\\n  print(result);\\n   return result;\\n  }\\n \\n}"
                    },
                    {
                        "username": "rafikrushanian",
                        "content": "[1,3][2,7] Output: 3.25000 Expected 2.50000 -- How? can somebody help me to understand why?"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "For some reason, I don't understand how some submissions are merging the arrays and getting away with it. The question clearly says that the solution should be O(log(m+n)) and merging the array will already take O(m+n). The test cases clearly do no justice to solution with complexity O(log(m+n))."
                    },
                    {
                        "username": "Pablitoz",
                        "content": "doesn\\'t seem like it should be a hard, i think this deserves a medium"
                    },
                    {
                        "username": "denisartemev228",
                        "content": "Good Morning, i have a problem with this questoins. in PyCharm i get 2.5 in test  nums1 = [1,2] nums2 = [3,4], BUT in leetcode i get 2.0. How?"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "smells like binary search"
                    },
                    {
                        "username": "beypazari",
                        "content": "My code returns the true answer on vs code but when i run the same code here its returning the wrong value. How??"
                    },
                    {
                        "username": "dmk978",
                        "content": "I believe a real problem definition have to be \"write a suite that checks the real complexity of supposed solution\". :)"
                    },
                    {
                        "username": "luckyempire",
                        "content": "l1=list(input().split())\\nl2=list(input().split())\\nl3=[]\\na=[]\\nl3=l1+l2\\nl3.sort()\\nif len(l3)%2!=0:\\n    print(l3[len(l3)//2])\\nelse:\\n    n=len(l3)\\n    print(((n//2)+((n//2)+1))/2)\\nWhy cant we use this type of approach ...I mean this is far way efficient code \\nAm I correct regarding this ????"
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "return Double(l3 [ (l3. count - 1) / 2 ]) something like this. "
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "You see the result of this is a floating point result print(l3[len(l3)//2]) but shouldn\\u2019t "
                    },
                    {
                        "username": "Kopiium",
                        "content": "okay maybe I\\'ve been asked this before haha"
                    }
                ]
            },
            {
                "id": 1851815,
                "content": [
                    {
                        "username": "Coder_Mishra",
                        "content": "In second test case you add nums1 and nums2 in a right way but like first nums1 and second nums2 but in first test case you add nums 2 in the middle of nums 1 then how could we develop this globally like apart from these testcases and below I give my solution in Dart language.\\n\\nclass Solution {\\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\\n     double result;\\n  List<String> res=[];\\n  \\n  nums1.addAll(nums2);\\n  Set<int> set= Set();\\n  for(int i=0;i<nums1.length;i++){\\n     set.add(nums1[i]);\\n  }\\n  \\n  String s= set.join(\"\");\\n  print(s);\\n  res= s.split(\"\");\\n  if(res.length%2==0){\\n       result=  (int.parse(res[(res.length/2).toInt()-1])+int.parse(res[((res.length/2)+1).toInt()-1]))/2;\\n  }\\n  else{\\n    result=double.parse(res[(res.length/2).toInt()]);\\n  }\\n  print(result);\\n   return result;\\n  }\\n \\n}"
                    },
                    {
                        "username": "rafikrushanian",
                        "content": "[1,3][2,7] Output: 3.25000 Expected 2.50000 -- How? can somebody help me to understand why?"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "For some reason, I don't understand how some submissions are merging the arrays and getting away with it. The question clearly says that the solution should be O(log(m+n)) and merging the array will already take O(m+n). The test cases clearly do no justice to solution with complexity O(log(m+n))."
                    },
                    {
                        "username": "Pablitoz",
                        "content": "doesn\\'t seem like it should be a hard, i think this deserves a medium"
                    },
                    {
                        "username": "denisartemev228",
                        "content": "Good Morning, i have a problem with this questoins. in PyCharm i get 2.5 in test  nums1 = [1,2] nums2 = [3,4], BUT in leetcode i get 2.0. How?"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "smells like binary search"
                    },
                    {
                        "username": "beypazari",
                        "content": "My code returns the true answer on vs code but when i run the same code here its returning the wrong value. How??"
                    },
                    {
                        "username": "dmk978",
                        "content": "I believe a real problem definition have to be \"write a suite that checks the real complexity of supposed solution\". :)"
                    },
                    {
                        "username": "luckyempire",
                        "content": "l1=list(input().split())\\nl2=list(input().split())\\nl3=[]\\na=[]\\nl3=l1+l2\\nl3.sort()\\nif len(l3)%2!=0:\\n    print(l3[len(l3)//2])\\nelse:\\n    n=len(l3)\\n    print(((n//2)+((n//2)+1))/2)\\nWhy cant we use this type of approach ...I mean this is far way efficient code \\nAm I correct regarding this ????"
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "return Double(l3 [ (l3. count - 1) / 2 ]) something like this. "
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "You see the result of this is a floating point result print(l3[len(l3)//2]) but shouldn\\u2019t "
                    },
                    {
                        "username": "Kopiium",
                        "content": "okay maybe I\\'ve been asked this before haha"
                    }
                ]
            },
            {
                "id": 1848737,
                "content": [
                    {
                        "username": "Coder_Mishra",
                        "content": "In second test case you add nums1 and nums2 in a right way but like first nums1 and second nums2 but in first test case you add nums 2 in the middle of nums 1 then how could we develop this globally like apart from these testcases and below I give my solution in Dart language.\\n\\nclass Solution {\\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\\n     double result;\\n  List<String> res=[];\\n  \\n  nums1.addAll(nums2);\\n  Set<int> set= Set();\\n  for(int i=0;i<nums1.length;i++){\\n     set.add(nums1[i]);\\n  }\\n  \\n  String s= set.join(\"\");\\n  print(s);\\n  res= s.split(\"\");\\n  if(res.length%2==0){\\n       result=  (int.parse(res[(res.length/2).toInt()-1])+int.parse(res[((res.length/2)+1).toInt()-1]))/2;\\n  }\\n  else{\\n    result=double.parse(res[(res.length/2).toInt()]);\\n  }\\n  print(result);\\n   return result;\\n  }\\n \\n}"
                    },
                    {
                        "username": "rafikrushanian",
                        "content": "[1,3][2,7] Output: 3.25000 Expected 2.50000 -- How? can somebody help me to understand why?"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "For some reason, I don't understand how some submissions are merging the arrays and getting away with it. The question clearly says that the solution should be O(log(m+n)) and merging the array will already take O(m+n). The test cases clearly do no justice to solution with complexity O(log(m+n))."
                    },
                    {
                        "username": "Pablitoz",
                        "content": "doesn\\'t seem like it should be a hard, i think this deserves a medium"
                    },
                    {
                        "username": "denisartemev228",
                        "content": "Good Morning, i have a problem with this questoins. in PyCharm i get 2.5 in test  nums1 = [1,2] nums2 = [3,4], BUT in leetcode i get 2.0. How?"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "smells like binary search"
                    },
                    {
                        "username": "beypazari",
                        "content": "My code returns the true answer on vs code but when i run the same code here its returning the wrong value. How??"
                    },
                    {
                        "username": "dmk978",
                        "content": "I believe a real problem definition have to be \"write a suite that checks the real complexity of supposed solution\". :)"
                    },
                    {
                        "username": "luckyempire",
                        "content": "l1=list(input().split())\\nl2=list(input().split())\\nl3=[]\\na=[]\\nl3=l1+l2\\nl3.sort()\\nif len(l3)%2!=0:\\n    print(l3[len(l3)//2])\\nelse:\\n    n=len(l3)\\n    print(((n//2)+((n//2)+1))/2)\\nWhy cant we use this type of approach ...I mean this is far way efficient code \\nAm I correct regarding this ????"
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "return Double(l3 [ (l3. count - 1) / 2 ]) something like this. "
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "You see the result of this is a floating point result print(l3[len(l3)//2]) but shouldn\\u2019t "
                    },
                    {
                        "username": "Kopiium",
                        "content": "okay maybe I\\'ve been asked this before haha"
                    }
                ]
            },
            {
                "id": 1848548,
                "content": [
                    {
                        "username": "Coder_Mishra",
                        "content": "In second test case you add nums1 and nums2 in a right way but like first nums1 and second nums2 but in first test case you add nums 2 in the middle of nums 1 then how could we develop this globally like apart from these testcases and below I give my solution in Dart language.\\n\\nclass Solution {\\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\\n     double result;\\n  List<String> res=[];\\n  \\n  nums1.addAll(nums2);\\n  Set<int> set= Set();\\n  for(int i=0;i<nums1.length;i++){\\n     set.add(nums1[i]);\\n  }\\n  \\n  String s= set.join(\"\");\\n  print(s);\\n  res= s.split(\"\");\\n  if(res.length%2==0){\\n       result=  (int.parse(res[(res.length/2).toInt()-1])+int.parse(res[((res.length/2)+1).toInt()-1]))/2;\\n  }\\n  else{\\n    result=double.parse(res[(res.length/2).toInt()]);\\n  }\\n  print(result);\\n   return result;\\n  }\\n \\n}"
                    },
                    {
                        "username": "rafikrushanian",
                        "content": "[1,3][2,7] Output: 3.25000 Expected 2.50000 -- How? can somebody help me to understand why?"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "For some reason, I don't understand how some submissions are merging the arrays and getting away with it. The question clearly says that the solution should be O(log(m+n)) and merging the array will already take O(m+n). The test cases clearly do no justice to solution with complexity O(log(m+n))."
                    },
                    {
                        "username": "Pablitoz",
                        "content": "doesn\\'t seem like it should be a hard, i think this deserves a medium"
                    },
                    {
                        "username": "denisartemev228",
                        "content": "Good Morning, i have a problem with this questoins. in PyCharm i get 2.5 in test  nums1 = [1,2] nums2 = [3,4], BUT in leetcode i get 2.0. How?"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "smells like binary search"
                    },
                    {
                        "username": "beypazari",
                        "content": "My code returns the true answer on vs code but when i run the same code here its returning the wrong value. How??"
                    },
                    {
                        "username": "dmk978",
                        "content": "I believe a real problem definition have to be \"write a suite that checks the real complexity of supposed solution\". :)"
                    },
                    {
                        "username": "luckyempire",
                        "content": "l1=list(input().split())\\nl2=list(input().split())\\nl3=[]\\na=[]\\nl3=l1+l2\\nl3.sort()\\nif len(l3)%2!=0:\\n    print(l3[len(l3)//2])\\nelse:\\n    n=len(l3)\\n    print(((n//2)+((n//2)+1))/2)\\nWhy cant we use this type of approach ...I mean this is far way efficient code \\nAm I correct regarding this ????"
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "return Double(l3 [ (l3. count - 1) / 2 ]) something like this. "
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "You see the result of this is a floating point result print(l3[len(l3)//2]) but shouldn\\u2019t "
                    },
                    {
                        "username": "Kopiium",
                        "content": "okay maybe I\\'ve been asked this before haha"
                    }
                ]
            },
            {
                "id": 1843112,
                "content": [
                    {
                        "username": "Coder_Mishra",
                        "content": "In second test case you add nums1 and nums2 in a right way but like first nums1 and second nums2 but in first test case you add nums 2 in the middle of nums 1 then how could we develop this globally like apart from these testcases and below I give my solution in Dart language.\\n\\nclass Solution {\\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\\n     double result;\\n  List<String> res=[];\\n  \\n  nums1.addAll(nums2);\\n  Set<int> set= Set();\\n  for(int i=0;i<nums1.length;i++){\\n     set.add(nums1[i]);\\n  }\\n  \\n  String s= set.join(\"\");\\n  print(s);\\n  res= s.split(\"\");\\n  if(res.length%2==0){\\n       result=  (int.parse(res[(res.length/2).toInt()-1])+int.parse(res[((res.length/2)+1).toInt()-1]))/2;\\n  }\\n  else{\\n    result=double.parse(res[(res.length/2).toInt()]);\\n  }\\n  print(result);\\n   return result;\\n  }\\n \\n}"
                    },
                    {
                        "username": "rafikrushanian",
                        "content": "[1,3][2,7] Output: 3.25000 Expected 2.50000 -- How? can somebody help me to understand why?"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "For some reason, I don't understand how some submissions are merging the arrays and getting away with it. The question clearly says that the solution should be O(log(m+n)) and merging the array will already take O(m+n). The test cases clearly do no justice to solution with complexity O(log(m+n))."
                    },
                    {
                        "username": "Pablitoz",
                        "content": "doesn\\'t seem like it should be a hard, i think this deserves a medium"
                    },
                    {
                        "username": "denisartemev228",
                        "content": "Good Morning, i have a problem with this questoins. in PyCharm i get 2.5 in test  nums1 = [1,2] nums2 = [3,4], BUT in leetcode i get 2.0. How?"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "smells like binary search"
                    },
                    {
                        "username": "beypazari",
                        "content": "My code returns the true answer on vs code but when i run the same code here its returning the wrong value. How??"
                    },
                    {
                        "username": "dmk978",
                        "content": "I believe a real problem definition have to be \"write a suite that checks the real complexity of supposed solution\". :)"
                    },
                    {
                        "username": "luckyempire",
                        "content": "l1=list(input().split())\\nl2=list(input().split())\\nl3=[]\\na=[]\\nl3=l1+l2\\nl3.sort()\\nif len(l3)%2!=0:\\n    print(l3[len(l3)//2])\\nelse:\\n    n=len(l3)\\n    print(((n//2)+((n//2)+1))/2)\\nWhy cant we use this type of approach ...I mean this is far way efficient code \\nAm I correct regarding this ????"
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "return Double(l3 [ (l3. count - 1) / 2 ]) something like this. "
                    },
                    {
                        "username": "LavajavaLux",
                        "content": "You see the result of this is a floating point result print(l3[len(l3)//2]) but shouldn\\u2019t "
                    },
                    {
                        "username": "Kopiium",
                        "content": "okay maybe I\\'ve been asked this before haha"
                    }
                ]
            },
            {
                "id": 1841129,
                "content": [
                    {
                        "username": "Urvesh_2212",
                        "content": "We can use Median of Median Algorithm (Application of Binary search)"
                    },
                    {
                        "username": "vobadgek",
                        "content": "Excellent task description, excellent edge cases\\n\\nnums1 = [4,5,6,8,9]\\nnums2 =[]\\n\\nOutput 6.33333\\nExpected 6.00000"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "So what\\'s the problem here? The supposed answer should be 6. Your result might be because you didn\\'t expected empty array like me. But question clearly says 0<=m<= 1000, which means m can be zero, or we may have empty array."
                    },
                    {
                        "username": "quangnpham",
                        "content": "```\ndef findMedianSortedArrays(self, nums1, nums2):\n        _compute_list = nums1 + nums2\n        _list_len = len(_compute_list)\n        _median_index = _list_len // 2\n        _compute_list.sort()\n        if _list_len & 1:\n            return float(_compute_list[_median_index])\n        return float((_compute_list[_median_index]+_compute_list[_median_index - 1])/2)\nInput: [1,2], [3,4]\nExpected: 2.50000\nIn my IDE, the result was 2.5 but 2 on this site\nWhat did I made wrong?"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "Use two pointer method to merge the array like merge sort then find the median"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "I don\\'t know why but its running for O(m+n) time complexity also."
                    },
                    {
                        "username": "geekofshire",
                        "content": " Something is worng with OA. I submitted a  `O(m+n)` solution yet my code is faster than 100% of the solutions."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "me too! "
                    },
                    {
                        "username": "ijackyu",
                        "content": "> nums1 =[1,1]\\nnums2 =[1,2]\\nOutput: 1.50000\\nExpected: 1.00000\\n\\nmerged array = [1,2], so I think the median is `1.5`, but the right output is `1`,why?"
                    },
                    {
                        "username": "ludono",
                        "content": "Merged array should be [1,1,1,2]"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "This problem is easy to solve but they marked it hard because of the requirement of `O(log(n+m))`. However they did not include it in their tests."
                    },
                    {
                        "username": "HauTranCong",
                        "content": "Input\nnums1 =\n[1,2]\nnums2 =\n[1,1]\nUse Testcase\nOutput\n1.50000\nExpected\n1.00000\n\nHow it can be 1? It should be (1 + 2) / 2  "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "This is why you don\\'t skip mathematics class my man."
                    },
                    {
                        "username": "lalitsahuji930",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] arr1, int[] arr2) {\\n        int[] array = new int[arr1.length + arr2.length];\\n        int i;\\n        for (i = 0; i < arr1.length; i++) {\\n            array[i] = arr1[i];\\n        }\\n        for (int j = 0; j < arr2.length; j++) {\\n            array[i] = arr2[j];\\n            i++;\\n        }\\n        Arrays.sort(array);\\n        double median;\\n        if (array.length % 2 == 1) {\\n            return(array[((array.length + 1) / 2)-1]);\\n        } else {\\n            median = (double) (array[((array.length) / 2) - 1] + array[(((array.length / 2) + 1)) - 1]) / 2;\\n            return(median);\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1839965,
                "content": [
                    {
                        "username": "Urvesh_2212",
                        "content": "We can use Median of Median Algorithm (Application of Binary search)"
                    },
                    {
                        "username": "vobadgek",
                        "content": "Excellent task description, excellent edge cases\\n\\nnums1 = [4,5,6,8,9]\\nnums2 =[]\\n\\nOutput 6.33333\\nExpected 6.00000"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "So what\\'s the problem here? The supposed answer should be 6. Your result might be because you didn\\'t expected empty array like me. But question clearly says 0<=m<= 1000, which means m can be zero, or we may have empty array."
                    },
                    {
                        "username": "quangnpham",
                        "content": "```\ndef findMedianSortedArrays(self, nums1, nums2):\n        _compute_list = nums1 + nums2\n        _list_len = len(_compute_list)\n        _median_index = _list_len // 2\n        _compute_list.sort()\n        if _list_len & 1:\n            return float(_compute_list[_median_index])\n        return float((_compute_list[_median_index]+_compute_list[_median_index - 1])/2)\nInput: [1,2], [3,4]\nExpected: 2.50000\nIn my IDE, the result was 2.5 but 2 on this site\nWhat did I made wrong?"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "Use two pointer method to merge the array like merge sort then find the median"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "I don\\'t know why but its running for O(m+n) time complexity also."
                    },
                    {
                        "username": "geekofshire",
                        "content": " Something is worng with OA. I submitted a  `O(m+n)` solution yet my code is faster than 100% of the solutions."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "me too! "
                    },
                    {
                        "username": "ijackyu",
                        "content": "> nums1 =[1,1]\\nnums2 =[1,2]\\nOutput: 1.50000\\nExpected: 1.00000\\n\\nmerged array = [1,2], so I think the median is `1.5`, but the right output is `1`,why?"
                    },
                    {
                        "username": "ludono",
                        "content": "Merged array should be [1,1,1,2]"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "This problem is easy to solve but they marked it hard because of the requirement of `O(log(n+m))`. However they did not include it in their tests."
                    },
                    {
                        "username": "HauTranCong",
                        "content": "Input\nnums1 =\n[1,2]\nnums2 =\n[1,1]\nUse Testcase\nOutput\n1.50000\nExpected\n1.00000\n\nHow it can be 1? It should be (1 + 2) / 2  "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "This is why you don\\'t skip mathematics class my man."
                    },
                    {
                        "username": "lalitsahuji930",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] arr1, int[] arr2) {\\n        int[] array = new int[arr1.length + arr2.length];\\n        int i;\\n        for (i = 0; i < arr1.length; i++) {\\n            array[i] = arr1[i];\\n        }\\n        for (int j = 0; j < arr2.length; j++) {\\n            array[i] = arr2[j];\\n            i++;\\n        }\\n        Arrays.sort(array);\\n        double median;\\n        if (array.length % 2 == 1) {\\n            return(array[((array.length + 1) / 2)-1]);\\n        } else {\\n            median = (double) (array[((array.length) / 2) - 1] + array[(((array.length / 2) + 1)) - 1]) / 2;\\n            return(median);\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1837667,
                "content": [
                    {
                        "username": "Urvesh_2212",
                        "content": "We can use Median of Median Algorithm (Application of Binary search)"
                    },
                    {
                        "username": "vobadgek",
                        "content": "Excellent task description, excellent edge cases\\n\\nnums1 = [4,5,6,8,9]\\nnums2 =[]\\n\\nOutput 6.33333\\nExpected 6.00000"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "So what\\'s the problem here? The supposed answer should be 6. Your result might be because you didn\\'t expected empty array like me. But question clearly says 0<=m<= 1000, which means m can be zero, or we may have empty array."
                    },
                    {
                        "username": "quangnpham",
                        "content": "```\ndef findMedianSortedArrays(self, nums1, nums2):\n        _compute_list = nums1 + nums2\n        _list_len = len(_compute_list)\n        _median_index = _list_len // 2\n        _compute_list.sort()\n        if _list_len & 1:\n            return float(_compute_list[_median_index])\n        return float((_compute_list[_median_index]+_compute_list[_median_index - 1])/2)\nInput: [1,2], [3,4]\nExpected: 2.50000\nIn my IDE, the result was 2.5 but 2 on this site\nWhat did I made wrong?"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "Use two pointer method to merge the array like merge sort then find the median"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "I don\\'t know why but its running for O(m+n) time complexity also."
                    },
                    {
                        "username": "geekofshire",
                        "content": " Something is worng with OA. I submitted a  `O(m+n)` solution yet my code is faster than 100% of the solutions."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "me too! "
                    },
                    {
                        "username": "ijackyu",
                        "content": "> nums1 =[1,1]\\nnums2 =[1,2]\\nOutput: 1.50000\\nExpected: 1.00000\\n\\nmerged array = [1,2], so I think the median is `1.5`, but the right output is `1`,why?"
                    },
                    {
                        "username": "ludono",
                        "content": "Merged array should be [1,1,1,2]"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "This problem is easy to solve but they marked it hard because of the requirement of `O(log(n+m))`. However they did not include it in their tests."
                    },
                    {
                        "username": "HauTranCong",
                        "content": "Input\nnums1 =\n[1,2]\nnums2 =\n[1,1]\nUse Testcase\nOutput\n1.50000\nExpected\n1.00000\n\nHow it can be 1? It should be (1 + 2) / 2  "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "This is why you don\\'t skip mathematics class my man."
                    },
                    {
                        "username": "lalitsahuji930",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] arr1, int[] arr2) {\\n        int[] array = new int[arr1.length + arr2.length];\\n        int i;\\n        for (i = 0; i < arr1.length; i++) {\\n            array[i] = arr1[i];\\n        }\\n        for (int j = 0; j < arr2.length; j++) {\\n            array[i] = arr2[j];\\n            i++;\\n        }\\n        Arrays.sort(array);\\n        double median;\\n        if (array.length % 2 == 1) {\\n            return(array[((array.length + 1) / 2)-1]);\\n        } else {\\n            median = (double) (array[((array.length) / 2) - 1] + array[(((array.length / 2) + 1)) - 1]) / 2;\\n            return(median);\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1837584,
                "content": [
                    {
                        "username": "Urvesh_2212",
                        "content": "We can use Median of Median Algorithm (Application of Binary search)"
                    },
                    {
                        "username": "vobadgek",
                        "content": "Excellent task description, excellent edge cases\\n\\nnums1 = [4,5,6,8,9]\\nnums2 =[]\\n\\nOutput 6.33333\\nExpected 6.00000"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "So what\\'s the problem here? The supposed answer should be 6. Your result might be because you didn\\'t expected empty array like me. But question clearly says 0<=m<= 1000, which means m can be zero, or we may have empty array."
                    },
                    {
                        "username": "quangnpham",
                        "content": "```\ndef findMedianSortedArrays(self, nums1, nums2):\n        _compute_list = nums1 + nums2\n        _list_len = len(_compute_list)\n        _median_index = _list_len // 2\n        _compute_list.sort()\n        if _list_len & 1:\n            return float(_compute_list[_median_index])\n        return float((_compute_list[_median_index]+_compute_list[_median_index - 1])/2)\nInput: [1,2], [3,4]\nExpected: 2.50000\nIn my IDE, the result was 2.5 but 2 on this site\nWhat did I made wrong?"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "Use two pointer method to merge the array like merge sort then find the median"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "I don\\'t know why but its running for O(m+n) time complexity also."
                    },
                    {
                        "username": "geekofshire",
                        "content": " Something is worng with OA. I submitted a  `O(m+n)` solution yet my code is faster than 100% of the solutions."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "me too! "
                    },
                    {
                        "username": "ijackyu",
                        "content": "> nums1 =[1,1]\\nnums2 =[1,2]\\nOutput: 1.50000\\nExpected: 1.00000\\n\\nmerged array = [1,2], so I think the median is `1.5`, but the right output is `1`,why?"
                    },
                    {
                        "username": "ludono",
                        "content": "Merged array should be [1,1,1,2]"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "This problem is easy to solve but they marked it hard because of the requirement of `O(log(n+m))`. However they did not include it in their tests."
                    },
                    {
                        "username": "HauTranCong",
                        "content": "Input\nnums1 =\n[1,2]\nnums2 =\n[1,1]\nUse Testcase\nOutput\n1.50000\nExpected\n1.00000\n\nHow it can be 1? It should be (1 + 2) / 2  "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "This is why you don\\'t skip mathematics class my man."
                    },
                    {
                        "username": "lalitsahuji930",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] arr1, int[] arr2) {\\n        int[] array = new int[arr1.length + arr2.length];\\n        int i;\\n        for (i = 0; i < arr1.length; i++) {\\n            array[i] = arr1[i];\\n        }\\n        for (int j = 0; j < arr2.length; j++) {\\n            array[i] = arr2[j];\\n            i++;\\n        }\\n        Arrays.sort(array);\\n        double median;\\n        if (array.length % 2 == 1) {\\n            return(array[((array.length + 1) / 2)-1]);\\n        } else {\\n            median = (double) (array[((array.length) / 2) - 1] + array[(((array.length / 2) + 1)) - 1]) / 2;\\n            return(median);\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1837582,
                "content": [
                    {
                        "username": "Urvesh_2212",
                        "content": "We can use Median of Median Algorithm (Application of Binary search)"
                    },
                    {
                        "username": "vobadgek",
                        "content": "Excellent task description, excellent edge cases\\n\\nnums1 = [4,5,6,8,9]\\nnums2 =[]\\n\\nOutput 6.33333\\nExpected 6.00000"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "So what\\'s the problem here? The supposed answer should be 6. Your result might be because you didn\\'t expected empty array like me. But question clearly says 0<=m<= 1000, which means m can be zero, or we may have empty array."
                    },
                    {
                        "username": "quangnpham",
                        "content": "```\ndef findMedianSortedArrays(self, nums1, nums2):\n        _compute_list = nums1 + nums2\n        _list_len = len(_compute_list)\n        _median_index = _list_len // 2\n        _compute_list.sort()\n        if _list_len & 1:\n            return float(_compute_list[_median_index])\n        return float((_compute_list[_median_index]+_compute_list[_median_index - 1])/2)\nInput: [1,2], [3,4]\nExpected: 2.50000\nIn my IDE, the result was 2.5 but 2 on this site\nWhat did I made wrong?"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "Use two pointer method to merge the array like merge sort then find the median"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "I don\\'t know why but its running for O(m+n) time complexity also."
                    },
                    {
                        "username": "geekofshire",
                        "content": " Something is worng with OA. I submitted a  `O(m+n)` solution yet my code is faster than 100% of the solutions."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "me too! "
                    },
                    {
                        "username": "ijackyu",
                        "content": "> nums1 =[1,1]\\nnums2 =[1,2]\\nOutput: 1.50000\\nExpected: 1.00000\\n\\nmerged array = [1,2], so I think the median is `1.5`, but the right output is `1`,why?"
                    },
                    {
                        "username": "ludono",
                        "content": "Merged array should be [1,1,1,2]"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "This problem is easy to solve but they marked it hard because of the requirement of `O(log(n+m))`. However they did not include it in their tests."
                    },
                    {
                        "username": "HauTranCong",
                        "content": "Input\nnums1 =\n[1,2]\nnums2 =\n[1,1]\nUse Testcase\nOutput\n1.50000\nExpected\n1.00000\n\nHow it can be 1? It should be (1 + 2) / 2  "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "This is why you don\\'t skip mathematics class my man."
                    },
                    {
                        "username": "lalitsahuji930",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] arr1, int[] arr2) {\\n        int[] array = new int[arr1.length + arr2.length];\\n        int i;\\n        for (i = 0; i < arr1.length; i++) {\\n            array[i] = arr1[i];\\n        }\\n        for (int j = 0; j < arr2.length; j++) {\\n            array[i] = arr2[j];\\n            i++;\\n        }\\n        Arrays.sort(array);\\n        double median;\\n        if (array.length % 2 == 1) {\\n            return(array[((array.length + 1) / 2)-1]);\\n        } else {\\n            median = (double) (array[((array.length) / 2) - 1] + array[(((array.length / 2) + 1)) - 1]) / 2;\\n            return(median);\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1834096,
                "content": [
                    {
                        "username": "Urvesh_2212",
                        "content": "We can use Median of Median Algorithm (Application of Binary search)"
                    },
                    {
                        "username": "vobadgek",
                        "content": "Excellent task description, excellent edge cases\\n\\nnums1 = [4,5,6,8,9]\\nnums2 =[]\\n\\nOutput 6.33333\\nExpected 6.00000"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "So what\\'s the problem here? The supposed answer should be 6. Your result might be because you didn\\'t expected empty array like me. But question clearly says 0<=m<= 1000, which means m can be zero, or we may have empty array."
                    },
                    {
                        "username": "quangnpham",
                        "content": "```\ndef findMedianSortedArrays(self, nums1, nums2):\n        _compute_list = nums1 + nums2\n        _list_len = len(_compute_list)\n        _median_index = _list_len // 2\n        _compute_list.sort()\n        if _list_len & 1:\n            return float(_compute_list[_median_index])\n        return float((_compute_list[_median_index]+_compute_list[_median_index - 1])/2)\nInput: [1,2], [3,4]\nExpected: 2.50000\nIn my IDE, the result was 2.5 but 2 on this site\nWhat did I made wrong?"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "Use two pointer method to merge the array like merge sort then find the median"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "I don\\'t know why but its running for O(m+n) time complexity also."
                    },
                    {
                        "username": "geekofshire",
                        "content": " Something is worng with OA. I submitted a  `O(m+n)` solution yet my code is faster than 100% of the solutions."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "me too! "
                    },
                    {
                        "username": "ijackyu",
                        "content": "> nums1 =[1,1]\\nnums2 =[1,2]\\nOutput: 1.50000\\nExpected: 1.00000\\n\\nmerged array = [1,2], so I think the median is `1.5`, but the right output is `1`,why?"
                    },
                    {
                        "username": "ludono",
                        "content": "Merged array should be [1,1,1,2]"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "This problem is easy to solve but they marked it hard because of the requirement of `O(log(n+m))`. However they did not include it in their tests."
                    },
                    {
                        "username": "HauTranCong",
                        "content": "Input\nnums1 =\n[1,2]\nnums2 =\n[1,1]\nUse Testcase\nOutput\n1.50000\nExpected\n1.00000\n\nHow it can be 1? It should be (1 + 2) / 2  "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "This is why you don\\'t skip mathematics class my man."
                    },
                    {
                        "username": "lalitsahuji930",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] arr1, int[] arr2) {\\n        int[] array = new int[arr1.length + arr2.length];\\n        int i;\\n        for (i = 0; i < arr1.length; i++) {\\n            array[i] = arr1[i];\\n        }\\n        for (int j = 0; j < arr2.length; j++) {\\n            array[i] = arr2[j];\\n            i++;\\n        }\\n        Arrays.sort(array);\\n        double median;\\n        if (array.length % 2 == 1) {\\n            return(array[((array.length + 1) / 2)-1]);\\n        } else {\\n            median = (double) (array[((array.length) / 2) - 1] + array[(((array.length / 2) + 1)) - 1]) / 2;\\n            return(median);\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1832970,
                "content": [
                    {
                        "username": "Urvesh_2212",
                        "content": "We can use Median of Median Algorithm (Application of Binary search)"
                    },
                    {
                        "username": "vobadgek",
                        "content": "Excellent task description, excellent edge cases\\n\\nnums1 = [4,5,6,8,9]\\nnums2 =[]\\n\\nOutput 6.33333\\nExpected 6.00000"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "So what\\'s the problem here? The supposed answer should be 6. Your result might be because you didn\\'t expected empty array like me. But question clearly says 0<=m<= 1000, which means m can be zero, or we may have empty array."
                    },
                    {
                        "username": "quangnpham",
                        "content": "```\ndef findMedianSortedArrays(self, nums1, nums2):\n        _compute_list = nums1 + nums2\n        _list_len = len(_compute_list)\n        _median_index = _list_len // 2\n        _compute_list.sort()\n        if _list_len & 1:\n            return float(_compute_list[_median_index])\n        return float((_compute_list[_median_index]+_compute_list[_median_index - 1])/2)\nInput: [1,2], [3,4]\nExpected: 2.50000\nIn my IDE, the result was 2.5 but 2 on this site\nWhat did I made wrong?"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "Use two pointer method to merge the array like merge sort then find the median"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "I don\\'t know why but its running for O(m+n) time complexity also."
                    },
                    {
                        "username": "geekofshire",
                        "content": " Something is worng with OA. I submitted a  `O(m+n)` solution yet my code is faster than 100% of the solutions."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "me too! "
                    },
                    {
                        "username": "ijackyu",
                        "content": "> nums1 =[1,1]\\nnums2 =[1,2]\\nOutput: 1.50000\\nExpected: 1.00000\\n\\nmerged array = [1,2], so I think the median is `1.5`, but the right output is `1`,why?"
                    },
                    {
                        "username": "ludono",
                        "content": "Merged array should be [1,1,1,2]"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "This problem is easy to solve but they marked it hard because of the requirement of `O(log(n+m))`. However they did not include it in their tests."
                    },
                    {
                        "username": "HauTranCong",
                        "content": "Input\nnums1 =\n[1,2]\nnums2 =\n[1,1]\nUse Testcase\nOutput\n1.50000\nExpected\n1.00000\n\nHow it can be 1? It should be (1 + 2) / 2  "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "This is why you don\\'t skip mathematics class my man."
                    },
                    {
                        "username": "lalitsahuji930",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] arr1, int[] arr2) {\\n        int[] array = new int[arr1.length + arr2.length];\\n        int i;\\n        for (i = 0; i < arr1.length; i++) {\\n            array[i] = arr1[i];\\n        }\\n        for (int j = 0; j < arr2.length; j++) {\\n            array[i] = arr2[j];\\n            i++;\\n        }\\n        Arrays.sort(array);\\n        double median;\\n        if (array.length % 2 == 1) {\\n            return(array[((array.length + 1) / 2)-1]);\\n        } else {\\n            median = (double) (array[((array.length) / 2) - 1] + array[(((array.length / 2) + 1)) - 1]) / 2;\\n            return(median);\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1828444,
                "content": [
                    {
                        "username": "Urvesh_2212",
                        "content": "We can use Median of Median Algorithm (Application of Binary search)"
                    },
                    {
                        "username": "vobadgek",
                        "content": "Excellent task description, excellent edge cases\\n\\nnums1 = [4,5,6,8,9]\\nnums2 =[]\\n\\nOutput 6.33333\\nExpected 6.00000"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "So what\\'s the problem here? The supposed answer should be 6. Your result might be because you didn\\'t expected empty array like me. But question clearly says 0<=m<= 1000, which means m can be zero, or we may have empty array."
                    },
                    {
                        "username": "quangnpham",
                        "content": "```\ndef findMedianSortedArrays(self, nums1, nums2):\n        _compute_list = nums1 + nums2\n        _list_len = len(_compute_list)\n        _median_index = _list_len // 2\n        _compute_list.sort()\n        if _list_len & 1:\n            return float(_compute_list[_median_index])\n        return float((_compute_list[_median_index]+_compute_list[_median_index - 1])/2)\nInput: [1,2], [3,4]\nExpected: 2.50000\nIn my IDE, the result was 2.5 but 2 on this site\nWhat did I made wrong?"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "Use two pointer method to merge the array like merge sort then find the median"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "I don\\'t know why but its running for O(m+n) time complexity also."
                    },
                    {
                        "username": "geekofshire",
                        "content": " Something is worng with OA. I submitted a  `O(m+n)` solution yet my code is faster than 100% of the solutions."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "me too! "
                    },
                    {
                        "username": "ijackyu",
                        "content": "> nums1 =[1,1]\\nnums2 =[1,2]\\nOutput: 1.50000\\nExpected: 1.00000\\n\\nmerged array = [1,2], so I think the median is `1.5`, but the right output is `1`,why?"
                    },
                    {
                        "username": "ludono",
                        "content": "Merged array should be [1,1,1,2]"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "This problem is easy to solve but they marked it hard because of the requirement of `O(log(n+m))`. However they did not include it in their tests."
                    },
                    {
                        "username": "HauTranCong",
                        "content": "Input\nnums1 =\n[1,2]\nnums2 =\n[1,1]\nUse Testcase\nOutput\n1.50000\nExpected\n1.00000\n\nHow it can be 1? It should be (1 + 2) / 2  "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "This is why you don\\'t skip mathematics class my man."
                    },
                    {
                        "username": "lalitsahuji930",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] arr1, int[] arr2) {\\n        int[] array = new int[arr1.length + arr2.length];\\n        int i;\\n        for (i = 0; i < arr1.length; i++) {\\n            array[i] = arr1[i];\\n        }\\n        for (int j = 0; j < arr2.length; j++) {\\n            array[i] = arr2[j];\\n            i++;\\n        }\\n        Arrays.sort(array);\\n        double median;\\n        if (array.length % 2 == 1) {\\n            return(array[((array.length + 1) / 2)-1]);\\n        } else {\\n            median = (double) (array[((array.length) / 2) - 1] + array[(((array.length / 2) + 1)) - 1]) / 2;\\n            return(median);\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1825994,
                "content": [
                    {
                        "username": "Urvesh_2212",
                        "content": "We can use Median of Median Algorithm (Application of Binary search)"
                    },
                    {
                        "username": "vobadgek",
                        "content": "Excellent task description, excellent edge cases\\n\\nnums1 = [4,5,6,8,9]\\nnums2 =[]\\n\\nOutput 6.33333\\nExpected 6.00000"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "So what\\'s the problem here? The supposed answer should be 6. Your result might be because you didn\\'t expected empty array like me. But question clearly says 0<=m<= 1000, which means m can be zero, or we may have empty array."
                    },
                    {
                        "username": "quangnpham",
                        "content": "```\ndef findMedianSortedArrays(self, nums1, nums2):\n        _compute_list = nums1 + nums2\n        _list_len = len(_compute_list)\n        _median_index = _list_len // 2\n        _compute_list.sort()\n        if _list_len & 1:\n            return float(_compute_list[_median_index])\n        return float((_compute_list[_median_index]+_compute_list[_median_index - 1])/2)\nInput: [1,2], [3,4]\nExpected: 2.50000\nIn my IDE, the result was 2.5 but 2 on this site\nWhat did I made wrong?"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "Use two pointer method to merge the array like merge sort then find the median"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "I don\\'t know why but its running for O(m+n) time complexity also."
                    },
                    {
                        "username": "geekofshire",
                        "content": " Something is worng with OA. I submitted a  `O(m+n)` solution yet my code is faster than 100% of the solutions."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "me too! "
                    },
                    {
                        "username": "ijackyu",
                        "content": "> nums1 =[1,1]\\nnums2 =[1,2]\\nOutput: 1.50000\\nExpected: 1.00000\\n\\nmerged array = [1,2], so I think the median is `1.5`, but the right output is `1`,why?"
                    },
                    {
                        "username": "ludono",
                        "content": "Merged array should be [1,1,1,2]"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "This problem is easy to solve but they marked it hard because of the requirement of `O(log(n+m))`. However they did not include it in their tests."
                    },
                    {
                        "username": "HauTranCong",
                        "content": "Input\nnums1 =\n[1,2]\nnums2 =\n[1,1]\nUse Testcase\nOutput\n1.50000\nExpected\n1.00000\n\nHow it can be 1? It should be (1 + 2) / 2  "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "This is why you don\\'t skip mathematics class my man."
                    },
                    {
                        "username": "lalitsahuji930",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] arr1, int[] arr2) {\\n        int[] array = new int[arr1.length + arr2.length];\\n        int i;\\n        for (i = 0; i < arr1.length; i++) {\\n            array[i] = arr1[i];\\n        }\\n        for (int j = 0; j < arr2.length; j++) {\\n            array[i] = arr2[j];\\n            i++;\\n        }\\n        Arrays.sort(array);\\n        double median;\\n        if (array.length % 2 == 1) {\\n            return(array[((array.length + 1) / 2)-1]);\\n        } else {\\n            median = (double) (array[((array.length) / 2) - 1] + array[(((array.length / 2) + 1)) - 1]) / 2;\\n            return(median);\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1814838,
                "content": [
                    {
                        "username": "Urvesh_2212",
                        "content": "We can use Median of Median Algorithm (Application of Binary search)"
                    },
                    {
                        "username": "vobadgek",
                        "content": "Excellent task description, excellent edge cases\\n\\nnums1 = [4,5,6,8,9]\\nnums2 =[]\\n\\nOutput 6.33333\\nExpected 6.00000"
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "So what\\'s the problem here? The supposed answer should be 6. Your result might be because you didn\\'t expected empty array like me. But question clearly says 0<=m<= 1000, which means m can be zero, or we may have empty array."
                    },
                    {
                        "username": "quangnpham",
                        "content": "```\ndef findMedianSortedArrays(self, nums1, nums2):\n        _compute_list = nums1 + nums2\n        _list_len = len(_compute_list)\n        _median_index = _list_len // 2\n        _compute_list.sort()\n        if _list_len & 1:\n            return float(_compute_list[_median_index])\n        return float((_compute_list[_median_index]+_compute_list[_median_index - 1])/2)\nInput: [1,2], [3,4]\nExpected: 2.50000\nIn my IDE, the result was 2.5 but 2 on this site\nWhat did I made wrong?"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "Use two pointer method to merge the array like merge sort then find the median"
                    },
                    {
                        "username": "saket1harsh",
                        "content": "I don\\'t know why but its running for O(m+n) time complexity also."
                    },
                    {
                        "username": "geekofshire",
                        "content": " Something is worng with OA. I submitted a  `O(m+n)` solution yet my code is faster than 100% of the solutions."
                    },
                    {
                        "username": "enkvadrat",
                        "content": "me too! "
                    },
                    {
                        "username": "ijackyu",
                        "content": "> nums1 =[1,1]\\nnums2 =[1,2]\\nOutput: 1.50000\\nExpected: 1.00000\\n\\nmerged array = [1,2], so I think the median is `1.5`, but the right output is `1`,why?"
                    },
                    {
                        "username": "ludono",
                        "content": "Merged array should be [1,1,1,2]"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "This problem is easy to solve but they marked it hard because of the requirement of `O(log(n+m))`. However they did not include it in their tests."
                    },
                    {
                        "username": "HauTranCong",
                        "content": "Input\nnums1 =\n[1,2]\nnums2 =\n[1,1]\nUse Testcase\nOutput\n1.50000\nExpected\n1.00000\n\nHow it can be 1? It should be (1 + 2) / 2  "
                    },
                    {
                        "username": "PiyushRaj27",
                        "content": "This is why you don\\'t skip mathematics class my man."
                    },
                    {
                        "username": "lalitsahuji930",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] arr1, int[] arr2) {\\n        int[] array = new int[arr1.length + arr2.length];\\n        int i;\\n        for (i = 0; i < arr1.length; i++) {\\n            array[i] = arr1[i];\\n        }\\n        for (int j = 0; j < arr2.length; j++) {\\n            array[i] = arr2[j];\\n            i++;\\n        }\\n        Arrays.sort(array);\\n        double median;\\n        if (array.length % 2 == 1) {\\n            return(array[((array.length + 1) / 2)-1]);\\n        } else {\\n            median = (double) (array[((array.length) / 2) - 1] + array[(((array.length / 2) + 1)) - 1]) / 2;\\n            return(median);\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1813996,
                "content": [
                    {
                        "username": "simransingh5019",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n       int d = nums1.length+nums2.length;\\n       int arr[] = new int[d];\\n       int i = 0;\\n       int k = 0;\\n       int j = 0;\\n       while(i!=nums1.length && j!= nums2.length)\\n       {\\n           if(nums1[i]>=nums2[j])\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n           }\\n           else\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n           }\\n           k++;\\n       }\\n           while(i!=nums1.length)\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n               k++;\\n           }\\n           while(j!=nums2.length)\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n               k++;\\n           }\\n           double median = 0;\\n          if(d%2==0)\\n          {\\n             median = (arr[(d/2)-1]+arr[d/2])/2;\\n            double a = arr[(d/2)-1];\\n            double b =arr[(d/2)];\\n            median = (a+b)/2;\\n          }\\n          else\\n          {\\n            median = arr[d/2];\\n          }\\n        return median;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "michaeltempesta",
                        "content": "I know this should be hard but it seems super easy.\\n\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        merged = []\\n        # len1 = len(nums1)\\n        # len2 = len(nums2)\\n        # longlist = max(len(nums1), len(nums2))\\n        # print(len1, nums1)\\n        # print(len2, nums2)\\n        # print(longlist)\\n        biglist = nums1 + nums2\\n        sbiglist = sorted(biglist)\\n        # print(sbiglist)\\n        # if len(sbiglist)%2 ==0:\\n        #     median = float((sbiglist[(len(sbiglist)/2)] + sbiglist[(len(sbiglist)/2) -1])/2)\\n        #     return \"{:.5f}\".format(median)\\n        #     # print(median)\\n        # elif len(sbiglist)%2 ==1:\\n        #     median = float(sbiglist[ceil(len(sbiglist)/2)])\\n        #     # print(median)\\n        #     return \"{:.5f}\".format(median)\\n        print(sbiglist)\\n        if len(sbiglist) % 2 == 0:\\n            median = float((sbiglist[len(sbiglist)/2] + sbiglist[(len(sbiglist)/2)-1])/2)\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n        elif len(sbiglist) % 2 == 1:\\n            median = float((sbiglist[ceil(len(sbiglist)/2)-1]))\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n\\nbut I get this runtime error:\\nTypeError: 2.0 is not valid value for the expected return type double\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\\nLine 61 in _driver (Solution.py)\\n    _driver()\\nLine 68 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: must be real number, not str\\nLine 22 in _serialize_float (./python3/__serializer__.py)\\nLine 65 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'double\\')\\nLine 59 in _driver (Solution.py)\\n\\nI don\\'t understand what the difference between a double and a float is and according to the examples ive given up to 5decimals on the floats.\\n\\n"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why Memory Limit Exceeded!"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "This Question shouldn\\'t have the right to be in the Hard section. It\\'s quite easy\\uD83E\\uDEE1"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "[1, 2] and [3, 4] when we merged and sorted these two we get [1, 2, 3, 4] and median of this is (2 + 3)/2 = 2.5 but I\\'m getting 2.0 why??"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution \\n{\\n         public double  findMedianSortedArrays(int[] nums1, int[] nums2)\\n    {\\n        int a =nums1.length;\\n        int b = nums2.length;\\n        int j=0,i=0;\\n        int[] arr = new int[a+b];\\n        for(i=0;i<a;i++)\\n        {\\n           arr[i]=nums1[i];\\n        }\\n        \\n        for(i=a;i<a+b && j<b;i++,j++)\\n        {\\n           arr[i]=nums2[j];\\n        }\\n      double median =0;\\n      int n =arr.length;\\n      if(n%2!=0)\\n      {\\n         int ind = n/2;\\n         \\n         median= arr[ind];\\n      return median;\\n         \\n      }\\n      else{\\n         int ind1= n/2-1;\\n         int ind2=(n/2);\\n         median = (arr[ind1]+arr[ind2]);\\n     return median/2;\\n      }\\n    }\\n}\\n\\n\\nOn online Compiler it is showing correct output \\nBut why it is  showing wrong here \\n"
                    },
                    {
                        "username": "rahul23071992",
                        "content": "Close\\nrahul23071992\\nrahul23071992\\nFeb 19, 2023 11:58\\n\\nDetails\\nSolution\\nPython\\nRuntime\\n59 ms\\nBeats\\n97.1%\\nMemory\\n13.7 MB\\nBeats\\n54.66%\\nClick the distribution chart to view more details\\nNotes\\nWrite your notes here\\nRelated Tags\\nSelect tags\\n0/5\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        joinlist=nums1 +nums2\\n        sorted_list=sorted(joinlist)\\n        if len(sorted_list)%2!=0:\\n            median=sorted_list[(len(sorted_list)//2)]\\n\\n        else:\\n            a=sorted_list[(len(sorted_list)//2)-1]\\n            b=sorted_list[(len(sorted_list)//2)]\\n            print(a,b)\\n            median=float((a+b))/2\\n        return median\\n            "
                    },
                    {
                        "username": "PawanSingh563",
                        "content": " if(x%2==0){\n           \n          double  y=((nums3[(x/2)-1]+nums3[((x/2)+1)-1])/2);\n            \n            return y;\n            \n        }\n        else{\n            double y=nums3[((x+1)/2)-1];\n            return y;\n        }\n\n\nhii, everyone  i am beginner for this platfrom , actually in this concept case 1  is right but case 2  is not right  \n\n any one can help me ????"
                    },
                    {
                        "username": "truongsoi",
                        "content": "I saw a lot of accepted submissions but none of them do checking the pre-defined constrains as mine? Does the auto acceptance test miss these test cases?"
                    },
                    {
                        "username": "priyanshu_3108",
                        "content": "Java Easy solution\\n`class Solution {\\n    public double findMedianSortedArrays(int[] a1, int[] a2) {\\n        int len = a1.length + a2.length;\\n        int [] merged = new int[len];\\n        int i = 0 , j = 0, k = 0;\\n\\n        while( i < a1.length && j < a2.length){\\n            if(a1[i] < a2[j]){\\n                merged[k] = a1[i];\\n                i++;\\n                k++;\\n            }else{\\n                merged[k] = a2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n\\n        while(i < a1.length){\\n              merged[k] = a1[i];\\n              i++;\\n              k++;           \\n        }\\n        while(j < a2.length){\\n            merged[k] = a2[j];\\n            j++;\\n            k++;           \\n        }\\n        // Here we created a merged array\\\\ now we have to find the median\\n        double median = 0.0;\\n         int mid = merged.length / 2;\\n\\n        if(merged.length % 2 == 1){\\n            median= merged[mid];\\n\\n        }else{\\n            median= (merged[mid] + merged[mid - 1]) / 2.0;\\n        }\\n        return median;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1809081,
                "content": [
                    {
                        "username": "simransingh5019",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n       int d = nums1.length+nums2.length;\\n       int arr[] = new int[d];\\n       int i = 0;\\n       int k = 0;\\n       int j = 0;\\n       while(i!=nums1.length && j!= nums2.length)\\n       {\\n           if(nums1[i]>=nums2[j])\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n           }\\n           else\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n           }\\n           k++;\\n       }\\n           while(i!=nums1.length)\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n               k++;\\n           }\\n           while(j!=nums2.length)\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n               k++;\\n           }\\n           double median = 0;\\n          if(d%2==0)\\n          {\\n             median = (arr[(d/2)-1]+arr[d/2])/2;\\n            double a = arr[(d/2)-1];\\n            double b =arr[(d/2)];\\n            median = (a+b)/2;\\n          }\\n          else\\n          {\\n            median = arr[d/2];\\n          }\\n        return median;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "michaeltempesta",
                        "content": "I know this should be hard but it seems super easy.\\n\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        merged = []\\n        # len1 = len(nums1)\\n        # len2 = len(nums2)\\n        # longlist = max(len(nums1), len(nums2))\\n        # print(len1, nums1)\\n        # print(len2, nums2)\\n        # print(longlist)\\n        biglist = nums1 + nums2\\n        sbiglist = sorted(biglist)\\n        # print(sbiglist)\\n        # if len(sbiglist)%2 ==0:\\n        #     median = float((sbiglist[(len(sbiglist)/2)] + sbiglist[(len(sbiglist)/2) -1])/2)\\n        #     return \"{:.5f}\".format(median)\\n        #     # print(median)\\n        # elif len(sbiglist)%2 ==1:\\n        #     median = float(sbiglist[ceil(len(sbiglist)/2)])\\n        #     # print(median)\\n        #     return \"{:.5f}\".format(median)\\n        print(sbiglist)\\n        if len(sbiglist) % 2 == 0:\\n            median = float((sbiglist[len(sbiglist)/2] + sbiglist[(len(sbiglist)/2)-1])/2)\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n        elif len(sbiglist) % 2 == 1:\\n            median = float((sbiglist[ceil(len(sbiglist)/2)-1]))\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n\\nbut I get this runtime error:\\nTypeError: 2.0 is not valid value for the expected return type double\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\\nLine 61 in _driver (Solution.py)\\n    _driver()\\nLine 68 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: must be real number, not str\\nLine 22 in _serialize_float (./python3/__serializer__.py)\\nLine 65 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'double\\')\\nLine 59 in _driver (Solution.py)\\n\\nI don\\'t understand what the difference between a double and a float is and according to the examples ive given up to 5decimals on the floats.\\n\\n"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why Memory Limit Exceeded!"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "This Question shouldn\\'t have the right to be in the Hard section. It\\'s quite easy\\uD83E\\uDEE1"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "[1, 2] and [3, 4] when we merged and sorted these two we get [1, 2, 3, 4] and median of this is (2 + 3)/2 = 2.5 but I\\'m getting 2.0 why??"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution \\n{\\n         public double  findMedianSortedArrays(int[] nums1, int[] nums2)\\n    {\\n        int a =nums1.length;\\n        int b = nums2.length;\\n        int j=0,i=0;\\n        int[] arr = new int[a+b];\\n        for(i=0;i<a;i++)\\n        {\\n           arr[i]=nums1[i];\\n        }\\n        \\n        for(i=a;i<a+b && j<b;i++,j++)\\n        {\\n           arr[i]=nums2[j];\\n        }\\n      double median =0;\\n      int n =arr.length;\\n      if(n%2!=0)\\n      {\\n         int ind = n/2;\\n         \\n         median= arr[ind];\\n      return median;\\n         \\n      }\\n      else{\\n         int ind1= n/2-1;\\n         int ind2=(n/2);\\n         median = (arr[ind1]+arr[ind2]);\\n     return median/2;\\n      }\\n    }\\n}\\n\\n\\nOn online Compiler it is showing correct output \\nBut why it is  showing wrong here \\n"
                    },
                    {
                        "username": "rahul23071992",
                        "content": "Close\\nrahul23071992\\nrahul23071992\\nFeb 19, 2023 11:58\\n\\nDetails\\nSolution\\nPython\\nRuntime\\n59 ms\\nBeats\\n97.1%\\nMemory\\n13.7 MB\\nBeats\\n54.66%\\nClick the distribution chart to view more details\\nNotes\\nWrite your notes here\\nRelated Tags\\nSelect tags\\n0/5\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        joinlist=nums1 +nums2\\n        sorted_list=sorted(joinlist)\\n        if len(sorted_list)%2!=0:\\n            median=sorted_list[(len(sorted_list)//2)]\\n\\n        else:\\n            a=sorted_list[(len(sorted_list)//2)-1]\\n            b=sorted_list[(len(sorted_list)//2)]\\n            print(a,b)\\n            median=float((a+b))/2\\n        return median\\n            "
                    },
                    {
                        "username": "PawanSingh563",
                        "content": " if(x%2==0){\n           \n          double  y=((nums3[(x/2)-1]+nums3[((x/2)+1)-1])/2);\n            \n            return y;\n            \n        }\n        else{\n            double y=nums3[((x+1)/2)-1];\n            return y;\n        }\n\n\nhii, everyone  i am beginner for this platfrom , actually in this concept case 1  is right but case 2  is not right  \n\n any one can help me ????"
                    },
                    {
                        "username": "truongsoi",
                        "content": "I saw a lot of accepted submissions but none of them do checking the pre-defined constrains as mine? Does the auto acceptance test miss these test cases?"
                    },
                    {
                        "username": "priyanshu_3108",
                        "content": "Java Easy solution\\n`class Solution {\\n    public double findMedianSortedArrays(int[] a1, int[] a2) {\\n        int len = a1.length + a2.length;\\n        int [] merged = new int[len];\\n        int i = 0 , j = 0, k = 0;\\n\\n        while( i < a1.length && j < a2.length){\\n            if(a1[i] < a2[j]){\\n                merged[k] = a1[i];\\n                i++;\\n                k++;\\n            }else{\\n                merged[k] = a2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n\\n        while(i < a1.length){\\n              merged[k] = a1[i];\\n              i++;\\n              k++;           \\n        }\\n        while(j < a2.length){\\n            merged[k] = a2[j];\\n            j++;\\n            k++;           \\n        }\\n        // Here we created a merged array\\\\ now we have to find the median\\n        double median = 0.0;\\n         int mid = merged.length / 2;\\n\\n        if(merged.length % 2 == 1){\\n            median= merged[mid];\\n\\n        }else{\\n            median= (merged[mid] + merged[mid - 1]) / 2.0;\\n        }\\n        return median;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1808647,
                "content": [
                    {
                        "username": "simransingh5019",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n       int d = nums1.length+nums2.length;\\n       int arr[] = new int[d];\\n       int i = 0;\\n       int k = 0;\\n       int j = 0;\\n       while(i!=nums1.length && j!= nums2.length)\\n       {\\n           if(nums1[i]>=nums2[j])\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n           }\\n           else\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n           }\\n           k++;\\n       }\\n           while(i!=nums1.length)\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n               k++;\\n           }\\n           while(j!=nums2.length)\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n               k++;\\n           }\\n           double median = 0;\\n          if(d%2==0)\\n          {\\n             median = (arr[(d/2)-1]+arr[d/2])/2;\\n            double a = arr[(d/2)-1];\\n            double b =arr[(d/2)];\\n            median = (a+b)/2;\\n          }\\n          else\\n          {\\n            median = arr[d/2];\\n          }\\n        return median;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "michaeltempesta",
                        "content": "I know this should be hard but it seems super easy.\\n\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        merged = []\\n        # len1 = len(nums1)\\n        # len2 = len(nums2)\\n        # longlist = max(len(nums1), len(nums2))\\n        # print(len1, nums1)\\n        # print(len2, nums2)\\n        # print(longlist)\\n        biglist = nums1 + nums2\\n        sbiglist = sorted(biglist)\\n        # print(sbiglist)\\n        # if len(sbiglist)%2 ==0:\\n        #     median = float((sbiglist[(len(sbiglist)/2)] + sbiglist[(len(sbiglist)/2) -1])/2)\\n        #     return \"{:.5f}\".format(median)\\n        #     # print(median)\\n        # elif len(sbiglist)%2 ==1:\\n        #     median = float(sbiglist[ceil(len(sbiglist)/2)])\\n        #     # print(median)\\n        #     return \"{:.5f}\".format(median)\\n        print(sbiglist)\\n        if len(sbiglist) % 2 == 0:\\n            median = float((sbiglist[len(sbiglist)/2] + sbiglist[(len(sbiglist)/2)-1])/2)\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n        elif len(sbiglist) % 2 == 1:\\n            median = float((sbiglist[ceil(len(sbiglist)/2)-1]))\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n\\nbut I get this runtime error:\\nTypeError: 2.0 is not valid value for the expected return type double\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\\nLine 61 in _driver (Solution.py)\\n    _driver()\\nLine 68 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: must be real number, not str\\nLine 22 in _serialize_float (./python3/__serializer__.py)\\nLine 65 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'double\\')\\nLine 59 in _driver (Solution.py)\\n\\nI don\\'t understand what the difference between a double and a float is and according to the examples ive given up to 5decimals on the floats.\\n\\n"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why Memory Limit Exceeded!"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "This Question shouldn\\'t have the right to be in the Hard section. It\\'s quite easy\\uD83E\\uDEE1"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "[1, 2] and [3, 4] when we merged and sorted these two we get [1, 2, 3, 4] and median of this is (2 + 3)/2 = 2.5 but I\\'m getting 2.0 why??"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution \\n{\\n         public double  findMedianSortedArrays(int[] nums1, int[] nums2)\\n    {\\n        int a =nums1.length;\\n        int b = nums2.length;\\n        int j=0,i=0;\\n        int[] arr = new int[a+b];\\n        for(i=0;i<a;i++)\\n        {\\n           arr[i]=nums1[i];\\n        }\\n        \\n        for(i=a;i<a+b && j<b;i++,j++)\\n        {\\n           arr[i]=nums2[j];\\n        }\\n      double median =0;\\n      int n =arr.length;\\n      if(n%2!=0)\\n      {\\n         int ind = n/2;\\n         \\n         median= arr[ind];\\n      return median;\\n         \\n      }\\n      else{\\n         int ind1= n/2-1;\\n         int ind2=(n/2);\\n         median = (arr[ind1]+arr[ind2]);\\n     return median/2;\\n      }\\n    }\\n}\\n\\n\\nOn online Compiler it is showing correct output \\nBut why it is  showing wrong here \\n"
                    },
                    {
                        "username": "rahul23071992",
                        "content": "Close\\nrahul23071992\\nrahul23071992\\nFeb 19, 2023 11:58\\n\\nDetails\\nSolution\\nPython\\nRuntime\\n59 ms\\nBeats\\n97.1%\\nMemory\\n13.7 MB\\nBeats\\n54.66%\\nClick the distribution chart to view more details\\nNotes\\nWrite your notes here\\nRelated Tags\\nSelect tags\\n0/5\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        joinlist=nums1 +nums2\\n        sorted_list=sorted(joinlist)\\n        if len(sorted_list)%2!=0:\\n            median=sorted_list[(len(sorted_list)//2)]\\n\\n        else:\\n            a=sorted_list[(len(sorted_list)//2)-1]\\n            b=sorted_list[(len(sorted_list)//2)]\\n            print(a,b)\\n            median=float((a+b))/2\\n        return median\\n            "
                    },
                    {
                        "username": "PawanSingh563",
                        "content": " if(x%2==0){\n           \n          double  y=((nums3[(x/2)-1]+nums3[((x/2)+1)-1])/2);\n            \n            return y;\n            \n        }\n        else{\n            double y=nums3[((x+1)/2)-1];\n            return y;\n        }\n\n\nhii, everyone  i am beginner for this platfrom , actually in this concept case 1  is right but case 2  is not right  \n\n any one can help me ????"
                    },
                    {
                        "username": "truongsoi",
                        "content": "I saw a lot of accepted submissions but none of them do checking the pre-defined constrains as mine? Does the auto acceptance test miss these test cases?"
                    },
                    {
                        "username": "priyanshu_3108",
                        "content": "Java Easy solution\\n`class Solution {\\n    public double findMedianSortedArrays(int[] a1, int[] a2) {\\n        int len = a1.length + a2.length;\\n        int [] merged = new int[len];\\n        int i = 0 , j = 0, k = 0;\\n\\n        while( i < a1.length && j < a2.length){\\n            if(a1[i] < a2[j]){\\n                merged[k] = a1[i];\\n                i++;\\n                k++;\\n            }else{\\n                merged[k] = a2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n\\n        while(i < a1.length){\\n              merged[k] = a1[i];\\n              i++;\\n              k++;           \\n        }\\n        while(j < a2.length){\\n            merged[k] = a2[j];\\n            j++;\\n            k++;           \\n        }\\n        // Here we created a merged array\\\\ now we have to find the median\\n        double median = 0.0;\\n         int mid = merged.length / 2;\\n\\n        if(merged.length % 2 == 1){\\n            median= merged[mid];\\n\\n        }else{\\n            median= (merged[mid] + merged[mid - 1]) / 2.0;\\n        }\\n        return median;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1808409,
                "content": [
                    {
                        "username": "simransingh5019",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n       int d = nums1.length+nums2.length;\\n       int arr[] = new int[d];\\n       int i = 0;\\n       int k = 0;\\n       int j = 0;\\n       while(i!=nums1.length && j!= nums2.length)\\n       {\\n           if(nums1[i]>=nums2[j])\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n           }\\n           else\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n           }\\n           k++;\\n       }\\n           while(i!=nums1.length)\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n               k++;\\n           }\\n           while(j!=nums2.length)\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n               k++;\\n           }\\n           double median = 0;\\n          if(d%2==0)\\n          {\\n             median = (arr[(d/2)-1]+arr[d/2])/2;\\n            double a = arr[(d/2)-1];\\n            double b =arr[(d/2)];\\n            median = (a+b)/2;\\n          }\\n          else\\n          {\\n            median = arr[d/2];\\n          }\\n        return median;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "michaeltempesta",
                        "content": "I know this should be hard but it seems super easy.\\n\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        merged = []\\n        # len1 = len(nums1)\\n        # len2 = len(nums2)\\n        # longlist = max(len(nums1), len(nums2))\\n        # print(len1, nums1)\\n        # print(len2, nums2)\\n        # print(longlist)\\n        biglist = nums1 + nums2\\n        sbiglist = sorted(biglist)\\n        # print(sbiglist)\\n        # if len(sbiglist)%2 ==0:\\n        #     median = float((sbiglist[(len(sbiglist)/2)] + sbiglist[(len(sbiglist)/2) -1])/2)\\n        #     return \"{:.5f}\".format(median)\\n        #     # print(median)\\n        # elif len(sbiglist)%2 ==1:\\n        #     median = float(sbiglist[ceil(len(sbiglist)/2)])\\n        #     # print(median)\\n        #     return \"{:.5f}\".format(median)\\n        print(sbiglist)\\n        if len(sbiglist) % 2 == 0:\\n            median = float((sbiglist[len(sbiglist)/2] + sbiglist[(len(sbiglist)/2)-1])/2)\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n        elif len(sbiglist) % 2 == 1:\\n            median = float((sbiglist[ceil(len(sbiglist)/2)-1]))\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n\\nbut I get this runtime error:\\nTypeError: 2.0 is not valid value for the expected return type double\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\\nLine 61 in _driver (Solution.py)\\n    _driver()\\nLine 68 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: must be real number, not str\\nLine 22 in _serialize_float (./python3/__serializer__.py)\\nLine 65 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'double\\')\\nLine 59 in _driver (Solution.py)\\n\\nI don\\'t understand what the difference between a double and a float is and according to the examples ive given up to 5decimals on the floats.\\n\\n"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why Memory Limit Exceeded!"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "This Question shouldn\\'t have the right to be in the Hard section. It\\'s quite easy\\uD83E\\uDEE1"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "[1, 2] and [3, 4] when we merged and sorted these two we get [1, 2, 3, 4] and median of this is (2 + 3)/2 = 2.5 but I\\'m getting 2.0 why??"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution \\n{\\n         public double  findMedianSortedArrays(int[] nums1, int[] nums2)\\n    {\\n        int a =nums1.length;\\n        int b = nums2.length;\\n        int j=0,i=0;\\n        int[] arr = new int[a+b];\\n        for(i=0;i<a;i++)\\n        {\\n           arr[i]=nums1[i];\\n        }\\n        \\n        for(i=a;i<a+b && j<b;i++,j++)\\n        {\\n           arr[i]=nums2[j];\\n        }\\n      double median =0;\\n      int n =arr.length;\\n      if(n%2!=0)\\n      {\\n         int ind = n/2;\\n         \\n         median= arr[ind];\\n      return median;\\n         \\n      }\\n      else{\\n         int ind1= n/2-1;\\n         int ind2=(n/2);\\n         median = (arr[ind1]+arr[ind2]);\\n     return median/2;\\n      }\\n    }\\n}\\n\\n\\nOn online Compiler it is showing correct output \\nBut why it is  showing wrong here \\n"
                    },
                    {
                        "username": "rahul23071992",
                        "content": "Close\\nrahul23071992\\nrahul23071992\\nFeb 19, 2023 11:58\\n\\nDetails\\nSolution\\nPython\\nRuntime\\n59 ms\\nBeats\\n97.1%\\nMemory\\n13.7 MB\\nBeats\\n54.66%\\nClick the distribution chart to view more details\\nNotes\\nWrite your notes here\\nRelated Tags\\nSelect tags\\n0/5\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        joinlist=nums1 +nums2\\n        sorted_list=sorted(joinlist)\\n        if len(sorted_list)%2!=0:\\n            median=sorted_list[(len(sorted_list)//2)]\\n\\n        else:\\n            a=sorted_list[(len(sorted_list)//2)-1]\\n            b=sorted_list[(len(sorted_list)//2)]\\n            print(a,b)\\n            median=float((a+b))/2\\n        return median\\n            "
                    },
                    {
                        "username": "PawanSingh563",
                        "content": " if(x%2==0){\n           \n          double  y=((nums3[(x/2)-1]+nums3[((x/2)+1)-1])/2);\n            \n            return y;\n            \n        }\n        else{\n            double y=nums3[((x+1)/2)-1];\n            return y;\n        }\n\n\nhii, everyone  i am beginner for this platfrom , actually in this concept case 1  is right but case 2  is not right  \n\n any one can help me ????"
                    },
                    {
                        "username": "truongsoi",
                        "content": "I saw a lot of accepted submissions but none of them do checking the pre-defined constrains as mine? Does the auto acceptance test miss these test cases?"
                    },
                    {
                        "username": "priyanshu_3108",
                        "content": "Java Easy solution\\n`class Solution {\\n    public double findMedianSortedArrays(int[] a1, int[] a2) {\\n        int len = a1.length + a2.length;\\n        int [] merged = new int[len];\\n        int i = 0 , j = 0, k = 0;\\n\\n        while( i < a1.length && j < a2.length){\\n            if(a1[i] < a2[j]){\\n                merged[k] = a1[i];\\n                i++;\\n                k++;\\n            }else{\\n                merged[k] = a2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n\\n        while(i < a1.length){\\n              merged[k] = a1[i];\\n              i++;\\n              k++;           \\n        }\\n        while(j < a2.length){\\n            merged[k] = a2[j];\\n            j++;\\n            k++;           \\n        }\\n        // Here we created a merged array\\\\ now we have to find the median\\n        double median = 0.0;\\n         int mid = merged.length / 2;\\n\\n        if(merged.length % 2 == 1){\\n            median= merged[mid];\\n\\n        }else{\\n            median= (merged[mid] + merged[mid - 1]) / 2.0;\\n        }\\n        return median;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1808289,
                "content": [
                    {
                        "username": "simransingh5019",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n       int d = nums1.length+nums2.length;\\n       int arr[] = new int[d];\\n       int i = 0;\\n       int k = 0;\\n       int j = 0;\\n       while(i!=nums1.length && j!= nums2.length)\\n       {\\n           if(nums1[i]>=nums2[j])\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n           }\\n           else\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n           }\\n           k++;\\n       }\\n           while(i!=nums1.length)\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n               k++;\\n           }\\n           while(j!=nums2.length)\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n               k++;\\n           }\\n           double median = 0;\\n          if(d%2==0)\\n          {\\n             median = (arr[(d/2)-1]+arr[d/2])/2;\\n            double a = arr[(d/2)-1];\\n            double b =arr[(d/2)];\\n            median = (a+b)/2;\\n          }\\n          else\\n          {\\n            median = arr[d/2];\\n          }\\n        return median;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "michaeltempesta",
                        "content": "I know this should be hard but it seems super easy.\\n\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        merged = []\\n        # len1 = len(nums1)\\n        # len2 = len(nums2)\\n        # longlist = max(len(nums1), len(nums2))\\n        # print(len1, nums1)\\n        # print(len2, nums2)\\n        # print(longlist)\\n        biglist = nums1 + nums2\\n        sbiglist = sorted(biglist)\\n        # print(sbiglist)\\n        # if len(sbiglist)%2 ==0:\\n        #     median = float((sbiglist[(len(sbiglist)/2)] + sbiglist[(len(sbiglist)/2) -1])/2)\\n        #     return \"{:.5f}\".format(median)\\n        #     # print(median)\\n        # elif len(sbiglist)%2 ==1:\\n        #     median = float(sbiglist[ceil(len(sbiglist)/2)])\\n        #     # print(median)\\n        #     return \"{:.5f}\".format(median)\\n        print(sbiglist)\\n        if len(sbiglist) % 2 == 0:\\n            median = float((sbiglist[len(sbiglist)/2] + sbiglist[(len(sbiglist)/2)-1])/2)\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n        elif len(sbiglist) % 2 == 1:\\n            median = float((sbiglist[ceil(len(sbiglist)/2)-1]))\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n\\nbut I get this runtime error:\\nTypeError: 2.0 is not valid value for the expected return type double\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\\nLine 61 in _driver (Solution.py)\\n    _driver()\\nLine 68 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: must be real number, not str\\nLine 22 in _serialize_float (./python3/__serializer__.py)\\nLine 65 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'double\\')\\nLine 59 in _driver (Solution.py)\\n\\nI don\\'t understand what the difference between a double and a float is and according to the examples ive given up to 5decimals on the floats.\\n\\n"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why Memory Limit Exceeded!"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "This Question shouldn\\'t have the right to be in the Hard section. It\\'s quite easy\\uD83E\\uDEE1"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "[1, 2] and [3, 4] when we merged and sorted these two we get [1, 2, 3, 4] and median of this is (2 + 3)/2 = 2.5 but I\\'m getting 2.0 why??"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution \\n{\\n         public double  findMedianSortedArrays(int[] nums1, int[] nums2)\\n    {\\n        int a =nums1.length;\\n        int b = nums2.length;\\n        int j=0,i=0;\\n        int[] arr = new int[a+b];\\n        for(i=0;i<a;i++)\\n        {\\n           arr[i]=nums1[i];\\n        }\\n        \\n        for(i=a;i<a+b && j<b;i++,j++)\\n        {\\n           arr[i]=nums2[j];\\n        }\\n      double median =0;\\n      int n =arr.length;\\n      if(n%2!=0)\\n      {\\n         int ind = n/2;\\n         \\n         median= arr[ind];\\n      return median;\\n         \\n      }\\n      else{\\n         int ind1= n/2-1;\\n         int ind2=(n/2);\\n         median = (arr[ind1]+arr[ind2]);\\n     return median/2;\\n      }\\n    }\\n}\\n\\n\\nOn online Compiler it is showing correct output \\nBut why it is  showing wrong here \\n"
                    },
                    {
                        "username": "rahul23071992",
                        "content": "Close\\nrahul23071992\\nrahul23071992\\nFeb 19, 2023 11:58\\n\\nDetails\\nSolution\\nPython\\nRuntime\\n59 ms\\nBeats\\n97.1%\\nMemory\\n13.7 MB\\nBeats\\n54.66%\\nClick the distribution chart to view more details\\nNotes\\nWrite your notes here\\nRelated Tags\\nSelect tags\\n0/5\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        joinlist=nums1 +nums2\\n        sorted_list=sorted(joinlist)\\n        if len(sorted_list)%2!=0:\\n            median=sorted_list[(len(sorted_list)//2)]\\n\\n        else:\\n            a=sorted_list[(len(sorted_list)//2)-1]\\n            b=sorted_list[(len(sorted_list)//2)]\\n            print(a,b)\\n            median=float((a+b))/2\\n        return median\\n            "
                    },
                    {
                        "username": "PawanSingh563",
                        "content": " if(x%2==0){\n           \n          double  y=((nums3[(x/2)-1]+nums3[((x/2)+1)-1])/2);\n            \n            return y;\n            \n        }\n        else{\n            double y=nums3[((x+1)/2)-1];\n            return y;\n        }\n\n\nhii, everyone  i am beginner for this platfrom , actually in this concept case 1  is right but case 2  is not right  \n\n any one can help me ????"
                    },
                    {
                        "username": "truongsoi",
                        "content": "I saw a lot of accepted submissions but none of them do checking the pre-defined constrains as mine? Does the auto acceptance test miss these test cases?"
                    },
                    {
                        "username": "priyanshu_3108",
                        "content": "Java Easy solution\\n`class Solution {\\n    public double findMedianSortedArrays(int[] a1, int[] a2) {\\n        int len = a1.length + a2.length;\\n        int [] merged = new int[len];\\n        int i = 0 , j = 0, k = 0;\\n\\n        while( i < a1.length && j < a2.length){\\n            if(a1[i] < a2[j]){\\n                merged[k] = a1[i];\\n                i++;\\n                k++;\\n            }else{\\n                merged[k] = a2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n\\n        while(i < a1.length){\\n              merged[k] = a1[i];\\n              i++;\\n              k++;           \\n        }\\n        while(j < a2.length){\\n            merged[k] = a2[j];\\n            j++;\\n            k++;           \\n        }\\n        // Here we created a merged array\\\\ now we have to find the median\\n        double median = 0.0;\\n         int mid = merged.length / 2;\\n\\n        if(merged.length % 2 == 1){\\n            median= merged[mid];\\n\\n        }else{\\n            median= (merged[mid] + merged[mid - 1]) / 2.0;\\n        }\\n        return median;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1807971,
                "content": [
                    {
                        "username": "simransingh5019",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n       int d = nums1.length+nums2.length;\\n       int arr[] = new int[d];\\n       int i = 0;\\n       int k = 0;\\n       int j = 0;\\n       while(i!=nums1.length && j!= nums2.length)\\n       {\\n           if(nums1[i]>=nums2[j])\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n           }\\n           else\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n           }\\n           k++;\\n       }\\n           while(i!=nums1.length)\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n               k++;\\n           }\\n           while(j!=nums2.length)\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n               k++;\\n           }\\n           double median = 0;\\n          if(d%2==0)\\n          {\\n             median = (arr[(d/2)-1]+arr[d/2])/2;\\n            double a = arr[(d/2)-1];\\n            double b =arr[(d/2)];\\n            median = (a+b)/2;\\n          }\\n          else\\n          {\\n            median = arr[d/2];\\n          }\\n        return median;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "michaeltempesta",
                        "content": "I know this should be hard but it seems super easy.\\n\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        merged = []\\n        # len1 = len(nums1)\\n        # len2 = len(nums2)\\n        # longlist = max(len(nums1), len(nums2))\\n        # print(len1, nums1)\\n        # print(len2, nums2)\\n        # print(longlist)\\n        biglist = nums1 + nums2\\n        sbiglist = sorted(biglist)\\n        # print(sbiglist)\\n        # if len(sbiglist)%2 ==0:\\n        #     median = float((sbiglist[(len(sbiglist)/2)] + sbiglist[(len(sbiglist)/2) -1])/2)\\n        #     return \"{:.5f}\".format(median)\\n        #     # print(median)\\n        # elif len(sbiglist)%2 ==1:\\n        #     median = float(sbiglist[ceil(len(sbiglist)/2)])\\n        #     # print(median)\\n        #     return \"{:.5f}\".format(median)\\n        print(sbiglist)\\n        if len(sbiglist) % 2 == 0:\\n            median = float((sbiglist[len(sbiglist)/2] + sbiglist[(len(sbiglist)/2)-1])/2)\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n        elif len(sbiglist) % 2 == 1:\\n            median = float((sbiglist[ceil(len(sbiglist)/2)-1]))\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n\\nbut I get this runtime error:\\nTypeError: 2.0 is not valid value for the expected return type double\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\\nLine 61 in _driver (Solution.py)\\n    _driver()\\nLine 68 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: must be real number, not str\\nLine 22 in _serialize_float (./python3/__serializer__.py)\\nLine 65 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'double\\')\\nLine 59 in _driver (Solution.py)\\n\\nI don\\'t understand what the difference between a double and a float is and according to the examples ive given up to 5decimals on the floats.\\n\\n"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why Memory Limit Exceeded!"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "This Question shouldn\\'t have the right to be in the Hard section. It\\'s quite easy\\uD83E\\uDEE1"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "[1, 2] and [3, 4] when we merged and sorted these two we get [1, 2, 3, 4] and median of this is (2 + 3)/2 = 2.5 but I\\'m getting 2.0 why??"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution \\n{\\n         public double  findMedianSortedArrays(int[] nums1, int[] nums2)\\n    {\\n        int a =nums1.length;\\n        int b = nums2.length;\\n        int j=0,i=0;\\n        int[] arr = new int[a+b];\\n        for(i=0;i<a;i++)\\n        {\\n           arr[i]=nums1[i];\\n        }\\n        \\n        for(i=a;i<a+b && j<b;i++,j++)\\n        {\\n           arr[i]=nums2[j];\\n        }\\n      double median =0;\\n      int n =arr.length;\\n      if(n%2!=0)\\n      {\\n         int ind = n/2;\\n         \\n         median= arr[ind];\\n      return median;\\n         \\n      }\\n      else{\\n         int ind1= n/2-1;\\n         int ind2=(n/2);\\n         median = (arr[ind1]+arr[ind2]);\\n     return median/2;\\n      }\\n    }\\n}\\n\\n\\nOn online Compiler it is showing correct output \\nBut why it is  showing wrong here \\n"
                    },
                    {
                        "username": "rahul23071992",
                        "content": "Close\\nrahul23071992\\nrahul23071992\\nFeb 19, 2023 11:58\\n\\nDetails\\nSolution\\nPython\\nRuntime\\n59 ms\\nBeats\\n97.1%\\nMemory\\n13.7 MB\\nBeats\\n54.66%\\nClick the distribution chart to view more details\\nNotes\\nWrite your notes here\\nRelated Tags\\nSelect tags\\n0/5\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        joinlist=nums1 +nums2\\n        sorted_list=sorted(joinlist)\\n        if len(sorted_list)%2!=0:\\n            median=sorted_list[(len(sorted_list)//2)]\\n\\n        else:\\n            a=sorted_list[(len(sorted_list)//2)-1]\\n            b=sorted_list[(len(sorted_list)//2)]\\n            print(a,b)\\n            median=float((a+b))/2\\n        return median\\n            "
                    },
                    {
                        "username": "PawanSingh563",
                        "content": " if(x%2==0){\n           \n          double  y=((nums3[(x/2)-1]+nums3[((x/2)+1)-1])/2);\n            \n            return y;\n            \n        }\n        else{\n            double y=nums3[((x+1)/2)-1];\n            return y;\n        }\n\n\nhii, everyone  i am beginner for this platfrom , actually in this concept case 1  is right but case 2  is not right  \n\n any one can help me ????"
                    },
                    {
                        "username": "truongsoi",
                        "content": "I saw a lot of accepted submissions but none of them do checking the pre-defined constrains as mine? Does the auto acceptance test miss these test cases?"
                    },
                    {
                        "username": "priyanshu_3108",
                        "content": "Java Easy solution\\n`class Solution {\\n    public double findMedianSortedArrays(int[] a1, int[] a2) {\\n        int len = a1.length + a2.length;\\n        int [] merged = new int[len];\\n        int i = 0 , j = 0, k = 0;\\n\\n        while( i < a1.length && j < a2.length){\\n            if(a1[i] < a2[j]){\\n                merged[k] = a1[i];\\n                i++;\\n                k++;\\n            }else{\\n                merged[k] = a2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n\\n        while(i < a1.length){\\n              merged[k] = a1[i];\\n              i++;\\n              k++;           \\n        }\\n        while(j < a2.length){\\n            merged[k] = a2[j];\\n            j++;\\n            k++;           \\n        }\\n        // Here we created a merged array\\\\ now we have to find the median\\n        double median = 0.0;\\n         int mid = merged.length / 2;\\n\\n        if(merged.length % 2 == 1){\\n            median= merged[mid];\\n\\n        }else{\\n            median= (merged[mid] + merged[mid - 1]) / 2.0;\\n        }\\n        return median;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1806680,
                "content": [
                    {
                        "username": "simransingh5019",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n       int d = nums1.length+nums2.length;\\n       int arr[] = new int[d];\\n       int i = 0;\\n       int k = 0;\\n       int j = 0;\\n       while(i!=nums1.length && j!= nums2.length)\\n       {\\n           if(nums1[i]>=nums2[j])\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n           }\\n           else\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n           }\\n           k++;\\n       }\\n           while(i!=nums1.length)\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n               k++;\\n           }\\n           while(j!=nums2.length)\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n               k++;\\n           }\\n           double median = 0;\\n          if(d%2==0)\\n          {\\n             median = (arr[(d/2)-1]+arr[d/2])/2;\\n            double a = arr[(d/2)-1];\\n            double b =arr[(d/2)];\\n            median = (a+b)/2;\\n          }\\n          else\\n          {\\n            median = arr[d/2];\\n          }\\n        return median;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "michaeltempesta",
                        "content": "I know this should be hard but it seems super easy.\\n\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        merged = []\\n        # len1 = len(nums1)\\n        # len2 = len(nums2)\\n        # longlist = max(len(nums1), len(nums2))\\n        # print(len1, nums1)\\n        # print(len2, nums2)\\n        # print(longlist)\\n        biglist = nums1 + nums2\\n        sbiglist = sorted(biglist)\\n        # print(sbiglist)\\n        # if len(sbiglist)%2 ==0:\\n        #     median = float((sbiglist[(len(sbiglist)/2)] + sbiglist[(len(sbiglist)/2) -1])/2)\\n        #     return \"{:.5f}\".format(median)\\n        #     # print(median)\\n        # elif len(sbiglist)%2 ==1:\\n        #     median = float(sbiglist[ceil(len(sbiglist)/2)])\\n        #     # print(median)\\n        #     return \"{:.5f}\".format(median)\\n        print(sbiglist)\\n        if len(sbiglist) % 2 == 0:\\n            median = float((sbiglist[len(sbiglist)/2] + sbiglist[(len(sbiglist)/2)-1])/2)\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n        elif len(sbiglist) % 2 == 1:\\n            median = float((sbiglist[ceil(len(sbiglist)/2)-1]))\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n\\nbut I get this runtime error:\\nTypeError: 2.0 is not valid value for the expected return type double\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\\nLine 61 in _driver (Solution.py)\\n    _driver()\\nLine 68 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: must be real number, not str\\nLine 22 in _serialize_float (./python3/__serializer__.py)\\nLine 65 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'double\\')\\nLine 59 in _driver (Solution.py)\\n\\nI don\\'t understand what the difference between a double and a float is and according to the examples ive given up to 5decimals on the floats.\\n\\n"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why Memory Limit Exceeded!"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "This Question shouldn\\'t have the right to be in the Hard section. It\\'s quite easy\\uD83E\\uDEE1"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "[1, 2] and [3, 4] when we merged and sorted these two we get [1, 2, 3, 4] and median of this is (2 + 3)/2 = 2.5 but I\\'m getting 2.0 why??"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution \\n{\\n         public double  findMedianSortedArrays(int[] nums1, int[] nums2)\\n    {\\n        int a =nums1.length;\\n        int b = nums2.length;\\n        int j=0,i=0;\\n        int[] arr = new int[a+b];\\n        for(i=0;i<a;i++)\\n        {\\n           arr[i]=nums1[i];\\n        }\\n        \\n        for(i=a;i<a+b && j<b;i++,j++)\\n        {\\n           arr[i]=nums2[j];\\n        }\\n      double median =0;\\n      int n =arr.length;\\n      if(n%2!=0)\\n      {\\n         int ind = n/2;\\n         \\n         median= arr[ind];\\n      return median;\\n         \\n      }\\n      else{\\n         int ind1= n/2-1;\\n         int ind2=(n/2);\\n         median = (arr[ind1]+arr[ind2]);\\n     return median/2;\\n      }\\n    }\\n}\\n\\n\\nOn online Compiler it is showing correct output \\nBut why it is  showing wrong here \\n"
                    },
                    {
                        "username": "rahul23071992",
                        "content": "Close\\nrahul23071992\\nrahul23071992\\nFeb 19, 2023 11:58\\n\\nDetails\\nSolution\\nPython\\nRuntime\\n59 ms\\nBeats\\n97.1%\\nMemory\\n13.7 MB\\nBeats\\n54.66%\\nClick the distribution chart to view more details\\nNotes\\nWrite your notes here\\nRelated Tags\\nSelect tags\\n0/5\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        joinlist=nums1 +nums2\\n        sorted_list=sorted(joinlist)\\n        if len(sorted_list)%2!=0:\\n            median=sorted_list[(len(sorted_list)//2)]\\n\\n        else:\\n            a=sorted_list[(len(sorted_list)//2)-1]\\n            b=sorted_list[(len(sorted_list)//2)]\\n            print(a,b)\\n            median=float((a+b))/2\\n        return median\\n            "
                    },
                    {
                        "username": "PawanSingh563",
                        "content": " if(x%2==0){\n           \n          double  y=((nums3[(x/2)-1]+nums3[((x/2)+1)-1])/2);\n            \n            return y;\n            \n        }\n        else{\n            double y=nums3[((x+1)/2)-1];\n            return y;\n        }\n\n\nhii, everyone  i am beginner for this platfrom , actually in this concept case 1  is right but case 2  is not right  \n\n any one can help me ????"
                    },
                    {
                        "username": "truongsoi",
                        "content": "I saw a lot of accepted submissions but none of them do checking the pre-defined constrains as mine? Does the auto acceptance test miss these test cases?"
                    },
                    {
                        "username": "priyanshu_3108",
                        "content": "Java Easy solution\\n`class Solution {\\n    public double findMedianSortedArrays(int[] a1, int[] a2) {\\n        int len = a1.length + a2.length;\\n        int [] merged = new int[len];\\n        int i = 0 , j = 0, k = 0;\\n\\n        while( i < a1.length && j < a2.length){\\n            if(a1[i] < a2[j]){\\n                merged[k] = a1[i];\\n                i++;\\n                k++;\\n            }else{\\n                merged[k] = a2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n\\n        while(i < a1.length){\\n              merged[k] = a1[i];\\n              i++;\\n              k++;           \\n        }\\n        while(j < a2.length){\\n            merged[k] = a2[j];\\n            j++;\\n            k++;           \\n        }\\n        // Here we created a merged array\\\\ now we have to find the median\\n        double median = 0.0;\\n         int mid = merged.length / 2;\\n\\n        if(merged.length % 2 == 1){\\n            median= merged[mid];\\n\\n        }else{\\n            median= (merged[mid] + merged[mid - 1]) / 2.0;\\n        }\\n        return median;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1805514,
                "content": [
                    {
                        "username": "simransingh5019",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n       int d = nums1.length+nums2.length;\\n       int arr[] = new int[d];\\n       int i = 0;\\n       int k = 0;\\n       int j = 0;\\n       while(i!=nums1.length && j!= nums2.length)\\n       {\\n           if(nums1[i]>=nums2[j])\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n           }\\n           else\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n           }\\n           k++;\\n       }\\n           while(i!=nums1.length)\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n               k++;\\n           }\\n           while(j!=nums2.length)\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n               k++;\\n           }\\n           double median = 0;\\n          if(d%2==0)\\n          {\\n             median = (arr[(d/2)-1]+arr[d/2])/2;\\n            double a = arr[(d/2)-1];\\n            double b =arr[(d/2)];\\n            median = (a+b)/2;\\n          }\\n          else\\n          {\\n            median = arr[d/2];\\n          }\\n        return median;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "michaeltempesta",
                        "content": "I know this should be hard but it seems super easy.\\n\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        merged = []\\n        # len1 = len(nums1)\\n        # len2 = len(nums2)\\n        # longlist = max(len(nums1), len(nums2))\\n        # print(len1, nums1)\\n        # print(len2, nums2)\\n        # print(longlist)\\n        biglist = nums1 + nums2\\n        sbiglist = sorted(biglist)\\n        # print(sbiglist)\\n        # if len(sbiglist)%2 ==0:\\n        #     median = float((sbiglist[(len(sbiglist)/2)] + sbiglist[(len(sbiglist)/2) -1])/2)\\n        #     return \"{:.5f}\".format(median)\\n        #     # print(median)\\n        # elif len(sbiglist)%2 ==1:\\n        #     median = float(sbiglist[ceil(len(sbiglist)/2)])\\n        #     # print(median)\\n        #     return \"{:.5f}\".format(median)\\n        print(sbiglist)\\n        if len(sbiglist) % 2 == 0:\\n            median = float((sbiglist[len(sbiglist)/2] + sbiglist[(len(sbiglist)/2)-1])/2)\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n        elif len(sbiglist) % 2 == 1:\\n            median = float((sbiglist[ceil(len(sbiglist)/2)-1]))\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n\\nbut I get this runtime error:\\nTypeError: 2.0 is not valid value for the expected return type double\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\\nLine 61 in _driver (Solution.py)\\n    _driver()\\nLine 68 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: must be real number, not str\\nLine 22 in _serialize_float (./python3/__serializer__.py)\\nLine 65 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'double\\')\\nLine 59 in _driver (Solution.py)\\n\\nI don\\'t understand what the difference between a double and a float is and according to the examples ive given up to 5decimals on the floats.\\n\\n"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why Memory Limit Exceeded!"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "This Question shouldn\\'t have the right to be in the Hard section. It\\'s quite easy\\uD83E\\uDEE1"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "[1, 2] and [3, 4] when we merged and sorted these two we get [1, 2, 3, 4] and median of this is (2 + 3)/2 = 2.5 but I\\'m getting 2.0 why??"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution \\n{\\n         public double  findMedianSortedArrays(int[] nums1, int[] nums2)\\n    {\\n        int a =nums1.length;\\n        int b = nums2.length;\\n        int j=0,i=0;\\n        int[] arr = new int[a+b];\\n        for(i=0;i<a;i++)\\n        {\\n           arr[i]=nums1[i];\\n        }\\n        \\n        for(i=a;i<a+b && j<b;i++,j++)\\n        {\\n           arr[i]=nums2[j];\\n        }\\n      double median =0;\\n      int n =arr.length;\\n      if(n%2!=0)\\n      {\\n         int ind = n/2;\\n         \\n         median= arr[ind];\\n      return median;\\n         \\n      }\\n      else{\\n         int ind1= n/2-1;\\n         int ind2=(n/2);\\n         median = (arr[ind1]+arr[ind2]);\\n     return median/2;\\n      }\\n    }\\n}\\n\\n\\nOn online Compiler it is showing correct output \\nBut why it is  showing wrong here \\n"
                    },
                    {
                        "username": "rahul23071992",
                        "content": "Close\\nrahul23071992\\nrahul23071992\\nFeb 19, 2023 11:58\\n\\nDetails\\nSolution\\nPython\\nRuntime\\n59 ms\\nBeats\\n97.1%\\nMemory\\n13.7 MB\\nBeats\\n54.66%\\nClick the distribution chart to view more details\\nNotes\\nWrite your notes here\\nRelated Tags\\nSelect tags\\n0/5\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        joinlist=nums1 +nums2\\n        sorted_list=sorted(joinlist)\\n        if len(sorted_list)%2!=0:\\n            median=sorted_list[(len(sorted_list)//2)]\\n\\n        else:\\n            a=sorted_list[(len(sorted_list)//2)-1]\\n            b=sorted_list[(len(sorted_list)//2)]\\n            print(a,b)\\n            median=float((a+b))/2\\n        return median\\n            "
                    },
                    {
                        "username": "PawanSingh563",
                        "content": " if(x%2==0){\n           \n          double  y=((nums3[(x/2)-1]+nums3[((x/2)+1)-1])/2);\n            \n            return y;\n            \n        }\n        else{\n            double y=nums3[((x+1)/2)-1];\n            return y;\n        }\n\n\nhii, everyone  i am beginner for this platfrom , actually in this concept case 1  is right but case 2  is not right  \n\n any one can help me ????"
                    },
                    {
                        "username": "truongsoi",
                        "content": "I saw a lot of accepted submissions but none of them do checking the pre-defined constrains as mine? Does the auto acceptance test miss these test cases?"
                    },
                    {
                        "username": "priyanshu_3108",
                        "content": "Java Easy solution\\n`class Solution {\\n    public double findMedianSortedArrays(int[] a1, int[] a2) {\\n        int len = a1.length + a2.length;\\n        int [] merged = new int[len];\\n        int i = 0 , j = 0, k = 0;\\n\\n        while( i < a1.length && j < a2.length){\\n            if(a1[i] < a2[j]){\\n                merged[k] = a1[i];\\n                i++;\\n                k++;\\n            }else{\\n                merged[k] = a2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n\\n        while(i < a1.length){\\n              merged[k] = a1[i];\\n              i++;\\n              k++;           \\n        }\\n        while(j < a2.length){\\n            merged[k] = a2[j];\\n            j++;\\n            k++;           \\n        }\\n        // Here we created a merged array\\\\ now we have to find the median\\n        double median = 0.0;\\n         int mid = merged.length / 2;\\n\\n        if(merged.length % 2 == 1){\\n            median= merged[mid];\\n\\n        }else{\\n            median= (merged[mid] + merged[mid - 1]) / 2.0;\\n        }\\n        return median;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1805218,
                "content": [
                    {
                        "username": "simransingh5019",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n       int d = nums1.length+nums2.length;\\n       int arr[] = new int[d];\\n       int i = 0;\\n       int k = 0;\\n       int j = 0;\\n       while(i!=nums1.length && j!= nums2.length)\\n       {\\n           if(nums1[i]>=nums2[j])\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n           }\\n           else\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n           }\\n           k++;\\n       }\\n           while(i!=nums1.length)\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n               k++;\\n           }\\n           while(j!=nums2.length)\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n               k++;\\n           }\\n           double median = 0;\\n          if(d%2==0)\\n          {\\n             median = (arr[(d/2)-1]+arr[d/2])/2;\\n            double a = arr[(d/2)-1];\\n            double b =arr[(d/2)];\\n            median = (a+b)/2;\\n          }\\n          else\\n          {\\n            median = arr[d/2];\\n          }\\n        return median;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "michaeltempesta",
                        "content": "I know this should be hard but it seems super easy.\\n\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        merged = []\\n        # len1 = len(nums1)\\n        # len2 = len(nums2)\\n        # longlist = max(len(nums1), len(nums2))\\n        # print(len1, nums1)\\n        # print(len2, nums2)\\n        # print(longlist)\\n        biglist = nums1 + nums2\\n        sbiglist = sorted(biglist)\\n        # print(sbiglist)\\n        # if len(sbiglist)%2 ==0:\\n        #     median = float((sbiglist[(len(sbiglist)/2)] + sbiglist[(len(sbiglist)/2) -1])/2)\\n        #     return \"{:.5f}\".format(median)\\n        #     # print(median)\\n        # elif len(sbiglist)%2 ==1:\\n        #     median = float(sbiglist[ceil(len(sbiglist)/2)])\\n        #     # print(median)\\n        #     return \"{:.5f}\".format(median)\\n        print(sbiglist)\\n        if len(sbiglist) % 2 == 0:\\n            median = float((sbiglist[len(sbiglist)/2] + sbiglist[(len(sbiglist)/2)-1])/2)\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n        elif len(sbiglist) % 2 == 1:\\n            median = float((sbiglist[ceil(len(sbiglist)/2)-1]))\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n\\nbut I get this runtime error:\\nTypeError: 2.0 is not valid value for the expected return type double\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\\nLine 61 in _driver (Solution.py)\\n    _driver()\\nLine 68 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: must be real number, not str\\nLine 22 in _serialize_float (./python3/__serializer__.py)\\nLine 65 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'double\\')\\nLine 59 in _driver (Solution.py)\\n\\nI don\\'t understand what the difference between a double and a float is and according to the examples ive given up to 5decimals on the floats.\\n\\n"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why Memory Limit Exceeded!"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "This Question shouldn\\'t have the right to be in the Hard section. It\\'s quite easy\\uD83E\\uDEE1"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "[1, 2] and [3, 4] when we merged and sorted these two we get [1, 2, 3, 4] and median of this is (2 + 3)/2 = 2.5 but I\\'m getting 2.0 why??"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution \\n{\\n         public double  findMedianSortedArrays(int[] nums1, int[] nums2)\\n    {\\n        int a =nums1.length;\\n        int b = nums2.length;\\n        int j=0,i=0;\\n        int[] arr = new int[a+b];\\n        for(i=0;i<a;i++)\\n        {\\n           arr[i]=nums1[i];\\n        }\\n        \\n        for(i=a;i<a+b && j<b;i++,j++)\\n        {\\n           arr[i]=nums2[j];\\n        }\\n      double median =0;\\n      int n =arr.length;\\n      if(n%2!=0)\\n      {\\n         int ind = n/2;\\n         \\n         median= arr[ind];\\n      return median;\\n         \\n      }\\n      else{\\n         int ind1= n/2-1;\\n         int ind2=(n/2);\\n         median = (arr[ind1]+arr[ind2]);\\n     return median/2;\\n      }\\n    }\\n}\\n\\n\\nOn online Compiler it is showing correct output \\nBut why it is  showing wrong here \\n"
                    },
                    {
                        "username": "rahul23071992",
                        "content": "Close\\nrahul23071992\\nrahul23071992\\nFeb 19, 2023 11:58\\n\\nDetails\\nSolution\\nPython\\nRuntime\\n59 ms\\nBeats\\n97.1%\\nMemory\\n13.7 MB\\nBeats\\n54.66%\\nClick the distribution chart to view more details\\nNotes\\nWrite your notes here\\nRelated Tags\\nSelect tags\\n0/5\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        joinlist=nums1 +nums2\\n        sorted_list=sorted(joinlist)\\n        if len(sorted_list)%2!=0:\\n            median=sorted_list[(len(sorted_list)//2)]\\n\\n        else:\\n            a=sorted_list[(len(sorted_list)//2)-1]\\n            b=sorted_list[(len(sorted_list)//2)]\\n            print(a,b)\\n            median=float((a+b))/2\\n        return median\\n            "
                    },
                    {
                        "username": "PawanSingh563",
                        "content": " if(x%2==0){\n           \n          double  y=((nums3[(x/2)-1]+nums3[((x/2)+1)-1])/2);\n            \n            return y;\n            \n        }\n        else{\n            double y=nums3[((x+1)/2)-1];\n            return y;\n        }\n\n\nhii, everyone  i am beginner for this platfrom , actually in this concept case 1  is right but case 2  is not right  \n\n any one can help me ????"
                    },
                    {
                        "username": "truongsoi",
                        "content": "I saw a lot of accepted submissions but none of them do checking the pre-defined constrains as mine? Does the auto acceptance test miss these test cases?"
                    },
                    {
                        "username": "priyanshu_3108",
                        "content": "Java Easy solution\\n`class Solution {\\n    public double findMedianSortedArrays(int[] a1, int[] a2) {\\n        int len = a1.length + a2.length;\\n        int [] merged = new int[len];\\n        int i = 0 , j = 0, k = 0;\\n\\n        while( i < a1.length && j < a2.length){\\n            if(a1[i] < a2[j]){\\n                merged[k] = a1[i];\\n                i++;\\n                k++;\\n            }else{\\n                merged[k] = a2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n\\n        while(i < a1.length){\\n              merged[k] = a1[i];\\n              i++;\\n              k++;           \\n        }\\n        while(j < a2.length){\\n            merged[k] = a2[j];\\n            j++;\\n            k++;           \\n        }\\n        // Here we created a merged array\\\\ now we have to find the median\\n        double median = 0.0;\\n         int mid = merged.length / 2;\\n\\n        if(merged.length % 2 == 1){\\n            median= merged[mid];\\n\\n        }else{\\n            median= (merged[mid] + merged[mid - 1]) / 2.0;\\n        }\\n        return median;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1805025,
                "content": [
                    {
                        "username": "simransingh5019",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n       int d = nums1.length+nums2.length;\\n       int arr[] = new int[d];\\n       int i = 0;\\n       int k = 0;\\n       int j = 0;\\n       while(i!=nums1.length && j!= nums2.length)\\n       {\\n           if(nums1[i]>=nums2[j])\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n           }\\n           else\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n           }\\n           k++;\\n       }\\n           while(i!=nums1.length)\\n           {\\n               arr[k] = nums1[i];\\n               i++;\\n               k++;\\n           }\\n           while(j!=nums2.length)\\n           {\\n               arr[k] = nums2[j];\\n               j++;\\n               k++;\\n           }\\n           double median = 0;\\n          if(d%2==0)\\n          {\\n             median = (arr[(d/2)-1]+arr[d/2])/2;\\n            double a = arr[(d/2)-1];\\n            double b =arr[(d/2)];\\n            median = (a+b)/2;\\n          }\\n          else\\n          {\\n            median = arr[d/2];\\n          }\\n        return median;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "michaeltempesta",
                        "content": "I know this should be hard but it seems super easy.\\n\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        merged = []\\n        # len1 = len(nums1)\\n        # len2 = len(nums2)\\n        # longlist = max(len(nums1), len(nums2))\\n        # print(len1, nums1)\\n        # print(len2, nums2)\\n        # print(longlist)\\n        biglist = nums1 + nums2\\n        sbiglist = sorted(biglist)\\n        # print(sbiglist)\\n        # if len(sbiglist)%2 ==0:\\n        #     median = float((sbiglist[(len(sbiglist)/2)] + sbiglist[(len(sbiglist)/2) -1])/2)\\n        #     return \"{:.5f}\".format(median)\\n        #     # print(median)\\n        # elif len(sbiglist)%2 ==1:\\n        #     median = float(sbiglist[ceil(len(sbiglist)/2)])\\n        #     # print(median)\\n        #     return \"{:.5f}\".format(median)\\n        print(sbiglist)\\n        if len(sbiglist) % 2 == 0:\\n            median = float((sbiglist[len(sbiglist)/2] + sbiglist[(len(sbiglist)/2)-1])/2)\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n        elif len(sbiglist) % 2 == 1:\\n            median = float((sbiglist[ceil(len(sbiglist)/2)-1]))\\n            print(\"{:.1f}\".format(median))\\n            return \"{:.1f}\".format(median)\\n\\nbut I get this runtime error:\\nTypeError: 2.0 is not valid value for the expected return type double\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\\nLine 61 in _driver (Solution.py)\\n    _driver()\\nLine 68 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: must be real number, not str\\nLine 22 in _serialize_float (./python3/__serializer__.py)\\nLine 65 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'double\\')\\nLine 59 in _driver (Solution.py)\\n\\nI don\\'t understand what the difference between a double and a float is and according to the examples ive given up to 5decimals on the floats.\\n\\n"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why Memory Limit Exceeded!"
                    },
                    {
                        "username": "faizanalam416",
                        "content": "This Question shouldn\\'t have the right to be in the Hard section. It\\'s quite easy\\uD83E\\uDEE1"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "[1, 2] and [3, 4] when we merged and sorted these two we get [1, 2, 3, 4] and median of this is (2 + 3)/2 = 2.5 but I\\'m getting 2.0 why??"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution \\n{\\n         public double  findMedianSortedArrays(int[] nums1, int[] nums2)\\n    {\\n        int a =nums1.length;\\n        int b = nums2.length;\\n        int j=0,i=0;\\n        int[] arr = new int[a+b];\\n        for(i=0;i<a;i++)\\n        {\\n           arr[i]=nums1[i];\\n        }\\n        \\n        for(i=a;i<a+b && j<b;i++,j++)\\n        {\\n           arr[i]=nums2[j];\\n        }\\n      double median =0;\\n      int n =arr.length;\\n      if(n%2!=0)\\n      {\\n         int ind = n/2;\\n         \\n         median= arr[ind];\\n      return median;\\n         \\n      }\\n      else{\\n         int ind1= n/2-1;\\n         int ind2=(n/2);\\n         median = (arr[ind1]+arr[ind2]);\\n     return median/2;\\n      }\\n    }\\n}\\n\\n\\nOn online Compiler it is showing correct output \\nBut why it is  showing wrong here \\n"
                    },
                    {
                        "username": "rahul23071992",
                        "content": "Close\\nrahul23071992\\nrahul23071992\\nFeb 19, 2023 11:58\\n\\nDetails\\nSolution\\nPython\\nRuntime\\n59 ms\\nBeats\\n97.1%\\nMemory\\n13.7 MB\\nBeats\\n54.66%\\nClick the distribution chart to view more details\\nNotes\\nWrite your notes here\\nRelated Tags\\nSelect tags\\n0/5\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        joinlist=nums1 +nums2\\n        sorted_list=sorted(joinlist)\\n        if len(sorted_list)%2!=0:\\n            median=sorted_list[(len(sorted_list)//2)]\\n\\n        else:\\n            a=sorted_list[(len(sorted_list)//2)-1]\\n            b=sorted_list[(len(sorted_list)//2)]\\n            print(a,b)\\n            median=float((a+b))/2\\n        return median\\n            "
                    },
                    {
                        "username": "PawanSingh563",
                        "content": " if(x%2==0){\n           \n          double  y=((nums3[(x/2)-1]+nums3[((x/2)+1)-1])/2);\n            \n            return y;\n            \n        }\n        else{\n            double y=nums3[((x+1)/2)-1];\n            return y;\n        }\n\n\nhii, everyone  i am beginner for this platfrom , actually in this concept case 1  is right but case 2  is not right  \n\n any one can help me ????"
                    },
                    {
                        "username": "truongsoi",
                        "content": "I saw a lot of accepted submissions but none of them do checking the pre-defined constrains as mine? Does the auto acceptance test miss these test cases?"
                    },
                    {
                        "username": "priyanshu_3108",
                        "content": "Java Easy solution\\n`class Solution {\\n    public double findMedianSortedArrays(int[] a1, int[] a2) {\\n        int len = a1.length + a2.length;\\n        int [] merged = new int[len];\\n        int i = 0 , j = 0, k = 0;\\n\\n        while( i < a1.length && j < a2.length){\\n            if(a1[i] < a2[j]){\\n                merged[k] = a1[i];\\n                i++;\\n                k++;\\n            }else{\\n                merged[k] = a2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n\\n        while(i < a1.length){\\n              merged[k] = a1[i];\\n              i++;\\n              k++;           \\n        }\\n        while(j < a2.length){\\n            merged[k] = a2[j];\\n            j++;\\n            k++;           \\n        }\\n        // Here we created a merged array\\\\ now we have to find the median\\n        double median = 0.0;\\n         int mid = merged.length / 2;\\n\\n        if(merged.length % 2 == 1){\\n            median= merged[mid];\\n\\n        }else{\\n            median= (merged[mid] + merged[mid - 1]) / 2.0;\\n        }\\n        return median;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1804302,
                "content": [
                    {
                        "username": "iam_avinash",
                        "content": " ArrayList<Integer> list = new ArrayList<>();\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        for(int i=0;i<n;i++){\\n            list.add(nums1[i]);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            list.add(nums2[j]);\\n        }\\n\\n        //sort ArrayList\\n        Collections.sort(list);\\n\\n        int len = list.size();\\n        if(len%2==0){\\n            double median = ((double)list.get(len/2 - 1) + (double)list.get (len/2))/2;\\n            return median;\\n        }else{\\n            double median = ((double)list.get((len+1)/2 - 1));\\n            return median;\\n        }"
                    },
                    {
                        "username": "srushtipatel",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, l1, l2):\\n        m=len(l1)\\n        n = len(l2)\\n        l3 = l1+l2\\n        l3.sort()\\n    \\n        if (m+n)%2 != 0:\\n            med_index = int((m+n)/2)\\n            res = l3[med_index]\\n        if (m+n)%2 == 0:\\n            med_index1 = ((m+n)/2)-1\\n            med_index2 = (m+n)/2\\n            res = (l3[med_index1] + l3[med_index2])/2\\n        return res\\ncan anyone tell me what\\'s the problem in this code.\\nthis is mathematically right code and gives the right output on vscode, but here the following testcase create a problem\\nnums1 =\\n[1,2]\\nnums2 =\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000"
                    },
                    {
                        "username": "Sakthi_01001",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n       answer=0.00000\\n       array=sorted(set(nums1+nums2))\\n       even=len(array)%2==0\\n       if len(array)==2:\\n           return answer+sum(array)/2\\n       elif len(array)==1:\\n           return answer+array[0]\\n       elif even==True:\\n           return answer+(array[(len(array)//2)]+array[(len(array)//2)-1])/2\\n       else:\\n           return answer+array[(len(array)//2)]\\n       return 0\\n\\n\\n\\nI don\\'t know why it\\'s failed at this Test Case \\nnums1=[1,1]\\nnums2=[1,2]\\n\\nthey expecting 1.00000\\nbut the code returns 1.50000\\n\\nbut (1+2)/2=1.5\\nthen what is 1.00000 "
                    },
                    {
                        "username": "prathamrajbhatt",
                        "content": "  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       int n1=nums1.size();\\n       int n2=nums2.size();\\n       if(n1>n2)\\n       findMedianSortedArrays(nums2,nums1);\\n       int l=0,h=n1;\\n       while(l<=h)\\n       {\\n           int cut1=(l+h)/2;\\n           int cut2=(n1+n2+1)/2-cut1;\\n           int left1=cut1==0?INT_MIN:nums1[cut1-1];\\n           int left2=cut2==0?INT_MIN:nums2[cut2-1];\\n            int right1=cut1==n1?INT_MAX:nums1[cut1];\\n           int right2=cut2==n2?INT_MAX:nums2[cut2];\\n          if((left1<=right2)&&(left2<=right1))\\n          {\\n              if((n1+n2)%2==0)\\n              return (max(left1,left2)+min(right1,right2))/2.0;\\n              else return max(left1,left2);\\n          }\\n          else if(left1>right1)\\n               h=cut1-1;\\n               else l=cut1+1;\\n\\n       }\\n       return 0.0;\\n\\n    }\\nTHIS IS STRIVERS SOLUTION BUT IT FAILS FOR EDGE CASE WHEN nums2 IS EMPTY.\\nSOMEONE MODIFY THIS CODE IF U CAN."
                    },
                    {
                        "username": "bgdnvk",
                        "content": "functions to make life easier (TS):\\n\\n```\\nfunction isFloat(n: number): boolean {\\n    return !!(n % 1)\\n}\\n\\nfunction isEven(n: number): boolean {\\n    return n % 2 === 0\\n}\\n\\nfunction getMid(n: number): number {\\n    return Math.floor(n/2)\\n}\\n```"
                    },
                    {
                        "username": "Pratyay_Amrit",
                        "content": "hey..\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "#include<iostream>\\nusing namespace std;\\n    void out(int* p, int s);\\n    void in(int* p, int s);\\n    void merge(int* p1, int* p2, int* p3, int s1, int s3);\\n    void sort(int* m, int s3);\\n    double median(int* m, int s3) {\\n        double med = 0;\\n        if (!(s3 % 2 == 0)) {\\n            return static_cast<double>(*(m + (((s3 + 1) / 2) - 1)));\\n\\n        }\\n        else\\n            return static_cast<double>((*(m + (s3 / 2)-1) + *(m + (s3 / 2))))/2;\\n    }\\nint main() {\\n    int s1=0, s2=0, s3=0;\\n    cin >> s1 >> s2;\\n    int* l1 = new int[s1];\\n    int* l2 = new int[s2];\\n    s3 = s1 + s2;\\n    int* m = new int[s3];\\n    in(l1, s1);\\n    in(l2, s2);\\n    merge(l1, l2, m, s1, s3);\\n    sort(m, s3);\\n    cout << median(m, s3);\\n    return 0;\\n}\\nvoid out(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cout << *(p + i) << \" \";\\n    }\\n    cout << endl;\\n}\\nvoid in(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cin >> p[i];\\n    }\\n}\\nvoid merge(int* p1, int* p2, int* p3, int s1, int s3) {\\n    for (int i = 0; i < s3; i++) {\\n        if (i < s1)\\n            *(p3 + i) = *(p1 + i);\\n        else\\n            p3[i] = *(p2 + (i - s1));\\n    }\\n}\\nvoid sort(int* m, int s3) {\\n    int temp = 0;\\n    for (int i = 0; i < s3; i++) {\\n        for (int j = i + 1; j < s3; j++) {\\n            if (*(m + i) > *(m + j)) {\\n                temp = 0;\\n                temp = *(m + i);\\n                *(m + i) = *(m + j);\\n                *(m + j) = temp;\\n            }\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "why its a compile error its working in visual studio ? "
                    },
                    {
                        "username": "user8219l",
                        "content": "https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/895749408/\\n\\nCan anyone help me why my solutions isnt working...\\nIts failing for nums1= [1] nums2=[2,3] input.\\nStuck on this from quite a few days.\\nplease help!!"
                    },
                    {
                        "username": "A01verma",
                        "content": "I run this code on my Pycharme IDE it did work well for every case, but here not the same result . can someone tell me why is \\n----------------------------------------------------------------------\\nnums1 = [1,2]\\nnums2 = [3,4]\\nfor i in nums2:\\n     nums1.append(i)\\nnums1.sort()\\nif len(nums1) % 2 == 0:\\n     res = (len(nums1) / 2)\\n     res1 = res - 1\\n     mr = (nums1[res] + nums1[res1])\\n     n = mr/2\\n     return(n)\\nelif len(nums1) % 2 == 1:\\n     re = int(len(nums1)/ 2)\\n     return(nums1[re])\\n------------------------------------------------------------------------\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n = nums1.length+nums2.length;\\n        int[] num = new int[n];\\n        int sum=0;\\n        for(int i=0;i<nums1.length;i++){\\n            num[i] = nums1[i];\\n        }\\n        //int j=n -nums1.length;\\n        for(int j=0;j<nums2.length;j++){\\n            num[nums1.length +j]=nums2[j];\\n        }\\n        int min=num[0];\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(num[i]>num[j]){\\n                    min=num[j];\\n                    num[j]=num[i];\\n                    num[i]=min;\\n                }\\n            }\\n           \\n        }\\n        for(int i=0;i<n;i++){\\n            sum =sum+num[i];\\n        }\\n        float g = n;\\n        float med =0;\\n        if(n%2==0){\\n            n = n/2;\\n            float ss = (num[n]+num[n-1] );\\n            med =ss/2;\\n            return med;\\n            \\n        }else{\\n            n = n/2;\\n            med = num[n];\\n            return med;\\n        }\\n      //return med;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1803566,
                "content": [
                    {
                        "username": "iam_avinash",
                        "content": " ArrayList<Integer> list = new ArrayList<>();\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        for(int i=0;i<n;i++){\\n            list.add(nums1[i]);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            list.add(nums2[j]);\\n        }\\n\\n        //sort ArrayList\\n        Collections.sort(list);\\n\\n        int len = list.size();\\n        if(len%2==0){\\n            double median = ((double)list.get(len/2 - 1) + (double)list.get (len/2))/2;\\n            return median;\\n        }else{\\n            double median = ((double)list.get((len+1)/2 - 1));\\n            return median;\\n        }"
                    },
                    {
                        "username": "srushtipatel",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, l1, l2):\\n        m=len(l1)\\n        n = len(l2)\\n        l3 = l1+l2\\n        l3.sort()\\n    \\n        if (m+n)%2 != 0:\\n            med_index = int((m+n)/2)\\n            res = l3[med_index]\\n        if (m+n)%2 == 0:\\n            med_index1 = ((m+n)/2)-1\\n            med_index2 = (m+n)/2\\n            res = (l3[med_index1] + l3[med_index2])/2\\n        return res\\ncan anyone tell me what\\'s the problem in this code.\\nthis is mathematically right code and gives the right output on vscode, but here the following testcase create a problem\\nnums1 =\\n[1,2]\\nnums2 =\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000"
                    },
                    {
                        "username": "Sakthi_01001",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n       answer=0.00000\\n       array=sorted(set(nums1+nums2))\\n       even=len(array)%2==0\\n       if len(array)==2:\\n           return answer+sum(array)/2\\n       elif len(array)==1:\\n           return answer+array[0]\\n       elif even==True:\\n           return answer+(array[(len(array)//2)]+array[(len(array)//2)-1])/2\\n       else:\\n           return answer+array[(len(array)//2)]\\n       return 0\\n\\n\\n\\nI don\\'t know why it\\'s failed at this Test Case \\nnums1=[1,1]\\nnums2=[1,2]\\n\\nthey expecting 1.00000\\nbut the code returns 1.50000\\n\\nbut (1+2)/2=1.5\\nthen what is 1.00000 "
                    },
                    {
                        "username": "prathamrajbhatt",
                        "content": "  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       int n1=nums1.size();\\n       int n2=nums2.size();\\n       if(n1>n2)\\n       findMedianSortedArrays(nums2,nums1);\\n       int l=0,h=n1;\\n       while(l<=h)\\n       {\\n           int cut1=(l+h)/2;\\n           int cut2=(n1+n2+1)/2-cut1;\\n           int left1=cut1==0?INT_MIN:nums1[cut1-1];\\n           int left2=cut2==0?INT_MIN:nums2[cut2-1];\\n            int right1=cut1==n1?INT_MAX:nums1[cut1];\\n           int right2=cut2==n2?INT_MAX:nums2[cut2];\\n          if((left1<=right2)&&(left2<=right1))\\n          {\\n              if((n1+n2)%2==0)\\n              return (max(left1,left2)+min(right1,right2))/2.0;\\n              else return max(left1,left2);\\n          }\\n          else if(left1>right1)\\n               h=cut1-1;\\n               else l=cut1+1;\\n\\n       }\\n       return 0.0;\\n\\n    }\\nTHIS IS STRIVERS SOLUTION BUT IT FAILS FOR EDGE CASE WHEN nums2 IS EMPTY.\\nSOMEONE MODIFY THIS CODE IF U CAN."
                    },
                    {
                        "username": "bgdnvk",
                        "content": "functions to make life easier (TS):\\n\\n```\\nfunction isFloat(n: number): boolean {\\n    return !!(n % 1)\\n}\\n\\nfunction isEven(n: number): boolean {\\n    return n % 2 === 0\\n}\\n\\nfunction getMid(n: number): number {\\n    return Math.floor(n/2)\\n}\\n```"
                    },
                    {
                        "username": "Pratyay_Amrit",
                        "content": "hey..\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "#include<iostream>\\nusing namespace std;\\n    void out(int* p, int s);\\n    void in(int* p, int s);\\n    void merge(int* p1, int* p2, int* p3, int s1, int s3);\\n    void sort(int* m, int s3);\\n    double median(int* m, int s3) {\\n        double med = 0;\\n        if (!(s3 % 2 == 0)) {\\n            return static_cast<double>(*(m + (((s3 + 1) / 2) - 1)));\\n\\n        }\\n        else\\n            return static_cast<double>((*(m + (s3 / 2)-1) + *(m + (s3 / 2))))/2;\\n    }\\nint main() {\\n    int s1=0, s2=0, s3=0;\\n    cin >> s1 >> s2;\\n    int* l1 = new int[s1];\\n    int* l2 = new int[s2];\\n    s3 = s1 + s2;\\n    int* m = new int[s3];\\n    in(l1, s1);\\n    in(l2, s2);\\n    merge(l1, l2, m, s1, s3);\\n    sort(m, s3);\\n    cout << median(m, s3);\\n    return 0;\\n}\\nvoid out(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cout << *(p + i) << \" \";\\n    }\\n    cout << endl;\\n}\\nvoid in(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cin >> p[i];\\n    }\\n}\\nvoid merge(int* p1, int* p2, int* p3, int s1, int s3) {\\n    for (int i = 0; i < s3; i++) {\\n        if (i < s1)\\n            *(p3 + i) = *(p1 + i);\\n        else\\n            p3[i] = *(p2 + (i - s1));\\n    }\\n}\\nvoid sort(int* m, int s3) {\\n    int temp = 0;\\n    for (int i = 0; i < s3; i++) {\\n        for (int j = i + 1; j < s3; j++) {\\n            if (*(m + i) > *(m + j)) {\\n                temp = 0;\\n                temp = *(m + i);\\n                *(m + i) = *(m + j);\\n                *(m + j) = temp;\\n            }\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "why its a compile error its working in visual studio ? "
                    },
                    {
                        "username": "user8219l",
                        "content": "https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/895749408/\\n\\nCan anyone help me why my solutions isnt working...\\nIts failing for nums1= [1] nums2=[2,3] input.\\nStuck on this from quite a few days.\\nplease help!!"
                    },
                    {
                        "username": "A01verma",
                        "content": "I run this code on my Pycharme IDE it did work well for every case, but here not the same result . can someone tell me why is \\n----------------------------------------------------------------------\\nnums1 = [1,2]\\nnums2 = [3,4]\\nfor i in nums2:\\n     nums1.append(i)\\nnums1.sort()\\nif len(nums1) % 2 == 0:\\n     res = (len(nums1) / 2)\\n     res1 = res - 1\\n     mr = (nums1[res] + nums1[res1])\\n     n = mr/2\\n     return(n)\\nelif len(nums1) % 2 == 1:\\n     re = int(len(nums1)/ 2)\\n     return(nums1[re])\\n------------------------------------------------------------------------\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n = nums1.length+nums2.length;\\n        int[] num = new int[n];\\n        int sum=0;\\n        for(int i=0;i<nums1.length;i++){\\n            num[i] = nums1[i];\\n        }\\n        //int j=n -nums1.length;\\n        for(int j=0;j<nums2.length;j++){\\n            num[nums1.length +j]=nums2[j];\\n        }\\n        int min=num[0];\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(num[i]>num[j]){\\n                    min=num[j];\\n                    num[j]=num[i];\\n                    num[i]=min;\\n                }\\n            }\\n           \\n        }\\n        for(int i=0;i<n;i++){\\n            sum =sum+num[i];\\n        }\\n        float g = n;\\n        float med =0;\\n        if(n%2==0){\\n            n = n/2;\\n            float ss = (num[n]+num[n-1] );\\n            med =ss/2;\\n            return med;\\n            \\n        }else{\\n            n = n/2;\\n            med = num[n];\\n            return med;\\n        }\\n      //return med;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1799551,
                "content": [
                    {
                        "username": "iam_avinash",
                        "content": " ArrayList<Integer> list = new ArrayList<>();\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        for(int i=0;i<n;i++){\\n            list.add(nums1[i]);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            list.add(nums2[j]);\\n        }\\n\\n        //sort ArrayList\\n        Collections.sort(list);\\n\\n        int len = list.size();\\n        if(len%2==0){\\n            double median = ((double)list.get(len/2 - 1) + (double)list.get (len/2))/2;\\n            return median;\\n        }else{\\n            double median = ((double)list.get((len+1)/2 - 1));\\n            return median;\\n        }"
                    },
                    {
                        "username": "srushtipatel",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, l1, l2):\\n        m=len(l1)\\n        n = len(l2)\\n        l3 = l1+l2\\n        l3.sort()\\n    \\n        if (m+n)%2 != 0:\\n            med_index = int((m+n)/2)\\n            res = l3[med_index]\\n        if (m+n)%2 == 0:\\n            med_index1 = ((m+n)/2)-1\\n            med_index2 = (m+n)/2\\n            res = (l3[med_index1] + l3[med_index2])/2\\n        return res\\ncan anyone tell me what\\'s the problem in this code.\\nthis is mathematically right code and gives the right output on vscode, but here the following testcase create a problem\\nnums1 =\\n[1,2]\\nnums2 =\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000"
                    },
                    {
                        "username": "Sakthi_01001",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n       answer=0.00000\\n       array=sorted(set(nums1+nums2))\\n       even=len(array)%2==0\\n       if len(array)==2:\\n           return answer+sum(array)/2\\n       elif len(array)==1:\\n           return answer+array[0]\\n       elif even==True:\\n           return answer+(array[(len(array)//2)]+array[(len(array)//2)-1])/2\\n       else:\\n           return answer+array[(len(array)//2)]\\n       return 0\\n\\n\\n\\nI don\\'t know why it\\'s failed at this Test Case \\nnums1=[1,1]\\nnums2=[1,2]\\n\\nthey expecting 1.00000\\nbut the code returns 1.50000\\n\\nbut (1+2)/2=1.5\\nthen what is 1.00000 "
                    },
                    {
                        "username": "prathamrajbhatt",
                        "content": "  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       int n1=nums1.size();\\n       int n2=nums2.size();\\n       if(n1>n2)\\n       findMedianSortedArrays(nums2,nums1);\\n       int l=0,h=n1;\\n       while(l<=h)\\n       {\\n           int cut1=(l+h)/2;\\n           int cut2=(n1+n2+1)/2-cut1;\\n           int left1=cut1==0?INT_MIN:nums1[cut1-1];\\n           int left2=cut2==0?INT_MIN:nums2[cut2-1];\\n            int right1=cut1==n1?INT_MAX:nums1[cut1];\\n           int right2=cut2==n2?INT_MAX:nums2[cut2];\\n          if((left1<=right2)&&(left2<=right1))\\n          {\\n              if((n1+n2)%2==0)\\n              return (max(left1,left2)+min(right1,right2))/2.0;\\n              else return max(left1,left2);\\n          }\\n          else if(left1>right1)\\n               h=cut1-1;\\n               else l=cut1+1;\\n\\n       }\\n       return 0.0;\\n\\n    }\\nTHIS IS STRIVERS SOLUTION BUT IT FAILS FOR EDGE CASE WHEN nums2 IS EMPTY.\\nSOMEONE MODIFY THIS CODE IF U CAN."
                    },
                    {
                        "username": "bgdnvk",
                        "content": "functions to make life easier (TS):\\n\\n```\\nfunction isFloat(n: number): boolean {\\n    return !!(n % 1)\\n}\\n\\nfunction isEven(n: number): boolean {\\n    return n % 2 === 0\\n}\\n\\nfunction getMid(n: number): number {\\n    return Math.floor(n/2)\\n}\\n```"
                    },
                    {
                        "username": "Pratyay_Amrit",
                        "content": "hey..\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "#include<iostream>\\nusing namespace std;\\n    void out(int* p, int s);\\n    void in(int* p, int s);\\n    void merge(int* p1, int* p2, int* p3, int s1, int s3);\\n    void sort(int* m, int s3);\\n    double median(int* m, int s3) {\\n        double med = 0;\\n        if (!(s3 % 2 == 0)) {\\n            return static_cast<double>(*(m + (((s3 + 1) / 2) - 1)));\\n\\n        }\\n        else\\n            return static_cast<double>((*(m + (s3 / 2)-1) + *(m + (s3 / 2))))/2;\\n    }\\nint main() {\\n    int s1=0, s2=0, s3=0;\\n    cin >> s1 >> s2;\\n    int* l1 = new int[s1];\\n    int* l2 = new int[s2];\\n    s3 = s1 + s2;\\n    int* m = new int[s3];\\n    in(l1, s1);\\n    in(l2, s2);\\n    merge(l1, l2, m, s1, s3);\\n    sort(m, s3);\\n    cout << median(m, s3);\\n    return 0;\\n}\\nvoid out(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cout << *(p + i) << \" \";\\n    }\\n    cout << endl;\\n}\\nvoid in(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cin >> p[i];\\n    }\\n}\\nvoid merge(int* p1, int* p2, int* p3, int s1, int s3) {\\n    for (int i = 0; i < s3; i++) {\\n        if (i < s1)\\n            *(p3 + i) = *(p1 + i);\\n        else\\n            p3[i] = *(p2 + (i - s1));\\n    }\\n}\\nvoid sort(int* m, int s3) {\\n    int temp = 0;\\n    for (int i = 0; i < s3; i++) {\\n        for (int j = i + 1; j < s3; j++) {\\n            if (*(m + i) > *(m + j)) {\\n                temp = 0;\\n                temp = *(m + i);\\n                *(m + i) = *(m + j);\\n                *(m + j) = temp;\\n            }\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "why its a compile error its working in visual studio ? "
                    },
                    {
                        "username": "user8219l",
                        "content": "https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/895749408/\\n\\nCan anyone help me why my solutions isnt working...\\nIts failing for nums1= [1] nums2=[2,3] input.\\nStuck on this from quite a few days.\\nplease help!!"
                    },
                    {
                        "username": "A01verma",
                        "content": "I run this code on my Pycharme IDE it did work well for every case, but here not the same result . can someone tell me why is \\n----------------------------------------------------------------------\\nnums1 = [1,2]\\nnums2 = [3,4]\\nfor i in nums2:\\n     nums1.append(i)\\nnums1.sort()\\nif len(nums1) % 2 == 0:\\n     res = (len(nums1) / 2)\\n     res1 = res - 1\\n     mr = (nums1[res] + nums1[res1])\\n     n = mr/2\\n     return(n)\\nelif len(nums1) % 2 == 1:\\n     re = int(len(nums1)/ 2)\\n     return(nums1[re])\\n------------------------------------------------------------------------\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n = nums1.length+nums2.length;\\n        int[] num = new int[n];\\n        int sum=0;\\n        for(int i=0;i<nums1.length;i++){\\n            num[i] = nums1[i];\\n        }\\n        //int j=n -nums1.length;\\n        for(int j=0;j<nums2.length;j++){\\n            num[nums1.length +j]=nums2[j];\\n        }\\n        int min=num[0];\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(num[i]>num[j]){\\n                    min=num[j];\\n                    num[j]=num[i];\\n                    num[i]=min;\\n                }\\n            }\\n           \\n        }\\n        for(int i=0;i<n;i++){\\n            sum =sum+num[i];\\n        }\\n        float g = n;\\n        float med =0;\\n        if(n%2==0){\\n            n = n/2;\\n            float ss = (num[n]+num[n-1] );\\n            med =ss/2;\\n            return med;\\n            \\n        }else{\\n            n = n/2;\\n            med = num[n];\\n            return med;\\n        }\\n      //return med;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1798141,
                "content": [
                    {
                        "username": "iam_avinash",
                        "content": " ArrayList<Integer> list = new ArrayList<>();\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        for(int i=0;i<n;i++){\\n            list.add(nums1[i]);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            list.add(nums2[j]);\\n        }\\n\\n        //sort ArrayList\\n        Collections.sort(list);\\n\\n        int len = list.size();\\n        if(len%2==0){\\n            double median = ((double)list.get(len/2 - 1) + (double)list.get (len/2))/2;\\n            return median;\\n        }else{\\n            double median = ((double)list.get((len+1)/2 - 1));\\n            return median;\\n        }"
                    },
                    {
                        "username": "srushtipatel",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, l1, l2):\\n        m=len(l1)\\n        n = len(l2)\\n        l3 = l1+l2\\n        l3.sort()\\n    \\n        if (m+n)%2 != 0:\\n            med_index = int((m+n)/2)\\n            res = l3[med_index]\\n        if (m+n)%2 == 0:\\n            med_index1 = ((m+n)/2)-1\\n            med_index2 = (m+n)/2\\n            res = (l3[med_index1] + l3[med_index2])/2\\n        return res\\ncan anyone tell me what\\'s the problem in this code.\\nthis is mathematically right code and gives the right output on vscode, but here the following testcase create a problem\\nnums1 =\\n[1,2]\\nnums2 =\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000"
                    },
                    {
                        "username": "Sakthi_01001",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n       answer=0.00000\\n       array=sorted(set(nums1+nums2))\\n       even=len(array)%2==0\\n       if len(array)==2:\\n           return answer+sum(array)/2\\n       elif len(array)==1:\\n           return answer+array[0]\\n       elif even==True:\\n           return answer+(array[(len(array)//2)]+array[(len(array)//2)-1])/2\\n       else:\\n           return answer+array[(len(array)//2)]\\n       return 0\\n\\n\\n\\nI don\\'t know why it\\'s failed at this Test Case \\nnums1=[1,1]\\nnums2=[1,2]\\n\\nthey expecting 1.00000\\nbut the code returns 1.50000\\n\\nbut (1+2)/2=1.5\\nthen what is 1.00000 "
                    },
                    {
                        "username": "prathamrajbhatt",
                        "content": "  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       int n1=nums1.size();\\n       int n2=nums2.size();\\n       if(n1>n2)\\n       findMedianSortedArrays(nums2,nums1);\\n       int l=0,h=n1;\\n       while(l<=h)\\n       {\\n           int cut1=(l+h)/2;\\n           int cut2=(n1+n2+1)/2-cut1;\\n           int left1=cut1==0?INT_MIN:nums1[cut1-1];\\n           int left2=cut2==0?INT_MIN:nums2[cut2-1];\\n            int right1=cut1==n1?INT_MAX:nums1[cut1];\\n           int right2=cut2==n2?INT_MAX:nums2[cut2];\\n          if((left1<=right2)&&(left2<=right1))\\n          {\\n              if((n1+n2)%2==0)\\n              return (max(left1,left2)+min(right1,right2))/2.0;\\n              else return max(left1,left2);\\n          }\\n          else if(left1>right1)\\n               h=cut1-1;\\n               else l=cut1+1;\\n\\n       }\\n       return 0.0;\\n\\n    }\\nTHIS IS STRIVERS SOLUTION BUT IT FAILS FOR EDGE CASE WHEN nums2 IS EMPTY.\\nSOMEONE MODIFY THIS CODE IF U CAN."
                    },
                    {
                        "username": "bgdnvk",
                        "content": "functions to make life easier (TS):\\n\\n```\\nfunction isFloat(n: number): boolean {\\n    return !!(n % 1)\\n}\\n\\nfunction isEven(n: number): boolean {\\n    return n % 2 === 0\\n}\\n\\nfunction getMid(n: number): number {\\n    return Math.floor(n/2)\\n}\\n```"
                    },
                    {
                        "username": "Pratyay_Amrit",
                        "content": "hey..\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "#include<iostream>\\nusing namespace std;\\n    void out(int* p, int s);\\n    void in(int* p, int s);\\n    void merge(int* p1, int* p2, int* p3, int s1, int s3);\\n    void sort(int* m, int s3);\\n    double median(int* m, int s3) {\\n        double med = 0;\\n        if (!(s3 % 2 == 0)) {\\n            return static_cast<double>(*(m + (((s3 + 1) / 2) - 1)));\\n\\n        }\\n        else\\n            return static_cast<double>((*(m + (s3 / 2)-1) + *(m + (s3 / 2))))/2;\\n    }\\nint main() {\\n    int s1=0, s2=0, s3=0;\\n    cin >> s1 >> s2;\\n    int* l1 = new int[s1];\\n    int* l2 = new int[s2];\\n    s3 = s1 + s2;\\n    int* m = new int[s3];\\n    in(l1, s1);\\n    in(l2, s2);\\n    merge(l1, l2, m, s1, s3);\\n    sort(m, s3);\\n    cout << median(m, s3);\\n    return 0;\\n}\\nvoid out(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cout << *(p + i) << \" \";\\n    }\\n    cout << endl;\\n}\\nvoid in(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cin >> p[i];\\n    }\\n}\\nvoid merge(int* p1, int* p2, int* p3, int s1, int s3) {\\n    for (int i = 0; i < s3; i++) {\\n        if (i < s1)\\n            *(p3 + i) = *(p1 + i);\\n        else\\n            p3[i] = *(p2 + (i - s1));\\n    }\\n}\\nvoid sort(int* m, int s3) {\\n    int temp = 0;\\n    for (int i = 0; i < s3; i++) {\\n        for (int j = i + 1; j < s3; j++) {\\n            if (*(m + i) > *(m + j)) {\\n                temp = 0;\\n                temp = *(m + i);\\n                *(m + i) = *(m + j);\\n                *(m + j) = temp;\\n            }\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "why its a compile error its working in visual studio ? "
                    },
                    {
                        "username": "user8219l",
                        "content": "https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/895749408/\\n\\nCan anyone help me why my solutions isnt working...\\nIts failing for nums1= [1] nums2=[2,3] input.\\nStuck on this from quite a few days.\\nplease help!!"
                    },
                    {
                        "username": "A01verma",
                        "content": "I run this code on my Pycharme IDE it did work well for every case, but here not the same result . can someone tell me why is \\n----------------------------------------------------------------------\\nnums1 = [1,2]\\nnums2 = [3,4]\\nfor i in nums2:\\n     nums1.append(i)\\nnums1.sort()\\nif len(nums1) % 2 == 0:\\n     res = (len(nums1) / 2)\\n     res1 = res - 1\\n     mr = (nums1[res] + nums1[res1])\\n     n = mr/2\\n     return(n)\\nelif len(nums1) % 2 == 1:\\n     re = int(len(nums1)/ 2)\\n     return(nums1[re])\\n------------------------------------------------------------------------\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n = nums1.length+nums2.length;\\n        int[] num = new int[n];\\n        int sum=0;\\n        for(int i=0;i<nums1.length;i++){\\n            num[i] = nums1[i];\\n        }\\n        //int j=n -nums1.length;\\n        for(int j=0;j<nums2.length;j++){\\n            num[nums1.length +j]=nums2[j];\\n        }\\n        int min=num[0];\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(num[i]>num[j]){\\n                    min=num[j];\\n                    num[j]=num[i];\\n                    num[i]=min;\\n                }\\n            }\\n           \\n        }\\n        for(int i=0;i<n;i++){\\n            sum =sum+num[i];\\n        }\\n        float g = n;\\n        float med =0;\\n        if(n%2==0){\\n            n = n/2;\\n            float ss = (num[n]+num[n-1] );\\n            med =ss/2;\\n            return med;\\n            \\n        }else{\\n            n = n/2;\\n            med = num[n];\\n            return med;\\n        }\\n      //return med;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1796909,
                "content": [
                    {
                        "username": "iam_avinash",
                        "content": " ArrayList<Integer> list = new ArrayList<>();\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        for(int i=0;i<n;i++){\\n            list.add(nums1[i]);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            list.add(nums2[j]);\\n        }\\n\\n        //sort ArrayList\\n        Collections.sort(list);\\n\\n        int len = list.size();\\n        if(len%2==0){\\n            double median = ((double)list.get(len/2 - 1) + (double)list.get (len/2))/2;\\n            return median;\\n        }else{\\n            double median = ((double)list.get((len+1)/2 - 1));\\n            return median;\\n        }"
                    },
                    {
                        "username": "srushtipatel",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, l1, l2):\\n        m=len(l1)\\n        n = len(l2)\\n        l3 = l1+l2\\n        l3.sort()\\n    \\n        if (m+n)%2 != 0:\\n            med_index = int((m+n)/2)\\n            res = l3[med_index]\\n        if (m+n)%2 == 0:\\n            med_index1 = ((m+n)/2)-1\\n            med_index2 = (m+n)/2\\n            res = (l3[med_index1] + l3[med_index2])/2\\n        return res\\ncan anyone tell me what\\'s the problem in this code.\\nthis is mathematically right code and gives the right output on vscode, but here the following testcase create a problem\\nnums1 =\\n[1,2]\\nnums2 =\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000"
                    },
                    {
                        "username": "Sakthi_01001",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n       answer=0.00000\\n       array=sorted(set(nums1+nums2))\\n       even=len(array)%2==0\\n       if len(array)==2:\\n           return answer+sum(array)/2\\n       elif len(array)==1:\\n           return answer+array[0]\\n       elif even==True:\\n           return answer+(array[(len(array)//2)]+array[(len(array)//2)-1])/2\\n       else:\\n           return answer+array[(len(array)//2)]\\n       return 0\\n\\n\\n\\nI don\\'t know why it\\'s failed at this Test Case \\nnums1=[1,1]\\nnums2=[1,2]\\n\\nthey expecting 1.00000\\nbut the code returns 1.50000\\n\\nbut (1+2)/2=1.5\\nthen what is 1.00000 "
                    },
                    {
                        "username": "prathamrajbhatt",
                        "content": "  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       int n1=nums1.size();\\n       int n2=nums2.size();\\n       if(n1>n2)\\n       findMedianSortedArrays(nums2,nums1);\\n       int l=0,h=n1;\\n       while(l<=h)\\n       {\\n           int cut1=(l+h)/2;\\n           int cut2=(n1+n2+1)/2-cut1;\\n           int left1=cut1==0?INT_MIN:nums1[cut1-1];\\n           int left2=cut2==0?INT_MIN:nums2[cut2-1];\\n            int right1=cut1==n1?INT_MAX:nums1[cut1];\\n           int right2=cut2==n2?INT_MAX:nums2[cut2];\\n          if((left1<=right2)&&(left2<=right1))\\n          {\\n              if((n1+n2)%2==0)\\n              return (max(left1,left2)+min(right1,right2))/2.0;\\n              else return max(left1,left2);\\n          }\\n          else if(left1>right1)\\n               h=cut1-1;\\n               else l=cut1+1;\\n\\n       }\\n       return 0.0;\\n\\n    }\\nTHIS IS STRIVERS SOLUTION BUT IT FAILS FOR EDGE CASE WHEN nums2 IS EMPTY.\\nSOMEONE MODIFY THIS CODE IF U CAN."
                    },
                    {
                        "username": "bgdnvk",
                        "content": "functions to make life easier (TS):\\n\\n```\\nfunction isFloat(n: number): boolean {\\n    return !!(n % 1)\\n}\\n\\nfunction isEven(n: number): boolean {\\n    return n % 2 === 0\\n}\\n\\nfunction getMid(n: number): number {\\n    return Math.floor(n/2)\\n}\\n```"
                    },
                    {
                        "username": "Pratyay_Amrit",
                        "content": "hey..\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "#include<iostream>\\nusing namespace std;\\n    void out(int* p, int s);\\n    void in(int* p, int s);\\n    void merge(int* p1, int* p2, int* p3, int s1, int s3);\\n    void sort(int* m, int s3);\\n    double median(int* m, int s3) {\\n        double med = 0;\\n        if (!(s3 % 2 == 0)) {\\n            return static_cast<double>(*(m + (((s3 + 1) / 2) - 1)));\\n\\n        }\\n        else\\n            return static_cast<double>((*(m + (s3 / 2)-1) + *(m + (s3 / 2))))/2;\\n    }\\nint main() {\\n    int s1=0, s2=0, s3=0;\\n    cin >> s1 >> s2;\\n    int* l1 = new int[s1];\\n    int* l2 = new int[s2];\\n    s3 = s1 + s2;\\n    int* m = new int[s3];\\n    in(l1, s1);\\n    in(l2, s2);\\n    merge(l1, l2, m, s1, s3);\\n    sort(m, s3);\\n    cout << median(m, s3);\\n    return 0;\\n}\\nvoid out(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cout << *(p + i) << \" \";\\n    }\\n    cout << endl;\\n}\\nvoid in(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cin >> p[i];\\n    }\\n}\\nvoid merge(int* p1, int* p2, int* p3, int s1, int s3) {\\n    for (int i = 0; i < s3; i++) {\\n        if (i < s1)\\n            *(p3 + i) = *(p1 + i);\\n        else\\n            p3[i] = *(p2 + (i - s1));\\n    }\\n}\\nvoid sort(int* m, int s3) {\\n    int temp = 0;\\n    for (int i = 0; i < s3; i++) {\\n        for (int j = i + 1; j < s3; j++) {\\n            if (*(m + i) > *(m + j)) {\\n                temp = 0;\\n                temp = *(m + i);\\n                *(m + i) = *(m + j);\\n                *(m + j) = temp;\\n            }\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "why its a compile error its working in visual studio ? "
                    },
                    {
                        "username": "user8219l",
                        "content": "https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/895749408/\\n\\nCan anyone help me why my solutions isnt working...\\nIts failing for nums1= [1] nums2=[2,3] input.\\nStuck on this from quite a few days.\\nplease help!!"
                    },
                    {
                        "username": "A01verma",
                        "content": "I run this code on my Pycharme IDE it did work well for every case, but here not the same result . can someone tell me why is \\n----------------------------------------------------------------------\\nnums1 = [1,2]\\nnums2 = [3,4]\\nfor i in nums2:\\n     nums1.append(i)\\nnums1.sort()\\nif len(nums1) % 2 == 0:\\n     res = (len(nums1) / 2)\\n     res1 = res - 1\\n     mr = (nums1[res] + nums1[res1])\\n     n = mr/2\\n     return(n)\\nelif len(nums1) % 2 == 1:\\n     re = int(len(nums1)/ 2)\\n     return(nums1[re])\\n------------------------------------------------------------------------\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n = nums1.length+nums2.length;\\n        int[] num = new int[n];\\n        int sum=0;\\n        for(int i=0;i<nums1.length;i++){\\n            num[i] = nums1[i];\\n        }\\n        //int j=n -nums1.length;\\n        for(int j=0;j<nums2.length;j++){\\n            num[nums1.length +j]=nums2[j];\\n        }\\n        int min=num[0];\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(num[i]>num[j]){\\n                    min=num[j];\\n                    num[j]=num[i];\\n                    num[i]=min;\\n                }\\n            }\\n           \\n        }\\n        for(int i=0;i<n;i++){\\n            sum =sum+num[i];\\n        }\\n        float g = n;\\n        float med =0;\\n        if(n%2==0){\\n            n = n/2;\\n            float ss = (num[n]+num[n-1] );\\n            med =ss/2;\\n            return med;\\n            \\n        }else{\\n            n = n/2;\\n            med = num[n];\\n            return med;\\n        }\\n      //return med;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1796853,
                "content": [
                    {
                        "username": "iam_avinash",
                        "content": " ArrayList<Integer> list = new ArrayList<>();\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        for(int i=0;i<n;i++){\\n            list.add(nums1[i]);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            list.add(nums2[j]);\\n        }\\n\\n        //sort ArrayList\\n        Collections.sort(list);\\n\\n        int len = list.size();\\n        if(len%2==0){\\n            double median = ((double)list.get(len/2 - 1) + (double)list.get (len/2))/2;\\n            return median;\\n        }else{\\n            double median = ((double)list.get((len+1)/2 - 1));\\n            return median;\\n        }"
                    },
                    {
                        "username": "srushtipatel",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, l1, l2):\\n        m=len(l1)\\n        n = len(l2)\\n        l3 = l1+l2\\n        l3.sort()\\n    \\n        if (m+n)%2 != 0:\\n            med_index = int((m+n)/2)\\n            res = l3[med_index]\\n        if (m+n)%2 == 0:\\n            med_index1 = ((m+n)/2)-1\\n            med_index2 = (m+n)/2\\n            res = (l3[med_index1] + l3[med_index2])/2\\n        return res\\ncan anyone tell me what\\'s the problem in this code.\\nthis is mathematically right code and gives the right output on vscode, but here the following testcase create a problem\\nnums1 =\\n[1,2]\\nnums2 =\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000"
                    },
                    {
                        "username": "Sakthi_01001",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n       answer=0.00000\\n       array=sorted(set(nums1+nums2))\\n       even=len(array)%2==0\\n       if len(array)==2:\\n           return answer+sum(array)/2\\n       elif len(array)==1:\\n           return answer+array[0]\\n       elif even==True:\\n           return answer+(array[(len(array)//2)]+array[(len(array)//2)-1])/2\\n       else:\\n           return answer+array[(len(array)//2)]\\n       return 0\\n\\n\\n\\nI don\\'t know why it\\'s failed at this Test Case \\nnums1=[1,1]\\nnums2=[1,2]\\n\\nthey expecting 1.00000\\nbut the code returns 1.50000\\n\\nbut (1+2)/2=1.5\\nthen what is 1.00000 "
                    },
                    {
                        "username": "prathamrajbhatt",
                        "content": "  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       int n1=nums1.size();\\n       int n2=nums2.size();\\n       if(n1>n2)\\n       findMedianSortedArrays(nums2,nums1);\\n       int l=0,h=n1;\\n       while(l<=h)\\n       {\\n           int cut1=(l+h)/2;\\n           int cut2=(n1+n2+1)/2-cut1;\\n           int left1=cut1==0?INT_MIN:nums1[cut1-1];\\n           int left2=cut2==0?INT_MIN:nums2[cut2-1];\\n            int right1=cut1==n1?INT_MAX:nums1[cut1];\\n           int right2=cut2==n2?INT_MAX:nums2[cut2];\\n          if((left1<=right2)&&(left2<=right1))\\n          {\\n              if((n1+n2)%2==0)\\n              return (max(left1,left2)+min(right1,right2))/2.0;\\n              else return max(left1,left2);\\n          }\\n          else if(left1>right1)\\n               h=cut1-1;\\n               else l=cut1+1;\\n\\n       }\\n       return 0.0;\\n\\n    }\\nTHIS IS STRIVERS SOLUTION BUT IT FAILS FOR EDGE CASE WHEN nums2 IS EMPTY.\\nSOMEONE MODIFY THIS CODE IF U CAN."
                    },
                    {
                        "username": "bgdnvk",
                        "content": "functions to make life easier (TS):\\n\\n```\\nfunction isFloat(n: number): boolean {\\n    return !!(n % 1)\\n}\\n\\nfunction isEven(n: number): boolean {\\n    return n % 2 === 0\\n}\\n\\nfunction getMid(n: number): number {\\n    return Math.floor(n/2)\\n}\\n```"
                    },
                    {
                        "username": "Pratyay_Amrit",
                        "content": "hey..\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "#include<iostream>\\nusing namespace std;\\n    void out(int* p, int s);\\n    void in(int* p, int s);\\n    void merge(int* p1, int* p2, int* p3, int s1, int s3);\\n    void sort(int* m, int s3);\\n    double median(int* m, int s3) {\\n        double med = 0;\\n        if (!(s3 % 2 == 0)) {\\n            return static_cast<double>(*(m + (((s3 + 1) / 2) - 1)));\\n\\n        }\\n        else\\n            return static_cast<double>((*(m + (s3 / 2)-1) + *(m + (s3 / 2))))/2;\\n    }\\nint main() {\\n    int s1=0, s2=0, s3=0;\\n    cin >> s1 >> s2;\\n    int* l1 = new int[s1];\\n    int* l2 = new int[s2];\\n    s3 = s1 + s2;\\n    int* m = new int[s3];\\n    in(l1, s1);\\n    in(l2, s2);\\n    merge(l1, l2, m, s1, s3);\\n    sort(m, s3);\\n    cout << median(m, s3);\\n    return 0;\\n}\\nvoid out(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cout << *(p + i) << \" \";\\n    }\\n    cout << endl;\\n}\\nvoid in(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cin >> p[i];\\n    }\\n}\\nvoid merge(int* p1, int* p2, int* p3, int s1, int s3) {\\n    for (int i = 0; i < s3; i++) {\\n        if (i < s1)\\n            *(p3 + i) = *(p1 + i);\\n        else\\n            p3[i] = *(p2 + (i - s1));\\n    }\\n}\\nvoid sort(int* m, int s3) {\\n    int temp = 0;\\n    for (int i = 0; i < s3; i++) {\\n        for (int j = i + 1; j < s3; j++) {\\n            if (*(m + i) > *(m + j)) {\\n                temp = 0;\\n                temp = *(m + i);\\n                *(m + i) = *(m + j);\\n                *(m + j) = temp;\\n            }\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "why its a compile error its working in visual studio ? "
                    },
                    {
                        "username": "user8219l",
                        "content": "https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/895749408/\\n\\nCan anyone help me why my solutions isnt working...\\nIts failing for nums1= [1] nums2=[2,3] input.\\nStuck on this from quite a few days.\\nplease help!!"
                    },
                    {
                        "username": "A01verma",
                        "content": "I run this code on my Pycharme IDE it did work well for every case, but here not the same result . can someone tell me why is \\n----------------------------------------------------------------------\\nnums1 = [1,2]\\nnums2 = [3,4]\\nfor i in nums2:\\n     nums1.append(i)\\nnums1.sort()\\nif len(nums1) % 2 == 0:\\n     res = (len(nums1) / 2)\\n     res1 = res - 1\\n     mr = (nums1[res] + nums1[res1])\\n     n = mr/2\\n     return(n)\\nelif len(nums1) % 2 == 1:\\n     re = int(len(nums1)/ 2)\\n     return(nums1[re])\\n------------------------------------------------------------------------\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n = nums1.length+nums2.length;\\n        int[] num = new int[n];\\n        int sum=0;\\n        for(int i=0;i<nums1.length;i++){\\n            num[i] = nums1[i];\\n        }\\n        //int j=n -nums1.length;\\n        for(int j=0;j<nums2.length;j++){\\n            num[nums1.length +j]=nums2[j];\\n        }\\n        int min=num[0];\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(num[i]>num[j]){\\n                    min=num[j];\\n                    num[j]=num[i];\\n                    num[i]=min;\\n                }\\n            }\\n           \\n        }\\n        for(int i=0;i<n;i++){\\n            sum =sum+num[i];\\n        }\\n        float g = n;\\n        float med =0;\\n        if(n%2==0){\\n            n = n/2;\\n            float ss = (num[n]+num[n-1] );\\n            med =ss/2;\\n            return med;\\n            \\n        }else{\\n            n = n/2;\\n            med = num[n];\\n            return med;\\n        }\\n      //return med;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1796471,
                "content": [
                    {
                        "username": "iam_avinash",
                        "content": " ArrayList<Integer> list = new ArrayList<>();\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        for(int i=0;i<n;i++){\\n            list.add(nums1[i]);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            list.add(nums2[j]);\\n        }\\n\\n        //sort ArrayList\\n        Collections.sort(list);\\n\\n        int len = list.size();\\n        if(len%2==0){\\n            double median = ((double)list.get(len/2 - 1) + (double)list.get (len/2))/2;\\n            return median;\\n        }else{\\n            double median = ((double)list.get((len+1)/2 - 1));\\n            return median;\\n        }"
                    },
                    {
                        "username": "srushtipatel",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, l1, l2):\\n        m=len(l1)\\n        n = len(l2)\\n        l3 = l1+l2\\n        l3.sort()\\n    \\n        if (m+n)%2 != 0:\\n            med_index = int((m+n)/2)\\n            res = l3[med_index]\\n        if (m+n)%2 == 0:\\n            med_index1 = ((m+n)/2)-1\\n            med_index2 = (m+n)/2\\n            res = (l3[med_index1] + l3[med_index2])/2\\n        return res\\ncan anyone tell me what\\'s the problem in this code.\\nthis is mathematically right code and gives the right output on vscode, but here the following testcase create a problem\\nnums1 =\\n[1,2]\\nnums2 =\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000"
                    },
                    {
                        "username": "Sakthi_01001",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n       answer=0.00000\\n       array=sorted(set(nums1+nums2))\\n       even=len(array)%2==0\\n       if len(array)==2:\\n           return answer+sum(array)/2\\n       elif len(array)==1:\\n           return answer+array[0]\\n       elif even==True:\\n           return answer+(array[(len(array)//2)]+array[(len(array)//2)-1])/2\\n       else:\\n           return answer+array[(len(array)//2)]\\n       return 0\\n\\n\\n\\nI don\\'t know why it\\'s failed at this Test Case \\nnums1=[1,1]\\nnums2=[1,2]\\n\\nthey expecting 1.00000\\nbut the code returns 1.50000\\n\\nbut (1+2)/2=1.5\\nthen what is 1.00000 "
                    },
                    {
                        "username": "prathamrajbhatt",
                        "content": "  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       int n1=nums1.size();\\n       int n2=nums2.size();\\n       if(n1>n2)\\n       findMedianSortedArrays(nums2,nums1);\\n       int l=0,h=n1;\\n       while(l<=h)\\n       {\\n           int cut1=(l+h)/2;\\n           int cut2=(n1+n2+1)/2-cut1;\\n           int left1=cut1==0?INT_MIN:nums1[cut1-1];\\n           int left2=cut2==0?INT_MIN:nums2[cut2-1];\\n            int right1=cut1==n1?INT_MAX:nums1[cut1];\\n           int right2=cut2==n2?INT_MAX:nums2[cut2];\\n          if((left1<=right2)&&(left2<=right1))\\n          {\\n              if((n1+n2)%2==0)\\n              return (max(left1,left2)+min(right1,right2))/2.0;\\n              else return max(left1,left2);\\n          }\\n          else if(left1>right1)\\n               h=cut1-1;\\n               else l=cut1+1;\\n\\n       }\\n       return 0.0;\\n\\n    }\\nTHIS IS STRIVERS SOLUTION BUT IT FAILS FOR EDGE CASE WHEN nums2 IS EMPTY.\\nSOMEONE MODIFY THIS CODE IF U CAN."
                    },
                    {
                        "username": "bgdnvk",
                        "content": "functions to make life easier (TS):\\n\\n```\\nfunction isFloat(n: number): boolean {\\n    return !!(n % 1)\\n}\\n\\nfunction isEven(n: number): boolean {\\n    return n % 2 === 0\\n}\\n\\nfunction getMid(n: number): number {\\n    return Math.floor(n/2)\\n}\\n```"
                    },
                    {
                        "username": "Pratyay_Amrit",
                        "content": "hey..\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "#include<iostream>\\nusing namespace std;\\n    void out(int* p, int s);\\n    void in(int* p, int s);\\n    void merge(int* p1, int* p2, int* p3, int s1, int s3);\\n    void sort(int* m, int s3);\\n    double median(int* m, int s3) {\\n        double med = 0;\\n        if (!(s3 % 2 == 0)) {\\n            return static_cast<double>(*(m + (((s3 + 1) / 2) - 1)));\\n\\n        }\\n        else\\n            return static_cast<double>((*(m + (s3 / 2)-1) + *(m + (s3 / 2))))/2;\\n    }\\nint main() {\\n    int s1=0, s2=0, s3=0;\\n    cin >> s1 >> s2;\\n    int* l1 = new int[s1];\\n    int* l2 = new int[s2];\\n    s3 = s1 + s2;\\n    int* m = new int[s3];\\n    in(l1, s1);\\n    in(l2, s2);\\n    merge(l1, l2, m, s1, s3);\\n    sort(m, s3);\\n    cout << median(m, s3);\\n    return 0;\\n}\\nvoid out(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cout << *(p + i) << \" \";\\n    }\\n    cout << endl;\\n}\\nvoid in(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cin >> p[i];\\n    }\\n}\\nvoid merge(int* p1, int* p2, int* p3, int s1, int s3) {\\n    for (int i = 0; i < s3; i++) {\\n        if (i < s1)\\n            *(p3 + i) = *(p1 + i);\\n        else\\n            p3[i] = *(p2 + (i - s1));\\n    }\\n}\\nvoid sort(int* m, int s3) {\\n    int temp = 0;\\n    for (int i = 0; i < s3; i++) {\\n        for (int j = i + 1; j < s3; j++) {\\n            if (*(m + i) > *(m + j)) {\\n                temp = 0;\\n                temp = *(m + i);\\n                *(m + i) = *(m + j);\\n                *(m + j) = temp;\\n            }\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "why its a compile error its working in visual studio ? "
                    },
                    {
                        "username": "user8219l",
                        "content": "https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/895749408/\\n\\nCan anyone help me why my solutions isnt working...\\nIts failing for nums1= [1] nums2=[2,3] input.\\nStuck on this from quite a few days.\\nplease help!!"
                    },
                    {
                        "username": "A01verma",
                        "content": "I run this code on my Pycharme IDE it did work well for every case, but here not the same result . can someone tell me why is \\n----------------------------------------------------------------------\\nnums1 = [1,2]\\nnums2 = [3,4]\\nfor i in nums2:\\n     nums1.append(i)\\nnums1.sort()\\nif len(nums1) % 2 == 0:\\n     res = (len(nums1) / 2)\\n     res1 = res - 1\\n     mr = (nums1[res] + nums1[res1])\\n     n = mr/2\\n     return(n)\\nelif len(nums1) % 2 == 1:\\n     re = int(len(nums1)/ 2)\\n     return(nums1[re])\\n------------------------------------------------------------------------\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n = nums1.length+nums2.length;\\n        int[] num = new int[n];\\n        int sum=0;\\n        for(int i=0;i<nums1.length;i++){\\n            num[i] = nums1[i];\\n        }\\n        //int j=n -nums1.length;\\n        for(int j=0;j<nums2.length;j++){\\n            num[nums1.length +j]=nums2[j];\\n        }\\n        int min=num[0];\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(num[i]>num[j]){\\n                    min=num[j];\\n                    num[j]=num[i];\\n                    num[i]=min;\\n                }\\n            }\\n           \\n        }\\n        for(int i=0;i<n;i++){\\n            sum =sum+num[i];\\n        }\\n        float g = n;\\n        float med =0;\\n        if(n%2==0){\\n            n = n/2;\\n            float ss = (num[n]+num[n-1] );\\n            med =ss/2;\\n            return med;\\n            \\n        }else{\\n            n = n/2;\\n            med = num[n];\\n            return med;\\n        }\\n      //return med;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1796374,
                "content": [
                    {
                        "username": "iam_avinash",
                        "content": " ArrayList<Integer> list = new ArrayList<>();\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        for(int i=0;i<n;i++){\\n            list.add(nums1[i]);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            list.add(nums2[j]);\\n        }\\n\\n        //sort ArrayList\\n        Collections.sort(list);\\n\\n        int len = list.size();\\n        if(len%2==0){\\n            double median = ((double)list.get(len/2 - 1) + (double)list.get (len/2))/2;\\n            return median;\\n        }else{\\n            double median = ((double)list.get((len+1)/2 - 1));\\n            return median;\\n        }"
                    },
                    {
                        "username": "srushtipatel",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, l1, l2):\\n        m=len(l1)\\n        n = len(l2)\\n        l3 = l1+l2\\n        l3.sort()\\n    \\n        if (m+n)%2 != 0:\\n            med_index = int((m+n)/2)\\n            res = l3[med_index]\\n        if (m+n)%2 == 0:\\n            med_index1 = ((m+n)/2)-1\\n            med_index2 = (m+n)/2\\n            res = (l3[med_index1] + l3[med_index2])/2\\n        return res\\ncan anyone tell me what\\'s the problem in this code.\\nthis is mathematically right code and gives the right output on vscode, but here the following testcase create a problem\\nnums1 =\\n[1,2]\\nnums2 =\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000"
                    },
                    {
                        "username": "Sakthi_01001",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n       answer=0.00000\\n       array=sorted(set(nums1+nums2))\\n       even=len(array)%2==0\\n       if len(array)==2:\\n           return answer+sum(array)/2\\n       elif len(array)==1:\\n           return answer+array[0]\\n       elif even==True:\\n           return answer+(array[(len(array)//2)]+array[(len(array)//2)-1])/2\\n       else:\\n           return answer+array[(len(array)//2)]\\n       return 0\\n\\n\\n\\nI don\\'t know why it\\'s failed at this Test Case \\nnums1=[1,1]\\nnums2=[1,2]\\n\\nthey expecting 1.00000\\nbut the code returns 1.50000\\n\\nbut (1+2)/2=1.5\\nthen what is 1.00000 "
                    },
                    {
                        "username": "prathamrajbhatt",
                        "content": "  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       int n1=nums1.size();\\n       int n2=nums2.size();\\n       if(n1>n2)\\n       findMedianSortedArrays(nums2,nums1);\\n       int l=0,h=n1;\\n       while(l<=h)\\n       {\\n           int cut1=(l+h)/2;\\n           int cut2=(n1+n2+1)/2-cut1;\\n           int left1=cut1==0?INT_MIN:nums1[cut1-1];\\n           int left2=cut2==0?INT_MIN:nums2[cut2-1];\\n            int right1=cut1==n1?INT_MAX:nums1[cut1];\\n           int right2=cut2==n2?INT_MAX:nums2[cut2];\\n          if((left1<=right2)&&(left2<=right1))\\n          {\\n              if((n1+n2)%2==0)\\n              return (max(left1,left2)+min(right1,right2))/2.0;\\n              else return max(left1,left2);\\n          }\\n          else if(left1>right1)\\n               h=cut1-1;\\n               else l=cut1+1;\\n\\n       }\\n       return 0.0;\\n\\n    }\\nTHIS IS STRIVERS SOLUTION BUT IT FAILS FOR EDGE CASE WHEN nums2 IS EMPTY.\\nSOMEONE MODIFY THIS CODE IF U CAN."
                    },
                    {
                        "username": "bgdnvk",
                        "content": "functions to make life easier (TS):\\n\\n```\\nfunction isFloat(n: number): boolean {\\n    return !!(n % 1)\\n}\\n\\nfunction isEven(n: number): boolean {\\n    return n % 2 === 0\\n}\\n\\nfunction getMid(n: number): number {\\n    return Math.floor(n/2)\\n}\\n```"
                    },
                    {
                        "username": "Pratyay_Amrit",
                        "content": "hey..\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "#include<iostream>\\nusing namespace std;\\n    void out(int* p, int s);\\n    void in(int* p, int s);\\n    void merge(int* p1, int* p2, int* p3, int s1, int s3);\\n    void sort(int* m, int s3);\\n    double median(int* m, int s3) {\\n        double med = 0;\\n        if (!(s3 % 2 == 0)) {\\n            return static_cast<double>(*(m + (((s3 + 1) / 2) - 1)));\\n\\n        }\\n        else\\n            return static_cast<double>((*(m + (s3 / 2)-1) + *(m + (s3 / 2))))/2;\\n    }\\nint main() {\\n    int s1=0, s2=0, s3=0;\\n    cin >> s1 >> s2;\\n    int* l1 = new int[s1];\\n    int* l2 = new int[s2];\\n    s3 = s1 + s2;\\n    int* m = new int[s3];\\n    in(l1, s1);\\n    in(l2, s2);\\n    merge(l1, l2, m, s1, s3);\\n    sort(m, s3);\\n    cout << median(m, s3);\\n    return 0;\\n}\\nvoid out(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cout << *(p + i) << \" \";\\n    }\\n    cout << endl;\\n}\\nvoid in(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cin >> p[i];\\n    }\\n}\\nvoid merge(int* p1, int* p2, int* p3, int s1, int s3) {\\n    for (int i = 0; i < s3; i++) {\\n        if (i < s1)\\n            *(p3 + i) = *(p1 + i);\\n        else\\n            p3[i] = *(p2 + (i - s1));\\n    }\\n}\\nvoid sort(int* m, int s3) {\\n    int temp = 0;\\n    for (int i = 0; i < s3; i++) {\\n        for (int j = i + 1; j < s3; j++) {\\n            if (*(m + i) > *(m + j)) {\\n                temp = 0;\\n                temp = *(m + i);\\n                *(m + i) = *(m + j);\\n                *(m + j) = temp;\\n            }\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "why its a compile error its working in visual studio ? "
                    },
                    {
                        "username": "user8219l",
                        "content": "https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/895749408/\\n\\nCan anyone help me why my solutions isnt working...\\nIts failing for nums1= [1] nums2=[2,3] input.\\nStuck on this from quite a few days.\\nplease help!!"
                    },
                    {
                        "username": "A01verma",
                        "content": "I run this code on my Pycharme IDE it did work well for every case, but here not the same result . can someone tell me why is \\n----------------------------------------------------------------------\\nnums1 = [1,2]\\nnums2 = [3,4]\\nfor i in nums2:\\n     nums1.append(i)\\nnums1.sort()\\nif len(nums1) % 2 == 0:\\n     res = (len(nums1) / 2)\\n     res1 = res - 1\\n     mr = (nums1[res] + nums1[res1])\\n     n = mr/2\\n     return(n)\\nelif len(nums1) % 2 == 1:\\n     re = int(len(nums1)/ 2)\\n     return(nums1[re])\\n------------------------------------------------------------------------\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n = nums1.length+nums2.length;\\n        int[] num = new int[n];\\n        int sum=0;\\n        for(int i=0;i<nums1.length;i++){\\n            num[i] = nums1[i];\\n        }\\n        //int j=n -nums1.length;\\n        for(int j=0;j<nums2.length;j++){\\n            num[nums1.length +j]=nums2[j];\\n        }\\n        int min=num[0];\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(num[i]>num[j]){\\n                    min=num[j];\\n                    num[j]=num[i];\\n                    num[i]=min;\\n                }\\n            }\\n           \\n        }\\n        for(int i=0;i<n;i++){\\n            sum =sum+num[i];\\n        }\\n        float g = n;\\n        float med =0;\\n        if(n%2==0){\\n            n = n/2;\\n            float ss = (num[n]+num[n-1] );\\n            med =ss/2;\\n            return med;\\n            \\n        }else{\\n            n = n/2;\\n            med = num[n];\\n            return med;\\n        }\\n      //return med;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1794774,
                "content": [
                    {
                        "username": "iam_avinash",
                        "content": " ArrayList<Integer> list = new ArrayList<>();\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        for(int i=0;i<n;i++){\\n            list.add(nums1[i]);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            list.add(nums2[j]);\\n        }\\n\\n        //sort ArrayList\\n        Collections.sort(list);\\n\\n        int len = list.size();\\n        if(len%2==0){\\n            double median = ((double)list.get(len/2 - 1) + (double)list.get (len/2))/2;\\n            return median;\\n        }else{\\n            double median = ((double)list.get((len+1)/2 - 1));\\n            return median;\\n        }"
                    },
                    {
                        "username": "srushtipatel",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, l1, l2):\\n        m=len(l1)\\n        n = len(l2)\\n        l3 = l1+l2\\n        l3.sort()\\n    \\n        if (m+n)%2 != 0:\\n            med_index = int((m+n)/2)\\n            res = l3[med_index]\\n        if (m+n)%2 == 0:\\n            med_index1 = ((m+n)/2)-1\\n            med_index2 = (m+n)/2\\n            res = (l3[med_index1] + l3[med_index2])/2\\n        return res\\ncan anyone tell me what\\'s the problem in this code.\\nthis is mathematically right code and gives the right output on vscode, but here the following testcase create a problem\\nnums1 =\\n[1,2]\\nnums2 =\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000"
                    },
                    {
                        "username": "Sakthi_01001",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n       answer=0.00000\\n       array=sorted(set(nums1+nums2))\\n       even=len(array)%2==0\\n       if len(array)==2:\\n           return answer+sum(array)/2\\n       elif len(array)==1:\\n           return answer+array[0]\\n       elif even==True:\\n           return answer+(array[(len(array)//2)]+array[(len(array)//2)-1])/2\\n       else:\\n           return answer+array[(len(array)//2)]\\n       return 0\\n\\n\\n\\nI don\\'t know why it\\'s failed at this Test Case \\nnums1=[1,1]\\nnums2=[1,2]\\n\\nthey expecting 1.00000\\nbut the code returns 1.50000\\n\\nbut (1+2)/2=1.5\\nthen what is 1.00000 "
                    },
                    {
                        "username": "prathamrajbhatt",
                        "content": "  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       int n1=nums1.size();\\n       int n2=nums2.size();\\n       if(n1>n2)\\n       findMedianSortedArrays(nums2,nums1);\\n       int l=0,h=n1;\\n       while(l<=h)\\n       {\\n           int cut1=(l+h)/2;\\n           int cut2=(n1+n2+1)/2-cut1;\\n           int left1=cut1==0?INT_MIN:nums1[cut1-1];\\n           int left2=cut2==0?INT_MIN:nums2[cut2-1];\\n            int right1=cut1==n1?INT_MAX:nums1[cut1];\\n           int right2=cut2==n2?INT_MAX:nums2[cut2];\\n          if((left1<=right2)&&(left2<=right1))\\n          {\\n              if((n1+n2)%2==0)\\n              return (max(left1,left2)+min(right1,right2))/2.0;\\n              else return max(left1,left2);\\n          }\\n          else if(left1>right1)\\n               h=cut1-1;\\n               else l=cut1+1;\\n\\n       }\\n       return 0.0;\\n\\n    }\\nTHIS IS STRIVERS SOLUTION BUT IT FAILS FOR EDGE CASE WHEN nums2 IS EMPTY.\\nSOMEONE MODIFY THIS CODE IF U CAN."
                    },
                    {
                        "username": "bgdnvk",
                        "content": "functions to make life easier (TS):\\n\\n```\\nfunction isFloat(n: number): boolean {\\n    return !!(n % 1)\\n}\\n\\nfunction isEven(n: number): boolean {\\n    return n % 2 === 0\\n}\\n\\nfunction getMid(n: number): number {\\n    return Math.floor(n/2)\\n}\\n```"
                    },
                    {
                        "username": "Pratyay_Amrit",
                        "content": "hey..\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "#include<iostream>\\nusing namespace std;\\n    void out(int* p, int s);\\n    void in(int* p, int s);\\n    void merge(int* p1, int* p2, int* p3, int s1, int s3);\\n    void sort(int* m, int s3);\\n    double median(int* m, int s3) {\\n        double med = 0;\\n        if (!(s3 % 2 == 0)) {\\n            return static_cast<double>(*(m + (((s3 + 1) / 2) - 1)));\\n\\n        }\\n        else\\n            return static_cast<double>((*(m + (s3 / 2)-1) + *(m + (s3 / 2))))/2;\\n    }\\nint main() {\\n    int s1=0, s2=0, s3=0;\\n    cin >> s1 >> s2;\\n    int* l1 = new int[s1];\\n    int* l2 = new int[s2];\\n    s3 = s1 + s2;\\n    int* m = new int[s3];\\n    in(l1, s1);\\n    in(l2, s2);\\n    merge(l1, l2, m, s1, s3);\\n    sort(m, s3);\\n    cout << median(m, s3);\\n    return 0;\\n}\\nvoid out(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cout << *(p + i) << \" \";\\n    }\\n    cout << endl;\\n}\\nvoid in(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cin >> p[i];\\n    }\\n}\\nvoid merge(int* p1, int* p2, int* p3, int s1, int s3) {\\n    for (int i = 0; i < s3; i++) {\\n        if (i < s1)\\n            *(p3 + i) = *(p1 + i);\\n        else\\n            p3[i] = *(p2 + (i - s1));\\n    }\\n}\\nvoid sort(int* m, int s3) {\\n    int temp = 0;\\n    for (int i = 0; i < s3; i++) {\\n        for (int j = i + 1; j < s3; j++) {\\n            if (*(m + i) > *(m + j)) {\\n                temp = 0;\\n                temp = *(m + i);\\n                *(m + i) = *(m + j);\\n                *(m + j) = temp;\\n            }\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "why its a compile error its working in visual studio ? "
                    },
                    {
                        "username": "user8219l",
                        "content": "https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/895749408/\\n\\nCan anyone help me why my solutions isnt working...\\nIts failing for nums1= [1] nums2=[2,3] input.\\nStuck on this from quite a few days.\\nplease help!!"
                    },
                    {
                        "username": "A01verma",
                        "content": "I run this code on my Pycharme IDE it did work well for every case, but here not the same result . can someone tell me why is \\n----------------------------------------------------------------------\\nnums1 = [1,2]\\nnums2 = [3,4]\\nfor i in nums2:\\n     nums1.append(i)\\nnums1.sort()\\nif len(nums1) % 2 == 0:\\n     res = (len(nums1) / 2)\\n     res1 = res - 1\\n     mr = (nums1[res] + nums1[res1])\\n     n = mr/2\\n     return(n)\\nelif len(nums1) % 2 == 1:\\n     re = int(len(nums1)/ 2)\\n     return(nums1[re])\\n------------------------------------------------------------------------\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n = nums1.length+nums2.length;\\n        int[] num = new int[n];\\n        int sum=0;\\n        for(int i=0;i<nums1.length;i++){\\n            num[i] = nums1[i];\\n        }\\n        //int j=n -nums1.length;\\n        for(int j=0;j<nums2.length;j++){\\n            num[nums1.length +j]=nums2[j];\\n        }\\n        int min=num[0];\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(num[i]>num[j]){\\n                    min=num[j];\\n                    num[j]=num[i];\\n                    num[i]=min;\\n                }\\n            }\\n           \\n        }\\n        for(int i=0;i<n;i++){\\n            sum =sum+num[i];\\n        }\\n        float g = n;\\n        float med =0;\\n        if(n%2==0){\\n            n = n/2;\\n            float ss = (num[n]+num[n-1] );\\n            med =ss/2;\\n            return med;\\n            \\n        }else{\\n            n = n/2;\\n            med = num[n];\\n            return med;\\n        }\\n      //return med;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1794271,
                "content": [
                    {
                        "username": "iam_avinash",
                        "content": " ArrayList<Integer> list = new ArrayList<>();\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        for(int i=0;i<n;i++){\\n            list.add(nums1[i]);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            list.add(nums2[j]);\\n        }\\n\\n        //sort ArrayList\\n        Collections.sort(list);\\n\\n        int len = list.size();\\n        if(len%2==0){\\n            double median = ((double)list.get(len/2 - 1) + (double)list.get (len/2))/2;\\n            return median;\\n        }else{\\n            double median = ((double)list.get((len+1)/2 - 1));\\n            return median;\\n        }"
                    },
                    {
                        "username": "srushtipatel",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, l1, l2):\\n        m=len(l1)\\n        n = len(l2)\\n        l3 = l1+l2\\n        l3.sort()\\n    \\n        if (m+n)%2 != 0:\\n            med_index = int((m+n)/2)\\n            res = l3[med_index]\\n        if (m+n)%2 == 0:\\n            med_index1 = ((m+n)/2)-1\\n            med_index2 = (m+n)/2\\n            res = (l3[med_index1] + l3[med_index2])/2\\n        return res\\ncan anyone tell me what\\'s the problem in this code.\\nthis is mathematically right code and gives the right output on vscode, but here the following testcase create a problem\\nnums1 =\\n[1,2]\\nnums2 =\\n[3,4]\\nOutput\\n2.00000\\nExpected\\n2.50000"
                    },
                    {
                        "username": "Sakthi_01001",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n       answer=0.00000\\n       array=sorted(set(nums1+nums2))\\n       even=len(array)%2==0\\n       if len(array)==2:\\n           return answer+sum(array)/2\\n       elif len(array)==1:\\n           return answer+array[0]\\n       elif even==True:\\n           return answer+(array[(len(array)//2)]+array[(len(array)//2)-1])/2\\n       else:\\n           return answer+array[(len(array)//2)]\\n       return 0\\n\\n\\n\\nI don\\'t know why it\\'s failed at this Test Case \\nnums1=[1,1]\\nnums2=[1,2]\\n\\nthey expecting 1.00000\\nbut the code returns 1.50000\\n\\nbut (1+2)/2=1.5\\nthen what is 1.00000 "
                    },
                    {
                        "username": "prathamrajbhatt",
                        "content": "  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       int n1=nums1.size();\\n       int n2=nums2.size();\\n       if(n1>n2)\\n       findMedianSortedArrays(nums2,nums1);\\n       int l=0,h=n1;\\n       while(l<=h)\\n       {\\n           int cut1=(l+h)/2;\\n           int cut2=(n1+n2+1)/2-cut1;\\n           int left1=cut1==0?INT_MIN:nums1[cut1-1];\\n           int left2=cut2==0?INT_MIN:nums2[cut2-1];\\n            int right1=cut1==n1?INT_MAX:nums1[cut1];\\n           int right2=cut2==n2?INT_MAX:nums2[cut2];\\n          if((left1<=right2)&&(left2<=right1))\\n          {\\n              if((n1+n2)%2==0)\\n              return (max(left1,left2)+min(right1,right2))/2.0;\\n              else return max(left1,left2);\\n          }\\n          else if(left1>right1)\\n               h=cut1-1;\\n               else l=cut1+1;\\n\\n       }\\n       return 0.0;\\n\\n    }\\nTHIS IS STRIVERS SOLUTION BUT IT FAILS FOR EDGE CASE WHEN nums2 IS EMPTY.\\nSOMEONE MODIFY THIS CODE IF U CAN."
                    },
                    {
                        "username": "bgdnvk",
                        "content": "functions to make life easier (TS):\\n\\n```\\nfunction isFloat(n: number): boolean {\\n    return !!(n % 1)\\n}\\n\\nfunction isEven(n: number): boolean {\\n    return n % 2 === 0\\n}\\n\\nfunction getMid(n: number): number {\\n    return Math.floor(n/2)\\n}\\n```"
                    },
                    {
                        "username": "Pratyay_Amrit",
                        "content": "hey..\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "#include<iostream>\\nusing namespace std;\\n    void out(int* p, int s);\\n    void in(int* p, int s);\\n    void merge(int* p1, int* p2, int* p3, int s1, int s3);\\n    void sort(int* m, int s3);\\n    double median(int* m, int s3) {\\n        double med = 0;\\n        if (!(s3 % 2 == 0)) {\\n            return static_cast<double>(*(m + (((s3 + 1) / 2) - 1)));\\n\\n        }\\n        else\\n            return static_cast<double>((*(m + (s3 / 2)-1) + *(m + (s3 / 2))))/2;\\n    }\\nint main() {\\n    int s1=0, s2=0, s3=0;\\n    cin >> s1 >> s2;\\n    int* l1 = new int[s1];\\n    int* l2 = new int[s2];\\n    s3 = s1 + s2;\\n    int* m = new int[s3];\\n    in(l1, s1);\\n    in(l2, s2);\\n    merge(l1, l2, m, s1, s3);\\n    sort(m, s3);\\n    cout << median(m, s3);\\n    return 0;\\n}\\nvoid out(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cout << *(p + i) << \" \";\\n    }\\n    cout << endl;\\n}\\nvoid in(int* p, int s)\\n{\\n    for (int i = 0; i < s; i++) {\\n        cin >> p[i];\\n    }\\n}\\nvoid merge(int* p1, int* p2, int* p3, int s1, int s3) {\\n    for (int i = 0; i < s3; i++) {\\n        if (i < s1)\\n            *(p3 + i) = *(p1 + i);\\n        else\\n            p3[i] = *(p2 + (i - s1));\\n    }\\n}\\nvoid sort(int* m, int s3) {\\n    int temp = 0;\\n    for (int i = 0; i < s3; i++) {\\n        for (int j = i + 1; j < s3; j++) {\\n            if (*(m + i) > *(m + j)) {\\n                temp = 0;\\n                temp = *(m + i);\\n                *(m + i) = *(m + j);\\n                *(m + j) = temp;\\n            }\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ham_Chi_Pak",
                        "content": "why its a compile error its working in visual studio ? "
                    },
                    {
                        "username": "user8219l",
                        "content": "https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/895749408/\\n\\nCan anyone help me why my solutions isnt working...\\nIts failing for nums1= [1] nums2=[2,3] input.\\nStuck on this from quite a few days.\\nplease help!!"
                    },
                    {
                        "username": "A01verma",
                        "content": "I run this code on my Pycharme IDE it did work well for every case, but here not the same result . can someone tell me why is \\n----------------------------------------------------------------------\\nnums1 = [1,2]\\nnums2 = [3,4]\\nfor i in nums2:\\n     nums1.append(i)\\nnums1.sort()\\nif len(nums1) % 2 == 0:\\n     res = (len(nums1) / 2)\\n     res1 = res - 1\\n     mr = (nums1[res] + nums1[res1])\\n     n = mr/2\\n     return(n)\\nelif len(nums1) % 2 == 1:\\n     re = int(len(nums1)/ 2)\\n     return(nums1[re])\\n------------------------------------------------------------------------\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int n = nums1.length+nums2.length;\\n        int[] num = new int[n];\\n        int sum=0;\\n        for(int i=0;i<nums1.length;i++){\\n            num[i] = nums1[i];\\n        }\\n        //int j=n -nums1.length;\\n        for(int j=0;j<nums2.length;j++){\\n            num[nums1.length +j]=nums2[j];\\n        }\\n        int min=num[0];\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(num[i]>num[j]){\\n                    min=num[j];\\n                    num[j]=num[i];\\n                    num[i]=min;\\n                }\\n            }\\n           \\n        }\\n        for(int i=0;i<n;i++){\\n            sum =sum+num[i];\\n        }\\n        float g = n;\\n        float med =0;\\n        if(n%2==0){\\n            n = n/2;\\n            float ss = (num[n]+num[n-1] );\\n            med =ss/2;\\n            return med;\\n            \\n        }else{\\n            n = n/2;\\n            med = num[n];\\n            return med;\\n        }\\n      //return med;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1794260,
                "content": [
                    {
                        "username": "tanayas13",
                        "content": "it\\'s clearly stated in the question that an O(log n) solution is required and that\\'s why it is marked as hard but weirdly it accepted my O(m + n) solution after merging the array : /"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n     int l1=nums1.length;\\n    int l2=nums2.length;\\n    int c=(l1+l2)/2;\\n    c++;\\n    double m=0, n=0;\\n    boolean odd=true;\\n    if((l1+l2)%2==0){\\n      odd=false;\\n    }\\n    int p1=0, p2=0;\\n    while(c-->0){\\n      n=m;\\n      int p1v=getp(nums1, p1);\\n      int p2v=getp(nums2, p2);\\n      if(p1v<p2v){\\n        m=nums1[p1++];\\n      }\\n      else{\\n        m=nums2[p2++];\\n      }\\n    }\\n    if(!odd){\\n      return new Double ((m+n)/2);\\n    }\\n    return m;\\n    }\\n    public static int getp(int [] db, int p){\\n    if(p>=db.length){\\n      return Integer.MAX_VALUE;\\n    }\\n    return db[p];\\n  }\\n}"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "It is the basis of merge sort!"
                    },
                    {
                        "username": "pozitron",
                        "content": "I might be missing something but do not get why this is deemed hard.\\nThis task is a part of merge sort algo (as one might guess - the merge part of it).\\nIt can be solved with O(n+m) complexity for both time and space.\\n\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/submissions/892496342/"
                    },
                    {
                        "username": "pozitron",
                        "content": "finally got why this is hard. O(n+m) is greater than O(log(n+m)) :-)"
                    },
                    {
                        "username": "Lucario123",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        join_arr = nums1+nums2\\n        join_arr.sort()\\n        if (len(join_arr)%2==0):\\n            n =len(join_arr)//2\\n            median = (join_arr[n]+join_arr[n-1])/2\\n            return median\\n        else:\\n            n =len(join_arr)//2\\n            median = join_arr[n]\\n            return median\\n"
                    },
                    {
                        "username": "kitie",
                        "content": "Why was this \\u201Cdifficult task\\u201D so easy?"
                    },
                    {
                        "username": "rjskomal",
                        "content": "Your solution takes O((n+m)*log(n+m)) time because you sorted the arrays again. Try using Binary Search to reduce the TC without sorting again... "
                    },
                    {
                        "username": "priti_sarkar",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int i =0 , j =0;\\n        int size_num1 = nums1.size();\\n        int size_num2 = nums2.size();\\n        \\n        while(size_num1>i || size_num2>j){\\n             ans.push_back(nums1[i]);\\n                i++;\\n        }\\n        while(size_num2>j){\\n             ans.push_back(nums2[j]);\\n               j++;\\n        }\\n        sort(ans.begin(),ans.end());\\n        int ans_size = ans.size();\\n        float mid = ans_size/2;\\n        if (ans_size % 2 == 0){\\n            float median = float (ans[mid]+ans[mid-1])/2;\\n            // double a1 = double(ab)/2;\\n            return median;\\n        }\\n        else{\\n            return ans[mid];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "qatestpavan5",
                        "content": "As i worked on few median problems in my math classes in college, the mean of the median of the two lists will be approximately equal to the combined array medium with large data sets and it may work with the given test cases. will this be a viable solution here?. Will this be a viable solution where accuracy is not needed?."
                    },
                    {
                        "username": "BudVic",
                        "content": "Unfortunately, the tests do not check the algorithmic complexity in any way. And one of the shortest solutions I\\'ve come across has a time complexity of O(nlogn), which is higher than the O(log(m+n)) we expected.\\n\\nIt uses the array_merge function to merge two arrays, and then the sort function to sort the array. Finally, it uses the ceil function and formula to calculate the median index. If the number of elements in the array is even, it returns the average of the two elements of the median, otherwise it returns the median value.\\n\\nYou can improve this code by using a merge algorithm or binary search to reduce the time complexity."
                    },
                    {
                        "username": "Rakesh_Indupuri",
                        "content": "Java Easy solution for understanding\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] result = new int[nums1.length+nums2.length];\\n        int index1=0;\\n        int index2=0;\\n        int indexRes=0;\\n        while(index1<nums1.length&&index2<nums2.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        while(index1<nums1.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n        }\\n        while(index2<nums2.length)\\n        {\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        Arrays.sort(result);\\n        int start=0;\\n        int end = result.length-1;\\n        double median;\\n        if(result.length%2==0)\\n        {\\n            double x = result[(start+end)/2];\\n            double y = result[((start+end)/2)+1];\\n            median=(x+y)/2;\\n        }\\n        else\\n        {\\n            median=result[(start+end)/2];\\n        }\\n        return median;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1793679,
                "content": [
                    {
                        "username": "tanayas13",
                        "content": "it\\'s clearly stated in the question that an O(log n) solution is required and that\\'s why it is marked as hard but weirdly it accepted my O(m + n) solution after merging the array : /"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n     int l1=nums1.length;\\n    int l2=nums2.length;\\n    int c=(l1+l2)/2;\\n    c++;\\n    double m=0, n=0;\\n    boolean odd=true;\\n    if((l1+l2)%2==0){\\n      odd=false;\\n    }\\n    int p1=0, p2=0;\\n    while(c-->0){\\n      n=m;\\n      int p1v=getp(nums1, p1);\\n      int p2v=getp(nums2, p2);\\n      if(p1v<p2v){\\n        m=nums1[p1++];\\n      }\\n      else{\\n        m=nums2[p2++];\\n      }\\n    }\\n    if(!odd){\\n      return new Double ((m+n)/2);\\n    }\\n    return m;\\n    }\\n    public static int getp(int [] db, int p){\\n    if(p>=db.length){\\n      return Integer.MAX_VALUE;\\n    }\\n    return db[p];\\n  }\\n}"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "It is the basis of merge sort!"
                    },
                    {
                        "username": "pozitron",
                        "content": "I might be missing something but do not get why this is deemed hard.\\nThis task is a part of merge sort algo (as one might guess - the merge part of it).\\nIt can be solved with O(n+m) complexity for both time and space.\\n\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/submissions/892496342/"
                    },
                    {
                        "username": "pozitron",
                        "content": "finally got why this is hard. O(n+m) is greater than O(log(n+m)) :-)"
                    },
                    {
                        "username": "Lucario123",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        join_arr = nums1+nums2\\n        join_arr.sort()\\n        if (len(join_arr)%2==0):\\n            n =len(join_arr)//2\\n            median = (join_arr[n]+join_arr[n-1])/2\\n            return median\\n        else:\\n            n =len(join_arr)//2\\n            median = join_arr[n]\\n            return median\\n"
                    },
                    {
                        "username": "kitie",
                        "content": "Why was this \\u201Cdifficult task\\u201D so easy?"
                    },
                    {
                        "username": "rjskomal",
                        "content": "Your solution takes O((n+m)*log(n+m)) time because you sorted the arrays again. Try using Binary Search to reduce the TC without sorting again... "
                    },
                    {
                        "username": "priti_sarkar",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int i =0 , j =0;\\n        int size_num1 = nums1.size();\\n        int size_num2 = nums2.size();\\n        \\n        while(size_num1>i || size_num2>j){\\n             ans.push_back(nums1[i]);\\n                i++;\\n        }\\n        while(size_num2>j){\\n             ans.push_back(nums2[j]);\\n               j++;\\n        }\\n        sort(ans.begin(),ans.end());\\n        int ans_size = ans.size();\\n        float mid = ans_size/2;\\n        if (ans_size % 2 == 0){\\n            float median = float (ans[mid]+ans[mid-1])/2;\\n            // double a1 = double(ab)/2;\\n            return median;\\n        }\\n        else{\\n            return ans[mid];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "qatestpavan5",
                        "content": "As i worked on few median problems in my math classes in college, the mean of the median of the two lists will be approximately equal to the combined array medium with large data sets and it may work with the given test cases. will this be a viable solution here?. Will this be a viable solution where accuracy is not needed?."
                    },
                    {
                        "username": "BudVic",
                        "content": "Unfortunately, the tests do not check the algorithmic complexity in any way. And one of the shortest solutions I\\'ve come across has a time complexity of O(nlogn), which is higher than the O(log(m+n)) we expected.\\n\\nIt uses the array_merge function to merge two arrays, and then the sort function to sort the array. Finally, it uses the ceil function and formula to calculate the median index. If the number of elements in the array is even, it returns the average of the two elements of the median, otherwise it returns the median value.\\n\\nYou can improve this code by using a merge algorithm or binary search to reduce the time complexity."
                    },
                    {
                        "username": "Rakesh_Indupuri",
                        "content": "Java Easy solution for understanding\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] result = new int[nums1.length+nums2.length];\\n        int index1=0;\\n        int index2=0;\\n        int indexRes=0;\\n        while(index1<nums1.length&&index2<nums2.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        while(index1<nums1.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n        }\\n        while(index2<nums2.length)\\n        {\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        Arrays.sort(result);\\n        int start=0;\\n        int end = result.length-1;\\n        double median;\\n        if(result.length%2==0)\\n        {\\n            double x = result[(start+end)/2];\\n            double y = result[((start+end)/2)+1];\\n            median=(x+y)/2;\\n        }\\n        else\\n        {\\n            median=result[(start+end)/2];\\n        }\\n        return median;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1792162,
                "content": [
                    {
                        "username": "tanayas13",
                        "content": "it\\'s clearly stated in the question that an O(log n) solution is required and that\\'s why it is marked as hard but weirdly it accepted my O(m + n) solution after merging the array : /"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n     int l1=nums1.length;\\n    int l2=nums2.length;\\n    int c=(l1+l2)/2;\\n    c++;\\n    double m=0, n=0;\\n    boolean odd=true;\\n    if((l1+l2)%2==0){\\n      odd=false;\\n    }\\n    int p1=0, p2=0;\\n    while(c-->0){\\n      n=m;\\n      int p1v=getp(nums1, p1);\\n      int p2v=getp(nums2, p2);\\n      if(p1v<p2v){\\n        m=nums1[p1++];\\n      }\\n      else{\\n        m=nums2[p2++];\\n      }\\n    }\\n    if(!odd){\\n      return new Double ((m+n)/2);\\n    }\\n    return m;\\n    }\\n    public static int getp(int [] db, int p){\\n    if(p>=db.length){\\n      return Integer.MAX_VALUE;\\n    }\\n    return db[p];\\n  }\\n}"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "It is the basis of merge sort!"
                    },
                    {
                        "username": "pozitron",
                        "content": "I might be missing something but do not get why this is deemed hard.\\nThis task is a part of merge sort algo (as one might guess - the merge part of it).\\nIt can be solved with O(n+m) complexity for both time and space.\\n\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/submissions/892496342/"
                    },
                    {
                        "username": "pozitron",
                        "content": "finally got why this is hard. O(n+m) is greater than O(log(n+m)) :-)"
                    },
                    {
                        "username": "Lucario123",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        join_arr = nums1+nums2\\n        join_arr.sort()\\n        if (len(join_arr)%2==0):\\n            n =len(join_arr)//2\\n            median = (join_arr[n]+join_arr[n-1])/2\\n            return median\\n        else:\\n            n =len(join_arr)//2\\n            median = join_arr[n]\\n            return median\\n"
                    },
                    {
                        "username": "kitie",
                        "content": "Why was this \\u201Cdifficult task\\u201D so easy?"
                    },
                    {
                        "username": "rjskomal",
                        "content": "Your solution takes O((n+m)*log(n+m)) time because you sorted the arrays again. Try using Binary Search to reduce the TC without sorting again... "
                    },
                    {
                        "username": "priti_sarkar",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int i =0 , j =0;\\n        int size_num1 = nums1.size();\\n        int size_num2 = nums2.size();\\n        \\n        while(size_num1>i || size_num2>j){\\n             ans.push_back(nums1[i]);\\n                i++;\\n        }\\n        while(size_num2>j){\\n             ans.push_back(nums2[j]);\\n               j++;\\n        }\\n        sort(ans.begin(),ans.end());\\n        int ans_size = ans.size();\\n        float mid = ans_size/2;\\n        if (ans_size % 2 == 0){\\n            float median = float (ans[mid]+ans[mid-1])/2;\\n            // double a1 = double(ab)/2;\\n            return median;\\n        }\\n        else{\\n            return ans[mid];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "qatestpavan5",
                        "content": "As i worked on few median problems in my math classes in college, the mean of the median of the two lists will be approximately equal to the combined array medium with large data sets and it may work with the given test cases. will this be a viable solution here?. Will this be a viable solution where accuracy is not needed?."
                    },
                    {
                        "username": "BudVic",
                        "content": "Unfortunately, the tests do not check the algorithmic complexity in any way. And one of the shortest solutions I\\'ve come across has a time complexity of O(nlogn), which is higher than the O(log(m+n)) we expected.\\n\\nIt uses the array_merge function to merge two arrays, and then the sort function to sort the array. Finally, it uses the ceil function and formula to calculate the median index. If the number of elements in the array is even, it returns the average of the two elements of the median, otherwise it returns the median value.\\n\\nYou can improve this code by using a merge algorithm or binary search to reduce the time complexity."
                    },
                    {
                        "username": "Rakesh_Indupuri",
                        "content": "Java Easy solution for understanding\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] result = new int[nums1.length+nums2.length];\\n        int index1=0;\\n        int index2=0;\\n        int indexRes=0;\\n        while(index1<nums1.length&&index2<nums2.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        while(index1<nums1.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n        }\\n        while(index2<nums2.length)\\n        {\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        Arrays.sort(result);\\n        int start=0;\\n        int end = result.length-1;\\n        double median;\\n        if(result.length%2==0)\\n        {\\n            double x = result[(start+end)/2];\\n            double y = result[((start+end)/2)+1];\\n            median=(x+y)/2;\\n        }\\n        else\\n        {\\n            median=result[(start+end)/2];\\n        }\\n        return median;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790315,
                "content": [
                    {
                        "username": "tanayas13",
                        "content": "it\\'s clearly stated in the question that an O(log n) solution is required and that\\'s why it is marked as hard but weirdly it accepted my O(m + n) solution after merging the array : /"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n     int l1=nums1.length;\\n    int l2=nums2.length;\\n    int c=(l1+l2)/2;\\n    c++;\\n    double m=0, n=0;\\n    boolean odd=true;\\n    if((l1+l2)%2==0){\\n      odd=false;\\n    }\\n    int p1=0, p2=0;\\n    while(c-->0){\\n      n=m;\\n      int p1v=getp(nums1, p1);\\n      int p2v=getp(nums2, p2);\\n      if(p1v<p2v){\\n        m=nums1[p1++];\\n      }\\n      else{\\n        m=nums2[p2++];\\n      }\\n    }\\n    if(!odd){\\n      return new Double ((m+n)/2);\\n    }\\n    return m;\\n    }\\n    public static int getp(int [] db, int p){\\n    if(p>=db.length){\\n      return Integer.MAX_VALUE;\\n    }\\n    return db[p];\\n  }\\n}"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "It is the basis of merge sort!"
                    },
                    {
                        "username": "pozitron",
                        "content": "I might be missing something but do not get why this is deemed hard.\\nThis task is a part of merge sort algo (as one might guess - the merge part of it).\\nIt can be solved with O(n+m) complexity for both time and space.\\n\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/submissions/892496342/"
                    },
                    {
                        "username": "pozitron",
                        "content": "finally got why this is hard. O(n+m) is greater than O(log(n+m)) :-)"
                    },
                    {
                        "username": "Lucario123",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        join_arr = nums1+nums2\\n        join_arr.sort()\\n        if (len(join_arr)%2==0):\\n            n =len(join_arr)//2\\n            median = (join_arr[n]+join_arr[n-1])/2\\n            return median\\n        else:\\n            n =len(join_arr)//2\\n            median = join_arr[n]\\n            return median\\n"
                    },
                    {
                        "username": "kitie",
                        "content": "Why was this \\u201Cdifficult task\\u201D so easy?"
                    },
                    {
                        "username": "rjskomal",
                        "content": "Your solution takes O((n+m)*log(n+m)) time because you sorted the arrays again. Try using Binary Search to reduce the TC without sorting again... "
                    },
                    {
                        "username": "priti_sarkar",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int i =0 , j =0;\\n        int size_num1 = nums1.size();\\n        int size_num2 = nums2.size();\\n        \\n        while(size_num1>i || size_num2>j){\\n             ans.push_back(nums1[i]);\\n                i++;\\n        }\\n        while(size_num2>j){\\n             ans.push_back(nums2[j]);\\n               j++;\\n        }\\n        sort(ans.begin(),ans.end());\\n        int ans_size = ans.size();\\n        float mid = ans_size/2;\\n        if (ans_size % 2 == 0){\\n            float median = float (ans[mid]+ans[mid-1])/2;\\n            // double a1 = double(ab)/2;\\n            return median;\\n        }\\n        else{\\n            return ans[mid];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "qatestpavan5",
                        "content": "As i worked on few median problems in my math classes in college, the mean of the median of the two lists will be approximately equal to the combined array medium with large data sets and it may work with the given test cases. will this be a viable solution here?. Will this be a viable solution where accuracy is not needed?."
                    },
                    {
                        "username": "BudVic",
                        "content": "Unfortunately, the tests do not check the algorithmic complexity in any way. And one of the shortest solutions I\\'ve come across has a time complexity of O(nlogn), which is higher than the O(log(m+n)) we expected.\\n\\nIt uses the array_merge function to merge two arrays, and then the sort function to sort the array. Finally, it uses the ceil function and formula to calculate the median index. If the number of elements in the array is even, it returns the average of the two elements of the median, otherwise it returns the median value.\\n\\nYou can improve this code by using a merge algorithm or binary search to reduce the time complexity."
                    },
                    {
                        "username": "Rakesh_Indupuri",
                        "content": "Java Easy solution for understanding\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] result = new int[nums1.length+nums2.length];\\n        int index1=0;\\n        int index2=0;\\n        int indexRes=0;\\n        while(index1<nums1.length&&index2<nums2.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        while(index1<nums1.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n        }\\n        while(index2<nums2.length)\\n        {\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        Arrays.sort(result);\\n        int start=0;\\n        int end = result.length-1;\\n        double median;\\n        if(result.length%2==0)\\n        {\\n            double x = result[(start+end)/2];\\n            double y = result[((start+end)/2)+1];\\n            median=(x+y)/2;\\n        }\\n        else\\n        {\\n            median=result[(start+end)/2];\\n        }\\n        return median;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1787947,
                "content": [
                    {
                        "username": "tanayas13",
                        "content": "it\\'s clearly stated in the question that an O(log n) solution is required and that\\'s why it is marked as hard but weirdly it accepted my O(m + n) solution after merging the array : /"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n     int l1=nums1.length;\\n    int l2=nums2.length;\\n    int c=(l1+l2)/2;\\n    c++;\\n    double m=0, n=0;\\n    boolean odd=true;\\n    if((l1+l2)%2==0){\\n      odd=false;\\n    }\\n    int p1=0, p2=0;\\n    while(c-->0){\\n      n=m;\\n      int p1v=getp(nums1, p1);\\n      int p2v=getp(nums2, p2);\\n      if(p1v<p2v){\\n        m=nums1[p1++];\\n      }\\n      else{\\n        m=nums2[p2++];\\n      }\\n    }\\n    if(!odd){\\n      return new Double ((m+n)/2);\\n    }\\n    return m;\\n    }\\n    public static int getp(int [] db, int p){\\n    if(p>=db.length){\\n      return Integer.MAX_VALUE;\\n    }\\n    return db[p];\\n  }\\n}"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "It is the basis of merge sort!"
                    },
                    {
                        "username": "pozitron",
                        "content": "I might be missing something but do not get why this is deemed hard.\\nThis task is a part of merge sort algo (as one might guess - the merge part of it).\\nIt can be solved with O(n+m) complexity for both time and space.\\n\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/submissions/892496342/"
                    },
                    {
                        "username": "pozitron",
                        "content": "finally got why this is hard. O(n+m) is greater than O(log(n+m)) :-)"
                    },
                    {
                        "username": "Lucario123",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        join_arr = nums1+nums2\\n        join_arr.sort()\\n        if (len(join_arr)%2==0):\\n            n =len(join_arr)//2\\n            median = (join_arr[n]+join_arr[n-1])/2\\n            return median\\n        else:\\n            n =len(join_arr)//2\\n            median = join_arr[n]\\n            return median\\n"
                    },
                    {
                        "username": "kitie",
                        "content": "Why was this \\u201Cdifficult task\\u201D so easy?"
                    },
                    {
                        "username": "rjskomal",
                        "content": "Your solution takes O((n+m)*log(n+m)) time because you sorted the arrays again. Try using Binary Search to reduce the TC without sorting again... "
                    },
                    {
                        "username": "priti_sarkar",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int i =0 , j =0;\\n        int size_num1 = nums1.size();\\n        int size_num2 = nums2.size();\\n        \\n        while(size_num1>i || size_num2>j){\\n             ans.push_back(nums1[i]);\\n                i++;\\n        }\\n        while(size_num2>j){\\n             ans.push_back(nums2[j]);\\n               j++;\\n        }\\n        sort(ans.begin(),ans.end());\\n        int ans_size = ans.size();\\n        float mid = ans_size/2;\\n        if (ans_size % 2 == 0){\\n            float median = float (ans[mid]+ans[mid-1])/2;\\n            // double a1 = double(ab)/2;\\n            return median;\\n        }\\n        else{\\n            return ans[mid];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "qatestpavan5",
                        "content": "As i worked on few median problems in my math classes in college, the mean of the median of the two lists will be approximately equal to the combined array medium with large data sets and it may work with the given test cases. will this be a viable solution here?. Will this be a viable solution where accuracy is not needed?."
                    },
                    {
                        "username": "BudVic",
                        "content": "Unfortunately, the tests do not check the algorithmic complexity in any way. And one of the shortest solutions I\\'ve come across has a time complexity of O(nlogn), which is higher than the O(log(m+n)) we expected.\\n\\nIt uses the array_merge function to merge two arrays, and then the sort function to sort the array. Finally, it uses the ceil function and formula to calculate the median index. If the number of elements in the array is even, it returns the average of the two elements of the median, otherwise it returns the median value.\\n\\nYou can improve this code by using a merge algorithm or binary search to reduce the time complexity."
                    },
                    {
                        "username": "Rakesh_Indupuri",
                        "content": "Java Easy solution for understanding\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] result = new int[nums1.length+nums2.length];\\n        int index1=0;\\n        int index2=0;\\n        int indexRes=0;\\n        while(index1<nums1.length&&index2<nums2.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        while(index1<nums1.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n        }\\n        while(index2<nums2.length)\\n        {\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        Arrays.sort(result);\\n        int start=0;\\n        int end = result.length-1;\\n        double median;\\n        if(result.length%2==0)\\n        {\\n            double x = result[(start+end)/2];\\n            double y = result[((start+end)/2)+1];\\n            median=(x+y)/2;\\n        }\\n        else\\n        {\\n            median=result[(start+end)/2];\\n        }\\n        return median;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1785214,
                "content": [
                    {
                        "username": "tanayas13",
                        "content": "it\\'s clearly stated in the question that an O(log n) solution is required and that\\'s why it is marked as hard but weirdly it accepted my O(m + n) solution after merging the array : /"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n     int l1=nums1.length;\\n    int l2=nums2.length;\\n    int c=(l1+l2)/2;\\n    c++;\\n    double m=0, n=0;\\n    boolean odd=true;\\n    if((l1+l2)%2==0){\\n      odd=false;\\n    }\\n    int p1=0, p2=0;\\n    while(c-->0){\\n      n=m;\\n      int p1v=getp(nums1, p1);\\n      int p2v=getp(nums2, p2);\\n      if(p1v<p2v){\\n        m=nums1[p1++];\\n      }\\n      else{\\n        m=nums2[p2++];\\n      }\\n    }\\n    if(!odd){\\n      return new Double ((m+n)/2);\\n    }\\n    return m;\\n    }\\n    public static int getp(int [] db, int p){\\n    if(p>=db.length){\\n      return Integer.MAX_VALUE;\\n    }\\n    return db[p];\\n  }\\n}"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "It is the basis of merge sort!"
                    },
                    {
                        "username": "pozitron",
                        "content": "I might be missing something but do not get why this is deemed hard.\\nThis task is a part of merge sort algo (as one might guess - the merge part of it).\\nIt can be solved with O(n+m) complexity for both time and space.\\n\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/submissions/892496342/"
                    },
                    {
                        "username": "pozitron",
                        "content": "finally got why this is hard. O(n+m) is greater than O(log(n+m)) :-)"
                    },
                    {
                        "username": "Lucario123",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        join_arr = nums1+nums2\\n        join_arr.sort()\\n        if (len(join_arr)%2==0):\\n            n =len(join_arr)//2\\n            median = (join_arr[n]+join_arr[n-1])/2\\n            return median\\n        else:\\n            n =len(join_arr)//2\\n            median = join_arr[n]\\n            return median\\n"
                    },
                    {
                        "username": "kitie",
                        "content": "Why was this \\u201Cdifficult task\\u201D so easy?"
                    },
                    {
                        "username": "rjskomal",
                        "content": "Your solution takes O((n+m)*log(n+m)) time because you sorted the arrays again. Try using Binary Search to reduce the TC without sorting again... "
                    },
                    {
                        "username": "priti_sarkar",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int i =0 , j =0;\\n        int size_num1 = nums1.size();\\n        int size_num2 = nums2.size();\\n        \\n        while(size_num1>i || size_num2>j){\\n             ans.push_back(nums1[i]);\\n                i++;\\n        }\\n        while(size_num2>j){\\n             ans.push_back(nums2[j]);\\n               j++;\\n        }\\n        sort(ans.begin(),ans.end());\\n        int ans_size = ans.size();\\n        float mid = ans_size/2;\\n        if (ans_size % 2 == 0){\\n            float median = float (ans[mid]+ans[mid-1])/2;\\n            // double a1 = double(ab)/2;\\n            return median;\\n        }\\n        else{\\n            return ans[mid];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "qatestpavan5",
                        "content": "As i worked on few median problems in my math classes in college, the mean of the median of the two lists will be approximately equal to the combined array medium with large data sets and it may work with the given test cases. will this be a viable solution here?. Will this be a viable solution where accuracy is not needed?."
                    },
                    {
                        "username": "BudVic",
                        "content": "Unfortunately, the tests do not check the algorithmic complexity in any way. And one of the shortest solutions I\\'ve come across has a time complexity of O(nlogn), which is higher than the O(log(m+n)) we expected.\\n\\nIt uses the array_merge function to merge two arrays, and then the sort function to sort the array. Finally, it uses the ceil function and formula to calculate the median index. If the number of elements in the array is even, it returns the average of the two elements of the median, otherwise it returns the median value.\\n\\nYou can improve this code by using a merge algorithm or binary search to reduce the time complexity."
                    },
                    {
                        "username": "Rakesh_Indupuri",
                        "content": "Java Easy solution for understanding\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] result = new int[nums1.length+nums2.length];\\n        int index1=0;\\n        int index2=0;\\n        int indexRes=0;\\n        while(index1<nums1.length&&index2<nums2.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        while(index1<nums1.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n        }\\n        while(index2<nums2.length)\\n        {\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        Arrays.sort(result);\\n        int start=0;\\n        int end = result.length-1;\\n        double median;\\n        if(result.length%2==0)\\n        {\\n            double x = result[(start+end)/2];\\n            double y = result[((start+end)/2)+1];\\n            median=(x+y)/2;\\n        }\\n        else\\n        {\\n            median=result[(start+end)/2];\\n        }\\n        return median;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1784804,
                "content": [
                    {
                        "username": "tanayas13",
                        "content": "it\\'s clearly stated in the question that an O(log n) solution is required and that\\'s why it is marked as hard but weirdly it accepted my O(m + n) solution after merging the array : /"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n     int l1=nums1.length;\\n    int l2=nums2.length;\\n    int c=(l1+l2)/2;\\n    c++;\\n    double m=0, n=0;\\n    boolean odd=true;\\n    if((l1+l2)%2==0){\\n      odd=false;\\n    }\\n    int p1=0, p2=0;\\n    while(c-->0){\\n      n=m;\\n      int p1v=getp(nums1, p1);\\n      int p2v=getp(nums2, p2);\\n      if(p1v<p2v){\\n        m=nums1[p1++];\\n      }\\n      else{\\n        m=nums2[p2++];\\n      }\\n    }\\n    if(!odd){\\n      return new Double ((m+n)/2);\\n    }\\n    return m;\\n    }\\n    public static int getp(int [] db, int p){\\n    if(p>=db.length){\\n      return Integer.MAX_VALUE;\\n    }\\n    return db[p];\\n  }\\n}"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "It is the basis of merge sort!"
                    },
                    {
                        "username": "pozitron",
                        "content": "I might be missing something but do not get why this is deemed hard.\\nThis task is a part of merge sort algo (as one might guess - the merge part of it).\\nIt can be solved with O(n+m) complexity for both time and space.\\n\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/submissions/892496342/"
                    },
                    {
                        "username": "pozitron",
                        "content": "finally got why this is hard. O(n+m) is greater than O(log(n+m)) :-)"
                    },
                    {
                        "username": "Lucario123",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        join_arr = nums1+nums2\\n        join_arr.sort()\\n        if (len(join_arr)%2==0):\\n            n =len(join_arr)//2\\n            median = (join_arr[n]+join_arr[n-1])/2\\n            return median\\n        else:\\n            n =len(join_arr)//2\\n            median = join_arr[n]\\n            return median\\n"
                    },
                    {
                        "username": "kitie",
                        "content": "Why was this \\u201Cdifficult task\\u201D so easy?"
                    },
                    {
                        "username": "rjskomal",
                        "content": "Your solution takes O((n+m)*log(n+m)) time because you sorted the arrays again. Try using Binary Search to reduce the TC without sorting again... "
                    },
                    {
                        "username": "priti_sarkar",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int i =0 , j =0;\\n        int size_num1 = nums1.size();\\n        int size_num2 = nums2.size();\\n        \\n        while(size_num1>i || size_num2>j){\\n             ans.push_back(nums1[i]);\\n                i++;\\n        }\\n        while(size_num2>j){\\n             ans.push_back(nums2[j]);\\n               j++;\\n        }\\n        sort(ans.begin(),ans.end());\\n        int ans_size = ans.size();\\n        float mid = ans_size/2;\\n        if (ans_size % 2 == 0){\\n            float median = float (ans[mid]+ans[mid-1])/2;\\n            // double a1 = double(ab)/2;\\n            return median;\\n        }\\n        else{\\n            return ans[mid];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "qatestpavan5",
                        "content": "As i worked on few median problems in my math classes in college, the mean of the median of the two lists will be approximately equal to the combined array medium with large data sets and it may work with the given test cases. will this be a viable solution here?. Will this be a viable solution where accuracy is not needed?."
                    },
                    {
                        "username": "BudVic",
                        "content": "Unfortunately, the tests do not check the algorithmic complexity in any way. And one of the shortest solutions I\\'ve come across has a time complexity of O(nlogn), which is higher than the O(log(m+n)) we expected.\\n\\nIt uses the array_merge function to merge two arrays, and then the sort function to sort the array. Finally, it uses the ceil function and formula to calculate the median index. If the number of elements in the array is even, it returns the average of the two elements of the median, otherwise it returns the median value.\\n\\nYou can improve this code by using a merge algorithm or binary search to reduce the time complexity."
                    },
                    {
                        "username": "Rakesh_Indupuri",
                        "content": "Java Easy solution for understanding\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] result = new int[nums1.length+nums2.length];\\n        int index1=0;\\n        int index2=0;\\n        int indexRes=0;\\n        while(index1<nums1.length&&index2<nums2.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        while(index1<nums1.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n        }\\n        while(index2<nums2.length)\\n        {\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        Arrays.sort(result);\\n        int start=0;\\n        int end = result.length-1;\\n        double median;\\n        if(result.length%2==0)\\n        {\\n            double x = result[(start+end)/2];\\n            double y = result[((start+end)/2)+1];\\n            median=(x+y)/2;\\n        }\\n        else\\n        {\\n            median=result[(start+end)/2];\\n        }\\n        return median;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1783612,
                "content": [
                    {
                        "username": "tanayas13",
                        "content": "it\\'s clearly stated in the question that an O(log n) solution is required and that\\'s why it is marked as hard but weirdly it accepted my O(m + n) solution after merging the array : /"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n     int l1=nums1.length;\\n    int l2=nums2.length;\\n    int c=(l1+l2)/2;\\n    c++;\\n    double m=0, n=0;\\n    boolean odd=true;\\n    if((l1+l2)%2==0){\\n      odd=false;\\n    }\\n    int p1=0, p2=0;\\n    while(c-->0){\\n      n=m;\\n      int p1v=getp(nums1, p1);\\n      int p2v=getp(nums2, p2);\\n      if(p1v<p2v){\\n        m=nums1[p1++];\\n      }\\n      else{\\n        m=nums2[p2++];\\n      }\\n    }\\n    if(!odd){\\n      return new Double ((m+n)/2);\\n    }\\n    return m;\\n    }\\n    public static int getp(int [] db, int p){\\n    if(p>=db.length){\\n      return Integer.MAX_VALUE;\\n    }\\n    return db[p];\\n  }\\n}"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "It is the basis of merge sort!"
                    },
                    {
                        "username": "pozitron",
                        "content": "I might be missing something but do not get why this is deemed hard.\\nThis task is a part of merge sort algo (as one might guess - the merge part of it).\\nIt can be solved with O(n+m) complexity for both time and space.\\n\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/submissions/892496342/"
                    },
                    {
                        "username": "pozitron",
                        "content": "finally got why this is hard. O(n+m) is greater than O(log(n+m)) :-)"
                    },
                    {
                        "username": "Lucario123",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        join_arr = nums1+nums2\\n        join_arr.sort()\\n        if (len(join_arr)%2==0):\\n            n =len(join_arr)//2\\n            median = (join_arr[n]+join_arr[n-1])/2\\n            return median\\n        else:\\n            n =len(join_arr)//2\\n            median = join_arr[n]\\n            return median\\n"
                    },
                    {
                        "username": "kitie",
                        "content": "Why was this \\u201Cdifficult task\\u201D so easy?"
                    },
                    {
                        "username": "rjskomal",
                        "content": "Your solution takes O((n+m)*log(n+m)) time because you sorted the arrays again. Try using Binary Search to reduce the TC without sorting again... "
                    },
                    {
                        "username": "priti_sarkar",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int i =0 , j =0;\\n        int size_num1 = nums1.size();\\n        int size_num2 = nums2.size();\\n        \\n        while(size_num1>i || size_num2>j){\\n             ans.push_back(nums1[i]);\\n                i++;\\n        }\\n        while(size_num2>j){\\n             ans.push_back(nums2[j]);\\n               j++;\\n        }\\n        sort(ans.begin(),ans.end());\\n        int ans_size = ans.size();\\n        float mid = ans_size/2;\\n        if (ans_size % 2 == 0){\\n            float median = float (ans[mid]+ans[mid-1])/2;\\n            // double a1 = double(ab)/2;\\n            return median;\\n        }\\n        else{\\n            return ans[mid];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "qatestpavan5",
                        "content": "As i worked on few median problems in my math classes in college, the mean of the median of the two lists will be approximately equal to the combined array medium with large data sets and it may work with the given test cases. will this be a viable solution here?. Will this be a viable solution where accuracy is not needed?."
                    },
                    {
                        "username": "BudVic",
                        "content": "Unfortunately, the tests do not check the algorithmic complexity in any way. And one of the shortest solutions I\\'ve come across has a time complexity of O(nlogn), which is higher than the O(log(m+n)) we expected.\\n\\nIt uses the array_merge function to merge two arrays, and then the sort function to sort the array. Finally, it uses the ceil function and formula to calculate the median index. If the number of elements in the array is even, it returns the average of the two elements of the median, otherwise it returns the median value.\\n\\nYou can improve this code by using a merge algorithm or binary search to reduce the time complexity."
                    },
                    {
                        "username": "Rakesh_Indupuri",
                        "content": "Java Easy solution for understanding\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] result = new int[nums1.length+nums2.length];\\n        int index1=0;\\n        int index2=0;\\n        int indexRes=0;\\n        while(index1<nums1.length&&index2<nums2.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        while(index1<nums1.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n        }\\n        while(index2<nums2.length)\\n        {\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        Arrays.sort(result);\\n        int start=0;\\n        int end = result.length-1;\\n        double median;\\n        if(result.length%2==0)\\n        {\\n            double x = result[(start+end)/2];\\n            double y = result[((start+end)/2)+1];\\n            median=(x+y)/2;\\n        }\\n        else\\n        {\\n            median=result[(start+end)/2];\\n        }\\n        return median;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1783440,
                "content": [
                    {
                        "username": "tanayas13",
                        "content": "it\\'s clearly stated in the question that an O(log n) solution is required and that\\'s why it is marked as hard but weirdly it accepted my O(m + n) solution after merging the array : /"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n     int l1=nums1.length;\\n    int l2=nums2.length;\\n    int c=(l1+l2)/2;\\n    c++;\\n    double m=0, n=0;\\n    boolean odd=true;\\n    if((l1+l2)%2==0){\\n      odd=false;\\n    }\\n    int p1=0, p2=0;\\n    while(c-->0){\\n      n=m;\\n      int p1v=getp(nums1, p1);\\n      int p2v=getp(nums2, p2);\\n      if(p1v<p2v){\\n        m=nums1[p1++];\\n      }\\n      else{\\n        m=nums2[p2++];\\n      }\\n    }\\n    if(!odd){\\n      return new Double ((m+n)/2);\\n    }\\n    return m;\\n    }\\n    public static int getp(int [] db, int p){\\n    if(p>=db.length){\\n      return Integer.MAX_VALUE;\\n    }\\n    return db[p];\\n  }\\n}"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "It is the basis of merge sort!"
                    },
                    {
                        "username": "pozitron",
                        "content": "I might be missing something but do not get why this is deemed hard.\\nThis task is a part of merge sort algo (as one might guess - the merge part of it).\\nIt can be solved with O(n+m) complexity for both time and space.\\n\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/submissions/892496342/"
                    },
                    {
                        "username": "pozitron",
                        "content": "finally got why this is hard. O(n+m) is greater than O(log(n+m)) :-)"
                    },
                    {
                        "username": "Lucario123",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        join_arr = nums1+nums2\\n        join_arr.sort()\\n        if (len(join_arr)%2==0):\\n            n =len(join_arr)//2\\n            median = (join_arr[n]+join_arr[n-1])/2\\n            return median\\n        else:\\n            n =len(join_arr)//2\\n            median = join_arr[n]\\n            return median\\n"
                    },
                    {
                        "username": "kitie",
                        "content": "Why was this \\u201Cdifficult task\\u201D so easy?"
                    },
                    {
                        "username": "rjskomal",
                        "content": "Your solution takes O((n+m)*log(n+m)) time because you sorted the arrays again. Try using Binary Search to reduce the TC without sorting again... "
                    },
                    {
                        "username": "priti_sarkar",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int i =0 , j =0;\\n        int size_num1 = nums1.size();\\n        int size_num2 = nums2.size();\\n        \\n        while(size_num1>i || size_num2>j){\\n             ans.push_back(nums1[i]);\\n                i++;\\n        }\\n        while(size_num2>j){\\n             ans.push_back(nums2[j]);\\n               j++;\\n        }\\n        sort(ans.begin(),ans.end());\\n        int ans_size = ans.size();\\n        float mid = ans_size/2;\\n        if (ans_size % 2 == 0){\\n            float median = float (ans[mid]+ans[mid-1])/2;\\n            // double a1 = double(ab)/2;\\n            return median;\\n        }\\n        else{\\n            return ans[mid];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "qatestpavan5",
                        "content": "As i worked on few median problems in my math classes in college, the mean of the median of the two lists will be approximately equal to the combined array medium with large data sets and it may work with the given test cases. will this be a viable solution here?. Will this be a viable solution where accuracy is not needed?."
                    },
                    {
                        "username": "BudVic",
                        "content": "Unfortunately, the tests do not check the algorithmic complexity in any way. And one of the shortest solutions I\\'ve come across has a time complexity of O(nlogn), which is higher than the O(log(m+n)) we expected.\\n\\nIt uses the array_merge function to merge two arrays, and then the sort function to sort the array. Finally, it uses the ceil function and formula to calculate the median index. If the number of elements in the array is even, it returns the average of the two elements of the median, otherwise it returns the median value.\\n\\nYou can improve this code by using a merge algorithm or binary search to reduce the time complexity."
                    },
                    {
                        "username": "Rakesh_Indupuri",
                        "content": "Java Easy solution for understanding\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] result = new int[nums1.length+nums2.length];\\n        int index1=0;\\n        int index2=0;\\n        int indexRes=0;\\n        while(index1<nums1.length&&index2<nums2.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        while(index1<nums1.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n        }\\n        while(index2<nums2.length)\\n        {\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        Arrays.sort(result);\\n        int start=0;\\n        int end = result.length-1;\\n        double median;\\n        if(result.length%2==0)\\n        {\\n            double x = result[(start+end)/2];\\n            double y = result[((start+end)/2)+1];\\n            median=(x+y)/2;\\n        }\\n        else\\n        {\\n            median=result[(start+end)/2];\\n        }\\n        return median;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1780858,
                "content": [
                    {
                        "username": "tanayas13",
                        "content": "it\\'s clearly stated in the question that an O(log n) solution is required and that\\'s why it is marked as hard but weirdly it accepted my O(m + n) solution after merging the array : /"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n     int l1=nums1.length;\\n    int l2=nums2.length;\\n    int c=(l1+l2)/2;\\n    c++;\\n    double m=0, n=0;\\n    boolean odd=true;\\n    if((l1+l2)%2==0){\\n      odd=false;\\n    }\\n    int p1=0, p2=0;\\n    while(c-->0){\\n      n=m;\\n      int p1v=getp(nums1, p1);\\n      int p2v=getp(nums2, p2);\\n      if(p1v<p2v){\\n        m=nums1[p1++];\\n      }\\n      else{\\n        m=nums2[p2++];\\n      }\\n    }\\n    if(!odd){\\n      return new Double ((m+n)/2);\\n    }\\n    return m;\\n    }\\n    public static int getp(int [] db, int p){\\n    if(p>=db.length){\\n      return Integer.MAX_VALUE;\\n    }\\n    return db[p];\\n  }\\n}"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "It is the basis of merge sort!"
                    },
                    {
                        "username": "pozitron",
                        "content": "I might be missing something but do not get why this is deemed hard.\\nThis task is a part of merge sort algo (as one might guess - the merge part of it).\\nIt can be solved with O(n+m) complexity for both time and space.\\n\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/submissions/892496342/"
                    },
                    {
                        "username": "pozitron",
                        "content": "finally got why this is hard. O(n+m) is greater than O(log(n+m)) :-)"
                    },
                    {
                        "username": "Lucario123",
                        "content": "class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        join_arr = nums1+nums2\\n        join_arr.sort()\\n        if (len(join_arr)%2==0):\\n            n =len(join_arr)//2\\n            median = (join_arr[n]+join_arr[n-1])/2\\n            return median\\n        else:\\n            n =len(join_arr)//2\\n            median = join_arr[n]\\n            return median\\n"
                    },
                    {
                        "username": "kitie",
                        "content": "Why was this \\u201Cdifficult task\\u201D so easy?"
                    },
                    {
                        "username": "rjskomal",
                        "content": "Your solution takes O((n+m)*log(n+m)) time because you sorted the arrays again. Try using Binary Search to reduce the TC without sorting again... "
                    },
                    {
                        "username": "priti_sarkar",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int i =0 , j =0;\\n        int size_num1 = nums1.size();\\n        int size_num2 = nums2.size();\\n        \\n        while(size_num1>i || size_num2>j){\\n             ans.push_back(nums1[i]);\\n                i++;\\n        }\\n        while(size_num2>j){\\n             ans.push_back(nums2[j]);\\n               j++;\\n        }\\n        sort(ans.begin(),ans.end());\\n        int ans_size = ans.size();\\n        float mid = ans_size/2;\\n        if (ans_size % 2 == 0){\\n            float median = float (ans[mid]+ans[mid-1])/2;\\n            // double a1 = double(ab)/2;\\n            return median;\\n        }\\n        else{\\n            return ans[mid];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "qatestpavan5",
                        "content": "As i worked on few median problems in my math classes in college, the mean of the median of the two lists will be approximately equal to the combined array medium with large data sets and it may work with the given test cases. will this be a viable solution here?. Will this be a viable solution where accuracy is not needed?."
                    },
                    {
                        "username": "BudVic",
                        "content": "Unfortunately, the tests do not check the algorithmic complexity in any way. And one of the shortest solutions I\\'ve come across has a time complexity of O(nlogn), which is higher than the O(log(m+n)) we expected.\\n\\nIt uses the array_merge function to merge two arrays, and then the sort function to sort the array. Finally, it uses the ceil function and formula to calculate the median index. If the number of elements in the array is even, it returns the average of the two elements of the median, otherwise it returns the median value.\\n\\nYou can improve this code by using a merge algorithm or binary search to reduce the time complexity."
                    },
                    {
                        "username": "Rakesh_Indupuri",
                        "content": "Java Easy solution for understanding\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] result = new int[nums1.length+nums2.length];\\n        int index1=0;\\n        int index2=0;\\n        int indexRes=0;\\n        while(index1<nums1.length&&index2<nums2.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        while(index1<nums1.length)\\n        {\\n            result[indexRes++]=nums1[index1++];\\n        }\\n        while(index2<nums2.length)\\n        {\\n            result[indexRes++]=nums2[index2++];\\n        }\\n        Arrays.sort(result);\\n        int start=0;\\n        int end = result.length-1;\\n        double median;\\n        if(result.length%2==0)\\n        {\\n            double x = result[(start+end)/2];\\n            double y = result[((start+end)/2)+1];\\n            median=(x+y)/2;\\n        }\\n        else\\n        {\\n            median=result[(start+end)/2];\\n        }\\n        return median;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1777069,
                "content": [
                    {
                        "username": "carminemangione",
                        "content": "I solved the code in Java with a provably best memory and performance model (first principles because i am a nerd) but was rated in the 20% for memory and performance. Does the environment not use a JIT? "
                    },
                    {
                        "username": "hassamUllah23",
                        "content": "### What the he*l?\\nmy code just failed a test case where...\\n `nums1=[1,1]` and `nums2=[1,2]`\\nthe resulting merged array would be `merged = [1,2]`\\nsubsequently, the median would be `median = (1+2)/2 = 1.5`\\n\\n**THEN HOW IS THE EXPECTED OUTPUT 1.0????**\\n\\nam I missing something in [My Code](https://leetcode.com/playground/iNNGzEUR) ?"
                    },
                    {
                        "username": "TableLadder39",
                        "content": "The resulting merged array in that case would be [1,1,1,2]"
                    },
                    {
                        "username": "Rohan_88",
                        "content": "ROHAN SIBY \n$arr1 = $nums1;\n        $arr2 = $nums2;\n        $arrayFull = array_merge($arr1,$arr2);\n        array_multisort($arrayFull,SORT_ASC,SORT_NUMERIC);\n        $count=count($arrayFull);\n\n        if($count%2 == 0){\n            $outputMedian = $arrayFull[$count/2] + $arrayFull[($count/2)-1];\n            $outputMedian = $outputMedian / 2;\n        } else {\n            $outputMedian = $arrayFull[$count/2];\n        }\n        echo \"Answer: \".$outputMedian;\n    }\n\nI have written this and I am getting correct answer in stdout but on output ta, I am not getting the answer. Any problem with compling PHP code?\n\nWhen I try to submit this Its not accepting Answer"
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "This is not a hard problem\\nyou just need to create an array which will store the elements of both the arrays.\\nAfter that sort the array\\nif the length is even then mean of 2 mid elements will be the answer \\nelse the mid element will give you the answer\\nhere is the solution you can check it but before that you can try it once by this method\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3073793/java-easy-solution/"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem is easy if we do that. But using sort function, has as runtime complexity O(nlog(n)). I don\\'t talk  about creating the new array. It take also same time depending in the language used.\\nThe problem is hard because you must resolve it in a runtime complexity equal to O(log(n)).\\nN. B. the length of both arrays is  lesser than 1000 in constraints. In that case we cane consider the runtime as constant time. And because of that, your approach can pass the test. But with length huge than that , it can\\'."
                    },
                    {
                        "username": "felix097",
                        "content": "How come this problem is rated as Hard, reading comments below asking such kind of question in interview is totally idiotic. It is very easy problem unless you check the term median of array. I didn't even check the solution I just solved it after knowing what was I asked."
                    },
                    {
                        "username": "abhi_prasad",
                        "content": "int m = nums1.length;\\n        int n = nums2.length;\\n        int a[] = new int[m+n];\\n        int i = 0, j=0, k=0;\\n        while(i<m&&j<n)\\n        {\\n            if (nums1[i]<nums2[j])\\n            {\\n                a[k]=nums1[i];\\n                i++;\\n            } \\n            else{\\n                 a[k]=nums2[j];\\n                 j++;\\n            }\\n            k++;\\n        }\\n        while(i<m){\\n            a[k]=nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n){\\n            a[k]=nums2[j];\\n            j++;\\n            k++;\\n        }\\n        if((m+n)%2!=0){\\n            return a[(m+n)/2];\\n        }\\n        else{\\n            int x =(m+n)/2;\\n            double p =a[x];\\n            double q=a[x-1];\\n            return(p+q)/2;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": " class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1.sort()\\n        if(len(nums1)%2==0):\\n            return (nums1[len(nums1)//2-1]+nums1[len(nums1)//2])/2\\n        else:\\n            return nums1[len(nums1)//2]"
                    },
                    {
                        "username": "abhiabhishek9347",
                        "content": "Generally by using the formula of median we can do the job but in case 2032 it arises a schenario where the nums1 and nums2 having the values (0,0) "
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        new=nums1+nums2\\n        new.sort()\\n        low,high=0,len(new)-1\\n        while(low<=high):\\n            mid=low+(high-low)//2\\n            if(len(new)%2==0):\\n                return (new[mid]+new[mid+1])/2\\n            else:\\n                return new[mid]\\nwhats wrong with my code"
                    },
                    {
                        "username": "codernoob",
                        "content": "Why is there no official solution for this question?"
                    }
                ]
            },
            {
                "id": 1771334,
                "content": [
                    {
                        "username": "carminemangione",
                        "content": "I solved the code in Java with a provably best memory and performance model (first principles because i am a nerd) but was rated in the 20% for memory and performance. Does the environment not use a JIT? "
                    },
                    {
                        "username": "hassamUllah23",
                        "content": "### What the he*l?\\nmy code just failed a test case where...\\n `nums1=[1,1]` and `nums2=[1,2]`\\nthe resulting merged array would be `merged = [1,2]`\\nsubsequently, the median would be `median = (1+2)/2 = 1.5`\\n\\n**THEN HOW IS THE EXPECTED OUTPUT 1.0????**\\n\\nam I missing something in [My Code](https://leetcode.com/playground/iNNGzEUR) ?"
                    },
                    {
                        "username": "TableLadder39",
                        "content": "The resulting merged array in that case would be [1,1,1,2]"
                    },
                    {
                        "username": "Rohan_88",
                        "content": "ROHAN SIBY \n$arr1 = $nums1;\n        $arr2 = $nums2;\n        $arrayFull = array_merge($arr1,$arr2);\n        array_multisort($arrayFull,SORT_ASC,SORT_NUMERIC);\n        $count=count($arrayFull);\n\n        if($count%2 == 0){\n            $outputMedian = $arrayFull[$count/2] + $arrayFull[($count/2)-1];\n            $outputMedian = $outputMedian / 2;\n        } else {\n            $outputMedian = $arrayFull[$count/2];\n        }\n        echo \"Answer: \".$outputMedian;\n    }\n\nI have written this and I am getting correct answer in stdout but on output ta, I am not getting the answer. Any problem with compling PHP code?\n\nWhen I try to submit this Its not accepting Answer"
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "This is not a hard problem\\nyou just need to create an array which will store the elements of both the arrays.\\nAfter that sort the array\\nif the length is even then mean of 2 mid elements will be the answer \\nelse the mid element will give you the answer\\nhere is the solution you can check it but before that you can try it once by this method\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3073793/java-easy-solution/"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem is easy if we do that. But using sort function, has as runtime complexity O(nlog(n)). I don\\'t talk  about creating the new array. It take also same time depending in the language used.\\nThe problem is hard because you must resolve it in a runtime complexity equal to O(log(n)).\\nN. B. the length of both arrays is  lesser than 1000 in constraints. In that case we cane consider the runtime as constant time. And because of that, your approach can pass the test. But with length huge than that , it can\\'."
                    },
                    {
                        "username": "felix097",
                        "content": "How come this problem is rated as Hard, reading comments below asking such kind of question in interview is totally idiotic. It is very easy problem unless you check the term median of array. I didn't even check the solution I just solved it after knowing what was I asked."
                    },
                    {
                        "username": "abhi_prasad",
                        "content": "int m = nums1.length;\\n        int n = nums2.length;\\n        int a[] = new int[m+n];\\n        int i = 0, j=0, k=0;\\n        while(i<m&&j<n)\\n        {\\n            if (nums1[i]<nums2[j])\\n            {\\n                a[k]=nums1[i];\\n                i++;\\n            } \\n            else{\\n                 a[k]=nums2[j];\\n                 j++;\\n            }\\n            k++;\\n        }\\n        while(i<m){\\n            a[k]=nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n){\\n            a[k]=nums2[j];\\n            j++;\\n            k++;\\n        }\\n        if((m+n)%2!=0){\\n            return a[(m+n)/2];\\n        }\\n        else{\\n            int x =(m+n)/2;\\n            double p =a[x];\\n            double q=a[x-1];\\n            return(p+q)/2;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": " class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1.sort()\\n        if(len(nums1)%2==0):\\n            return (nums1[len(nums1)//2-1]+nums1[len(nums1)//2])/2\\n        else:\\n            return nums1[len(nums1)//2]"
                    },
                    {
                        "username": "abhiabhishek9347",
                        "content": "Generally by using the formula of median we can do the job but in case 2032 it arises a schenario where the nums1 and nums2 having the values (0,0) "
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        new=nums1+nums2\\n        new.sort()\\n        low,high=0,len(new)-1\\n        while(low<=high):\\n            mid=low+(high-low)//2\\n            if(len(new)%2==0):\\n                return (new[mid]+new[mid+1])/2\\n            else:\\n                return new[mid]\\nwhats wrong with my code"
                    },
                    {
                        "username": "codernoob",
                        "content": "Why is there no official solution for this question?"
                    }
                ]
            },
            {
                "id": 1770824,
                "content": [
                    {
                        "username": "carminemangione",
                        "content": "I solved the code in Java with a provably best memory and performance model (first principles because i am a nerd) but was rated in the 20% for memory and performance. Does the environment not use a JIT? "
                    },
                    {
                        "username": "hassamUllah23",
                        "content": "### What the he*l?\\nmy code just failed a test case where...\\n `nums1=[1,1]` and `nums2=[1,2]`\\nthe resulting merged array would be `merged = [1,2]`\\nsubsequently, the median would be `median = (1+2)/2 = 1.5`\\n\\n**THEN HOW IS THE EXPECTED OUTPUT 1.0????**\\n\\nam I missing something in [My Code](https://leetcode.com/playground/iNNGzEUR) ?"
                    },
                    {
                        "username": "TableLadder39",
                        "content": "The resulting merged array in that case would be [1,1,1,2]"
                    },
                    {
                        "username": "Rohan_88",
                        "content": "ROHAN SIBY \n$arr1 = $nums1;\n        $arr2 = $nums2;\n        $arrayFull = array_merge($arr1,$arr2);\n        array_multisort($arrayFull,SORT_ASC,SORT_NUMERIC);\n        $count=count($arrayFull);\n\n        if($count%2 == 0){\n            $outputMedian = $arrayFull[$count/2] + $arrayFull[($count/2)-1];\n            $outputMedian = $outputMedian / 2;\n        } else {\n            $outputMedian = $arrayFull[$count/2];\n        }\n        echo \"Answer: \".$outputMedian;\n    }\n\nI have written this and I am getting correct answer in stdout but on output ta, I am not getting the answer. Any problem with compling PHP code?\n\nWhen I try to submit this Its not accepting Answer"
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "This is not a hard problem\\nyou just need to create an array which will store the elements of both the arrays.\\nAfter that sort the array\\nif the length is even then mean of 2 mid elements will be the answer \\nelse the mid element will give you the answer\\nhere is the solution you can check it but before that you can try it once by this method\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3073793/java-easy-solution/"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem is easy if we do that. But using sort function, has as runtime complexity O(nlog(n)). I don\\'t talk  about creating the new array. It take also same time depending in the language used.\\nThe problem is hard because you must resolve it in a runtime complexity equal to O(log(n)).\\nN. B. the length of both arrays is  lesser than 1000 in constraints. In that case we cane consider the runtime as constant time. And because of that, your approach can pass the test. But with length huge than that , it can\\'."
                    },
                    {
                        "username": "felix097",
                        "content": "How come this problem is rated as Hard, reading comments below asking such kind of question in interview is totally idiotic. It is very easy problem unless you check the term median of array. I didn't even check the solution I just solved it after knowing what was I asked."
                    },
                    {
                        "username": "abhi_prasad",
                        "content": "int m = nums1.length;\\n        int n = nums2.length;\\n        int a[] = new int[m+n];\\n        int i = 0, j=0, k=0;\\n        while(i<m&&j<n)\\n        {\\n            if (nums1[i]<nums2[j])\\n            {\\n                a[k]=nums1[i];\\n                i++;\\n            } \\n            else{\\n                 a[k]=nums2[j];\\n                 j++;\\n            }\\n            k++;\\n        }\\n        while(i<m){\\n            a[k]=nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n){\\n            a[k]=nums2[j];\\n            j++;\\n            k++;\\n        }\\n        if((m+n)%2!=0){\\n            return a[(m+n)/2];\\n        }\\n        else{\\n            int x =(m+n)/2;\\n            double p =a[x];\\n            double q=a[x-1];\\n            return(p+q)/2;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": " class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1.sort()\\n        if(len(nums1)%2==0):\\n            return (nums1[len(nums1)//2-1]+nums1[len(nums1)//2])/2\\n        else:\\n            return nums1[len(nums1)//2]"
                    },
                    {
                        "username": "abhiabhishek9347",
                        "content": "Generally by using the formula of median we can do the job but in case 2032 it arises a schenario where the nums1 and nums2 having the values (0,0) "
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        new=nums1+nums2\\n        new.sort()\\n        low,high=0,len(new)-1\\n        while(low<=high):\\n            mid=low+(high-low)//2\\n            if(len(new)%2==0):\\n                return (new[mid]+new[mid+1])/2\\n            else:\\n                return new[mid]\\nwhats wrong with my code"
                    },
                    {
                        "username": "codernoob",
                        "content": "Why is there no official solution for this question?"
                    }
                ]
            },
            {
                "id": 1765274,
                "content": [
                    {
                        "username": "carminemangione",
                        "content": "I solved the code in Java with a provably best memory and performance model (first principles because i am a nerd) but was rated in the 20% for memory and performance. Does the environment not use a JIT? "
                    },
                    {
                        "username": "hassamUllah23",
                        "content": "### What the he*l?\\nmy code just failed a test case where...\\n `nums1=[1,1]` and `nums2=[1,2]`\\nthe resulting merged array would be `merged = [1,2]`\\nsubsequently, the median would be `median = (1+2)/2 = 1.5`\\n\\n**THEN HOW IS THE EXPECTED OUTPUT 1.0????**\\n\\nam I missing something in [My Code](https://leetcode.com/playground/iNNGzEUR) ?"
                    },
                    {
                        "username": "TableLadder39",
                        "content": "The resulting merged array in that case would be [1,1,1,2]"
                    },
                    {
                        "username": "Rohan_88",
                        "content": "ROHAN SIBY \n$arr1 = $nums1;\n        $arr2 = $nums2;\n        $arrayFull = array_merge($arr1,$arr2);\n        array_multisort($arrayFull,SORT_ASC,SORT_NUMERIC);\n        $count=count($arrayFull);\n\n        if($count%2 == 0){\n            $outputMedian = $arrayFull[$count/2] + $arrayFull[($count/2)-1];\n            $outputMedian = $outputMedian / 2;\n        } else {\n            $outputMedian = $arrayFull[$count/2];\n        }\n        echo \"Answer: \".$outputMedian;\n    }\n\nI have written this and I am getting correct answer in stdout but on output ta, I am not getting the answer. Any problem with compling PHP code?\n\nWhen I try to submit this Its not accepting Answer"
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "This is not a hard problem\\nyou just need to create an array which will store the elements of both the arrays.\\nAfter that sort the array\\nif the length is even then mean of 2 mid elements will be the answer \\nelse the mid element will give you the answer\\nhere is the solution you can check it but before that you can try it once by this method\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3073793/java-easy-solution/"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem is easy if we do that. But using sort function, has as runtime complexity O(nlog(n)). I don\\'t talk  about creating the new array. It take also same time depending in the language used.\\nThe problem is hard because you must resolve it in a runtime complexity equal to O(log(n)).\\nN. B. the length of both arrays is  lesser than 1000 in constraints. In that case we cane consider the runtime as constant time. And because of that, your approach can pass the test. But with length huge than that , it can\\'."
                    },
                    {
                        "username": "felix097",
                        "content": "How come this problem is rated as Hard, reading comments below asking such kind of question in interview is totally idiotic. It is very easy problem unless you check the term median of array. I didn't even check the solution I just solved it after knowing what was I asked."
                    },
                    {
                        "username": "abhi_prasad",
                        "content": "int m = nums1.length;\\n        int n = nums2.length;\\n        int a[] = new int[m+n];\\n        int i = 0, j=0, k=0;\\n        while(i<m&&j<n)\\n        {\\n            if (nums1[i]<nums2[j])\\n            {\\n                a[k]=nums1[i];\\n                i++;\\n            } \\n            else{\\n                 a[k]=nums2[j];\\n                 j++;\\n            }\\n            k++;\\n        }\\n        while(i<m){\\n            a[k]=nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n){\\n            a[k]=nums2[j];\\n            j++;\\n            k++;\\n        }\\n        if((m+n)%2!=0){\\n            return a[(m+n)/2];\\n        }\\n        else{\\n            int x =(m+n)/2;\\n            double p =a[x];\\n            double q=a[x-1];\\n            return(p+q)/2;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": " class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1.sort()\\n        if(len(nums1)%2==0):\\n            return (nums1[len(nums1)//2-1]+nums1[len(nums1)//2])/2\\n        else:\\n            return nums1[len(nums1)//2]"
                    },
                    {
                        "username": "abhiabhishek9347",
                        "content": "Generally by using the formula of median we can do the job but in case 2032 it arises a schenario where the nums1 and nums2 having the values (0,0) "
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        new=nums1+nums2\\n        new.sort()\\n        low,high=0,len(new)-1\\n        while(low<=high):\\n            mid=low+(high-low)//2\\n            if(len(new)%2==0):\\n                return (new[mid]+new[mid+1])/2\\n            else:\\n                return new[mid]\\nwhats wrong with my code"
                    },
                    {
                        "username": "codernoob",
                        "content": "Why is there no official solution for this question?"
                    }
                ]
            },
            {
                "id": 1762436,
                "content": [
                    {
                        "username": "carminemangione",
                        "content": "I solved the code in Java with a provably best memory and performance model (first principles because i am a nerd) but was rated in the 20% for memory and performance. Does the environment not use a JIT? "
                    },
                    {
                        "username": "hassamUllah23",
                        "content": "### What the he*l?\\nmy code just failed a test case where...\\n `nums1=[1,1]` and `nums2=[1,2]`\\nthe resulting merged array would be `merged = [1,2]`\\nsubsequently, the median would be `median = (1+2)/2 = 1.5`\\n\\n**THEN HOW IS THE EXPECTED OUTPUT 1.0????**\\n\\nam I missing something in [My Code](https://leetcode.com/playground/iNNGzEUR) ?"
                    },
                    {
                        "username": "TableLadder39",
                        "content": "The resulting merged array in that case would be [1,1,1,2]"
                    },
                    {
                        "username": "Rohan_88",
                        "content": "ROHAN SIBY \n$arr1 = $nums1;\n        $arr2 = $nums2;\n        $arrayFull = array_merge($arr1,$arr2);\n        array_multisort($arrayFull,SORT_ASC,SORT_NUMERIC);\n        $count=count($arrayFull);\n\n        if($count%2 == 0){\n            $outputMedian = $arrayFull[$count/2] + $arrayFull[($count/2)-1];\n            $outputMedian = $outputMedian / 2;\n        } else {\n            $outputMedian = $arrayFull[$count/2];\n        }\n        echo \"Answer: \".$outputMedian;\n    }\n\nI have written this and I am getting correct answer in stdout but on output ta, I am not getting the answer. Any problem with compling PHP code?\n\nWhen I try to submit this Its not accepting Answer"
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "This is not a hard problem\\nyou just need to create an array which will store the elements of both the arrays.\\nAfter that sort the array\\nif the length is even then mean of 2 mid elements will be the answer \\nelse the mid element will give you the answer\\nhere is the solution you can check it but before that you can try it once by this method\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3073793/java-easy-solution/"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem is easy if we do that. But using sort function, has as runtime complexity O(nlog(n)). I don\\'t talk  about creating the new array. It take also same time depending in the language used.\\nThe problem is hard because you must resolve it in a runtime complexity equal to O(log(n)).\\nN. B. the length of both arrays is  lesser than 1000 in constraints. In that case we cane consider the runtime as constant time. And because of that, your approach can pass the test. But with length huge than that , it can\\'."
                    },
                    {
                        "username": "felix097",
                        "content": "How come this problem is rated as Hard, reading comments below asking such kind of question in interview is totally idiotic. It is very easy problem unless you check the term median of array. I didn't even check the solution I just solved it after knowing what was I asked."
                    },
                    {
                        "username": "abhi_prasad",
                        "content": "int m = nums1.length;\\n        int n = nums2.length;\\n        int a[] = new int[m+n];\\n        int i = 0, j=0, k=0;\\n        while(i<m&&j<n)\\n        {\\n            if (nums1[i]<nums2[j])\\n            {\\n                a[k]=nums1[i];\\n                i++;\\n            } \\n            else{\\n                 a[k]=nums2[j];\\n                 j++;\\n            }\\n            k++;\\n        }\\n        while(i<m){\\n            a[k]=nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n){\\n            a[k]=nums2[j];\\n            j++;\\n            k++;\\n        }\\n        if((m+n)%2!=0){\\n            return a[(m+n)/2];\\n        }\\n        else{\\n            int x =(m+n)/2;\\n            double p =a[x];\\n            double q=a[x-1];\\n            return(p+q)/2;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": " class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1.sort()\\n        if(len(nums1)%2==0):\\n            return (nums1[len(nums1)//2-1]+nums1[len(nums1)//2])/2\\n        else:\\n            return nums1[len(nums1)//2]"
                    },
                    {
                        "username": "abhiabhishek9347",
                        "content": "Generally by using the formula of median we can do the job but in case 2032 it arises a schenario where the nums1 and nums2 having the values (0,0) "
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        new=nums1+nums2\\n        new.sort()\\n        low,high=0,len(new)-1\\n        while(low<=high):\\n            mid=low+(high-low)//2\\n            if(len(new)%2==0):\\n                return (new[mid]+new[mid+1])/2\\n            else:\\n                return new[mid]\\nwhats wrong with my code"
                    },
                    {
                        "username": "codernoob",
                        "content": "Why is there no official solution for this question?"
                    }
                ]
            },
            {
                "id": 1762166,
                "content": [
                    {
                        "username": "carminemangione",
                        "content": "I solved the code in Java with a provably best memory and performance model (first principles because i am a nerd) but was rated in the 20% for memory and performance. Does the environment not use a JIT? "
                    },
                    {
                        "username": "hassamUllah23",
                        "content": "### What the he*l?\\nmy code just failed a test case where...\\n `nums1=[1,1]` and `nums2=[1,2]`\\nthe resulting merged array would be `merged = [1,2]`\\nsubsequently, the median would be `median = (1+2)/2 = 1.5`\\n\\n**THEN HOW IS THE EXPECTED OUTPUT 1.0????**\\n\\nam I missing something in [My Code](https://leetcode.com/playground/iNNGzEUR) ?"
                    },
                    {
                        "username": "TableLadder39",
                        "content": "The resulting merged array in that case would be [1,1,1,2]"
                    },
                    {
                        "username": "Rohan_88",
                        "content": "ROHAN SIBY \n$arr1 = $nums1;\n        $arr2 = $nums2;\n        $arrayFull = array_merge($arr1,$arr2);\n        array_multisort($arrayFull,SORT_ASC,SORT_NUMERIC);\n        $count=count($arrayFull);\n\n        if($count%2 == 0){\n            $outputMedian = $arrayFull[$count/2] + $arrayFull[($count/2)-1];\n            $outputMedian = $outputMedian / 2;\n        } else {\n            $outputMedian = $arrayFull[$count/2];\n        }\n        echo \"Answer: \".$outputMedian;\n    }\n\nI have written this and I am getting correct answer in stdout but on output ta, I am not getting the answer. Any problem with compling PHP code?\n\nWhen I try to submit this Its not accepting Answer"
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "This is not a hard problem\\nyou just need to create an array which will store the elements of both the arrays.\\nAfter that sort the array\\nif the length is even then mean of 2 mid elements will be the answer \\nelse the mid element will give you the answer\\nhere is the solution you can check it but before that you can try it once by this method\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3073793/java-easy-solution/"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem is easy if we do that. But using sort function, has as runtime complexity O(nlog(n)). I don\\'t talk  about creating the new array. It take also same time depending in the language used.\\nThe problem is hard because you must resolve it in a runtime complexity equal to O(log(n)).\\nN. B. the length of both arrays is  lesser than 1000 in constraints. In that case we cane consider the runtime as constant time. And because of that, your approach can pass the test. But with length huge than that , it can\\'."
                    },
                    {
                        "username": "felix097",
                        "content": "How come this problem is rated as Hard, reading comments below asking such kind of question in interview is totally idiotic. It is very easy problem unless you check the term median of array. I didn't even check the solution I just solved it after knowing what was I asked."
                    },
                    {
                        "username": "abhi_prasad",
                        "content": "int m = nums1.length;\\n        int n = nums2.length;\\n        int a[] = new int[m+n];\\n        int i = 0, j=0, k=0;\\n        while(i<m&&j<n)\\n        {\\n            if (nums1[i]<nums2[j])\\n            {\\n                a[k]=nums1[i];\\n                i++;\\n            } \\n            else{\\n                 a[k]=nums2[j];\\n                 j++;\\n            }\\n            k++;\\n        }\\n        while(i<m){\\n            a[k]=nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n){\\n            a[k]=nums2[j];\\n            j++;\\n            k++;\\n        }\\n        if((m+n)%2!=0){\\n            return a[(m+n)/2];\\n        }\\n        else{\\n            int x =(m+n)/2;\\n            double p =a[x];\\n            double q=a[x-1];\\n            return(p+q)/2;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": " class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1.sort()\\n        if(len(nums1)%2==0):\\n            return (nums1[len(nums1)//2-1]+nums1[len(nums1)//2])/2\\n        else:\\n            return nums1[len(nums1)//2]"
                    },
                    {
                        "username": "abhiabhishek9347",
                        "content": "Generally by using the formula of median we can do the job but in case 2032 it arises a schenario where the nums1 and nums2 having the values (0,0) "
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        new=nums1+nums2\\n        new.sort()\\n        low,high=0,len(new)-1\\n        while(low<=high):\\n            mid=low+(high-low)//2\\n            if(len(new)%2==0):\\n                return (new[mid]+new[mid+1])/2\\n            else:\\n                return new[mid]\\nwhats wrong with my code"
                    },
                    {
                        "username": "codernoob",
                        "content": "Why is there no official solution for this question?"
                    }
                ]
            },
            {
                "id": 1761835,
                "content": [
                    {
                        "username": "carminemangione",
                        "content": "I solved the code in Java with a provably best memory and performance model (first principles because i am a nerd) but was rated in the 20% for memory and performance. Does the environment not use a JIT? "
                    },
                    {
                        "username": "hassamUllah23",
                        "content": "### What the he*l?\\nmy code just failed a test case where...\\n `nums1=[1,1]` and `nums2=[1,2]`\\nthe resulting merged array would be `merged = [1,2]`\\nsubsequently, the median would be `median = (1+2)/2 = 1.5`\\n\\n**THEN HOW IS THE EXPECTED OUTPUT 1.0????**\\n\\nam I missing something in [My Code](https://leetcode.com/playground/iNNGzEUR) ?"
                    },
                    {
                        "username": "TableLadder39",
                        "content": "The resulting merged array in that case would be [1,1,1,2]"
                    },
                    {
                        "username": "Rohan_88",
                        "content": "ROHAN SIBY \n$arr1 = $nums1;\n        $arr2 = $nums2;\n        $arrayFull = array_merge($arr1,$arr2);\n        array_multisort($arrayFull,SORT_ASC,SORT_NUMERIC);\n        $count=count($arrayFull);\n\n        if($count%2 == 0){\n            $outputMedian = $arrayFull[$count/2] + $arrayFull[($count/2)-1];\n            $outputMedian = $outputMedian / 2;\n        } else {\n            $outputMedian = $arrayFull[$count/2];\n        }\n        echo \"Answer: \".$outputMedian;\n    }\n\nI have written this and I am getting correct answer in stdout but on output ta, I am not getting the answer. Any problem with compling PHP code?\n\nWhen I try to submit this Its not accepting Answer"
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "This is not a hard problem\\nyou just need to create an array which will store the elements of both the arrays.\\nAfter that sort the array\\nif the length is even then mean of 2 mid elements will be the answer \\nelse the mid element will give you the answer\\nhere is the solution you can check it but before that you can try it once by this method\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3073793/java-easy-solution/"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem is easy if we do that. But using sort function, has as runtime complexity O(nlog(n)). I don\\'t talk  about creating the new array. It take also same time depending in the language used.\\nThe problem is hard because you must resolve it in a runtime complexity equal to O(log(n)).\\nN. B. the length of both arrays is  lesser than 1000 in constraints. In that case we cane consider the runtime as constant time. And because of that, your approach can pass the test. But with length huge than that , it can\\'."
                    },
                    {
                        "username": "felix097",
                        "content": "How come this problem is rated as Hard, reading comments below asking such kind of question in interview is totally idiotic. It is very easy problem unless you check the term median of array. I didn't even check the solution I just solved it after knowing what was I asked."
                    },
                    {
                        "username": "abhi_prasad",
                        "content": "int m = nums1.length;\\n        int n = nums2.length;\\n        int a[] = new int[m+n];\\n        int i = 0, j=0, k=0;\\n        while(i<m&&j<n)\\n        {\\n            if (nums1[i]<nums2[j])\\n            {\\n                a[k]=nums1[i];\\n                i++;\\n            } \\n            else{\\n                 a[k]=nums2[j];\\n                 j++;\\n            }\\n            k++;\\n        }\\n        while(i<m){\\n            a[k]=nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n){\\n            a[k]=nums2[j];\\n            j++;\\n            k++;\\n        }\\n        if((m+n)%2!=0){\\n            return a[(m+n)/2];\\n        }\\n        else{\\n            int x =(m+n)/2;\\n            double p =a[x];\\n            double q=a[x-1];\\n            return(p+q)/2;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": " class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1.sort()\\n        if(len(nums1)%2==0):\\n            return (nums1[len(nums1)//2-1]+nums1[len(nums1)//2])/2\\n        else:\\n            return nums1[len(nums1)//2]"
                    },
                    {
                        "username": "abhiabhishek9347",
                        "content": "Generally by using the formula of median we can do the job but in case 2032 it arises a schenario where the nums1 and nums2 having the values (0,0) "
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        new=nums1+nums2\\n        new.sort()\\n        low,high=0,len(new)-1\\n        while(low<=high):\\n            mid=low+(high-low)//2\\n            if(len(new)%2==0):\\n                return (new[mid]+new[mid+1])/2\\n            else:\\n                return new[mid]\\nwhats wrong with my code"
                    },
                    {
                        "username": "codernoob",
                        "content": "Why is there no official solution for this question?"
                    }
                ]
            },
            {
                "id": 1760035,
                "content": [
                    {
                        "username": "carminemangione",
                        "content": "I solved the code in Java with a provably best memory and performance model (first principles because i am a nerd) but was rated in the 20% for memory and performance. Does the environment not use a JIT? "
                    },
                    {
                        "username": "hassamUllah23",
                        "content": "### What the he*l?\\nmy code just failed a test case where...\\n `nums1=[1,1]` and `nums2=[1,2]`\\nthe resulting merged array would be `merged = [1,2]`\\nsubsequently, the median would be `median = (1+2)/2 = 1.5`\\n\\n**THEN HOW IS THE EXPECTED OUTPUT 1.0????**\\n\\nam I missing something in [My Code](https://leetcode.com/playground/iNNGzEUR) ?"
                    },
                    {
                        "username": "TableLadder39",
                        "content": "The resulting merged array in that case would be [1,1,1,2]"
                    },
                    {
                        "username": "Rohan_88",
                        "content": "ROHAN SIBY \n$arr1 = $nums1;\n        $arr2 = $nums2;\n        $arrayFull = array_merge($arr1,$arr2);\n        array_multisort($arrayFull,SORT_ASC,SORT_NUMERIC);\n        $count=count($arrayFull);\n\n        if($count%2 == 0){\n            $outputMedian = $arrayFull[$count/2] + $arrayFull[($count/2)-1];\n            $outputMedian = $outputMedian / 2;\n        } else {\n            $outputMedian = $arrayFull[$count/2];\n        }\n        echo \"Answer: \".$outputMedian;\n    }\n\nI have written this and I am getting correct answer in stdout but on output ta, I am not getting the answer. Any problem with compling PHP code?\n\nWhen I try to submit this Its not accepting Answer"
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "This is not a hard problem\\nyou just need to create an array which will store the elements of both the arrays.\\nAfter that sort the array\\nif the length is even then mean of 2 mid elements will be the answer \\nelse the mid element will give you the answer\\nhere is the solution you can check it but before that you can try it once by this method\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3073793/java-easy-solution/"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem is easy if we do that. But using sort function, has as runtime complexity O(nlog(n)). I don\\'t talk  about creating the new array. It take also same time depending in the language used.\\nThe problem is hard because you must resolve it in a runtime complexity equal to O(log(n)).\\nN. B. the length of both arrays is  lesser than 1000 in constraints. In that case we cane consider the runtime as constant time. And because of that, your approach can pass the test. But with length huge than that , it can\\'."
                    },
                    {
                        "username": "felix097",
                        "content": "How come this problem is rated as Hard, reading comments below asking such kind of question in interview is totally idiotic. It is very easy problem unless you check the term median of array. I didn't even check the solution I just solved it after knowing what was I asked."
                    },
                    {
                        "username": "abhi_prasad",
                        "content": "int m = nums1.length;\\n        int n = nums2.length;\\n        int a[] = new int[m+n];\\n        int i = 0, j=0, k=0;\\n        while(i<m&&j<n)\\n        {\\n            if (nums1[i]<nums2[j])\\n            {\\n                a[k]=nums1[i];\\n                i++;\\n            } \\n            else{\\n                 a[k]=nums2[j];\\n                 j++;\\n            }\\n            k++;\\n        }\\n        while(i<m){\\n            a[k]=nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n){\\n            a[k]=nums2[j];\\n            j++;\\n            k++;\\n        }\\n        if((m+n)%2!=0){\\n            return a[(m+n)/2];\\n        }\\n        else{\\n            int x =(m+n)/2;\\n            double p =a[x];\\n            double q=a[x-1];\\n            return(p+q)/2;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": " class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1.sort()\\n        if(len(nums1)%2==0):\\n            return (nums1[len(nums1)//2-1]+nums1[len(nums1)//2])/2\\n        else:\\n            return nums1[len(nums1)//2]"
                    },
                    {
                        "username": "abhiabhishek9347",
                        "content": "Generally by using the formula of median we can do the job but in case 2032 it arises a schenario where the nums1 and nums2 having the values (0,0) "
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        new=nums1+nums2\\n        new.sort()\\n        low,high=0,len(new)-1\\n        while(low<=high):\\n            mid=low+(high-low)//2\\n            if(len(new)%2==0):\\n                return (new[mid]+new[mid+1])/2\\n            else:\\n                return new[mid]\\nwhats wrong with my code"
                    },
                    {
                        "username": "codernoob",
                        "content": "Why is there no official solution for this question?"
                    }
                ]
            },
            {
                "id": 1759094,
                "content": [
                    {
                        "username": "carminemangione",
                        "content": "I solved the code in Java with a provably best memory and performance model (first principles because i am a nerd) but was rated in the 20% for memory and performance. Does the environment not use a JIT? "
                    },
                    {
                        "username": "hassamUllah23",
                        "content": "### What the he*l?\\nmy code just failed a test case where...\\n `nums1=[1,1]` and `nums2=[1,2]`\\nthe resulting merged array would be `merged = [1,2]`\\nsubsequently, the median would be `median = (1+2)/2 = 1.5`\\n\\n**THEN HOW IS THE EXPECTED OUTPUT 1.0????**\\n\\nam I missing something in [My Code](https://leetcode.com/playground/iNNGzEUR) ?"
                    },
                    {
                        "username": "TableLadder39",
                        "content": "The resulting merged array in that case would be [1,1,1,2]"
                    },
                    {
                        "username": "Rohan_88",
                        "content": "ROHAN SIBY \n$arr1 = $nums1;\n        $arr2 = $nums2;\n        $arrayFull = array_merge($arr1,$arr2);\n        array_multisort($arrayFull,SORT_ASC,SORT_NUMERIC);\n        $count=count($arrayFull);\n\n        if($count%2 == 0){\n            $outputMedian = $arrayFull[$count/2] + $arrayFull[($count/2)-1];\n            $outputMedian = $outputMedian / 2;\n        } else {\n            $outputMedian = $arrayFull[$count/2];\n        }\n        echo \"Answer: \".$outputMedian;\n    }\n\nI have written this and I am getting correct answer in stdout but on output ta, I am not getting the answer. Any problem with compling PHP code?\n\nWhen I try to submit this Its not accepting Answer"
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "This is not a hard problem\\nyou just need to create an array which will store the elements of both the arrays.\\nAfter that sort the array\\nif the length is even then mean of 2 mid elements will be the answer \\nelse the mid element will give you the answer\\nhere is the solution you can check it but before that you can try it once by this method\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3073793/java-easy-solution/"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem is easy if we do that. But using sort function, has as runtime complexity O(nlog(n)). I don\\'t talk  about creating the new array. It take also same time depending in the language used.\\nThe problem is hard because you must resolve it in a runtime complexity equal to O(log(n)).\\nN. B. the length of both arrays is  lesser than 1000 in constraints. In that case we cane consider the runtime as constant time. And because of that, your approach can pass the test. But with length huge than that , it can\\'."
                    },
                    {
                        "username": "felix097",
                        "content": "How come this problem is rated as Hard, reading comments below asking such kind of question in interview is totally idiotic. It is very easy problem unless you check the term median of array. I didn't even check the solution I just solved it after knowing what was I asked."
                    },
                    {
                        "username": "abhi_prasad",
                        "content": "int m = nums1.length;\\n        int n = nums2.length;\\n        int a[] = new int[m+n];\\n        int i = 0, j=0, k=0;\\n        while(i<m&&j<n)\\n        {\\n            if (nums1[i]<nums2[j])\\n            {\\n                a[k]=nums1[i];\\n                i++;\\n            } \\n            else{\\n                 a[k]=nums2[j];\\n                 j++;\\n            }\\n            k++;\\n        }\\n        while(i<m){\\n            a[k]=nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n){\\n            a[k]=nums2[j];\\n            j++;\\n            k++;\\n        }\\n        if((m+n)%2!=0){\\n            return a[(m+n)/2];\\n        }\\n        else{\\n            int x =(m+n)/2;\\n            double p =a[x];\\n            double q=a[x-1];\\n            return(p+q)/2;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": " class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1.sort()\\n        if(len(nums1)%2==0):\\n            return (nums1[len(nums1)//2-1]+nums1[len(nums1)//2])/2\\n        else:\\n            return nums1[len(nums1)//2]"
                    },
                    {
                        "username": "abhiabhishek9347",
                        "content": "Generally by using the formula of median we can do the job but in case 2032 it arises a schenario where the nums1 and nums2 having the values (0,0) "
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        new=nums1+nums2\\n        new.sort()\\n        low,high=0,len(new)-1\\n        while(low<=high):\\n            mid=low+(high-low)//2\\n            if(len(new)%2==0):\\n                return (new[mid]+new[mid+1])/2\\n            else:\\n                return new[mid]\\nwhats wrong with my code"
                    },
                    {
                        "username": "codernoob",
                        "content": "Why is there no official solution for this question?"
                    }
                ]
            },
            {
                "id": 1758277,
                "content": [
                    {
                        "username": "carminemangione",
                        "content": "I solved the code in Java with a provably best memory and performance model (first principles because i am a nerd) but was rated in the 20% for memory and performance. Does the environment not use a JIT? "
                    },
                    {
                        "username": "hassamUllah23",
                        "content": "### What the he*l?\\nmy code just failed a test case where...\\n `nums1=[1,1]` and `nums2=[1,2]`\\nthe resulting merged array would be `merged = [1,2]`\\nsubsequently, the median would be `median = (1+2)/2 = 1.5`\\n\\n**THEN HOW IS THE EXPECTED OUTPUT 1.0????**\\n\\nam I missing something in [My Code](https://leetcode.com/playground/iNNGzEUR) ?"
                    },
                    {
                        "username": "TableLadder39",
                        "content": "The resulting merged array in that case would be [1,1,1,2]"
                    },
                    {
                        "username": "Rohan_88",
                        "content": "ROHAN SIBY \n$arr1 = $nums1;\n        $arr2 = $nums2;\n        $arrayFull = array_merge($arr1,$arr2);\n        array_multisort($arrayFull,SORT_ASC,SORT_NUMERIC);\n        $count=count($arrayFull);\n\n        if($count%2 == 0){\n            $outputMedian = $arrayFull[$count/2] + $arrayFull[($count/2)-1];\n            $outputMedian = $outputMedian / 2;\n        } else {\n            $outputMedian = $arrayFull[$count/2];\n        }\n        echo \"Answer: \".$outputMedian;\n    }\n\nI have written this and I am getting correct answer in stdout but on output ta, I am not getting the answer. Any problem with compling PHP code?\n\nWhen I try to submit this Its not accepting Answer"
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "This is not a hard problem\\nyou just need to create an array which will store the elements of both the arrays.\\nAfter that sort the array\\nif the length is even then mean of 2 mid elements will be the answer \\nelse the mid element will give you the answer\\nhere is the solution you can check it but before that you can try it once by this method\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3073793/java-easy-solution/"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem is easy if we do that. But using sort function, has as runtime complexity O(nlog(n)). I don\\'t talk  about creating the new array. It take also same time depending in the language used.\\nThe problem is hard because you must resolve it in a runtime complexity equal to O(log(n)).\\nN. B. the length of both arrays is  lesser than 1000 in constraints. In that case we cane consider the runtime as constant time. And because of that, your approach can pass the test. But with length huge than that , it can\\'."
                    },
                    {
                        "username": "felix097",
                        "content": "How come this problem is rated as Hard, reading comments below asking such kind of question in interview is totally idiotic. It is very easy problem unless you check the term median of array. I didn't even check the solution I just solved it after knowing what was I asked."
                    },
                    {
                        "username": "abhi_prasad",
                        "content": "int m = nums1.length;\\n        int n = nums2.length;\\n        int a[] = new int[m+n];\\n        int i = 0, j=0, k=0;\\n        while(i<m&&j<n)\\n        {\\n            if (nums1[i]<nums2[j])\\n            {\\n                a[k]=nums1[i];\\n                i++;\\n            } \\n            else{\\n                 a[k]=nums2[j];\\n                 j++;\\n            }\\n            k++;\\n        }\\n        while(i<m){\\n            a[k]=nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n){\\n            a[k]=nums2[j];\\n            j++;\\n            k++;\\n        }\\n        if((m+n)%2!=0){\\n            return a[(m+n)/2];\\n        }\\n        else{\\n            int x =(m+n)/2;\\n            double p =a[x];\\n            double q=a[x-1];\\n            return(p+q)/2;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": " class Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        for i in nums2:\\n            nums1.append(i)\\n        nums1.sort()\\n        if(len(nums1)%2==0):\\n            return (nums1[len(nums1)//2-1]+nums1[len(nums1)//2])/2\\n        else:\\n            return nums1[len(nums1)//2]"
                    },
                    {
                        "username": "abhiabhishek9347",
                        "content": "Generally by using the formula of median we can do the job but in case 2032 it arises a schenario where the nums1 and nums2 having the values (0,0) "
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        new=nums1+nums2\\n        new.sort()\\n        low,high=0,len(new)-1\\n        while(low<=high):\\n            mid=low+(high-low)//2\\n            if(len(new)%2==0):\\n                return (new[mid]+new[mid+1])/2\\n            else:\\n                return new[mid]\\nwhats wrong with my code"
                    },
                    {
                        "username": "codernoob",
                        "content": "Why is there no official solution for this question?"
                    }
                ]
            },
            {
                "id": 1756531,
                "content": [
                    {
                        "username": "Bruhtholomew",
                        "content": "```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums = nums1 + nums2\\n        counter = 0\\n        total = 0\\n        for i in nums:\\n            total += i\\n            counter += 1\\n\\n        answer = float(total / counter)\\n        return answer\\n```\\nWhy doesn\\'t this work? The Output is 2.0 on leetcode, but when I run it in my console its 2.5.\\nThanks in advance!\\nxoxo"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        nums1.extend(nums2)\\n        l1=len(nums1)\\n        nums1.sort()\\n        if(l1%2==0):\\n            \\n            return (float(nums1[l1/2]+nums1[(l1/2)-1])/2)\\n        else:\\n            return nums1[l1//2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Manoj_Kumar_Devisetti",
                        "content": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        for i in nums2:\n            nums1.append(i)\n        nums1.sort()\n        if(len(nums1)%2!=0):\n            return nums1[len(nums1)//2]\n        else:\n            return (nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2"
                    },
                    {
                        "username": "sanketannadate6",
                        "content": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n    int m = nums1.size();\\n    int n = nums2.size();\\n    if (m > n) {\\n        return findMedianSortedArrays(nums2, nums1);\\n    }\\n    int imin = 0;\\n    int imax = m;\\n    while (imin <= imax) {\\n        int i = (imin + imax) / 2;\\n        int j = (m + n + 1) / 2 - i;\\n        if (i < m && j > 0 && nums2[j-1] > nums1[i]) {\\n            imin = i + 1;\\n        } else if (i > 0 && j < n && nums2[j] < nums1[i-1]) {\\n            imax = i - 1;\\n        } else {\\n            double max_of_left;\\n            if (i == 0) {\\n                max_of_left = nums2[j-1];\\n            } else if (j == 0) {\\n                max_of_left = nums1[i-1];\\n            } else {\\n                max_of_left = max(nums1[i-1], nums2[j-1]);\\n            }\\n            if ((m + n) % 2 == 1) {\\n                return max_of_left;\\n            }\\n            double min_of_right;\\n            if (i == m) {\\n                min_of_right = nums2[j];\\n            } else if (j == n) {\\n                min_of_right = nums1[i];\\n            } else {\\n                min_of_right = min(nums1[i], nums2[j]);\\n            }\\n            return (max_of_left + min_of_right) / 2;\\n        }\\n    }\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "saranshs2021",
                        "content": " class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            \n            nums1, nums2, m, n = nums2, nums1, n, m\n        \n        left, right = 0, m\n        while left <= right:\n            # partition the shorter array\n            i = (left + right) // 2\n            # partition the longer array\n            j = (m + n + 1) // 2 - i\n            if j > 0 and i < m and nums2[j-1] > nums1[i]:\n                # median is in the right half of nums1\n                left = i + 1\n            elif i > 0 and j < n and nums1[i-1] > nums2[j]:\n                # median is in the left half of nums1\n                right = i - 1\n            else:\n                # i is perfect\n                if i == 0:\n                    max_of_left = nums2[j-1]\n                elif j == 0:\n                    max_of_left = nums1[i-1]\n                else:\n                    max_of_left = max(nums1[i-1], nums2[j-1])\n                if (m + n) % 2 == 1:\n                    return max_of_left\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2\n        return -1\n\nWhat is wrong with my code?"
                    },
                    {
                        "username": "fojetin",
                        "content": "The constraints is to weak\\n```\\n0 <= nums1.length == 1000\\n0 <= nums2.length <= 1000\\n```\\n\\nWhen you have only 2000 numbers in merged array every solution will pass, even O(n**3) i think. And of course this complexity don\\'t match with hard task level."
                    },
                    {
                        "username": "lzouknak",
                        "content": "Python 60ms solved, simple code\\n\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        x = sorted(nums1+nums2)\\n        if (0 <= len(nums1) <= 1000 and 0 <= len(nums2) <= 1000) and ( max(x)<=1e6 and min(x)>=-1e6) and (1<= len(x) <= 2000):\\n            if len(x)%2 == 0:\\n                med = 0.5*(x[int(len(x)/2)-1] + x[int(len(x)/2)])\\n            elif len(x)%2 == 1:\\n                med =  x[int(len(x)/2)]\\n        return med "
                    },
                    {
                        "username": "ibbu731",
                        "content": "hello,\\nwhat does \"overall run time complexity\" mean"
                    },
                    {
                        "username": "VishuKalier",
                        "content": " `public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1.length == 0 && nums2.length == 0) \\n            return 0.0;\\n        if(nums1.length > nums2.length)\\n        {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        int lo = 0, hi = nums1.length, total = nums1.length + nums2.length;\\n        while(lo <= hi)\\n        {\\n            int aleft = lo + (hi - lo) / 2;\\n            int bleft = (total + 1) / 2 - aleft;\\n            int maVal = aleft == 0 ? Integer.MIN_VALUE : nums1[aleft - 1];\\n            int mbVal = bleft == 0 ? Integer.MIN_VALUE : nums2[bleft - 1];\\n            int aVal = aleft == nums1.length ? Integer.MAX_VALUE : nums1[aleft];\\n            int bVal = bleft == nums2.length ? Integer.MAX_VALUE : nums2[bleft];\\n            if(maVal <= bVal && mbVal <= aVal)\\n            {\\n                double res = Math.max(maVal, mbVal);\\n                if(total % 2 == 0)\\n                {\\n                    res += Math.min(aVal, bVal);\\n                    res /= 2.0;\\n                }\\n                return res;\\n            }\\n            else if(maVal > bVal)\\n            {\\n                hi = aleft - 1;\\n            }\\n            else\\n            {\\n                lo = aleft + 1;\\n            }\\n        }\\n    return 0.0d;\\n    }`"
                    }
                ]
            },
            {
                "id": 1754141,
                "content": [
                    {
                        "username": "Bruhtholomew",
                        "content": "```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums = nums1 + nums2\\n        counter = 0\\n        total = 0\\n        for i in nums:\\n            total += i\\n            counter += 1\\n\\n        answer = float(total / counter)\\n        return answer\\n```\\nWhy doesn\\'t this work? The Output is 2.0 on leetcode, but when I run it in my console its 2.5.\\nThanks in advance!\\nxoxo"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        nums1.extend(nums2)\\n        l1=len(nums1)\\n        nums1.sort()\\n        if(l1%2==0):\\n            \\n            return (float(nums1[l1/2]+nums1[(l1/2)-1])/2)\\n        else:\\n            return nums1[l1//2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Manoj_Kumar_Devisetti",
                        "content": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        for i in nums2:\n            nums1.append(i)\n        nums1.sort()\n        if(len(nums1)%2!=0):\n            return nums1[len(nums1)//2]\n        else:\n            return (nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2"
                    },
                    {
                        "username": "sanketannadate6",
                        "content": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n    int m = nums1.size();\\n    int n = nums2.size();\\n    if (m > n) {\\n        return findMedianSortedArrays(nums2, nums1);\\n    }\\n    int imin = 0;\\n    int imax = m;\\n    while (imin <= imax) {\\n        int i = (imin + imax) / 2;\\n        int j = (m + n + 1) / 2 - i;\\n        if (i < m && j > 0 && nums2[j-1] > nums1[i]) {\\n            imin = i + 1;\\n        } else if (i > 0 && j < n && nums2[j] < nums1[i-1]) {\\n            imax = i - 1;\\n        } else {\\n            double max_of_left;\\n            if (i == 0) {\\n                max_of_left = nums2[j-1];\\n            } else if (j == 0) {\\n                max_of_left = nums1[i-1];\\n            } else {\\n                max_of_left = max(nums1[i-1], nums2[j-1]);\\n            }\\n            if ((m + n) % 2 == 1) {\\n                return max_of_left;\\n            }\\n            double min_of_right;\\n            if (i == m) {\\n                min_of_right = nums2[j];\\n            } else if (j == n) {\\n                min_of_right = nums1[i];\\n            } else {\\n                min_of_right = min(nums1[i], nums2[j]);\\n            }\\n            return (max_of_left + min_of_right) / 2;\\n        }\\n    }\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "saranshs2021",
                        "content": " class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            \n            nums1, nums2, m, n = nums2, nums1, n, m\n        \n        left, right = 0, m\n        while left <= right:\n            # partition the shorter array\n            i = (left + right) // 2\n            # partition the longer array\n            j = (m + n + 1) // 2 - i\n            if j > 0 and i < m and nums2[j-1] > nums1[i]:\n                # median is in the right half of nums1\n                left = i + 1\n            elif i > 0 and j < n and nums1[i-1] > nums2[j]:\n                # median is in the left half of nums1\n                right = i - 1\n            else:\n                # i is perfect\n                if i == 0:\n                    max_of_left = nums2[j-1]\n                elif j == 0:\n                    max_of_left = nums1[i-1]\n                else:\n                    max_of_left = max(nums1[i-1], nums2[j-1])\n                if (m + n) % 2 == 1:\n                    return max_of_left\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2\n        return -1\n\nWhat is wrong with my code?"
                    },
                    {
                        "username": "fojetin",
                        "content": "The constraints is to weak\\n```\\n0 <= nums1.length == 1000\\n0 <= nums2.length <= 1000\\n```\\n\\nWhen you have only 2000 numbers in merged array every solution will pass, even O(n**3) i think. And of course this complexity don\\'t match with hard task level."
                    },
                    {
                        "username": "lzouknak",
                        "content": "Python 60ms solved, simple code\\n\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        x = sorted(nums1+nums2)\\n        if (0 <= len(nums1) <= 1000 and 0 <= len(nums2) <= 1000) and ( max(x)<=1e6 and min(x)>=-1e6) and (1<= len(x) <= 2000):\\n            if len(x)%2 == 0:\\n                med = 0.5*(x[int(len(x)/2)-1] + x[int(len(x)/2)])\\n            elif len(x)%2 == 1:\\n                med =  x[int(len(x)/2)]\\n        return med "
                    },
                    {
                        "username": "ibbu731",
                        "content": "hello,\\nwhat does \"overall run time complexity\" mean"
                    },
                    {
                        "username": "VishuKalier",
                        "content": " `public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1.length == 0 && nums2.length == 0) \\n            return 0.0;\\n        if(nums1.length > nums2.length)\\n        {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        int lo = 0, hi = nums1.length, total = nums1.length + nums2.length;\\n        while(lo <= hi)\\n        {\\n            int aleft = lo + (hi - lo) / 2;\\n            int bleft = (total + 1) / 2 - aleft;\\n            int maVal = aleft == 0 ? Integer.MIN_VALUE : nums1[aleft - 1];\\n            int mbVal = bleft == 0 ? Integer.MIN_VALUE : nums2[bleft - 1];\\n            int aVal = aleft == nums1.length ? Integer.MAX_VALUE : nums1[aleft];\\n            int bVal = bleft == nums2.length ? Integer.MAX_VALUE : nums2[bleft];\\n            if(maVal <= bVal && mbVal <= aVal)\\n            {\\n                double res = Math.max(maVal, mbVal);\\n                if(total % 2 == 0)\\n                {\\n                    res += Math.min(aVal, bVal);\\n                    res /= 2.0;\\n                }\\n                return res;\\n            }\\n            else if(maVal > bVal)\\n            {\\n                hi = aleft - 1;\\n            }\\n            else\\n            {\\n                lo = aleft + 1;\\n            }\\n        }\\n    return 0.0d;\\n    }`"
                    }
                ]
            },
            {
                "id": 1752579,
                "content": [
                    {
                        "username": "Bruhtholomew",
                        "content": "```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums = nums1 + nums2\\n        counter = 0\\n        total = 0\\n        for i in nums:\\n            total += i\\n            counter += 1\\n\\n        answer = float(total / counter)\\n        return answer\\n```\\nWhy doesn\\'t this work? The Output is 2.0 on leetcode, but when I run it in my console its 2.5.\\nThanks in advance!\\nxoxo"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        nums1.extend(nums2)\\n        l1=len(nums1)\\n        nums1.sort()\\n        if(l1%2==0):\\n            \\n            return (float(nums1[l1/2]+nums1[(l1/2)-1])/2)\\n        else:\\n            return nums1[l1//2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Manoj_Kumar_Devisetti",
                        "content": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        for i in nums2:\n            nums1.append(i)\n        nums1.sort()\n        if(len(nums1)%2!=0):\n            return nums1[len(nums1)//2]\n        else:\n            return (nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2"
                    },
                    {
                        "username": "sanketannadate6",
                        "content": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n    int m = nums1.size();\\n    int n = nums2.size();\\n    if (m > n) {\\n        return findMedianSortedArrays(nums2, nums1);\\n    }\\n    int imin = 0;\\n    int imax = m;\\n    while (imin <= imax) {\\n        int i = (imin + imax) / 2;\\n        int j = (m + n + 1) / 2 - i;\\n        if (i < m && j > 0 && nums2[j-1] > nums1[i]) {\\n            imin = i + 1;\\n        } else if (i > 0 && j < n && nums2[j] < nums1[i-1]) {\\n            imax = i - 1;\\n        } else {\\n            double max_of_left;\\n            if (i == 0) {\\n                max_of_left = nums2[j-1];\\n            } else if (j == 0) {\\n                max_of_left = nums1[i-1];\\n            } else {\\n                max_of_left = max(nums1[i-1], nums2[j-1]);\\n            }\\n            if ((m + n) % 2 == 1) {\\n                return max_of_left;\\n            }\\n            double min_of_right;\\n            if (i == m) {\\n                min_of_right = nums2[j];\\n            } else if (j == n) {\\n                min_of_right = nums1[i];\\n            } else {\\n                min_of_right = min(nums1[i], nums2[j]);\\n            }\\n            return (max_of_left + min_of_right) / 2;\\n        }\\n    }\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "saranshs2021",
                        "content": " class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            \n            nums1, nums2, m, n = nums2, nums1, n, m\n        \n        left, right = 0, m\n        while left <= right:\n            # partition the shorter array\n            i = (left + right) // 2\n            # partition the longer array\n            j = (m + n + 1) // 2 - i\n            if j > 0 and i < m and nums2[j-1] > nums1[i]:\n                # median is in the right half of nums1\n                left = i + 1\n            elif i > 0 and j < n and nums1[i-1] > nums2[j]:\n                # median is in the left half of nums1\n                right = i - 1\n            else:\n                # i is perfect\n                if i == 0:\n                    max_of_left = nums2[j-1]\n                elif j == 0:\n                    max_of_left = nums1[i-1]\n                else:\n                    max_of_left = max(nums1[i-1], nums2[j-1])\n                if (m + n) % 2 == 1:\n                    return max_of_left\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2\n        return -1\n\nWhat is wrong with my code?"
                    },
                    {
                        "username": "fojetin",
                        "content": "The constraints is to weak\\n```\\n0 <= nums1.length == 1000\\n0 <= nums2.length <= 1000\\n```\\n\\nWhen you have only 2000 numbers in merged array every solution will pass, even O(n**3) i think. And of course this complexity don\\'t match with hard task level."
                    },
                    {
                        "username": "lzouknak",
                        "content": "Python 60ms solved, simple code\\n\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        x = sorted(nums1+nums2)\\n        if (0 <= len(nums1) <= 1000 and 0 <= len(nums2) <= 1000) and ( max(x)<=1e6 and min(x)>=-1e6) and (1<= len(x) <= 2000):\\n            if len(x)%2 == 0:\\n                med = 0.5*(x[int(len(x)/2)-1] + x[int(len(x)/2)])\\n            elif len(x)%2 == 1:\\n                med =  x[int(len(x)/2)]\\n        return med "
                    },
                    {
                        "username": "ibbu731",
                        "content": "hello,\\nwhat does \"overall run time complexity\" mean"
                    },
                    {
                        "username": "VishuKalier",
                        "content": " `public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1.length == 0 && nums2.length == 0) \\n            return 0.0;\\n        if(nums1.length > nums2.length)\\n        {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        int lo = 0, hi = nums1.length, total = nums1.length + nums2.length;\\n        while(lo <= hi)\\n        {\\n            int aleft = lo + (hi - lo) / 2;\\n            int bleft = (total + 1) / 2 - aleft;\\n            int maVal = aleft == 0 ? Integer.MIN_VALUE : nums1[aleft - 1];\\n            int mbVal = bleft == 0 ? Integer.MIN_VALUE : nums2[bleft - 1];\\n            int aVal = aleft == nums1.length ? Integer.MAX_VALUE : nums1[aleft];\\n            int bVal = bleft == nums2.length ? Integer.MAX_VALUE : nums2[bleft];\\n            if(maVal <= bVal && mbVal <= aVal)\\n            {\\n                double res = Math.max(maVal, mbVal);\\n                if(total % 2 == 0)\\n                {\\n                    res += Math.min(aVal, bVal);\\n                    res /= 2.0;\\n                }\\n                return res;\\n            }\\n            else if(maVal > bVal)\\n            {\\n                hi = aleft - 1;\\n            }\\n            else\\n            {\\n                lo = aleft + 1;\\n            }\\n        }\\n    return 0.0d;\\n    }`"
                    }
                ]
            },
            {
                "id": 1752165,
                "content": [
                    {
                        "username": "Bruhtholomew",
                        "content": "```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums = nums1 + nums2\\n        counter = 0\\n        total = 0\\n        for i in nums:\\n            total += i\\n            counter += 1\\n\\n        answer = float(total / counter)\\n        return answer\\n```\\nWhy doesn\\'t this work? The Output is 2.0 on leetcode, but when I run it in my console its 2.5.\\nThanks in advance!\\nxoxo"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        nums1.extend(nums2)\\n        l1=len(nums1)\\n        nums1.sort()\\n        if(l1%2==0):\\n            \\n            return (float(nums1[l1/2]+nums1[(l1/2)-1])/2)\\n        else:\\n            return nums1[l1//2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Manoj_Kumar_Devisetti",
                        "content": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        for i in nums2:\n            nums1.append(i)\n        nums1.sort()\n        if(len(nums1)%2!=0):\n            return nums1[len(nums1)//2]\n        else:\n            return (nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2"
                    },
                    {
                        "username": "sanketannadate6",
                        "content": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n    int m = nums1.size();\\n    int n = nums2.size();\\n    if (m > n) {\\n        return findMedianSortedArrays(nums2, nums1);\\n    }\\n    int imin = 0;\\n    int imax = m;\\n    while (imin <= imax) {\\n        int i = (imin + imax) / 2;\\n        int j = (m + n + 1) / 2 - i;\\n        if (i < m && j > 0 && nums2[j-1] > nums1[i]) {\\n            imin = i + 1;\\n        } else if (i > 0 && j < n && nums2[j] < nums1[i-1]) {\\n            imax = i - 1;\\n        } else {\\n            double max_of_left;\\n            if (i == 0) {\\n                max_of_left = nums2[j-1];\\n            } else if (j == 0) {\\n                max_of_left = nums1[i-1];\\n            } else {\\n                max_of_left = max(nums1[i-1], nums2[j-1]);\\n            }\\n            if ((m + n) % 2 == 1) {\\n                return max_of_left;\\n            }\\n            double min_of_right;\\n            if (i == m) {\\n                min_of_right = nums2[j];\\n            } else if (j == n) {\\n                min_of_right = nums1[i];\\n            } else {\\n                min_of_right = min(nums1[i], nums2[j]);\\n            }\\n            return (max_of_left + min_of_right) / 2;\\n        }\\n    }\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "saranshs2021",
                        "content": " class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            \n            nums1, nums2, m, n = nums2, nums1, n, m\n        \n        left, right = 0, m\n        while left <= right:\n            # partition the shorter array\n            i = (left + right) // 2\n            # partition the longer array\n            j = (m + n + 1) // 2 - i\n            if j > 0 and i < m and nums2[j-1] > nums1[i]:\n                # median is in the right half of nums1\n                left = i + 1\n            elif i > 0 and j < n and nums1[i-1] > nums2[j]:\n                # median is in the left half of nums1\n                right = i - 1\n            else:\n                # i is perfect\n                if i == 0:\n                    max_of_left = nums2[j-1]\n                elif j == 0:\n                    max_of_left = nums1[i-1]\n                else:\n                    max_of_left = max(nums1[i-1], nums2[j-1])\n                if (m + n) % 2 == 1:\n                    return max_of_left\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2\n        return -1\n\nWhat is wrong with my code?"
                    },
                    {
                        "username": "fojetin",
                        "content": "The constraints is to weak\\n```\\n0 <= nums1.length == 1000\\n0 <= nums2.length <= 1000\\n```\\n\\nWhen you have only 2000 numbers in merged array every solution will pass, even O(n**3) i think. And of course this complexity don\\'t match with hard task level."
                    },
                    {
                        "username": "lzouknak",
                        "content": "Python 60ms solved, simple code\\n\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        x = sorted(nums1+nums2)\\n        if (0 <= len(nums1) <= 1000 and 0 <= len(nums2) <= 1000) and ( max(x)<=1e6 and min(x)>=-1e6) and (1<= len(x) <= 2000):\\n            if len(x)%2 == 0:\\n                med = 0.5*(x[int(len(x)/2)-1] + x[int(len(x)/2)])\\n            elif len(x)%2 == 1:\\n                med =  x[int(len(x)/2)]\\n        return med "
                    },
                    {
                        "username": "ibbu731",
                        "content": "hello,\\nwhat does \"overall run time complexity\" mean"
                    },
                    {
                        "username": "VishuKalier",
                        "content": " `public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1.length == 0 && nums2.length == 0) \\n            return 0.0;\\n        if(nums1.length > nums2.length)\\n        {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        int lo = 0, hi = nums1.length, total = nums1.length + nums2.length;\\n        while(lo <= hi)\\n        {\\n            int aleft = lo + (hi - lo) / 2;\\n            int bleft = (total + 1) / 2 - aleft;\\n            int maVal = aleft == 0 ? Integer.MIN_VALUE : nums1[aleft - 1];\\n            int mbVal = bleft == 0 ? Integer.MIN_VALUE : nums2[bleft - 1];\\n            int aVal = aleft == nums1.length ? Integer.MAX_VALUE : nums1[aleft];\\n            int bVal = bleft == nums2.length ? Integer.MAX_VALUE : nums2[bleft];\\n            if(maVal <= bVal && mbVal <= aVal)\\n            {\\n                double res = Math.max(maVal, mbVal);\\n                if(total % 2 == 0)\\n                {\\n                    res += Math.min(aVal, bVal);\\n                    res /= 2.0;\\n                }\\n                return res;\\n            }\\n            else if(maVal > bVal)\\n            {\\n                hi = aleft - 1;\\n            }\\n            else\\n            {\\n                lo = aleft + 1;\\n            }\\n        }\\n    return 0.0d;\\n    }`"
                    }
                ]
            },
            {
                "id": 1750087,
                "content": [
                    {
                        "username": "Bruhtholomew",
                        "content": "```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums = nums1 + nums2\\n        counter = 0\\n        total = 0\\n        for i in nums:\\n            total += i\\n            counter += 1\\n\\n        answer = float(total / counter)\\n        return answer\\n```\\nWhy doesn\\'t this work? The Output is 2.0 on leetcode, but when I run it in my console its 2.5.\\nThanks in advance!\\nxoxo"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        nums1.extend(nums2)\\n        l1=len(nums1)\\n        nums1.sort()\\n        if(l1%2==0):\\n            \\n            return (float(nums1[l1/2]+nums1[(l1/2)-1])/2)\\n        else:\\n            return nums1[l1//2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Manoj_Kumar_Devisetti",
                        "content": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        for i in nums2:\n            nums1.append(i)\n        nums1.sort()\n        if(len(nums1)%2!=0):\n            return nums1[len(nums1)//2]\n        else:\n            return (nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2"
                    },
                    {
                        "username": "sanketannadate6",
                        "content": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n    int m = nums1.size();\\n    int n = nums2.size();\\n    if (m > n) {\\n        return findMedianSortedArrays(nums2, nums1);\\n    }\\n    int imin = 0;\\n    int imax = m;\\n    while (imin <= imax) {\\n        int i = (imin + imax) / 2;\\n        int j = (m + n + 1) / 2 - i;\\n        if (i < m && j > 0 && nums2[j-1] > nums1[i]) {\\n            imin = i + 1;\\n        } else if (i > 0 && j < n && nums2[j] < nums1[i-1]) {\\n            imax = i - 1;\\n        } else {\\n            double max_of_left;\\n            if (i == 0) {\\n                max_of_left = nums2[j-1];\\n            } else if (j == 0) {\\n                max_of_left = nums1[i-1];\\n            } else {\\n                max_of_left = max(nums1[i-1], nums2[j-1]);\\n            }\\n            if ((m + n) % 2 == 1) {\\n                return max_of_left;\\n            }\\n            double min_of_right;\\n            if (i == m) {\\n                min_of_right = nums2[j];\\n            } else if (j == n) {\\n                min_of_right = nums1[i];\\n            } else {\\n                min_of_right = min(nums1[i], nums2[j]);\\n            }\\n            return (max_of_left + min_of_right) / 2;\\n        }\\n    }\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "saranshs2021",
                        "content": " class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            \n            nums1, nums2, m, n = nums2, nums1, n, m\n        \n        left, right = 0, m\n        while left <= right:\n            # partition the shorter array\n            i = (left + right) // 2\n            # partition the longer array\n            j = (m + n + 1) // 2 - i\n            if j > 0 and i < m and nums2[j-1] > nums1[i]:\n                # median is in the right half of nums1\n                left = i + 1\n            elif i > 0 and j < n and nums1[i-1] > nums2[j]:\n                # median is in the left half of nums1\n                right = i - 1\n            else:\n                # i is perfect\n                if i == 0:\n                    max_of_left = nums2[j-1]\n                elif j == 0:\n                    max_of_left = nums1[i-1]\n                else:\n                    max_of_left = max(nums1[i-1], nums2[j-1])\n                if (m + n) % 2 == 1:\n                    return max_of_left\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2\n        return -1\n\nWhat is wrong with my code?"
                    },
                    {
                        "username": "fojetin",
                        "content": "The constraints is to weak\\n```\\n0 <= nums1.length == 1000\\n0 <= nums2.length <= 1000\\n```\\n\\nWhen you have only 2000 numbers in merged array every solution will pass, even O(n**3) i think. And of course this complexity don\\'t match with hard task level."
                    },
                    {
                        "username": "lzouknak",
                        "content": "Python 60ms solved, simple code\\n\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        x = sorted(nums1+nums2)\\n        if (0 <= len(nums1) <= 1000 and 0 <= len(nums2) <= 1000) and ( max(x)<=1e6 and min(x)>=-1e6) and (1<= len(x) <= 2000):\\n            if len(x)%2 == 0:\\n                med = 0.5*(x[int(len(x)/2)-1] + x[int(len(x)/2)])\\n            elif len(x)%2 == 1:\\n                med =  x[int(len(x)/2)]\\n        return med "
                    },
                    {
                        "username": "ibbu731",
                        "content": "hello,\\nwhat does \"overall run time complexity\" mean"
                    },
                    {
                        "username": "VishuKalier",
                        "content": " `public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1.length == 0 && nums2.length == 0) \\n            return 0.0;\\n        if(nums1.length > nums2.length)\\n        {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        int lo = 0, hi = nums1.length, total = nums1.length + nums2.length;\\n        while(lo <= hi)\\n        {\\n            int aleft = lo + (hi - lo) / 2;\\n            int bleft = (total + 1) / 2 - aleft;\\n            int maVal = aleft == 0 ? Integer.MIN_VALUE : nums1[aleft - 1];\\n            int mbVal = bleft == 0 ? Integer.MIN_VALUE : nums2[bleft - 1];\\n            int aVal = aleft == nums1.length ? Integer.MAX_VALUE : nums1[aleft];\\n            int bVal = bleft == nums2.length ? Integer.MAX_VALUE : nums2[bleft];\\n            if(maVal <= bVal && mbVal <= aVal)\\n            {\\n                double res = Math.max(maVal, mbVal);\\n                if(total % 2 == 0)\\n                {\\n                    res += Math.min(aVal, bVal);\\n                    res /= 2.0;\\n                }\\n                return res;\\n            }\\n            else if(maVal > bVal)\\n            {\\n                hi = aleft - 1;\\n            }\\n            else\\n            {\\n                lo = aleft + 1;\\n            }\\n        }\\n    return 0.0d;\\n    }`"
                    }
                ]
            },
            {
                "id": 1750025,
                "content": [
                    {
                        "username": "Bruhtholomew",
                        "content": "```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums = nums1 + nums2\\n        counter = 0\\n        total = 0\\n        for i in nums:\\n            total += i\\n            counter += 1\\n\\n        answer = float(total / counter)\\n        return answer\\n```\\nWhy doesn\\'t this work? The Output is 2.0 on leetcode, but when I run it in my console its 2.5.\\nThanks in advance!\\nxoxo"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        nums1.extend(nums2)\\n        l1=len(nums1)\\n        nums1.sort()\\n        if(l1%2==0):\\n            \\n            return (float(nums1[l1/2]+nums1[(l1/2)-1])/2)\\n        else:\\n            return nums1[l1//2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Manoj_Kumar_Devisetti",
                        "content": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        for i in nums2:\n            nums1.append(i)\n        nums1.sort()\n        if(len(nums1)%2!=0):\n            return nums1[len(nums1)//2]\n        else:\n            return (nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2"
                    },
                    {
                        "username": "sanketannadate6",
                        "content": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n    int m = nums1.size();\\n    int n = nums2.size();\\n    if (m > n) {\\n        return findMedianSortedArrays(nums2, nums1);\\n    }\\n    int imin = 0;\\n    int imax = m;\\n    while (imin <= imax) {\\n        int i = (imin + imax) / 2;\\n        int j = (m + n + 1) / 2 - i;\\n        if (i < m && j > 0 && nums2[j-1] > nums1[i]) {\\n            imin = i + 1;\\n        } else if (i > 0 && j < n && nums2[j] < nums1[i-1]) {\\n            imax = i - 1;\\n        } else {\\n            double max_of_left;\\n            if (i == 0) {\\n                max_of_left = nums2[j-1];\\n            } else if (j == 0) {\\n                max_of_left = nums1[i-1];\\n            } else {\\n                max_of_left = max(nums1[i-1], nums2[j-1]);\\n            }\\n            if ((m + n) % 2 == 1) {\\n                return max_of_left;\\n            }\\n            double min_of_right;\\n            if (i == m) {\\n                min_of_right = nums2[j];\\n            } else if (j == n) {\\n                min_of_right = nums1[i];\\n            } else {\\n                min_of_right = min(nums1[i], nums2[j]);\\n            }\\n            return (max_of_left + min_of_right) / 2;\\n        }\\n    }\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "saranshs2021",
                        "content": " class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            \n            nums1, nums2, m, n = nums2, nums1, n, m\n        \n        left, right = 0, m\n        while left <= right:\n            # partition the shorter array\n            i = (left + right) // 2\n            # partition the longer array\n            j = (m + n + 1) // 2 - i\n            if j > 0 and i < m and nums2[j-1] > nums1[i]:\n                # median is in the right half of nums1\n                left = i + 1\n            elif i > 0 and j < n and nums1[i-1] > nums2[j]:\n                # median is in the left half of nums1\n                right = i - 1\n            else:\n                # i is perfect\n                if i == 0:\n                    max_of_left = nums2[j-1]\n                elif j == 0:\n                    max_of_left = nums1[i-1]\n                else:\n                    max_of_left = max(nums1[i-1], nums2[j-1])\n                if (m + n) % 2 == 1:\n                    return max_of_left\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2\n        return -1\n\nWhat is wrong with my code?"
                    },
                    {
                        "username": "fojetin",
                        "content": "The constraints is to weak\\n```\\n0 <= nums1.length == 1000\\n0 <= nums2.length <= 1000\\n```\\n\\nWhen you have only 2000 numbers in merged array every solution will pass, even O(n**3) i think. And of course this complexity don\\'t match with hard task level."
                    },
                    {
                        "username": "lzouknak",
                        "content": "Python 60ms solved, simple code\\n\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        x = sorted(nums1+nums2)\\n        if (0 <= len(nums1) <= 1000 and 0 <= len(nums2) <= 1000) and ( max(x)<=1e6 and min(x)>=-1e6) and (1<= len(x) <= 2000):\\n            if len(x)%2 == 0:\\n                med = 0.5*(x[int(len(x)/2)-1] + x[int(len(x)/2)])\\n            elif len(x)%2 == 1:\\n                med =  x[int(len(x)/2)]\\n        return med "
                    },
                    {
                        "username": "ibbu731",
                        "content": "hello,\\nwhat does \"overall run time complexity\" mean"
                    },
                    {
                        "username": "VishuKalier",
                        "content": " `public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1.length == 0 && nums2.length == 0) \\n            return 0.0;\\n        if(nums1.length > nums2.length)\\n        {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        int lo = 0, hi = nums1.length, total = nums1.length + nums2.length;\\n        while(lo <= hi)\\n        {\\n            int aleft = lo + (hi - lo) / 2;\\n            int bleft = (total + 1) / 2 - aleft;\\n            int maVal = aleft == 0 ? Integer.MIN_VALUE : nums1[aleft - 1];\\n            int mbVal = bleft == 0 ? Integer.MIN_VALUE : nums2[bleft - 1];\\n            int aVal = aleft == nums1.length ? Integer.MAX_VALUE : nums1[aleft];\\n            int bVal = bleft == nums2.length ? Integer.MAX_VALUE : nums2[bleft];\\n            if(maVal <= bVal && mbVal <= aVal)\\n            {\\n                double res = Math.max(maVal, mbVal);\\n                if(total % 2 == 0)\\n                {\\n                    res += Math.min(aVal, bVal);\\n                    res /= 2.0;\\n                }\\n                return res;\\n            }\\n            else if(maVal > bVal)\\n            {\\n                hi = aleft - 1;\\n            }\\n            else\\n            {\\n                lo = aleft + 1;\\n            }\\n        }\\n    return 0.0d;\\n    }`"
                    }
                ]
            },
            {
                "id": 1749863,
                "content": [
                    {
                        "username": "Bruhtholomew",
                        "content": "```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums = nums1 + nums2\\n        counter = 0\\n        total = 0\\n        for i in nums:\\n            total += i\\n            counter += 1\\n\\n        answer = float(total / counter)\\n        return answer\\n```\\nWhy doesn\\'t this work? The Output is 2.0 on leetcode, but when I run it in my console its 2.5.\\nThanks in advance!\\nxoxo"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        nums1.extend(nums2)\\n        l1=len(nums1)\\n        nums1.sort()\\n        if(l1%2==0):\\n            \\n            return (float(nums1[l1/2]+nums1[(l1/2)-1])/2)\\n        else:\\n            return nums1[l1//2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Manoj_Kumar_Devisetti",
                        "content": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        for i in nums2:\n            nums1.append(i)\n        nums1.sort()\n        if(len(nums1)%2!=0):\n            return nums1[len(nums1)//2]\n        else:\n            return (nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2"
                    },
                    {
                        "username": "sanketannadate6",
                        "content": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n    int m = nums1.size();\\n    int n = nums2.size();\\n    if (m > n) {\\n        return findMedianSortedArrays(nums2, nums1);\\n    }\\n    int imin = 0;\\n    int imax = m;\\n    while (imin <= imax) {\\n        int i = (imin + imax) / 2;\\n        int j = (m + n + 1) / 2 - i;\\n        if (i < m && j > 0 && nums2[j-1] > nums1[i]) {\\n            imin = i + 1;\\n        } else if (i > 0 && j < n && nums2[j] < nums1[i-1]) {\\n            imax = i - 1;\\n        } else {\\n            double max_of_left;\\n            if (i == 0) {\\n                max_of_left = nums2[j-1];\\n            } else if (j == 0) {\\n                max_of_left = nums1[i-1];\\n            } else {\\n                max_of_left = max(nums1[i-1], nums2[j-1]);\\n            }\\n            if ((m + n) % 2 == 1) {\\n                return max_of_left;\\n            }\\n            double min_of_right;\\n            if (i == m) {\\n                min_of_right = nums2[j];\\n            } else if (j == n) {\\n                min_of_right = nums1[i];\\n            } else {\\n                min_of_right = min(nums1[i], nums2[j]);\\n            }\\n            return (max_of_left + min_of_right) / 2;\\n        }\\n    }\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "saranshs2021",
                        "content": " class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            \n            nums1, nums2, m, n = nums2, nums1, n, m\n        \n        left, right = 0, m\n        while left <= right:\n            # partition the shorter array\n            i = (left + right) // 2\n            # partition the longer array\n            j = (m + n + 1) // 2 - i\n            if j > 0 and i < m and nums2[j-1] > nums1[i]:\n                # median is in the right half of nums1\n                left = i + 1\n            elif i > 0 and j < n and nums1[i-1] > nums2[j]:\n                # median is in the left half of nums1\n                right = i - 1\n            else:\n                # i is perfect\n                if i == 0:\n                    max_of_left = nums2[j-1]\n                elif j == 0:\n                    max_of_left = nums1[i-1]\n                else:\n                    max_of_left = max(nums1[i-1], nums2[j-1])\n                if (m + n) % 2 == 1:\n                    return max_of_left\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2\n        return -1\n\nWhat is wrong with my code?"
                    },
                    {
                        "username": "fojetin",
                        "content": "The constraints is to weak\\n```\\n0 <= nums1.length == 1000\\n0 <= nums2.length <= 1000\\n```\\n\\nWhen you have only 2000 numbers in merged array every solution will pass, even O(n**3) i think. And of course this complexity don\\'t match with hard task level."
                    },
                    {
                        "username": "lzouknak",
                        "content": "Python 60ms solved, simple code\\n\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        x = sorted(nums1+nums2)\\n        if (0 <= len(nums1) <= 1000 and 0 <= len(nums2) <= 1000) and ( max(x)<=1e6 and min(x)>=-1e6) and (1<= len(x) <= 2000):\\n            if len(x)%2 == 0:\\n                med = 0.5*(x[int(len(x)/2)-1] + x[int(len(x)/2)])\\n            elif len(x)%2 == 1:\\n                med =  x[int(len(x)/2)]\\n        return med "
                    },
                    {
                        "username": "ibbu731",
                        "content": "hello,\\nwhat does \"overall run time complexity\" mean"
                    },
                    {
                        "username": "VishuKalier",
                        "content": " `public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1.length == 0 && nums2.length == 0) \\n            return 0.0;\\n        if(nums1.length > nums2.length)\\n        {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        int lo = 0, hi = nums1.length, total = nums1.length + nums2.length;\\n        while(lo <= hi)\\n        {\\n            int aleft = lo + (hi - lo) / 2;\\n            int bleft = (total + 1) / 2 - aleft;\\n            int maVal = aleft == 0 ? Integer.MIN_VALUE : nums1[aleft - 1];\\n            int mbVal = bleft == 0 ? Integer.MIN_VALUE : nums2[bleft - 1];\\n            int aVal = aleft == nums1.length ? Integer.MAX_VALUE : nums1[aleft];\\n            int bVal = bleft == nums2.length ? Integer.MAX_VALUE : nums2[bleft];\\n            if(maVal <= bVal && mbVal <= aVal)\\n            {\\n                double res = Math.max(maVal, mbVal);\\n                if(total % 2 == 0)\\n                {\\n                    res += Math.min(aVal, bVal);\\n                    res /= 2.0;\\n                }\\n                return res;\\n            }\\n            else if(maVal > bVal)\\n            {\\n                hi = aleft - 1;\\n            }\\n            else\\n            {\\n                lo = aleft + 1;\\n            }\\n        }\\n    return 0.0d;\\n    }`"
                    }
                ]
            },
            {
                "id": 1748887,
                "content": [
                    {
                        "username": "Bruhtholomew",
                        "content": "```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums = nums1 + nums2\\n        counter = 0\\n        total = 0\\n        for i in nums:\\n            total += i\\n            counter += 1\\n\\n        answer = float(total / counter)\\n        return answer\\n```\\nWhy doesn\\'t this work? The Output is 2.0 on leetcode, but when I run it in my console its 2.5.\\nThanks in advance!\\nxoxo"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        nums1.extend(nums2)\\n        l1=len(nums1)\\n        nums1.sort()\\n        if(l1%2==0):\\n            \\n            return (float(nums1[l1/2]+nums1[(l1/2)-1])/2)\\n        else:\\n            return nums1[l1//2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Manoj_Kumar_Devisetti",
                        "content": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        for i in nums2:\n            nums1.append(i)\n        nums1.sort()\n        if(len(nums1)%2!=0):\n            return nums1[len(nums1)//2]\n        else:\n            return (nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2"
                    },
                    {
                        "username": "sanketannadate6",
                        "content": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n    int m = nums1.size();\\n    int n = nums2.size();\\n    if (m > n) {\\n        return findMedianSortedArrays(nums2, nums1);\\n    }\\n    int imin = 0;\\n    int imax = m;\\n    while (imin <= imax) {\\n        int i = (imin + imax) / 2;\\n        int j = (m + n + 1) / 2 - i;\\n        if (i < m && j > 0 && nums2[j-1] > nums1[i]) {\\n            imin = i + 1;\\n        } else if (i > 0 && j < n && nums2[j] < nums1[i-1]) {\\n            imax = i - 1;\\n        } else {\\n            double max_of_left;\\n            if (i == 0) {\\n                max_of_left = nums2[j-1];\\n            } else if (j == 0) {\\n                max_of_left = nums1[i-1];\\n            } else {\\n                max_of_left = max(nums1[i-1], nums2[j-1]);\\n            }\\n            if ((m + n) % 2 == 1) {\\n                return max_of_left;\\n            }\\n            double min_of_right;\\n            if (i == m) {\\n                min_of_right = nums2[j];\\n            } else if (j == n) {\\n                min_of_right = nums1[i];\\n            } else {\\n                min_of_right = min(nums1[i], nums2[j]);\\n            }\\n            return (max_of_left + min_of_right) / 2;\\n        }\\n    }\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "saranshs2021",
                        "content": " class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            \n            nums1, nums2, m, n = nums2, nums1, n, m\n        \n        left, right = 0, m\n        while left <= right:\n            # partition the shorter array\n            i = (left + right) // 2\n            # partition the longer array\n            j = (m + n + 1) // 2 - i\n            if j > 0 and i < m and nums2[j-1] > nums1[i]:\n                # median is in the right half of nums1\n                left = i + 1\n            elif i > 0 and j < n and nums1[i-1] > nums2[j]:\n                # median is in the left half of nums1\n                right = i - 1\n            else:\n                # i is perfect\n                if i == 0:\n                    max_of_left = nums2[j-1]\n                elif j == 0:\n                    max_of_left = nums1[i-1]\n                else:\n                    max_of_left = max(nums1[i-1], nums2[j-1])\n                if (m + n) % 2 == 1:\n                    return max_of_left\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2\n        return -1\n\nWhat is wrong with my code?"
                    },
                    {
                        "username": "fojetin",
                        "content": "The constraints is to weak\\n```\\n0 <= nums1.length == 1000\\n0 <= nums2.length <= 1000\\n```\\n\\nWhen you have only 2000 numbers in merged array every solution will pass, even O(n**3) i think. And of course this complexity don\\'t match with hard task level."
                    },
                    {
                        "username": "lzouknak",
                        "content": "Python 60ms solved, simple code\\n\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        x = sorted(nums1+nums2)\\n        if (0 <= len(nums1) <= 1000 and 0 <= len(nums2) <= 1000) and ( max(x)<=1e6 and min(x)>=-1e6) and (1<= len(x) <= 2000):\\n            if len(x)%2 == 0:\\n                med = 0.5*(x[int(len(x)/2)-1] + x[int(len(x)/2)])\\n            elif len(x)%2 == 1:\\n                med =  x[int(len(x)/2)]\\n        return med "
                    },
                    {
                        "username": "ibbu731",
                        "content": "hello,\\nwhat does \"overall run time complexity\" mean"
                    },
                    {
                        "username": "VishuKalier",
                        "content": " `public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1.length == 0 && nums2.length == 0) \\n            return 0.0;\\n        if(nums1.length > nums2.length)\\n        {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        int lo = 0, hi = nums1.length, total = nums1.length + nums2.length;\\n        while(lo <= hi)\\n        {\\n            int aleft = lo + (hi - lo) / 2;\\n            int bleft = (total + 1) / 2 - aleft;\\n            int maVal = aleft == 0 ? Integer.MIN_VALUE : nums1[aleft - 1];\\n            int mbVal = bleft == 0 ? Integer.MIN_VALUE : nums2[bleft - 1];\\n            int aVal = aleft == nums1.length ? Integer.MAX_VALUE : nums1[aleft];\\n            int bVal = bleft == nums2.length ? Integer.MAX_VALUE : nums2[bleft];\\n            if(maVal <= bVal && mbVal <= aVal)\\n            {\\n                double res = Math.max(maVal, mbVal);\\n                if(total % 2 == 0)\\n                {\\n                    res += Math.min(aVal, bVal);\\n                    res /= 2.0;\\n                }\\n                return res;\\n            }\\n            else if(maVal > bVal)\\n            {\\n                hi = aleft - 1;\\n            }\\n            else\\n            {\\n                lo = aleft + 1;\\n            }\\n        }\\n    return 0.0d;\\n    }`"
                    }
                ]
            },
            {
                "id": 1748436,
                "content": [
                    {
                        "username": "Bruhtholomew",
                        "content": "```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums = nums1 + nums2\\n        counter = 0\\n        total = 0\\n        for i in nums:\\n            total += i\\n            counter += 1\\n\\n        answer = float(total / counter)\\n        return answer\\n```\\nWhy doesn\\'t this work? The Output is 2.0 on leetcode, but when I run it in my console its 2.5.\\nThanks in advance!\\nxoxo"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        nums1.extend(nums2)\\n        l1=len(nums1)\\n        nums1.sort()\\n        if(l1%2==0):\\n            \\n            return (float(nums1[l1/2]+nums1[(l1/2)-1])/2)\\n        else:\\n            return nums1[l1//2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Manoj_Kumar_Devisetti",
                        "content": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        for i in nums2:\n            nums1.append(i)\n        nums1.sort()\n        if(len(nums1)%2!=0):\n            return nums1[len(nums1)//2]\n        else:\n            return (nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2"
                    },
                    {
                        "username": "sanketannadate6",
                        "content": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n    int m = nums1.size();\\n    int n = nums2.size();\\n    if (m > n) {\\n        return findMedianSortedArrays(nums2, nums1);\\n    }\\n    int imin = 0;\\n    int imax = m;\\n    while (imin <= imax) {\\n        int i = (imin + imax) / 2;\\n        int j = (m + n + 1) / 2 - i;\\n        if (i < m && j > 0 && nums2[j-1] > nums1[i]) {\\n            imin = i + 1;\\n        } else if (i > 0 && j < n && nums2[j] < nums1[i-1]) {\\n            imax = i - 1;\\n        } else {\\n            double max_of_left;\\n            if (i == 0) {\\n                max_of_left = nums2[j-1];\\n            } else if (j == 0) {\\n                max_of_left = nums1[i-1];\\n            } else {\\n                max_of_left = max(nums1[i-1], nums2[j-1]);\\n            }\\n            if ((m + n) % 2 == 1) {\\n                return max_of_left;\\n            }\\n            double min_of_right;\\n            if (i == m) {\\n                min_of_right = nums2[j];\\n            } else if (j == n) {\\n                min_of_right = nums1[i];\\n            } else {\\n                min_of_right = min(nums1[i], nums2[j]);\\n            }\\n            return (max_of_left + min_of_right) / 2;\\n        }\\n    }\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "saranshs2021",
                        "content": " class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            \n            nums1, nums2, m, n = nums2, nums1, n, m\n        \n        left, right = 0, m\n        while left <= right:\n            # partition the shorter array\n            i = (left + right) // 2\n            # partition the longer array\n            j = (m + n + 1) // 2 - i\n            if j > 0 and i < m and nums2[j-1] > nums1[i]:\n                # median is in the right half of nums1\n                left = i + 1\n            elif i > 0 and j < n and nums1[i-1] > nums2[j]:\n                # median is in the left half of nums1\n                right = i - 1\n            else:\n                # i is perfect\n                if i == 0:\n                    max_of_left = nums2[j-1]\n                elif j == 0:\n                    max_of_left = nums1[i-1]\n                else:\n                    max_of_left = max(nums1[i-1], nums2[j-1])\n                if (m + n) % 2 == 1:\n                    return max_of_left\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2\n        return -1\n\nWhat is wrong with my code?"
                    },
                    {
                        "username": "fojetin",
                        "content": "The constraints is to weak\\n```\\n0 <= nums1.length == 1000\\n0 <= nums2.length <= 1000\\n```\\n\\nWhen you have only 2000 numbers in merged array every solution will pass, even O(n**3) i think. And of course this complexity don\\'t match with hard task level."
                    },
                    {
                        "username": "lzouknak",
                        "content": "Python 60ms solved, simple code\\n\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        x = sorted(nums1+nums2)\\n        if (0 <= len(nums1) <= 1000 and 0 <= len(nums2) <= 1000) and ( max(x)<=1e6 and min(x)>=-1e6) and (1<= len(x) <= 2000):\\n            if len(x)%2 == 0:\\n                med = 0.5*(x[int(len(x)/2)-1] + x[int(len(x)/2)])\\n            elif len(x)%2 == 1:\\n                med =  x[int(len(x)/2)]\\n        return med "
                    },
                    {
                        "username": "ibbu731",
                        "content": "hello,\\nwhat does \"overall run time complexity\" mean"
                    },
                    {
                        "username": "VishuKalier",
                        "content": " `public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1.length == 0 && nums2.length == 0) \\n            return 0.0;\\n        if(nums1.length > nums2.length)\\n        {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        int lo = 0, hi = nums1.length, total = nums1.length + nums2.length;\\n        while(lo <= hi)\\n        {\\n            int aleft = lo + (hi - lo) / 2;\\n            int bleft = (total + 1) / 2 - aleft;\\n            int maVal = aleft == 0 ? Integer.MIN_VALUE : nums1[aleft - 1];\\n            int mbVal = bleft == 0 ? Integer.MIN_VALUE : nums2[bleft - 1];\\n            int aVal = aleft == nums1.length ? Integer.MAX_VALUE : nums1[aleft];\\n            int bVal = bleft == nums2.length ? Integer.MAX_VALUE : nums2[bleft];\\n            if(maVal <= bVal && mbVal <= aVal)\\n            {\\n                double res = Math.max(maVal, mbVal);\\n                if(total % 2 == 0)\\n                {\\n                    res += Math.min(aVal, bVal);\\n                    res /= 2.0;\\n                }\\n                return res;\\n            }\\n            else if(maVal > bVal)\\n            {\\n                hi = aleft - 1;\\n            }\\n            else\\n            {\\n                lo = aleft + 1;\\n            }\\n        }\\n    return 0.0d;\\n    }`"
                    }
                ]
            },
            {
                "id": 1748419,
                "content": [
                    {
                        "username": "Bruhtholomew",
                        "content": "```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums = nums1 + nums2\\n        counter = 0\\n        total = 0\\n        for i in nums:\\n            total += i\\n            counter += 1\\n\\n        answer = float(total / counter)\\n        return answer\\n```\\nWhy doesn\\'t this work? The Output is 2.0 on leetcode, but when I run it in my console its 2.5.\\nThanks in advance!\\nxoxo"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n    \\n        nums1.extend(nums2)\\n        l1=len(nums1)\\n        nums1.sort()\\n        if(l1%2==0):\\n            \\n            return (float(nums1[l1/2]+nums1[(l1/2)-1])/2)\\n        else:\\n            return nums1[l1//2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Manoj_Kumar_Devisetti",
                        "content": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        for i in nums2:\n            nums1.append(i)\n        nums1.sort()\n        if(len(nums1)%2!=0):\n            return nums1[len(nums1)//2]\n        else:\n            return (nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2"
                    },
                    {
                        "username": "sanketannadate6",
                        "content": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n    int m = nums1.size();\\n    int n = nums2.size();\\n    if (m > n) {\\n        return findMedianSortedArrays(nums2, nums1);\\n    }\\n    int imin = 0;\\n    int imax = m;\\n    while (imin <= imax) {\\n        int i = (imin + imax) / 2;\\n        int j = (m + n + 1) / 2 - i;\\n        if (i < m && j > 0 && nums2[j-1] > nums1[i]) {\\n            imin = i + 1;\\n        } else if (i > 0 && j < n && nums2[j] < nums1[i-1]) {\\n            imax = i - 1;\\n        } else {\\n            double max_of_left;\\n            if (i == 0) {\\n                max_of_left = nums2[j-1];\\n            } else if (j == 0) {\\n                max_of_left = nums1[i-1];\\n            } else {\\n                max_of_left = max(nums1[i-1], nums2[j-1]);\\n            }\\n            if ((m + n) % 2 == 1) {\\n                return max_of_left;\\n            }\\n            double min_of_right;\\n            if (i == m) {\\n                min_of_right = nums2[j];\\n            } else if (j == n) {\\n                min_of_right = nums1[i];\\n            } else {\\n                min_of_right = min(nums1[i], nums2[j]);\\n            }\\n            return (max_of_left + min_of_right) / 2;\\n        }\\n    }\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "saranshs2021",
                        "content": " class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            \n            nums1, nums2, m, n = nums2, nums1, n, m\n        \n        left, right = 0, m\n        while left <= right:\n            # partition the shorter array\n            i = (left + right) // 2\n            # partition the longer array\n            j = (m + n + 1) // 2 - i\n            if j > 0 and i < m and nums2[j-1] > nums1[i]:\n                # median is in the right half of nums1\n                left = i + 1\n            elif i > 0 and j < n and nums1[i-1] > nums2[j]:\n                # median is in the left half of nums1\n                right = i - 1\n            else:\n                # i is perfect\n                if i == 0:\n                    max_of_left = nums2[j-1]\n                elif j == 0:\n                    max_of_left = nums1[i-1]\n                else:\n                    max_of_left = max(nums1[i-1], nums2[j-1])\n                if (m + n) % 2 == 1:\n                    return max_of_left\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2\n        return -1\n\nWhat is wrong with my code?"
                    },
                    {
                        "username": "fojetin",
                        "content": "The constraints is to weak\\n```\\n0 <= nums1.length == 1000\\n0 <= nums2.length <= 1000\\n```\\n\\nWhen you have only 2000 numbers in merged array every solution will pass, even O(n**3) i think. And of course this complexity don\\'t match with hard task level."
                    },
                    {
                        "username": "lzouknak",
                        "content": "Python 60ms solved, simple code\\n\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        x = sorted(nums1+nums2)\\n        if (0 <= len(nums1) <= 1000 and 0 <= len(nums2) <= 1000) and ( max(x)<=1e6 and min(x)>=-1e6) and (1<= len(x) <= 2000):\\n            if len(x)%2 == 0:\\n                med = 0.5*(x[int(len(x)/2)-1] + x[int(len(x)/2)])\\n            elif len(x)%2 == 1:\\n                med =  x[int(len(x)/2)]\\n        return med "
                    },
                    {
                        "username": "ibbu731",
                        "content": "hello,\\nwhat does \"overall run time complexity\" mean"
                    },
                    {
                        "username": "VishuKalier",
                        "content": " `public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        if(nums1.length == 0 && nums2.length == 0) \\n            return 0.0;\\n        if(nums1.length > nums2.length)\\n        {\\n            int[] temp = nums1;\\n            nums1 = nums2;\\n            nums2 = temp;\\n        }\\n        int lo = 0, hi = nums1.length, total = nums1.length + nums2.length;\\n        while(lo <= hi)\\n        {\\n            int aleft = lo + (hi - lo) / 2;\\n            int bleft = (total + 1) / 2 - aleft;\\n            int maVal = aleft == 0 ? Integer.MIN_VALUE : nums1[aleft - 1];\\n            int mbVal = bleft == 0 ? Integer.MIN_VALUE : nums2[bleft - 1];\\n            int aVal = aleft == nums1.length ? Integer.MAX_VALUE : nums1[aleft];\\n            int bVal = bleft == nums2.length ? Integer.MAX_VALUE : nums2[bleft];\\n            if(maVal <= bVal && mbVal <= aVal)\\n            {\\n                double res = Math.max(maVal, mbVal);\\n                if(total % 2 == 0)\\n                {\\n                    res += Math.min(aVal, bVal);\\n                    res /= 2.0;\\n                }\\n                return res;\\n            }\\n            else if(maVal > bVal)\\n            {\\n                hi = aleft - 1;\\n            }\\n            else\\n            {\\n                lo = aleft + 1;\\n            }\\n        }\\n    return 0.0d;\\n    }`"
                    }
                ]
            },
            {
                "id": 1745352,
                "content": [
                    {
                        "username": "oinrup",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double median=0.00;\\n        int arr[] =new int[nums1.length+nums2.length];\\n        int n=nums1.length;\\n        for(int i=0;i<nums1.length;i++){\\n            arr[i]=nums1[i];\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            arr[n]=nums1[i];\\n                n++;\\n        }\\n        Arrays.sort(arr);\\n        while(arr.length!=0){\\n            if(arr.length%2!=0){\\n                median=(double)arr[arr.length/2];\\n            }\\n            else{\\n                int m=arr.length/2;\\n                double mm=(arr[arr.length/2]+arr[arr.length/2-1])/2;\\n                 median=mm;\\n            }\\n        }\\n\\nreturn median;\\n    }\\n}\\ncan anyone help me . I am not sure whats wrong in it."
                    },
                    {
                        "username": "inTEGraTOR",
                        "content": "I think it is worth defining median, since there are several wrong answers below because of this, and many questions:\\n\\n> The median of an array is the value in the middle of the array when the elements are sorted in numerical order. If the array has an odd number of elements, then the median is the middle element. If the array has an even number of elements, then the median is the average of the two middle elements.\\n\\n> For example, the median of the array [3, 5, 2, 1, 4] is 3, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5], and 3 is the middle element. The median of the array [3, 5, 2, 1, 4, 6] is (3 + 4) / 2 = 3.5, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5, 6], and 3.5 is the average of the two middle elements (3 and 4)."
                    },
                    {
                        "username": "user9407T",
                        "content": "---------Python Solution---------\\n\\nimport math\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        value = 0      \\n        n = len(nums1)\\n        m = len(nums2)\\n        temp = nums1 + nums2\\n        temp = sorted(temp)\\n        lenTemp = int(len(temp))\\n        if lenTemp % 2 == 0:\\n            value = (temp[math.floor(lenTemp/2) - 1] + temp[math.floor(lenTemp/2)]) / 2 \\n        else:\\n            value = temp[math.floor(lenTemp/2)]\\n        return value"
                    },
                    {
                        "username": "infi123",
                        "content": "Hello, where can I find the official solution for this problem?"
                    },
                    {
                        "username": "andregoes",
                        "content": "This should be working, but for some reason it does not. I test it off LeetCode and it works. But somehow it doesn\\'t here.\\n\\n```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        # Concatenate and sort lists\\n        numsAgg = nums1 + nums2\\n        numsAgg.sort()\\n       \\n        n = len(numsAgg) // 2\\n        if (len(numsAgg) % 2) == 0:\\n            return ( numsAgg[n] + numsAgg[n-1] ) / 2\\n        else:\\n            return numsAgg[n]\\n```"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2987826/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "its giving runtime error why?\\n double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0, j=0 ,k =0;\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        while(i<m && j<n){\\n            if(nums1 [i]< nums2[j]){\\n                ans[k++]=nums1[i++];\\n            }\\n             else{\\n                ans[k++]=nums2[j++];\\n            }\\n        }\\n         while(i<m){\\n             ans[k++]=nums1[i++];\\n         }\\n          while(j<n){\\n             ans[k++]=nums2[j++];\\n         }\\n\\n         int t = ans.size();\\n         int middle = t/2;\\n\\n         if (t % 2==0){\\n          return (double)(ans[middle - 1] + ans[middle]) / 2.0;\\n         }\\n\\n         else\\n          return (double)ans[middle];\\n\\n\\n        \\n\\n        \\n    }"
                    },
                    {
                        "username": "Joydey",
                        "content": "can anyone fix this code its runing properly but when i submit this the compiler showin wrong ans\\n\\n\\n\\ndouble findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) {\\n  int totalSize = nums1Size + nums2Size;\\n  int half = totalSize / 2;\\n  int i = 0, j = 0;\\n  double median1, median2;\\n  while (i < nums1Size && j < nums2Size) {\\n    if (nums1[i] <= nums2[j]) {\\n      if (i + j == half) {\\n        median1 = nums1[i];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums1[i];\\n      }\\n      i++;\\n    } else {\\n      if (i + j == half) {\\n        median1 = nums2[j];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums2[j];\\n      }\\n      j++;\\n    }\\n  }\\n  while (i < nums1Size) {\\n    if (i + j == half) {\\n      median1 = nums1[i];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums1[i];\\n    }\\n    i++;\\n  }\\n  while (j < nums2Size) {\\n    if (i + j == half) {\\n      median1 = nums2[j];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums2[j];\\n    }\\n    j++;\\n  }\\n  if (totalSize % 2 == 0) {\\n    return (median1 + median2) / 2;\\n  } else {\\n    return median1;\\n  }\\n}\\n\\n"
                    },
                    {
                        "username": "eyeshield99",
                        "content": "I\\'m a beginner and my solution is this in python, why did it outputs 2.00000 it must be 2.50000 please enlighten me\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums1.extend(nums2)\\n        nums1.sort()\\n        med=0\\n        if len(nums1)%2==0:\\n            med=(nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2\\n        else:\\n            med=nums1[len(nums1)//2]\\n        return float(\"{:.5f}\".format(med))"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1743616,
                "content": [
                    {
                        "username": "oinrup",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double median=0.00;\\n        int arr[] =new int[nums1.length+nums2.length];\\n        int n=nums1.length;\\n        for(int i=0;i<nums1.length;i++){\\n            arr[i]=nums1[i];\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            arr[n]=nums1[i];\\n                n++;\\n        }\\n        Arrays.sort(arr);\\n        while(arr.length!=0){\\n            if(arr.length%2!=0){\\n                median=(double)arr[arr.length/2];\\n            }\\n            else{\\n                int m=arr.length/2;\\n                double mm=(arr[arr.length/2]+arr[arr.length/2-1])/2;\\n                 median=mm;\\n            }\\n        }\\n\\nreturn median;\\n    }\\n}\\ncan anyone help me . I am not sure whats wrong in it."
                    },
                    {
                        "username": "inTEGraTOR",
                        "content": "I think it is worth defining median, since there are several wrong answers below because of this, and many questions:\\n\\n> The median of an array is the value in the middle of the array when the elements are sorted in numerical order. If the array has an odd number of elements, then the median is the middle element. If the array has an even number of elements, then the median is the average of the two middle elements.\\n\\n> For example, the median of the array [3, 5, 2, 1, 4] is 3, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5], and 3 is the middle element. The median of the array [3, 5, 2, 1, 4, 6] is (3 + 4) / 2 = 3.5, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5, 6], and 3.5 is the average of the two middle elements (3 and 4)."
                    },
                    {
                        "username": "user9407T",
                        "content": "---------Python Solution---------\\n\\nimport math\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        value = 0      \\n        n = len(nums1)\\n        m = len(nums2)\\n        temp = nums1 + nums2\\n        temp = sorted(temp)\\n        lenTemp = int(len(temp))\\n        if lenTemp % 2 == 0:\\n            value = (temp[math.floor(lenTemp/2) - 1] + temp[math.floor(lenTemp/2)]) / 2 \\n        else:\\n            value = temp[math.floor(lenTemp/2)]\\n        return value"
                    },
                    {
                        "username": "infi123",
                        "content": "Hello, where can I find the official solution for this problem?"
                    },
                    {
                        "username": "andregoes",
                        "content": "This should be working, but for some reason it does not. I test it off LeetCode and it works. But somehow it doesn\\'t here.\\n\\n```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        # Concatenate and sort lists\\n        numsAgg = nums1 + nums2\\n        numsAgg.sort()\\n       \\n        n = len(numsAgg) // 2\\n        if (len(numsAgg) % 2) == 0:\\n            return ( numsAgg[n] + numsAgg[n-1] ) / 2\\n        else:\\n            return numsAgg[n]\\n```"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2987826/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "its giving runtime error why?\\n double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0, j=0 ,k =0;\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        while(i<m && j<n){\\n            if(nums1 [i]< nums2[j]){\\n                ans[k++]=nums1[i++];\\n            }\\n             else{\\n                ans[k++]=nums2[j++];\\n            }\\n        }\\n         while(i<m){\\n             ans[k++]=nums1[i++];\\n         }\\n          while(j<n){\\n             ans[k++]=nums2[j++];\\n         }\\n\\n         int t = ans.size();\\n         int middle = t/2;\\n\\n         if (t % 2==0){\\n          return (double)(ans[middle - 1] + ans[middle]) / 2.0;\\n         }\\n\\n         else\\n          return (double)ans[middle];\\n\\n\\n        \\n\\n        \\n    }"
                    },
                    {
                        "username": "Joydey",
                        "content": "can anyone fix this code its runing properly but when i submit this the compiler showin wrong ans\\n\\n\\n\\ndouble findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) {\\n  int totalSize = nums1Size + nums2Size;\\n  int half = totalSize / 2;\\n  int i = 0, j = 0;\\n  double median1, median2;\\n  while (i < nums1Size && j < nums2Size) {\\n    if (nums1[i] <= nums2[j]) {\\n      if (i + j == half) {\\n        median1 = nums1[i];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums1[i];\\n      }\\n      i++;\\n    } else {\\n      if (i + j == half) {\\n        median1 = nums2[j];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums2[j];\\n      }\\n      j++;\\n    }\\n  }\\n  while (i < nums1Size) {\\n    if (i + j == half) {\\n      median1 = nums1[i];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums1[i];\\n    }\\n    i++;\\n  }\\n  while (j < nums2Size) {\\n    if (i + j == half) {\\n      median1 = nums2[j];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums2[j];\\n    }\\n    j++;\\n  }\\n  if (totalSize % 2 == 0) {\\n    return (median1 + median2) / 2;\\n  } else {\\n    return median1;\\n  }\\n}\\n\\n"
                    },
                    {
                        "username": "eyeshield99",
                        "content": "I\\'m a beginner and my solution is this in python, why did it outputs 2.00000 it must be 2.50000 please enlighten me\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums1.extend(nums2)\\n        nums1.sort()\\n        med=0\\n        if len(nums1)%2==0:\\n            med=(nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2\\n        else:\\n            med=nums1[len(nums1)//2]\\n        return float(\"{:.5f}\".format(med))"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1742375,
                "content": [
                    {
                        "username": "oinrup",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double median=0.00;\\n        int arr[] =new int[nums1.length+nums2.length];\\n        int n=nums1.length;\\n        for(int i=0;i<nums1.length;i++){\\n            arr[i]=nums1[i];\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            arr[n]=nums1[i];\\n                n++;\\n        }\\n        Arrays.sort(arr);\\n        while(arr.length!=0){\\n            if(arr.length%2!=0){\\n                median=(double)arr[arr.length/2];\\n            }\\n            else{\\n                int m=arr.length/2;\\n                double mm=(arr[arr.length/2]+arr[arr.length/2-1])/2;\\n                 median=mm;\\n            }\\n        }\\n\\nreturn median;\\n    }\\n}\\ncan anyone help me . I am not sure whats wrong in it."
                    },
                    {
                        "username": "inTEGraTOR",
                        "content": "I think it is worth defining median, since there are several wrong answers below because of this, and many questions:\\n\\n> The median of an array is the value in the middle of the array when the elements are sorted in numerical order. If the array has an odd number of elements, then the median is the middle element. If the array has an even number of elements, then the median is the average of the two middle elements.\\n\\n> For example, the median of the array [3, 5, 2, 1, 4] is 3, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5], and 3 is the middle element. The median of the array [3, 5, 2, 1, 4, 6] is (3 + 4) / 2 = 3.5, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5, 6], and 3.5 is the average of the two middle elements (3 and 4)."
                    },
                    {
                        "username": "user9407T",
                        "content": "---------Python Solution---------\\n\\nimport math\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        value = 0      \\n        n = len(nums1)\\n        m = len(nums2)\\n        temp = nums1 + nums2\\n        temp = sorted(temp)\\n        lenTemp = int(len(temp))\\n        if lenTemp % 2 == 0:\\n            value = (temp[math.floor(lenTemp/2) - 1] + temp[math.floor(lenTemp/2)]) / 2 \\n        else:\\n            value = temp[math.floor(lenTemp/2)]\\n        return value"
                    },
                    {
                        "username": "infi123",
                        "content": "Hello, where can I find the official solution for this problem?"
                    },
                    {
                        "username": "andregoes",
                        "content": "This should be working, but for some reason it does not. I test it off LeetCode and it works. But somehow it doesn\\'t here.\\n\\n```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        # Concatenate and sort lists\\n        numsAgg = nums1 + nums2\\n        numsAgg.sort()\\n       \\n        n = len(numsAgg) // 2\\n        if (len(numsAgg) % 2) == 0:\\n            return ( numsAgg[n] + numsAgg[n-1] ) / 2\\n        else:\\n            return numsAgg[n]\\n```"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2987826/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "its giving runtime error why?\\n double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0, j=0 ,k =0;\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        while(i<m && j<n){\\n            if(nums1 [i]< nums2[j]){\\n                ans[k++]=nums1[i++];\\n            }\\n             else{\\n                ans[k++]=nums2[j++];\\n            }\\n        }\\n         while(i<m){\\n             ans[k++]=nums1[i++];\\n         }\\n          while(j<n){\\n             ans[k++]=nums2[j++];\\n         }\\n\\n         int t = ans.size();\\n         int middle = t/2;\\n\\n         if (t % 2==0){\\n          return (double)(ans[middle - 1] + ans[middle]) / 2.0;\\n         }\\n\\n         else\\n          return (double)ans[middle];\\n\\n\\n        \\n\\n        \\n    }"
                    },
                    {
                        "username": "Joydey",
                        "content": "can anyone fix this code its runing properly but when i submit this the compiler showin wrong ans\\n\\n\\n\\ndouble findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) {\\n  int totalSize = nums1Size + nums2Size;\\n  int half = totalSize / 2;\\n  int i = 0, j = 0;\\n  double median1, median2;\\n  while (i < nums1Size && j < nums2Size) {\\n    if (nums1[i] <= nums2[j]) {\\n      if (i + j == half) {\\n        median1 = nums1[i];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums1[i];\\n      }\\n      i++;\\n    } else {\\n      if (i + j == half) {\\n        median1 = nums2[j];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums2[j];\\n      }\\n      j++;\\n    }\\n  }\\n  while (i < nums1Size) {\\n    if (i + j == half) {\\n      median1 = nums1[i];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums1[i];\\n    }\\n    i++;\\n  }\\n  while (j < nums2Size) {\\n    if (i + j == half) {\\n      median1 = nums2[j];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums2[j];\\n    }\\n    j++;\\n  }\\n  if (totalSize % 2 == 0) {\\n    return (median1 + median2) / 2;\\n  } else {\\n    return median1;\\n  }\\n}\\n\\n"
                    },
                    {
                        "username": "eyeshield99",
                        "content": "I\\'m a beginner and my solution is this in python, why did it outputs 2.00000 it must be 2.50000 please enlighten me\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums1.extend(nums2)\\n        nums1.sort()\\n        med=0\\n        if len(nums1)%2==0:\\n            med=(nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2\\n        else:\\n            med=nums1[len(nums1)//2]\\n        return float(\"{:.5f}\".format(med))"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1740451,
                "content": [
                    {
                        "username": "oinrup",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double median=0.00;\\n        int arr[] =new int[nums1.length+nums2.length];\\n        int n=nums1.length;\\n        for(int i=0;i<nums1.length;i++){\\n            arr[i]=nums1[i];\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            arr[n]=nums1[i];\\n                n++;\\n        }\\n        Arrays.sort(arr);\\n        while(arr.length!=0){\\n            if(arr.length%2!=0){\\n                median=(double)arr[arr.length/2];\\n            }\\n            else{\\n                int m=arr.length/2;\\n                double mm=(arr[arr.length/2]+arr[arr.length/2-1])/2;\\n                 median=mm;\\n            }\\n        }\\n\\nreturn median;\\n    }\\n}\\ncan anyone help me . I am not sure whats wrong in it."
                    },
                    {
                        "username": "inTEGraTOR",
                        "content": "I think it is worth defining median, since there are several wrong answers below because of this, and many questions:\\n\\n> The median of an array is the value in the middle of the array when the elements are sorted in numerical order. If the array has an odd number of elements, then the median is the middle element. If the array has an even number of elements, then the median is the average of the two middle elements.\\n\\n> For example, the median of the array [3, 5, 2, 1, 4] is 3, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5], and 3 is the middle element. The median of the array [3, 5, 2, 1, 4, 6] is (3 + 4) / 2 = 3.5, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5, 6], and 3.5 is the average of the two middle elements (3 and 4)."
                    },
                    {
                        "username": "user9407T",
                        "content": "---------Python Solution---------\\n\\nimport math\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        value = 0      \\n        n = len(nums1)\\n        m = len(nums2)\\n        temp = nums1 + nums2\\n        temp = sorted(temp)\\n        lenTemp = int(len(temp))\\n        if lenTemp % 2 == 0:\\n            value = (temp[math.floor(lenTemp/2) - 1] + temp[math.floor(lenTemp/2)]) / 2 \\n        else:\\n            value = temp[math.floor(lenTemp/2)]\\n        return value"
                    },
                    {
                        "username": "infi123",
                        "content": "Hello, where can I find the official solution for this problem?"
                    },
                    {
                        "username": "andregoes",
                        "content": "This should be working, but for some reason it does not. I test it off LeetCode and it works. But somehow it doesn\\'t here.\\n\\n```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        # Concatenate and sort lists\\n        numsAgg = nums1 + nums2\\n        numsAgg.sort()\\n       \\n        n = len(numsAgg) // 2\\n        if (len(numsAgg) % 2) == 0:\\n            return ( numsAgg[n] + numsAgg[n-1] ) / 2\\n        else:\\n            return numsAgg[n]\\n```"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2987826/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "its giving runtime error why?\\n double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0, j=0 ,k =0;\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        while(i<m && j<n){\\n            if(nums1 [i]< nums2[j]){\\n                ans[k++]=nums1[i++];\\n            }\\n             else{\\n                ans[k++]=nums2[j++];\\n            }\\n        }\\n         while(i<m){\\n             ans[k++]=nums1[i++];\\n         }\\n          while(j<n){\\n             ans[k++]=nums2[j++];\\n         }\\n\\n         int t = ans.size();\\n         int middle = t/2;\\n\\n         if (t % 2==0){\\n          return (double)(ans[middle - 1] + ans[middle]) / 2.0;\\n         }\\n\\n         else\\n          return (double)ans[middle];\\n\\n\\n        \\n\\n        \\n    }"
                    },
                    {
                        "username": "Joydey",
                        "content": "can anyone fix this code its runing properly but when i submit this the compiler showin wrong ans\\n\\n\\n\\ndouble findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) {\\n  int totalSize = nums1Size + nums2Size;\\n  int half = totalSize / 2;\\n  int i = 0, j = 0;\\n  double median1, median2;\\n  while (i < nums1Size && j < nums2Size) {\\n    if (nums1[i] <= nums2[j]) {\\n      if (i + j == half) {\\n        median1 = nums1[i];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums1[i];\\n      }\\n      i++;\\n    } else {\\n      if (i + j == half) {\\n        median1 = nums2[j];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums2[j];\\n      }\\n      j++;\\n    }\\n  }\\n  while (i < nums1Size) {\\n    if (i + j == half) {\\n      median1 = nums1[i];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums1[i];\\n    }\\n    i++;\\n  }\\n  while (j < nums2Size) {\\n    if (i + j == half) {\\n      median1 = nums2[j];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums2[j];\\n    }\\n    j++;\\n  }\\n  if (totalSize % 2 == 0) {\\n    return (median1 + median2) / 2;\\n  } else {\\n    return median1;\\n  }\\n}\\n\\n"
                    },
                    {
                        "username": "eyeshield99",
                        "content": "I\\'m a beginner and my solution is this in python, why did it outputs 2.00000 it must be 2.50000 please enlighten me\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums1.extend(nums2)\\n        nums1.sort()\\n        med=0\\n        if len(nums1)%2==0:\\n            med=(nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2\\n        else:\\n            med=nums1[len(nums1)//2]\\n        return float(\"{:.5f}\".format(med))"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1739242,
                "content": [
                    {
                        "username": "oinrup",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double median=0.00;\\n        int arr[] =new int[nums1.length+nums2.length];\\n        int n=nums1.length;\\n        for(int i=0;i<nums1.length;i++){\\n            arr[i]=nums1[i];\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            arr[n]=nums1[i];\\n                n++;\\n        }\\n        Arrays.sort(arr);\\n        while(arr.length!=0){\\n            if(arr.length%2!=0){\\n                median=(double)arr[arr.length/2];\\n            }\\n            else{\\n                int m=arr.length/2;\\n                double mm=(arr[arr.length/2]+arr[arr.length/2-1])/2;\\n                 median=mm;\\n            }\\n        }\\n\\nreturn median;\\n    }\\n}\\ncan anyone help me . I am not sure whats wrong in it."
                    },
                    {
                        "username": "inTEGraTOR",
                        "content": "I think it is worth defining median, since there are several wrong answers below because of this, and many questions:\\n\\n> The median of an array is the value in the middle of the array when the elements are sorted in numerical order. If the array has an odd number of elements, then the median is the middle element. If the array has an even number of elements, then the median is the average of the two middle elements.\\n\\n> For example, the median of the array [3, 5, 2, 1, 4] is 3, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5], and 3 is the middle element. The median of the array [3, 5, 2, 1, 4, 6] is (3 + 4) / 2 = 3.5, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5, 6], and 3.5 is the average of the two middle elements (3 and 4)."
                    },
                    {
                        "username": "user9407T",
                        "content": "---------Python Solution---------\\n\\nimport math\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        value = 0      \\n        n = len(nums1)\\n        m = len(nums2)\\n        temp = nums1 + nums2\\n        temp = sorted(temp)\\n        lenTemp = int(len(temp))\\n        if lenTemp % 2 == 0:\\n            value = (temp[math.floor(lenTemp/2) - 1] + temp[math.floor(lenTemp/2)]) / 2 \\n        else:\\n            value = temp[math.floor(lenTemp/2)]\\n        return value"
                    },
                    {
                        "username": "infi123",
                        "content": "Hello, where can I find the official solution for this problem?"
                    },
                    {
                        "username": "andregoes",
                        "content": "This should be working, but for some reason it does not. I test it off LeetCode and it works. But somehow it doesn\\'t here.\\n\\n```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        # Concatenate and sort lists\\n        numsAgg = nums1 + nums2\\n        numsAgg.sort()\\n       \\n        n = len(numsAgg) // 2\\n        if (len(numsAgg) % 2) == 0:\\n            return ( numsAgg[n] + numsAgg[n-1] ) / 2\\n        else:\\n            return numsAgg[n]\\n```"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2987826/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "its giving runtime error why?\\n double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0, j=0 ,k =0;\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        while(i<m && j<n){\\n            if(nums1 [i]< nums2[j]){\\n                ans[k++]=nums1[i++];\\n            }\\n             else{\\n                ans[k++]=nums2[j++];\\n            }\\n        }\\n         while(i<m){\\n             ans[k++]=nums1[i++];\\n         }\\n          while(j<n){\\n             ans[k++]=nums2[j++];\\n         }\\n\\n         int t = ans.size();\\n         int middle = t/2;\\n\\n         if (t % 2==0){\\n          return (double)(ans[middle - 1] + ans[middle]) / 2.0;\\n         }\\n\\n         else\\n          return (double)ans[middle];\\n\\n\\n        \\n\\n        \\n    }"
                    },
                    {
                        "username": "Joydey",
                        "content": "can anyone fix this code its runing properly but when i submit this the compiler showin wrong ans\\n\\n\\n\\ndouble findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) {\\n  int totalSize = nums1Size + nums2Size;\\n  int half = totalSize / 2;\\n  int i = 0, j = 0;\\n  double median1, median2;\\n  while (i < nums1Size && j < nums2Size) {\\n    if (nums1[i] <= nums2[j]) {\\n      if (i + j == half) {\\n        median1 = nums1[i];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums1[i];\\n      }\\n      i++;\\n    } else {\\n      if (i + j == half) {\\n        median1 = nums2[j];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums2[j];\\n      }\\n      j++;\\n    }\\n  }\\n  while (i < nums1Size) {\\n    if (i + j == half) {\\n      median1 = nums1[i];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums1[i];\\n    }\\n    i++;\\n  }\\n  while (j < nums2Size) {\\n    if (i + j == half) {\\n      median1 = nums2[j];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums2[j];\\n    }\\n    j++;\\n  }\\n  if (totalSize % 2 == 0) {\\n    return (median1 + median2) / 2;\\n  } else {\\n    return median1;\\n  }\\n}\\n\\n"
                    },
                    {
                        "username": "eyeshield99",
                        "content": "I\\'m a beginner and my solution is this in python, why did it outputs 2.00000 it must be 2.50000 please enlighten me\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums1.extend(nums2)\\n        nums1.sort()\\n        med=0\\n        if len(nums1)%2==0:\\n            med=(nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2\\n        else:\\n            med=nums1[len(nums1)//2]\\n        return float(\"{:.5f}\".format(med))"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1738524,
                "content": [
                    {
                        "username": "oinrup",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double median=0.00;\\n        int arr[] =new int[nums1.length+nums2.length];\\n        int n=nums1.length;\\n        for(int i=0;i<nums1.length;i++){\\n            arr[i]=nums1[i];\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            arr[n]=nums1[i];\\n                n++;\\n        }\\n        Arrays.sort(arr);\\n        while(arr.length!=0){\\n            if(arr.length%2!=0){\\n                median=(double)arr[arr.length/2];\\n            }\\n            else{\\n                int m=arr.length/2;\\n                double mm=(arr[arr.length/2]+arr[arr.length/2-1])/2;\\n                 median=mm;\\n            }\\n        }\\n\\nreturn median;\\n    }\\n}\\ncan anyone help me . I am not sure whats wrong in it."
                    },
                    {
                        "username": "inTEGraTOR",
                        "content": "I think it is worth defining median, since there are several wrong answers below because of this, and many questions:\\n\\n> The median of an array is the value in the middle of the array when the elements are sorted in numerical order. If the array has an odd number of elements, then the median is the middle element. If the array has an even number of elements, then the median is the average of the two middle elements.\\n\\n> For example, the median of the array [3, 5, 2, 1, 4] is 3, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5], and 3 is the middle element. The median of the array [3, 5, 2, 1, 4, 6] is (3 + 4) / 2 = 3.5, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5, 6], and 3.5 is the average of the two middle elements (3 and 4)."
                    },
                    {
                        "username": "user9407T",
                        "content": "---------Python Solution---------\\n\\nimport math\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        value = 0      \\n        n = len(nums1)\\n        m = len(nums2)\\n        temp = nums1 + nums2\\n        temp = sorted(temp)\\n        lenTemp = int(len(temp))\\n        if lenTemp % 2 == 0:\\n            value = (temp[math.floor(lenTemp/2) - 1] + temp[math.floor(lenTemp/2)]) / 2 \\n        else:\\n            value = temp[math.floor(lenTemp/2)]\\n        return value"
                    },
                    {
                        "username": "infi123",
                        "content": "Hello, where can I find the official solution for this problem?"
                    },
                    {
                        "username": "andregoes",
                        "content": "This should be working, but for some reason it does not. I test it off LeetCode and it works. But somehow it doesn\\'t here.\\n\\n```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        # Concatenate and sort lists\\n        numsAgg = nums1 + nums2\\n        numsAgg.sort()\\n       \\n        n = len(numsAgg) // 2\\n        if (len(numsAgg) % 2) == 0:\\n            return ( numsAgg[n] + numsAgg[n-1] ) / 2\\n        else:\\n            return numsAgg[n]\\n```"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2987826/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "its giving runtime error why?\\n double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0, j=0 ,k =0;\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        while(i<m && j<n){\\n            if(nums1 [i]< nums2[j]){\\n                ans[k++]=nums1[i++];\\n            }\\n             else{\\n                ans[k++]=nums2[j++];\\n            }\\n        }\\n         while(i<m){\\n             ans[k++]=nums1[i++];\\n         }\\n          while(j<n){\\n             ans[k++]=nums2[j++];\\n         }\\n\\n         int t = ans.size();\\n         int middle = t/2;\\n\\n         if (t % 2==0){\\n          return (double)(ans[middle - 1] + ans[middle]) / 2.0;\\n         }\\n\\n         else\\n          return (double)ans[middle];\\n\\n\\n        \\n\\n        \\n    }"
                    },
                    {
                        "username": "Joydey",
                        "content": "can anyone fix this code its runing properly but when i submit this the compiler showin wrong ans\\n\\n\\n\\ndouble findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) {\\n  int totalSize = nums1Size + nums2Size;\\n  int half = totalSize / 2;\\n  int i = 0, j = 0;\\n  double median1, median2;\\n  while (i < nums1Size && j < nums2Size) {\\n    if (nums1[i] <= nums2[j]) {\\n      if (i + j == half) {\\n        median1 = nums1[i];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums1[i];\\n      }\\n      i++;\\n    } else {\\n      if (i + j == half) {\\n        median1 = nums2[j];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums2[j];\\n      }\\n      j++;\\n    }\\n  }\\n  while (i < nums1Size) {\\n    if (i + j == half) {\\n      median1 = nums1[i];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums1[i];\\n    }\\n    i++;\\n  }\\n  while (j < nums2Size) {\\n    if (i + j == half) {\\n      median1 = nums2[j];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums2[j];\\n    }\\n    j++;\\n  }\\n  if (totalSize % 2 == 0) {\\n    return (median1 + median2) / 2;\\n  } else {\\n    return median1;\\n  }\\n}\\n\\n"
                    },
                    {
                        "username": "eyeshield99",
                        "content": "I\\'m a beginner and my solution is this in python, why did it outputs 2.00000 it must be 2.50000 please enlighten me\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums1.extend(nums2)\\n        nums1.sort()\\n        med=0\\n        if len(nums1)%2==0:\\n            med=(nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2\\n        else:\\n            med=nums1[len(nums1)//2]\\n        return float(\"{:.5f}\".format(med))"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1738333,
                "content": [
                    {
                        "username": "oinrup",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double median=0.00;\\n        int arr[] =new int[nums1.length+nums2.length];\\n        int n=nums1.length;\\n        for(int i=0;i<nums1.length;i++){\\n            arr[i]=nums1[i];\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            arr[n]=nums1[i];\\n                n++;\\n        }\\n        Arrays.sort(arr);\\n        while(arr.length!=0){\\n            if(arr.length%2!=0){\\n                median=(double)arr[arr.length/2];\\n            }\\n            else{\\n                int m=arr.length/2;\\n                double mm=(arr[arr.length/2]+arr[arr.length/2-1])/2;\\n                 median=mm;\\n            }\\n        }\\n\\nreturn median;\\n    }\\n}\\ncan anyone help me . I am not sure whats wrong in it."
                    },
                    {
                        "username": "inTEGraTOR",
                        "content": "I think it is worth defining median, since there are several wrong answers below because of this, and many questions:\\n\\n> The median of an array is the value in the middle of the array when the elements are sorted in numerical order. If the array has an odd number of elements, then the median is the middle element. If the array has an even number of elements, then the median is the average of the two middle elements.\\n\\n> For example, the median of the array [3, 5, 2, 1, 4] is 3, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5], and 3 is the middle element. The median of the array [3, 5, 2, 1, 4, 6] is (3 + 4) / 2 = 3.5, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5, 6], and 3.5 is the average of the two middle elements (3 and 4)."
                    },
                    {
                        "username": "user9407T",
                        "content": "---------Python Solution---------\\n\\nimport math\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        value = 0      \\n        n = len(nums1)\\n        m = len(nums2)\\n        temp = nums1 + nums2\\n        temp = sorted(temp)\\n        lenTemp = int(len(temp))\\n        if lenTemp % 2 == 0:\\n            value = (temp[math.floor(lenTemp/2) - 1] + temp[math.floor(lenTemp/2)]) / 2 \\n        else:\\n            value = temp[math.floor(lenTemp/2)]\\n        return value"
                    },
                    {
                        "username": "infi123",
                        "content": "Hello, where can I find the official solution for this problem?"
                    },
                    {
                        "username": "andregoes",
                        "content": "This should be working, but for some reason it does not. I test it off LeetCode and it works. But somehow it doesn\\'t here.\\n\\n```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        # Concatenate and sort lists\\n        numsAgg = nums1 + nums2\\n        numsAgg.sort()\\n       \\n        n = len(numsAgg) // 2\\n        if (len(numsAgg) % 2) == 0:\\n            return ( numsAgg[n] + numsAgg[n-1] ) / 2\\n        else:\\n            return numsAgg[n]\\n```"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2987826/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "its giving runtime error why?\\n double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0, j=0 ,k =0;\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        while(i<m && j<n){\\n            if(nums1 [i]< nums2[j]){\\n                ans[k++]=nums1[i++];\\n            }\\n             else{\\n                ans[k++]=nums2[j++];\\n            }\\n        }\\n         while(i<m){\\n             ans[k++]=nums1[i++];\\n         }\\n          while(j<n){\\n             ans[k++]=nums2[j++];\\n         }\\n\\n         int t = ans.size();\\n         int middle = t/2;\\n\\n         if (t % 2==0){\\n          return (double)(ans[middle - 1] + ans[middle]) / 2.0;\\n         }\\n\\n         else\\n          return (double)ans[middle];\\n\\n\\n        \\n\\n        \\n    }"
                    },
                    {
                        "username": "Joydey",
                        "content": "can anyone fix this code its runing properly but when i submit this the compiler showin wrong ans\\n\\n\\n\\ndouble findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) {\\n  int totalSize = nums1Size + nums2Size;\\n  int half = totalSize / 2;\\n  int i = 0, j = 0;\\n  double median1, median2;\\n  while (i < nums1Size && j < nums2Size) {\\n    if (nums1[i] <= nums2[j]) {\\n      if (i + j == half) {\\n        median1 = nums1[i];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums1[i];\\n      }\\n      i++;\\n    } else {\\n      if (i + j == half) {\\n        median1 = nums2[j];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums2[j];\\n      }\\n      j++;\\n    }\\n  }\\n  while (i < nums1Size) {\\n    if (i + j == half) {\\n      median1 = nums1[i];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums1[i];\\n    }\\n    i++;\\n  }\\n  while (j < nums2Size) {\\n    if (i + j == half) {\\n      median1 = nums2[j];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums2[j];\\n    }\\n    j++;\\n  }\\n  if (totalSize % 2 == 0) {\\n    return (median1 + median2) / 2;\\n  } else {\\n    return median1;\\n  }\\n}\\n\\n"
                    },
                    {
                        "username": "eyeshield99",
                        "content": "I\\'m a beginner and my solution is this in python, why did it outputs 2.00000 it must be 2.50000 please enlighten me\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums1.extend(nums2)\\n        nums1.sort()\\n        med=0\\n        if len(nums1)%2==0:\\n            med=(nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2\\n        else:\\n            med=nums1[len(nums1)//2]\\n        return float(\"{:.5f}\".format(med))"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1737144,
                "content": [
                    {
                        "username": "oinrup",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double median=0.00;\\n        int arr[] =new int[nums1.length+nums2.length];\\n        int n=nums1.length;\\n        for(int i=0;i<nums1.length;i++){\\n            arr[i]=nums1[i];\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            arr[n]=nums1[i];\\n                n++;\\n        }\\n        Arrays.sort(arr);\\n        while(arr.length!=0){\\n            if(arr.length%2!=0){\\n                median=(double)arr[arr.length/2];\\n            }\\n            else{\\n                int m=arr.length/2;\\n                double mm=(arr[arr.length/2]+arr[arr.length/2-1])/2;\\n                 median=mm;\\n            }\\n        }\\n\\nreturn median;\\n    }\\n}\\ncan anyone help me . I am not sure whats wrong in it."
                    },
                    {
                        "username": "inTEGraTOR",
                        "content": "I think it is worth defining median, since there are several wrong answers below because of this, and many questions:\\n\\n> The median of an array is the value in the middle of the array when the elements are sorted in numerical order. If the array has an odd number of elements, then the median is the middle element. If the array has an even number of elements, then the median is the average of the two middle elements.\\n\\n> For example, the median of the array [3, 5, 2, 1, 4] is 3, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5], and 3 is the middle element. The median of the array [3, 5, 2, 1, 4, 6] is (3 + 4) / 2 = 3.5, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5, 6], and 3.5 is the average of the two middle elements (3 and 4)."
                    },
                    {
                        "username": "user9407T",
                        "content": "---------Python Solution---------\\n\\nimport math\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        value = 0      \\n        n = len(nums1)\\n        m = len(nums2)\\n        temp = nums1 + nums2\\n        temp = sorted(temp)\\n        lenTemp = int(len(temp))\\n        if lenTemp % 2 == 0:\\n            value = (temp[math.floor(lenTemp/2) - 1] + temp[math.floor(lenTemp/2)]) / 2 \\n        else:\\n            value = temp[math.floor(lenTemp/2)]\\n        return value"
                    },
                    {
                        "username": "infi123",
                        "content": "Hello, where can I find the official solution for this problem?"
                    },
                    {
                        "username": "andregoes",
                        "content": "This should be working, but for some reason it does not. I test it off LeetCode and it works. But somehow it doesn\\'t here.\\n\\n```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        # Concatenate and sort lists\\n        numsAgg = nums1 + nums2\\n        numsAgg.sort()\\n       \\n        n = len(numsAgg) // 2\\n        if (len(numsAgg) % 2) == 0:\\n            return ( numsAgg[n] + numsAgg[n-1] ) / 2\\n        else:\\n            return numsAgg[n]\\n```"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2987826/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "its giving runtime error why?\\n double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0, j=0 ,k =0;\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        while(i<m && j<n){\\n            if(nums1 [i]< nums2[j]){\\n                ans[k++]=nums1[i++];\\n            }\\n             else{\\n                ans[k++]=nums2[j++];\\n            }\\n        }\\n         while(i<m){\\n             ans[k++]=nums1[i++];\\n         }\\n          while(j<n){\\n             ans[k++]=nums2[j++];\\n         }\\n\\n         int t = ans.size();\\n         int middle = t/2;\\n\\n         if (t % 2==0){\\n          return (double)(ans[middle - 1] + ans[middle]) / 2.0;\\n         }\\n\\n         else\\n          return (double)ans[middle];\\n\\n\\n        \\n\\n        \\n    }"
                    },
                    {
                        "username": "Joydey",
                        "content": "can anyone fix this code its runing properly but when i submit this the compiler showin wrong ans\\n\\n\\n\\ndouble findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) {\\n  int totalSize = nums1Size + nums2Size;\\n  int half = totalSize / 2;\\n  int i = 0, j = 0;\\n  double median1, median2;\\n  while (i < nums1Size && j < nums2Size) {\\n    if (nums1[i] <= nums2[j]) {\\n      if (i + j == half) {\\n        median1 = nums1[i];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums1[i];\\n      }\\n      i++;\\n    } else {\\n      if (i + j == half) {\\n        median1 = nums2[j];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums2[j];\\n      }\\n      j++;\\n    }\\n  }\\n  while (i < nums1Size) {\\n    if (i + j == half) {\\n      median1 = nums1[i];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums1[i];\\n    }\\n    i++;\\n  }\\n  while (j < nums2Size) {\\n    if (i + j == half) {\\n      median1 = nums2[j];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums2[j];\\n    }\\n    j++;\\n  }\\n  if (totalSize % 2 == 0) {\\n    return (median1 + median2) / 2;\\n  } else {\\n    return median1;\\n  }\\n}\\n\\n"
                    },
                    {
                        "username": "eyeshield99",
                        "content": "I\\'m a beginner and my solution is this in python, why did it outputs 2.00000 it must be 2.50000 please enlighten me\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums1.extend(nums2)\\n        nums1.sort()\\n        med=0\\n        if len(nums1)%2==0:\\n            med=(nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2\\n        else:\\n            med=nums1[len(nums1)//2]\\n        return float(\"{:.5f}\".format(med))"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1735758,
                "content": [
                    {
                        "username": "oinrup",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double median=0.00;\\n        int arr[] =new int[nums1.length+nums2.length];\\n        int n=nums1.length;\\n        for(int i=0;i<nums1.length;i++){\\n            arr[i]=nums1[i];\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            arr[n]=nums1[i];\\n                n++;\\n        }\\n        Arrays.sort(arr);\\n        while(arr.length!=0){\\n            if(arr.length%2!=0){\\n                median=(double)arr[arr.length/2];\\n            }\\n            else{\\n                int m=arr.length/2;\\n                double mm=(arr[arr.length/2]+arr[arr.length/2-1])/2;\\n                 median=mm;\\n            }\\n        }\\n\\nreturn median;\\n    }\\n}\\ncan anyone help me . I am not sure whats wrong in it."
                    },
                    {
                        "username": "inTEGraTOR",
                        "content": "I think it is worth defining median, since there are several wrong answers below because of this, and many questions:\\n\\n> The median of an array is the value in the middle of the array when the elements are sorted in numerical order. If the array has an odd number of elements, then the median is the middle element. If the array has an even number of elements, then the median is the average of the two middle elements.\\n\\n> For example, the median of the array [3, 5, 2, 1, 4] is 3, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5], and 3 is the middle element. The median of the array [3, 5, 2, 1, 4, 6] is (3 + 4) / 2 = 3.5, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5, 6], and 3.5 is the average of the two middle elements (3 and 4)."
                    },
                    {
                        "username": "user9407T",
                        "content": "---------Python Solution---------\\n\\nimport math\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        value = 0      \\n        n = len(nums1)\\n        m = len(nums2)\\n        temp = nums1 + nums2\\n        temp = sorted(temp)\\n        lenTemp = int(len(temp))\\n        if lenTemp % 2 == 0:\\n            value = (temp[math.floor(lenTemp/2) - 1] + temp[math.floor(lenTemp/2)]) / 2 \\n        else:\\n            value = temp[math.floor(lenTemp/2)]\\n        return value"
                    },
                    {
                        "username": "infi123",
                        "content": "Hello, where can I find the official solution for this problem?"
                    },
                    {
                        "username": "andregoes",
                        "content": "This should be working, but for some reason it does not. I test it off LeetCode and it works. But somehow it doesn\\'t here.\\n\\n```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        # Concatenate and sort lists\\n        numsAgg = nums1 + nums2\\n        numsAgg.sort()\\n       \\n        n = len(numsAgg) // 2\\n        if (len(numsAgg) % 2) == 0:\\n            return ( numsAgg[n] + numsAgg[n-1] ) / 2\\n        else:\\n            return numsAgg[n]\\n```"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2987826/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "its giving runtime error why?\\n double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0, j=0 ,k =0;\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        while(i<m && j<n){\\n            if(nums1 [i]< nums2[j]){\\n                ans[k++]=nums1[i++];\\n            }\\n             else{\\n                ans[k++]=nums2[j++];\\n            }\\n        }\\n         while(i<m){\\n             ans[k++]=nums1[i++];\\n         }\\n          while(j<n){\\n             ans[k++]=nums2[j++];\\n         }\\n\\n         int t = ans.size();\\n         int middle = t/2;\\n\\n         if (t % 2==0){\\n          return (double)(ans[middle - 1] + ans[middle]) / 2.0;\\n         }\\n\\n         else\\n          return (double)ans[middle];\\n\\n\\n        \\n\\n        \\n    }"
                    },
                    {
                        "username": "Joydey",
                        "content": "can anyone fix this code its runing properly but when i submit this the compiler showin wrong ans\\n\\n\\n\\ndouble findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) {\\n  int totalSize = nums1Size + nums2Size;\\n  int half = totalSize / 2;\\n  int i = 0, j = 0;\\n  double median1, median2;\\n  while (i < nums1Size && j < nums2Size) {\\n    if (nums1[i] <= nums2[j]) {\\n      if (i + j == half) {\\n        median1 = nums1[i];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums1[i];\\n      }\\n      i++;\\n    } else {\\n      if (i + j == half) {\\n        median1 = nums2[j];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums2[j];\\n      }\\n      j++;\\n    }\\n  }\\n  while (i < nums1Size) {\\n    if (i + j == half) {\\n      median1 = nums1[i];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums1[i];\\n    }\\n    i++;\\n  }\\n  while (j < nums2Size) {\\n    if (i + j == half) {\\n      median1 = nums2[j];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums2[j];\\n    }\\n    j++;\\n  }\\n  if (totalSize % 2 == 0) {\\n    return (median1 + median2) / 2;\\n  } else {\\n    return median1;\\n  }\\n}\\n\\n"
                    },
                    {
                        "username": "eyeshield99",
                        "content": "I\\'m a beginner and my solution is this in python, why did it outputs 2.00000 it must be 2.50000 please enlighten me\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums1.extend(nums2)\\n        nums1.sort()\\n        med=0\\n        if len(nums1)%2==0:\\n            med=(nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2\\n        else:\\n            med=nums1[len(nums1)//2]\\n        return float(\"{:.5f}\".format(med))"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1735631,
                "content": [
                    {
                        "username": "oinrup",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double median=0.00;\\n        int arr[] =new int[nums1.length+nums2.length];\\n        int n=nums1.length;\\n        for(int i=0;i<nums1.length;i++){\\n            arr[i]=nums1[i];\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            arr[n]=nums1[i];\\n                n++;\\n        }\\n        Arrays.sort(arr);\\n        while(arr.length!=0){\\n            if(arr.length%2!=0){\\n                median=(double)arr[arr.length/2];\\n            }\\n            else{\\n                int m=arr.length/2;\\n                double mm=(arr[arr.length/2]+arr[arr.length/2-1])/2;\\n                 median=mm;\\n            }\\n        }\\n\\nreturn median;\\n    }\\n}\\ncan anyone help me . I am not sure whats wrong in it."
                    },
                    {
                        "username": "inTEGraTOR",
                        "content": "I think it is worth defining median, since there are several wrong answers below because of this, and many questions:\\n\\n> The median of an array is the value in the middle of the array when the elements are sorted in numerical order. If the array has an odd number of elements, then the median is the middle element. If the array has an even number of elements, then the median is the average of the two middle elements.\\n\\n> For example, the median of the array [3, 5, 2, 1, 4] is 3, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5], and 3 is the middle element. The median of the array [3, 5, 2, 1, 4, 6] is (3 + 4) / 2 = 3.5, because when the elements are sorted, the array becomes [1, 2, 3, 4, 5, 6], and 3.5 is the average of the two middle elements (3 and 4)."
                    },
                    {
                        "username": "user9407T",
                        "content": "---------Python Solution---------\\n\\nimport math\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        value = 0      \\n        n = len(nums1)\\n        m = len(nums2)\\n        temp = nums1 + nums2\\n        temp = sorted(temp)\\n        lenTemp = int(len(temp))\\n        if lenTemp % 2 == 0:\\n            value = (temp[math.floor(lenTemp/2) - 1] + temp[math.floor(lenTemp/2)]) / 2 \\n        else:\\n            value = temp[math.floor(lenTemp/2)]\\n        return value"
                    },
                    {
                        "username": "infi123",
                        "content": "Hello, where can I find the official solution for this problem?"
                    },
                    {
                        "username": "andregoes",
                        "content": "This should be working, but for some reason it does not. I test it off LeetCode and it works. But somehow it doesn\\'t here.\\n\\n```\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        # Concatenate and sort lists\\n        numsAgg = nums1 + nums2\\n        numsAgg.sort()\\n       \\n        n = len(numsAgg) // 2\\n        if (len(numsAgg) % 2) == 0:\\n            return ( numsAgg[n] + numsAgg[n-1] ) / 2\\n        else:\\n            return numsAgg[n]\\n```"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2987826/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "its giving runtime error why?\\n double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0, j=0 ,k =0;\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        while(i<m && j<n){\\n            if(nums1 [i]< nums2[j]){\\n                ans[k++]=nums1[i++];\\n            }\\n             else{\\n                ans[k++]=nums2[j++];\\n            }\\n        }\\n         while(i<m){\\n             ans[k++]=nums1[i++];\\n         }\\n          while(j<n){\\n             ans[k++]=nums2[j++];\\n         }\\n\\n         int t = ans.size();\\n         int middle = t/2;\\n\\n         if (t % 2==0){\\n          return (double)(ans[middle - 1] + ans[middle]) / 2.0;\\n         }\\n\\n         else\\n          return (double)ans[middle];\\n\\n\\n        \\n\\n        \\n    }"
                    },
                    {
                        "username": "Joydey",
                        "content": "can anyone fix this code its runing properly but when i submit this the compiler showin wrong ans\\n\\n\\n\\ndouble findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) {\\n  int totalSize = nums1Size + nums2Size;\\n  int half = totalSize / 2;\\n  int i = 0, j = 0;\\n  double median1, median2;\\n  while (i < nums1Size && j < nums2Size) {\\n    if (nums1[i] <= nums2[j]) {\\n      if (i + j == half) {\\n        median1 = nums1[i];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums1[i];\\n      }\\n      i++;\\n    } else {\\n      if (i + j == half) {\\n        median1 = nums2[j];\\n        break;\\n      }\\n      if (i + j == half - 1) {\\n        median2 = nums2[j];\\n      }\\n      j++;\\n    }\\n  }\\n  while (i < nums1Size) {\\n    if (i + j == half) {\\n      median1 = nums1[i];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums1[i];\\n    }\\n    i++;\\n  }\\n  while (j < nums2Size) {\\n    if (i + j == half) {\\n      median1 = nums2[j];\\n      break;\\n    }\\n    if (i + j == half - 1) {\\n      median2 = nums2[j];\\n    }\\n    j++;\\n  }\\n  if (totalSize % 2 == 0) {\\n    return (median1 + median2) / 2;\\n  } else {\\n    return median1;\\n  }\\n}\\n\\n"
                    },
                    {
                        "username": "eyeshield99",
                        "content": "I\\'m a beginner and my solution is this in python, why did it outputs 2.00000 it must be 2.50000 please enlighten me\\nclass Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \"\"\"\\n        nums1.extend(nums2)\\n        nums1.sort()\\n        med=0\\n        if len(nums1)%2==0:\\n            med=(nums1[len(nums1)//2]+nums1[(len(nums1)//2)-1])/2\\n        else:\\n            med=nums1[len(nums1)//2]\\n        return float(\"{:.5f}\".format(med))"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1735625,
                "content": [
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in java, python, c++ and c programming\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "dovbysh",
                        "content": "I sent a solution with time complexity O(log(m+n)). The difference between 3ms and 12ms in one empty string in the code. So, for solutions in Go need more complicated tests."
                    },
                    {
                        "username": "deleted_user",
                        "content": "idk"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// this is one way to solve the problem, but a space on O( m+n) is required here and time complexity in also O(nlog(m+n))\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector< int> a;\\n        for( int  i=0;i< nums1.size();i++){\\n            a.push_back(nums1[i]);\\n        }\\n        for( int  i=0;i< nums2.size();i++){\\n            a.push_back(nums2[i]);\\n        }\\n        sort( a.begin(), a.end());\\n        int l= a.size();\\n        if( l%2==0){\\n            return ( a[l/2]+a[(l/2)-1])/2.0;\\n        }\\n        else{\\n            return a[l/2];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// whye it shows that no viable conversion from returned value of type vector<double> to function return type double\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m= nums2.size();\\n        vector<double>ans(n+m);\\n        int i=0,j=0,k=0;\\n        while( i< min( m,n)){\\n            if( nums1[j]<nums2[k]){\\n                ans[i]=nums1[j];\\n                cout<<ans[i]<<endl;\\n                i++;j++;\\n            }\\n            else{\\n                ans[i]=nums2[k];\\n                cout<<ans[i]<<endl;\\n                i++;k++;\\n            }\\n        }\\n        if ( j==n){ \\n            while(i<m+n)\\n            ans[i]=nums2[k];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            k++;\\n        }\\n         if ( j==m){ \\n            while(i<m+n)\\n            ans[i]=nums1[j];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "imrrai009",
                        "content": "Easiest i could think\\uD83D\\uDE01\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int>v(nums1.size()+nums2.size());\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        merge(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),v.begin());\\n\\n        int low=0;\\n        int high=v.size()-1;\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\n            if(v.size()%2==0)\\n            return  (float)(v[mid]+(v[mid+1]))/2;\\n            else\\n            return (float)v[mid];\\n        }\\n        return -1;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "vipin_tiwari",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    const mergedArry= [...nums1, ...nums2]\\n    const sum= mergedArry.reduce((accum, current)=> accum+ current , 0)\\n    return  sum/mergedArry.length;\\n};\\n\\nIs there anything wrong with this solution?. It\\'s passing both testcases(case1 and case2) but at the time of submitting the code it\\'s showing the \\'wrong Answer\\'. "
                    },
                    {
                        "username": "nyck33",
                        "content": "Can I do:\\n(Median of array1 + Median of array2) / 2 ?  In which case I need to know the lengths of array1 and array2 but counting would take O(n+m) on its own.  "
                    },
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] merge = new int[nums1.length + nums2.length];\\n        int i = 0;\\n        for(i = 0; i < nums1.length; i++)\\n            merge[i] = nums1[i];\\n        for(; i - nums1.length < nums2.length; i++)\\n            merge[i] = nums2[i - nums1.length];\\n        Arrays.sort(merge);\\n        return (merge.length) % 2 != 0 ? \\n            (double)merge[merge.length / 2] : (double)(merge[merge.length / 2] + merge[merge.length / 2 - 1]) / 2;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1733532,
                "content": [
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in java, python, c++ and c programming\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "dovbysh",
                        "content": "I sent a solution with time complexity O(log(m+n)). The difference between 3ms and 12ms in one empty string in the code. So, for solutions in Go need more complicated tests."
                    },
                    {
                        "username": "deleted_user",
                        "content": "idk"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// this is one way to solve the problem, but a space on O( m+n) is required here and time complexity in also O(nlog(m+n))\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector< int> a;\\n        for( int  i=0;i< nums1.size();i++){\\n            a.push_back(nums1[i]);\\n        }\\n        for( int  i=0;i< nums2.size();i++){\\n            a.push_back(nums2[i]);\\n        }\\n        sort( a.begin(), a.end());\\n        int l= a.size();\\n        if( l%2==0){\\n            return ( a[l/2]+a[(l/2)-1])/2.0;\\n        }\\n        else{\\n            return a[l/2];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// whye it shows that no viable conversion from returned value of type vector<double> to function return type double\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m= nums2.size();\\n        vector<double>ans(n+m);\\n        int i=0,j=0,k=0;\\n        while( i< min( m,n)){\\n            if( nums1[j]<nums2[k]){\\n                ans[i]=nums1[j];\\n                cout<<ans[i]<<endl;\\n                i++;j++;\\n            }\\n            else{\\n                ans[i]=nums2[k];\\n                cout<<ans[i]<<endl;\\n                i++;k++;\\n            }\\n        }\\n        if ( j==n){ \\n            while(i<m+n)\\n            ans[i]=nums2[k];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            k++;\\n        }\\n         if ( j==m){ \\n            while(i<m+n)\\n            ans[i]=nums1[j];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "imrrai009",
                        "content": "Easiest i could think\\uD83D\\uDE01\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int>v(nums1.size()+nums2.size());\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        merge(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),v.begin());\\n\\n        int low=0;\\n        int high=v.size()-1;\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\n            if(v.size()%2==0)\\n            return  (float)(v[mid]+(v[mid+1]))/2;\\n            else\\n            return (float)v[mid];\\n        }\\n        return -1;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "vipin_tiwari",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    const mergedArry= [...nums1, ...nums2]\\n    const sum= mergedArry.reduce((accum, current)=> accum+ current , 0)\\n    return  sum/mergedArry.length;\\n};\\n\\nIs there anything wrong with this solution?. It\\'s passing both testcases(case1 and case2) but at the time of submitting the code it\\'s showing the \\'wrong Answer\\'. "
                    },
                    {
                        "username": "nyck33",
                        "content": "Can I do:\\n(Median of array1 + Median of array2) / 2 ?  In which case I need to know the lengths of array1 and array2 but counting would take O(n+m) on its own.  "
                    },
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] merge = new int[nums1.length + nums2.length];\\n        int i = 0;\\n        for(i = 0; i < nums1.length; i++)\\n            merge[i] = nums1[i];\\n        for(; i - nums1.length < nums2.length; i++)\\n            merge[i] = nums2[i - nums1.length];\\n        Arrays.sort(merge);\\n        return (merge.length) % 2 != 0 ? \\n            (double)merge[merge.length / 2] : (double)(merge[merge.length / 2] + merge[merge.length / 2 - 1]) / 2;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1733351,
                "content": [
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in java, python, c++ and c programming\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "dovbysh",
                        "content": "I sent a solution with time complexity O(log(m+n)). The difference between 3ms and 12ms in one empty string in the code. So, for solutions in Go need more complicated tests."
                    },
                    {
                        "username": "deleted_user",
                        "content": "idk"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// this is one way to solve the problem, but a space on O( m+n) is required here and time complexity in also O(nlog(m+n))\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector< int> a;\\n        for( int  i=0;i< nums1.size();i++){\\n            a.push_back(nums1[i]);\\n        }\\n        for( int  i=0;i< nums2.size();i++){\\n            a.push_back(nums2[i]);\\n        }\\n        sort( a.begin(), a.end());\\n        int l= a.size();\\n        if( l%2==0){\\n            return ( a[l/2]+a[(l/2)-1])/2.0;\\n        }\\n        else{\\n            return a[l/2];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// whye it shows that no viable conversion from returned value of type vector<double> to function return type double\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m= nums2.size();\\n        vector<double>ans(n+m);\\n        int i=0,j=0,k=0;\\n        while( i< min( m,n)){\\n            if( nums1[j]<nums2[k]){\\n                ans[i]=nums1[j];\\n                cout<<ans[i]<<endl;\\n                i++;j++;\\n            }\\n            else{\\n                ans[i]=nums2[k];\\n                cout<<ans[i]<<endl;\\n                i++;k++;\\n            }\\n        }\\n        if ( j==n){ \\n            while(i<m+n)\\n            ans[i]=nums2[k];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            k++;\\n        }\\n         if ( j==m){ \\n            while(i<m+n)\\n            ans[i]=nums1[j];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "imrrai009",
                        "content": "Easiest i could think\\uD83D\\uDE01\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int>v(nums1.size()+nums2.size());\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        merge(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),v.begin());\\n\\n        int low=0;\\n        int high=v.size()-1;\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\n            if(v.size()%2==0)\\n            return  (float)(v[mid]+(v[mid+1]))/2;\\n            else\\n            return (float)v[mid];\\n        }\\n        return -1;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "vipin_tiwari",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    const mergedArry= [...nums1, ...nums2]\\n    const sum= mergedArry.reduce((accum, current)=> accum+ current , 0)\\n    return  sum/mergedArry.length;\\n};\\n\\nIs there anything wrong with this solution?. It\\'s passing both testcases(case1 and case2) but at the time of submitting the code it\\'s showing the \\'wrong Answer\\'. "
                    },
                    {
                        "username": "nyck33",
                        "content": "Can I do:\\n(Median of array1 + Median of array2) / 2 ?  In which case I need to know the lengths of array1 and array2 but counting would take O(n+m) on its own.  "
                    },
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] merge = new int[nums1.length + nums2.length];\\n        int i = 0;\\n        for(i = 0; i < nums1.length; i++)\\n            merge[i] = nums1[i];\\n        for(; i - nums1.length < nums2.length; i++)\\n            merge[i] = nums2[i - nums1.length];\\n        Arrays.sort(merge);\\n        return (merge.length) % 2 != 0 ? \\n            (double)merge[merge.length / 2] : (double)(merge[merge.length / 2] + merge[merge.length / 2 - 1]) / 2;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1731652,
                "content": [
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in java, python, c++ and c programming\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "dovbysh",
                        "content": "I sent a solution with time complexity O(log(m+n)). The difference between 3ms and 12ms in one empty string in the code. So, for solutions in Go need more complicated tests."
                    },
                    {
                        "username": "deleted_user",
                        "content": "idk"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// this is one way to solve the problem, but a space on O( m+n) is required here and time complexity in also O(nlog(m+n))\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector< int> a;\\n        for( int  i=0;i< nums1.size();i++){\\n            a.push_back(nums1[i]);\\n        }\\n        for( int  i=0;i< nums2.size();i++){\\n            a.push_back(nums2[i]);\\n        }\\n        sort( a.begin(), a.end());\\n        int l= a.size();\\n        if( l%2==0){\\n            return ( a[l/2]+a[(l/2)-1])/2.0;\\n        }\\n        else{\\n            return a[l/2];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// whye it shows that no viable conversion from returned value of type vector<double> to function return type double\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m= nums2.size();\\n        vector<double>ans(n+m);\\n        int i=0,j=0,k=0;\\n        while( i< min( m,n)){\\n            if( nums1[j]<nums2[k]){\\n                ans[i]=nums1[j];\\n                cout<<ans[i]<<endl;\\n                i++;j++;\\n            }\\n            else{\\n                ans[i]=nums2[k];\\n                cout<<ans[i]<<endl;\\n                i++;k++;\\n            }\\n        }\\n        if ( j==n){ \\n            while(i<m+n)\\n            ans[i]=nums2[k];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            k++;\\n        }\\n         if ( j==m){ \\n            while(i<m+n)\\n            ans[i]=nums1[j];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "imrrai009",
                        "content": "Easiest i could think\\uD83D\\uDE01\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int>v(nums1.size()+nums2.size());\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        merge(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),v.begin());\\n\\n        int low=0;\\n        int high=v.size()-1;\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\n            if(v.size()%2==0)\\n            return  (float)(v[mid]+(v[mid+1]))/2;\\n            else\\n            return (float)v[mid];\\n        }\\n        return -1;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "vipin_tiwari",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    const mergedArry= [...nums1, ...nums2]\\n    const sum= mergedArry.reduce((accum, current)=> accum+ current , 0)\\n    return  sum/mergedArry.length;\\n};\\n\\nIs there anything wrong with this solution?. It\\'s passing both testcases(case1 and case2) but at the time of submitting the code it\\'s showing the \\'wrong Answer\\'. "
                    },
                    {
                        "username": "nyck33",
                        "content": "Can I do:\\n(Median of array1 + Median of array2) / 2 ?  In which case I need to know the lengths of array1 and array2 but counting would take O(n+m) on its own.  "
                    },
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] merge = new int[nums1.length + nums2.length];\\n        int i = 0;\\n        for(i = 0; i < nums1.length; i++)\\n            merge[i] = nums1[i];\\n        for(; i - nums1.length < nums2.length; i++)\\n            merge[i] = nums2[i - nums1.length];\\n        Arrays.sort(merge);\\n        return (merge.length) % 2 != 0 ? \\n            (double)merge[merge.length / 2] : (double)(merge[merge.length / 2] + merge[merge.length / 2 - 1]) / 2;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1731323,
                "content": [
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in java, python, c++ and c programming\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "dovbysh",
                        "content": "I sent a solution with time complexity O(log(m+n)). The difference between 3ms and 12ms in one empty string in the code. So, for solutions in Go need more complicated tests."
                    },
                    {
                        "username": "deleted_user",
                        "content": "idk"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// this is one way to solve the problem, but a space on O( m+n) is required here and time complexity in also O(nlog(m+n))\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector< int> a;\\n        for( int  i=0;i< nums1.size();i++){\\n            a.push_back(nums1[i]);\\n        }\\n        for( int  i=0;i< nums2.size();i++){\\n            a.push_back(nums2[i]);\\n        }\\n        sort( a.begin(), a.end());\\n        int l= a.size();\\n        if( l%2==0){\\n            return ( a[l/2]+a[(l/2)-1])/2.0;\\n        }\\n        else{\\n            return a[l/2];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// whye it shows that no viable conversion from returned value of type vector<double> to function return type double\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m= nums2.size();\\n        vector<double>ans(n+m);\\n        int i=0,j=0,k=0;\\n        while( i< min( m,n)){\\n            if( nums1[j]<nums2[k]){\\n                ans[i]=nums1[j];\\n                cout<<ans[i]<<endl;\\n                i++;j++;\\n            }\\n            else{\\n                ans[i]=nums2[k];\\n                cout<<ans[i]<<endl;\\n                i++;k++;\\n            }\\n        }\\n        if ( j==n){ \\n            while(i<m+n)\\n            ans[i]=nums2[k];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            k++;\\n        }\\n         if ( j==m){ \\n            while(i<m+n)\\n            ans[i]=nums1[j];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "imrrai009",
                        "content": "Easiest i could think\\uD83D\\uDE01\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int>v(nums1.size()+nums2.size());\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        merge(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),v.begin());\\n\\n        int low=0;\\n        int high=v.size()-1;\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\n            if(v.size()%2==0)\\n            return  (float)(v[mid]+(v[mid+1]))/2;\\n            else\\n            return (float)v[mid];\\n        }\\n        return -1;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "vipin_tiwari",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    const mergedArry= [...nums1, ...nums2]\\n    const sum= mergedArry.reduce((accum, current)=> accum+ current , 0)\\n    return  sum/mergedArry.length;\\n};\\n\\nIs there anything wrong with this solution?. It\\'s passing both testcases(case1 and case2) but at the time of submitting the code it\\'s showing the \\'wrong Answer\\'. "
                    },
                    {
                        "username": "nyck33",
                        "content": "Can I do:\\n(Median of array1 + Median of array2) / 2 ?  In which case I need to know the lengths of array1 and array2 but counting would take O(n+m) on its own.  "
                    },
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] merge = new int[nums1.length + nums2.length];\\n        int i = 0;\\n        for(i = 0; i < nums1.length; i++)\\n            merge[i] = nums1[i];\\n        for(; i - nums1.length < nums2.length; i++)\\n            merge[i] = nums2[i - nums1.length];\\n        Arrays.sort(merge);\\n        return (merge.length) % 2 != 0 ? \\n            (double)merge[merge.length / 2] : (double)(merge[merge.length / 2] + merge[merge.length / 2 - 1]) / 2;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1731201,
                "content": [
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in java, python, c++ and c programming\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "dovbysh",
                        "content": "I sent a solution with time complexity O(log(m+n)). The difference between 3ms and 12ms in one empty string in the code. So, for solutions in Go need more complicated tests."
                    },
                    {
                        "username": "deleted_user",
                        "content": "idk"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// this is one way to solve the problem, but a space on O( m+n) is required here and time complexity in also O(nlog(m+n))\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector< int> a;\\n        for( int  i=0;i< nums1.size();i++){\\n            a.push_back(nums1[i]);\\n        }\\n        for( int  i=0;i< nums2.size();i++){\\n            a.push_back(nums2[i]);\\n        }\\n        sort( a.begin(), a.end());\\n        int l= a.size();\\n        if( l%2==0){\\n            return ( a[l/2]+a[(l/2)-1])/2.0;\\n        }\\n        else{\\n            return a[l/2];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// whye it shows that no viable conversion from returned value of type vector<double> to function return type double\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m= nums2.size();\\n        vector<double>ans(n+m);\\n        int i=0,j=0,k=0;\\n        while( i< min( m,n)){\\n            if( nums1[j]<nums2[k]){\\n                ans[i]=nums1[j];\\n                cout<<ans[i]<<endl;\\n                i++;j++;\\n            }\\n            else{\\n                ans[i]=nums2[k];\\n                cout<<ans[i]<<endl;\\n                i++;k++;\\n            }\\n        }\\n        if ( j==n){ \\n            while(i<m+n)\\n            ans[i]=nums2[k];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            k++;\\n        }\\n         if ( j==m){ \\n            while(i<m+n)\\n            ans[i]=nums1[j];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "imrrai009",
                        "content": "Easiest i could think\\uD83D\\uDE01\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int>v(nums1.size()+nums2.size());\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        merge(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),v.begin());\\n\\n        int low=0;\\n        int high=v.size()-1;\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\n            if(v.size()%2==0)\\n            return  (float)(v[mid]+(v[mid+1]))/2;\\n            else\\n            return (float)v[mid];\\n        }\\n        return -1;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "vipin_tiwari",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    const mergedArry= [...nums1, ...nums2]\\n    const sum= mergedArry.reduce((accum, current)=> accum+ current , 0)\\n    return  sum/mergedArry.length;\\n};\\n\\nIs there anything wrong with this solution?. It\\'s passing both testcases(case1 and case2) but at the time of submitting the code it\\'s showing the \\'wrong Answer\\'. "
                    },
                    {
                        "username": "nyck33",
                        "content": "Can I do:\\n(Median of array1 + Median of array2) / 2 ?  In which case I need to know the lengths of array1 and array2 but counting would take O(n+m) on its own.  "
                    },
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] merge = new int[nums1.length + nums2.length];\\n        int i = 0;\\n        for(i = 0; i < nums1.length; i++)\\n            merge[i] = nums1[i];\\n        for(; i - nums1.length < nums2.length; i++)\\n            merge[i] = nums2[i - nums1.length];\\n        Arrays.sort(merge);\\n        return (merge.length) % 2 != 0 ? \\n            (double)merge[merge.length / 2] : (double)(merge[merge.length / 2] + merge[merge.length / 2 - 1]) / 2;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1729900,
                "content": [
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in java, python, c++ and c programming\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "dovbysh",
                        "content": "I sent a solution with time complexity O(log(m+n)). The difference between 3ms and 12ms in one empty string in the code. So, for solutions in Go need more complicated tests."
                    },
                    {
                        "username": "deleted_user",
                        "content": "idk"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// this is one way to solve the problem, but a space on O( m+n) is required here and time complexity in also O(nlog(m+n))\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector< int> a;\\n        for( int  i=0;i< nums1.size();i++){\\n            a.push_back(nums1[i]);\\n        }\\n        for( int  i=0;i< nums2.size();i++){\\n            a.push_back(nums2[i]);\\n        }\\n        sort( a.begin(), a.end());\\n        int l= a.size();\\n        if( l%2==0){\\n            return ( a[l/2]+a[(l/2)-1])/2.0;\\n        }\\n        else{\\n            return a[l/2];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// whye it shows that no viable conversion from returned value of type vector<double> to function return type double\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m= nums2.size();\\n        vector<double>ans(n+m);\\n        int i=0,j=0,k=0;\\n        while( i< min( m,n)){\\n            if( nums1[j]<nums2[k]){\\n                ans[i]=nums1[j];\\n                cout<<ans[i]<<endl;\\n                i++;j++;\\n            }\\n            else{\\n                ans[i]=nums2[k];\\n                cout<<ans[i]<<endl;\\n                i++;k++;\\n            }\\n        }\\n        if ( j==n){ \\n            while(i<m+n)\\n            ans[i]=nums2[k];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            k++;\\n        }\\n         if ( j==m){ \\n            while(i<m+n)\\n            ans[i]=nums1[j];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "imrrai009",
                        "content": "Easiest i could think\\uD83D\\uDE01\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int>v(nums1.size()+nums2.size());\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        merge(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),v.begin());\\n\\n        int low=0;\\n        int high=v.size()-1;\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\n            if(v.size()%2==0)\\n            return  (float)(v[mid]+(v[mid+1]))/2;\\n            else\\n            return (float)v[mid];\\n        }\\n        return -1;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "vipin_tiwari",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    const mergedArry= [...nums1, ...nums2]\\n    const sum= mergedArry.reduce((accum, current)=> accum+ current , 0)\\n    return  sum/mergedArry.length;\\n};\\n\\nIs there anything wrong with this solution?. It\\'s passing both testcases(case1 and case2) but at the time of submitting the code it\\'s showing the \\'wrong Answer\\'. "
                    },
                    {
                        "username": "nyck33",
                        "content": "Can I do:\\n(Median of array1 + Median of array2) / 2 ?  In which case I need to know the lengths of array1 and array2 but counting would take O(n+m) on its own.  "
                    },
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] merge = new int[nums1.length + nums2.length];\\n        int i = 0;\\n        for(i = 0; i < nums1.length; i++)\\n            merge[i] = nums1[i];\\n        for(; i - nums1.length < nums2.length; i++)\\n            merge[i] = nums2[i - nums1.length];\\n        Arrays.sort(merge);\\n        return (merge.length) % 2 != 0 ? \\n            (double)merge[merge.length / 2] : (double)(merge[merge.length / 2] + merge[merge.length / 2 - 1]) / 2;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1728896,
                "content": [
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in java, python, c++ and c programming\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "dovbysh",
                        "content": "I sent a solution with time complexity O(log(m+n)). The difference between 3ms and 12ms in one empty string in the code. So, for solutions in Go need more complicated tests."
                    },
                    {
                        "username": "deleted_user",
                        "content": "idk"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// this is one way to solve the problem, but a space on O( m+n) is required here and time complexity in also O(nlog(m+n))\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector< int> a;\\n        for( int  i=0;i< nums1.size();i++){\\n            a.push_back(nums1[i]);\\n        }\\n        for( int  i=0;i< nums2.size();i++){\\n            a.push_back(nums2[i]);\\n        }\\n        sort( a.begin(), a.end());\\n        int l= a.size();\\n        if( l%2==0){\\n            return ( a[l/2]+a[(l/2)-1])/2.0;\\n        }\\n        else{\\n            return a[l/2];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// whye it shows that no viable conversion from returned value of type vector<double> to function return type double\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m= nums2.size();\\n        vector<double>ans(n+m);\\n        int i=0,j=0,k=0;\\n        while( i< min( m,n)){\\n            if( nums1[j]<nums2[k]){\\n                ans[i]=nums1[j];\\n                cout<<ans[i]<<endl;\\n                i++;j++;\\n            }\\n            else{\\n                ans[i]=nums2[k];\\n                cout<<ans[i]<<endl;\\n                i++;k++;\\n            }\\n        }\\n        if ( j==n){ \\n            while(i<m+n)\\n            ans[i]=nums2[k];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            k++;\\n        }\\n         if ( j==m){ \\n            while(i<m+n)\\n            ans[i]=nums1[j];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "imrrai009",
                        "content": "Easiest i could think\\uD83D\\uDE01\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int>v(nums1.size()+nums2.size());\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        merge(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),v.begin());\\n\\n        int low=0;\\n        int high=v.size()-1;\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\n            if(v.size()%2==0)\\n            return  (float)(v[mid]+(v[mid+1]))/2;\\n            else\\n            return (float)v[mid];\\n        }\\n        return -1;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "vipin_tiwari",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    const mergedArry= [...nums1, ...nums2]\\n    const sum= mergedArry.reduce((accum, current)=> accum+ current , 0)\\n    return  sum/mergedArry.length;\\n};\\n\\nIs there anything wrong with this solution?. It\\'s passing both testcases(case1 and case2) but at the time of submitting the code it\\'s showing the \\'wrong Answer\\'. "
                    },
                    {
                        "username": "nyck33",
                        "content": "Can I do:\\n(Median of array1 + Median of array2) / 2 ?  In which case I need to know the lengths of array1 and array2 but counting would take O(n+m) on its own.  "
                    },
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] merge = new int[nums1.length + nums2.length];\\n        int i = 0;\\n        for(i = 0; i < nums1.length; i++)\\n            merge[i] = nums1[i];\\n        for(; i - nums1.length < nums2.length; i++)\\n            merge[i] = nums2[i - nums1.length];\\n        Arrays.sort(merge);\\n        return (merge.length) % 2 != 0 ? \\n            (double)merge[merge.length / 2] : (double)(merge[merge.length / 2] + merge[merge.length / 2 - 1]) / 2;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1727974,
                "content": [
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in java, python, c++ and c programming\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "dovbysh",
                        "content": "I sent a solution with time complexity O(log(m+n)). The difference between 3ms and 12ms in one empty string in the code. So, for solutions in Go need more complicated tests."
                    },
                    {
                        "username": "deleted_user",
                        "content": "idk"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// this is one way to solve the problem, but a space on O( m+n) is required here and time complexity in also O(nlog(m+n))\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector< int> a;\\n        for( int  i=0;i< nums1.size();i++){\\n            a.push_back(nums1[i]);\\n        }\\n        for( int  i=0;i< nums2.size();i++){\\n            a.push_back(nums2[i]);\\n        }\\n        sort( a.begin(), a.end());\\n        int l= a.size();\\n        if( l%2==0){\\n            return ( a[l/2]+a[(l/2)-1])/2.0;\\n        }\\n        else{\\n            return a[l/2];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// whye it shows that no viable conversion from returned value of type vector<double> to function return type double\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m= nums2.size();\\n        vector<double>ans(n+m);\\n        int i=0,j=0,k=0;\\n        while( i< min( m,n)){\\n            if( nums1[j]<nums2[k]){\\n                ans[i]=nums1[j];\\n                cout<<ans[i]<<endl;\\n                i++;j++;\\n            }\\n            else{\\n                ans[i]=nums2[k];\\n                cout<<ans[i]<<endl;\\n                i++;k++;\\n            }\\n        }\\n        if ( j==n){ \\n            while(i<m+n)\\n            ans[i]=nums2[k];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            k++;\\n        }\\n         if ( j==m){ \\n            while(i<m+n)\\n            ans[i]=nums1[j];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "imrrai009",
                        "content": "Easiest i could think\\uD83D\\uDE01\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int>v(nums1.size()+nums2.size());\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        merge(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),v.begin());\\n\\n        int low=0;\\n        int high=v.size()-1;\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\n            if(v.size()%2==0)\\n            return  (float)(v[mid]+(v[mid+1]))/2;\\n            else\\n            return (float)v[mid];\\n        }\\n        return -1;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "vipin_tiwari",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    const mergedArry= [...nums1, ...nums2]\\n    const sum= mergedArry.reduce((accum, current)=> accum+ current , 0)\\n    return  sum/mergedArry.length;\\n};\\n\\nIs there anything wrong with this solution?. It\\'s passing both testcases(case1 and case2) but at the time of submitting the code it\\'s showing the \\'wrong Answer\\'. "
                    },
                    {
                        "username": "nyck33",
                        "content": "Can I do:\\n(Median of array1 + Median of array2) / 2 ?  In which case I need to know the lengths of array1 and array2 but counting would take O(n+m) on its own.  "
                    },
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] merge = new int[nums1.length + nums2.length];\\n        int i = 0;\\n        for(i = 0; i < nums1.length; i++)\\n            merge[i] = nums1[i];\\n        for(; i - nums1.length < nums2.length; i++)\\n            merge[i] = nums2[i - nums1.length];\\n        Arrays.sort(merge);\\n        return (merge.length) % 2 != 0 ? \\n            (double)merge[merge.length / 2] : (double)(merge[merge.length / 2] + merge[merge.length / 2 - 1]) / 2;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1725088,
                "content": [
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in java, python, c++ and c programming\\n[https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://thecscience.com/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "dovbysh",
                        "content": "I sent a solution with time complexity O(log(m+n)). The difference between 3ms and 12ms in one empty string in the code. So, for solutions in Go need more complicated tests."
                    },
                    {
                        "username": "deleted_user",
                        "content": "idk"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// this is one way to solve the problem, but a space on O( m+n) is required here and time complexity in also O(nlog(m+n))\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        vector< int> a;\\n        for( int  i=0;i< nums1.size();i++){\\n            a.push_back(nums1[i]);\\n        }\\n        for( int  i=0;i< nums2.size();i++){\\n            a.push_back(nums2[i]);\\n        }\\n        sort( a.begin(), a.end());\\n        int l= a.size();\\n        if( l%2==0){\\n            return ( a[l/2]+a[(l/2)-1])/2.0;\\n        }\\n        else{\\n            return a[l/2];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user4474EC",
                        "content": "// whye it shows that no viable conversion from returned value of type vector<double> to function return type double\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m= nums2.size();\\n        vector<double>ans(n+m);\\n        int i=0,j=0,k=0;\\n        while( i< min( m,n)){\\n            if( nums1[j]<nums2[k]){\\n                ans[i]=nums1[j];\\n                cout<<ans[i]<<endl;\\n                i++;j++;\\n            }\\n            else{\\n                ans[i]=nums2[k];\\n                cout<<ans[i]<<endl;\\n                i++;k++;\\n            }\\n        }\\n        if ( j==n){ \\n            while(i<m+n)\\n            ans[i]=nums2[k];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            k++;\\n        }\\n         if ( j==m){ \\n            while(i<m+n)\\n            ans[i]=nums1[j];\\n            cout<<ans[i]<<endl;\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "imrrai009",
                        "content": "Easiest i could think\\uD83D\\uDE01\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int>v(nums1.size()+nums2.size());\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        merge(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),v.begin());\\n\\n        int low=0;\\n        int high=v.size()-1;\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\n            if(v.size()%2==0)\\n            return  (float)(v[mid]+(v[mid+1]))/2;\\n            else\\n            return (float)v[mid];\\n        }\\n        return -1;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "vipin_tiwari",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    const mergedArry= [...nums1, ...nums2]\\n    const sum= mergedArry.reduce((accum, current)=> accum+ current , 0)\\n    return  sum/mergedArry.length;\\n};\\n\\nIs there anything wrong with this solution?. It\\'s passing both testcases(case1 and case2) but at the time of submitting the code it\\'s showing the \\'wrong Answer\\'. "
                    },
                    {
                        "username": "nyck33",
                        "content": "Can I do:\\n(Median of array1 + Median of array2) / 2 ?  In which case I need to know the lengths of array1 and array2 but counting would take O(n+m) on its own.  "
                    },
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int[] merge = new int[nums1.length + nums2.length];\\n        int i = 0;\\n        for(i = 0; i < nums1.length; i++)\\n            merge[i] = nums1[i];\\n        for(; i - nums1.length < nums2.length; i++)\\n            merge[i] = nums2[i - nums1.length];\\n        Arrays.sort(merge);\\n        return (merge.length) % 2 != 0 ? \\n            (double)merge[merge.length / 2] : (double)(merge[merge.length / 2] + merge[merge.length / 2 - 1]) / 2;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1721895,
                "content": [
                    {
                        "username": "calm27",
                        "content": "if not O(log(n+m)) efficiency requirement it should be a medium problem. "
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Alilqq",
                        "content": "Hi, Im in an 8th grade in an non english speaking country and I don't know at all whats a median, I understand everything else.. please help"
                    },
                    {
                        "username": "doubleshab",
                        "content": "Hi, the median of a sorted array is the value stored in its middle index. For an array of length 3, such as [1, 2, 3], the median is 2 (the value stored in its second index). In this problem, if there is not a middle index because there is an even number of values in the array, then the problem wants you to return the average of the two values in the indices closest to the middle. For an array of length 4, such as [10, 13, 40, 99], the median is (13 + 40)/2 = 26.5 (the average of the two values closest to the middle). Hope this helps!"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "I was trying to solve this question using divide and conquer with nums1 array size  bigger than nums2 array size, but getting wrong answer.\\ncan anyone please explain me why we required to keep first array size lesser or equal to second array size"
                    },
                    {
                        "username": "yasarhike19",
                        "content": "nums1 =\\n[]\\nnums2 =\\n[1]\\nhey anybody tell me what is the median for the arrays."
                    },
                    {
                        "username": "mo3z_52",
                        "content": "Hi I have a simple question : Is it necessary to merge the two arrays (because if not I think it may be solved through if statement) "
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "i am working in amazon\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "best solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1717316,
                "content": [
                    {
                        "username": "calm27",
                        "content": "if not O(log(n+m)) efficiency requirement it should be a medium problem. "
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Alilqq",
                        "content": "Hi, Im in an 8th grade in an non english speaking country and I don't know at all whats a median, I understand everything else.. please help"
                    },
                    {
                        "username": "doubleshab",
                        "content": "Hi, the median of a sorted array is the value stored in its middle index. For an array of length 3, such as [1, 2, 3], the median is 2 (the value stored in its second index). In this problem, if there is not a middle index because there is an even number of values in the array, then the problem wants you to return the average of the two values in the indices closest to the middle. For an array of length 4, such as [10, 13, 40, 99], the median is (13 + 40)/2 = 26.5 (the average of the two values closest to the middle). Hope this helps!"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "I was trying to solve this question using divide and conquer with nums1 array size  bigger than nums2 array size, but getting wrong answer.\\ncan anyone please explain me why we required to keep first array size lesser or equal to second array size"
                    },
                    {
                        "username": "yasarhike19",
                        "content": "nums1 =\\n[]\\nnums2 =\\n[1]\\nhey anybody tell me what is the median for the arrays."
                    },
                    {
                        "username": "mo3z_52",
                        "content": "Hi I have a simple question : Is it necessary to merge the two arrays (because if not I think it may be solved through if statement) "
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "i am working in amazon\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "best solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1717313,
                "content": [
                    {
                        "username": "calm27",
                        "content": "if not O(log(n+m)) efficiency requirement it should be a medium problem. "
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Alilqq",
                        "content": "Hi, Im in an 8th grade in an non english speaking country and I don't know at all whats a median, I understand everything else.. please help"
                    },
                    {
                        "username": "doubleshab",
                        "content": "Hi, the median of a sorted array is the value stored in its middle index. For an array of length 3, such as [1, 2, 3], the median is 2 (the value stored in its second index). In this problem, if there is not a middle index because there is an even number of values in the array, then the problem wants you to return the average of the two values in the indices closest to the middle. For an array of length 4, such as [10, 13, 40, 99], the median is (13 + 40)/2 = 26.5 (the average of the two values closest to the middle). Hope this helps!"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "I was trying to solve this question using divide and conquer with nums1 array size  bigger than nums2 array size, but getting wrong answer.\\ncan anyone please explain me why we required to keep first array size lesser or equal to second array size"
                    },
                    {
                        "username": "yasarhike19",
                        "content": "nums1 =\\n[]\\nnums2 =\\n[1]\\nhey anybody tell me what is the median for the arrays."
                    },
                    {
                        "username": "mo3z_52",
                        "content": "Hi I have a simple question : Is it necessary to merge the two arrays (because if not I think it may be solved through if statement) "
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "i am working in amazon\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "best solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1717311,
                "content": [
                    {
                        "username": "calm27",
                        "content": "if not O(log(n+m)) efficiency requirement it should be a medium problem. "
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Alilqq",
                        "content": "Hi, Im in an 8th grade in an non english speaking country and I don't know at all whats a median, I understand everything else.. please help"
                    },
                    {
                        "username": "doubleshab",
                        "content": "Hi, the median of a sorted array is the value stored in its middle index. For an array of length 3, such as [1, 2, 3], the median is 2 (the value stored in its second index). In this problem, if there is not a middle index because there is an even number of values in the array, then the problem wants you to return the average of the two values in the indices closest to the middle. For an array of length 4, such as [10, 13, 40, 99], the median is (13 + 40)/2 = 26.5 (the average of the two values closest to the middle). Hope this helps!"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "I was trying to solve this question using divide and conquer with nums1 array size  bigger than nums2 array size, but getting wrong answer.\\ncan anyone please explain me why we required to keep first array size lesser or equal to second array size"
                    },
                    {
                        "username": "yasarhike19",
                        "content": "nums1 =\\n[]\\nnums2 =\\n[1]\\nhey anybody tell me what is the median for the arrays."
                    },
                    {
                        "username": "mo3z_52",
                        "content": "Hi I have a simple question : Is it necessary to merge the two arrays (because if not I think it may be solved through if statement) "
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "i am working in amazon\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "best solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1713688,
                "content": [
                    {
                        "username": "calm27",
                        "content": "if not O(log(n+m)) efficiency requirement it should be a medium problem. "
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Alilqq",
                        "content": "Hi, Im in an 8th grade in an non english speaking country and I don't know at all whats a median, I understand everything else.. please help"
                    },
                    {
                        "username": "doubleshab",
                        "content": "Hi, the median of a sorted array is the value stored in its middle index. For an array of length 3, such as [1, 2, 3], the median is 2 (the value stored in its second index). In this problem, if there is not a middle index because there is an even number of values in the array, then the problem wants you to return the average of the two values in the indices closest to the middle. For an array of length 4, such as [10, 13, 40, 99], the median is (13 + 40)/2 = 26.5 (the average of the two values closest to the middle). Hope this helps!"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "I was trying to solve this question using divide and conquer with nums1 array size  bigger than nums2 array size, but getting wrong answer.\\ncan anyone please explain me why we required to keep first array size lesser or equal to second array size"
                    },
                    {
                        "username": "yasarhike19",
                        "content": "nums1 =\\n[]\\nnums2 =\\n[1]\\nhey anybody tell me what is the median for the arrays."
                    },
                    {
                        "username": "mo3z_52",
                        "content": "Hi I have a simple question : Is it necessary to merge the two arrays (because if not I think it may be solved through if statement) "
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "i am working in amazon\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "best solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1713162,
                "content": [
                    {
                        "username": "calm27",
                        "content": "if not O(log(n+m)) efficiency requirement it should be a medium problem. "
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Alilqq",
                        "content": "Hi, Im in an 8th grade in an non english speaking country and I don't know at all whats a median, I understand everything else.. please help"
                    },
                    {
                        "username": "doubleshab",
                        "content": "Hi, the median of a sorted array is the value stored in its middle index. For an array of length 3, such as [1, 2, 3], the median is 2 (the value stored in its second index). In this problem, if there is not a middle index because there is an even number of values in the array, then the problem wants you to return the average of the two values in the indices closest to the middle. For an array of length 4, such as [10, 13, 40, 99], the median is (13 + 40)/2 = 26.5 (the average of the two values closest to the middle). Hope this helps!"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "I was trying to solve this question using divide and conquer with nums1 array size  bigger than nums2 array size, but getting wrong answer.\\ncan anyone please explain me why we required to keep first array size lesser or equal to second array size"
                    },
                    {
                        "username": "yasarhike19",
                        "content": "nums1 =\\n[]\\nnums2 =\\n[1]\\nhey anybody tell me what is the median for the arrays."
                    },
                    {
                        "username": "mo3z_52",
                        "content": "Hi I have a simple question : Is it necessary to merge the two arrays (because if not I think it may be solved through if statement) "
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "i am working in amazon\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "best solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1711042,
                "content": [
                    {
                        "username": "calm27",
                        "content": "if not O(log(n+m)) efficiency requirement it should be a medium problem. "
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Alilqq",
                        "content": "Hi, Im in an 8th grade in an non english speaking country and I don't know at all whats a median, I understand everything else.. please help"
                    },
                    {
                        "username": "doubleshab",
                        "content": "Hi, the median of a sorted array is the value stored in its middle index. For an array of length 3, such as [1, 2, 3], the median is 2 (the value stored in its second index). In this problem, if there is not a middle index because there is an even number of values in the array, then the problem wants you to return the average of the two values in the indices closest to the middle. For an array of length 4, such as [10, 13, 40, 99], the median is (13 + 40)/2 = 26.5 (the average of the two values closest to the middle). Hope this helps!"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "I was trying to solve this question using divide and conquer with nums1 array size  bigger than nums2 array size, but getting wrong answer.\\ncan anyone please explain me why we required to keep first array size lesser or equal to second array size"
                    },
                    {
                        "username": "yasarhike19",
                        "content": "nums1 =\\n[]\\nnums2 =\\n[1]\\nhey anybody tell me what is the median for the arrays."
                    },
                    {
                        "username": "mo3z_52",
                        "content": "Hi I have a simple question : Is it necessary to merge the two arrays (because if not I think it may be solved through if statement) "
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "i am working in amazon\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "best solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1709787,
                "content": [
                    {
                        "username": "calm27",
                        "content": "if not O(log(n+m)) efficiency requirement it should be a medium problem. "
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Alilqq",
                        "content": "Hi, Im in an 8th grade in an non english speaking country and I don't know at all whats a median, I understand everything else.. please help"
                    },
                    {
                        "username": "doubleshab",
                        "content": "Hi, the median of a sorted array is the value stored in its middle index. For an array of length 3, such as [1, 2, 3], the median is 2 (the value stored in its second index). In this problem, if there is not a middle index because there is an even number of values in the array, then the problem wants you to return the average of the two values in the indices closest to the middle. For an array of length 4, such as [10, 13, 40, 99], the median is (13 + 40)/2 = 26.5 (the average of the two values closest to the middle). Hope this helps!"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "I was trying to solve this question using divide and conquer with nums1 array size  bigger than nums2 array size, but getting wrong answer.\\ncan anyone please explain me why we required to keep first array size lesser or equal to second array size"
                    },
                    {
                        "username": "yasarhike19",
                        "content": "nums1 =\\n[]\\nnums2 =\\n[1]\\nhey anybody tell me what is the median for the arrays."
                    },
                    {
                        "username": "mo3z_52",
                        "content": "Hi I have a simple question : Is it necessary to merge the two arrays (because if not I think it may be solved through if statement) "
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "i am working in amazon\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "best solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1709613,
                "content": [
                    {
                        "username": "calm27",
                        "content": "if not O(log(n+m)) efficiency requirement it should be a medium problem. "
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Alilqq",
                        "content": "Hi, Im in an 8th grade in an non english speaking country and I don't know at all whats a median, I understand everything else.. please help"
                    },
                    {
                        "username": "doubleshab",
                        "content": "Hi, the median of a sorted array is the value stored in its middle index. For an array of length 3, such as [1, 2, 3], the median is 2 (the value stored in its second index). In this problem, if there is not a middle index because there is an even number of values in the array, then the problem wants you to return the average of the two values in the indices closest to the middle. For an array of length 4, such as [10, 13, 40, 99], the median is (13 + 40)/2 = 26.5 (the average of the two values closest to the middle). Hope this helps!"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "I was trying to solve this question using divide and conquer with nums1 array size  bigger than nums2 array size, but getting wrong answer.\\ncan anyone please explain me why we required to keep first array size lesser or equal to second array size"
                    },
                    {
                        "username": "yasarhike19",
                        "content": "nums1 =\\n[]\\nnums2 =\\n[1]\\nhey anybody tell me what is the median for the arrays."
                    },
                    {
                        "username": "mo3z_52",
                        "content": "Hi I have a simple question : Is it necessary to merge the two arrays (because if not I think it may be solved through if statement) "
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "i am working in amazon\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "best solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1709612,
                "content": [
                    {
                        "username": "calm27",
                        "content": "if not O(log(n+m)) efficiency requirement it should be a medium problem. "
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "   public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        double d=0.0f;\\n        int fal = nums1.length;      \\n        int sal = nums2.length; \\n        int[] result = new int[fal + sal]; \\n        System.arraycopy(nums1, 0, result, 0, fal);  \\n        System.arraycopy(nums2, 0, result, fal, sal);  \\n        Arrays.sort(result);\\n        if(result.length % 2 == 0){\\n           d=(result[result.length/2] + result[(result.length/2)-1])/2.0;\\n           return d;\\n        }else{\\n           return result[(result.length - 1)/2];\\n        }\\n     }"
                    },
                    {
                        "username": "Alilqq",
                        "content": "Hi, Im in an 8th grade in an non english speaking country and I don't know at all whats a median, I understand everything else.. please help"
                    },
                    {
                        "username": "doubleshab",
                        "content": "Hi, the median of a sorted array is the value stored in its middle index. For an array of length 3, such as [1, 2, 3], the median is 2 (the value stored in its second index). In this problem, if there is not a middle index because there is an even number of values in the array, then the problem wants you to return the average of the two values in the indices closest to the middle. For an array of length 4, such as [10, 13, 40, 99], the median is (13 + 40)/2 = 26.5 (the average of the two values closest to the middle). Hope this helps!"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "I was trying to solve this question using divide and conquer with nums1 array size  bigger than nums2 array size, but getting wrong answer.\\ncan anyone please explain me why we required to keep first array size lesser or equal to second array size"
                    },
                    {
                        "username": "yasarhike19",
                        "content": "nums1 =\\n[]\\nnums2 =\\n[1]\\nhey anybody tell me what is the median for the arrays."
                    },
                    {
                        "username": "mo3z_52",
                        "content": "Hi I have a simple question : Is it necessary to merge the two arrays (because if not I think it may be solved through if statement) "
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "i am working in amazon\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "best solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1709611,
                "content": [
                    {
                        "username": "lznpgxn809",
                        "content": "solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "luzede",
                        "content": "When I see stuff like  `O(logn)` complexity, my mind goes to Binary Search and Binary Search Tree. Since those two are the ones I was taught at the University. Also I was taught MergeSort which is of `O(nlogn)` complexity. I don\\'t really remember how MergeSort is done but I think it has to do with that, since the two arrays are already sorted and for a merge to take place, two arrays must be sorted from the start. I think the Merging is of `O(n)` complexity so maybe instead of Merging, you need a different approach, something much smarter. I am certain this will at some point need to use Binary Search.\\n\\nIf one does not know of Binary Search I think, he is not going to solve this. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How is this the hardest question on leetcode let alone a leetcode hard?  I have found leetcode easies harder than this question.  I went to sort leetcode questions be difficulty to see what the hardest question was and this came up.  This question should be reclassified as a leetcode easy."
                    },
                    {
                        "username": "anurag-k",
                        "content": "can someone explain how the time complexity of the binary search (partitioning) solution comes out as log (m+n)?"
                    },
                    {
                        "username": "jbagani",
                        "content": "It is even accepting O((M+N) log(M+N)) solutions"
                    },
                    {
                        "username": "user2579pD",
                        "content": "actually solution has O( log( min(n, m) ) )"
                    },
                    {
                        "username": "user7363Ra",
                        "content": "Can someone tell me why the below solution doesn\\'t work for input -- nums1 = [2] && nums2 = []. ?\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        if(n1 > n2)\\n        {\\n            findMedianSortedArrays(nums2, nums1);\\n        }\\n        int low = 0, high = n1;\\n        int noOfElements = (n1+n2+1)/2;\\n        while(low<=high)\\n        {\\n            int cut1 = (low+high)/2;\\n            int cut2 = noOfElements - cut1;\\n\\n            int l1 = cut1 == 0 ?  INT_MIN : nums1[cut1-1];\\n            int l2 = cut2 ==  0 ? INT_MIN : nums2[cut2-1] ;\\n            int r1 = cut1 == n1 ? INT_MAX : nums1[cut1] ;\\n            int r2 = cut2 == n2 ? INT_MAX : nums2[cut2] ;\\n            \\n            if(l1<=r2 && l2<=r1)\\n            {\\n                if((n1+n2)%2 == 0)\\n                {\\n                    return (max(l1,l2)+ min(r1,r2))/2.0;\\n                }\\n                else{\\n                    return max(l1,l2)/1.0;\\n                }\\n            }\\n            else if(l1 > r2)\\n            {\\n                high = cut1 - 1;\\n            }\\n            else\\n            {\\n                low = cut1 + 1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "hassanharoon321",
                        "content": "Simple solution understanding by reading\\n\\nFirst understand median. There are 2 cases \\n1) First for odd\\n2) Second for even\\n\\nstep1: merge both array and sort them\\n\\nstep2: for even case, divide length of an array by 2 then just return it by numArr[i] or numArr[i-1] also divide it by 2\\n\\nstep 3: for odd case, Math.ceil(numArr.length / 2) then return it by array index -1\\n\\n"
                    },
                    {
                        "username": "project101studio",
                        "content": "I\\'m trying to divided by two and it returns me the entire part only.\\nFor example, 5/2 = 2.0000\\n:("
                    }
                ]
            },
            {
                "id": 1709610,
                "content": [
                    {
                        "username": "lznpgxn809",
                        "content": "solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "luzede",
                        "content": "When I see stuff like  `O(logn)` complexity, my mind goes to Binary Search and Binary Search Tree. Since those two are the ones I was taught at the University. Also I was taught MergeSort which is of `O(nlogn)` complexity. I don\\'t really remember how MergeSort is done but I think it has to do with that, since the two arrays are already sorted and for a merge to take place, two arrays must be sorted from the start. I think the Merging is of `O(n)` complexity so maybe instead of Merging, you need a different approach, something much smarter. I am certain this will at some point need to use Binary Search.\\n\\nIf one does not know of Binary Search I think, he is not going to solve this. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How is this the hardest question on leetcode let alone a leetcode hard?  I have found leetcode easies harder than this question.  I went to sort leetcode questions be difficulty to see what the hardest question was and this came up.  This question should be reclassified as a leetcode easy."
                    },
                    {
                        "username": "anurag-k",
                        "content": "can someone explain how the time complexity of the binary search (partitioning) solution comes out as log (m+n)?"
                    },
                    {
                        "username": "jbagani",
                        "content": "It is even accepting O((M+N) log(M+N)) solutions"
                    },
                    {
                        "username": "user2579pD",
                        "content": "actually solution has O( log( min(n, m) ) )"
                    },
                    {
                        "username": "user7363Ra",
                        "content": "Can someone tell me why the below solution doesn\\'t work for input -- nums1 = [2] && nums2 = []. ?\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        if(n1 > n2)\\n        {\\n            findMedianSortedArrays(nums2, nums1);\\n        }\\n        int low = 0, high = n1;\\n        int noOfElements = (n1+n2+1)/2;\\n        while(low<=high)\\n        {\\n            int cut1 = (low+high)/2;\\n            int cut2 = noOfElements - cut1;\\n\\n            int l1 = cut1 == 0 ?  INT_MIN : nums1[cut1-1];\\n            int l2 = cut2 ==  0 ? INT_MIN : nums2[cut2-1] ;\\n            int r1 = cut1 == n1 ? INT_MAX : nums1[cut1] ;\\n            int r2 = cut2 == n2 ? INT_MAX : nums2[cut2] ;\\n            \\n            if(l1<=r2 && l2<=r1)\\n            {\\n                if((n1+n2)%2 == 0)\\n                {\\n                    return (max(l1,l2)+ min(r1,r2))/2.0;\\n                }\\n                else{\\n                    return max(l1,l2)/1.0;\\n                }\\n            }\\n            else if(l1 > r2)\\n            {\\n                high = cut1 - 1;\\n            }\\n            else\\n            {\\n                low = cut1 + 1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "hassanharoon321",
                        "content": "Simple solution understanding by reading\\n\\nFirst understand median. There are 2 cases \\n1) First for odd\\n2) Second for even\\n\\nstep1: merge both array and sort them\\n\\nstep2: for even case, divide length of an array by 2 then just return it by numArr[i] or numArr[i-1] also divide it by 2\\n\\nstep 3: for odd case, Math.ceil(numArr.length / 2) then return it by array index -1\\n\\n"
                    },
                    {
                        "username": "project101studio",
                        "content": "I\\'m trying to divided by two and it returns me the entire part only.\\nFor example, 5/2 = 2.0000\\n:("
                    }
                ]
            },
            {
                "id": 1701935,
                "content": [
                    {
                        "username": "lznpgxn809",
                        "content": "solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "luzede",
                        "content": "When I see stuff like  `O(logn)` complexity, my mind goes to Binary Search and Binary Search Tree. Since those two are the ones I was taught at the University. Also I was taught MergeSort which is of `O(nlogn)` complexity. I don\\'t really remember how MergeSort is done but I think it has to do with that, since the two arrays are already sorted and for a merge to take place, two arrays must be sorted from the start. I think the Merging is of `O(n)` complexity so maybe instead of Merging, you need a different approach, something much smarter. I am certain this will at some point need to use Binary Search.\\n\\nIf one does not know of Binary Search I think, he is not going to solve this. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How is this the hardest question on leetcode let alone a leetcode hard?  I have found leetcode easies harder than this question.  I went to sort leetcode questions be difficulty to see what the hardest question was and this came up.  This question should be reclassified as a leetcode easy."
                    },
                    {
                        "username": "anurag-k",
                        "content": "can someone explain how the time complexity of the binary search (partitioning) solution comes out as log (m+n)?"
                    },
                    {
                        "username": "jbagani",
                        "content": "It is even accepting O((M+N) log(M+N)) solutions"
                    },
                    {
                        "username": "user2579pD",
                        "content": "actually solution has O( log( min(n, m) ) )"
                    },
                    {
                        "username": "user7363Ra",
                        "content": "Can someone tell me why the below solution doesn\\'t work for input -- nums1 = [2] && nums2 = []. ?\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        if(n1 > n2)\\n        {\\n            findMedianSortedArrays(nums2, nums1);\\n        }\\n        int low = 0, high = n1;\\n        int noOfElements = (n1+n2+1)/2;\\n        while(low<=high)\\n        {\\n            int cut1 = (low+high)/2;\\n            int cut2 = noOfElements - cut1;\\n\\n            int l1 = cut1 == 0 ?  INT_MIN : nums1[cut1-1];\\n            int l2 = cut2 ==  0 ? INT_MIN : nums2[cut2-1] ;\\n            int r1 = cut1 == n1 ? INT_MAX : nums1[cut1] ;\\n            int r2 = cut2 == n2 ? INT_MAX : nums2[cut2] ;\\n            \\n            if(l1<=r2 && l2<=r1)\\n            {\\n                if((n1+n2)%2 == 0)\\n                {\\n                    return (max(l1,l2)+ min(r1,r2))/2.0;\\n                }\\n                else{\\n                    return max(l1,l2)/1.0;\\n                }\\n            }\\n            else if(l1 > r2)\\n            {\\n                high = cut1 - 1;\\n            }\\n            else\\n            {\\n                low = cut1 + 1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "hassanharoon321",
                        "content": "Simple solution understanding by reading\\n\\nFirst understand median. There are 2 cases \\n1) First for odd\\n2) Second for even\\n\\nstep1: merge both array and sort them\\n\\nstep2: for even case, divide length of an array by 2 then just return it by numArr[i] or numArr[i-1] also divide it by 2\\n\\nstep 3: for odd case, Math.ceil(numArr.length / 2) then return it by array index -1\\n\\n"
                    },
                    {
                        "username": "project101studio",
                        "content": "I\\'m trying to divided by two and it returns me the entire part only.\\nFor example, 5/2 = 2.0000\\n:("
                    }
                ]
            },
            {
                "id": 1701584,
                "content": [
                    {
                        "username": "lznpgxn809",
                        "content": "solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "luzede",
                        "content": "When I see stuff like  `O(logn)` complexity, my mind goes to Binary Search and Binary Search Tree. Since those two are the ones I was taught at the University. Also I was taught MergeSort which is of `O(nlogn)` complexity. I don\\'t really remember how MergeSort is done but I think it has to do with that, since the two arrays are already sorted and for a merge to take place, two arrays must be sorted from the start. I think the Merging is of `O(n)` complexity so maybe instead of Merging, you need a different approach, something much smarter. I am certain this will at some point need to use Binary Search.\\n\\nIf one does not know of Binary Search I think, he is not going to solve this. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How is this the hardest question on leetcode let alone a leetcode hard?  I have found leetcode easies harder than this question.  I went to sort leetcode questions be difficulty to see what the hardest question was and this came up.  This question should be reclassified as a leetcode easy."
                    },
                    {
                        "username": "anurag-k",
                        "content": "can someone explain how the time complexity of the binary search (partitioning) solution comes out as log (m+n)?"
                    },
                    {
                        "username": "jbagani",
                        "content": "It is even accepting O((M+N) log(M+N)) solutions"
                    },
                    {
                        "username": "user2579pD",
                        "content": "actually solution has O( log( min(n, m) ) )"
                    },
                    {
                        "username": "user7363Ra",
                        "content": "Can someone tell me why the below solution doesn\\'t work for input -- nums1 = [2] && nums2 = []. ?\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        if(n1 > n2)\\n        {\\n            findMedianSortedArrays(nums2, nums1);\\n        }\\n        int low = 0, high = n1;\\n        int noOfElements = (n1+n2+1)/2;\\n        while(low<=high)\\n        {\\n            int cut1 = (low+high)/2;\\n            int cut2 = noOfElements - cut1;\\n\\n            int l1 = cut1 == 0 ?  INT_MIN : nums1[cut1-1];\\n            int l2 = cut2 ==  0 ? INT_MIN : nums2[cut2-1] ;\\n            int r1 = cut1 == n1 ? INT_MAX : nums1[cut1] ;\\n            int r2 = cut2 == n2 ? INT_MAX : nums2[cut2] ;\\n            \\n            if(l1<=r2 && l2<=r1)\\n            {\\n                if((n1+n2)%2 == 0)\\n                {\\n                    return (max(l1,l2)+ min(r1,r2))/2.0;\\n                }\\n                else{\\n                    return max(l1,l2)/1.0;\\n                }\\n            }\\n            else if(l1 > r2)\\n            {\\n                high = cut1 - 1;\\n            }\\n            else\\n            {\\n                low = cut1 + 1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "hassanharoon321",
                        "content": "Simple solution understanding by reading\\n\\nFirst understand median. There are 2 cases \\n1) First for odd\\n2) Second for even\\n\\nstep1: merge both array and sort them\\n\\nstep2: for even case, divide length of an array by 2 then just return it by numArr[i] or numArr[i-1] also divide it by 2\\n\\nstep 3: for odd case, Math.ceil(numArr.length / 2) then return it by array index -1\\n\\n"
                    },
                    {
                        "username": "project101studio",
                        "content": "I\\'m trying to divided by two and it returns me the entire part only.\\nFor example, 5/2 = 2.0000\\n:("
                    }
                ]
            },
            {
                "id": 1693685,
                "content": [
                    {
                        "username": "lznpgxn809",
                        "content": "solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "luzede",
                        "content": "When I see stuff like  `O(logn)` complexity, my mind goes to Binary Search and Binary Search Tree. Since those two are the ones I was taught at the University. Also I was taught MergeSort which is of `O(nlogn)` complexity. I don\\'t really remember how MergeSort is done but I think it has to do with that, since the two arrays are already sorted and for a merge to take place, two arrays must be sorted from the start. I think the Merging is of `O(n)` complexity so maybe instead of Merging, you need a different approach, something much smarter. I am certain this will at some point need to use Binary Search.\\n\\nIf one does not know of Binary Search I think, he is not going to solve this. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How is this the hardest question on leetcode let alone a leetcode hard?  I have found leetcode easies harder than this question.  I went to sort leetcode questions be difficulty to see what the hardest question was and this came up.  This question should be reclassified as a leetcode easy."
                    },
                    {
                        "username": "anurag-k",
                        "content": "can someone explain how the time complexity of the binary search (partitioning) solution comes out as log (m+n)?"
                    },
                    {
                        "username": "jbagani",
                        "content": "It is even accepting O((M+N) log(M+N)) solutions"
                    },
                    {
                        "username": "user2579pD",
                        "content": "actually solution has O( log( min(n, m) ) )"
                    },
                    {
                        "username": "user7363Ra",
                        "content": "Can someone tell me why the below solution doesn\\'t work for input -- nums1 = [2] && nums2 = []. ?\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        if(n1 > n2)\\n        {\\n            findMedianSortedArrays(nums2, nums1);\\n        }\\n        int low = 0, high = n1;\\n        int noOfElements = (n1+n2+1)/2;\\n        while(low<=high)\\n        {\\n            int cut1 = (low+high)/2;\\n            int cut2 = noOfElements - cut1;\\n\\n            int l1 = cut1 == 0 ?  INT_MIN : nums1[cut1-1];\\n            int l2 = cut2 ==  0 ? INT_MIN : nums2[cut2-1] ;\\n            int r1 = cut1 == n1 ? INT_MAX : nums1[cut1] ;\\n            int r2 = cut2 == n2 ? INT_MAX : nums2[cut2] ;\\n            \\n            if(l1<=r2 && l2<=r1)\\n            {\\n                if((n1+n2)%2 == 0)\\n                {\\n                    return (max(l1,l2)+ min(r1,r2))/2.0;\\n                }\\n                else{\\n                    return max(l1,l2)/1.0;\\n                }\\n            }\\n            else if(l1 > r2)\\n            {\\n                high = cut1 - 1;\\n            }\\n            else\\n            {\\n                low = cut1 + 1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "hassanharoon321",
                        "content": "Simple solution understanding by reading\\n\\nFirst understand median. There are 2 cases \\n1) First for odd\\n2) Second for even\\n\\nstep1: merge both array and sort them\\n\\nstep2: for even case, divide length of an array by 2 then just return it by numArr[i] or numArr[i-1] also divide it by 2\\n\\nstep 3: for odd case, Math.ceil(numArr.length / 2) then return it by array index -1\\n\\n"
                    },
                    {
                        "username": "project101studio",
                        "content": "I\\'m trying to divided by two and it returns me the entire part only.\\nFor example, 5/2 = 2.0000\\n:("
                    }
                ]
            },
            {
                "id": 1691787,
                "content": [
                    {
                        "username": "lznpgxn809",
                        "content": "solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "luzede",
                        "content": "When I see stuff like  `O(logn)` complexity, my mind goes to Binary Search and Binary Search Tree. Since those two are the ones I was taught at the University. Also I was taught MergeSort which is of `O(nlogn)` complexity. I don\\'t really remember how MergeSort is done but I think it has to do with that, since the two arrays are already sorted and for a merge to take place, two arrays must be sorted from the start. I think the Merging is of `O(n)` complexity so maybe instead of Merging, you need a different approach, something much smarter. I am certain this will at some point need to use Binary Search.\\n\\nIf one does not know of Binary Search I think, he is not going to solve this. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How is this the hardest question on leetcode let alone a leetcode hard?  I have found leetcode easies harder than this question.  I went to sort leetcode questions be difficulty to see what the hardest question was and this came up.  This question should be reclassified as a leetcode easy."
                    },
                    {
                        "username": "anurag-k",
                        "content": "can someone explain how the time complexity of the binary search (partitioning) solution comes out as log (m+n)?"
                    },
                    {
                        "username": "jbagani",
                        "content": "It is even accepting O((M+N) log(M+N)) solutions"
                    },
                    {
                        "username": "user2579pD",
                        "content": "actually solution has O( log( min(n, m) ) )"
                    },
                    {
                        "username": "user7363Ra",
                        "content": "Can someone tell me why the below solution doesn\\'t work for input -- nums1 = [2] && nums2 = []. ?\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        if(n1 > n2)\\n        {\\n            findMedianSortedArrays(nums2, nums1);\\n        }\\n        int low = 0, high = n1;\\n        int noOfElements = (n1+n2+1)/2;\\n        while(low<=high)\\n        {\\n            int cut1 = (low+high)/2;\\n            int cut2 = noOfElements - cut1;\\n\\n            int l1 = cut1 == 0 ?  INT_MIN : nums1[cut1-1];\\n            int l2 = cut2 ==  0 ? INT_MIN : nums2[cut2-1] ;\\n            int r1 = cut1 == n1 ? INT_MAX : nums1[cut1] ;\\n            int r2 = cut2 == n2 ? INT_MAX : nums2[cut2] ;\\n            \\n            if(l1<=r2 && l2<=r1)\\n            {\\n                if((n1+n2)%2 == 0)\\n                {\\n                    return (max(l1,l2)+ min(r1,r2))/2.0;\\n                }\\n                else{\\n                    return max(l1,l2)/1.0;\\n                }\\n            }\\n            else if(l1 > r2)\\n            {\\n                high = cut1 - 1;\\n            }\\n            else\\n            {\\n                low = cut1 + 1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "hassanharoon321",
                        "content": "Simple solution understanding by reading\\n\\nFirst understand median. There are 2 cases \\n1) First for odd\\n2) Second for even\\n\\nstep1: merge both array and sort them\\n\\nstep2: for even case, divide length of an array by 2 then just return it by numArr[i] or numArr[i-1] also divide it by 2\\n\\nstep 3: for odd case, Math.ceil(numArr.length / 2) then return it by array index -1\\n\\n"
                    },
                    {
                        "username": "project101studio",
                        "content": "I\\'m trying to divided by two and it returns me the entire part only.\\nFor example, 5/2 = 2.0000\\n:("
                    }
                ]
            },
            {
                "id": 1686014,
                "content": [
                    {
                        "username": "lznpgxn809",
                        "content": "solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "luzede",
                        "content": "When I see stuff like  `O(logn)` complexity, my mind goes to Binary Search and Binary Search Tree. Since those two are the ones I was taught at the University. Also I was taught MergeSort which is of `O(nlogn)` complexity. I don\\'t really remember how MergeSort is done but I think it has to do with that, since the two arrays are already sorted and for a merge to take place, two arrays must be sorted from the start. I think the Merging is of `O(n)` complexity so maybe instead of Merging, you need a different approach, something much smarter. I am certain this will at some point need to use Binary Search.\\n\\nIf one does not know of Binary Search I think, he is not going to solve this. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How is this the hardest question on leetcode let alone a leetcode hard?  I have found leetcode easies harder than this question.  I went to sort leetcode questions be difficulty to see what the hardest question was and this came up.  This question should be reclassified as a leetcode easy."
                    },
                    {
                        "username": "anurag-k",
                        "content": "can someone explain how the time complexity of the binary search (partitioning) solution comes out as log (m+n)?"
                    },
                    {
                        "username": "jbagani",
                        "content": "It is even accepting O((M+N) log(M+N)) solutions"
                    },
                    {
                        "username": "user2579pD",
                        "content": "actually solution has O( log( min(n, m) ) )"
                    },
                    {
                        "username": "user7363Ra",
                        "content": "Can someone tell me why the below solution doesn\\'t work for input -- nums1 = [2] && nums2 = []. ?\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        if(n1 > n2)\\n        {\\n            findMedianSortedArrays(nums2, nums1);\\n        }\\n        int low = 0, high = n1;\\n        int noOfElements = (n1+n2+1)/2;\\n        while(low<=high)\\n        {\\n            int cut1 = (low+high)/2;\\n            int cut2 = noOfElements - cut1;\\n\\n            int l1 = cut1 == 0 ?  INT_MIN : nums1[cut1-1];\\n            int l2 = cut2 ==  0 ? INT_MIN : nums2[cut2-1] ;\\n            int r1 = cut1 == n1 ? INT_MAX : nums1[cut1] ;\\n            int r2 = cut2 == n2 ? INT_MAX : nums2[cut2] ;\\n            \\n            if(l1<=r2 && l2<=r1)\\n            {\\n                if((n1+n2)%2 == 0)\\n                {\\n                    return (max(l1,l2)+ min(r1,r2))/2.0;\\n                }\\n                else{\\n                    return max(l1,l2)/1.0;\\n                }\\n            }\\n            else if(l1 > r2)\\n            {\\n                high = cut1 - 1;\\n            }\\n            else\\n            {\\n                low = cut1 + 1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "hassanharoon321",
                        "content": "Simple solution understanding by reading\\n\\nFirst understand median. There are 2 cases \\n1) First for odd\\n2) Second for even\\n\\nstep1: merge both array and sort them\\n\\nstep2: for even case, divide length of an array by 2 then just return it by numArr[i] or numArr[i-1] also divide it by 2\\n\\nstep 3: for odd case, Math.ceil(numArr.length / 2) then return it by array index -1\\n\\n"
                    },
                    {
                        "username": "project101studio",
                        "content": "I\\'m trying to divided by two and it returns me the entire part only.\\nFor example, 5/2 = 2.0000\\n:("
                    }
                ]
            },
            {
                "id": 1680197,
                "content": [
                    {
                        "username": "lznpgxn809",
                        "content": "solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "luzede",
                        "content": "When I see stuff like  `O(logn)` complexity, my mind goes to Binary Search and Binary Search Tree. Since those two are the ones I was taught at the University. Also I was taught MergeSort which is of `O(nlogn)` complexity. I don\\'t really remember how MergeSort is done but I think it has to do with that, since the two arrays are already sorted and for a merge to take place, two arrays must be sorted from the start. I think the Merging is of `O(n)` complexity so maybe instead of Merging, you need a different approach, something much smarter. I am certain this will at some point need to use Binary Search.\\n\\nIf one does not know of Binary Search I think, he is not going to solve this. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How is this the hardest question on leetcode let alone a leetcode hard?  I have found leetcode easies harder than this question.  I went to sort leetcode questions be difficulty to see what the hardest question was and this came up.  This question should be reclassified as a leetcode easy."
                    },
                    {
                        "username": "anurag-k",
                        "content": "can someone explain how the time complexity of the binary search (partitioning) solution comes out as log (m+n)?"
                    },
                    {
                        "username": "jbagani",
                        "content": "It is even accepting O((M+N) log(M+N)) solutions"
                    },
                    {
                        "username": "user2579pD",
                        "content": "actually solution has O( log( min(n, m) ) )"
                    },
                    {
                        "username": "user7363Ra",
                        "content": "Can someone tell me why the below solution doesn\\'t work for input -- nums1 = [2] && nums2 = []. ?\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        if(n1 > n2)\\n        {\\n            findMedianSortedArrays(nums2, nums1);\\n        }\\n        int low = 0, high = n1;\\n        int noOfElements = (n1+n2+1)/2;\\n        while(low<=high)\\n        {\\n            int cut1 = (low+high)/2;\\n            int cut2 = noOfElements - cut1;\\n\\n            int l1 = cut1 == 0 ?  INT_MIN : nums1[cut1-1];\\n            int l2 = cut2 ==  0 ? INT_MIN : nums2[cut2-1] ;\\n            int r1 = cut1 == n1 ? INT_MAX : nums1[cut1] ;\\n            int r2 = cut2 == n2 ? INT_MAX : nums2[cut2] ;\\n            \\n            if(l1<=r2 && l2<=r1)\\n            {\\n                if((n1+n2)%2 == 0)\\n                {\\n                    return (max(l1,l2)+ min(r1,r2))/2.0;\\n                }\\n                else{\\n                    return max(l1,l2)/1.0;\\n                }\\n            }\\n            else if(l1 > r2)\\n            {\\n                high = cut1 - 1;\\n            }\\n            else\\n            {\\n                low = cut1 + 1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "hassanharoon321",
                        "content": "Simple solution understanding by reading\\n\\nFirst understand median. There are 2 cases \\n1) First for odd\\n2) Second for even\\n\\nstep1: merge both array and sort them\\n\\nstep2: for even case, divide length of an array by 2 then just return it by numArr[i] or numArr[i-1] also divide it by 2\\n\\nstep 3: for odd case, Math.ceil(numArr.length / 2) then return it by array index -1\\n\\n"
                    },
                    {
                        "username": "project101studio",
                        "content": "I\\'m trying to divided by two and it returns me the entire part only.\\nFor example, 5/2 = 2.0000\\n:("
                    }
                ]
            },
            {
                "id": 1678765,
                "content": [
                    {
                        "username": "lznpgxn809",
                        "content": "solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "luzede",
                        "content": "When I see stuff like  `O(logn)` complexity, my mind goes to Binary Search and Binary Search Tree. Since those two are the ones I was taught at the University. Also I was taught MergeSort which is of `O(nlogn)` complexity. I don\\'t really remember how MergeSort is done but I think it has to do with that, since the two arrays are already sorted and for a merge to take place, two arrays must be sorted from the start. I think the Merging is of `O(n)` complexity so maybe instead of Merging, you need a different approach, something much smarter. I am certain this will at some point need to use Binary Search.\\n\\nIf one does not know of Binary Search I think, he is not going to solve this. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How is this the hardest question on leetcode let alone a leetcode hard?  I have found leetcode easies harder than this question.  I went to sort leetcode questions be difficulty to see what the hardest question was and this came up.  This question should be reclassified as a leetcode easy."
                    },
                    {
                        "username": "anurag-k",
                        "content": "can someone explain how the time complexity of the binary search (partitioning) solution comes out as log (m+n)?"
                    },
                    {
                        "username": "jbagani",
                        "content": "It is even accepting O((M+N) log(M+N)) solutions"
                    },
                    {
                        "username": "user2579pD",
                        "content": "actually solution has O( log( min(n, m) ) )"
                    },
                    {
                        "username": "user7363Ra",
                        "content": "Can someone tell me why the below solution doesn\\'t work for input -- nums1 = [2] && nums2 = []. ?\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        if(n1 > n2)\\n        {\\n            findMedianSortedArrays(nums2, nums1);\\n        }\\n        int low = 0, high = n1;\\n        int noOfElements = (n1+n2+1)/2;\\n        while(low<=high)\\n        {\\n            int cut1 = (low+high)/2;\\n            int cut2 = noOfElements - cut1;\\n\\n            int l1 = cut1 == 0 ?  INT_MIN : nums1[cut1-1];\\n            int l2 = cut2 ==  0 ? INT_MIN : nums2[cut2-1] ;\\n            int r1 = cut1 == n1 ? INT_MAX : nums1[cut1] ;\\n            int r2 = cut2 == n2 ? INT_MAX : nums2[cut2] ;\\n            \\n            if(l1<=r2 && l2<=r1)\\n            {\\n                if((n1+n2)%2 == 0)\\n                {\\n                    return (max(l1,l2)+ min(r1,r2))/2.0;\\n                }\\n                else{\\n                    return max(l1,l2)/1.0;\\n                }\\n            }\\n            else if(l1 > r2)\\n            {\\n                high = cut1 - 1;\\n            }\\n            else\\n            {\\n                low = cut1 + 1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "hassanharoon321",
                        "content": "Simple solution understanding by reading\\n\\nFirst understand median. There are 2 cases \\n1) First for odd\\n2) Second for even\\n\\nstep1: merge both array and sort them\\n\\nstep2: for even case, divide length of an array by 2 then just return it by numArr[i] or numArr[i-1] also divide it by 2\\n\\nstep 3: for odd case, Math.ceil(numArr.length / 2) then return it by array index -1\\n\\n"
                    },
                    {
                        "username": "project101studio",
                        "content": "I\\'m trying to divided by two and it returns me the entire part only.\\nFor example, 5/2 = 2.0000\\n:("
                    }
                ]
            },
            {
                "id": 1676541,
                "content": [
                    {
                        "username": "lznpgxn809",
                        "content": "solution\\nvar findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "lznpgxn809",
                        "content": "var findMedianSortedArrays = function(nums1, nums2) {\\n    let x = [...nums1,...nums2].sort((a,b) => a-b);\\n    if(x.length % 2 == 0){\\n        return (x[(x.length/2) - 1] + x[(x.length/2)])/2;\\n    }else{\\n        return x[Math.ceil(x.length/2) - 1];\\n    }\\n};"
                    },
                    {
                        "username": "luzede",
                        "content": "When I see stuff like  `O(logn)` complexity, my mind goes to Binary Search and Binary Search Tree. Since those two are the ones I was taught at the University. Also I was taught MergeSort which is of `O(nlogn)` complexity. I don\\'t really remember how MergeSort is done but I think it has to do with that, since the two arrays are already sorted and for a merge to take place, two arrays must be sorted from the start. I think the Merging is of `O(n)` complexity so maybe instead of Merging, you need a different approach, something much smarter. I am certain this will at some point need to use Binary Search.\\n\\nIf one does not know of Binary Search I think, he is not going to solve this. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How is this the hardest question on leetcode let alone a leetcode hard?  I have found leetcode easies harder than this question.  I went to sort leetcode questions be difficulty to see what the hardest question was and this came up.  This question should be reclassified as a leetcode easy."
                    },
                    {
                        "username": "anurag-k",
                        "content": "can someone explain how the time complexity of the binary search (partitioning) solution comes out as log (m+n)?"
                    },
                    {
                        "username": "jbagani",
                        "content": "It is even accepting O((M+N) log(M+N)) solutions"
                    },
                    {
                        "username": "user2579pD",
                        "content": "actually solution has O( log( min(n, m) ) )"
                    },
                    {
                        "username": "user7363Ra",
                        "content": "Can someone tell me why the below solution doesn\\'t work for input -- nums1 = [2] && nums2 = []. ?\\n```\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        if(n1 > n2)\\n        {\\n            findMedianSortedArrays(nums2, nums1);\\n        }\\n        int low = 0, high = n1;\\n        int noOfElements = (n1+n2+1)/2;\\n        while(low<=high)\\n        {\\n            int cut1 = (low+high)/2;\\n            int cut2 = noOfElements - cut1;\\n\\n            int l1 = cut1 == 0 ?  INT_MIN : nums1[cut1-1];\\n            int l2 = cut2 ==  0 ? INT_MIN : nums2[cut2-1] ;\\n            int r1 = cut1 == n1 ? INT_MAX : nums1[cut1] ;\\n            int r2 = cut2 == n2 ? INT_MAX : nums2[cut2] ;\\n            \\n            if(l1<=r2 && l2<=r1)\\n            {\\n                if((n1+n2)%2 == 0)\\n                {\\n                    return (max(l1,l2)+ min(r1,r2))/2.0;\\n                }\\n                else{\\n                    return max(l1,l2)/1.0;\\n                }\\n            }\\n            else if(l1 > r2)\\n            {\\n                high = cut1 - 1;\\n            }\\n            else\\n            {\\n                low = cut1 + 1;\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "hassanharoon321",
                        "content": "Simple solution understanding by reading\\n\\nFirst understand median. There are 2 cases \\n1) First for odd\\n2) Second for even\\n\\nstep1: merge both array and sort them\\n\\nstep2: for even case, divide length of an array by 2 then just return it by numArr[i] or numArr[i-1] also divide it by 2\\n\\nstep 3: for odd case, Math.ceil(numArr.length / 2) then return it by array index -1\\n\\n"
                    },
                    {
                        "username": "project101studio",
                        "content": "I\\'m trying to divided by two and it returns me the entire part only.\\nFor example, 5/2 = 2.0000\\n:("
                    }
                ]
            },
            {
                "id": 1673939,
                "content": [
                    {
                        "username": "COFA",
                        "content": "small hint : \\nuse the concept of merge sort to solve it .\\nsearch and you can ,Bro"
                    },
                    {
                        "username": "mehul302",
                        "content": "Very weak test cases and weird results"
                    },
                    {
                        "username": "sudipsarkar419",
                        "content": "IDK how my code is being accepted even though its running in 0(n+m)!!!! Knowing that its great to see"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the length in both arrays is lesser than 1000. We consider that as a constant time."
                    },
                    {
                        "username": "ak2545307",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums2.size() < nums1.size())return findMedianSortedArrays(nums2,nums1);\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n    int low = 0 , high = n1;\\n    while(low <= high){\\n        int cut1 = (low + high) >>1;\\n        int cut2 = (n1+ n2+ 1)/2 - cut1;\\n        int left1 = cut1 == 0 ? INT_MIN : nums1[cut1-1];\\n        int left2 = cut2 == 0 ? INT_MIN : nums2[cut2 -1];\\n        int right1 = cut1 == n1 ? INT_MAX : nums1[cut1];\\n        int right2  = cut2 == n2 ? INT_MAX : nums2[cut2];\\n         \\n         if(left1 <= right2  && left2 <= right1){\\n             if((n1+n2)%2 == 0)\\n             return (max(left1,left2) + min(right1, right2)) /2.0;\\n             else\\n             return max(left1,left2);\\n         }  \\n         else if(left1 > right2){\\n             high = cut1 -1;\\n         }\\n         else{\\n             low = cut1+ 1;\\n         }\\n\\n    }\\n    return 0.0;\\n    }"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python Java C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "koff82",
                        "content": "LeetCode staff, please adjust your judge for this question, or mark it as easy. My trivial O(n log(n)) solution gets accepted."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "You can make it O(n+m) easily"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\n#python , #c++ , #c , #java \\n\\n\\nhttps://zeroplusfour.com/add-two-numbers-leetcode-solution/"
                    },
                    {
                        "username": "bekzat_erkinbekov",
                        "content": "// Brute Force:\\n               // 1.Merge Both Array\\n              // 2.Sort them\\n             // 3.Find Median\\n            // TIME COMPLEXITY: O(n)+O(nlogn)+O(n)\\n            // SPACE COMPLEXITY: O(1)\\n \\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       // Initialization some neccessary variables\\n        vector<int>v;\\n        \\n        // store the array in the new array\\n        for(auto num:nums1)   // O(n1)\\n            v.push_back(num);\\n        \\n        for(auto num:nums2)  // O(n2)\\n            v.push_back(num);\\n        \\n        // Sort the array to find the median\\n        sort(v.begin(),v.end());  // O(nlogn)\\n        \\n        // Find the median and Return it\\n        int n=v.size();  // O(n)\\n        \\n        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;\\n    }\\n};\\n\\n** Accepted **"
                    },
                    {
                        "username": "Vithesh",
                        "content": "....can\\'t read constraints?!!"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "EASY AND SIMPLE SOLUATION\\n \\nhttps://github.com/Nilesh2925/MEDIAN-OF-TWO-SORTED-ARRAYS/blob/main/MEDIAN%20OF%20TWO%20ARRAYS"
                    },
                    {
                        "username": "parismania",
                        "content": "This passes the leetcode gate, but has O(m+n) complexity (because of merge), not O(log(m+n)) as required."
                    },
                    {
                        "username": "waquarahmed823",
                        "content": "what would be the merge array of [1,1] and [1,2]?? because my answer is 1.5 and expected is 1."
                    }
                ]
            },
            {
                "id": 1672505,
                "content": [
                    {
                        "username": "COFA",
                        "content": "small hint : \\nuse the concept of merge sort to solve it .\\nsearch and you can ,Bro"
                    },
                    {
                        "username": "mehul302",
                        "content": "Very weak test cases and weird results"
                    },
                    {
                        "username": "sudipsarkar419",
                        "content": "IDK how my code is being accepted even though its running in 0(n+m)!!!! Knowing that its great to see"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the length in both arrays is lesser than 1000. We consider that as a constant time."
                    },
                    {
                        "username": "ak2545307",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums2.size() < nums1.size())return findMedianSortedArrays(nums2,nums1);\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n    int low = 0 , high = n1;\\n    while(low <= high){\\n        int cut1 = (low + high) >>1;\\n        int cut2 = (n1+ n2+ 1)/2 - cut1;\\n        int left1 = cut1 == 0 ? INT_MIN : nums1[cut1-1];\\n        int left2 = cut2 == 0 ? INT_MIN : nums2[cut2 -1];\\n        int right1 = cut1 == n1 ? INT_MAX : nums1[cut1];\\n        int right2  = cut2 == n2 ? INT_MAX : nums2[cut2];\\n         \\n         if(left1 <= right2  && left2 <= right1){\\n             if((n1+n2)%2 == 0)\\n             return (max(left1,left2) + min(right1, right2)) /2.0;\\n             else\\n             return max(left1,left2);\\n         }  \\n         else if(left1 > right2){\\n             high = cut1 -1;\\n         }\\n         else{\\n             low = cut1+ 1;\\n         }\\n\\n    }\\n    return 0.0;\\n    }"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python Java C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "koff82",
                        "content": "LeetCode staff, please adjust your judge for this question, or mark it as easy. My trivial O(n log(n)) solution gets accepted."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "You can make it O(n+m) easily"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\n#python , #c++ , #c , #java \\n\\n\\nhttps://zeroplusfour.com/add-two-numbers-leetcode-solution/"
                    },
                    {
                        "username": "bekzat_erkinbekov",
                        "content": "// Brute Force:\\n               // 1.Merge Both Array\\n              // 2.Sort them\\n             // 3.Find Median\\n            // TIME COMPLEXITY: O(n)+O(nlogn)+O(n)\\n            // SPACE COMPLEXITY: O(1)\\n \\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       // Initialization some neccessary variables\\n        vector<int>v;\\n        \\n        // store the array in the new array\\n        for(auto num:nums1)   // O(n1)\\n            v.push_back(num);\\n        \\n        for(auto num:nums2)  // O(n2)\\n            v.push_back(num);\\n        \\n        // Sort the array to find the median\\n        sort(v.begin(),v.end());  // O(nlogn)\\n        \\n        // Find the median and Return it\\n        int n=v.size();  // O(n)\\n        \\n        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;\\n    }\\n};\\n\\n** Accepted **"
                    },
                    {
                        "username": "Vithesh",
                        "content": "....can\\'t read constraints?!!"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "EASY AND SIMPLE SOLUATION\\n \\nhttps://github.com/Nilesh2925/MEDIAN-OF-TWO-SORTED-ARRAYS/blob/main/MEDIAN%20OF%20TWO%20ARRAYS"
                    },
                    {
                        "username": "parismania",
                        "content": "This passes the leetcode gate, but has O(m+n) complexity (because of merge), not O(log(m+n)) as required."
                    },
                    {
                        "username": "waquarahmed823",
                        "content": "what would be the merge array of [1,1] and [1,2]?? because my answer is 1.5 and expected is 1."
                    }
                ]
            },
            {
                "id": 1672480,
                "content": [
                    {
                        "username": "COFA",
                        "content": "small hint : \\nuse the concept of merge sort to solve it .\\nsearch and you can ,Bro"
                    },
                    {
                        "username": "mehul302",
                        "content": "Very weak test cases and weird results"
                    },
                    {
                        "username": "sudipsarkar419",
                        "content": "IDK how my code is being accepted even though its running in 0(n+m)!!!! Knowing that its great to see"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the length in both arrays is lesser than 1000. We consider that as a constant time."
                    },
                    {
                        "username": "ak2545307",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums2.size() < nums1.size())return findMedianSortedArrays(nums2,nums1);\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n    int low = 0 , high = n1;\\n    while(low <= high){\\n        int cut1 = (low + high) >>1;\\n        int cut2 = (n1+ n2+ 1)/2 - cut1;\\n        int left1 = cut1 == 0 ? INT_MIN : nums1[cut1-1];\\n        int left2 = cut2 == 0 ? INT_MIN : nums2[cut2 -1];\\n        int right1 = cut1 == n1 ? INT_MAX : nums1[cut1];\\n        int right2  = cut2 == n2 ? INT_MAX : nums2[cut2];\\n         \\n         if(left1 <= right2  && left2 <= right1){\\n             if((n1+n2)%2 == 0)\\n             return (max(left1,left2) + min(right1, right2)) /2.0;\\n             else\\n             return max(left1,left2);\\n         }  \\n         else if(left1 > right2){\\n             high = cut1 -1;\\n         }\\n         else{\\n             low = cut1+ 1;\\n         }\\n\\n    }\\n    return 0.0;\\n    }"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python Java C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "koff82",
                        "content": "LeetCode staff, please adjust your judge for this question, or mark it as easy. My trivial O(n log(n)) solution gets accepted."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "You can make it O(n+m) easily"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\n#python , #c++ , #c , #java \\n\\n\\nhttps://zeroplusfour.com/add-two-numbers-leetcode-solution/"
                    },
                    {
                        "username": "bekzat_erkinbekov",
                        "content": "// Brute Force:\\n               // 1.Merge Both Array\\n              // 2.Sort them\\n             // 3.Find Median\\n            // TIME COMPLEXITY: O(n)+O(nlogn)+O(n)\\n            // SPACE COMPLEXITY: O(1)\\n \\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       // Initialization some neccessary variables\\n        vector<int>v;\\n        \\n        // store the array in the new array\\n        for(auto num:nums1)   // O(n1)\\n            v.push_back(num);\\n        \\n        for(auto num:nums2)  // O(n2)\\n            v.push_back(num);\\n        \\n        // Sort the array to find the median\\n        sort(v.begin(),v.end());  // O(nlogn)\\n        \\n        // Find the median and Return it\\n        int n=v.size();  // O(n)\\n        \\n        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;\\n    }\\n};\\n\\n** Accepted **"
                    },
                    {
                        "username": "Vithesh",
                        "content": "....can\\'t read constraints?!!"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "EASY AND SIMPLE SOLUATION\\n \\nhttps://github.com/Nilesh2925/MEDIAN-OF-TWO-SORTED-ARRAYS/blob/main/MEDIAN%20OF%20TWO%20ARRAYS"
                    },
                    {
                        "username": "parismania",
                        "content": "This passes the leetcode gate, but has O(m+n) complexity (because of merge), not O(log(m+n)) as required."
                    },
                    {
                        "username": "waquarahmed823",
                        "content": "what would be the merge array of [1,1] and [1,2]?? because my answer is 1.5 and expected is 1."
                    }
                ]
            },
            {
                "id": 1671949,
                "content": [
                    {
                        "username": "COFA",
                        "content": "small hint : \\nuse the concept of merge sort to solve it .\\nsearch and you can ,Bro"
                    },
                    {
                        "username": "mehul302",
                        "content": "Very weak test cases and weird results"
                    },
                    {
                        "username": "sudipsarkar419",
                        "content": "IDK how my code is being accepted even though its running in 0(n+m)!!!! Knowing that its great to see"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the length in both arrays is lesser than 1000. We consider that as a constant time."
                    },
                    {
                        "username": "ak2545307",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums2.size() < nums1.size())return findMedianSortedArrays(nums2,nums1);\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n    int low = 0 , high = n1;\\n    while(low <= high){\\n        int cut1 = (low + high) >>1;\\n        int cut2 = (n1+ n2+ 1)/2 - cut1;\\n        int left1 = cut1 == 0 ? INT_MIN : nums1[cut1-1];\\n        int left2 = cut2 == 0 ? INT_MIN : nums2[cut2 -1];\\n        int right1 = cut1 == n1 ? INT_MAX : nums1[cut1];\\n        int right2  = cut2 == n2 ? INT_MAX : nums2[cut2];\\n         \\n         if(left1 <= right2  && left2 <= right1){\\n             if((n1+n2)%2 == 0)\\n             return (max(left1,left2) + min(right1, right2)) /2.0;\\n             else\\n             return max(left1,left2);\\n         }  \\n         else if(left1 > right2){\\n             high = cut1 -1;\\n         }\\n         else{\\n             low = cut1+ 1;\\n         }\\n\\n    }\\n    return 0.0;\\n    }"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python Java C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "koff82",
                        "content": "LeetCode staff, please adjust your judge for this question, or mark it as easy. My trivial O(n log(n)) solution gets accepted."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "You can make it O(n+m) easily"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\n#python , #c++ , #c , #java \\n\\n\\nhttps://zeroplusfour.com/add-two-numbers-leetcode-solution/"
                    },
                    {
                        "username": "bekzat_erkinbekov",
                        "content": "// Brute Force:\\n               // 1.Merge Both Array\\n              // 2.Sort them\\n             // 3.Find Median\\n            // TIME COMPLEXITY: O(n)+O(nlogn)+O(n)\\n            // SPACE COMPLEXITY: O(1)\\n \\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       // Initialization some neccessary variables\\n        vector<int>v;\\n        \\n        // store the array in the new array\\n        for(auto num:nums1)   // O(n1)\\n            v.push_back(num);\\n        \\n        for(auto num:nums2)  // O(n2)\\n            v.push_back(num);\\n        \\n        // Sort the array to find the median\\n        sort(v.begin(),v.end());  // O(nlogn)\\n        \\n        // Find the median and Return it\\n        int n=v.size();  // O(n)\\n        \\n        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;\\n    }\\n};\\n\\n** Accepted **"
                    },
                    {
                        "username": "Vithesh",
                        "content": "....can\\'t read constraints?!!"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "EASY AND SIMPLE SOLUATION\\n \\nhttps://github.com/Nilesh2925/MEDIAN-OF-TWO-SORTED-ARRAYS/blob/main/MEDIAN%20OF%20TWO%20ARRAYS"
                    },
                    {
                        "username": "parismania",
                        "content": "This passes the leetcode gate, but has O(m+n) complexity (because of merge), not O(log(m+n)) as required."
                    },
                    {
                        "username": "waquarahmed823",
                        "content": "what would be the merge array of [1,1] and [1,2]?? because my answer is 1.5 and expected is 1."
                    }
                ]
            },
            {
                "id": 1671223,
                "content": [
                    {
                        "username": "COFA",
                        "content": "small hint : \\nuse the concept of merge sort to solve it .\\nsearch and you can ,Bro"
                    },
                    {
                        "username": "mehul302",
                        "content": "Very weak test cases and weird results"
                    },
                    {
                        "username": "sudipsarkar419",
                        "content": "IDK how my code is being accepted even though its running in 0(n+m)!!!! Knowing that its great to see"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the length in both arrays is lesser than 1000. We consider that as a constant time."
                    },
                    {
                        "username": "ak2545307",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums2.size() < nums1.size())return findMedianSortedArrays(nums2,nums1);\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n    int low = 0 , high = n1;\\n    while(low <= high){\\n        int cut1 = (low + high) >>1;\\n        int cut2 = (n1+ n2+ 1)/2 - cut1;\\n        int left1 = cut1 == 0 ? INT_MIN : nums1[cut1-1];\\n        int left2 = cut2 == 0 ? INT_MIN : nums2[cut2 -1];\\n        int right1 = cut1 == n1 ? INT_MAX : nums1[cut1];\\n        int right2  = cut2 == n2 ? INT_MAX : nums2[cut2];\\n         \\n         if(left1 <= right2  && left2 <= right1){\\n             if((n1+n2)%2 == 0)\\n             return (max(left1,left2) + min(right1, right2)) /2.0;\\n             else\\n             return max(left1,left2);\\n         }  \\n         else if(left1 > right2){\\n             high = cut1 -1;\\n         }\\n         else{\\n             low = cut1+ 1;\\n         }\\n\\n    }\\n    return 0.0;\\n    }"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python Java C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "koff82",
                        "content": "LeetCode staff, please adjust your judge for this question, or mark it as easy. My trivial O(n log(n)) solution gets accepted."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "You can make it O(n+m) easily"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\n#python , #c++ , #c , #java \\n\\n\\nhttps://zeroplusfour.com/add-two-numbers-leetcode-solution/"
                    },
                    {
                        "username": "bekzat_erkinbekov",
                        "content": "// Brute Force:\\n               // 1.Merge Both Array\\n              // 2.Sort them\\n             // 3.Find Median\\n            // TIME COMPLEXITY: O(n)+O(nlogn)+O(n)\\n            // SPACE COMPLEXITY: O(1)\\n \\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       // Initialization some neccessary variables\\n        vector<int>v;\\n        \\n        // store the array in the new array\\n        for(auto num:nums1)   // O(n1)\\n            v.push_back(num);\\n        \\n        for(auto num:nums2)  // O(n2)\\n            v.push_back(num);\\n        \\n        // Sort the array to find the median\\n        sort(v.begin(),v.end());  // O(nlogn)\\n        \\n        // Find the median and Return it\\n        int n=v.size();  // O(n)\\n        \\n        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;\\n    }\\n};\\n\\n** Accepted **"
                    },
                    {
                        "username": "Vithesh",
                        "content": "....can\\'t read constraints?!!"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "EASY AND SIMPLE SOLUATION\\n \\nhttps://github.com/Nilesh2925/MEDIAN-OF-TWO-SORTED-ARRAYS/blob/main/MEDIAN%20OF%20TWO%20ARRAYS"
                    },
                    {
                        "username": "parismania",
                        "content": "This passes the leetcode gate, but has O(m+n) complexity (because of merge), not O(log(m+n)) as required."
                    },
                    {
                        "username": "waquarahmed823",
                        "content": "what would be the merge array of [1,1] and [1,2]?? because my answer is 1.5 and expected is 1."
                    }
                ]
            },
            {
                "id": 1658942,
                "content": [
                    {
                        "username": "COFA",
                        "content": "small hint : \\nuse the concept of merge sort to solve it .\\nsearch and you can ,Bro"
                    },
                    {
                        "username": "mehul302",
                        "content": "Very weak test cases and weird results"
                    },
                    {
                        "username": "sudipsarkar419",
                        "content": "IDK how my code is being accepted even though its running in 0(n+m)!!!! Knowing that its great to see"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the length in both arrays is lesser than 1000. We consider that as a constant time."
                    },
                    {
                        "username": "ak2545307",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums2.size() < nums1.size())return findMedianSortedArrays(nums2,nums1);\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n    int low = 0 , high = n1;\\n    while(low <= high){\\n        int cut1 = (low + high) >>1;\\n        int cut2 = (n1+ n2+ 1)/2 - cut1;\\n        int left1 = cut1 == 0 ? INT_MIN : nums1[cut1-1];\\n        int left2 = cut2 == 0 ? INT_MIN : nums2[cut2 -1];\\n        int right1 = cut1 == n1 ? INT_MAX : nums1[cut1];\\n        int right2  = cut2 == n2 ? INT_MAX : nums2[cut2];\\n         \\n         if(left1 <= right2  && left2 <= right1){\\n             if((n1+n2)%2 == 0)\\n             return (max(left1,left2) + min(right1, right2)) /2.0;\\n             else\\n             return max(left1,left2);\\n         }  \\n         else if(left1 > right2){\\n             high = cut1 -1;\\n         }\\n         else{\\n             low = cut1+ 1;\\n         }\\n\\n    }\\n    return 0.0;\\n    }"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python Java C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "koff82",
                        "content": "LeetCode staff, please adjust your judge for this question, or mark it as easy. My trivial O(n log(n)) solution gets accepted."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "You can make it O(n+m) easily"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\n#python , #c++ , #c , #java \\n\\n\\nhttps://zeroplusfour.com/add-two-numbers-leetcode-solution/"
                    },
                    {
                        "username": "bekzat_erkinbekov",
                        "content": "// Brute Force:\\n               // 1.Merge Both Array\\n              // 2.Sort them\\n             // 3.Find Median\\n            // TIME COMPLEXITY: O(n)+O(nlogn)+O(n)\\n            // SPACE COMPLEXITY: O(1)\\n \\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       // Initialization some neccessary variables\\n        vector<int>v;\\n        \\n        // store the array in the new array\\n        for(auto num:nums1)   // O(n1)\\n            v.push_back(num);\\n        \\n        for(auto num:nums2)  // O(n2)\\n            v.push_back(num);\\n        \\n        // Sort the array to find the median\\n        sort(v.begin(),v.end());  // O(nlogn)\\n        \\n        // Find the median and Return it\\n        int n=v.size();  // O(n)\\n        \\n        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;\\n    }\\n};\\n\\n** Accepted **"
                    },
                    {
                        "username": "Vithesh",
                        "content": "....can\\'t read constraints?!!"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "EASY AND SIMPLE SOLUATION\\n \\nhttps://github.com/Nilesh2925/MEDIAN-OF-TWO-SORTED-ARRAYS/blob/main/MEDIAN%20OF%20TWO%20ARRAYS"
                    },
                    {
                        "username": "parismania",
                        "content": "This passes the leetcode gate, but has O(m+n) complexity (because of merge), not O(log(m+n)) as required."
                    },
                    {
                        "username": "waquarahmed823",
                        "content": "what would be the merge array of [1,1] and [1,2]?? because my answer is 1.5 and expected is 1."
                    }
                ]
            },
            {
                "id": 1648660,
                "content": [
                    {
                        "username": "COFA",
                        "content": "small hint : \\nuse the concept of merge sort to solve it .\\nsearch and you can ,Bro"
                    },
                    {
                        "username": "mehul302",
                        "content": "Very weak test cases and weird results"
                    },
                    {
                        "username": "sudipsarkar419",
                        "content": "IDK how my code is being accepted even though its running in 0(n+m)!!!! Knowing that its great to see"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the length in both arrays is lesser than 1000. We consider that as a constant time."
                    },
                    {
                        "username": "ak2545307",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums2.size() < nums1.size())return findMedianSortedArrays(nums2,nums1);\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n    int low = 0 , high = n1;\\n    while(low <= high){\\n        int cut1 = (low + high) >>1;\\n        int cut2 = (n1+ n2+ 1)/2 - cut1;\\n        int left1 = cut1 == 0 ? INT_MIN : nums1[cut1-1];\\n        int left2 = cut2 == 0 ? INT_MIN : nums2[cut2 -1];\\n        int right1 = cut1 == n1 ? INT_MAX : nums1[cut1];\\n        int right2  = cut2 == n2 ? INT_MAX : nums2[cut2];\\n         \\n         if(left1 <= right2  && left2 <= right1){\\n             if((n1+n2)%2 == 0)\\n             return (max(left1,left2) + min(right1, right2)) /2.0;\\n             else\\n             return max(left1,left2);\\n         }  \\n         else if(left1 > right2){\\n             high = cut1 -1;\\n         }\\n         else{\\n             low = cut1+ 1;\\n         }\\n\\n    }\\n    return 0.0;\\n    }"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python Java C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "koff82",
                        "content": "LeetCode staff, please adjust your judge for this question, or mark it as easy. My trivial O(n log(n)) solution gets accepted."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "You can make it O(n+m) easily"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\n#python , #c++ , #c , #java \\n\\n\\nhttps://zeroplusfour.com/add-two-numbers-leetcode-solution/"
                    },
                    {
                        "username": "bekzat_erkinbekov",
                        "content": "// Brute Force:\\n               // 1.Merge Both Array\\n              // 2.Sort them\\n             // 3.Find Median\\n            // TIME COMPLEXITY: O(n)+O(nlogn)+O(n)\\n            // SPACE COMPLEXITY: O(1)\\n \\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       // Initialization some neccessary variables\\n        vector<int>v;\\n        \\n        // store the array in the new array\\n        for(auto num:nums1)   // O(n1)\\n            v.push_back(num);\\n        \\n        for(auto num:nums2)  // O(n2)\\n            v.push_back(num);\\n        \\n        // Sort the array to find the median\\n        sort(v.begin(),v.end());  // O(nlogn)\\n        \\n        // Find the median and Return it\\n        int n=v.size();  // O(n)\\n        \\n        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;\\n    }\\n};\\n\\n** Accepted **"
                    },
                    {
                        "username": "Vithesh",
                        "content": "....can\\'t read constraints?!!"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "EASY AND SIMPLE SOLUATION\\n \\nhttps://github.com/Nilesh2925/MEDIAN-OF-TWO-SORTED-ARRAYS/blob/main/MEDIAN%20OF%20TWO%20ARRAYS"
                    },
                    {
                        "username": "parismania",
                        "content": "This passes the leetcode gate, but has O(m+n) complexity (because of merge), not O(log(m+n)) as required."
                    },
                    {
                        "username": "waquarahmed823",
                        "content": "what would be the merge array of [1,1] and [1,2]?? because my answer is 1.5 and expected is 1."
                    }
                ]
            },
            {
                "id": 1645784,
                "content": [
                    {
                        "username": "COFA",
                        "content": "small hint : \\nuse the concept of merge sort to solve it .\\nsearch and you can ,Bro"
                    },
                    {
                        "username": "mehul302",
                        "content": "Very weak test cases and weird results"
                    },
                    {
                        "username": "sudipsarkar419",
                        "content": "IDK how my code is being accepted even though its running in 0(n+m)!!!! Knowing that its great to see"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the length in both arrays is lesser than 1000. We consider that as a constant time."
                    },
                    {
                        "username": "ak2545307",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums2.size() < nums1.size())return findMedianSortedArrays(nums2,nums1);\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n    int low = 0 , high = n1;\\n    while(low <= high){\\n        int cut1 = (low + high) >>1;\\n        int cut2 = (n1+ n2+ 1)/2 - cut1;\\n        int left1 = cut1 == 0 ? INT_MIN : nums1[cut1-1];\\n        int left2 = cut2 == 0 ? INT_MIN : nums2[cut2 -1];\\n        int right1 = cut1 == n1 ? INT_MAX : nums1[cut1];\\n        int right2  = cut2 == n2 ? INT_MAX : nums2[cut2];\\n         \\n         if(left1 <= right2  && left2 <= right1){\\n             if((n1+n2)%2 == 0)\\n             return (max(left1,left2) + min(right1, right2)) /2.0;\\n             else\\n             return max(left1,left2);\\n         }  \\n         else if(left1 > right2){\\n             high = cut1 -1;\\n         }\\n         else{\\n             low = cut1+ 1;\\n         }\\n\\n    }\\n    return 0.0;\\n    }"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python Java C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "koff82",
                        "content": "LeetCode staff, please adjust your judge for this question, or mark it as easy. My trivial O(n log(n)) solution gets accepted."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "You can make it O(n+m) easily"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\n#python , #c++ , #c , #java \\n\\n\\nhttps://zeroplusfour.com/add-two-numbers-leetcode-solution/"
                    },
                    {
                        "username": "bekzat_erkinbekov",
                        "content": "// Brute Force:\\n               // 1.Merge Both Array\\n              // 2.Sort them\\n             // 3.Find Median\\n            // TIME COMPLEXITY: O(n)+O(nlogn)+O(n)\\n            // SPACE COMPLEXITY: O(1)\\n \\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       // Initialization some neccessary variables\\n        vector<int>v;\\n        \\n        // store the array in the new array\\n        for(auto num:nums1)   // O(n1)\\n            v.push_back(num);\\n        \\n        for(auto num:nums2)  // O(n2)\\n            v.push_back(num);\\n        \\n        // Sort the array to find the median\\n        sort(v.begin(),v.end());  // O(nlogn)\\n        \\n        // Find the median and Return it\\n        int n=v.size();  // O(n)\\n        \\n        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;\\n    }\\n};\\n\\n** Accepted **"
                    },
                    {
                        "username": "Vithesh",
                        "content": "....can\\'t read constraints?!!"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "EASY AND SIMPLE SOLUATION\\n \\nhttps://github.com/Nilesh2925/MEDIAN-OF-TWO-SORTED-ARRAYS/blob/main/MEDIAN%20OF%20TWO%20ARRAYS"
                    },
                    {
                        "username": "parismania",
                        "content": "This passes the leetcode gate, but has O(m+n) complexity (because of merge), not O(log(m+n)) as required."
                    },
                    {
                        "username": "waquarahmed823",
                        "content": "what would be the merge array of [1,1] and [1,2]?? because my answer is 1.5 and expected is 1."
                    }
                ]
            },
            {
                "id": 1639556,
                "content": [
                    {
                        "username": "COFA",
                        "content": "small hint : \\nuse the concept of merge sort to solve it .\\nsearch and you can ,Bro"
                    },
                    {
                        "username": "mehul302",
                        "content": "Very weak test cases and weird results"
                    },
                    {
                        "username": "sudipsarkar419",
                        "content": "IDK how my code is being accepted even though its running in 0(n+m)!!!! Knowing that its great to see"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the length in both arrays is lesser than 1000. We consider that as a constant time."
                    },
                    {
                        "username": "ak2545307",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums2.size() < nums1.size())return findMedianSortedArrays(nums2,nums1);\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n    int low = 0 , high = n1;\\n    while(low <= high){\\n        int cut1 = (low + high) >>1;\\n        int cut2 = (n1+ n2+ 1)/2 - cut1;\\n        int left1 = cut1 == 0 ? INT_MIN : nums1[cut1-1];\\n        int left2 = cut2 == 0 ? INT_MIN : nums2[cut2 -1];\\n        int right1 = cut1 == n1 ? INT_MAX : nums1[cut1];\\n        int right2  = cut2 == n2 ? INT_MAX : nums2[cut2];\\n         \\n         if(left1 <= right2  && left2 <= right1){\\n             if((n1+n2)%2 == 0)\\n             return (max(left1,left2) + min(right1, right2)) /2.0;\\n             else\\n             return max(left1,left2);\\n         }  \\n         else if(left1 > right2){\\n             high = cut1 -1;\\n         }\\n         else{\\n             low = cut1+ 1;\\n         }\\n\\n    }\\n    return 0.0;\\n    }"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python Java C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "koff82",
                        "content": "LeetCode staff, please adjust your judge for this question, or mark it as easy. My trivial O(n log(n)) solution gets accepted."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "You can make it O(n+m) easily"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\n#python , #c++ , #c , #java \\n\\n\\nhttps://zeroplusfour.com/add-two-numbers-leetcode-solution/"
                    },
                    {
                        "username": "bekzat_erkinbekov",
                        "content": "// Brute Force:\\n               // 1.Merge Both Array\\n              // 2.Sort them\\n             // 3.Find Median\\n            // TIME COMPLEXITY: O(n)+O(nlogn)+O(n)\\n            // SPACE COMPLEXITY: O(1)\\n \\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       // Initialization some neccessary variables\\n        vector<int>v;\\n        \\n        // store the array in the new array\\n        for(auto num:nums1)   // O(n1)\\n            v.push_back(num);\\n        \\n        for(auto num:nums2)  // O(n2)\\n            v.push_back(num);\\n        \\n        // Sort the array to find the median\\n        sort(v.begin(),v.end());  // O(nlogn)\\n        \\n        // Find the median and Return it\\n        int n=v.size();  // O(n)\\n        \\n        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;\\n    }\\n};\\n\\n** Accepted **"
                    },
                    {
                        "username": "Vithesh",
                        "content": "....can\\'t read constraints?!!"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "EASY AND SIMPLE SOLUATION\\n \\nhttps://github.com/Nilesh2925/MEDIAN-OF-TWO-SORTED-ARRAYS/blob/main/MEDIAN%20OF%20TWO%20ARRAYS"
                    },
                    {
                        "username": "parismania",
                        "content": "This passes the leetcode gate, but has O(m+n) complexity (because of merge), not O(log(m+n)) as required."
                    },
                    {
                        "username": "waquarahmed823",
                        "content": "what would be the merge array of [1,1] and [1,2]?? because my answer is 1.5 and expected is 1."
                    }
                ]
            },
            {
                "id": 1626349,
                "content": [
                    {
                        "username": "COFA",
                        "content": "small hint : \\nuse the concept of merge sort to solve it .\\nsearch and you can ,Bro"
                    },
                    {
                        "username": "mehul302",
                        "content": "Very weak test cases and weird results"
                    },
                    {
                        "username": "sudipsarkar419",
                        "content": "IDK how my code is being accepted even though its running in 0(n+m)!!!! Knowing that its great to see"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the length in both arrays is lesser than 1000. We consider that as a constant time."
                    },
                    {
                        "username": "ak2545307",
                        "content": "class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums2.size() < nums1.size())return findMedianSortedArrays(nums2,nums1);\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n    int low = 0 , high = n1;\\n    while(low <= high){\\n        int cut1 = (low + high) >>1;\\n        int cut2 = (n1+ n2+ 1)/2 - cut1;\\n        int left1 = cut1 == 0 ? INT_MIN : nums1[cut1-1];\\n        int left2 = cut2 == 0 ? INT_MIN : nums2[cut2 -1];\\n        int right1 = cut1 == n1 ? INT_MAX : nums1[cut1];\\n        int right2  = cut2 == n2 ? INT_MAX : nums2[cut2];\\n         \\n         if(left1 <= right2  && left2 <= right1){\\n             if((n1+n2)%2 == 0)\\n             return (max(left1,left2) + min(right1, right2)) /2.0;\\n             else\\n             return max(left1,left2);\\n         }  \\n         else if(left1 > right2){\\n             high = cut1 -1;\\n         }\\n         else{\\n             low = cut1+ 1;\\n         }\\n\\n    }\\n    return 0.0;\\n    }"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python Java C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-median-of-two-sorted-arrays-problem-solution.html)"
                    },
                    {
                        "username": "koff82",
                        "content": "LeetCode staff, please adjust your judge for this question, or mark it as easy. My trivial O(n log(n)) solution gets accepted."
                    },
                    {
                        "username": "alperkaya0",
                        "content": "You can make it O(n+m) easily"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\n#python , #c++ , #c , #java \\n\\n\\nhttps://zeroplusfour.com/add-two-numbers-leetcode-solution/"
                    },
                    {
                        "username": "bekzat_erkinbekov",
                        "content": "// Brute Force:\\n               // 1.Merge Both Array\\n              // 2.Sort them\\n             // 3.Find Median\\n            // TIME COMPLEXITY: O(n)+O(nlogn)+O(n)\\n            // SPACE COMPLEXITY: O(1)\\n \\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n       // Initialization some neccessary variables\\n        vector<int>v;\\n        \\n        // store the array in the new array\\n        for(auto num:nums1)   // O(n1)\\n            v.push_back(num);\\n        \\n        for(auto num:nums2)  // O(n2)\\n            v.push_back(num);\\n        \\n        // Sort the array to find the median\\n        sort(v.begin(),v.end());  // O(nlogn)\\n        \\n        // Find the median and Return it\\n        int n=v.size();  // O(n)\\n        \\n        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;\\n    }\\n};\\n\\n** Accepted **"
                    },
                    {
                        "username": "Vithesh",
                        "content": "....can\\'t read constraints?!!"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "EASY AND SIMPLE SOLUATION\\n \\nhttps://github.com/Nilesh2925/MEDIAN-OF-TWO-SORTED-ARRAYS/blob/main/MEDIAN%20OF%20TWO%20ARRAYS"
                    },
                    {
                        "username": "parismania",
                        "content": "This passes the leetcode gate, but has O(m+n) complexity (because of merge), not O(log(m+n)) as required."
                    },
                    {
                        "username": "waquarahmed823",
                        "content": "what would be the merge array of [1,1] and [1,2]?? because my answer is 1.5 and expected is 1."
                    }
                ]
            },
            {
                "id": 1625649,
                "content": [
                    {
                        "username": "volskrad13",
                        "content": "why the expected output of [1,2] is 1.0 ?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "centYY",
                        "content": "I think this question is too easy. I wrote it in 5 mins. So, I think the difficulty of it may be easy, not Hard."
                    },
                    {
                        "username": "aksshatkhanna25",
                        "content": "you are legend"
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "group link\\nhttps://chat.whatsapp.com/D1jVp7mN1q93NLnBtVwKb1"
                    },
                    {
                        "username": "realitant",
                        "content": "Why on earth is this marked as hard? The hardest part was avoiding off by 1 errors in the median function."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "You did it wrong, u got a complexity of O(n+m) and will fail the interview"
                    },
                    {
                        "username": "vikas_singhff",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int arr[] = new int[nums1.length+nums2.length];\\n        int j = 0;\\n        for(int i=0; i<nums1.length; i++) {\\n            arr[j++] = nums1[i];\\n        }\\n        for(int i:nums2) {\\n            arr[j++] = i;\\n        }\\n        Arrays.sort(arr);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int size = arr.length;\\n        if(size % 2 == 0) {\\n            list.add(arr[size/2]);\\n            list.add(arr[(size-1)/2]);\\n        }\\n        else {\\n            list.add(arr[size/2]);\\n        }\\n        int sum =0;\\n        for(int i:list) {\\n            sum =sum +i;\\n        }\\n\\n        return (double) sum/list.size();\\n    }\\n}"
                    },
                    {
                        "username": "gd4niele",
                        "content": "this problem is way much easier than the yesterday\\'s one"
                    },
                    {
                        "username": "gd4niele",
                        "content": "[@lucasscodes](/lucasscodes) no i did O(log(n + m))"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you did it wrong and used O(n+m).\\nthis will fail your interview"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### median is data point not fractional value."
                    },
                    {
                        "username": "psionl0",
                        "content": "It would not be possible to return a median if the array was an even size under your definition. All my life I have been taught that for an even number of elements, the median is the average of the two middle elements."
                    },
                    {
                        "username": "sakethrahulkoredla",
                        "content": "A median must be present in the data"
                    },
                    {
                        "username": "psionl0",
                        "content": "All my life I have been taught that this is not the case for an even number of elements."
                    }
                ]
            },
            {
                "id": 1576298,
                "content": [
                    {
                        "username": "volskrad13",
                        "content": "why the expected output of [1,2] is 1.0 ?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "centYY",
                        "content": "I think this question is too easy. I wrote it in 5 mins. So, I think the difficulty of it may be easy, not Hard."
                    },
                    {
                        "username": "aksshatkhanna25",
                        "content": "you are legend"
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "group link\\nhttps://chat.whatsapp.com/D1jVp7mN1q93NLnBtVwKb1"
                    },
                    {
                        "username": "realitant",
                        "content": "Why on earth is this marked as hard? The hardest part was avoiding off by 1 errors in the median function."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "You did it wrong, u got a complexity of O(n+m) and will fail the interview"
                    },
                    {
                        "username": "vikas_singhff",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int arr[] = new int[nums1.length+nums2.length];\\n        int j = 0;\\n        for(int i=0; i<nums1.length; i++) {\\n            arr[j++] = nums1[i];\\n        }\\n        for(int i:nums2) {\\n            arr[j++] = i;\\n        }\\n        Arrays.sort(arr);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int size = arr.length;\\n        if(size % 2 == 0) {\\n            list.add(arr[size/2]);\\n            list.add(arr[(size-1)/2]);\\n        }\\n        else {\\n            list.add(arr[size/2]);\\n        }\\n        int sum =0;\\n        for(int i:list) {\\n            sum =sum +i;\\n        }\\n\\n        return (double) sum/list.size();\\n    }\\n}"
                    },
                    {
                        "username": "gd4niele",
                        "content": "this problem is way much easier than the yesterday\\'s one"
                    },
                    {
                        "username": "gd4niele",
                        "content": "[@lucasscodes](/lucasscodes) no i did O(log(n + m))"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you did it wrong and used O(n+m).\\nthis will fail your interview"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### median is data point not fractional value."
                    },
                    {
                        "username": "psionl0",
                        "content": "It would not be possible to return a median if the array was an even size under your definition. All my life I have been taught that for an even number of elements, the median is the average of the two middle elements."
                    },
                    {
                        "username": "sakethrahulkoredla",
                        "content": "A median must be present in the data"
                    },
                    {
                        "username": "psionl0",
                        "content": "All my life I have been taught that this is not the case for an even number of elements."
                    }
                ]
            },
            {
                "id": 1570779,
                "content": [
                    {
                        "username": "volskrad13",
                        "content": "why the expected output of [1,2] is 1.0 ?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "centYY",
                        "content": "I think this question is too easy. I wrote it in 5 mins. So, I think the difficulty of it may be easy, not Hard."
                    },
                    {
                        "username": "aksshatkhanna25",
                        "content": "you are legend"
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "group link\\nhttps://chat.whatsapp.com/D1jVp7mN1q93NLnBtVwKb1"
                    },
                    {
                        "username": "realitant",
                        "content": "Why on earth is this marked as hard? The hardest part was avoiding off by 1 errors in the median function."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "You did it wrong, u got a complexity of O(n+m) and will fail the interview"
                    },
                    {
                        "username": "vikas_singhff",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int arr[] = new int[nums1.length+nums2.length];\\n        int j = 0;\\n        for(int i=0; i<nums1.length; i++) {\\n            arr[j++] = nums1[i];\\n        }\\n        for(int i:nums2) {\\n            arr[j++] = i;\\n        }\\n        Arrays.sort(arr);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int size = arr.length;\\n        if(size % 2 == 0) {\\n            list.add(arr[size/2]);\\n            list.add(arr[(size-1)/2]);\\n        }\\n        else {\\n            list.add(arr[size/2]);\\n        }\\n        int sum =0;\\n        for(int i:list) {\\n            sum =sum +i;\\n        }\\n\\n        return (double) sum/list.size();\\n    }\\n}"
                    },
                    {
                        "username": "gd4niele",
                        "content": "this problem is way much easier than the yesterday\\'s one"
                    },
                    {
                        "username": "gd4niele",
                        "content": "[@lucasscodes](/lucasscodes) no i did O(log(n + m))"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you did it wrong and used O(n+m).\\nthis will fail your interview"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### median is data point not fractional value."
                    },
                    {
                        "username": "psionl0",
                        "content": "It would not be possible to return a median if the array was an even size under your definition. All my life I have been taught that for an even number of elements, the median is the average of the two middle elements."
                    },
                    {
                        "username": "sakethrahulkoredla",
                        "content": "A median must be present in the data"
                    },
                    {
                        "username": "psionl0",
                        "content": "All my life I have been taught that this is not the case for an even number of elements."
                    }
                ]
            },
            {
                "id": 1566463,
                "content": [
                    {
                        "username": "volskrad13",
                        "content": "why the expected output of [1,2] is 1.0 ?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "centYY",
                        "content": "I think this question is too easy. I wrote it in 5 mins. So, I think the difficulty of it may be easy, not Hard."
                    },
                    {
                        "username": "aksshatkhanna25",
                        "content": "you are legend"
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "group link\\nhttps://chat.whatsapp.com/D1jVp7mN1q93NLnBtVwKb1"
                    },
                    {
                        "username": "realitant",
                        "content": "Why on earth is this marked as hard? The hardest part was avoiding off by 1 errors in the median function."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "You did it wrong, u got a complexity of O(n+m) and will fail the interview"
                    },
                    {
                        "username": "vikas_singhff",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int arr[] = new int[nums1.length+nums2.length];\\n        int j = 0;\\n        for(int i=0; i<nums1.length; i++) {\\n            arr[j++] = nums1[i];\\n        }\\n        for(int i:nums2) {\\n            arr[j++] = i;\\n        }\\n        Arrays.sort(arr);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int size = arr.length;\\n        if(size % 2 == 0) {\\n            list.add(arr[size/2]);\\n            list.add(arr[(size-1)/2]);\\n        }\\n        else {\\n            list.add(arr[size/2]);\\n        }\\n        int sum =0;\\n        for(int i:list) {\\n            sum =sum +i;\\n        }\\n\\n        return (double) sum/list.size();\\n    }\\n}"
                    },
                    {
                        "username": "gd4niele",
                        "content": "this problem is way much easier than the yesterday\\'s one"
                    },
                    {
                        "username": "gd4niele",
                        "content": "[@lucasscodes](/lucasscodes) no i did O(log(n + m))"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you did it wrong and used O(n+m).\\nthis will fail your interview"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### median is data point not fractional value."
                    },
                    {
                        "username": "psionl0",
                        "content": "It would not be possible to return a median if the array was an even size under your definition. All my life I have been taught that for an even number of elements, the median is the average of the two middle elements."
                    },
                    {
                        "username": "sakethrahulkoredla",
                        "content": "A median must be present in the data"
                    },
                    {
                        "username": "psionl0",
                        "content": "All my life I have been taught that this is not the case for an even number of elements."
                    }
                ]
            },
            {
                "id": 1575523,
                "content": [
                    {
                        "username": "volskrad13",
                        "content": "why the expected output of [1,2] is 1.0 ?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "centYY",
                        "content": "I think this question is too easy. I wrote it in 5 mins. So, I think the difficulty of it may be easy, not Hard."
                    },
                    {
                        "username": "aksshatkhanna25",
                        "content": "you are legend"
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "group link\\nhttps://chat.whatsapp.com/D1jVp7mN1q93NLnBtVwKb1"
                    },
                    {
                        "username": "realitant",
                        "content": "Why on earth is this marked as hard? The hardest part was avoiding off by 1 errors in the median function."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "You did it wrong, u got a complexity of O(n+m) and will fail the interview"
                    },
                    {
                        "username": "vikas_singhff",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int arr[] = new int[nums1.length+nums2.length];\\n        int j = 0;\\n        for(int i=0; i<nums1.length; i++) {\\n            arr[j++] = nums1[i];\\n        }\\n        for(int i:nums2) {\\n            arr[j++] = i;\\n        }\\n        Arrays.sort(arr);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int size = arr.length;\\n        if(size % 2 == 0) {\\n            list.add(arr[size/2]);\\n            list.add(arr[(size-1)/2]);\\n        }\\n        else {\\n            list.add(arr[size/2]);\\n        }\\n        int sum =0;\\n        for(int i:list) {\\n            sum =sum +i;\\n        }\\n\\n        return (double) sum/list.size();\\n    }\\n}"
                    },
                    {
                        "username": "gd4niele",
                        "content": "this problem is way much easier than the yesterday\\'s one"
                    },
                    {
                        "username": "gd4niele",
                        "content": "[@lucasscodes](/lucasscodes) no i did O(log(n + m))"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you did it wrong and used O(n+m).\\nthis will fail your interview"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### median is data point not fractional value."
                    },
                    {
                        "username": "psionl0",
                        "content": "It would not be possible to return a median if the array was an even size under your definition. All my life I have been taught that for an even number of elements, the median is the average of the two middle elements."
                    },
                    {
                        "username": "sakethrahulkoredla",
                        "content": "A median must be present in the data"
                    },
                    {
                        "username": "psionl0",
                        "content": "All my life I have been taught that this is not the case for an even number of elements."
                    }
                ]
            },
            {
                "id": 2067125,
                "content": [
                    {
                        "username": "volskrad13",
                        "content": "why the expected output of [1,2] is 1.0 ?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "centYY",
                        "content": "I think this question is too easy. I wrote it in 5 mins. So, I think the difficulty of it may be easy, not Hard."
                    },
                    {
                        "username": "aksshatkhanna25",
                        "content": "you are legend"
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "group link\\nhttps://chat.whatsapp.com/D1jVp7mN1q93NLnBtVwKb1"
                    },
                    {
                        "username": "realitant",
                        "content": "Why on earth is this marked as hard? The hardest part was avoiding off by 1 errors in the median function."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "You did it wrong, u got a complexity of O(n+m) and will fail the interview"
                    },
                    {
                        "username": "vikas_singhff",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int arr[] = new int[nums1.length+nums2.length];\\n        int j = 0;\\n        for(int i=0; i<nums1.length; i++) {\\n            arr[j++] = nums1[i];\\n        }\\n        for(int i:nums2) {\\n            arr[j++] = i;\\n        }\\n        Arrays.sort(arr);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int size = arr.length;\\n        if(size % 2 == 0) {\\n            list.add(arr[size/2]);\\n            list.add(arr[(size-1)/2]);\\n        }\\n        else {\\n            list.add(arr[size/2]);\\n        }\\n        int sum =0;\\n        for(int i:list) {\\n            sum =sum +i;\\n        }\\n\\n        return (double) sum/list.size();\\n    }\\n}"
                    },
                    {
                        "username": "gd4niele",
                        "content": "this problem is way much easier than the yesterday\\'s one"
                    },
                    {
                        "username": "gd4niele",
                        "content": "[@lucasscodes](/lucasscodes) no i did O(log(n + m))"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you did it wrong and used O(n+m).\\nthis will fail your interview"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### median is data point not fractional value."
                    },
                    {
                        "username": "psionl0",
                        "content": "It would not be possible to return a median if the array was an even size under your definition. All my life I have been taught that for an even number of elements, the median is the average of the two middle elements."
                    },
                    {
                        "username": "sakethrahulkoredla",
                        "content": "A median must be present in the data"
                    },
                    {
                        "username": "psionl0",
                        "content": "All my life I have been taught that this is not the case for an even number of elements."
                    }
                ]
            },
            {
                "id": 2066867,
                "content": [
                    {
                        "username": "volskrad13",
                        "content": "why the expected output of [1,2] is 1.0 ?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "centYY",
                        "content": "I think this question is too easy. I wrote it in 5 mins. So, I think the difficulty of it may be easy, not Hard."
                    },
                    {
                        "username": "aksshatkhanna25",
                        "content": "you are legend"
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "group link\\nhttps://chat.whatsapp.com/D1jVp7mN1q93NLnBtVwKb1"
                    },
                    {
                        "username": "realitant",
                        "content": "Why on earth is this marked as hard? The hardest part was avoiding off by 1 errors in the median function."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "You did it wrong, u got a complexity of O(n+m) and will fail the interview"
                    },
                    {
                        "username": "vikas_singhff",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int arr[] = new int[nums1.length+nums2.length];\\n        int j = 0;\\n        for(int i=0; i<nums1.length; i++) {\\n            arr[j++] = nums1[i];\\n        }\\n        for(int i:nums2) {\\n            arr[j++] = i;\\n        }\\n        Arrays.sort(arr);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int size = arr.length;\\n        if(size % 2 == 0) {\\n            list.add(arr[size/2]);\\n            list.add(arr[(size-1)/2]);\\n        }\\n        else {\\n            list.add(arr[size/2]);\\n        }\\n        int sum =0;\\n        for(int i:list) {\\n            sum =sum +i;\\n        }\\n\\n        return (double) sum/list.size();\\n    }\\n}"
                    },
                    {
                        "username": "gd4niele",
                        "content": "this problem is way much easier than the yesterday\\'s one"
                    },
                    {
                        "username": "gd4niele",
                        "content": "[@lucasscodes](/lucasscodes) no i did O(log(n + m))"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you did it wrong and used O(n+m).\\nthis will fail your interview"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### median is data point not fractional value."
                    },
                    {
                        "username": "psionl0",
                        "content": "It would not be possible to return a median if the array was an even size under your definition. All my life I have been taught that for an even number of elements, the median is the average of the two middle elements."
                    },
                    {
                        "username": "sakethrahulkoredla",
                        "content": "A median must be present in the data"
                    },
                    {
                        "username": "psionl0",
                        "content": "All my life I have been taught that this is not the case for an even number of elements."
                    }
                ]
            },
            {
                "id": 2066793,
                "content": [
                    {
                        "username": "volskrad13",
                        "content": "why the expected output of [1,2] is 1.0 ?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "centYY",
                        "content": "I think this question is too easy. I wrote it in 5 mins. So, I think the difficulty of it may be easy, not Hard."
                    },
                    {
                        "username": "aksshatkhanna25",
                        "content": "you are legend"
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "group link\\nhttps://chat.whatsapp.com/D1jVp7mN1q93NLnBtVwKb1"
                    },
                    {
                        "username": "realitant",
                        "content": "Why on earth is this marked as hard? The hardest part was avoiding off by 1 errors in the median function."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "You did it wrong, u got a complexity of O(n+m) and will fail the interview"
                    },
                    {
                        "username": "vikas_singhff",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int arr[] = new int[nums1.length+nums2.length];\\n        int j = 0;\\n        for(int i=0; i<nums1.length; i++) {\\n            arr[j++] = nums1[i];\\n        }\\n        for(int i:nums2) {\\n            arr[j++] = i;\\n        }\\n        Arrays.sort(arr);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int size = arr.length;\\n        if(size % 2 == 0) {\\n            list.add(arr[size/2]);\\n            list.add(arr[(size-1)/2]);\\n        }\\n        else {\\n            list.add(arr[size/2]);\\n        }\\n        int sum =0;\\n        for(int i:list) {\\n            sum =sum +i;\\n        }\\n\\n        return (double) sum/list.size();\\n    }\\n}"
                    },
                    {
                        "username": "gd4niele",
                        "content": "this problem is way much easier than the yesterday\\'s one"
                    },
                    {
                        "username": "gd4niele",
                        "content": "[@lucasscodes](/lucasscodes) no i did O(log(n + m))"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you did it wrong and used O(n+m).\\nthis will fail your interview"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### median is data point not fractional value."
                    },
                    {
                        "username": "psionl0",
                        "content": "It would not be possible to return a median if the array was an even size under your definition. All my life I have been taught that for an even number of elements, the median is the average of the two middle elements."
                    },
                    {
                        "username": "sakethrahulkoredla",
                        "content": "A median must be present in the data"
                    },
                    {
                        "username": "psionl0",
                        "content": "All my life I have been taught that this is not the case for an even number of elements."
                    }
                ]
            },
            {
                "id": 2066569,
                "content": [
                    {
                        "username": "volskrad13",
                        "content": "why the expected output of [1,2] is 1.0 ?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "centYY",
                        "content": "I think this question is too easy. I wrote it in 5 mins. So, I think the difficulty of it may be easy, not Hard."
                    },
                    {
                        "username": "aksshatkhanna25",
                        "content": "you are legend"
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "group link\\nhttps://chat.whatsapp.com/D1jVp7mN1q93NLnBtVwKb1"
                    },
                    {
                        "username": "realitant",
                        "content": "Why on earth is this marked as hard? The hardest part was avoiding off by 1 errors in the median function."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "You did it wrong, u got a complexity of O(n+m) and will fail the interview"
                    },
                    {
                        "username": "vikas_singhff",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int arr[] = new int[nums1.length+nums2.length];\\n        int j = 0;\\n        for(int i=0; i<nums1.length; i++) {\\n            arr[j++] = nums1[i];\\n        }\\n        for(int i:nums2) {\\n            arr[j++] = i;\\n        }\\n        Arrays.sort(arr);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int size = arr.length;\\n        if(size % 2 == 0) {\\n            list.add(arr[size/2]);\\n            list.add(arr[(size-1)/2]);\\n        }\\n        else {\\n            list.add(arr[size/2]);\\n        }\\n        int sum =0;\\n        for(int i:list) {\\n            sum =sum +i;\\n        }\\n\\n        return (double) sum/list.size();\\n    }\\n}"
                    },
                    {
                        "username": "gd4niele",
                        "content": "this problem is way much easier than the yesterday\\'s one"
                    },
                    {
                        "username": "gd4niele",
                        "content": "[@lucasscodes](/lucasscodes) no i did O(log(n + m))"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you did it wrong and used O(n+m).\\nthis will fail your interview"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### median is data point not fractional value."
                    },
                    {
                        "username": "psionl0",
                        "content": "It would not be possible to return a median if the array was an even size under your definition. All my life I have been taught that for an even number of elements, the median is the average of the two middle elements."
                    },
                    {
                        "username": "sakethrahulkoredla",
                        "content": "A median must be present in the data"
                    },
                    {
                        "username": "psionl0",
                        "content": "All my life I have been taught that this is not the case for an even number of elements."
                    }
                ]
            },
            {
                "id": 2064770,
                "content": [
                    {
                        "username": "volskrad13",
                        "content": "why the expected output of [1,2] is 1.0 ?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/find-median-of-two-sorted-arrays-leetcode-solutions/"
                    },
                    {
                        "username": "centYY",
                        "content": "I think this question is too easy. I wrote it in 5 mins. So, I think the difficulty of it may be easy, not Hard."
                    },
                    {
                        "username": "aksshatkhanna25",
                        "content": "you are legend"
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "group link\\nhttps://chat.whatsapp.com/D1jVp7mN1q93NLnBtVwKb1"
                    },
                    {
                        "username": "realitant",
                        "content": "Why on earth is this marked as hard? The hardest part was avoiding off by 1 errors in the median function."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "You did it wrong, u got a complexity of O(n+m) and will fail the interview"
                    },
                    {
                        "username": "vikas_singhff",
                        "content": "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int arr[] = new int[nums1.length+nums2.length];\\n        int j = 0;\\n        for(int i=0; i<nums1.length; i++) {\\n            arr[j++] = nums1[i];\\n        }\\n        for(int i:nums2) {\\n            arr[j++] = i;\\n        }\\n        Arrays.sort(arr);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int size = arr.length;\\n        if(size % 2 == 0) {\\n            list.add(arr[size/2]);\\n            list.add(arr[(size-1)/2]);\\n        }\\n        else {\\n            list.add(arr[size/2]);\\n        }\\n        int sum =0;\\n        for(int i:list) {\\n            sum =sum +i;\\n        }\\n\\n        return (double) sum/list.size();\\n    }\\n}"
                    },
                    {
                        "username": "gd4niele",
                        "content": "this problem is way much easier than the yesterday\\'s one"
                    },
                    {
                        "username": "gd4niele",
                        "content": "[@lucasscodes](/lucasscodes) no i did O(log(n + m))"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you did it wrong and used O(n+m).\\nthis will fail your interview"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### median is data point not fractional value."
                    },
                    {
                        "username": "psionl0",
                        "content": "It would not be possible to return a median if the array was an even size under your definition. All my life I have been taught that for an even number of elements, the median is the average of the two middle elements."
                    },
                    {
                        "username": "sakethrahulkoredla",
                        "content": "A median must be present in the data"
                    },
                    {
                        "username": "psionl0",
                        "content": "All my life I have been taught that this is not the case for an even number of elements."
                    }
                ]
            }
        ]
    }
]