[
    {
        "title": "Loud and Rich",
        "question_content": "There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness.\nYou are given an array richer where richer[i] = [ai, bi] indicates that ai has more money than bi and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time).\nReturn an integer array answer where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x.\n&nbsp;\nExample 1:\n\nInput: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\nOutput: [5,5,2,5,4,5,6,7]\nExplanation: \nanswer[0] = 5.\nPerson 5 has more money than 3, which has more money than 1, which has more money than 0.\nThe only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0.\nanswer[7] = 7.\nAmong all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.\nThe other answers can be filled out with similar reasoning.\n\nExample 2:\n\nInput: richer = [], quiet = [0]\nOutput: [0]\n\n&nbsp;\nConstraints:\n\n\tn == quiet.length\n\t1 <= n <= 500\n\t0 <= quiet[i] < n\n\tAll the values of quiet are unique.\n\t0 <= richer.length <= n * (n - 1) / 2\n\t0 <= ai, bi < n\n\tai != bi\n\tAll the pairs of richer are unique.\n\tThe observations in richer are all logically consistent.",
        "solutions": [
            {
                "id": 137918,
                "title": "c-java-python-concise-dfs",
                "content": "**Explanation**:\\nThe description is not easy to understand.\\nIn fact it\\'s a basic dfs traversal problem.\\nFor every people, call a sub function `dfs` to compare the `quiet` with others, who is richer than him.\\nAlso we will note this answer to avoid repeated calculation.\\n\\n\\n**Time Complexity**:\\nO(richer.length),\\nSub function `dfs` traverse every people only once, and every `richer` is traversed only one once.\\n\\n**C++:**\\n```\\n    unordered_map<int, vector<int>> richer2;\\n    vector<int> res;\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        for (auto v : richer) richer2[v[1]].push_back(v[0]);\\n        res = vector<int> (quiet.size(), -1);\\n        for (int i = 0; i < quiet.size(); i++) dfs(i, quiet);\\n        return res;\\n    }\\n\\n    int dfs(int i, vector<int>& quiet) {\\n        if (res[i] >= 0) return res[i];\\n        res[i] = i;\\n        for (int j : richer2[i]) if (quiet[res[i]] > quiet[dfs(j, quiet)]) res[i] = res[j];\\n        return res[i];\\n    }\\n```\\n\\n**Java:**\\n```\\n    HashMap<Integer, List<Integer>> richer2 = new HashMap<>();\\n    int res[];\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        for (int i = 0; i < n; ++i) richer2.put(i, new ArrayList<Integer>());\\n        for (int[] v : richer) richer2.get(v[1]).add(v[0]);\\n        res = new int[n]; Arrays.fill(res, -1);\\n        for (int i = 0; i < n; i++) dfs(i, quiet);\\n        return res;\\n    }\\n\\n    int dfs(int i, int[] quiet) {\\n        if (res[i] >= 0) return res[i];\\n        res[i] = i;\\n        for (int j : richer2.get(i)) if (quiet[res[i]] > quiet[dfs(j, quiet)]) res[i] = res[j];\\n        return res[i];\\n    }\\n```\\n\\n**Python:**\\n```\\nclass Solution(object):\\n\\n    def loudAndRich(self, richer, quiet):\\n        m = collections.defaultdict(list)\\n        for i, j in richer: m[j].append(i)\\n        res = [-1] * len(quiet)\\n\\n        def dfs(i):\\n            if res[i] >= 0: return res[i]\\n            res[i] = i\\n            for j in m[i]:\\n                if quiet[res[i]] > quiet[dfs(j)]: res[i] = res[j]\\n            return res[i]\\n\\n        for i in range(len(quiet)): dfs(i)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    unordered_map<int, vector<int>> richer2;\\n    vector<int> res;\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        for (auto v : richer) richer2[v[1]].push_back(v[0]);\\n        res = vector<int> (quiet.size(), -1);\\n        for (int i = 0; i < quiet.size(); i++) dfs(i, quiet);\\n        return res;\\n    }\\n\\n    int dfs(int i, vector<int>& quiet) {\\n        if (res[i] >= 0) return res[i];\\n        res[i] = i;\\n        for (int j : richer2[i]) if (quiet[res[i]] > quiet[dfs(j, quiet)]) res[i] = res[j];\\n        return res[i];\\n    }\\n```\n```\\n    HashMap<Integer, List<Integer>> richer2 = new HashMap<>();\\n    int res[];\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        for (int i = 0; i < n; ++i) richer2.put(i, new ArrayList<Integer>());\\n        for (int[] v : richer) richer2.get(v[1]).add(v[0]);\\n        res = new int[n]; Arrays.fill(res, -1);\\n        for (int i = 0; i < n; i++) dfs(i, quiet);\\n        return res;\\n    }\\n\\n    int dfs(int i, int[] quiet) {\\n        if (res[i] >= 0) return res[i];\\n        res[i] = i;\\n        for (int j : richer2.get(i)) if (quiet[res[i]] > quiet[dfs(j, quiet)]) res[i] = res[j];\\n        return res[i];\\n    }\\n```\n```\\nclass Solution(object):\\n\\n    def loudAndRich(self, richer, quiet):\\n        m = collections.defaultdict(list)\\n        for i, j in richer: m[j].append(i)\\n        res = [-1] * len(quiet)\\n\\n        def dfs(i):\\n            if res[i] >= 0: return res[i]\\n            res[i] = i\\n            for j in m[i]:\\n                if quiet[res[i]] > quiet[dfs(j)]: res[i] = res[j]\\n            return res[i]\\n\\n        for i in range(len(quiet)): dfs(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138088,
                "title": "c-with-topological-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        const int N = quiet.size();\\n        vector<vector<int>> graph(N);\\n        vector<int> indegrees(N, 0);\\n        for (auto& r : richer) {\\n            ++indegrees[r[1]];\\n            graph[r[0]].push_back(r[1]);\\n        }\\n        \\n        deque<int> q;\\n        for (int i = 0; i < indegrees.size(); ++i) {\\n            if (indegrees[i] == 0) {\\n                q.push_back(i);\\n            }\\n        }\\n        \\n        vector<int> answers(N);\\n        iota(answers.begin(), answers.end(), 0);\\n        while (!q.empty()) {\\n            auto idx = q.front();\\n            q.pop_front();\\n            for (auto next : graph[idx]) {\\n                if (quiet[answers[next]] > quiet[answers[idx]]) {\\n                    answers[next] = answers[idx];\\n                }\\n                if (--indegrees[next] == 0) {\\n                    q.push_back(next);\\n                }\\n            }\\n        }\\n        return answers;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        const int N = quiet.size();\\n        vector<vector<int>> graph(N);\\n        vector<int> indegrees(N, 0);\\n        for (auto& r : richer) {\\n            ++indegrees[r[1]];\\n            graph[r[0]].push_back(r[1]);\\n        }\\n        \\n        deque<int> q;\\n        for (int i = 0; i < indegrees.size(); ++i) {\\n            if (indegrees[i] == 0) {\\n                q.push_back(i);\\n            }\\n        }\\n        \\n        vector<int> answers(N);\\n        iota(answers.begin(), answers.end(), 0);\\n        while (!q.empty()) {\\n            auto idx = q.front();\\n            q.pop_front();\\n            for (auto next : graph[idx]) {\\n                if (quiet[answers[next]] > quiet[answers[idx]]) {\\n                    answers[next] = answers[idx];\\n                }\\n                if (--indegrees[next] == 0) {\\n                    q.push_back(next);\\n                }\\n            }\\n        }\\n        return answers;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366657,
                "title": "c-bfs-topological-sort-indegree-commented-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        \\n        //build graph and calculate indegrees\\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n       \\n        //initialise ans array and push nodes with 0 degrees into queue\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            \\n            for(int i : g[curr]){\\n                //if parent node having more money is quieter , update\\n                if(ans[i] == INT_MAX || quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                \\n                if(--indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        \\n        //build graph and calculate indegrees\\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n       \\n        //initialise ans array and push nodes with 0 degrees into queue\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            \\n            for(int i : g[curr]){\\n                //if parent node having more money is quieter , update\\n                if(ans[i] == INT_MAX || quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                \\n                if(--indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980153,
                "title": "c-kahn-s-algo-bfs-traversal-with-comments-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor any person, we look for all the person who is equally rich or richer than them and then we select the quietest among these set of richer people.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(V+E), [V->Number of Nodes, E->Number of Edges]\\n\\n- Space complexity:\\nO(V)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        \\n        //build graph and calculate indegrees\\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n       \\n        //initialise ans array and push nodes with 0 degrees into queue\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            \\n            for(int i : g[curr]){\\n                //if parent node having more money is quieter , update\\n                if(ans[i] == INT_MAX || quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                \\n                if(--indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![9b3e244e-2239-4981-9d94-3578491ea5ed_1672392871.6117275.png](https://assets.leetcode.com/users/images/b5b09507-cc27-4673-b636-1163a6c08831_1672595757.4628367.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        \\n        //build graph and calculate indegrees\\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n       \\n        //initialise ans array and push nodes with 0 degrees into queue\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            \\n            for(int i : g[curr]){\\n                //if parent node having more money is quieter , update\\n                if(ans[i] == INT_MAX || quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                \\n                if(--indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 266859,
                "title": "python-cached-dfs",
                "content": "We want to find the least quiet person that\\'s richer or equal rich to our target. So we can convert the ```richer``` to a directed graph. \\n\\nEach child node is the richer person in the relationship. So when we search from our target node, all the node we visited in such directed graph will be richer persons than our target. And we just find out the least quite one from them.\\n\\nThus, we can use DFS here to collect all children nodes and target node itself (since our target node might be the richest node or all of its children nodes are quieter than itself). Then we just pick out the least quite one (```min(candidates, key=lambda x:quiet[x]```)).\\n\\nAnd previous searched result can be cached and reused. We can just save it in our answer array.\\n```\\ndef loudAndRich(richer, quiet):\\n\\tg, loud = collections.defaultdict(set), [-1]*len(quiet)\\n\\tfor u, v in richer: g[v].add(u)\\n\\tdef dfs(node):\\n\\t\\tif loud[node] < 0: loud[node] = min([dfs(nei) for nei in g[node]]+[node], key=lambda x:quiet[x])\\n\\t\\treturn loud[node]\\n\\treturn list(map(dfs, range(len(quiet))))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```richer```\n```min(candidates, key=lambda x:quiet[x]```\n```\\ndef loudAndRich(richer, quiet):\\n\\tg, loud = collections.defaultdict(set), [-1]*len(quiet)\\n\\tfor u, v in richer: g[v].add(u)\\n\\tdef dfs(node):\\n\\t\\tif loud[node] < 0: loud[node] = min([dfs(nei) for nei in g[node]]+[node], key=lambda x:quiet[x])\\n\\t\\treturn loud[node]\\n\\treturn list(map(dfs, range(len(quiet))))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2502004,
                "title": "c-easy-bfs-topological-sort",
                "content": "Read the last paragraph of the question: answer[x] = y if y is the least quiet person among all people who definitely have equal to or more money than the person x\\n**EXPLANATION**:\\nFor any person, we look for all the person who is equally rich or richer than them and then we select the quietest among these set of richer people.\\n**Example**: Richness order: x>y, z>y, w>v. Then we can\\'t decide who is the richest among x,z & w b/c we don\\'t have proper information regarding their comparison. So we assume that all of them are richest.\\nFor any \\'a\\' who is richest we don\\'t have any \\'b\\' who is richer or equally rich, so we have only \\'a\\' himself the only candidate to be checked for quietest so ans[a] = a.\\nThus we use topological sort here in such a way that richest are the least dependent (no indegree)\\n\\nThen the lesser rich will see if the ans of richer one is quieter than his ans(no comparison of richness b/c richness order: ans[richer] >= richer & richer >= lesser rich so obviously ans[richer] >= lesser rich). If yes then he will replace his answer with the ans[richer].\\n\\n**If it helps please UPVOTE! and let others also know**\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) //topological sort\\n    {\\n        int n = quiet.size();\\n        vector<int> ans(n), adj[n], indegree(n,0);\\n        queue<int> q;\\n        int v;\\n        \\n        for(auto r: richer)\\n        {\\n            adj[r[0]].push_back(r[1]);\\n            indegree[r[1]]++;\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            ans[i] = i;\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty())   //BFS topo sort\\n        {\\n            v = q.front(), q.pop();\\n            \\n            for(auto u: adj[v])\\n            {\\n                if(quiet[ans[v]] < quiet[ans[u]])  //v is richer than u and b/c ans[v] can also be some other value than v which is more rich and is quietest and quieter than ans[u] then ans[u] will be ans[v]\\n                    ans[u] = ans[v];\\n                if(--indegree[u] == 0)\\n                    q.push(u);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) //topological sort\\n    {\\n        int n = quiet.size();\\n        vector<int> ans(n), adj[n], indegree(n,0);\\n        queue<int> q;\\n        int v;\\n        \\n        for(auto r: richer)\\n        {\\n            adj[r[0]].push_back(r[1]);\\n            indegree[r[1]]++;\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            ans[i] = i;\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty())   //BFS topo sort\\n        {\\n            v = q.front(), q.pop();\\n            \\n            for(auto u: adj[v])\\n            {\\n                if(quiet[ans[v]] < quiet[ans[u]])  //v is richer than u and b/c ans[v] can also be some other value than v which is more rich and is quietest and quieter than ans[u] then ans[u] will be ans[v]\\n                    ans[u] = ans[v];\\n                if(--indegree[u] == 0)\\n                    q.push(u);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038943,
                "title": "java-solution-dfs-memoization-o-n-2-beats-100-5ms",
                "content": "\\n    public static int[] loudAndRich(int[][] richer, int[] quiet) {\\n\\t\\tint n = quiet.length;\\n\\t\\tList<Integer>[] graph = new ArrayList[n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tgraph[i] = new ArrayList<Integer>();\\n\\n\\t\\tfor (int[] rich : richer)\\n\\t\\t\\tgraph[rich[1]].add(rich[0]);\\n\\n\\t\\tint[] ans = new int[n];\\n\\t\\tboolean[] visited = new boolean[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (!visited[i])\\n\\t\\t\\t\\tloudAndRich(n, i, graph, visited, ans, quiet);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic static int loudAndRich(int n, int src, List<Integer>[] graph, boolean[] visited, int[] ans, int[] quiet) {\\n\\n\\t\\tif (visited[src])\\n\\t\\t\\treturn ans[src];\\n\\n\\t\\tvisited[src] = true;\\n\\t\\tList<Integer> nbrs = graph[src];\\n\\t\\tint min = quiet[src];\\n\\t\\tint person = src;\\n\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\tint p = loudAndRich(n, nbr, graph, visited, ans, quiet);\\n\\t\\t\\tif (quiet[p] < min) {\\n\\t\\t\\t\\tmin = quiet[p];\\n\\t\\t\\t\\tperson = p;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans[src] = person;\\n\\t\\treturn person;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    public static int[] loudAndRich(int[][] richer, int[] quiet) {\\n\\t\\tint n = quiet.length;\\n\\t\\tList<Integer>[] graph = new ArrayList[n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tgraph[i] = new ArrayList<Integer>();\\n\\n\\t\\tfor (int[] rich : richer)\\n\\t\\t\\tgraph[rich[1]].add(rich[0]);\\n\\n\\t\\tint[] ans = new int[n];\\n\\t\\tboolean[] visited = new boolean[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (!visited[i])\\n\\t\\t\\t\\tloudAndRich(n, i, graph, visited, ans, quiet);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic static int loudAndRich(int n, int src, List<Integer>[] graph, boolean[] visited, int[] ans, int[] quiet) {\\n\\n\\t\\tif (visited[src])\\n\\t\\t\\treturn ans[src];\\n\\n\\t\\tvisited[src] = true;\\n\\t\\tList<Integer> nbrs = graph[src];\\n\\t\\tint min = quiet[src];\\n\\t\\tint person = src;\\n\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\tint p = loudAndRich(n, nbr, graph, visited, ans, quiet);\\n\\t\\t\\tif (quiet[p] < min) {\\n\\t\\t\\t\\tmin = quiet[p];\\n\\t\\t\\t\\tperson = p;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans[src] = person;\\n\\t\\treturn person;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 510945,
                "title": "c-dfs-clean-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int size = quiet.size();\\n        vector<vector<int>> graph(size);\\n        vector<int> ans(size, -1);\\n        // Constructs Graph\\n        for (auto rich : richer) {\\n            graph[rich[1]].push_back(rich[0]);\\n        }\\n        // Run DFS for each person on Graph\\n        for (int i = 0; i < size; i++) {\\n            dfs(graph, quiet, ans, i);\\n        }\\n        return ans;\\n    }\\n\\n    int dfs(vector<vector<int>> &graph, vector<int> &quiet, vector<int> &ans, int currentPerson) {\\n        // Check and return whether if the answer is already calculated or not\\n        if (ans[currentPerson] >= 0) {\\n            return ans[currentPerson];\\n        }\\n        // Save at least person\\'s value itself in case that no richer and least loud person found in search\\n        ans[currentPerson] = currentPerson;\\n        for (auto child : graph[currentPerson]) {\\n            if (quiet[dfs(graph, quiet, ans, child)] < quiet[ans[currentPerson]]) {\\n                ans[currentPerson] = ans[child];\\n            }\\n        }\\n        return ans[currentPerson];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int size = quiet.size();\\n        vector<vector<int>> graph(size);\\n        vector<int> ans(size, -1);\\n        // Constructs Graph\\n        for (auto rich : richer) {\\n            graph[rich[1]].push_back(rich[0]);\\n        }\\n        // Run DFS for each person on Graph\\n        for (int i = 0; i < size; i++) {\\n            dfs(graph, quiet, ans, i);\\n        }\\n        return ans;\\n    }\\n\\n    int dfs(vector<vector<int>> &graph, vector<int> &quiet, vector<int> &ans, int currentPerson) {\\n        // Check and return whether if the answer is already calculated or not\\n        if (ans[currentPerson] >= 0) {\\n            return ans[currentPerson];\\n        }\\n        // Save at least person\\'s value itself in case that no richer and least loud person found in search\\n        ans[currentPerson] = currentPerson;\\n        for (auto child : graph[currentPerson]) {\\n            if (quiet[dfs(graph, quiet, ans, child)] < quiet[ans[currentPerson]]) {\\n                ans[currentPerson] = ans[child];\\n            }\\n        }\\n        return ans[currentPerson];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241019,
                "title": "python-topological-sort-solution",
                "content": "Thanks for the visit. Below is the code for the python solution with topological sort. Basically, I formed graph where the direction of edge is from the node with richer to the one that is less rich. I then performed simple topological sort where I updated each item\\'s corresponding quiettest and richer node. \\n\\n\\n\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        length = len(quiet)\\n        arr = [i for i in range(length)]\\n        indegree = [0 for _ in range(length)]\\n        graph = collections.defaultdict(list)\\n        dq = collections.deque([])\\n        \\n        for a, b in richer:\\n            # Note that the graph is uni-directional\\n            graph[a].append(b)\\n            indegree[b] += 1\\n\\n        for i in range(length):\\n            if not indegree[i]: \\n                dq.append(i)\\n    \\n        while dq:\\n            node = dq.popleft()\\n            \\n            for vertex in graph[node]:\\n                indegree[vertex] -= 1\\n                if quiet[arr[node]] < quiet[arr[vertex]]:\\n                    arr[vertex] = arr[node]\\n                if not indegree[vertex]:\\n                    dq.append(vertex)\\n        return arr\\n```\\n\\nThanks for the visit, and I appreciate any comments.",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        length = len(quiet)\\n        arr = [i for i in range(length)]\\n        indegree = [0 for _ in range(length)]\\n        graph = collections.defaultdict(list)\\n        dq = collections.deque([])\\n        \\n        for a, b in richer:\\n            # Note that the graph is uni-directional\\n            graph[a].append(b)\\n            indegree[b] += 1\\n\\n        for i in range(length):\\n            if not indegree[i]: \\n                dq.append(i)\\n    \\n        while dq:\\n            node = dq.popleft()\\n            \\n            for vertex in graph[node]:\\n                indegree[vertex] -= 1\\n                if quiet[arr[node]] < quiet[arr[vertex]]:\\n                    arr[vertex] = arr[node]\\n                if not indegree[vertex]:\\n                    dq.append(vertex)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021757,
                "title": "java-topological-sort",
                "content": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        int[]res = new int[n];\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i=0;i<n;i++)\\n            graph[i] = new ArrayList<>();\\n        Arrays.fill(res,-1);\\n        int[]indegree = new int[n];\\n        for(int[]edge : richer){\\n            graph[edge[0]].add(edge[1]);\\n            indegree[edge[1]]++;\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0) q.add(i);\\n            res[i] = i;\\n        }\\n        while(!q.isEmpty()){\\n            int u = q.poll();\\n            for(int v : graph[u]){\\n                if(quiet[v]>quiet[u]){\\n                    quiet[v] = quiet[u];\\n                    res[v]=res[u];\\n                }\\n                indegree[v]--;\\n                if(indegree[v]==0) q.offer(v);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        int[]res = new int[n];\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i=0;i<n;i++)\\n            graph[i] = new ArrayList<>();\\n        Arrays.fill(res,-1);\\n        int[]indegree = new int[n];\\n        for(int[]edge : richer){\\n            graph[edge[0]].add(edge[1]);\\n            indegree[edge[1]]++;\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0) q.add(i);\\n            res[i] = i;\\n        }\\n        while(!q.isEmpty()){\\n            int u = q.poll();\\n            for(int v : graph[u]){\\n                if(quiet[v]>quiet[u]){\\n                    quiet[v] = quiet[u];\\n                    res[v]=res[u];\\n                }\\n                indegree[v]--;\\n                if(indegree[v]==0) q.offer(v);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731706,
                "title": "dfs-92ms-faster-than-96-05-bfs-kahn-algorithm-88ms-faster-than-98-03-topo-sort",
                "content": "Upvote if is\\'s helpful\\n\\nDFS:\\n\\n\\tclass Solution {\\n\\tpublic:\\n    \\n\\t\\tvector<vector<int>> graph;\\n\\t\\tvector<int> ans;\\n    \\n\\t\\tvoid dfs(int &current, vector<int> &quiet) {\\n        \\n\\t\\t\\tans[current] = current;\\n\\n\\t\\t\\tfor(auto &neighbour : graph[current]) {\\n\\t\\t\\t\\tif(ans[neighbour] == -1) \\n\\t\\t\\t\\t\\tdfs(neighbour, quiet);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(quiet[ans[current]] > quiet[ans[neighbour]])\\n\\t\\t\\t\\t\\tans[current] = ans[neighbour];\\n\\t\\t\\t}\\n        \\n\\t\\t}\\n    \\n\\t\\tvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n\\t\\t\\tint n = quiet.size();\\n\\t\\t\\tgraph.resize(n);\\n\\t\\t\\tans.resize(n, -1);\\n        \\n\\t\\t\\tfor(auto &pair : richer)\\n\\t\\t\\t\\tgraph[pair[1]].push_back(pair[0]);\\n        \\n\\t\\t\\tfor(int person = 0; person < n; person++) {\\n\\t\\t\\t\\tif(ans[person] == -1)\\n\\t\\t\\t\\t\\tdfs(person, quiet);\\n\\t\\t\\t}\\n        \\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\nBFS Kahn algorithm:\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t\\n\\t\\tvector<vector<int>> graph;\\n\\t\\tvector<int> ans;\\n\\t\\tvector<int> in_degree;\\n    \\n\\t\\tvoid kahn(vector<int> &quiet) {\\n        \\n\\t\\t\\tqueue<int> adj;\\n        \\n\\t\\t\\tfor(int person = 0; person < ans.size(); person++) {\\n\\t\\t\\t\\tif(in_degree[person]==0) {\\n\\t\\t\\t\\t\\tadj.push(person);\\n\\t\\t\\t\\t\\tans[person] = person;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        \\n\\t\\t\\twhile(!adj.empty()) {\\n\\t\\t\\t\\tint current = adj.front();\\n\\t\\t\\t\\tadj.pop();\\n            \\n\\t\\t\\t\\tfor(auto &child:graph[current]) {\\n\\t\\t\\t\\t\\tif(ans[child] == -1) \\n\\t\\t\\t\\t\\t\\tans[child] = child;\\n                \\n\\t\\t\\t\\t\\tif(quiet[ans[child]] > quiet[ans[current]])\\n\\t\\t\\t\\t\\t\\tans[child] = ans[current];\\n                \\n\\t\\t\\t\\t\\tin_degree[child]--;\\n\\t\\t\\t\\t\\tif(in_degree[child] == 0)\\n\\t\\t\\t\\t\\t\\tadj.push(child);\\n                \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n    \\n\\t\\tvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n\\t\\t\\tint n = quiet.size();\\n\\t\\t\\tgraph.resize(n);\\n\\t\\t\\tans.resize(n, -1);\\n\\t\\t\\tin_degree.resize(n);\\n        \\n\\t\\t\\tfor(auto &pair : richer){\\n\\t\\t\\t\\tgraph[pair[0]].push_back(pair[1]);\\n\\t\\t\\t\\tin_degree[pair[1]]++;\\n\\t\\t\\t}\\n        \\n\\t\\t\\tkahn(quiet);\\n\\t\\t\\t\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    \\n\\t\\tvector<vector<int>> graph;\\n\\t\\tvector<int> ans;\\n    \\n\\t\\tvoid dfs(int &current, vector<int> &quiet) {\\n        \\n\\t\\t\\tans[current] = current;\\n\\n\\t\\t\\tfor(auto &neighbour : graph[current]) {\\n\\t\\t\\t\\tif(ans[neighbour] == -1) \\n\\t\\t\\t\\t\\tdfs(neighbour, quiet);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(quiet[ans[current]] > quiet[ans[neighbour]])\\n\\t\\t\\t\\t\\tans[current] = ans[neighbour];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 707952,
                "title": "python-3-dfs-recursive-solution",
                "content": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        @lru_cache(None)\\n        def dfs(node):\\n            if node not in graph:\\n                return node\\n            minimum = node\\n            for neighbour in graph[node]:\\n                candidate = dfs(neighbour)\\n                if quiet[minimum] > quiet[candidate]:\\n                    minimum = candidate \\n            return minimum  \\n        n = len(quiet)\\n        graph = defaultdict(list)\\n        for u , v in richer:\\n            graph[v].append(u)\\n        return list(map(dfs , range(n)))\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        @lru_cache(None)\\n        def dfs(node):\\n            if node not in graph:\\n                return node\\n            minimum = node\\n            for neighbour in graph[node]:\\n                candidate = dfs(neighbour)\\n                if quiet[minimum] > quiet[candidate]:\\n                    minimum = candidate \\n            return minimum  \\n        n = len(quiet)\\n        graph = defaultdict(list)\\n        for u , v in richer:\\n            graph[v].append(u)\\n        return list(map(dfs , range(n)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725152,
                "title": "easy-c-topo-sort-solution-with-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        int n = q.size();\\n        vector<int> adj[n];\\n        vector<int> ind(n,0);\\n        for(auto it:r)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            ind[it[1]]++;\\n        }\\n        queue<int> qu;\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[i] == 0)\\n            qu.push(i);\\n            ans[i]=i;\\n        }\\n        while(!qu.empty())\\n        {\\n            int node = qu.front();\\n            qu.pop();\\n            for(auto it:adj[node])\\n            {\\n                if(q[node]<q[it])\\n                {\\n                    q[it]=q[node];\\n                    ans[it]=ans[node];\\n                }\\n                ind[it]--;\\n                if(ind[it] == 0)\\n                qu.push(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        int n = q.size();\\n        vector<int> adj[n];\\n        vector<int> ind(n,0);\\n        for(auto it:r)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            ind[it[1]]++;\\n        }\\n        queue<int> qu;\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[i] == 0)\\n            qu.push(i);\\n            ans[i]=i;\\n        }\\n        while(!qu.empty())\\n        {\\n            int node = qu.front();\\n            qu.pop();\\n            for(auto it:adj[node])\\n            {\\n                if(q[node]<q[it])\\n                {\\n                    q[it]=q[node];\\n                    ans[it]=ans[node];\\n                }\\n                ind[it]--;\\n                if(ind[it] == 0)\\n                qu.push(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618768,
                "title": "c-easy-to-understand-dfs-2-approaches",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    int dfs(int node,vector<vector<int> > &graph,vector<int> quiet,vector<int> &ans)\\n    {\\n        if(ans[node]!=-1)\\n        return ans[node];\\n        else\\n        {\\n        //storing the node\\'s value as ans for the time being\\n        ans[node]=node;\\n        for(auto child:graph[node])\\n        {\\n            //finding the minimum quitenss for the child connected to the node and storing the ans for the child to the ans for the node(if quitesness of node is not lesser than that)\\n            if(quiet[dfs(child,graph,quiet,ans)]<quiet[ans[node]])\\n            {\\n                ans[node]=ans[child];\\n            }\\n        }\\n        }\\n        return ans[node];\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        //constructing the graph\\n        int n=quiet.size();\\n        vector<vector<int>> graph(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            graph[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            //calling dfs func. for each of the nodes\\n            dfs(i,graph,quiet,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Using topological sort**\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> indegree(n,0);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++)\\n        ans[i]=i;\\n        vector<vector<int> > graph(n);\\n        for(auto &x:richer)\\n        {\\n            graph[x[0]].push_back(x[1]);\\n            indegree[x[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]==0)\\n            q.push(i);\\n        }\\n        while(!q.empty())\\n        {\\n            int element=q.front();\\n            q.pop();\\n            for(int node:graph[element])\\n            {\\n                if(quiet[ans[node]]>quiet[ans[element]])\\n                {\\n                    ans[node]=ans[element];\\n                }\\n                indegree[node]--;\\n                if(indegree[node]==0)\\n                q.push(node);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node,vector<vector<int> > &graph,vector<int> quiet,vector<int> &ans)\\n    {\\n        if(ans[node]!=-1)\\n        return ans[node];\\n        else\\n        {\\n        //storing the node\\'s value as ans for the time being\\n        ans[node]=node;\\n        for(auto child:graph[node])\\n        {\\n            //finding the minimum quitenss for the child connected to the node and storing the ans for the child to the ans for the node(if quitesness of node is not lesser than that)\\n            if(quiet[dfs(child,graph,quiet,ans)]<quiet[ans[node]])\\n            {\\n                ans[node]=ans[child];\\n            }\\n        }\\n        }\\n        return ans[node];\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        //constructing the graph\\n        int n=quiet.size();\\n        vector<vector<int>> graph(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            graph[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            //calling dfs func. for each of the nodes\\n            dfs(i,graph,quiet,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> indegree(n,0);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++)\\n        ans[i]=i;\\n        vector<vector<int> > graph(n);\\n        for(auto &x:richer)\\n        {\\n            graph[x[0]].push_back(x[1]);\\n            indegree[x[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]==0)\\n            q.push(i);\\n        }\\n        while(!q.empty())\\n        {\\n            int element=q.front();\\n            q.pop();\\n            for(int node:graph[element])\\n            {\\n                if(quiet[ans[node]]>quiet[ans[element]])\\n                {\\n                    ans[node]=ans[element];\\n                }\\n                indegree[node]--;\\n                if(indegree[node]==0)\\n                q.push(node);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588417,
                "title": "java-dfs-topological-sort-using-adjacency-list-in-o-n-time",
                "content": "Runtime: 9 ms, faster than 61.89% of Java online submissions for Loud and Rich.\\nMemory Usage: 61.6 MB, less than 16.78% of Java online submissions for Loud and Rich.\\n\\n\\n\\n```\\n// Time O(N)\\n// Space O(N)\\n\\nclass Solution {\\n    \\n     List<Integer>[] graph;\\n         \\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        \\n        int n = quiet.length;\\n        if(quiet == null || n == 0) return new int[0];\\n        \\n        //initialize graph with adjacency list\\n        graph = new ArrayList[n];\\n        \\n         for(int node = 0; node < graph.length; node++)\\n            graph[node] = new ArrayList<>();\\n        \\n        //build graph: poor -> rich\\n        for(int i = 0; i < richer.length; i++){\\n            graph[richer[i][1]].add(richer[i][0]);\\n        }\\n        \\n        //answer array\\n        int[] answer = new int[n];\\n        Arrays.fill(answer, -1);\\n        \\n        \\n        for(int i = 0; i < n; i++){\\n            dfs(i, answer, quiet);\\n        }\\n        return answer;\\n\\n    }\\n    \\n    \\n    public int dfs(int node, int[] answer, int[] quiet){\\n        \\n        //filling result array with -1 initially will avoid repetion here\\n        if (answer[node] == -1){\\n            answer[node] = node;\\n            \\n            //depthwise check for every richer person if they are quieter\\n            for (int child: graph[node]){\\n                \\n                int curr = dfs(child, answer, quiet);\\n                \\n                //quieter person\\n                if (quiet[curr] < quiet[answer[node]])\\n                    answer[node] = curr;\\n            }\\n        }\\n        return answer[node];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n    \\n     List<Integer>[] graph;\\n         \\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        \\n        int n = quiet.length;\\n        if(quiet == null || n == 0) return new int[0];\\n        \\n        //initialize graph with adjacency list\\n        graph = new ArrayList[n];\\n        \\n         for(int node = 0; node < graph.length; node++)\\n            graph[node] = new ArrayList<>();\\n        \\n        //build graph: poor -> rich\\n        for(int i = 0; i < richer.length; i++){\\n            graph[richer[i][1]].add(richer[i][0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1548347,
                "title": "both-bfs-and-dfs-solution-c-crystal-clear-code",
                "content": "# Approach 1: using DFS \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<vector<int>>& adj, vector<int>& quiet, vector<int>& ans, int node) {\\n        if(ans[node] != -1) return ans[node];\\n        \\n        ans[node] = node;\\n        for(auto& adjnode : adj[node]) {\\n            int ans_adjnode = dfs(adj, quiet, ans, adjnode);\\n            \\n            if(quiet[ans_adjnode] < quiet[ans[node]]) {\\n                ans[node] = ans_adjnode;\\n            }\\n        }\\n        \\n        return ans[node];\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        \\n        vector<vector<int>> adj(n);\\n\\n        for(auto& rich : richer) {\\n            adj[rich[1]].push_back(rich[0]);\\n        }\\n        \\n        vector<int> answer(n, -1);\\n        \\n        for(int i=0; i<n; i++) {\\n            if(answer[i] == -1)\\n                dfs(adj, quiet, answer, i);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\\n\\n# Approach 2 : using BFS (Topo Sort)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        \\n        vector<vector<int>> adj(n);\\n        vector<int> indegree(n, 0);\\n        for(auto& rich : richer) {\\n            adj[rich[0]].push_back(rich[1]);\\n            indegree[rich[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        vector<int> answer(n);\\n        \\n        for(int i=0; i<n; i++) {\\n            answer[i] = i;\\n            if(indegree[i] == 0) q.push(i);\\n        }\\n        \\n        while(q.size()) {\\n            int node = q.front(); q.pop();\\n            \\n            for(auto& adjNode : adj[node]) {\\n                if(quiet[answer[adjNode]] > quiet[answer[node]]) {\\n                    answer[adjNode] = answer[node];\\n                }\\n                \\n                indegree[adjNode]--;\\n                if(indegree[adjNode] == 0) q.push(adjNode);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<vector<int>>& adj, vector<int>& quiet, vector<int>& ans, int node) {\\n        if(ans[node] != -1) return ans[node];\\n        \\n        ans[node] = node;\\n        for(auto& adjnode : adj[node]) {\\n            int ans_adjnode = dfs(adj, quiet, ans, adjnode);\\n            \\n            if(quiet[ans_adjnode] < quiet[ans[node]]) {\\n                ans[node] = ans_adjnode;\\n            }\\n        }\\n        \\n        return ans[node];\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        \\n        vector<vector<int>> adj(n);\\n\\n        for(auto& rich : richer) {\\n            adj[rich[1]].push_back(rich[0]);\\n        }\\n        \\n        vector<int> answer(n, -1);\\n        \\n        for(int i=0; i<n; i++) {\\n            if(answer[i] == -1)\\n                dfs(adj, quiet, answer, i);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        \\n        vector<vector<int>> adj(n);\\n        vector<int> indegree(n, 0);\\n        for(auto& rich : richer) {\\n            adj[rich[0]].push_back(rich[1]);\\n            indegree[rich[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        vector<int> answer(n);\\n        \\n        for(int i=0; i<n; i++) {\\n            answer[i] = i;\\n            if(indegree[i] == 0) q.push(i);\\n        }\\n        \\n        while(q.size()) {\\n            int node = q.front(); q.pop();\\n            \\n            for(auto& adjNode : adj[node]) {\\n                if(quiet[answer[adjNode]] > quiet[answer[node]]) {\\n                    answer[adjNode] = answer[node];\\n                }\\n                \\n                indegree[adjNode]--;\\n                if(indegree[adjNode] == 0) q.push(adjNode);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310921,
                "title": "easy-c-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n=quiet.size();\\n        vector<int> res(n,-1);\\n        //create a adjacency list\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            //make a directed edge from richer[i][1] to richer[i][0]\\n            //because richer[i][1] is richer than richer[i][0] and also we can explore\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(res[i]==-1)\\n            {\\n                //if it has not been calculated yet\\n                dfs(i,adj,res,quiet);\\n            }\\n        }\\n        return res;\\n    }\\n    int dfs(int person,vector<vector<int>>& adj,vector<int>& res,vector<int>& quiet)\\n    {\\n        int minPerson=person;\\n        for(auto rich:adj[person])\\n        {\\n            if(res[rich]!=-1)\\n            {\\n                //if it has already calculated\\n                if(quiet[res[rich]] < quiet[minPerson])\\n                {\\n                    minPerson=res[rich];\\n                }\\n            }\\n            else{\\n                int somePerson=dfs(rich,adj,res,quiet);\\n                if(quiet[somePerson] < quiet[minPerson])\\n                {\\n                    minPerson=somePerson;\\n                }\\n            } \\n               \\n        }\\n        res[person]=minPerson;\\n        return minPerson;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n=quiet.size();\\n        vector<int> res(n,-1);\\n        //create a adjacency list\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            //make a directed edge from richer[i][1] to richer[i][0]\\n            //because richer[i][1] is richer than richer[i][0] and also we can explore\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(res[i]==-1)\\n            {\\n                //if it has not been calculated yet\\n                dfs(i,adj,res,quiet);\\n            }\\n        }\\n        return res;\\n    }\\n    int dfs(int person,vector<vector<int>>& adj,vector<int>& res,vector<int>& quiet)\\n    {\\n        int minPerson=person;\\n        for(auto rich:adj[person])\\n        {\\n            if(res[rich]!=-1)\\n            {\\n                //if it has already calculated\\n                if(quiet[res[rich]] < quiet[minPerson])\\n                {\\n                    minPerson=res[rich];\\n                }\\n            }\\n            else{\\n                int somePerson=dfs(rich,adj,res,quiet);\\n                if(quiet[somePerson] < quiet[minPerson])\\n                {\\n                    minPerson=somePerson;\\n                }\\n            } \\n               \\n        }\\n        res[person]=minPerson;\\n        return minPerson;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 403311,
                "title": "standard-python-bfs-solution-similar-to-topological-sorting",
                "content": "```\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n = len(quiet)\\n        answer = n * [-1]\\n\\t\\t# create a directed graph\\n        pre, suc = [set() for _ in range(n)], [set() for _ in range(n)]\\n        indegree = n * [0]\\n        for x, y in richer:\\n            suc[x].add(y)\\n            pre[y].add(x)\\n            indegree[y] += 1\\n        # visit the sources (richest people) first\\n        curr_level = {x for x in range(n) if indegree[x] == 0}\\n        for x in curr_level:\\n            answer[x] = x\\n        while curr_level:\\n            next_level = set()\\n            for x in curr_level:\\n                for y in suc[x]:\\n                    indegree[y] -= 1\\n                    # new level of sources after removing the previous sources\\n                    if indegree[y] == 0: \\n                        answer[y] = y\\n                        for p in pre[y]:\\n                            if quiet[answer[p]] < quiet[answer[y]]:\\n                                answer[y] = answer[p]\\n                        next_level.add(y)\\n            curr_level = next_level\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n = len(quiet)\\n        answer = n * [-1]\\n\\t\\t# create a directed graph\\n        pre, suc = [set() for _ in range(n)], [set() for _ in range(n)]\\n        indegree = n * [0]\\n        for x, y in richer:\\n            suc[x].add(y)\\n            pre[y].add(x)\\n            indegree[y] += 1\\n        # visit the sources (richest people) first\\n        curr_level = {x for x in range(n) if indegree[x] == 0}\\n        for x in curr_level:\\n            answer[x] = x\\n        while curr_level:\\n            next_level = set()\\n            for x in curr_level:\\n                for y in suc[x]:\\n                    indegree[y] -= 1\\n                    # new level of sources after removing the previous sources\\n                    if indegree[y] == 0: \\n                        answer[y] = y\\n                        for p in pre[y]:\\n                            if quiet[answer[p]] < quiet[answer[y]]:\\n                                answer[y] = answer[p]\\n                        next_level.add(y)\\n            curr_level = next_level\\n        return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3556523,
                "title": "python-3-8-lines-cached-dfs-t-m-74-44",
                "content": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        \\n        n = len(quiet)\\n        g, f = defaultdict(list), lambda x: list(map(dfs,x)) \\n        for u, v in richer: g[v].append(u)\\n\\n        @lru_cache(2000)\\n        def dfs(node):\\n            return min(((f(g[node]))+[node]), key=lambda x:quiet[x])\\n        \\n        return f(range(n))\\n```\\n[https://leetcode.com/problems/loud-and-rich/submissions/955947460/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*+*R*) and space complexity is *O*(*N*+*R*) in which *N* ~`len(quiet)`and *R* ~`len(richer)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        \\n        n = len(quiet)\\n        g, f = defaultdict(list), lambda x: list(map(dfs,x)) \\n        for u, v in richer: g[v].append(u)\\n\\n        @lru_cache(2000)\\n        def dfs(node):\\n            return min(((f(g[node]))+[node]), key=lambda x:quiet[x])\\n        \\n        return f(range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241793,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> adj[],int node,vector<int>& vis,int& ans,int& mini,vector<int>& quiet){\\n        vis[node] = 1;\\n        if(quiet[node]<mini){\\n            mini = quiet[node];\\n            ans = node;\\n        }\\n        \\n        for(auto it : adj[node]){\\n            if(!vis[it]){\\n                dfs(adj,it,vis,ans,mini,quiet);\\n            }\\n        }\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        for(auto it : richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans(n,-1);\\n        for(int i = 0;i<n;i++){\\n            vector<int> vis(n,0);\\n            int mini = INT_MAX;\\n            dfs(adj,i,vis,ans[i],mini,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> adj[],int node,vector<int>& vis,int& ans,int& mini,vector<int>& quiet){\\n        vis[node] = 1;\\n        if(quiet[node]<mini){\\n            mini = quiet[node];\\n            ans = node;\\n        }\\n        \\n        for(auto it : adj[node]){\\n            if(!vis[it]){\\n                dfs(adj,it,vis,ans,mini,quiet);\\n            }\\n        }\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        for(auto it : richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans(n,-1);\\n        for(int i = 0;i<n;i++){\\n            vector<int> vis(n,0);\\n            int mini = INT_MAX;\\n            dfs(adj,i,vis,ans[i],mini,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528688,
                "title": "c-using-topological-sorting",
                "content": "class Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n      \\n\\t  //Use TopoSort\\n       \\n        //n->no of person\\n        int n=quiet.size();\\n        \\n        //stores ans\\n        vector<int> ans(n);\\n        \\n        //initially let no one is poor than other\\n        for(int i=0;i<n;i++) ans[i]=i;\\n      \\n        \\n   \\n        vector<int> adj[n];\\n        \\n        \\n        //outdegree out[i] rep no of people richer than ith person\\n        vector<int> out(n,0);\\n        \\n        for(auto x:richer)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            out[x[1]]++;\\n            \\n            \\n        }\\n        \\n        queue<int> q;\\n        \\n        \\n        for(int i=0;i<n;i++) if(out[i]==0) q.push(i);\\n        \\n        \\n        while(!q.empty())\\n        {\\n            \\n            int u=q.front();\\n            q.pop();\\n           \\n            \\n            //trav neighbour of richer person u ,and updating the least quiet person for its adj node.\\n            for(auto x:adj[u])\\n            { \\n                 if(quiet[ans[x]]>quiet[ans[u]])\\n                {\\n                    ans[x]=ans[u];\\n                }\\n                \\n                //if out[x]==0, means there is no reacher person than this,so we processs it\\n               if(--out[x]==0) q.push(x);\\n                \\n            }\\n            \\n            \\n        }\\n        \\n         \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n      \\n\\t  //Use TopoSort\\n       \\n        //n->no of person\\n        int n=quiet.size();\\n        \\n        //stores ans\\n        vector<int> ans(n);\\n        \\n        //initially let no one is poor than other\\n        for(int i=0;i<n;i++) ans[i]=i;\\n      \\n        \\n   \\n        vector<int> adj[n];\\n        \\n        \\n        //outdegree out[i] rep no of people richer than ith person\\n        vector<int> out(n,0);\\n        \\n        for(auto x:richer)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            out[x[1]]++;\\n            \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1430693,
                "title": "topological-sort-c",
                "content": "```\\n vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n         int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        \\n        \\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n       \\n       \\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            \\n            for(int i : g[curr]){\\n                \\n                if(quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                indg[i]--;\\n                if(indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\n vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n         int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        \\n        \\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n       \\n       \\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            \\n            for(int i : g[curr]){\\n                \\n                if(quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                indg[i]--;\\n                if(indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1358548,
                "title": "c-indegree-count-solution",
                "content": "Runtime: 92 ms, faster than 91.59% of C++ online submissions for Loud and Rich.\\nMemory Usage: 42.6 MB, less than 72.74% of C++ online submissions for Loud and Rich.\\n\\n```\\nIn this problem we have to find the least quiet person who is more or equal reacher than anyone.\\nSo we make edge list of each person from richer array such that edgelist[richer[i][0]] contains richer[i][1]\\nmeans there is a directed edge between richer to poorer person.\\n\\nWe solve the problem using Indegree count. First we populate result vector with own index as it handle \\nthe case for nodes with Indegree count 0 automatically. Then we create the edge list of nodes from richer\\nvector and also update the result vector of richer[i][1] if quiet[result[richer[i][0]]]<quiet[result[richer[i][1]]].\\nThis automatically handles the result of neighbor nodes\\' of Indegree count 0 nodes.\\n\\nThen we populate the Max Priority Queue with nodes and Indegree count pair for nodes Indegree > 0. As \\nwe can see that higher Indegree count nodes will have impact on lower Indegree count nodes. So, we take\\nthe top node of Max Priority Queue and update its neighbor nodes result if current nodes\\' quiteness is less\\nthan the neighbor nodes\\' quiteness and continue until queue is empty.\\n\\nExample:\\nInput: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\\nOutput: [5,5,2,5,4,5,6,7]\\n\\nBelow is the simulation of solution:\\n```\\n\\n![image](https://assets.leetcode.com/users/images/f2e1a1fc-cabd-44f3-acfb-50d804bc25c7_1627103373.6610482.png)\\n\\n![image](https://assets.leetcode.com/users/images/30c4140d-d700-4f58-b171-642ded1bbfd6_1627103656.4510098.png)\\n\\n![image](https://assets.leetcode.com/users/images/cd0a0d30-713f-49a3-9973-5de71ed3fb46_1627106387.578677.png)\\n\\n![image](https://assets.leetcode.com/users/images/32dee1bf-6d96-4d36-9f99-42ea41a26fde_1627106396.6677387.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        \\n        // track Indegree count of nodes\\n        vector<int>indegree(n,0);\\n        \\n        // make adjacent list of nodes where a directed edge from richer to poorer person  \\n        vector<vector<int>>edges(n);\\n        \\n        // result vector containing answer\\n        vector<int>result(n);\\n        \\n        // Max priority queue of node and indegree count\\n        // Insert weight Indegree count as first element \\n        priority_queue<pair<int,int>> pQ;\\n\\n        // make default result each person as their own index\\n        for(int i=0;i<n;i++)\\n            result[i]=i;\\n        \\n        // populate the edgelist and update result based on result \\n        // also count the indegree count of node richer[i][1] from righer vector\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            edges[richer[i][0]].push_back(richer[i][1]);\\n            indegree[richer[i][1]]++;\\n            if(quiet[result[richer[i][0]]]<quiet[result[richer[i][1]]])\\n                result[richer[i][1]] = result[richer[i][0]];\\n        }\\n        \\n        // populate the priority queue for nodes with Indegree count > 0\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]>0)\\n                pQ.push(make_pair(indegree[i],i));  //pair {indegree count, node}\\n        }\\n        \\n        int node;\\n        \\n        // process all nodes in priortiy queue\\n        while(!pQ.empty())\\n        {            \\n            node = pQ.top().second;\\n            pQ.pop();\\n\\n            // update result of all neighbor nodes if current node\\'s quiteness is lower\\n            for(int j=0;j<edges[node].size();j++)\\n            {\\n                if(quiet[result[node]]<quiet[result[edges[node][j]]])\\n                    result[edges[node][j]] = result[node];\\n            }\\n        }\\n                                   \\n        return result;                                   \\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nIn this problem we have to find the least quiet person who is more or equal reacher than anyone.\\nSo we make edge list of each person from richer array such that edgelist[richer[i][0]] contains richer[i][1]\\nmeans there is a directed edge between richer to poorer person.\\n\\nWe solve the problem using Indegree count. First we populate result vector with own index as it handle \\nthe case for nodes with Indegree count 0 automatically. Then we create the edge list of nodes from richer\\nvector and also update the result vector of richer[i][1] if quiet[result[richer[i][0]]]<quiet[result[richer[i][1]]].\\nThis automatically handles the result of neighbor nodes\\' of Indegree count 0 nodes.\\n\\nThen we populate the Max Priority Queue with nodes and Indegree count pair for nodes Indegree > 0. As \\nwe can see that higher Indegree count nodes will have impact on lower Indegree count nodes. So, we take\\nthe top node of Max Priority Queue and update its neighbor nodes result if current nodes\\' quiteness is less\\nthan the neighbor nodes\\' quiteness and continue until queue is empty.\\n\\nExample:\\nInput: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\\nOutput: [5,5,2,5,4,5,6,7]\\n\\nBelow is the simulation of solution:\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        \\n        // track Indegree count of nodes\\n        vector<int>indegree(n,0);\\n        \\n        // make adjacent list of nodes where a directed edge from richer to poorer person  \\n        vector<vector<int>>edges(n);\\n        \\n        // result vector containing answer\\n        vector<int>result(n);\\n        \\n        // Max priority queue of node and indegree count\\n        // Insert weight Indegree count as first element \\n        priority_queue<pair<int,int>> pQ;\\n\\n        // make default result each person as their own index\\n        for(int i=0;i<n;i++)\\n            result[i]=i;\\n        \\n        // populate the edgelist and update result based on result \\n        // also count the indegree count of node richer[i][1] from righer vector\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            edges[richer[i][0]].push_back(richer[i][1]);\\n            indegree[richer[i][1]]++;\\n            if(quiet[result[richer[i][0]]]<quiet[result[richer[i][1]]])\\n                result[richer[i][1]] = result[richer[i][0]];\\n        }\\n        \\n        // populate the priority queue for nodes with Indegree count > 0\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]>0)\\n                pQ.push(make_pair(indegree[i],i));  //pair {indegree count, node}\\n        }\\n        \\n        int node;\\n        \\n        // process all nodes in priortiy queue\\n        while(!pQ.empty())\\n        {            \\n            node = pQ.top().second;\\n            pQ.pop();\\n\\n            // update result of all neighbor nodes if current node\\'s quiteness is lower\\n            for(int j=0;j<edges[node].size();j++)\\n            {\\n                if(quiet[result[node]]<quiet[result[edges[node][j]]])\\n                    result[edges[node][j]] = result[node];\\n            }\\n        }\\n                                   \\n        return result;                                   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 665959,
                "title": "cpp-dfs",
                "content": "Runtime: 220 ms, faster than 51.85% of C++ online submissions for Loud and Rich.\\nMemory Usage: 43.1 MB, less than 100.00% of C++ online submissions for Loud and Rich.Rich.\\n    Explanation : \\nwe will create a map where value vector will have all the people having more money than key\\nnow if there\\'s no value found for any key i then output at i will be i because no one has more money than i\\n    if there\\'s value vector present we will find the the output for all the vector elements(people rich than current index)\\n        and then whoever is most quite among them will be my output\\nexample:\\nfor the given example 1 the map will be :\\n0 -> 1\\n1 ->2,3\\n3->4,5,6\\n7->3\\noutput of 2,4,5,6 will be 2,4,5,6 as no one\\'s rich than themselves \\n    for 0 we will find whether 0 is quite or 1 now again for one we will find output for 2,3 and 2 will be 2 but 3 we will agian find value for 4,5,6(because if 3 is rich than 1 and 4 is rich than 3 then 4 is rich than 1) which is 4,5,6 and quite among them is 5 and ans of 5 will be 5 and ans for 1 quite among ans 1,2,5 is 5 and so on\\n```\\n    class Solution {\\n    void dfs( unordered_map<int,vector<int>>& moreMoneyThanMe,vector<int>& quiet, , vector<int>& output, int i, int n){\\n        if(output[i] != -1){\\n            return;\\n        }\\n        int it;\\n        if(moreMoneyThanMe.find(i) == moreMoneyThanMe.end()){\\n            output[i] = i;\\n            return;\\n        }\\n        int min_ = quiet[i]; int ans = i;\\n        for(it = 0; it < moreMoneyThanMe[i].size(); it++){\\n            dfs(moreMoneyThanMe,quiet,output,moreMoneyThanMe[i][it],n);\\n            if(min_ > quiet[output[moreMoneyThanMe[i][it]]]){\\n                min_ = quiet[output[moreMoneyThanMe[i][it]]];\\n                ans = output[moreMoneyThanMe[i][it]];\\n            }\\n        }\\n        output[i] = ans;\\n    }\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        unordered_map<int,vector<int>> moreMoneyThanMe;\\n        int n = quiet.size();\\n        vector<int> output(n,-1);\\n        int i;\\n        for(i = 0; i < richer.size(); i++){\\n            moreMoneyThanMe[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        for(i = 0; i < n; i++){\\n            if(output[i] == -1){\\n                dfs(moreMoneyThanMe,quiet,output,i,n);\\n            }\\n        }\\n        return output;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    void dfs( unordered_map<int,vector<int>>& moreMoneyThanMe,vector<int>& quiet, , vector<int>& output, int i, int n){\\n        if(output[i] != -1){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 138830,
                "title": "python-topology-sort-solution",
                "content": "Richer can be used to construct a directed graph. Start with the richest, i.e.; nodes without outward edges. For these nodes x, answer[x] = x since there is no y such that y is richer than x. Then for node y that has outward edges to [xi], xi being one of the richest nodes, answer[y] = z where z is some xi having the smallest quiet value among [xi], then this answer can be used in a new iteration to calculate answer for nodes with outward edges to [yi].  \\n```\\nclass Solution:\\n    def loudAndRich(self, richer, quiet):\\n        \"\"\"\\n        :type richer: List[List[int]]\\n        :type quiet: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        qs = [-1] * len(quiet)\\n        d = {}\\n        for r in richer:\\n            if r[1] not in d:\\n                d[r[1]] = [r[0]]\\n            else:\\n                d[r[1]].append(r[0])\\n        \\n        for i in range(len(quiet)):\\n            if i not in d:\\n                qs[i] = quiet[i]\\n        g = {}\\n        for q in enumerate(quiet):\\n            g[q[1]] = q[0]\\n        \\n        while d:\\n            for k in d.keys():\\n                m = min(list(map(lambda x: qs[x], d[k]))) if d[k] else -1 \\n                if m == -1:\\n                    continue\\n                qs[k] = min(m, quiet[k])\\n                d.pop(k, None)\\n        return map(lambda x: g[x], qs)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer, quiet):\\n        \"\"\"\\n        :type richer: List[List[int]]\\n        :type quiet: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        qs = [-1] * len(quiet)\\n        d = {}\\n        for r in richer:\\n            if r[1] not in d:\\n                d[r[1]] = [r[0]]\\n            else:\\n                d[r[1]].append(r[0])\\n        \\n        for i in range(len(quiet)):\\n            if i not in d:\\n                qs[i] = quiet[i]\\n        g = {}\\n        for q in enumerate(quiet):\\n            g[q[1]] = q[0]\\n        \\n        while d:\\n            for k in d.keys():\\n                m = min(list(map(lambda x: qs[x], d[k]))) if d[k] else -1 \\n                if m == -1:\\n                    continue\\n                qs[k] = min(m, quiet[k])\\n                d.pop(k, None)\\n        return map(lambda x: g[x], qs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138125,
                "title": "dfs-with-memory",
                "content": "```\\nclass Solution {\\n    unordered_map<int, set<int>> mp;\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        for(int i = 0; i < richer.size(); i++)\\n            mp[richer[i][1]].insert(richer[i][0]);\\n        vector<int> ans(quiet.size(), -1);\\n        for(int i = 0; i < quiet.size(); i++)\\n            if(ans[i] == -1) lookFor(ans, quiet, i);\\n        return ans;\\n    }\\n    void lookFor(vector<int>& ans, vector<int>& quiet, int person){\\n        int man = person;\\n        int noise = quiet[person];\\n        for(int target : mp[person]){\\n            if(ans[target] == -1) lookFor(ans, quiet, target);\\n            if(quiet[ans[target]] < noise){\\n                noise = quiet[ans[target]];\\n                man = ans[target];\\n            }\\n        }\\n        ans[person] = man;\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<int, set<int>> mp;\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        for(int i = 0; i < richer.size(); i++)\\n            mp[richer[i][1]].insert(richer[i][0]);\\n        vector<int> ans(quiet.size(), -1);\\n        for(int i = 0; i < quiet.size(); i++)\\n            if(ans[i] == -1) lookFor(ans, quiet, i);\\n        return ans;\\n    }\\n    void lookFor(vector<int>& ans, vector<int>& quiet, int person){\\n        int man = person;\\n        int noise = quiet[person];\\n        for(int target : mp[person]){\\n            if(ans[target] == -1) lookFor(ans, quiet, target);\\n            if(quiet[ans[target]] < noise){\\n                noise = quiet[ans[target]];\\n                man = ans[target];\\n            }\\n        }\\n        ans[person] = man;\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137943,
                "title": "easy-and-readable-dfs-with-memorilization",
                "content": "```\\nclass Solution {\\n    int[] res;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for (int[] row : richer) {\\n            map.putIfAbsent(row[1], new ArrayList<Integer>());\\n            map.get(row[1]).add(row[0]);\\n        }\\n        res = new int[quiet.length];\\n        Arrays.fill(res, -1);\\n        for (int i = 0; i < quiet.length; i++) {\\n            res[i] = dfs(map, i, quiet);\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(HashMap<Integer, List<Integer>> adj, int i, int[] quiet) {\\n        if (res[i] != -1) return res[i];\\n        List<Integer> list = adj.get(i);\\n        res[i] = i;\\n        if (adj.get(i) != null) {\\n            for (int elem : adj.get(i)) {\\n                int n = dfs(adj, elem, quiet);\\n                if (quiet[n] < quiet[res[i]]) res[i] = n;\\n            }\\n        }\\n        return res[i];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] res;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for (int[] row : richer) {\\n            map.putIfAbsent(row[1], new ArrayList<Integer>());\\n            map.get(row[1]).add(row[0]);\\n        }\\n        res = new int[quiet.length];\\n        Arrays.fill(res, -1);\\n        for (int i = 0; i < quiet.length; i++) {\\n            res[i] = dfs(map, i, quiet);\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(HashMap<Integer, List<Integer>> adj, int i, int[] quiet) {\\n        if (res[i] != -1) return res[i];\\n        List<Integer> list = adj.get(i);\\n        res[i] = i;\\n        if (adj.get(i) != null) {\\n            for (int elem : adj.get(i)) {\\n                int n = dfs(adj, elem, quiet);\\n                if (quiet[n] < quiet[res[i]]) res[i] = n;\\n            }\\n        }\\n        return res[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864688,
                "title": "dp-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the quietest person each person knows within a social network represented as a directed graph. To find the quietest person a particular person p knows, we can traverse the social network starting from p and recursively find the quietest person among p\\'s neighbors. We will use depth-first search (DFS) to achieve this.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We can implement a recursive DFS function dfs(node, adj, quiet) that takes a person node, the adjacency list adj representing the social network, and the quiet vector representing the quietness levels of all people.\\n2. Within the dfs function, we will check if the quietest person for node has already been calculated and stored in the dp array (dynamic programming memoization). If it has, we return that value.\\n3. If the quietest person for node has not been calculated yet, we initialize miniVal to the quietness level of the current person node and miniNode to node. We then loop through all the neighbors of node (i.e., the people node knows) using the adjacency list adj.\\n4. For each neighbor, we recursively call the dfs function to find the quietest person that the neighbor knows. We update miniVal and miniNode if the quietness level of the neighbor is smaller than the current miniVal.\\n5. Finally, we return miniNode as the quietest person that node knows and store this value in the dp array for future use.\\n6. In the loudAndRich function, we initialize the dp array to store the results of the DFS to avoid redundant computations. We also create the adjacency list adj using the richer vector. For each person i in the network, we call the dfs function to find the quietest person that i knows and store the result in the ans\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe DFS function dfs is called once for each person in the network, and within each call, we may visit each neighbor once. Hence, the time complexity is O(N + E), where N is the number of people and E is the number of edges in the social network (richer relationships).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n We use additional space for the dp array, the adjacency list adj, and the ans vector. The space complexity is O(N + E) for the adjacency list and O(N) for the dp array and ans vector, resulting in a total space complexity of O(N + E).\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){\\n        if(dp[node]!=-1) return dp[node];\\n\\n        int miniVal  = quiet[node]; // if there is no outgoing edge from the node\\n        // then the node is the quitiest person he knows who is as rich \\n        // as him \\n        int miniNode = node;\\n        // stores the node with the properties\\n\\n        for(auto it:adj[node]){\\n            int miniIndex = dfs(it,adj,quiet);// do a dfs traversal for all the\\n            // adjNode\\n            if(quiet[miniIndex] < miniVal){\\n                miniVal = quiet[miniIndex];\\n                miniNode = miniIndex;\\n            } \\n\\n        }\\n\\n        return dp[node] = miniNode;        \\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        dp.resize(n,-1);\\n        vector<vector<int>>adj(n);\\n        vector<int>ans;\\n        for(auto it: richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        for(int i =0;i<n;i++){\\n            int res = dfs(i,adj,quiet);\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){\\n        if(dp[node]!=-1) return dp[node];\\n\\n        int miniVal  = quiet[node]; // if there is no outgoing edge from the node\\n        // then the node is the quitiest person he knows who is as rich \\n        // as him \\n        int miniNode = node;\\n        // stores the node with the properties\\n\\n        for(auto it:adj[node]){\\n            int miniIndex = dfs(it,adj,quiet);// do a dfs traversal for all the\\n            // adjNode\\n            if(quiet[miniIndex] < miniVal){\\n                miniVal = quiet[miniIndex];\\n                miniNode = miniIndex;\\n            } \\n\\n        }\\n\\n        return dp[node] = miniNode;        \\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        dp.resize(n,-1);\\n        vector<vector<int>>adj(n);\\n        vector<int>ans;\\n        for(auto it: richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        for(int i =0;i<n;i++){\\n            int res = dfs(i,adj,quiet);\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491512,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            for(int i : g[curr]){\\n                if(ans[i] == INT_MAX || quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                if(--indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n\\n        graph = defaultdict(list)\\n        for a, b in richer:\\n            graph[b].append(a)\\n        \\n        n = len(quiet)\\n        answer = [i for i in range(n)]\\n\\n        seen = set()\\n        \\n        def dfs(x, seen, answer):\\n            seen.add(x)\\n            for y in graph[x]:\\n                if y not in seen:\\n                    dfs(y, seen, answer)\\n                temp = answer[x]\\n                if quiet[temp] > quiet[answer[y]]:\\n                    answer[x] = answer[y]\\n        \\n        for i in range(n):\\n            if i not in seen:\\n                dfs(i, seen, answer)\\n\\n        return answer\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        int[] res = new int[n];\\n        for(int i=0; i<n; i++){\\n            res[i] = i;\\n        }\\n        boolean changed = true;\\n        while(changed){\\n            changed = false;\\n            for(int[] rich : richer){\\n                if(quiet[res[rich[0]]] < quiet[res[rich[1]]]){\\n                    res[rich[1]] = res[rich[0]];\\n                    changed = true;\\n                }\\n            }\\n        }  \\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            for(int i : g[curr]){\\n                if(ans[i] == INT_MAX || quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                if(--indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n\\n        graph = defaultdict(list)\\n        for a, b in richer:\\n            graph[b].append(a)\\n        \\n        n = len(quiet)\\n        answer = [i for i in range(n)]\\n\\n        seen = set()\\n        \\n        def dfs(x, seen, answer):\\n            seen.add(x)\\n            for y in graph[x]:\\n                if y not in seen:\\n                    dfs(y, seen, answer)\\n                temp = answer[x]\\n                if quiet[temp] > quiet[answer[y]]:\\n                    answer[x] = answer[y]\\n        \\n        for i in range(n):\\n            if i not in seen:\\n                dfs(i, seen, answer)\\n\\n        return answer\\n```\n```Java []\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        int[] res = new int[n];\\n        for(int i=0; i<n; i++){\\n            res[i] = i;\\n        }\\n        boolean changed = true;\\n        while(changed){\\n            changed = false;\\n            for(int[] rich : richer){\\n                if(quiet[res[rich[0]]] < quiet[res[rich[1]]]){\\n                    res[rich[1]] = res[rich[0]];\\n                    changed = true;\\n                }\\n            }\\n        }  \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750857,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> richer2;\\n    vector<int> res;\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        for (auto v : richer) richer2[v[1]].push_back(v[0]);\\n        res = vector<int> (quiet.size(), -1);\\n        for (int i = 0; i < quiet.size(); i++) dfs(i, quiet);\\n        return res;\\n    }\\n\\n    int dfs(int i, vector<int>& quiet) {\\n        if (res[i] >= 0) return res[i];\\n        res[i] = i;\\n        for (int j : richer2[i]) if (quiet[res[i]] > quiet[dfs(j, quiet)]) res[i] = res[j];\\n        return res[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> richer2;\\n    vector<int> res;\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        for (auto v : richer) richer2[v[1]].push_back(v[0]);\\n        res = vector<int> (quiet.size(), -1);\\n        for (int i = 0; i < quiet.size(); i++) dfs(i, quiet);\\n        return res;\\n    }\\n\\n    int dfs(int i, vector<int>& quiet) {\\n        if (res[i] >= 0) return res[i];\\n        res[i] = i;\\n        for (int j : richer2[i]) if (quiet[res[i]] > quiet[dfs(j, quiet)]) res[i] = res[j];\\n        return res[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714041,
                "title": "python-pure-topological-sort",
                "content": "**Explanation**\\nwe want to know the quietest person that is richer than self, which means we want to process all that are richer than self. this is where topological sort comes in. \\n\\nusing topological sort we want to process the richest ones first. i.e the count of the richer person for a person needs to be zero.\\n\\nWhen processing a rich person we want to compare it\\'s quietness against people poorer. so we will compare the quieteness of self against other poor people.\\n\\n**P.S** we will store the pointer of the quietest person on answer.\\n\\n\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        richer_count = [0 for _ in range(len(quiet))]\\n        graph = defaultdict(list)\\n        answer = [idx for idx in range(len(quiet))]\\n        \\n        ## create the graph so that we go from the richer to the poorer\\n        for rich, poor in richer:\\n            graph[rich].append(poor)\\n            richer_count[poor] += 1\\n            \\n        ## we include the richest ones.\\n        queue = collections.deque([])\\n        for person, rich_count in enumerate(richer_count):\\n            if not rich_count:\\n                queue.append(person)\\n                \\n        while queue:\\n            person = queue.popleft()\\n            ## pointer to the quietest person\\n            quieter_person = answer[person]\\n            \\n            for poorer in graph[person]:\\n                ## pointer to the quietest person richer than me\\n                quieter_richer = answer[poorer]\\n                ## on the answer we are storing the pointer to the quietest one. so for the next poorer we are going to store the pointer which contains the quietest\\n                answer[poorer] = min(quieter_person, quieter_richer, key = lambda prsn : quiet[prsn])\\n                richer_count[poorer] -= 1\\n                if not richer_count[poorer]:\\n                    queue.append(poorer)\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        richer_count = [0 for _ in range(len(quiet))]\\n        graph = defaultdict(list)\\n        answer = [idx for idx in range(len(quiet))]\\n        \\n        ## create the graph so that we go from the richer to the poorer\\n        for rich, poor in richer:\\n            graph[rich].append(poor)\\n            richer_count[poor] += 1\\n            \\n        ## we include the richest ones.\\n        queue = collections.deque([])\\n        for person, rich_count in enumerate(richer_count):\\n            if not rich_count:\\n                queue.append(person)\\n                \\n        while queue:\\n            person = queue.popleft()\\n            ## pointer to the quietest person\\n            quieter_person = answer[person]\\n            \\n            for poorer in graph[person]:\\n                ## pointer to the quietest person richer than me\\n                quieter_richer = answer[poorer]\\n                ## on the answer we are storing the pointer to the quietest one. so for the next poorer we are going to store the pointer which contains the quietest\\n                answer[poorer] = min(quieter_person, quieter_richer, key = lambda prsn : quiet[prsn])\\n                richer_count[poorer] -= 1\\n                if not richer_count[poorer]:\\n                    queue.append(poorer)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545576,
                "title": "easy-dfs-solution-in-cpp",
                "content": "**Finding all ansector of given node and than had a check for most quietest anscestor that the current node**\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,int parent,vector<vector<int>>&edge,vector<int>&vis,vector<vector<int>>&ansc){\\n        \\n        vis[i]=1;\\n        for(auto ele:edge[i]){\\n            if(!vis[ele])dfs(ele,parent,edge,vis,ansc);\\n        }\\n        \\n        if(i!=parent)\\n            ansc[i].push_back(parent);\\n    }\\n    \\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>>ansc(n),edge(n);\\n        \\n        for(auto ele:richer){\\n            edge[ele[0]].push_back(ele[1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int>vis(n);\\n            dfs(i,i,edge,vis,ansc);\\n        }\\n        \\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++){\\n            int mini=quiet[i],a=i;\\n            \\n            for(auto ele:ansc[i]){\\n                if(mini>=quiet[ele]){\\n                    a=ele;\\n                    mini=quiet[ele];\\n                }\\n            }\\n            \\n            ans[i]=a;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    void dfs(int i,int parent,vector<vector<int>>&edge,vector<int>&vis,vector<vector<int>>&ansc){\\n        \\n        vis[i]=1;\\n        for(auto ele:edge[i]){\\n            if(!vis[ele])dfs(ele,parent,edge,vis,ansc);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2445906,
                "title": "c-graph-bfs-easy-solution",
                "content": "```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tvector<int> loudAndRich(vector<vector < int>> &richer, vector< int > &quiet)\\n\\t\\t{\\n\\t\\t\\tint n = quiet.size();\\n\\n\\t\\t\\tvector<int> indgree(n, 0);\\n\\t\\t\\tvector<int> dist(n, INT_MAX);\\n\\t\\t\\tqueue<int> q;\\n\\n\\t\\t\\tvector<int> adj[n];\\n\\t\\t\\tfor (auto x: richer)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int> data = x;\\n\\t\\t\\t\\tint a = data[0];\\n\\t\\t\\t\\tint b = data[1];\\n\\t\\t\\t\\tadj[a].push_back(b);\\n\\t\\t\\t\\tindgree[b]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdist[i] = i;\\n\\t\\t\\t\\tif (indgree[i] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tq.push(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint f = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tfor (auto x: adj[f])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (quiet[dist[x]] > quiet[dist[f]])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdist[x] = dist[f];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tindgree[x]--;\\n\\n\\t\\t\\t\\t\\tif (indgree[x] == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tq.push(x);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dist;\\n\\n\\t\\t}\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution\\n{\\n\\tpublic:\\n\\t\\tvector<int> loudAndRich(vector<vector < int>> &richer, vector< int > &quiet)\\n\\t\\t{\\n\\t\\t\\tint n = quiet.size();\\n\\n\\t\\t\\tvector<int> indgree(n, 0);\\n\\t\\t\\tvector<int> dist(n, INT_MAX);\\n\\t\\t\\tqueue<int> q;\\n\\n\\t\\t\\tvector<int> adj[n];\\n\\t\\t\\tfor (auto x: richer)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int> data = x;\\n\\t\\t\\t\\tint a = data[0];\\n\\t\\t\\t\\tint b = data[1];\\n\\t\\t\\t\\tadj[a].push_back(b);\\n\\t\\t\\t\\tindgree[b]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1957788,
                "title": "c-topological-sort-with-explanation",
                "content": "class Solution {\\npublic:\\n    \\n    /*\\n        The problem statement is bit confusing to understand. \\n        First Let us Understand the question.\\n        If we assume the graph as a directed graph such that x->y means y is ritcher than x.\\n        \\n        Let\\'s Take example of the question that has been provided to us in the question.\\n        richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\\n        \\n        so its adjacency list representation would look something like\\n        \\n        0 | 1\\n        1 | 2 3\\n        2 |\\n        3 | 4 5 6\\n        4 | \\n        5 | \\n        6 | \\n        7 | 3\\n        \\n        and now if we perform dfs over each node and store the minimum quietness and the candidate then we will get our answer.\\n        But this is not a efficient approach and may give TLE.\\n        \\n        So let\\'s Try to look this question from some other perspective.\\n        \\n        What if we change the edge direction then our adjacency list will look something like this\\n        \\n        0 |  \\n        1 | 0\\n        2 | 1\\n        3 | 1 7\\n        4 | 3\\n        5 | 3\\n        6 | 3\\n        7 | \\n        \\n        and in degree would be\\n        \\n        index - 0 1 2 3 4 5 6 7\\n        in    - 1 2 0 3 0 0 0 1\\n        \\n        and if we observe this the nodes with indegree 0 have the same queitness as they don\\'t have any one richer than them.\\n        so here we may get an idea that we might use topological sort in this question to get our answer.\\n        \\n        so we will push the nodes with indegree 0 in the queue and keep their quetness as it is.\\n        as we perfom the topological sort we will check if the quiet[parent]<quiet[child], then this means that parent is richer than \\n        child and he is more quieter than him then we can update our ans.\\n        and finally after performing topological sort we will get the answer.\\n    \\n    */\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int> > graph(n);\\n        vector<int> in(n,0);\\n        for(auto i:richer)\\n        {\\n            graph[i[0]].push_back(i[1]);\\n            in[i[1]]++;\\n        }\\n        queue<int> q;\\n        vector<int> ans(n);\\n        iota(ans.begin(),ans.end(),0);\\n        for(int i=0;i<n;++i)\\n        {\\n            if(in[i]==0)\\n            {\\n                q.push(i);\\n                ans[i]=i;\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int cur=q.front();\\n            q.pop();\\n            for(auto child:graph[cur])\\n            {\\n                in[child]--;\\n                if(quiet[cur]<quiet[child])\\n                {\\n                    quiet[child]=quiet[cur];\\n                    ans[child]=ans[cur];\\n                }\\n                if(in[child]==0)\\n                    q.push(child);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    /*\\n        The problem statement is bit confusing to understand. \\n        First Let us Understand the question.\\n        If we assume the graph as a directed graph such that x->y means y is ritcher than x.\\n        \\n        Let\\'s Take example of the question that has been provided to us in the question.\\n        richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\\n        \\n        so its adjacency list representation would look something like\\n        \\n        0 | 1\\n        1 | 2 3\\n        2 |\\n        3 | 4 5 6\\n        4 | \\n        5 | \\n        6 | \\n        7 | 3\\n        \\n        and now if we perform dfs over each node and store the minimum quietness and the candidate then we will get our answer.\\n        But this is not a efficient approach and may give TLE.\\n        \\n        So let\\'s Try to look this question from some other perspective.\\n        \\n        What if we change the edge direction then our adjacency list will look something like this\\n        \\n        0 |  \\n        1 | 0\\n        2 | 1\\n        3 | 1 7\\n        4 | 3\\n        5 | 3\\n        6 | 3\\n        7 | \\n        \\n        and in degree would be\\n        \\n        index - 0 1 2 3 4 5 6 7\\n        in    - 1 2 0 3 0 0 0 1\\n        \\n        and if we observe this the nodes with indegree 0 have the same queitness as they don\\'t have any one richer than them.\\n        so here we may get an idea that we might use topological sort in this question to get our answer.\\n        \\n        so we will push the nodes with indegree 0 in the queue and keep their quetness as it is.\\n        as we perfom the topological sort we will check if the quiet[parent]<quiet[child], then this means that parent is richer than \\n        child and he is more quieter than him then we can update our ans.\\n        and finally after performing topological sort we will get the answer.\\n    \\n    */\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int> > graph(n);\\n        vector<int> in(n,0);\\n        for(auto i:richer)\\n        {\\n            graph[i[0]].push_back(i[1]);\\n            in[i[1]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1473739,
                "title": "well-documented-python-solution",
                "content": "```\\nclass Solution(object):\\n    def loudAndRich(self, richer, quiet):\\n        \"\"\"\\n        :type richer: List[List[int]]\\n        :type quiet: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        def find_quietest(i):\\n            \\n            #recursively visit all the neighbors of i and calculate least noisy\\n            #sinc we have to apply min ops on the quiet[node_number]; we are storing both node_num and val of quiet[node_number]\\n            #for instance dict1 = {0: [1], 1: [2, 3], 3: [4, 5, 6], 7: [3]}\\n            #queit = [3,2,5,4,6,1,7,0]\\n            \\'\\'\\'\\n            for node 0: we take min((0, 3), find_quietest(1)) --> min((0, 3), (5, 1)) --> (5,1)\\n            find_quietest(1) = min((1, 2), find_quietest(2), find_quietest(3))\\n                             = min((1, 2), (2, 5), (5, 1))\\n                             = (5, 1)\\n            find_quietest(2) = (2, 5)\\n            find_quietest(3) = min((3, 4), find_quietest(4), find_quietest(5), find_quietest(6)) \\n                             = min((3,4), (4,6), (5,1), (6,7))\\n                             = (5,1)\\n            find_quietest(4) = (4, 6)\\n            find_quietest(5) = (5, 1)\\n            find_quietest(6) = (6, 7)\\n            \\n            \\'\\'\\'\\n            \\n            if i in memo:\\n                return memo[i]\\n            \\n            #as no information has been given about i\\n            if i not in dict1:\\n                return (i, quiet[i])\\n            \\n            quietest = (i, quiet[i])\\n            \\n            for richer in dict1[i]:\\n                quietest = min(quietest, find_quietest(richer), key= lambda x: x[1])\\n            \\n            return quietest\\n        \\n        #base \\n        if len(quiet) == 1:\\n            return quiet\\n        \\n        dict1 = {}\\n        memo = {}\\n        \\n        \\n        #Convert richer into a directed graph\\n        #For example: [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]\\n        #dict[0] = [1] which indicates 1 has more money than 0\\n        #so value at key x is all people richer than x\\n        for val in richer:\\n            if val[1] in dict1:\\n                dict1[val[1]].append(val[0])\\n            else:\\n                dict1[val[1]] = [val[0]]\\n        \\n        \\n        #create a copy of quiet as every person will be either itself or least quiet between itself and all its richer neighbors  \\n        result = list(quiet)\\n        \\n        for i in range(len(quiet)):\\n            #navigate all the neighbors richer than the node\\n            output = find_quietest(i)\\n            result[i] = output[0]\\n            #used for memoization\\n            memo[i] = output\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def loudAndRich(self, richer, quiet):\\n        \"\"\"\\n        :type richer: List[List[int]]\\n        :type quiet: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        def find_quietest(i):\\n            \\n            #recursively visit all the neighbors of i and calculate least noisy\\n            #sinc we have to apply min ops on the quiet[node_number]; we are storing both node_num and val of quiet[node_number]\\n            #for instance dict1 = {0: [1], 1: [2, 3], 3: [4, 5, 6], 7: [3]}\\n            #queit = [3,2,5,4,6,1,7,0]\\n            \\'\\'\\'\\n            for node 0: we take min((0, 3), find_quietest(1)) --> min((0, 3), (5, 1)) --> (5,1)\\n            find_quietest(1) = min((1, 2), find_quietest(2), find_quietest(3))\\n                             = min((1, 2), (2, 5), (5, 1))\\n                             = (5, 1)\\n            find_quietest(2) = (2, 5)\\n            find_quietest(3) = min((3, 4), find_quietest(4), find_quietest(5), find_quietest(6)) \\n                             = min((3,4), (4,6), (5,1), (6,7))\\n                             = (5,1)\\n            find_quietest(4) = (4, 6)\\n            find_quietest(5) = (5, 1)\\n            find_quietest(6) = (6, 7)\\n            \\n            \\'\\'\\'\\n            \\n            if i in memo:\\n                return memo[i]\\n            \\n            #as no information has been given about i\\n            if i not in dict1:\\n                return (i, quiet[i])\\n            \\n            quietest = (i, quiet[i])\\n            \\n            for richer in dict1[i]:\\n                quietest = min(quietest, find_quietest(richer), key= lambda x: x[1])\\n            \\n            return quietest\\n        \\n        #base \\n        if len(quiet) == 1:\\n            return quiet\\n        \\n        dict1 = {}\\n        memo = {}\\n        \\n        \\n        #Convert richer into a directed graph\\n        #For example: [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]\\n        #dict[0] = [1] which indicates 1 has more money than 0\\n        #so value at key x is all people richer than x\\n        for val in richer:\\n            if val[1] in dict1:\\n                dict1[val[1]].append(val[0])\\n            else:\\n                dict1[val[1]] = [val[0]]\\n        \\n        \\n        #create a copy of quiet as every person will be either itself or least quiet between itself and all its richer neighbors  \\n        result = list(quiet)\\n        \\n        for i in range(len(quiet)):\\n            #navigate all the neighbors richer than the node\\n            output = find_quietest(i)\\n            result[i] = output[0]\\n            #used for memoization\\n            memo[i] = output\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433995,
                "title": "javascript-dfs-memo-with-explanation",
                "content": "From the richer array [[a,b]], create a map with key and adjacency list\\n* key = person index (b)\\n* adjacency list = list of people directly richer than person (push a into map.get(b))\\n\\nCreate answer array. From person 0 to person n - 1 (0 indexed), find the quietest person and fill it into answer array.\\n* getQuietest(person) method finds the quiestest person richer or equal to the given person. \\n* It does so by comparing the quiet value of the given person and everyone in the person\\'s adj list, and if the adjacent people have their own adj list, do a DFS search through it. This will cover all richer/equal to ppl. Find the min quiet value from all these people and return the index of the quietest person.\\n* Before every return value, store the return value into the memo map. This prevents searching through the same person again.\\n \\n```\\nvar loudAndRich = function(richer, quiet) {\\n    const map = new Map();\\n    for (const [rich, poor] of richer) {\\n        map.set(poor, (map.get(poor) || new Set()).add(rich));        \\n    }\\n    \\n    const memo = new Map();\\n    const getQuietest = (person) => {\\n        if (memo.has(person)) return memo.get(person);\\n        const richerList = map.get(person);\\n        let min = quiet[person];\\n        let quietest = person;\\n        if (!richerList) {\\n            memo.set(person, quietest);\\n            return quietest;\\n        }\\n        for (const rich of richerList) {         \\n            if (quiet[getQuietest(rich)] < min) {\\n                min = quiet[getQuietest(rich)];\\n                quietest = getQuietest(rich);\\n            }            \\n        }\\n        memo.set(person, quietest);\\n        return quietest;\\n    }\\n    const answer = [];\\n    for (let i=0; i<quiet.length; i++) {\\n        answer.push(getQuietest(i));\\n    }\\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nvar loudAndRich = function(richer, quiet) {\\n    const map = new Map();\\n    for (const [rich, poor] of richer) {\\n        map.set(poor, (map.get(poor) || new Set()).add(rich));        \\n    }\\n    \\n    const memo = new Map();\\n    const getQuietest = (person) => {\\n        if (memo.has(person)) return memo.get(person);\\n        const richerList = map.get(person);\\n        let min = quiet[person];\\n        let quietest = person;\\n        if (!richerList) {\\n            memo.set(person, quietest);\\n            return quietest;\\n        }\\n        for (const rich of richerList) {         \\n            if (quiet[getQuietest(rich)] < min) {\\n                min = quiet[getQuietest(rich)];\\n                quietest = getQuietest(rich);\\n            }            \\n        }\\n        memo.set(person, quietest);\\n        return quietest;\\n    }\\n    const answer = [];\\n    for (let i=0; i<quiet.length; i++) {\\n        answer.push(getQuietest(i));\\n    }\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1383787,
                "title": "python-topological-sort-robbing-everyone-from-rich-to-poor",
                "content": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n = len(quiet)\\n        \\n        # build adjacency list and indegree for topological sort\\n        adj_list = [[] for _ in range(n)]\\n        indegree = [0] * n\\n        for rich, poor in richer:\\n            adj_list[rich].append(poor)\\n            indegree[poor] += 1\\n        \\n        # traverse(or rob) each node(or person) in topological order, from richest to poorest\\n        richer_and_louder = list(range(n))\\n        richest = [i for i, count in enumerate(indegree) if count == 0]\\n        for rich in iter(lambda: richest.pop() if richest else None, None):    #rob one by one until they all broke\\n            for poor in adj_list[rich]:\\n                richer_and_louder[poor] = min(richer_and_louder[poor], richer_and_louder[rich], key=quiet.__getitem__)\\n                indegree[poor] -= 1    # lower the poor\\'s poverty ranking since the richer has been robbed\\n                if indegree[poor] == 0:\\n                    richest.append(poor)   # poor is the one of the richest since no one is richer than him/her\\n        return richer_and_louder\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n = len(quiet)\\n        \\n        # build adjacency list and indegree for topological sort\\n        adj_list = [[] for _ in range(n)]\\n        indegree = [0] * n\\n        for rich, poor in richer:\\n            adj_list[rich].append(poor)\\n            indegree[poor] += 1\\n        \\n        # traverse(or rob) each node(or person) in topological order, from richest to poorest\\n        richer_and_louder = list(range(n))\\n        richest = [i for i, count in enumerate(indegree) if count == 0]\\n        for rich in iter(lambda: richest.pop() if richest else None, None):    #rob one by one until they all broke\\n            for poor in adj_list[rich]:\\n                richer_and_louder[poor] = min(richer_and_louder[poor], richer_and_louder[rich], key=quiet.__getitem__)\\n                indegree[poor] -= 1    # lower the poor\\'s poverty ranking since the richer has been robbed\\n                if indegree[poor] == 0:\\n                    richest.append(poor)   # poor is the one of the richest since no one is richer than him/her\\n        return richer_and_louder\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381156,
                "title": "simple-java-dfs-solution-99-faster-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    ArrayList<ArrayList<Integer>> graph;\\n    int output[];   //to store result\\n    \\n    public void addEdge(int u, int v){\\n        graph.get(u).add(v);\\n    }\\n    \\n    public void buildGraph(int[][] richer){\\n        for(int[] pair: richer){\\n            int poor= pair[1];\\n            int rich= pair[0];\\n            addEdge(poor,rich);  //adding edges from poor to rich\\n        }\\n    }\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n= quiet.length;\\n        graph= new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        buildGraph(richer);  //build adjacency list so that we can do dfs\\n        output= new int[n];\\n        Arrays.fill(output,-1);\\n        for(int i=0;i<n;i++){    //doing dfs\\n            if(output[i]==-1){\\n                dfs(i,quiet);\\n            }\\n        }\\n        return output;\\n    }\\n    \\n    public int dfs(int person, int quiet[]){\\n        \\n         if(output[person]!=-1)    //if we already know answer for this person return same answer (Memoization)\\n             return output[person];\\n        int least_quiet_person=person;   //initially the person himself is the least_quiet_person\\n        int least_quietness= quiet[person];\\n        \\n        for(int nbr: graph.get(person)){\\n            int newPerson= dfs(nbr,quiet);\\n            if(quiet[newPerson]<least_quietness){      //while doing dfs, if we found  a person who is more quiet we update our values\\n                least_quietness= quiet[newPerson];\\n                least_quiet_person=newPerson;\\n            }\\n        }\\n        output[person]=least_quiet_person;  //store the answer in output array\\n        return least_quiet_person;\\n        \\n      }\\n}      \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    ArrayList<ArrayList<Integer>> graph;\\n    int output[];   //to store result\\n    \\n    public void addEdge(int u, int v){\\n        graph.get(u).add(v);\\n    }\\n    \\n    public void buildGraph(int[][] richer){\\n        for(int[] pair: richer){\\n            int poor= pair[1];\\n            int rich= pair[0];\\n            addEdge(poor,rich);  //adding edges from poor to rich\\n        }\\n    }\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n= quiet.length;\\n        graph= new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        buildGraph(richer);  //build adjacency list so that we can do dfs\\n        output= new int[n];\\n        Arrays.fill(output,-1);\\n        for(int i=0;i<n;i++){    //doing dfs\\n            if(output[i]==-1){\\n                dfs(i,quiet);\\n            }\\n        }\\n        return output;\\n    }\\n    \\n    public int dfs(int person, int quiet[]){\\n        \\n         if(output[person]!=-1)    //if we already know answer for this person return same answer (Memoization)\\n             return output[person];\\n        int least_quiet_person=person;   //initially the person himself is the least_quiet_person\\n        int least_quietness= quiet[person];\\n        \\n        for(int nbr: graph.get(person)){\\n            int newPerson= dfs(nbr,quiet);\\n            if(quiet[newPerson]<least_quietness){      //while doing dfs, if we found  a person who is more quiet we update our values\\n                least_quietness= quiet[newPerson];\\n                least_quiet_person=newPerson;\\n            }\\n        }\\n        output[person]=least_quiet_person;  //store the answer in output array\\n        return least_quiet_person;\\n        \\n      }\\n}      \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782931,
                "title": "python-3-dfs-memoization-lru-cache",
                "content": "- First, we make a graph with dictionary, where key is person `x` and values are those who is richer than `x` (list of people). \\n- Second, we do a DFS and at the same time `lru_cache` will take care of the repeat input of any person `i`\\n\\n- `cur`: current quiet level\\n- `r`: current rich people who is least quiet\\n\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        graph = collections.defaultdict(list)\\n        for x, y in richer: graph[y].append(x)\\n\\t\\t\\n        @lru_cache(maxsize=None)\\n        def dfs(i):\\n            cur, r = quiet[i], i\\n            if i not in graph: return cur, r\\n            for rich in graph[i]:\\n                cur1, r1 = dfs(rich)\\n                if cur1 < cur:\\n                    cur, r = cur1, r1\\n            return cur, r \\n        return [dfs(i)[1] for i in range(len(quiet))]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        graph = collections.defaultdict(list)\\n        for x, y in richer: graph[y].append(x)\\n\\t\\t\\n        @lru_cache(maxsize=None)\\n        def dfs(i):\\n            cur, r = quiet[i], i\\n            if i not in graph: return cur, r\\n            for rich in graph[i]:\\n                cur1, r1 = dfs(rich)\\n                if cur1 < cur:\\n                    cur, r = cur1, r1\\n            return cur, r \\n        return [dfs(i)[1] for i in range(len(quiet))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039098,
                "title": "easy-topological-sort",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n= quiet.size();\\n        vector<vector<int>> graph(n);\\n        vector<int> ans(n);\\n        vector<int> in(n,0);\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n        }\\n        for(int i=0;i<richer.size();i++)\\n        {\\n           int u=richer[i][0];\\n           int v=richer[i][1];\\n           graph[u].push_back(v);\\n           in[v]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n    \\n       while(!q.empty())\\n       {\\n           int top=q.front();\\n           q.pop();\\n           for(auto x: graph[top])\\n           {   in[x]--;\\n               if(in[x]==0) q.push(x);\\n               if(quiet[ans[x]]>quiet[ans[top]])\\n               {\\n                   ans[x]=ans[top];\\n               }\\n\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n= quiet.size();\\n        vector<vector<int>> graph(n);\\n        vector<int> ans(n);\\n        vector<int> in(n,0);\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n        }\\n        for(int i=0;i<richer.size();i++)\\n        {\\n           int u=richer[i][0];\\n           int v=richer[i][1];\\n           graph[u].push_back(v);\\n           in[v]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n    \\n       while(!q.empty())\\n       {\\n           int top=q.front();\\n           q.pop();\\n           for(auto x: graph[top])\\n           {   in[x]--;\\n               if(in[x]==0) q.push(x);\\n               if(quiet[ans[x]]>quiet[ans[top]])\\n               {\\n                   ans[x]=ans[top];\\n               }\\n\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872237,
                "title": "easy-c-solution-using-topo-sort-94-ms-solution-beats-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        int c = richer.size();\\n        vector<int> adj[n], rev[n], indegree(n, 0), dup, m[n], ans(n);\\n        for(int i = 0; i < c; i++){\\n            int a = richer[i][0];\\n            int b = richer[i][1];\\n            adj[a].push_back(b);\\n            rev[b].push_back(a);\\n            indegree[b]++;\\n        }\\n        dup = indegree;\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < n; i++){\\n            if(indegree[i] == 0){\\n                q.push({i, 0});\\n            }\\n        }\\n        while(!q.empty()){\\n            int temp = q.front().first;\\n            int lvl = q.front().second;\\n            q.pop();\\n            m[lvl].push_back(quiet[temp]);\\n            for(auto it: adj[temp]){\\n                indegree[it]--;\\n                if(indegree[it] == 0){\\n                    q.push({it, lvl+1});\\n                }\\n            }\\n        }\\n        map<int, int> mp;\\n        for(int i = 0; i < n; i++){\\n            mp[quiet[i]] = i;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(m[i].size() == 0) break;\\n            for(auto it: m[i]){\\n                int c = mp[it];\\n                if(rev[c].size() == 0){ \\n                    ans[c] = c;\\n                }\\n                else{\\n                    int mini = quiet[c];\\n                    for(auto it2: rev[c]){\\n                        mini = min(mini, quiet[ans[it2]]);\\n                    }\\n                    ans[c] = mp[mini];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        int c = richer.size();\\n        vector<int> adj[n], rev[n], indegree(n, 0), dup, m[n], ans(n);\\n        for(int i = 0; i < c; i++){\\n            int a = richer[i][0];\\n            int b = richer[i][1];\\n            adj[a].push_back(b);\\n            rev[b].push_back(a);\\n            indegree[b]++;\\n        }\\n        dup = indegree;\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < n; i++){\\n            if(indegree[i] == 0){\\n                q.push({i, 0});\\n            }\\n        }\\n        while(!q.empty()){\\n            int temp = q.front().first;\\n            int lvl = q.front().second;\\n            q.pop();\\n            m[lvl].push_back(quiet[temp]);\\n            for(auto it: adj[temp]){\\n                indegree[it]--;\\n                if(indegree[it] == 0){\\n                    q.push({it, lvl+1});\\n                }\\n            }\\n        }\\n        map<int, int> mp;\\n        for(int i = 0; i < n; i++){\\n            mp[quiet[i]] = i;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(m[i].size() == 0) break;\\n            for(auto it: m[i]){\\n                int c = mp[it];\\n                if(rev[c].size() == 0){ \\n                    ans[c] = c;\\n                }\\n                else{\\n                    int mini = quiet[c];\\n                    for(auto it2: rev[c]){\\n                        mini = min(mini, quiet[ans[it2]]);\\n                    }\\n                    ans[c] = mp[mini];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819772,
                "title": "kahn-s-algorithm-topological-sort-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere, We can see there is a sequence a --> b --> c --> d, a is richer than b, b richer than c and so on. We can also observe one thing that the richest person cannot have anyone more quiet than him with more money. So, the answer for the richest will be the same person itself. So, we begin with the richest person (i.e in graph terms we can say that their indegree will be zero)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use Kahn\\'s algorithm to traverse the graph(persons) and updating their quietness and the answer array at the same time.\\n\\n# Complexity\\n- Time complexity:\\nO(N+E)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        vector<int> indeg(n,0);\\n        for(auto it: richer){\\n            adj[it[0]].push_back(it[1]);\\n            indeg[it[1]]++;\\n        }\\n\\n        queue<int> q;\\n        vector<int> answer(n);\\n        for(int i=0;i<n;i++){\\n            if(indeg[i] == 0){\\n                q.push(i);\\n            }\\n            answer[i] = i;\\n        }\\n\\n        while(!q.empty()){\\n            int curr = q.front();\\n            int currQ = quiet[curr];\\n            q.pop();\\n            for(auto it:adj[curr]){\\n                if(currQ<quiet[it]){\\n                    answer[it] = answer[curr];\\n                    quiet[it] = currQ;\\n                }\\n                indeg[it]--;\\n                if(indeg[it] == 0)\\n                q.push(it);\\n            }\\n\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        vector<int> indeg(n,0);\\n        for(auto it: richer){\\n            adj[it[0]].push_back(it[1]);\\n            indeg[it[1]]++;\\n        }\\n\\n        queue<int> q;\\n        vector<int> answer(n);\\n        for(int i=0;i<n;i++){\\n            if(indeg[i] == 0){\\n                q.push(i);\\n            }\\n            answer[i] = i;\\n        }\\n\\n        while(!q.empty()){\\n            int curr = q.front();\\n            int currQ = quiet[curr];\\n            q.pop();\\n            for(auto it:adj[curr]){\\n                if(currQ<quiet[it]){\\n                    answer[it] = answer[curr];\\n                    quiet[it] = currQ;\\n                }\\n                indeg[it]--;\\n                if(indeg[it] == 0)\\n                q.push(it);\\n            }\\n\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736867,
                "title": "simple-c-approach-using-topo-sort-and-dfs",
                "content": "# Intuition\\nI have used topo sort and made some minor changes to get the answer.\\n\\n# Space Complexity\\nApprox O(3V) -> adjacency list to store the graph, indegree for sorting and answer for storing the answer. \\'V\\' number of node.\\n\\n# Time Complexity\\nApprox O(V) + O(V + E)\\n\\n# Approach\\n- Initially I created the adj list and a indegree vector.\\n- Then I initialized the answer vector \\'ans\\' with the node itself because incase of node with indegree of zero the answer will be the node itself => `[0, 1, 2 , 3, 4, 5, 6, 7]`\\n- Then I have just added the nodes with indegree \\'0\\' to a queue.\\n- Next I will move directly to the condition as the rest of the code is pretty standard one.\\n- In the if statement I have compared the quiet value of the node that is stored as ans for the \"Current node\" with the quiet value of node stored in the ans for the \"child notes you may say\". Confused ?\\n- Consider the scenario `2 with quiet value of 5 ` and `1 with quiet value of 2`.\\n- In the if state `if(quiet[ans[node]] < quiet[ans[it]])` turns out to be `quiet[2] < quiet[1]` => `5 < 2`. The condition stands false and `ans[1] = 1`.\\n- Conside another scenario where condition is true. `5 with quiet value of 1` and `3 with quiet value of 4`.\\n- In the if state `if(quiet[ans[node]] < quiet[ans[it]])` turns out to be `quiet[5] < quiet[3]` => `1 < 4`. The condition stands true and `ans[3] = 5`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int V=quiet.size();\\n        vector<int> adj[V];\\n        vector<int> vis(V,0);\\n        vector<int> indegree(V,0);\\n        \\n        for(auto it:richer){\\n            adj[it[0]].push_back(it[1]);\\n            indegree[it[1]]++;\\n        }\\n\\n        vector<int> ans(V);\\n        queue<int> q;\\n        for(int i=0;i<V;i++){\\n            // initializing ans of each node with node value.\\n            ans[i]=i;\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n\\n            for(auto it: adj[node]){\\n                indegree[it]--;\\n\\n                // Updating the answer value of child node if the quiet value of child node is more than parent node.\\n               if(quiet[ans[node]] < quiet[ans[it]]){\\n                    ans[it]=ans[node];\\n                }\\n                if(indegree[it]==0)q.push(it);\\n            }\\n        }\\n\\n\\n\\n        return ans;\\n\\n    }\\n};\\n\\n**PLEASE CONSIDER UPVOTING IF YOU HAVE UNDERSTOOD MY APPROACH. USE A DRY RUN TO UNDERSTAND IT BETTER. **\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int V=quiet.size();\\n        vector<int> adj[V];\\n        vector<int> vis(V,0);\\n        vector<int> indegree(V,0);\\n        \\n        for(auto it:richer){\\n            adj[it[0]].push_back(it[1]);\\n            indegree[it[1]]++;\\n        }\\n\\n        vector<int> ans(V);\\n        queue<int> q;\\n        for(int i=0;i<V;i++){\\n            // initializing ans of each node with node value.\\n            ans[i]=i;\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n\\n            for(auto it: adj[node]){\\n                indegree[it]--;\\n\\n                // Updating the answer value of child node if the quiet value of child node is more than parent node.\\n               if(quiet[ans[node]] < quiet[ans[it]]){\\n                    ans[it]=ans[node];\\n                }\\n                if(indegree[it]==0)q.push(it);\\n            }\\n        }\\n\\n\\n\\n        return ans;\\n\\n    }\\n};\\n\\n**PLEASE CONSIDER UPVOTING IF YOU HAVE UNDERSTOOD MY APPROACH. USE A DRY RUN TO UNDERSTAND IT BETTER. **\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353212,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int[] quietest = new int[quiet.length];\\n        for(int i = 0; i < quiet.length; i++){\\n            quietest[i] = searchForQuietest(richer, quiet, i, quietest);\\n        }\\n        return quietest;\\n    }\\n    public int searchForQuietest(int[][] richer, int[] quiet, int person, int[] quietest){\\n        int leastQuiet = person;\\n        for(int i = 0; i < richer.length; i++){\\n            if(richer[i][1] == person){\\n                int leastQuietPerson;\\n                if(quietest[richer[i][0]] != 0)\\n                    leastQuietPerson = quietest[richer[i][0]];\\n                else leastQuietPerson = searchForQuietest(richer, quiet, richer[i][0], quietest);\\n                leastQuiet = Math.min(quiet[leastQuietPerson], quiet[leastQuiet]) == quiet[leastQuiet]?leastQuiet: leastQuietPerson;\\n            }\\n        }\\n    return leastQuiet;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int[] quietest = new int[quiet.length];\\n        for(int i = 0; i < quiet.length; i++){\\n            quietest[i] = searchForQuietest(richer, quiet, i, quietest);\\n        }\\n        return quietest;\\n    }\\n    public int searchForQuietest(int[][] richer, int[] quiet, int person, int[] quietest){\\n        int leastQuiet = person;\\n        for(int i = 0; i < richer.length; i++){\\n            if(richer[i][1] == person){\\n                int leastQuietPerson;\\n                if(quietest[richer[i][0]] != 0)\\n                    leastQuietPerson = quietest[richer[i][0]];\\n                else leastQuietPerson = searchForQuietest(richer, quiet, richer[i][0], quietest);\\n                leastQuiet = Math.min(quiet[leastQuietPerson], quiet[leastQuiet]) == quiet[leastQuiet]?leastQuiet: leastQuietPerson;\\n            }\\n        }\\n    return leastQuiet;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050307,
                "title": "c-dp-easy-and-clean-code",
                "content": "# Intuition\\nMake a list of all the people who are richer than ith person\\n\\n# Approach\\nTraverse the list and store person with minimum quietness level.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void makeList(unordered_map<int, list<int>> &adj, vector<vector<int>>& richer){\\n        for(auto i : richer){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n    }\\n\\n    pair<int, int> solve(unordered_map<int, list<int>> &adj, vector<int>& quiet, vector<pair<int, int>> &dp, int node){\\n        if(dp[node].first != -1) return dp[node];\\n\\n        pair<int, int> num = {node, quiet[node]};\\n\\n        for(auto i : adj[node]){\\n            pair<int, int> temp = solve(adj, quiet, dp, i);\\n\\n            if(temp.second < num.second){\\n                num = temp;\\n            }\\n        }\\n\\n        return dp[node] = num;\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        unordered_map<int, list<int>> adj;\\n        makeList(adj, richer);\\n\\n        vector<pair<int, int>> dp(n, {-1, -1});\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++){\\n            pair<int, int> res = solve(adj, quiet, dp, i);\\n            ans[i] = res.first;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void makeList(unordered_map<int, list<int>> &adj, vector<vector<int>>& richer){\\n        for(auto i : richer){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n    }\\n\\n    pair<int, int> solve(unordered_map<int, list<int>> &adj, vector<int>& quiet, vector<pair<int, int>> &dp, int node){\\n        if(dp[node].first != -1) return dp[node];\\n\\n        pair<int, int> num = {node, quiet[node]};\\n\\n        for(auto i : adj[node]){\\n            pair<int, int> temp = solve(adj, quiet, dp, i);\\n\\n            if(temp.second < num.second){\\n                num = temp;\\n            }\\n        }\\n\\n        return dp[node] = num;\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        unordered_map<int, list<int>> adj;\\n        makeList(adj, richer);\\n\\n        vector<pair<int, int>> dp(n, {-1, -1});\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++){\\n            pair<int, int> res = solve(adj, quiet, dp, i);\\n            ans[i] = res.first;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982984,
                "title": "fastest-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N+LENGTH OF RICHER)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N*LENGTH OF RICHER)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dfs(self,node,visited,ans,value,lst):\\n        # print(node)\\n        visited[node]=1\\n        for i in lst[node]:\\n            if visited[i]==0:\\n                self.dfs(i,visited,ans,value,lst)\\n            x=value[i]\\n            # print(node,i,value[node],x)\\n            if x<value[node]:\\n                value[node]=x\\n                ans[node]=ans[i]\\n        return \\n\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n=len(quiet)\\n        visited=[0]*n\\n        lst=[[] for i in range(n)]\\n        for i,j in richer:\\n            lst[j].append(i)\\n        # print(lst)\\n        ans=[i for i in range(n)]\\n        value=[quiet[i] for i in range(n)]\\n        for i in range(n):\\n            if visited[i]==0:\\n                self.dfs(i,visited,ans,value,lst)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self,node,visited,ans,value,lst):\\n        # print(node)\\n        visited[node]=1\\n        for i in lst[node]:\\n            if visited[i]==0:\\n                self.dfs(i,visited,ans,value,lst)\\n            x=value[i]\\n            # print(node,i,value[node],x)\\n            if x<value[node]:\\n                value[node]=x\\n                ans[node]=ans[i]\\n        return \\n\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n=len(quiet)\\n        visited=[0]*n\\n        lst=[[] for i in range(n)]\\n        for i,j in richer:\\n            lst[j].append(i)\\n        # print(lst)\\n        ans=[i for i in range(n)]\\n        value=[quiet[i] for i in range(n)]\\n        for i in range(n):\\n            if visited[i]==0:\\n                self.dfs(i,visited,ans,value,lst)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982738,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N+length of richer)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*length of richer)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n=len(quiet)\\n        indegree=[0]*n\\n        lst=[[] for i in range(n)]\\n        for i,j in richer:\\n            lst[i].append(j)\\n            indegree[j]+=1\\n        ans=[i for i in range(n)]\\n        value=[quiet[i] for i in range(n)]\\n        st=[]\\n        for i in range(n):\\n            if indegree[i]==0:\\n                st.append(i)\\n        while st:\\n            x=st.pop(0)\\n            for i in lst[x]:\\n                indegree[i]-=1\\n                if value[x]<value[i]:\\n                    ans[i]=ans[x]\\n                    value[i]=value[x]\\n                if indegree[i]==0:\\n                    st.append(i)\\n        return ans\\n                \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n=len(quiet)\\n        indegree=[0]*n\\n        lst=[[] for i in range(n)]\\n        for i,j in richer:\\n            lst[i].append(j)\\n            indegree[j]+=1\\n        ans=[i for i in range(n)]\\n        value=[quiet[i] for i in range(n)]\\n        st=[]\\n        for i in range(n):\\n            if indegree[i]==0:\\n                st.append(i)\\n        while st:\\n            x=st.pop(0)\\n            for i in lst[x]:\\n                indegree[i]-=1\\n                if value[x]<value[i]:\\n                    ans[i]=ans[x]\\n                    value[i]=value[x]\\n                if indegree[i]==0:\\n                    st.append(i)\\n        return ans\\n                \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919252,
                "title": "dfs-memoization-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int, int> dfs(int node, vector<int> adjList[], vector<int> &quiet, unordered_map<int, pair<int, int>> &Map) {\\n        \\n        if(Map.count(node) == 1) return Map[node];\\n        \\n        pair<int, int> ans = {node, quiet[node]}; \\n        \\n        for(auto &iter : adjList[node]) {\\n            pair<int, int> temp = dfs(iter, adjList, quiet, Map);\\n            \\n            if(temp.second <= ans.second) {\\n                ans = temp;\\n            }\\n        }\\n        \\n        return Map[node] = ans;\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adjList[n], ans(n);\\n        \\n        for(int i = 0; i < richer.size(); i++) {\\n            int v = richer[i][0];\\n            int u = richer[i][1];\\n            \\n            adjList[u].push_back(v);\\n        }\\n        \\n        unordered_map<int, pair<int, int>> Map;\\n\\n        for(int i = 0; i < n; i++) {\\n            pair<int, int> curr = dfs(i, adjList, quiet, Map);\\n            \\n            ans[i] = curr.first;\\n        }\\n        \\n        return ans;\\n    } \\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    pair<int, int> dfs(int node, vector<int> adjList[], vector<int> &quiet, unordered_map<int, pair<int, int>> &Map) {\\n        \\n        if(Map.count(node) == 1) return Map[node];\\n        \\n        pair<int, int> ans = {node, quiet[node]}",
                "codeTag": "Java"
            },
            {
                "id": 2895828,
                "title": "loud-and-rich-using-dfs-and-priority-queue",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int ans[];\\n    Map<Integer,List<Integer>> map=new HashMap<>();\\n    int temp[]=new int[0];\\n    int curr_node=0;\\n    List<Integer> vis=new ArrayList<Integer>();\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        \\n        ans=new int[quiet.length];\\n        for(int i=0;i<=richer.length;i++){\\n            \\n            if(!map.containsKey(i)){\\n                map.put(i,new ArrayList());\\n            }\\n            if(i<richer.length && !map.containsKey(richer[i][0])){\\n                map.put(richer[i][0],new ArrayList());\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n            else if(i<richer.length){\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n        }\\n        \\n        Comparator<pair> comp=new Comparator<pair>(){\\n            public int compare(pair p1,pair p2){\\n                if(p1.cost>p2.cost){\\n                    return 1;\\n                }\\n                else{\\n                    return -1;\\n                }\\n\\n            }\\n        };\\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\\n        for(int i=0;i<quiet.length;i++){\\n            ans[i]=-1;\\n            pq.add(new pair(i,quiet[i]));\\n        }\\n        \\n        while(!pq.isEmpty()){\\n            pair top=pq.poll();\\n            //System.out.println(top.node+\" \"+top.cost);\\n            curr_node=top.node;\\n            if(!vis.contains(top.node)){\\n            dfs(top.node);\\n            }\\n        }\\n        return ans;\\n       \\n    }\\n    public void dfs(int node){\\n        //System.out.println(node);\\n        if(ans[node]==-1){\\n            ans[node]=curr_node;\\n        }\\n        if(!vis.contains(node) && map.containsKey(node)){\\n            vis.add(node);\\n             \\n            for(int i : map.get(node)){\\n            dfs(i);\\n        \\n        }\\n        }\\n            \\n    }\\n}\\n\\nclass pair{\\n    int node,cost;\\n    pair(int node,int cost){\\n        this.node=node;\\n        this.cost=cost;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans[];\\n    Map<Integer,List<Integer>> map=new HashMap<>();\\n    int temp[]=new int[0];\\n    int curr_node=0;\\n    List<Integer> vis=new ArrayList<Integer>();\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        \\n        ans=new int[quiet.length];\\n        for(int i=0;i<=richer.length;i++){\\n            \\n            if(!map.containsKey(i)){\\n                map.put(i,new ArrayList());\\n            }\\n            if(i<richer.length && !map.containsKey(richer[i][0])){\\n                map.put(richer[i][0],new ArrayList());\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n            else if(i<richer.length){\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n        }\\n        \\n        Comparator<pair> comp=new Comparator<pair>(){\\n            public int compare(pair p1,pair p2){\\n                if(p1.cost>p2.cost){\\n                    return 1;\\n                }\\n                else{\\n                    return -1;\\n                }\\n\\n            }\\n        };\\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\\n        for(int i=0;i<quiet.length;i++){\\n            ans[i]=-1;\\n            pq.add(new pair(i,quiet[i]));\\n        }\\n        \\n        while(!pq.isEmpty()){\\n            pair top=pq.poll();\\n            //System.out.println(top.node+\" \"+top.cost);\\n            curr_node=top.node;\\n            if(!vis.contains(top.node)){\\n            dfs(top.node);\\n            }\\n        }\\n        return ans;\\n       \\n    }\\n    public void dfs(int node){\\n        //System.out.println(node);\\n        if(ans[node]==-1){\\n            ans[node]=curr_node;\\n        }\\n        if(!vis.contains(node) && map.containsKey(node)){\\n            vis.add(node);\\n             \\n            for(int i : map.get(node)){\\n            dfs(i);\\n        \\n        }\\n        }\\n            \\n    }\\n}\\n\\nclass pair{\\n    int node,cost;\\n    pair(int node,int cost){\\n        this.node=node;\\n        this.cost=cost;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506190,
                "title": "java-bfs-o-v-e-topological-sort",
                "content": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int n = quiet.length;\\n        for(int i = 0; i < n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }\\n        \\n        int[] inDegree = new int[n];\\n        for(int[] edge : richer) {\\n            graph.get(edge[0]).add(edge[1]);\\n            inDegree[edge[1]]++;\\n        }\\n        \\n        Queue<Integer> queue = new ArrayDeque<>();\\n        int[] result = new int[n];\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(inDegree[i] == 0) {\\n                queue.offer(i);\\n            }\\n            result[i] = i;\\n        }\\n        \\n        while(!queue.isEmpty()) {\\n            Integer curr = queue.poll();\\n            for(Integer neighbour : graph.get(curr)) {\\n                inDegree[neighbour]--;\\n                if(inDegree[neighbour] == 0) {\\n                    queue.offer(neighbour);\\n                }\\n                \\n                if(quiet[result[neighbour]] > quiet[result[curr]]) {\\n                    result[neighbour] = result[curr];\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int n = quiet.length;\\n        for(int i = 0; i < n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }\\n        \\n        int[] inDegree = new int[n];\\n        for(int[] edge : richer) {\\n            graph.get(edge[0]).add(edge[1]);\\n            inDegree[edge[1]]++;\\n        }\\n        \\n        Queue<Integer> queue = new ArrayDeque<>();\\n        int[] result = new int[n];\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(inDegree[i] == 0) {\\n                queue.offer(i);\\n            }\\n            result[i] = i;\\n        }\\n        \\n        while(!queue.isEmpty()) {\\n            Integer curr = queue.poll();\\n            for(Integer neighbour : graph.get(curr)) {\\n                inDegree[neighbour]--;\\n                if(inDegree[neighbour] == 0) {\\n                    queue.offer(neighbour);\\n                }\\n                \\n                if(quiet[result[neighbour]] > quiet[result[curr]]) {\\n                    result[neighbour] = result[curr];\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305768,
                "title": "c-simple-dfs",
                "content": "\\t```\\n\\tint dfs(int src, vector<int>& vis, vector<int>& quiet, vector<int> adj[], vector<int>& ans)  {\\n        vis[src] = 1;\\n        ans[src] = src;\\n        for(auto child : adj[src])\\n        {\\n            if(!vis[child])\\n            {\\n                int y = dfs(child,vis,quiet,adj,ans);\\n                if(quiet[y] < quiet[ans[src]])\\n                    ans[src] = y;\\n            }\\n            else\\n            {\\n                if(quiet[ans[child]] < quiet[ans[src]])\\n                    ans[src] = ans[child];\\n            }\\n        }\\n       return ans[src];\\n    }\\n\\tvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> ans(n,0), vis(n,0),  adj[n];\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n                dfs(i,vis,quiet,adj,ans);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n\\tint dfs(int src, vector<int>& vis, vector<int>& quiet, vector<int> adj[], vector<int>& ans)  {\\n        vis[src] = 1;\\n        ans[src] = src;\\n        for(auto child : adj[src])\\n        {\\n            if(!vis[child])\\n            {\\n                int y = dfs(child,vis,quiet,adj,ans);\\n                if(quiet[y] < quiet[ans[src]])\\n                    ans[src] = y;\\n            }\\n            else\\n            {\\n                if(quiet[ans[child]] < quiet[ans[src]])\\n                    ans[src] = ans[child];\\n            }\\n        }\\n       return ans[src];\\n    }\\n\\tvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> ans(n,0), vis(n,0),  adj[n];\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n                dfs(i,vis,quiet,adj,ans);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2185754,
                "title": "easy-c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void check(int x,vector<vector<int>> &adj,vector<int>&ans,vector<int>& quiet,int min,int n){\\n        int res=x;\\n        vector<int> vis(n,0);\\n        vis[x]=1;\\n        queue<int> q;\\n        q.push(x);\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto it:adj[node]){\\n                if(vis[it]==0){\\n                    vis[it]=1;\\n                    if(quiet[it]<min){\\n                        min=quiet[it];\\n                        res=it;\\n                    }\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        ans.push_back(res);\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>> adj(n);\\n        for(auto it:richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            check(i,adj,ans,quiet,quiet[i],n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void check(int x,vector<vector<int>> &adj,vector<int>&ans,vector<int>& quiet,int min,int n){\\n        int res=x;\\n        vector<int> vis(n,0);\\n        vis[x]=1;\\n        queue<int> q;\\n        q.push(x);\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto it:adj[node]){\\n                if(vis[it]==0){\\n                    vis[it]=1;\\n                    if(quiet[it]<min){\\n                        min=quiet[it];\\n                        res=it;\\n                    }\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        ans.push_back(res);\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>> adj(n);\\n        for(auto it:richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            check(i,adj,ans,quiet,quiet[i],n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162438,
                "title": "kahn-s-algorithm-c-code",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n\\t\\n        int n = quiet.size(); \\n        vector<int> indegree(n,0);\\n        vector<int> ans(n,0);\\n        vector<vector<int>> adj(n);\\n        queue<int> q;\\n        \\n        for(auto it: richer)\\n        {\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            indegree[v]++;\\n        }\\n        \\n        \\n        for(int i =0;i<n;i++)\\n        {\\n            ans[i]=i;\\n            if(indegree[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            for(auto it: adj[node])\\n            {\\n                if(quiet[ans[it]]>quiet[ans[node]])\\n                {\\n                    ans[it]= ans[node];\\n                }\\n                    \\n                indegree[it]--;\\n                \\n                if(indegree[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n\\t\\n        int n = quiet.size(); \\n        vector<int> indegree(n,0);\\n        vector<int> ans(n,0);\\n        vector<vector<int>> adj(n);\\n        queue<int> q;\\n        \\n        for(auto it: richer)\\n        {\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            indegree[v]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2157804,
                "title": "c-code-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[505];\\n    vector<int> ans;\\n    \\n    void dfs(int node,int parent,vector<int> &q){\\n        if (parent!=-1 && q[node]>q[parent]){\\n            q[node]=q[parent];\\n            ans[node]=ans[parent];\\n        }\\n        else if (parent!=-1){\\n            return;\\n        }\\n       \\n        for (auto it: adj[node]){\\n            if (it!=parent){\\n                dfs(it,node,q);\\n            }\\n        }\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& v, vector<int>& q) {\\n        int i;\\n        int n=v.size();\\n        \\n        for (i=0; i<n; i++){\\n            adj[v[i][0]].push_back(v[i][1]);\\n        }\\n        for (i=0; i<q.size(); i++){\\n            ans.push_back(i);\\n        }\\n        \\n        for (i=0; i<q.size(); i++){\\n            dfs(i,-1,q);\\n        }\\n        \\n        \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[505];\\n    vector<int> ans;\\n    \\n    void dfs(int node,int parent,vector<int> &q){\\n        if (parent!=-1 && q[node]>q[parent]){\\n            q[node]=q[parent];\\n            ans[node]=ans[parent];\\n        }\\n        else if (parent!=-1){\\n            return;\\n        }\\n       \\n        for (auto it: adj[node]){\\n            if (it!=parent){\\n                dfs(it,node,q);\\n            }\\n        }\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& v, vector<int>& q) {\\n        int i;\\n        int n=v.size();\\n        \\n        for (i=0; i<n; i++){\\n            adj[v[i][0]].push_back(v[i][1]);\\n        }\\n        for (i=0; i<q.size(); i++){\\n            ans.push_back(i);\\n        }\\n        \\n        for (i=0; i<q.size(); i++){\\n            dfs(i,-1,q);\\n        }\\n        \\n        \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112749,
                "title": "c-dfs-topological-sort",
                "content": "Step 1: Create graph with edge in direction of increasing Richness.\\nStep 2: Run DFS on all 0 indegree nodes.\\nStep 3: Return min value node from dfs method comparing current node quietness value with all child nodes.\\nStep 4: Use the result array to reduce reprocessing (DP) if the node is already visited.\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> quiet;\\n    vector<vector<int>> adjList;\\n    vector<bool> isVisited;\\n    vector<int> result;\\n    \\n    int dfs(int curr) {\\n        isVisited[curr] = true;\\n        int minV = curr;\\n        \\n        for (int i : adjList[curr]) {\\n            if (!isVisited[i]) {\\n                int temp = dfs(i);\\n                if (quiet[minV] > quiet[temp]) {\\n                    minV = temp;\\n                }\\n            } else {\\n                if (quiet[minV] > quiet[result[i]]) {\\n                    minV = result[i];\\n                }\\n            }\\n        }\\n        \\n        result[curr] = minV;\\n        return minV;\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        n = quiet.size();\\n        result.assign(n, 0);\\n        adjList.assign(n, vector<int>(0));\\n        isVisited.assign(n, false);\\n        this->quiet = quiet;\\n        \\n        for (vector<int> edge : richer) {\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        for (int i=0 ; i<n ; i++) {\\n            if (!isVisited[i])\\n                dfs(i);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> quiet;\\n    vector<vector<int>> adjList;\\n    vector<bool> isVisited;\\n    vector<int> result;\\n    \\n    int dfs(int curr) {\\n        isVisited[curr] = true;\\n        int minV = curr;\\n        \\n        for (int i : adjList[curr]) {\\n            if (!isVisited[i]) {\\n                int temp = dfs(i);\\n                if (quiet[minV] > quiet[temp]) {\\n                    minV = temp;\\n                }\\n            } else {\\n                if (quiet[minV] > quiet[result[i]]) {\\n                    minV = result[i];\\n                }\\n            }\\n        }\\n        \\n        result[curr] = minV;\\n        return minV;\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        n = quiet.size();\\n        result.assign(n, 0);\\n        adjList.assign(n, vector<int>(0));\\n        isVisited.assign(n, false);\\n        this->quiet = quiet;\\n        \\n        for (vector<int> edge : richer) {\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        for (int i=0 ; i<n ; i++) {\\n            if (!isVisited[i])\\n                dfs(i);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054250,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(const int &node,unordered_map<int,vector<int>> &edges,vector<int> &quiet,vector<int> &ans){\\n        ans[node] = node;  \\n        for(const int &i:edges[node]){\\n            if(ans[i] == -1) dfs(i,edges,quiet,ans);\\n            if(quiet[node] > quiet[i]){\\n                quiet[node] = quiet[i];\\n                ans[node] = ans[i];\\n            }\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        unordered_map<int,vector<int>> edges;\\n        const int n = quiet.size();\\n        vector<int> ans(n,-1);\\n        for(auto const &it:richer) edges[it[1]].emplace_back(it[0]);\\n        for(int i = 0;i<n;i++){\\n            if(ans[i] == -1) dfs(i,edges,quiet,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(const int &node,unordered_map<int,vector<int>> &edges,vector<int> &quiet,vector<int> &ans){\\n        ans[node] = node;  \\n        for(const int &i:edges[node]){\\n            if(ans[i] == -1) dfs(i,edges,quiet,ans);\\n            if(quiet[node] > quiet[i]){\\n                quiet[node] = quiet[i];\\n                ans[node] = ans[i];\\n            }\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        unordered_map<int,vector<int>> edges;\\n        const int n = quiet.size();\\n        vector<int> ans(n,-1);\\n        for(auto const &it:richer) edges[it[1]].emplace_back(it[0]);\\n        for(int i = 0;i<n;i++){\\n            if(ans[i] == -1) dfs(i,edges,quiet,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812925,
                "title": "illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/90319328-3390-4713-9eca-898e38f9c32a_1646224652.1311088.png)\\n\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        \"\"\" O(N^2)TS \"\"\"\\n        nodes = list(range(len(quiet)))\\n        grid = {n: [] for n in nodes}\\n        [grid[b].append(a) for a, b in richer]\\n\\n        @functools.cache\\n        def fn(node):\\n            return min([node] + [fn(kid) for kid in grid[node]], key=lambda n: quiet[n])\\n\\n        return map(fn, nodes)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/90319328-3390-4713-9eca-898e38f9c32a_1646224652.1311088.png)\\n\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        \"\"\" O(N^2)TS \"\"\"\\n        nodes = list(range(len(quiet)))\\n        grid = {n: [] for n in nodes}\\n        [grid[b].append(a) for a, b in richer]\\n\\n        @functools.cache\\n        def fn(node):\\n            return min([node] + [fn(kid) for kid in grid[node]], key=lambda n: quiet[n])\\n\\n        return map(fn, nodes)",
                "codeTag": "Python3"
            },
            {
                "id": 1799395,
                "title": "c-dfs-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        unordered_map<int, vector<int>> richerMap;\\n        vector<int> res = vector<int> (quiet.size(), -1);\\n        for (auto v : richer) richerMap[v[1]].push_back(v[0]);\\n        for (int i = 0; i < quiet.size(); i++) dfs(i, quiet, richerMap, res);\\n        return res;\\n    }\\n\\n    int dfs(int i, vector<int>& quiet, unordered_map<int, vector<int>>& richerMap, vector<int>& res) {\\n        if (res[i] >= 0) \\n            return res[i];\\n        res[i] = i;\\n        for (int j : richerMap[i]) if (quiet[res[i]] > quiet[dfs(j, quiet, richerMap, res)]) res[i] = res[j];\\n        return res[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        unordered_map<int, vector<int>> richerMap;\\n        vector<int> res = vector<int> (quiet.size(), -1);\\n        for (auto v : richer) richerMap[v[1]].push_back(v[0]);\\n        for (int i = 0; i < quiet.size(); i++) dfs(i, quiet, richerMap, res);\\n        return res;\\n    }\\n\\n    int dfs(int i, vector<int>& quiet, unordered_map<int, vector<int>>& richerMap, vector<int>& res) {\\n        if (res[i] >= 0) \\n            return res[i];\\n        res[i] = i;\\n        for (int j : richerMap[i]) if (quiet[res[i]] > quiet[dfs(j, quiet, richerMap, res)]) res[i] = res[j];\\n        return res[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734814,
                "title": "dp-intuitive-postorder",
                "content": "```\\nclass Solution {\\npublic:\\n    //Simple Postorder Classical Dp \\n    vector<int> dp;\\n    int dfs(vector<vector<int>>& g,int i,vector<int>&q){\\n        if(dp[i]!=-1) return dp[i];\\n        int mini=i;\\n        for(auto nbr:g[i]){\\n            int a=dfs(g,nbr,q);\\n            if(q[mini]>q[a]) mini=a;\\n        }\\n        return dp[i]=mini;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& q) {\\n        int n=q.size();\\n        vector<vector<int>> g(n);\\n        for(auto i:richer){\\n            g[i[1]].push_back(i[0]);\\n        }\\n        dp=vector<int>(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==-1) dp[i]=dfs(g,i,q);\\n        }\\n        \\n        return dp;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n    //Simple Postorder Classical Dp \\n    vector<int> dp;\\n    int dfs(vector<vector<int>>& g,int i,vector<int>&q){\\n        if(dp[i]!=-1) return dp[i];\\n        int mini=i;\\n        for(auto nbr:g[i]){\\n            int a=dfs(g,nbr,q);\\n            if(q[mini]>q[a]) mini=a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1630491,
                "title": "c-o-v-e-linear",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>> graph(n);\\n        for(auto e:richer) graph[e[1]].push_back(e[0]);\\n        vector<bool> visited(n,false);\\n        vector<int> loud(n);\\n        for(int i=0;i<n;i++) dfs(graph,i,visited,loud,quiet);  \\n        return loud;\\n    }\\n    \\n    int dfs(vector<vector<int>>& graph,int node,vector<bool>& visited,vector<int>& loud,vector<int>& quiet) {\\n        if(visited[node]) return loud[node];\\n        visited[node]=true;\\n        int loudIdx=node;\\n        for(int adj:graph[node]) {\\n            int dfsIdx=dfs(graph,adj,visited,loud,quiet);\\n            if(quiet[dfsIdx]<quiet[loudIdx]) loudIdx=dfsIdx;\\n        }\\n        return loud[node]=loudIdx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Topological Sort",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>> graph(n);\\n        for(auto e:richer) graph[e[1]].push_back(e[0]);\\n        vector<bool> visited(n,false);\\n        vector<int> loud(n);\\n        for(int i=0;i<n;i++) dfs(graph,i,visited,loud,quiet);  \\n        return loud;\\n    }\\n    \\n    int dfs(vector<vector<int>>& graph,int node,vector<bool>& visited,vector<int>& loud,vector<int>& quiet) {\\n        if(visited[node]) return loud[node];\\n        visited[node]=true;\\n        int loudIdx=node;\\n        for(int adj:graph[node]) {\\n            int dfsIdx=dfs(graph,adj,visited,loud,quiet);\\n            if(quiet[dfsIdx]<quiet[loudIdx]) loudIdx=dfsIdx;\\n        }\\n        return loud[node]=loudIdx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395206,
                "title": "python-dfs-directed-graph-beats-95",
                "content": "Idea is considering the richer people as parents and having directed edges to poorer ones and then fact that quiter people can effect themselves and poorer people than them.\\n\\nThe order of processing the nodes is quiter to louder people and updating the answer. The answer also acts a visited array meaning we don\\'t need to update a quiter person that was already updated.\\n\\n```\\nclass Solution:\\n    def dfs(self, adj_list, ans, node, par):\\n        ans[node] = par\\n        \\n        for neig in adj_list[node]:\\n            if ans[neig] == -1:\\n                self.dfs(adj_list, ans, neig, par)\\n        \\n    \\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        order = [(quietness, idx) for idx, quietness in enumerate(quiet)]\\n        order.sort()\\n        n = len(quiet)\\n        \\n        # form adj list\\n        adj_list = collections.defaultdict(lambda: [])\\n        for par, child in richer:\\n            adj_list[par].append(child)\\n             \\n        ans = [-1]*n\\n        while order:\\n            _, node = order.pop(0)\\n            \\n            # update all possible child for the node using dfs\\n            # if not updated yet\\n            # no need of visited since there would be no cycles\\n            if ans[node] == -1:\\n                self.dfs(adj_list, ans, node, node)\\n                \\n        return ans\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self, adj_list, ans, node, par):\\n        ans[node] = par\\n        \\n        for neig in adj_list[node]:\\n            if ans[neig] == -1:\\n                self.dfs(adj_list, ans, neig, par)\\n        \\n    \\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        order = [(quietness, idx) for idx, quietness in enumerate(quiet)]\\n        order.sort()\\n        n = len(quiet)\\n        \\n        # form adj list\\n        adj_list = collections.defaultdict(lambda: [])\\n        for par, child in richer:\\n            adj_list[par].append(child)\\n             \\n        ans = [-1]*n\\n        while order:\\n            _, node = order.pop(0)\\n            \\n            # update all possible child for the node using dfs\\n            # if not updated yet\\n            # no need of visited since there would be no cycles\\n            if ans[node] == -1:\\n                self.dfs(adj_list, ans, node, node)\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362662,
                "title": "c-using-kahn-s-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) \\n    {\\n        int n = quiet.size();\\n        vector<int> indegree(n,0),ans(n);\\n        vector<vector<int>> g(n);\\n        queue<int> leaves;\\n        \\n        for (auto& x:richer)\\n        {\\n            g[x[0]].push_back(x[1]);\\n            indegree[x[1]]++;\\n        }\\n        \\n        for (int i=0;i<n;i++)\\n        {\\n            if (indegree[i]==0)\\n                leaves.push(i);\\n            ans[i]=i;\\n        }\\n        \\n        while (!leaves.empty())\\n        {\\n            int sz=leaves.size();\\n            for (int i=0;i<sz;i++)\\n            {\\n                int x = leaves.front();\\n                leaves.pop();\\n                \\n                for (auto& neighbour:g[x])\\n                {\\n                    indegree[neighbour]--;\\n                    if (quiet[ans[neighbour]]>quiet[ans[x]])\\n                        ans[neighbour]=ans[x];\\n                    if (indegree[neighbour]==0)\\n                        leaves.push(neighbour);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) \\n    {\\n        int n = quiet.size();\\n        vector<int> indegree(n,0),ans(n);\\n        vector<vector<int>> g(n);\\n        queue<int> leaves;\\n        \\n        for (auto& x:richer)\\n        {\\n            g[x[0]].push_back(x[1]);\\n            indegree[x[1]]++;\\n        }\\n        \\n        for (int i=0;i<n;i++)\\n        {\\n            if (indegree[i]==0)\\n                leaves.push(i);\\n            ans[i]=i;\\n        }\\n        \\n        while (!leaves.empty())\\n        {\\n            int sz=leaves.size();\\n            for (int i=0;i<sz;i++)\\n            {\\n                int x = leaves.front();\\n                leaves.pop();\\n                \\n                for (auto& neighbour:g[x])\\n                {\\n                    indegree[neighbour]--;\\n                    if (quiet[ans[neighbour]]>quiet[ans[x]])\\n                        ans[neighbour]=ans[x];\\n                    if (indegree[neighbour]==0)\\n                        leaves.push(neighbour);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256998,
                "title": "c-dfs-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    unordered_map<int,int>visited,SILENT;\\n    \\n    \\n    int dfs(unordered_map<int,vector<int>>&graph,vector<int>& quiet,int i)\\n    {\\n        int a=INT_MAX;\\n        \\n        for(auto x:graph[i])\\n        {\\n            if(!visited[x])\\n            {\\n               a=std::min(a,dfs(graph,quiet,x));\\n            }\\n            else\\n            {\\n                a=std::min(a,visited[x]);\\n            }\\n            \\n        }\\n        \\n        return visited[i]=std::min(a,quiet[i]+1);\\n        \\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        vector<int>ans;\\n        unordered_map<int,vector<int>>graph;\\n        \\n        \\n        for(int i=0;i<quiet.size();i++)\\n        {\\n            SILENT[quiet[i]]=i;\\n        }\\n        \\n        \\n        for(auto x:richer)\\n        {\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        for(int i=0;i<quiet.size();i++)\\n        {\\n            if(!visited[i])\\n            {\\n                visited[i]=dfs(graph,quiet,i);\\n            }\\n            ans.push_back(SILENT[visited[i]-1]);\\n        }\\n        return ans;\\n   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    unordered_map<int,int>visited,SILENT;\\n    \\n    \\n    int dfs(unordered_map<int,vector<int>>&graph,vector<int>& quiet,int i)\\n    {\\n        int a=INT_MAX;\\n        \\n        for(auto x:graph[i])\\n        {\\n            if(!visited[x])\\n            {\\n               a=std::min(a,dfs(graph,quiet,x));\\n            }\\n            else\\n            {\\n                a=std::min(a,visited[x]);\\n            }\\n            \\n        }\\n        \\n        return visited[i]=std::min(a,quiet[i]+1);\\n        \\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        vector<int>ans;\\n        unordered_map<int,vector<int>>graph;\\n        \\n        \\n        for(int i=0;i<quiet.size();i++)\\n        {\\n            SILENT[quiet[i]]=i;\\n        }\\n        \\n        \\n        for(auto x:richer)\\n        {\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        for(int i=0;i<quiet.size();i++)\\n        {\\n            if(!visited[i])\\n            {\\n                visited[i]=dfs(graph,quiet,i);\\n            }\\n            ans.push_back(SILENT[visited[i]-1]);\\n        }\\n        return ans;\\n   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202619,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&rich, vector<int>&ans, vector<int>&quiet, int&i){\\n        if(ans[i]==-1){\\n            if(rich[i].size()==0) ans[i] = i;\\n            else{\\n                int temp = ans[i] = i;\\n                for(int j = 0;j<rich[i].size();j++){\\n                    temp = dfs(rich, ans, quiet, rich[i][j]);\\n                    if(quiet[ans[i]]>quiet[temp]) ans[i] = temp;\\n                }\\n            }\\n        }\\n        return ans[i];\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<vector<int>> rich(quiet.size());\\n        vector<int> ans(quiet.size(),-1);\\n        for(int i = 0;i<richer.size();i++){\\n            rich[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        for(int i = 0;i<quiet.size();i++){\\n            if(ans[i]==-1){\\n                if(rich[i].size()==0) ans[i] = i;\\n                else{\\n                    int temp = ans[i] = i;\\n                    for(int j = 0;j<rich[i].size();j++){\\n                        temp = dfs(rich, ans, quiet, rich[i][j]);\\n                        if(quiet[ans[i]]>quiet[temp]) ans[i] = temp;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&rich, vector<int>&ans, vector<int>&quiet, int&i){\\n        if(ans[i]==-1){\\n            if(rich[i].size()==0) ans[i] = i;\\n            else{\\n                int temp = ans[i] = i;\\n                for(int j = 0;j<rich[i].size();j++){\\n                    temp = dfs(rich, ans, quiet, rich[i][j]);\\n                    if(quiet[ans[i]]>quiet[temp]) ans[i] = temp;\\n                }\\n            }\\n        }\\n        return ans[i];\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<vector<int>> rich(quiet.size());\\n        vector<int> ans(quiet.size(),-1);\\n        for(int i = 0;i<richer.size();i++){\\n            rich[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        for(int i = 0;i<quiet.size();i++){\\n            if(ans[i]==-1){\\n                if(rich[i].size()==0) ans[i] = i;\\n                else{\\n                    int temp = ans[i] = i;\\n                    for(int j = 0;j<rich[i].size();j++){\\n                        temp = dfs(rich, ans, quiet, rich[i][j]);\\n                        if(quiet[ans[i]]>quiet[temp]) ans[i] = temp;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045369,
                "title": "c-dfs-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> adj[],vector<bool>& visited,vector<int>& quiet,vector<int>& answer,int node){\\n        answer[node]=node;\\n        visited[node]=true;\\n        for(auto u:adj[node]){\\n            if(!visited[u]){\\n                if(answer[u]==-1)\\n                    dfs(adj,visited,quiet,answer,u);\\n                if(quiet[answer[u]]<quiet[answer[node]])\\n                    answer[node]=answer[u];\\n            }\\n        }\\n        visited[node]=false;\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> adj[n];\\n        for(int i=0;i<richer.size();i++){\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<bool> visited(n,false);\\n        vector<int> answer(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(!visited[i])\\n                dfs(adj,visited,quiet,answer,i);\\n        }\\n        return answer;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void dfs(vector<int> adj[],vector<bool>& visited,vector<int>& quiet,vector<int>& answer,int node){\\n        answer[node]=node;\\n        visited[node]=true;\\n        for(auto u:adj[node]){\\n            if(!visited[u]){\\n                if(answer[u]==-1)\\n                    dfs(adj,visited,quiet,answer,u);\\n                if(quiet[answer[u]]<quiet[answer[node]])\\n                    answer[node]=answer[u];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1035948,
                "title": "solution-using-topological-traversal",
                "content": "\\t// time complexity : O(e+v)\\n\\t/*  approach : using topological traversal\\n\\t\\t  --> we know that no node is richer than the leaf nodes(or nodes having indegree==0) , so ans for those nodes is node themself\\n\\t\\t  --> do a topological traversal , which ensures we visit node more richer nodes first \\n\\t\\t  --> if we find that the quitness level of its parent is < quitness level of neighbour node , \\n\\t\\t\\t\\t  we update the quitness level of neighbour node and the ans for neighbour node is = ans of parent node.\\n\\t*/\\n\\tclass Solution {\\n\\t\\tpublic int[] loudAndRich(int[][] richer, int[] quiet) {\\n\\t\\t\\tList<List<Integer>> adj = new ArrayList<>();\\n\\t\\t\\tint n = quiet.length;\\n\\t\\t\\tint[] inDegree = new int[n];\\n\\t\\t\\tfor(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n\\t\\t\\tfor(int [] ele : richer){\\n\\t\\t\\t\\tinDegree[ele[1]]++;\\n\\t\\t\\t\\tadj.get(ele[0]).add(ele[1]);\\n\\t\\t\\t}\\n\\t\\t\\tint[] res = new int[n];\\n\\t\\t\\tQueue<Integer> q = new LinkedList<>();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t res[i] = i;\\n\\t\\t\\t\\tif(inDegree[i]==0)\\n\\t\\t\\t\\t\\tq.add(i);\\n\\t\\t\\t}\\n\\t\\t\\twhile(!q.isEmpty()){\\n\\t\\t\\t\\tint x = q.poll();\\n\\t\\t\\t\\tfor(int neig : adj.get(x)){\\n\\t\\t\\t\\t\\tif(--inDegree[neig]==0)q.add(neig);\\n\\t\\t\\t\\t\\tif(quiet[neig]>quiet[res[x]]){\\n\\t\\t\\t\\t\\t\\tres[neig] = res[x];\\n\\t\\t\\t\\t\\t\\tquiet[neig] = quiet[res[x]];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[] loudAndRich(int[][] richer, int[] quiet) {\\n\\t\\t\\tList<List<Integer>> adj = new ArrayList<>();\\n\\t\\t\\tint n = quiet.length;\\n\\t\\t\\tint[] inDegree = new int[n];\\n\\t\\t\\tfor(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n\\t\\t\\tfor(int [] ele : richer){\\n\\t\\t\\t\\tinDegree[ele[1]]++;\\n\\t\\t\\t\\tadj.get(ele[0]).add(ele[1]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 939564,
                "title": "python3-memoized-dfs-o-n",
                "content": "Algo \\nIt is not hard to identify that the problem represents a digraph. Given `x, y` in `richer`, a edge points from `y` to `x`. For any given node `y`, we need to collect the richer and loudest people in a sub-tree rooted at `y`. A DFS does that. To avoid repeating the same traversal, we memoize the value for nodes that we\\'ve traversed. \\n\\nImplementation \\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        graph = {} # graph as adjacency list \\n        for x, y in richer: graph.setdefault(y, []).append(x)\\n        \\n        @lru_cache(None)\\n        def fn(x): \\n            \"\"\"Return richer & loudest person given person.\"\"\"\\n            ans = x\\n            for xx in graph.get(x, []): \\n                if quiet[fn(xx)] < quiet[ans]: ans = fn(xx)\\n            return ans \\n        \\n        return [fn(x) for x in range(len(quiet))]\\n```\\n\\nAnalysis\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        graph = {} # graph as adjacency list \\n        for x, y in richer: graph.setdefault(y, []).append(x)\\n        \\n        @lru_cache(None)\\n        def fn(x): \\n            \"\"\"Return richer & loudest person given person.\"\"\"\\n            ans = x\\n            for xx in graph.get(x, []): \\n                if quiet[fn(xx)] < quiet[ans]: ans = fn(xx)\\n            return ans \\n        \\n        return [fn(x) for x in range(len(quiet))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 704323,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(int i, const vector<int>& qs, vector<int>& dp, const vector<vector<int>>& r) {\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int result = i; \\n        for(int j : r[i]){\\n            int tmp = f(j,qs,dp,r);\\n            if(qs[tmp]<qs[result]) {\\n                result = tmp; \\n            }\\n        }\\n        return dp[i] = result;       \\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int> dp(quiet.size(),-1);\\n        vector<vector<int>> r(quiet.size());\\n        for(auto& x: richer){\\n            r[x[1]].push_back(x[0]);\\n        }\\n        for(int i =0;i<dp.size();i++){\\n            f(i,quiet,dp,r);\\n        }\\n        return dp; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, const vector<int>& qs, vector<int>& dp, const vector<vector<int>>& r) {\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int result = i; \\n        for(int j : r[i]){\\n            int tmp = f(j,qs,dp,r);\\n            if(qs[tmp]<qs[result]) {\\n                result = tmp; \\n            }\\n        }\\n        return dp[i] = result;       \\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int> dp(quiet.size(),-1);\\n        vector<vector<int>> r(quiet.size());\\n        for(auto& x: richer){\\n            r[x[1]].push_back(x[0]);\\n        }\\n        for(int i =0;i<dp.size();i++){\\n            f(i,quiet,dp,r);\\n        }\\n        return dp; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371189,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph;\\n    int[] ans;\\n    boolean[] seen;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        graph = new HashMap<>();\\n        ans = new int[quiet.length];\\n        seen = new boolean[quiet.length];\\n        for(int n = 0; n < quiet.length; n++){\\n            ans[n] = n;\\n        }\\n        for(int[] rich: richer){\\n            graph.putIfAbsent(rich[1], new ArrayList<>());\\n            graph.get(rich[1]).add(rich[0]);\\n        }\\n        for(int i = 0; i < quiet.length; i++){\\n            dfs(i, quiet);\\n        }\\n        return ans;\\n    }\\n    \\n    public void dfs(int node, int[] quiet){\\n        if(seen[node]) return;\\n        if(graph.containsKey(node)){\\n            List<Integer> cur = graph.get(node);\\n            int size = cur.size();\\n            for(int i = 0; i < size; i++){\\n                dfs(cur.get(i), quiet);\\n                ans[node] = quiet[ans[cur.get(i)]] < quiet[ans[node]]? ans[cur.get(i)] : ans[node];\\n            }\\n            // System.out.println(node + \" \" + ans[node]);\\n        }\\n        else{\\n            ans[node] = node;\\n            // System.out.println(node + \" \" + ans[node]);\\n        }\\n        seen[node] = true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph;\\n    int[] ans;\\n    boolean[] seen;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        graph = new HashMap<>();\\n        ans = new int[quiet.length];\\n        seen = new boolean[quiet.length];\\n        for(int n = 0; n < quiet.length; n++){\\n            ans[n] = n;\\n        }\\n        for(int[] rich: richer){\\n            graph.putIfAbsent(rich[1], new ArrayList<>());\\n            graph.get(rich[1]).add(rich[0]);\\n        }\\n        for(int i = 0; i < quiet.length; i++){\\n            dfs(i, quiet);\\n        }\\n        return ans;\\n    }\\n    \\n    public void dfs(int node, int[] quiet){\\n        if(seen[node]) return;\\n        if(graph.containsKey(node)){\\n            List<Integer> cur = graph.get(node);\\n            int size = cur.size();\\n            for(int i = 0; i < size; i++){\\n                dfs(cur.get(i), quiet);\\n                ans[node] = quiet[ans[cur.get(i)]] < quiet[ans[node]]? ans[cur.get(i)] : ans[node];\\n            }\\n            // System.out.println(node + \" \" + ans[node]);\\n        }\\n        else{\\n            ans[node] = node;\\n            // System.out.println(node + \" \" + ans[node]);\\n        }\\n        seen[node] = true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348418,
                "title": "dfs-python",
                "content": "```python\\nclass Solution:\\n    def loudAndRich(self, richer, quiet):\\n        N = len(quiet)\\n        if richer == []:\\n            return [i for i in range(N)]\\n        g = [[] for _ in range(N)]\\n        ans = [-1] * N\\n        stack = []\\n        for k in richer:\\n            g[k[1]].append(k[0])\\n        def dfs(i):\\n            if ans[i] == -1:\\n                ans[i] = i\\n                for r in g[i]:\\n                    cand = dfs(r)\\n                    if quiet[cand] < quiet[ans[i]]:\\n                        ans[i] = cand\\n            return ans[i]\\n        return [dfs(i) for i in range(N)]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def loudAndRich(self, richer, quiet):\\n        N = len(quiet)\\n        if richer == []:\\n            return [i for i in range(N)]\\n        g = [[] for _ in range(N)]\\n        ans = [-1] * N\\n        stack = []\\n        for k in richer:\\n            g[k[1]].append(k[0])\\n        def dfs(i):\\n            if ans[i] == -1:\\n                ans[i] = i\\n                for r in g[i]:\\n                    cand = dfs(r)\\n                    if quiet[cand] < quiet[ans[i]]:\\n                        ans[i] = cand\\n            return ans[i]\\n        return [dfs(i) for i in range(N)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138773,
                "title": "straightforward-c-dfs-solution-with-explanation",
                "content": "Create a ```G```raph of child/parents where the child is richer than or equally rich as the parent.  Perform DFS on this graph.  DFS is performed for for all unprocessed nodes by checking if any ```cand```idate ```nei```ghbor of ```i``` is quieter than the current ```A```nswer for ```i```.  The quietest person is stored and returned in the ```A```nswer for each ```i```.\\n\\nNote: unprocessed nodes are represented in ```A``` with the value ```-1```.\\n\\n```\\nusing VI=vector<int>;\\nusing VVI=vector<VI>;\\nclass Solution {\\npublic:\\n    VI loudAndRich(VVI& R, VI& Q) {\\n        int N=(int)Q.size(); VVI G=VVI(N,VI{}); VI A=VI(N,-1);\\n        for (const auto& richer: R){\\n            int more=richer[0], less=richer[1];\\n            G[less].push_back(more);\\n        }\\n        for (int i=0; i<N; ++i)\\n            dfs(G,Q,A,i);\\n        return A;\\n    }\\nprivate:\\n    int dfs(const VVI& G, const VI& Q, VI& A, int i){\\n        if (A[i]>=0) return A[i]; else A[i]=i;\\n        for (const auto nei: G[i]){\\n            int cand=dfs(G,Q,A,nei);\\n            if (Q[cand] < Q[A[i]])\\n                A[i]=cand;\\n        }\\n        return A[i];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```G```\n```cand```\n```nei```\n```i```\n```A```\n```i```\n```A```\n```i```\n```A```\n```-1```\n```\\nusing VI=vector<int>;\\nusing VVI=vector<VI>;\\nclass Solution {\\npublic:\\n    VI loudAndRich(VVI& R, VI& Q) {\\n        int N=(int)Q.size(); VVI G=VVI(N,VI{}); VI A=VI(N,-1);\\n        for (const auto& richer: R){\\n            int more=richer[0], less=richer[1];\\n            G[less].push_back(more);\\n        }\\n        for (int i=0; i<N; ++i)\\n            dfs(G,Q,A,i);\\n        return A;\\n    }\\nprivate:\\n    int dfs(const VVI& G, const VI& Q, VI& A, int i){\\n        if (A[i]>=0) return A[i]; else A[i]=i;\\n        for (const auto nei: G[i]){\\n            int cand=dfs(G,Q,A,nei);\\n            if (Q[cand] < Q[A[i]])\\n                A[i]=cand;\\n        }\\n        return A[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138062,
                "title": "python-12-lines-dfs-w-memoization-108-ms",
                "content": "```\\nclass Solution:\\n    def loudAndRich(self, richer, quiet):\\n        edges, memo, res = collections.defaultdict(list), {}, [i for i in range(len(quiet))]\\n        for r, p in richer: edges[p].append(r)\\n        def explore(i):\\n            if i in memo: return memo[i]\\n            cur_min = i\\n            for v in edges[i]:\\n                cur = explore(v)\\n                if quiet[cur] < quiet[cur_min]: cur_min = cur\\n            res[i] = memo[i] = cur_min\\n            return cur_min\\n        for i in range(len(quiet)): explore(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer, quiet):\\n        edges, memo, res = collections.defaultdict(list), {}, [i for i in range(len(quiet))]\\n        for r, p in richer: edges[p].append(r)\\n        def explore(i):\\n            if i in memo: return memo[i]\\n            cur_min = i\\n            for v in edges[i]:\\n                cur = explore(v)\\n                if quiet[cur] < quiet[cur_min]: cur_min = cur\\n            res[i] = memo[i] = cur_min\\n            return cur_min\\n        for i in range(len(quiet)): explore(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137987,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        // construct \"adjacent list\" , record richer people \\n        List<List<Integer>> list = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            list.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < richer.length; i++) {\\n            list.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        \\n        int[] result = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            // no one is richer than i\\n            if (list.get(i).size() == 0) {\\n                result[i] = i;\\n                continue;\\n            }\\n            // otherwise,do BFS\\n            result[i] = bfs(list, quiet, i);\\n        }\\n        \\n        return result;\\n    }\\n    private int bfs(List<List<Integer>> list, int[] quiet, int index) {\\n        int result = index;\\n        int q = Integer.MAX_VALUE; // least quiet\\n        boolean[] visited = new boolean[quiet.length];\\n        Queue<Integer> queue = new LinkedList<>();\\n        visited[index] = true;\\n        queue.offer(index);\\n        \\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            if (quiet[curr] < q) {\\n                q = quiet[curr];\\n                result = curr;\\n            }\\n            if (list.get(curr).size() != 0) {\\n                for (int next : list.get(curr)) {\\n                    if (visited[next]) {\\n                        continue;\\n                    }\\n                    queue.offer(next);\\n                    visited[next] = true;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        // construct \"adjacent list\" , record richer people \\n        List<List<Integer>> list = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            list.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < richer.length; i++) {\\n            list.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        \\n        int[] result = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            // no one is richer than i\\n            if (list.get(i).size() == 0) {\\n                result[i] = i;\\n                continue;\\n            }\\n            // otherwise,do BFS\\n            result[i] = bfs(list, quiet, i);\\n        }\\n        \\n        return result;\\n    }\\n    private int bfs(List<List<Integer>> list, int[] quiet, int index) {\\n        int result = index;\\n        int q = Integer.MAX_VALUE; // least quiet\\n        boolean[] visited = new boolean[quiet.length];\\n        Queue<Integer> queue = new LinkedList<>();\\n        visited[index] = true;\\n        queue.offer(index);\\n        \\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            if (quiet[curr] < q) {\\n                q = quiet[curr];\\n                result = curr;\\n            }\\n            if (list.get(curr).size() != 0) {\\n                for (int next : list.get(curr)) {\\n                    if (visited[next]) {\\n                        continue;\\n                    }\\n                    queue.offer(next);\\n                    visited[next] = true;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137923,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int N = quiet.length;\\n        int[][] graph = new int[N][N];\\n        for (int[] r : richer) {\\n            graph[r[1]][r[0]] = 1;\\n        }\\n        int[] result = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            result[i] = -1;\\n        }\\n        for (int i = 0; i < N; i++) {\\n            dfs(graph, quiet, result, i);\\n        }\\n        return result;\\n    }\\n    private int dfs(int[][] graph, int[] quiet, int[] result, int index) {\\n        if (result[index] > -1) {\\n            return result[index];\\n        }\\n        int r = index;\\n        for (int i = 0; i < quiet.length; i++) {\\n            if (graph[index][i] == 1) {\\n                int temp = dfs(graph, quiet, result, i);\\n                if (quiet[temp] < quiet[r]) {\\n                    r = temp;\\n                }\\n            }\\n        }\\n        result[index] = r;\\n        return result[index];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int N = quiet.length;\\n        int[][] graph = new int[N][N];\\n        for (int[] r : richer) {\\n            graph[r[1]][r[0]] = 1;\\n        }\\n        int[] result = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            result[i] = -1;\\n        }\\n        for (int i = 0; i < N; i++) {\\n            dfs(graph, quiet, result, i);\\n        }\\n        return result;\\n    }\\n    private int dfs(int[][] graph, int[] quiet, int[] result, int index) {\\n        if (result[index] > -1) {\\n            return result[index];\\n        }\\n        int r = index;\\n        for (int i = 0; i < quiet.length; i++) {\\n            if (graph[index][i] == 1) {\\n                int temp = dfs(graph, quiet, result, i);\\n                if (quiet[temp] < quiet[r]) {\\n                    r = temp;\\n                }\\n            }\\n        }\\n        result[index] = r;\\n        return result[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093344,
                "title": "java-easy-to-understand-10ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n\\n        int n = quiet.length;\\n        int[] ans = new int[n];\\n        int[] inDegree = new int[n];\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            ans[i] = i;\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            inDegree[i] = 0;\\n        }\\n        for(int i = 0; i < n ; i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n\\n\\n        for(int i = 0; i < richer.length; i++){\\n            adj.get(richer[i][0]).add(richer[i][1]);\\n            inDegree[richer[i][1]]++;\\n        }\\n\\n        \\n\\n        ArrayDeque<Integer> q = new ArrayDeque<>();\\n\\n        for(int i = 0; i < n; i++){\\n            if(inDegree[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n\\n        while(!q.isEmpty()){\\n         \\n            int s = q.size();\\n            int cur = q.poll();\\n         \\n            for(Integer it : adj.get(cur)){\\n           \\n                inDegree[it]--;\\n                if(quiet[ans[cur]] < quiet[ans[it]]){\\n                  \\n                    ans[it] = ans[cur];\\n                }\\n                if(inDegree[it] ==  0){\\n                    q.add(it);\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n\\n        int n = quiet.length;\\n        int[] ans = new int[n];\\n        int[] inDegree = new int[n];\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            ans[i] = i;\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            inDegree[i] = 0;\\n        }\\n        for(int i = 0; i < n ; i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n\\n\\n        for(int i = 0; i < richer.length; i++){\\n            adj.get(richer[i][0]).add(richer[i][1]);\\n            inDegree[richer[i][1]]++;\\n        }\\n\\n        \\n\\n        ArrayDeque<Integer> q = new ArrayDeque<>();\\n\\n        for(int i = 0; i < n; i++){\\n            if(inDegree[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n\\n        while(!q.isEmpty()){\\n         \\n            int s = q.size();\\n            int cur = q.poll();\\n         \\n            for(Integer it : adj.get(cur)){\\n           \\n                inDegree[it]--;\\n                if(quiet[ans[cur]] < quiet[ans[it]]){\\n                  \\n                    ans[it] = ans[cur];\\n                }\\n                if(inDegree[it] ==  0){\\n                    q.add(it);\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062226,
                "title": "c-toposort-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<bool>&visited, vector<int>adj[], stack<int>&st) {\\n        visited[node] = true;\\n        for (auto child : adj[node]) {\\n            if (visited[child])\\n                continue;\\n            dfs(child, visited, adj, st);\\n        }\\n        st.push(node);\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int>ans(n, 0);\\n        stack<int>order;\\n        vector<int>adj[n];\\n\\n        for (int i = 0; i < n; i++)\\n            ans[i] = i;\\n\\n        for (auto vec : richer) {\\n            adj[vec[0]].push_back(vec[1]);\\n        }\\n\\n        vector<bool>visited(n, false);\\n        for (int i = 0; i < n; i++)\\n            if (!visited[i])\\n                dfs(i, visited, adj, order);\\n\\n        while (!order.empty()) {\\n            int node = order.top();\\n            order.pop();\\n            for (auto child : adj[node]) {\\n                if (quiet[ans[child]] > quiet[ans[node]])\\n                    ans[child] = ans[node];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<bool>&visited, vector<int>adj[], stack<int>&st) {\\n        visited[node] = true;\\n        for (auto child : adj[node]) {\\n            if (visited[child])\\n                continue;\\n            dfs(child, visited, adj, st);\\n        }\\n        st.push(node);\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int>ans(n, 0);\\n        stack<int>order;\\n        vector<int>adj[n];\\n\\n        for (int i = 0; i < n; i++)\\n            ans[i] = i;\\n\\n        for (auto vec : richer) {\\n            adj[vec[0]].push_back(vec[1]);\\n        }\\n\\n        vector<bool>visited(n, false);\\n        for (int i = 0; i < n; i++)\\n            if (!visited[i])\\n                dfs(i, visited, adj, order);\\n\\n        while (!order.empty()) {\\n            int node = order.top();\\n            order.pop();\\n            for (auto child : adj[node]) {\\n                if (quiet[ans[child]] > quiet[ans[node]])\\n                    ans[child] = ans[node];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059897,
                "title": "c-topoligcal-sorting-easy-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReverse the edges and do topological sorting. At each step update the\\nquitest of every next people.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBelow part of code update quitest every time when we pop queue\\n```\\nif(quiet[quitest[x]] > quiet[quitest[u]])\\n                quitest[x] = quitest[u];\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        vector<int> outdegree(n, 0);\\n        vector<int> quitest(n);\\n        for(auto x: richer){\\n            adj[x[0]].push_back(x[1]);\\n            outdegree[x[1]]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i = 0; i < n; i++){\\n            quitest[i] = i;\\n            if(outdegree[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n\\n        while(q.empty() == false){\\n            int u = q.front();\\n            q.pop();\\n            cout<<u<<\": \";\\n            for(int x: adj[u]){\\n                outdegree[x]--;\\n                if(quiet[quitest[x]] > quiet[quitest[u]])\\n                quitest[x] = quitest[u];\\n                if(outdegree[x] == 0){\\n                    q.push(x);\\n                }\\n            }\\n            // for(int i = 0; i < n; i++)\\n            // cout<<quitest[i]<<\" \";\\n            // cout<<\" ## \";\\n        }\\n        return quitest;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif(quiet[quitest[x]] > quiet[quitest[u]])\\n                quitest[x] = quitest[u];\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        vector<int> outdegree(n, 0);\\n        vector<int> quitest(n);\\n        for(auto x: richer){\\n            adj[x[0]].push_back(x[1]);\\n            outdegree[x[1]]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i = 0; i < n; i++){\\n            quitest[i] = i;\\n            if(outdegree[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n\\n        while(q.empty() == false){\\n            int u = q.front();\\n            q.pop();\\n            cout<<u<<\": \";\\n            for(int x: adj[u]){\\n                outdegree[x]--;\\n                if(quiet[quitest[x]] > quiet[quitest[u]])\\n                quitest[x] = quitest[u];\\n                if(outdegree[x] == 0){\\n                    q.push(x);\\n                }\\n            }\\n            // for(int i = 0; i < n; i++)\\n            // cout<<quitest[i]<<\" \";\\n            // cout<<\" ## \";\\n        }\\n        return quitest;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4056936,
                "title": "python3-simple-dfs-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        N = len(quiet)\\n        graph = collections.defaultdict(list)\\n        for e in richer:\\n            pre = e[1]\\n            next = e[0]\\n            graph[pre].append(next)\\n\\n        @cache\\n        def dfs(root):\\n            ret = quiet[root]\\n            for next in graph[root]:\\n                ret = min(ret, dfs(next))\\n            return ret\\n\\n        hm = dict()\\n        for i, e in enumerate(quiet):\\n            hm[e] = i\\n\\n        ans = []\\n        for i in range(N):\\n            ans.append(hm[dfs(i)])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        N = len(quiet)\\n        graph = collections.defaultdict(list)\\n        for e in richer:\\n            pre = e[1]\\n            next = e[0]\\n            graph[pre].append(next)\\n\\n        @cache\\n        def dfs(root):\\n            ret = quiet[root]\\n            for next in graph[root]:\\n                ret = min(ret, dfs(next))\\n            return ret\\n\\n        hm = dict()\\n        for i, e in enumerate(quiet):\\n            hm[e] = i\\n\\n        ans = []\\n        for i in range(N):\\n            ans.append(hm[dfs(i)])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050854,
                "title": "c-solution-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n=quiet.size();\\n        \\n        vector<int> res(n);\\n        \\n        iota(res.begin(), res.end(), 0);\\n        vector<int> indegree(n, 0);\\n        vector<int> graph[n];\\n        \\n        for(auto elem:richer){\\n            indegree[elem[1]]++;\\n            graph[elem[0]].push_back(elem[1]);\\n        }\\n        queue<int> q;\\n        \\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr=q.front();\\n            q.pop();\\n            \\n            for(auto u:graph[curr]){\\n                if(quiet[res[u]]>quiet[res[curr]]){\\n                    res[u]=res[curr];\\n                }\\n                indegree[u]--;\\n                if(indegree[u]==0)\\n                    q.push(u);\\n                \\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```\\n\\nPlease uvote if you liked the solution",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n=quiet.size();\\n        \\n        vector<int> res(n);\\n        \\n        iota(res.begin(), res.end(), 0);\\n        vector<int> indegree(n, 0);\\n        vector<int> graph[n];\\n        \\n        for(auto elem:richer){\\n            indegree[elem[1]]++;\\n            graph[elem[0]].push_back(elem[1]);\\n        }\\n        queue<int> q;\\n        \\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr=q.front();\\n            q.pop();\\n            \\n            for(auto u:graph[curr]){\\n                if(quiet[res[u]]>quiet[res[curr]]){\\n                    res[u]=res[curr];\\n                }\\n                indegree[u]--;\\n                if(indegree[u]==0)\\n                    q.push(u);\\n                \\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046878,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int ans[] = new int[quiet.length];\\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\\n        for(int i=0;i<quiet.length;i++){\\n            list.add(new ArrayList<>());\\n            ans[i]=i;\\n        }\\n        for(int i=0;i<richer.length;i++){\\n            list.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        boolean vis[] = new boolean[quiet.length];\\n        for(int i=0;i<quiet.length;i++){\\n            if(vis[i]==false){\\n                dfs(i,list,vis,ans,quiet);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(int node ,ArrayList<ArrayList<Integer>> list ,boolean vis[] ,int ans[],int quiet[] ){\\n         vis[node]=true;\\n         for(int j:list.get(node)){\\n             if(vis[j]==false){\\n                 dfs(j,list,vis,ans,quiet);\\n                 if(quiet[node]>quiet[j]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }else{\\n                 if(quiet[j]<quiet[ans[node]]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }\\n         }\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    void dfs(int s,vector<int>*adj,vector<bool>&visited,vector<int>&ans,vector<int>&quiet){\\n        visited[s]=true;\\n        int min=s;\\n        for(int x:adj[s]){\\n            if(!visited[x])\\n            dfs(x,adj,visited,ans,quiet);\\n            if(quiet[ans[x]]<quiet[min])\\n            min=ans[x];\\n        }\\n        ans[s]=min;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int>adj[quiet.size()];\\n        vector<int>ans(quiet.size(),false);\\n        //creation of graph\\n        for(int i=0;i<richer.size();i++){\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<bool>visited(quiet.size(),false);\\n        for(int i=0;i<quiet.size();i++){\\n            if(!visited[i])\\n            dfs(i,adj,visited,ans,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int ans[] = new int[quiet.length];\\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\\n        for(int i=0;i<quiet.length;i++){\\n            list.add(new ArrayList<>());\\n            ans[i]=i;\\n        }\\n        for(int i=0;i<richer.length;i++){\\n            list.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        boolean vis[] = new boolean[quiet.length];\\n        for(int i=0;i<quiet.length;i++){\\n            if(vis[i]==false){\\n                dfs(i,list,vis,ans,quiet);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(int node ,ArrayList<ArrayList<Integer>> list ,boolean vis[] ,int ans[],int quiet[] ){\\n         vis[node]=true;\\n         for(int j:list.get(node)){\\n             if(vis[j]==false){\\n                 dfs(j,list,vis,ans,quiet);\\n                 if(quiet[node]>quiet[j]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }else{\\n                 if(quiet[j]<quiet[ans[node]]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }\\n         }\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    void dfs(int s,vector<int>*adj,vector<bool>&visited,vector<int>&ans,vector<int>&quiet){\\n        visited[s]=true;\\n        int min=s;\\n        for(int x:adj[s]){\\n            if(!visited[x])\\n            dfs(x,adj,visited,ans,quiet);\\n            if(quiet[ans[x]]<quiet[min])\\n            min=ans[x];\\n        }\\n        ans[s]=min;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int>adj[quiet.size()];\\n        vector<int>ans(quiet.size(),false);\\n        //creation of graph\\n        for(int i=0;i<richer.size();i++){\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<bool>visited(quiet.size(),false);\\n        for(int i=0;i<quiet.size();i++){\\n            if(!visited[i])\\n            dfs(i,adj,visited,ans,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046772,
                "title": "easy-java-solution",
                "content": "# Intuition\\nUnderstanding the relationship between people based on the amount of money can be visualized as a graph. In this graph, a directed edge from person i to person j indicates that i is richer than j. We want to traverse this graph to find the least quiet person for each individual. The first intuition is to represent richer relationships in the form of an adjacency list and traverse it.\\n\\n# Approach\\n1. Adjacency List Representation: Represent the richer relationships using an adjacency list. For each relationship [i, j], add i to the list of j indicating that i is richer than j.\\n\\n2. Depth First Search (DFS): Start DFS traversal for each person. The purpose of this traversal is to find the quietest person amongst all the people richer than the current person, including themselves.\\n\\n3. Memoization: Store already computed results for each person in the answer array. This avoids redundant calculations and prevents us from running into infinite loops. If we\\'ve already computed the quietest richer person for a particular person, we just return the stored result.\\n\\n4. Updating Quietest Person: During the DFS traversal, at each step, compare the quietness of the current person with the quietness of the DFS result for the richer person. Update the quietest person accordingly.\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < richer.length; i++) {\\n            adj.get(richer[i][1]).add(richer[i][0]); \\n        }\\n\\n        int[] answer = new int[n];\\n        Arrays.fill(answer, -1); \\n\\n        for (int i = 0; i < n; i++) {\\n            dfs(i, adj, quiet, answer);\\n        }\\n\\n        return answer;\\n    }\\n\\n    private int dfs(int person,  ArrayList<ArrayList<Integer>> adj, int[] quiet, int[] answer) {\\n        if (answer[person] != -1) {\\n            return answer[person];\\n        }\\n\\n        int minQuietPerson = person; \\n        for (int richerPerson : adj.get(person)) {\\n            int quietPerson = dfs(richerPerson, adj, quiet, answer);\\n            if (quiet[quietPerson] < quiet[minQuietPerson]) {\\n                minQuietPerson = quietPerson;\\n            }\\n        }\\n\\n        answer[person] = minQuietPerson;\\n        return minQuietPerson;\\n    }\\n}\\n\\n```\\n\\n![upvote.webp](https://assets.leetcode.com/users/images/b08811e9-c195-4626-9c79-1d9c9eb85ffc_1694761956.513607.webp)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < richer.length; i++) {\\n            adj.get(richer[i][1]).add(richer[i][0]); \\n        }\\n\\n        int[] answer = new int[n];\\n        Arrays.fill(answer, -1); \\n\\n        for (int i = 0; i < n; i++) {\\n            dfs(i, adj, quiet, answer);\\n        }\\n\\n        return answer;\\n    }\\n\\n    private int dfs(int person,  ArrayList<ArrayList<Integer>> adj, int[] quiet, int[] answer) {\\n        if (answer[person] != -1) {\\n            return answer[person];\\n        }\\n\\n        int minQuietPerson = person; \\n        for (int richerPerson : adj.get(person)) {\\n            int quietPerson = dfs(richerPerson, adj, quiet, answer);\\n            if (quiet[quietPerson] < quiet[minQuietPerson]) {\\n                minQuietPerson = quietPerson;\\n            }\\n        }\\n\\n        answer[person] = minQuietPerson;\\n        return minQuietPerson;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044865,
                "title": "c-dp-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(int node,unordered_map<int,vector<int>> &adj,vector<int>& quiet,vector<int>& dp)\\n    {\\n        if(dp[node]!=-1) return dp[node];\\n        int mini = quiet[node];\\n        for(auto it:adj[node])\\n        {\\n            mini = min(mini,dfs(it,adj,quiet,dp));\\n        }\\n        return dp[node] = mini;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        //so this is a one directional graph.\\n        unordered_map<int,vector<int>> adj;\\n        int n = richer.size();\\n        int m = quiet.size();\\n        unordered_map<int,int> store;\\n        for(int i = 0;i<m;i++)\\n        {\\n            store[quiet[i]] = i;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<int> ans(m);\\n        vector<int> vis(m);\\n        vector<int> dp(500,-1);\\n        for(int i = 0;i<m;i++)\\n        {\\n            dp.clear();\\n            int k = dfs(i,adj,quiet,dp);\\n            ans[i] = store[k];\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(int node,unordered_map<int,vector<int>> &adj,vector<int>& quiet,vector<int>& dp)\\n    {\\n        if(dp[node]!=-1) return dp[node];\\n        int mini = quiet[node];\\n        for(auto it:adj[node])\\n        {\\n            mini = min(mini,dfs(it,adj,quiet,dp));\\n        }\\n        return dp[node] = mini;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        //so this is a one directional graph.\\n        unordered_map<int,vector<int>> adj;\\n        int n = richer.size();\\n        int m = quiet.size();\\n        unordered_map<int,int> store;\\n        for(int i = 0;i<m;i++)\\n        {\\n            store[quiet[i]] = i;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<int> ans(m);\\n        vector<int> vis(m);\\n        vector<int> dp(500,-1);\\n        for(int i = 0;i<m;i++)\\n        {\\n            dp.clear();\\n            int k = dfs(i,adj,quiet,dp);\\n            ans[i] = store[k];\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039822,
                "title": "loud-and-rich-graph-memoization-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhy did we think of graph at the first place ?? Because for every person(node) there can be many other persons (nodes) who are richer, and somehow if we can store all the richer persons and then do a traversal to find the quietest one among them our job will be done. Now we might think if we know 1,2,3 are richer than 0 then we can just traverse on them(0,1,2,3) and then find quietest among them but what if 5,6 are richer than 1 and also quieter than 1. This indicates need for a DFS search, a graph like structure.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCoding a DFS solution is pretty easy, but will we traverse for each node seperately ? What if a particular subgraph is common among two nodes. Yes, we can just memoize it which will also ensure that our complexity stays O(n) that is each node is visited once.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) as each node will be visited only once since we are memoizing the result\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) \\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        //graph + dp based question\\n        // we will create a directed graph where subgraph of each node will consist of members which are richer than the current node\\n        // we will also have a visited dp array whch will be initially filled with -1, it will serve 2 purposes firstly it will indicate whether node is visited or not and secondly it will also store the quietest person for the subgraph if each index\\n        int n=quiet.length;\\n        ArrayList<Integer> [] graph=new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            graph[i]=new ArrayList<>();\\n        }\\n        for(int[] rich : richer){\\n            int a=rich[0];\\n            int b=rich[1];\\n            graph[b].add(a);\\n        }\\n        int[] dp=new int[n];\\n        Arrays.fill(dp,-1);\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==-1){\\n                //not visited\\n                dfs(i,graph,dp,quiet);\\n            }\\n        }\\n        return dp;\\n    }\\n    public int dfs(int src,ArrayList<Integer> []graph,int[] dp,int[] quiet){\\n        if(dp[src]!=-1){\\n            return dp[src];\\n        }\\n        int minQuiet=quiet[src];\\n        int minIdx=src;\\n        for(int nbr : graph[src]){\\n            int rvIdx=dfs(nbr,graph,dp,quiet);\\n            if(quiet[rvIdx]<minQuiet){\\n                minQuiet=quiet[rvIdx];\\n                minIdx=rvIdx;\\n            }\\n        }\\n        return dp[src]=minIdx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        //graph + dp based question\\n        // we will create a directed graph where subgraph of each node will consist of members which are richer than the current node\\n        // we will also have a visited dp array whch will be initially filled with -1, it will serve 2 purposes firstly it will indicate whether node is visited or not and secondly it will also store the quietest person for the subgraph if each index\\n        int n=quiet.length;\\n        ArrayList<Integer> [] graph=new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            graph[i]=new ArrayList<>();\\n        }\\n        for(int[] rich : richer){\\n            int a=rich[0];\\n            int b=rich[1];\\n            graph[b].add(a);\\n        }\\n        int[] dp=new int[n];\\n        Arrays.fill(dp,-1);\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==-1){\\n                //not visited\\n                dfs(i,graph,dp,quiet);\\n            }\\n        }\\n        return dp;\\n    }\\n    public int dfs(int src,ArrayList<Integer> []graph,int[] dp,int[] quiet){\\n        if(dp[src]!=-1){\\n            return dp[src];\\n        }\\n        int minQuiet=quiet[src];\\n        int minIdx=src;\\n        for(int nbr : graph[src]){\\n            int rvIdx=dfs(nbr,graph,dp,quiet);\\n            if(quiet[rvIdx]<minQuiet){\\n                minQuiet=quiet[rvIdx];\\n                minIdx=rvIdx;\\n            }\\n        }\\n        return dp[src]=minIdx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035860,
                "title": "cpp-easy-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501];\\n    int dfs(int u,vector<int>*adj,vector<int>&quiet){\\n         int ans=u;\\n        int mini=quiet[u];\\n        if(dp[u]!=-1) return dp[u];\\n         for(auto v:adj[u]){\\n             int t=dfs(v,adj,quiet);\\n             if(mini>quiet[t]){\\n                 mini=quiet[t];\\n                 ans=t;\\n                 \\n             }\\n         }\\n        return dp[u]=ans;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int>ans;\\n        vector<int>adj[501];\\n        int maxi=-1;\\n        for(auto vec:richer){\\n            adj[vec[1]].push_back(vec[0]);\\n        }\\n        for(auto x:quiet)\\n            maxi=max(maxi,x);\\n        \\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<=maxi;i++){\\n            int t=dfs(i,adj,quiet);\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[501];\\n    int dfs(int u,vector<int>*adj,vector<int>&quiet){\\n         int ans=u;\\n        int mini=quiet[u];\\n        if(dp[u]!=-1) return dp[u];\\n         for(auto v:adj[u]){\\n             int t=dfs(v,adj,quiet);\\n             if(mini>quiet[t]){\\n                 mini=quiet[t];\\n                 ans=t;\\n                 \\n             }",
                "codeTag": "Java"
            },
            {
                "id": 4035608,
                "title": "very-basic-dfs-approach",
                "content": "# Intuition\\nJust create a simple graph in which thier is a directed edge from   \\nj -> i.\\n\\n# Approach\\nSimply do a dfs and update the ans vector.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int s,vector<int>*adj,vector<bool>&visited,vector<int>&ans,vector<int>&quiet){\\n        visited[s]=true;\\n        int min=s;\\n        for(int x:adj[s]){\\n            if(!visited[x])\\n            dfs(x,adj,visited,ans,quiet);\\n            if(quiet[ans[x]]<quiet[min])\\n            min=ans[x];\\n        }\\n        ans[s]=min;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int>adj[quiet.size()];\\n        vector<int>ans(quiet.size(),false);\\n        //creation of graph\\n        for(int i=0;i<richer.size();i++){\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<bool>visited(quiet.size(),false);\\n        for(int i=0;i<quiet.size();i++){\\n            if(!visited[i])\\n            dfs(i,adj,visited,ans,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int s,vector<int>*adj,vector<bool>&visited,vector<int>&ans,vector<int>&quiet){\\n        visited[s]=true;\\n        int min=s;\\n        for(int x:adj[s]){\\n            if(!visited[x])\\n            dfs(x,adj,visited,ans,quiet);\\n            if(quiet[ans[x]]<quiet[min])\\n            min=ans[x];\\n        }\\n        ans[s]=min;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int>adj[quiet.size()];\\n        vector<int>ans(quiet.size(),false);\\n        //creation of graph\\n        for(int i=0;i<richer.size();i++){\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<bool>visited(quiet.size(),false);\\n        for(int i=0;i<quiet.size();i++){\\n            if(!visited[i])\\n            dfs(i,adj,visited,ans,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031203,
                "title": "1-dfs-brute-force-tle-2-dfs-dp-effective-solution-beats-90",
                "content": "# Code :-   DFS(brute force)\\n```\\nclass Solution {\\n    int node,mn;\\npublic:\\n    void solve(int i,vector<vector<int>>& v,vector<int>& b)\\n    {\\n        for(auto& x:v[i])\\n        {\\n            if(mn>=b[x])\\n            {\\n                mn=b[x];\\n                node=x;\\n            }\\n            solve(x,v,b);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& a, vector<int>& b) \\n    {\\n        int n=b.size();\\n        vector<vector<int>> v(n);\\n        vector<int> g(n,0);\\n        for(int i=0;i<a.size();i++)\\n            v[a[i][1]].push_back(a[i][0]);\\n        vector<int> vis(n,0);\\n        vector<int> ans(n),c;\\n        for(int i=0;i<n;i++)\\n        {\\n            mn=b[i];\\n            node=i;\\n            solve(i,v,b);\\n            ans[i]=node;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code :-   DFS+DP(effective solution)\\n```\\nclass Solution {\\n    int node,mn;\\npublic:\\n    void solve(int i,vector<vector<int>>& v,vector<int>& b,vector<int>& ans)\\n    {\\n        if(ans[i]!=-1)\\n        {\\n            if(mn>b[ans[i]])\\n            {\\n                node=ans[i];\\n                mn=b[ans[i]];\\n            }\\n            return;\\n        }\\n        for(auto& x:v[i])\\n        {\\n            if(mn>=b[x])\\n            {\\n                mn=b[x];\\n                node=x;\\n            }\\n            solve(x,v,b,ans);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& a, vector<int>& b) \\n    {\\n        int n=b.size();\\n        vector<vector<int>> v(n);\\n        vector<int> g(n,0);\\n        for(int i=0;i<a.size();i++)\\n            v[a[i][1]].push_back(a[i][0]);\\n        vector<int> vis(n,0);\\n        vector<int> ans(n,-1),c;\\n        for(int i=0;i<n;i++)\\n        {\\n            mn=b[i];\\n            node=i;\\n            solve(i,v,b,ans);\\n            ans[i]=node;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int node,mn;\\npublic:\\n    void solve(int i,vector<vector<int>>& v,vector<int>& b)\\n    {\\n        for(auto& x:v[i])\\n        {\\n            if(mn>=b[x])\\n            {\\n                mn=b[x];\\n                node=x;\\n            }\\n            solve(x,v,b);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& a, vector<int>& b) \\n    {\\n        int n=b.size();\\n        vector<vector<int>> v(n);\\n        vector<int> g(n,0);\\n        for(int i=0;i<a.size();i++)\\n            v[a[i][1]].push_back(a[i][0]);\\n        vector<int> vis(n,0);\\n        vector<int> ans(n),c;\\n        for(int i=0;i<n;i++)\\n        {\\n            mn=b[i];\\n            node=i;\\n            solve(i,v,b);\\n            ans[i]=node;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int node,mn;\\npublic:\\n    void solve(int i,vector<vector<int>>& v,vector<int>& b,vector<int>& ans)\\n    {\\n        if(ans[i]!=-1)\\n        {\\n            if(mn>b[ans[i]])\\n            {\\n                node=ans[i];\\n                mn=b[ans[i]];\\n            }\\n            return;\\n        }\\n        for(auto& x:v[i])\\n        {\\n            if(mn>=b[x])\\n            {\\n                mn=b[x];\\n                node=x;\\n            }\\n            solve(x,v,b,ans);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& a, vector<int>& b) \\n    {\\n        int n=b.size();\\n        vector<vector<int>> v(n);\\n        vector<int> g(n,0);\\n        for(int i=0;i<a.size();i++)\\n            v[a[i][1]].push_back(a[i][0]);\\n        vector<int> vis(n,0);\\n        vector<int> ans(n,-1),c;\\n        for(int i=0;i<n;i++)\\n        {\\n            mn=b[i];\\n            node=i;\\n            solve(i,v,b,ans);\\n            ans[i]=node;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018239,
                "title": "easy-dfs-memozation",
                "content": "It\\'s just directed graph problem with dfs \\nthe richer aray is nothing but directed edge infomation and quiter array is let\\'s say node values and it\\'s unique (a plus point)\\nso what we are asked is that find minimum value(quiter value) in among all the nodes in it\\'s subtree where current node is least rich and all it\\'s sub child is greater or equal rich\\nand we have to do this for each i in (0 to n) so we can memoize the results for future access \\n```\\nclass Solution {\\npublic:\\n    int dp[501];\\n    vector<int> a;\\n    vector<vector<int>> g;\\n    int dfs(int s)\\n    {\\n        if(dp[s]!=-1) return dp[s];\\n        int ans= a[s];\\n        \\n        for(auto i: g[s])\\n        {\\n            ans= min(ans, dfs(i));\\n        }\\n        \\n        return dp[s]= ans;\\n        \\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) \\n    {\\n        a=q;\\n        int n=q.size();\\n        g.resize(n);\\n        unordered_map<int,int> m;\\n        \\n        for(int i=0; i<n; i++) m[a[i]]=i;\\n        for(auto i: r) g[i[1]].push_back(i[0]);\\n        \\n        vector<int> ans(n,0);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0; i<n; i++) \\n        {\\n            int val=dfs(i);\\n            ans[i]= m[val];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501];\\n    vector<int> a;\\n    vector<vector<int>> g;\\n    int dfs(int s)\\n    {\\n        if(dp[s]!=-1) return dp[s];\\n        int ans= a[s];\\n        \\n        for(auto i: g[s])\\n        {\\n            ans= min(ans, dfs(i));\\n        }\\n        \\n        return dp[s]= ans;\\n        \\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) \\n    {\\n        a=q;\\n        int n=q.size();\\n        g.resize(n);\\n        unordered_map<int,int> m;\\n        \\n        for(int i=0; i<n; i++) m[a[i]]=i;\\n        for(auto i: r) g[i[1]].push_back(i[0]);\\n        \\n        vector<int> ans(n,0);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0; i<n; i++) \\n        {\\n            int val=dfs(i);\\n            ans[i]= m[val];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015818,
                "title": "python3-topological-sort-dfs",
                "content": "# Intuition\\n- Create a graph with the edges given to understand the neigbhors \\n- Post that if you do topological sort you will arrive to list of richer people now get the quietest among them\\n\\n# Approach\\n- Topo Sort whilee keeping track of the quietest\\n\\n# Complexity\\n- Time complexity:\\n- O(V*N+E)\\n- n because of the loop in stack\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def loudAndRich(self, richer, quiet):\\n        \"\"\"\\n        :type richer: List[List[int]]\\n        :type quiet: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n\\n        def solve(richer,quiet):\\n            graph = defaultdict(list)\\n\\n            for i in range(len(richer)):\\n                graph[richer[i][1]].append(richer[i][0])\\n            vis = [False for _ in range(len(quiet))]\\n            pathVis = [False for _ in range(len(quiet))]\\n\\n\\n            ans = {}\\n            for i in range(len(quiet)):\\n                ans[i] = i\\n\\n\\n            def topoSort(v,stack):\\n                vis[v] = True\\n                pathVis[v] = True\\n                for n in graph[v]:\\n                    if vis[n] == False and pathVis[n] == False:\\n                        topoSort(n,stack+[v])\\n                    elif vis[n] == True:\\n                        if quiet[ans[n]] < quiet[ans[v]]:\\n                            ans[v] = ans[n]\\n\\n                if len(graph[v]) == 0:\\n                    stack.append(v)\\n                    for i in range(len(stack)-2,-1,-1):\\n                        if quiet[ans[stack[i]]] > quiet[ans[stack[i+1]]]:\\n                            ans[stack[i]] = ans[stack[i+1]]\\n                if len(stack) !=0:\\n                    stack.pop()    \\n                pathVis[v] = False\\n\\n            stack = []\\n            for i in range(len(vis)):\\n                if vis[i]==False:\\n                    topoSort(i,stack)\\n\\n            result = [None for _ in range(len(quiet))]\\n            for key in ans:\\n                result[key] = ans[key]\\n            return result\\n        return solve(richer,quiet)\\n        # return [2]\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution(object):\\n    def loudAndRich(self, richer, quiet):\\n        \"\"\"\\n        :type richer: List[List[int]]\\n        :type quiet: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n\\n        def solve(richer,quiet):\\n            graph = defaultdict(list)\\n\\n            for i in range(len(richer)):\\n                graph[richer[i][1]].append(richer[i][0])\\n            vis = [False for _ in range(len(quiet))]\\n            pathVis = [False for _ in range(len(quiet))]\\n\\n\\n            ans = {}\\n            for i in range(len(quiet)):\\n                ans[i] = i\\n\\n\\n            def topoSort(v,stack):\\n                vis[v] = True\\n                pathVis[v] = True\\n                for n in graph[v]:\\n                    if vis[n] == False and pathVis[n] == False:\\n                        topoSort(n,stack+[v])\\n                    elif vis[n] == True:\\n                        if quiet[ans[n]] < quiet[ans[v]]:\\n                            ans[v] = ans[n]\\n\\n                if len(graph[v]) == 0:\\n                    stack.append(v)\\n                    for i in range(len(stack)-2,-1,-1):\\n                        if quiet[ans[stack[i]]] > quiet[ans[stack[i+1]]]:\\n                            ans[stack[i]] = ans[stack[i+1]]\\n                if len(stack) !=0:\\n                    stack.pop()    \\n                pathVis[v] = False\\n\\n            stack = []\\n            for i in range(len(vis)):\\n                if vis[i]==False:\\n                    topoSort(i,stack)\\n\\n            result = [None for _ in range(len(quiet))]\\n            for key in ans:\\n                result[key] = ans[key]\\n            return result\\n        return solve(richer,quiet)\\n        # return [2]\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996845,
                "title": "begineer-friendly-solution-c-dfs-o-n",
                "content": "\\n\\n# Approach\\nCreate adjacency list of directed graph.\\nif there is a edge a->b , it means b is richer than a.\\nSteps:\\n1)Visit a node ,check its quitness and declare it with mini.\\n2)Now check its neighbours quitness via a recursive call.\\n3)compare quitness of neighbour and the current node and update its value in ans array.\\n\\n          \\n    \\n\\n# Complexity\\n- Time complexity:\\n  O(N)\\n\\n- Space complexity:\\n O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    unordered_map<int,vector<int>>adj;\\n\\n    int dfs(int node, vector<int>& quiet){\\n\\n        if(ans[node] != (-1)){return ans[node];} //caching \\n      \\n         <!-- step2 -->\\n        int mini = node;\\n        <!-- step3 -->\\n        for(auto it : adj[node]){\\n            \\n            if(quiet[dfs(it,quiet)] < quiet[mini]){\\n               \\n               mini = dfs(it,quiet);\\n          \\n            }\\n         \\n\\n        }\\n       \\n        ans[node] = mini;\\n        return mini;\\n\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n =  quiet.size();\\n        ans.resize(n,-1);\\n        <!-- step1 -->\\n        for(auto it : richer ){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0 ; i<n ; i++){\\n            if(ans[i] == -1){\\n                dfs(i,quiet);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    unordered_map<int,vector<int>>adj;\\n\\n    int dfs(int node, vector<int>& quiet){\\n\\n        if(ans[node] != (-1)){return ans[node];} //caching \\n      \\n         <!-- step2 -->\\n        int mini = node;\\n        <!-- step3 -->\\n        for(auto it : adj[node]){\\n            \\n            if(quiet[dfs(it,quiet)] < quiet[mini]){\\n               \\n               mini = dfs(it,quiet);\\n          \\n            }\\n         \\n\\n        }\\n       \\n        ans[node] = mini;\\n        return mini;\\n\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n =  quiet.size();\\n        ans.resize(n,-1);\\n        <!-- step1 -->\\n        for(auto it : richer ){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0 ; i<n ; i++){\\n            if(ans[i] == -1){\\n                dfs(i,quiet);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978243,
                "title": "easy-c-topological-sort-3-line-code-logic",
                "content": "# Intuition\\nProblem Statement clearly states its a topological sort, all we need to do is add a logic to get the desired output.\\n\\nanswer[x] = y the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x.\\n\\n```\\n//Suppose a is richer than b and b is richer than c , now quietness so\\n\\nanswer[a] = a (richest)\\nanswer[b] = min(quiet[a],quiet[b])   (more or equal money)\\nanswer[c] = min(quiet[c],quiet[b]) \\n```\\n**ONLY THIS INTUITION WAS REQUIRED**\\n\\n\\n# Approach\\n\\n```cpp\\nif(quiet[ans[b]]>quiet[ans[a]]) // we need the number of the person\\n{\\n    ans[b]=ans[a];\\n}\\n\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> ans(n);\\n        \\n        vector<int> adj[n];\\n        vector<int> indegree(n,0);\\n\\n        for(auto r : richer) {\\n            adj[r[0]].push_back(r[1]);\\n            indegree[r[1]]++;\\n        }\\n        vector<pair<int,int>> sorted;\\n        queue<int> q;\\n\\n        for(int i=0;i<n;i++) {\\n             ans[i]=i;\\n            if(indegree[i]==0) {\\n             q.push(i);\\n\\n            }\\n        }\\n        \\n        int k=0;\\n        while(!q.empty()){\\n                int u = q.front();\\n\\t            q.pop();\\n\\t            \\n\\t            for(auto v : adj[u]){\\n\\t                indegree[v]--;\\n                    if(quiet[ans[v]]>quiet[ans[u]]){\\n                        ans[v]=ans[u];\\n                    }\\n\\t                if(indegree[v]==0) q.push(v);\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n//Suppose a is richer than b and b is richer than c , now quietness so\\n\\nanswer[a] = a (richest)\\nanswer[b] = min(quiet[a],quiet[b])   (more or equal money)\\nanswer[c] = min(quiet[c],quiet[b]) \\n```\n```cpp\\nif(quiet[ans[b]]>quiet[ans[a]]) // we need the number of the person\\n{\\n    ans[b]=ans[a];\\n}\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> ans(n);\\n        \\n        vector<int> adj[n];\\n        vector<int> indegree(n,0);\\n\\n        for(auto r : richer) {\\n            adj[r[0]].push_back(r[1]);\\n            indegree[r[1]]++;\\n        }\\n        vector<pair<int,int>> sorted;\\n        queue<int> q;\\n\\n        for(int i=0;i<n;i++) {\\n             ans[i]=i;\\n            if(indegree[i]==0) {\\n             q.push(i);\\n\\n            }\\n        }\\n        \\n        int k=0;\\n        while(!q.empty()){\\n                int u = q.front();\\n\\t            q.pop();\\n\\t            \\n\\t            for(auto v : adj[u]){\\n\\t                indegree[v]--;\\n                    if(quiet[ans[v]]>quiet[ans[u]]){\\n                        ans[v]=ans[u];\\n                    }\\n\\t                if(indegree[v]==0) q.push(v);\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969882,
                "title": "extended-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n\\n        vector<int> in(n,-1) ;\\n\\n        vector<int> adj[n];\\n\\n        for(auto i:richer)\\n        {\\n            int u = i [0] ;\\n            int v = i [1] ;\\n\\n            adj [u].push_back(v);\\n\\n            if(in[u]==-1)in[u]=0;\\n            if(in [v]==-1)in [v]=0;\\n            in [v]++;\\n        }\\n        \\n         vector<int>m(n);\\n         queue<int>q;\\n         for(int i=0;i<n;i++)\\n         {\\n             if(in[i]==0)q.push(i);\\n             m[quiet[i]]=i;\\n         }\\n         while(q.size())\\n         {\\n              int t= q.front();\\n              q.pop() ;\\n\\n              for( auto i :adj[t])\\n              {\\n                  if(--in[i]==0)\\n                  q.push(i);\\n\\n                  quiet[i]=min(quiet[i],quiet[t]);\\n              }\\n         }\\n         for(int i=0; i< n; i++)\\n         {\\n            \\n                 quiet[i]=m[quiet[i]];\\n            //  }\\n            //  else\\n            //  quiet[i]=i;\\n         }\\n        \\n        return quiet;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n\\n        vector<int> in(n,-1) ;\\n\\n        vector<int> adj[n];\\n\\n        for(auto i:richer)\\n        {\\n            int u = i [0] ;\\n            int v = i [1] ;\\n\\n            adj [u].push_back(v);\\n\\n            if(in[u]==-1)in[u]=0;\\n            if(in [v]==-1)in [v]=0;\\n            in [v]++;\\n        }\\n        \\n         vector<int>m(n);\\n         queue<int>q;\\n         for(int i=0;i<n;i++)\\n         {\\n             if(in[i]==0)q.push(i);\\n             m[quiet[i]]=i;\\n         }\\n         while(q.size())\\n         {\\n              int t= q.front();\\n              q.pop() ;\\n\\n              for( auto i :adj[t])\\n              {\\n                  if(--in[i]==0)\\n                  q.push(i);\\n\\n                  quiet[i]=min(quiet[i],quiet[t]);\\n              }\\n         }\\n         for(int i=0; i< n; i++)\\n         {\\n            \\n                 quiet[i]=m[quiet[i]];\\n            //  }\\n            //  else\\n            //  quiet[i]=i;\\n         }\\n        \\n        return quiet;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969191,
                "title": "c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    void dfs(int curr, vector<int> adjList[], vector<bool> &visited, vector<int>& quiet) {\\n        if(visited[curr]) return;\\n        visited[curr] = true;\\n        for(int next: adjList[curr]) {\\n            dfs(next, adjList, visited, quiet);\\n            quiet[curr] = min(quiet[curr], quiet[next]); \\n        }\\n    }\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adjList[n];\\n        for(vector<int> edge: richer) {\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        unordered_map<int, int> index;\\n        for(int i = 0; i < n; i++) index[quiet[i]] = i;\\n        vector<bool> visited(n);\\n        for(int i = 0; i < n; i++) {\\n            dfs(i, adjList, visited, quiet);\\n        }\\n        for(int i = 0; i < n; i++) quiet[i] = index[quiet[i]];\\n        return quiet;\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\n    void dfs(int curr, vector<int> adjList[], vector<bool> &visited, vector<int>& quiet, vector<int>& ans) {\\n        if(visited[curr]) return;\\n        visited[curr] = true;\\n        for(int next: adjList[curr]) {\\n            dfs(next, adjList, visited, quiet, ans);\\n            if(quiet[ans[next]] < quiet[ans[curr]])\\n                ans[curr] = ans[next];\\n        }\\n    }\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adjList[n], ans(n);\\n        for(vector<int> edge: richer) {\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        iota(ans.begin(), ans.end(), 0);\\n        vector<bool> visited(n);\\n        for(int i = 0; i < n; i++) {\\n            dfs(i, adjList, visited, quiet, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int curr, vector<int> adjList[], vector<bool> &visited, vector<int>& quiet) {\\n        if(visited[curr]) return;\\n        visited[curr] = true;\\n        for(int next: adjList[curr]) {\\n            dfs(next, adjList, visited, quiet);\\n            quiet[curr] = min(quiet[curr], quiet[next]); \\n        }\\n    }\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adjList[n];\\n        for(vector<int> edge: richer) {\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        unordered_map<int, int> index;\\n        for(int i = 0; i < n; i++) index[quiet[i]] = i;\\n        vector<bool> visited(n);\\n        for(int i = 0; i < n; i++) {\\n            dfs(i, adjList, visited, quiet);\\n        }\\n        for(int i = 0; i < n; i++) quiet[i] = index[quiet[i]];\\n        return quiet;\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\n    void dfs(int curr, vector<int> adjList[], vector<bool> &visited, vector<int>& quiet, vector<int>& ans) {\\n        if(visited[curr]) return;\\n        visited[curr] = true;\\n        for(int next: adjList[curr]) {\\n            dfs(next, adjList, visited, quiet, ans);\\n            if(quiet[ans[next]] < quiet[ans[curr]])\\n                ans[curr] = ans[next];\\n        }\\n    }\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adjList[n], ans(n);\\n        for(vector<int> edge: richer) {\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        iota(ans.begin(), ans.end(), 0);\\n        vector<bool> visited(n);\\n        for(int i = 0; i < n; i++) {\\n            dfs(i, adjList, visited, quiet, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963872,
                "title": "dfs-beats-100-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere I have used DFS approach and constructed a directed graph like richer[i]=[a,b] then there is a edge from b-> a that will tell about who are more richer people than the node.\\nanswer[i]=min(quiet[i],quietness of all child)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(edges+vertices)\\nas its a dfs approach\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int node,vector<int>& quiet,vector<bool> &visited, vector<vector<int>> &v,vector<int> &answer){\\n        if(visited[node]){\\n            return answer[node];\\n        }\\n        visited[node]=true;\\n\\n        int value=node;\\n        for(int i=0;i<v[node].size();i++){\\n//checking if there is any node in child tree that has low quiet value by calling dfs on every child\\n            int p=dfs(v[node][i],quiet,visited,v,answer);\\n            if(quiet[value]>quiet[p]){\\n                value=p;\\n            }\\n        }\\n        return answer[node]=value;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> answer(n);\\n        for(int i=0;i<n;i++){\\n            answer[i]=i;\\n        }\\n        vector<vector<int>> v(n);\\n        vector<int> indegree(n,0);\\n//indegree is used here to know from which node dfs can be started its not always neccasry that 0 is starting point\\n        for(int i=0;i<richer.size();i++){\\n            indegree[richer[i][0]]++;\\n            v[richer[i][1]].push_back(richer[i][0]);\\n        }\\n      \\n        vector<bool> visited(n,false);\\n        for(int i=0;i<n;i++){\\n            if(visited[i]==false && indegree[i]==0){\\n                dfs(i,quiet,visited,v,answer);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node,vector<int>& quiet,vector<bool> &visited, vector<vector<int>> &v,vector<int> &answer){\\n        if(visited[node]){\\n            return answer[node];\\n        }\\n        visited[node]=true;\\n\\n        int value=node;\\n        for(int i=0;i<v[node].size();i++){\\n//checking if there is any node in child tree that has low quiet value by calling dfs on every child\\n            int p=dfs(v[node][i],quiet,visited,v,answer);\\n            if(quiet[value]>quiet[p]){\\n                value=p;\\n            }\\n        }\\n        return answer[node]=value;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> answer(n);\\n        for(int i=0;i<n;i++){\\n            answer[i]=i;\\n        }\\n        vector<vector<int>> v(n);\\n        vector<int> indegree(n,0);\\n//indegree is used here to know from which node dfs can be started its not always neccasry that 0 is starting point\\n        for(int i=0;i<richer.size();i++){\\n            indegree[richer[i][0]]++;\\n            v[richer[i][1]].push_back(richer[i][0]);\\n        }\\n      \\n        vector<bool> visited(n,false);\\n        for(int i=0;i<n;i++){\\n            if(visited[i]==false && indegree[i]==0){\\n                dfs(i,quiet,visited,v,answer);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962955,
                "title": "python-clean-and-simple-topological-solution",
                "content": "```\\nfrom collections import defaultdict\\nfrom functools import cache\\nfrom itertools import chain\\n\\n\\nclass Solution:\\n    def loudAndRich(self, richer: list[list[int]], quiet: list[int]) -> list[int]:\\n        n = len(quiet)\\n\\n        g = self.create_graph(richer)\\n\\n        @cache\\n        def dfs(u: int) -> tuple[int, int]:\\n            \"\"\"\\n            finds the least quiet person having money more than or equal to person \"u\" \\n            and returns tuple containing the quietness and corresponding person index \\n            with that quietness \\n            :param u: \\n            :return:  \\n            \"\"\"\\n            return min(\\n                chain(\\n                    map(dfs, g[u]),\\n                    ((quiet[u], u),)\\n                )\\n            )\\n\\n        return [dfs(i)[1] for i in range(n)]\\n\\n    @staticmethod\\n    def create_graph(edges: list[list[int]]) -> defaultdict[int, list[int]]:\\n        g = defaultdict(list)\\n\\n        for a, b in edges:\\n            g[b].append(a)\\n\\n        return g\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom functools import cache\\nfrom itertools import chain\\n\\n\\nclass Solution:\\n    def loudAndRich(self, richer: list[list[int]], quiet: list[int]) -> list[int]:\\n        n = len(quiet)\\n\\n        g = self.create_graph(richer)\\n\\n        @cache\\n        def dfs(u: int) -> tuple[int, int]:\\n            \"\"\"\\n            finds the least quiet person having money more than or equal to person \"u\" \\n            and returns tuple containing the quietness and corresponding person index \\n            with that quietness \\n            :param u: \\n            :return:  \\n            \"\"\"\\n            return min(\\n                chain(\\n                    map(dfs, g[u]),\\n                    ((quiet[u], u),)\\n                )\\n            )\\n\\n        return [dfs(i)[1] for i in range(n)]\\n\\n    @staticmethod\\n    def create_graph(edges: list[list[int]]) -> defaultdict[int, list[int]]:\\n        g = defaultdict(list)\\n\\n        for a, b in edges:\\n            g[b].append(a)\\n\\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955095,
                "title": "java-dfs-traversal-on-poor-directed-graph",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        return dfsApproach(richer, quiet);\\n    }\\n    \\n    /*\\n    Algo:\\n        Create graph for showing poor relationship\\n        graph = {k: richer[1], v: list(richer[0])}\\n\\n        run dfs and get node with min quietness for each node\\n    */\\n\\n    private int[] dfsApproach(int[][] richer, int[] quiet) {\\n        Map<Integer, Set<Integer>> graph = Arrays.stream(richer).collect(Collectors.groupingBy(rich -> rich[1], Collectors.mapping(rich -> rich[0], Collectors.toSet())));\\n        \\n        int n = quiet.length;\\n        int[] result = IntStream.generate(() -> -1).limit(n).toArray();\\n        \\n        IntStream.range(0, n).forEach(u -> dfsApproach(u, graph, quiet, result));\\n        \\n        return result;\\n    }\\n    private int dfsApproach(int u, Map<Integer, Set<Integer>> graph, int[] quiet, int[] result) {\\n        if(result[u] != -1) return result[u];\\n\\n        Set<Integer> neighbors = graph.getOrDefault(u, Set.of());\\n        \\n        return result[u] = neighbors.stream().mapToInt(v -> dfsApproach(v, graph, quiet, result)).reduce(u, (minNode, v) -> quiet[minNode] < quiet[v] ? minNode : v);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        return dfsApproach(richer, quiet);\\n    }\\n    \\n    /*\\n    Algo:\\n        Create graph for showing poor relationship\\n        graph = {k: richer[1], v: list(richer[0])}\\n\\n        run dfs and get node with min quietness for each node\\n    */\\n\\n    private int[] dfsApproach(int[][] richer, int[] quiet) {\\n        Map<Integer, Set<Integer>> graph = Arrays.stream(richer).collect(Collectors.groupingBy(rich -> rich[1], Collectors.mapping(rich -> rich[0], Collectors.toSet())));\\n        \\n        int n = quiet.length;\\n        int[] result = IntStream.generate(() -> -1).limit(n).toArray();\\n        \\n        IntStream.range(0, n).forEach(u -> dfsApproach(u, graph, quiet, result));\\n        \\n        return result;\\n    }\\n    private int dfsApproach(int u, Map<Integer, Set<Integer>> graph, int[] quiet, int[] result) {\\n        if(result[u] != -1) return result[u];\\n\\n        Set<Integer> neighbors = graph.getOrDefault(u, Set.of());\\n        \\n        return result[u] = neighbors.stream().mapToInt(v -> dfsApproach(v, graph, quiet, result)).reduce(u, (minNode, v) -> quiet[minNode] < quiet[v] ? minNode : v);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937900,
                "title": "python-3-simple-topologcal-sort-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n\\n        # create an indegree array and adjList from rich to poor\\n        adjList = defaultdict(list)\\n        indegree = [0] * len(quiet)\\n        for u, v in richer:\\n            adjList[u].append(v)\\n            indegree[v] += 1\\n\\n        # store the index of the least quiteness for each indegree reduction\\n        q = deque()\\n        leastQuiet = [i for i in range(len(quiet))]\\n        for i in range(len(quiet)):\\n            if not indegree[i]:\\n                q.append(i)\\n\\n        res = [0] * len(quiet)\\n        # starting from the src; rich\\n            # bfs-topological sort\\n        while q:\\n            node = q.popleft()\\n            res[node] = leastQuiet[node]\\n\\n            for nei in adjList[node]:\\n                indegree[nei] -= 1\\n\\n                # update the index of the least quiet stored in the nei\\n                    # when visiting from the source\\n                if quiet[leastQuiet[nei]] > quiet[leastQuiet[node]]:\\n                    leastQuiet[nei] = leastQuiet[node]\\n                if not indegree[nei]:\\n                    q.append(nei)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n\\n        # create an indegree array and adjList from rich to poor\\n        adjList = defaultdict(list)\\n        indegree = [0] * len(quiet)\\n        for u, v in richer:\\n            adjList[u].append(v)\\n            indegree[v] += 1\\n\\n        # store the index of the least quiteness for each indegree reduction\\n        q = deque()\\n        leastQuiet = [i for i in range(len(quiet))]\\n        for i in range(len(quiet)):\\n            if not indegree[i]:\\n                q.append(i)\\n\\n        res = [0] * len(quiet)\\n        # starting from the src; rich\\n            # bfs-topological sort\\n        while q:\\n            node = q.popleft()\\n            res[node] = leastQuiet[node]\\n\\n            for nei in adjList[node]:\\n                indegree[nei] -= 1\\n\\n                # update the index of the least quiet stored in the nei\\n                    # when visiting from the source\\n                if quiet[leastQuiet[nei]] > quiet[leastQuiet[node]]:\\n                    leastQuiet[nei] = leastQuiet[node]\\n                if not indegree[nei]:\\n                    q.append(nei)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937550,
                "title": "concise-and-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> adj(n);\\n        vector<int> ans(n, INT_MAX);\\n        vector<int> indegree(n, 0);\\n        queue<int> q;\\n            for (const auto& relation : richer) {\\n            int source = relation[0];\\n            int target = relation[1];\\n            adj[source].push_back(target);\\n            indegree[target]++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = i;\\n            if (indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            \\n            for (int neighbor : adj[node]) {\\n                if (ans[neighbor] == INT_MAX || quiet[ans[neighbor]] > quiet[ans[node]]) {\\n                    ans[neighbor] = ans[node];\\n                }\\n                indegree[neighbor]--;\\n                if (indegree[neighbor] == 0) {\\n                    q.push(neighbor);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> adj(n);\\n        vector<int> ans(n, INT_MAX);\\n        vector<int> indegree(n, 0);\\n        queue<int> q;\\n            for (const auto& relation : richer) {\\n            int source = relation[0];\\n            int target = relation[1];\\n            adj[source].push_back(target);\\n            indegree[target]++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = i;\\n            if (indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            \\n            for (int neighbor : adj[node]) {\\n                if (ans[neighbor] == INT_MAX || quiet[ans[neighbor]] > quiet[ans[node]]) {\\n                    ans[neighbor] = ans[node];\\n                }\\n                indegree[neighbor]--;\\n                if (indegree[neighbor] == 0) {\\n                    q.push(neighbor);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933684,
                "title": "dynamic-programming-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int dp[501];\\n    int dfs(map<int,vector<int>>&adj, vector<int>& quiet,int node){\\n        int num=node;\\n        if(dp[node]!=-1) return dp[node];\\n        for(int i=0; i<adj[node].size(); i++){\\n            \\n            int temp = dfs(adj,quiet,adj[node][i]);\\n            if(quiet[num]>quiet[temp])\\n            num = temp;\\n        }\\n        \\n        if(quiet[node] < quiet[num])\\n        return dp[node] = node;\\n        return dp[node] = num;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        map<int, vector<int>>adj;\\n        for(int i=0; i<richer.size(); i++){\\n            adj[richer[i][1]].push_back(richer[i][0]);   \\n        }\\n        vector<int> ans;\\n        for(int i=0; i<501; i++){\\n            dp[i] = -1;\\n        }\\n        for(int i=0; i<quiet.size(); i++){\\n            ans.push_back(dfs(adj,quiet,i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int dp[501];\\n    int dfs(map<int,vector<int>>&adj, vector<int>& quiet,int node){\\n        int num=node;\\n        if(dp[node]!=-1) return dp[node];\\n        for(int i=0; i<adj[node].size(); i++){\\n            \\n            int temp = dfs(adj,quiet,adj[node][i]);\\n            if(quiet[num]>quiet[temp])\\n            num = temp;\\n        }\\n        \\n        if(quiet[node] < quiet[num])\\n        return dp[node] = node;\\n        return dp[node] = num;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        map<int, vector<int>>adj;\\n        for(int i=0; i<richer.size(); i++){\\n            adj[richer[i][1]].push_back(richer[i][0]);   \\n        }\\n        vector<int> ans;\\n        for(int i=0; i<501; i++){\\n            dp[i] = -1;\\n        }\\n        for(int i=0; i<quiet.size(); i++){\\n            ans.push_back(dfs(adj,quiet,i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926449,
                "title": "simple-cpp-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(map<int,vector<int>>&graph,int v,vector<int>&visited, vector<int>& quiet,int& idx){\\n\\n        visited[v] = 1;\\n\\n        for(auto node:graph[v]){\\n\\n            if(!visited[node]){\\n                if(quiet[node]<quiet[idx]){\\n                    idx = node;\\n                }\\n                dfs(graph,node,visited,quiet,idx);\\n            }\\n        }\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n\\n        map<int,vector<int>> graph;\\n        vector<int> ans;\\n\\n        for(auto v:richer){\\n            graph[v[1]].push_back(v[0]);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n\\n            int minQuiet = i;\\n            vector<int>vis(n,0);\\n            dfs(graph,i,vis,quiet,minQuiet);\\n            ans.push_back(minQuiet);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(map<int,vector<int>>&graph,int v,vector<int>&visited, vector<int>& quiet,int& idx){\\n\\n        visited[v] = 1;\\n\\n        for(auto node:graph[v]){\\n\\n            if(!visited[node]){\\n                if(quiet[node]<quiet[idx]){\\n                    idx = node;\\n                }\\n                dfs(graph,node,visited,quiet,idx);\\n            }\\n        }\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n\\n        map<int,vector<int>> graph;\\n        vector<int> ans;\\n\\n        for(auto v:richer){\\n            graph[v[1]].push_back(v[0]);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n\\n            int minQuiet = i;\\n            vector<int>vis(n,0);\\n            dfs(graph,i,vis,quiet,minQuiet);\\n            ans.push_back(minQuiet);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889227,
                "title": "c-dfs-approach",
                "content": "# Intuition\\nThe main thing would be here is to construct the adjacency list as it only provides the way forward to traverse through the richer people than the current people and find the quietest among them.\\n\\nIn order to construct the adjacency matrix we have to relate them reverse so that someone who is poor is always having the richer person in the adjacency list in order for him to traverse and find the richer people than him.\\n\\n`adj[richer[i][1]].push_back(richer[i][0])`\\n\\n# Approach\\nOnce after creating the adjacency list we can actually traverse by using DFS for each index and if we have already found the answer during the previous search then we simply return the answer and fill the answer array.\\nThis approach is also called as Hashing the DFS such that we might not move through the already found answer instead if we have the answer already hashed we simply return it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int idx, vector<int> &ans, vector<int> adj[], vector<int> &quiet) {\\n        if(ans[idx] == -1) {\\n            ans[idx] = idx;\\n            for(auto &it:adj[idx]) {\\n                int quietest = dfs(it, ans, adj, quiet);\\n                if(quiet[quietest] < quiet[ans[idx]]) {\\n                    ans[idx] = quietest;\\n                }\\n            }\\n        }\\n        return ans[idx];\\n\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        for(auto &it : richer) {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans(n, -1);\\n        for(int i=0;i<n;i++) {\\n            dfs(i, ans, adj, quiet);\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int idx, vector<int> &ans, vector<int> adj[], vector<int> &quiet) {\\n        if(ans[idx] == -1) {\\n            ans[idx] = idx;\\n            for(auto &it:adj[idx]) {\\n                int quietest = dfs(it, ans, adj, quiet);\\n                if(quiet[quietest] < quiet[ans[idx]]) {\\n                    ans[idx] = quietest;\\n                }\\n            }\\n        }\\n        return ans[idx];\\n\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        for(auto &it : richer) {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans(n, -1);\\n        for(int i=0;i<n;i++) {\\n            dfs(i, ans, adj, quiet);\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885008,
                "title": "c-topological-sorting-graph",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        //topological sort can help me in iterating over all the persons who are richer than child so basically i can compare everytime and fill the right person there\\n        int n=quiet.size();\\n        vector<int> indegree(n,0), ans(n,0);\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++)ans[i]=i;//assume i is itself the ans which is true in some cases\\n        for(auto vec:richer){\\n            adj[vec[0]].push_back(vec[1]);\\n            indegree[vec[1]]++;\\n        }\\n        // push all the richest persons in the queue\\n        queue<int> pending;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)pending.push(i);\\n        }\\n        //topo sort\\n        while(!pending.empty()){\\n            int u=pending.front();\\n            pending.pop();\\n            for(auto child : adj[u]){\\n                indegree[child]--;//dependency removal from parent\\n                if(indegree[child]==0)pending.push(child);//all the richer are explored\\n                if(quiet[ans[child]]>quiet[ans[u]]){// ans[u] is the person least quiet person than u being the richer or equal than it\\n                    ans[child]=ans[u];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        //topological sort can help me in iterating over all the persons who are richer than child so basically i can compare everytime and fill the right person there\\n        int n=quiet.size();\\n        vector<int> indegree(n,0), ans(n,0);\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++)ans[i]=i;//assume i is itself the ans which is true in some cases\\n        for(auto vec:richer){\\n            adj[vec[0]].push_back(vec[1]);\\n            indegree[vec[1]]++;\\n        }\\n        // push all the richest persons in the queue\\n        queue<int> pending;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)pending.push(i);\\n        }\\n        //topo sort\\n        while(!pending.empty()){\\n            int u=pending.front();\\n            pending.pop();\\n            for(auto child : adj[u]){\\n                indegree[child]--;//dependency removal from parent\\n                if(indegree[child]==0)pending.push(child);//all the richer are explored\\n                if(quiet[ans[child]]>quiet[ans[u]]){// ans[u] is the person least quiet person than u being the richer or equal than it\\n                    ans[child]=ans[u];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872531,
                "title": "python-dfs-solution-beats-100",
                "content": "Build graph in reverse way let\\'s say we are given [x,y], then build graph like there is an edge from y to x and not vice-versa. Use dfs to compute min value of all the children and also maintain the index of min value child, also check for min with self also. update the min value computed for both ans and quiet. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n      n = len(quiet) \\n      g,ans,mark = [[] for _ in range(n)],[i for i in range(n)],[False]*n\\n      for x,y in richer : g[y].append(x) \\n\\n      def dfs(x):\\n        mark[x] = True \\n        for i in g[x]:\\n          if not mark[i] : dfs(i) \\n          if quiet[x] > quiet[i] : \\n            quiet[x] = quiet[i] # taking min of all the parent values \\n            ans[x] = ans[i]  # taking index which has min value\\n      \\n      for i in range(n): \\n        if not mark[i] : \\n          dfs(i) \\n        \\n      return ans \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n      n = len(quiet) \\n      g,ans,mark = [[] for _ in range(n)],[i for i in range(n)],[False]*n\\n      for x,y in richer : g[y].append(x) \\n\\n      def dfs(x):\\n        mark[x] = True \\n        for i in g[x]:\\n          if not mark[i] : dfs(i) \\n          if quiet[x] > quiet[i] : \\n            quiet[x] = quiet[i] # taking min of all the parent values \\n            ans[x] = ans[i]  # taking index which has min value\\n      \\n      for i in range(n): \\n        if not mark[i] : \\n          dfs(i) \\n        \\n      return ans \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849717,
                "title": "c-topological-sort-solution-using-result-array-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<vector<int>> adjL(quiet.size(), vector<int>());\\n        vector<int> indegree(quiet.size(), 0);\\n\\n        for (auto rich : richer) {\\n            adjL[rich[0]].push_back(rich[1]);\\n            indegree[rich[1]]++;\\n        }\\n\\n        queue<int> q;\\n\\n        for (int i = 0; i < indegree.size(); i++) {\\n            if (indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<int> result(quiet.size());\\n\\n        for (int i = 0; i < result.size(); i++) {\\n            result[i] = i;\\n        }\\n    \\n        while (!q.empty()) {\\n            int front = q.front();\\n            \\n            q.pop();\\n\\n            for (int v : adjL[front]) {\\n                if (quiet[result[v]] > quiet[result[front]]) {\\n                    result[v] = result[front];\\n                }\\n\\n                if (--indegree[v] == 0) {\\n                    q.push(v);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<vector<int>> adjL(quiet.size(), vector<int>());\\n        vector<int> indegree(quiet.size(), 0);\\n\\n        for (auto rich : richer) {\\n            adjL[rich[0]].push_back(rich[1]);\\n            indegree[rich[1]]++;\\n        }\\n\\n        queue<int> q;\\n\\n        for (int i = 0; i < indegree.size(); i++) {\\n            if (indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<int> result(quiet.size());\\n\\n        for (int i = 0; i < result.size(); i++) {\\n            result[i] = i;\\n        }\\n    \\n        while (!q.empty()) {\\n            int front = q.front();\\n            \\n            q.pop();\\n\\n            for (int v : adjL[front]) {\\n                if (quiet[result[v]] > quiet[result[front]]) {\\n                    result[v] = result[front];\\n                }\\n\\n                if (--indegree[v] == 0) {\\n                    q.push(v);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833511,
                "title": "c-graphs-dfs",
                "content": "~~~\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector <vector <int>> g(n);\\n        for (int i=0; i<richer.size(); i++)\\n            g[richer[i][1]].push_back(richer[i][0]);\\n        \\n        vector <int> ans(n);\\n        for (int i=0; i<n; i++)\\n            ans[i] = i;\\n        \\n        vector <int> vis(n, 0);\\n        for (int i=0; i<n; i++)\\n            dfs (i, g, vis, ans, quiet);\\n        \\n        return ans;\\n    }\\n    \\n    void dfs (int v, vector <vector <int>>& g, vector <int>& vis, vector <int>& ans, vector <int>& q)\\n    {\\n        if (vis[v])\\n            return;\\n        \\n        vis[v] = 1;\\n        for (int i=0; i<g[v].size(); i++)\\n        {\\n            dfs (g[v][i], g, vis, ans, q);\\n            if (q[ans[g[v][i]]]<q[ans[v]])\\n                ans[v] = ans[g[v][i]];\\n        }\\n    }\\n};\\n~~~",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector <vector <int>> g(n);\\n        for (int i=0; i<richer.size(); i++)\\n            g[richer[i][1]].push_back(richer[i][0]);\\n        \\n        vector <int> ans(n);\\n        for (int i=0; i<n; i++)\\n            ans[i] = i;\\n        \\n        vector <int> vis(n, 0);\\n        for (int i=0; i<n; i++)\\n            dfs (i, g, vis, ans, quiet);\\n        \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3829015,
                "title": "khan-s-algorithm-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to return an answer array where each index represents a person from 0 to N-1. The value of a particular index would be a special person who is least quiet among all the persons having equal or more money than the index(person).\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(V+E)$$ \\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int N = quiet.size();\\n        vector<int> indegree(N,0);\\n        vector<int> adj[N];\\n        for(auto x: richer){\\n            adj[x[0]].push_back(x[1]);\\n            indegree[x[1]]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i=0; i<N; i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<int> answer(N);\\n        iota(answer.begin(),answer.end(),0);    \\n        \\n        while(!q.empty()){\\n            int personX = q.front();\\n            q.pop();\\n            for(auto personY: adj[personX]){\\n                if(quiet[answer[personY]] > quiet[answer[personX]]){\\n                    answer[personY]=answer[personX];\\n                }\\n                indegree[personY]--;\\n                if(indegree[personY]==0){\\n                    q.push(personY);\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int N = quiet.size();\\n        vector<int> indegree(N,0);\\n        vector<int> adj[N];\\n        for(auto x: richer){\\n            adj[x[0]].push_back(x[1]);\\n            indegree[x[1]]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i=0; i<N; i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<int> answer(N);\\n        iota(answer.begin(),answer.end(),0);    \\n        \\n        while(!q.empty()){\\n            int personX = q.front();\\n            q.pop();\\n            for(auto personY: adj[personX]){\\n                if(quiet[answer[personY]] > quiet[answer[personX]]){\\n                    answer[personY]=answer[personX];\\n                }\\n                indegree[personY]--;\\n                if(indegree[personY]==0){\\n                    q.push(personY);\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821524,
                "title": "python-simple-bfs-beats-100",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/a9b1640f-ce0b-41ec-bee0-71001ad366d7_1690423946.9974694.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        graph = defaultdict(list)\\n        for a,b in richer:\\n            graph[a].append(b)\\n        \\n        order = deque(quiet)\\n        \\n        # print(graph)\\n\\n        out = list(range(len(quiet)))\\n\\n        while order:\\n            i = order.popleft()\\n            # print(out, i, graph[i])\\n\\n            for nxt in graph[i]:\\n                # self.dfs(graph, quiet, nxt, i, out, visited)\\n                if quiet[out[i]] < quiet[out[nxt]]:\\n                    out[nxt] = out[i]\\n                    order.append(nxt)\\n\\n        return out\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        graph = defaultdict(list)\\n        for a,b in richer:\\n            graph[a].append(b)\\n        \\n        order = deque(quiet)\\n        \\n        # print(graph)\\n\\n        out = list(range(len(quiet)))\\n\\n        while order:\\n            i = order.popleft()\\n            # print(out, i, graph[i])\\n\\n            for nxt in graph[i]:\\n                # self.dfs(graph, quiet, nxt, i, out, visited)\\n                if quiet[out[i]] < quiet[out[nxt]]:\\n                    out[nxt] = out[i]\\n                    order.append(nxt)\\n\\n        return out\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820415,
                "title": "python-bfs-topo-sort",
                "content": "\\n# Code\\n```\\nfrom collections import defaultdict,deque\\n\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n\\n        graph,revg = defaultdict(list),defaultdict(list)\\n        n = len(quiet)\\n        ind = [0 for i in range(n)]\\n\\n        for x,y in richer:\\n            graph[x].append(y)\\n            revg[y].append(x)\\n            ind[y]+=1\\n\\n        q = deque()\\n\\n        for i,x in enumerate(ind):\\n            if x==0:\\n                q.append(i)\\n\\n        ans = [0 for i in range(n)]\\n        while q:\\n            cs = len(q)\\n            for i in range(cs):\\n                ele = q.popleft()\\n                ans[ele] = ele\\n                cq = quiet[ele]\\n\\n                for anc in revg[ele]:\\n                    if quiet[ans[anc]]<cq:\\n                        cq = quiet[ans[anc]]\\n                        ans[ele]=ans[anc]\\n\\n                for neigh in graph[ele]:\\n                    ind[neigh]-=1\\n                    if ind[neigh]==0:\\n                        q.append(neigh)\\n\\n        return ans\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict,deque\\n\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n\\n        graph,revg = defaultdict(list),defaultdict(list)\\n        n = len(quiet)\\n        ind = [0 for i in range(n)]\\n\\n        for x,y in richer:\\n            graph[x].append(y)\\n            revg[y].append(x)\\n            ind[y]+=1\\n\\n        q = deque()\\n\\n        for i,x in enumerate(ind):\\n            if x==0:\\n                q.append(i)\\n\\n        ans = [0 for i in range(n)]\\n        while q:\\n            cs = len(q)\\n            for i in range(cs):\\n                ele = q.popleft()\\n                ans[ele] = ele\\n                cq = quiet[ele]\\n\\n                for anc in revg[ele]:\\n                    if quiet[ans[anc]]<cq:\\n                        cq = quiet[ans[anc]]\\n                        ans[ele]=ans[anc]\\n\\n                for neigh in graph[ele]:\\n                    ind[neigh]-=1\\n                    if ind[neigh]==0:\\n                        q.append(neigh)\\n\\n        return ans\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820202,
                "title": "100-beats-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    DFS and Dynamic Programming\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Finding the minimum quiet of all the neighbours( all the indices that are richer than the index considered ).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nclass Solution {\\n    List<Integer> lis[];\\n    int n;\\n    int dp[];\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        n=quiet.length;\\n        dp=new int[n];\\n        lis=new ArrayList[n];\\n        Arrays.fill(dp,-1);\\n        int res[]=new int[n];\\n        for(int i=0;i<n;i++)\\n            lis[i]=new ArrayList<>();\\n        for(int i[] : richer)\\n        {\\n            lis[i[1]].add(i[0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=dfs(i,quiet);\\n        }\\n        return res;\\n    }\\n    public int dfs(int ind,int []quiet)\\n    {\\n        if(dp[ind]!=-1) return dp[ind];\\n        int minIndex=ind,minQuiet=quiet[ind];\\n        for(int i : lis[ind])\\n        {\\n            int min=dfs(i,quiet);\\n            if(quiet[min]<minQuiet)\\n            {\\n                minQuiet=quiet[min];\\n                minIndex=min;\\n            }\\n        }\\n        return dp[ind]=minIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> lis[];\\n    int n;\\n    int dp[];\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        n=quiet.length;\\n        dp=new int[n];\\n        lis=new ArrayList[n];\\n        Arrays.fill(dp,-1);\\n        int res[]=new int[n];\\n        for(int i=0;i<n;i++)\\n            lis[i]=new ArrayList<>();\\n        for(int i[] : richer)\\n        {\\n            lis[i[1]].add(i[0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=dfs(i,quiet);\\n        }\\n        return res;\\n    }\\n    public int dfs(int ind,int []quiet)\\n    {\\n        if(dp[ind]!=-1) return dp[ind];\\n        int minIndex=ind,minQuiet=quiet[ind];\\n        for(int i : lis[ind])\\n        {\\n            int min=dfs(i,quiet);\\n            if(quiet[min]<minQuiet)\\n            {\\n                minQuiet=quiet[min];\\n                minIndex=min;\\n            }\\n        }\\n        return dp[ind]=minIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798374,
                "title": "a-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] LoudAndRich(int[][] richer, int[] quiet) {\\n        var dict = new Dictionary<int, IList<int>>();\\n        for (int i = 0; i < richer.Length; i++)\\n        {\\n            if (!dict.ContainsKey(richer[i][1]))\\n                dict[richer[i][1]] = new List<int>();\\n            dict[richer[i][1]].Add(richer[i][0]);\\n        }\\n        int[] res = new int[quiet.Length];\\n        for (int i = 0; i < res.Length; i++) res[i] = -1;\\n        for (int i = 0; i < quiet.Length; i++)\\n            Helper(i, dict, quiet, res);\\n        return res;\\n    }\\n    void Helper(int index, Dictionary<int, IList<int>> dict, int[] quiet, int[] res)\\n    {\\n        if (res[index] > -1) return;\\n        res[index] = index;\\n        if (dict.ContainsKey(index))\\n        {\\n            foreach(var item in dict[index])\\n            {\\n                Helper(item, dict, quiet, res);\\n                if (quiet[res[item]] < quiet[res[index]])\\n                    res[index] = res[item];\\n            }           \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] LoudAndRich(int[][] richer, int[] quiet) {\\n        var dict = new Dictionary<int, IList<int>>();\\n        for (int i = 0; i < richer.Length; i++)\\n        {\\n            if (!dict.ContainsKey(richer[i][1]))\\n                dict[richer[i][1]] = new List<int>();\\n            dict[richer[i][1]].Add(richer[i][0]);\\n        }\\n        int[] res = new int[quiet.Length];\\n        for (int i = 0; i < res.Length; i++) res[i] = -1;\\n        for (int i = 0; i < quiet.Length; i++)\\n            Helper(i, dict, quiet, res);\\n        return res;\\n    }\\n    void Helper(int index, Dictionary<int, IList<int>> dict, int[] quiet, int[] res)\\n    {\\n        if (res[index] > -1) return;\\n        res[index] = index;\\n        if (dict.ContainsKey(index))\\n        {\\n            foreach(var item in dict[index])\\n            {\\n                Helper(item, dict, quiet, res);\\n                if (quiet[res[item]] < quiet[res[index]])\\n                    res[index] = res[item];\\n            }           \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781877,
                "title": "c-beat-92-5-in-tc-beat-70-in-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>&ans,vector<vector<int>>&adj,vector<int>&vis,vector<int>& q)\\n    {\\n        vis[node]=1;\\n    //    cout<<node<<endl;\\n        for(auto i:adj[node])\\n        {\\n            if(vis[i]==0)\\n            {\\n                 dfs(i,ans,adj,vis,q);\\n                 \\n            }\\n            ans[node]=min(ans[node],ans[i]);\\n        }\\n        // cout<<node<<\" \"<<ans[node]<<endl;\\n       return;\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        int n=q.size();\\n        vector<int>ans(n);\\n        vector<vector<int>>adj(n);\\n\\n        for(auto &i:r)\\n        {\\n            // cout<<i[0]<<\" \"<<i[1]<<endl;\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[q[i]]=i;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i]=q[i];\\n        } \\n\\n        vector<int>vis(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n              if(vis[i]==0)\\n              {\\n                  dfs(i,ans,adj,vis,q);\\n              }\\n        }\\n\\n       for(auto &i:ans)\\n       {\\n           i=mp[i];\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>&ans,vector<vector<int>>&adj,vector<int>&vis,vector<int>& q)\\n    {\\n        vis[node]=1;\\n    //    cout<<node<<endl;\\n        for(auto i:adj[node])\\n        {\\n            if(vis[i]==0)\\n            {\\n                 dfs(i,ans,adj,vis,q);\\n                 \\n            }\\n            ans[node]=min(ans[node],ans[i]);\\n        }\\n        // cout<<node<<\" \"<<ans[node]<<endl;\\n       return;\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        int n=q.size();\\n        vector<int>ans(n);\\n        vector<vector<int>>adj(n);\\n\\n        for(auto &i:r)\\n        {\\n            // cout<<i[0]<<\" \"<<i[1]<<endl;\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[q[i]]=i;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i]=q[i];\\n        } \\n\\n        vector<int>vis(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n              if(vis[i]==0)\\n              {\\n                  dfs(i,ans,adj,vis,q);\\n              }\\n        }\\n\\n       for(auto &i:ans)\\n       {\\n           i=mp[i];\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3766961,
                "title": "esay-java-dfs-loud-and-rich",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        ArrayList<Integer> arr[] = new ArrayList[quiet.length];\\n        boolean[] visited =  new boolean[quiet.length];\\n        int[] ans=new int[quiet.length];\\n        Arrays.fill(ans,-1);\\n\\n        for(int i=0;i<quiet.length;i++){\\n            arr[i]=new ArrayList<>();\\n        }\\n         for(int i=0;i<richer.length;i++){\\n            arr[richer[i][1]].add(richer[i][0]);\\n        }\\n\\n\\n        for(int i=0;i<visited.length;i++){\\n            if(!visited[i]){\\n                dfs(i,visited,ans,quiet,arr);\\n            }\\n        }\\n        return ans;\\n    }\\n \\n    int[] dfs( int source , boolean[] visited , int[] ans ,  int[] quite ,  ArrayList<Integer> arr[]){\\n        visited[source]=true;\\n        int[] currmen= { source , quite[source] };\\n        for( int negibours : arr[source] ){\\n            if( ans[negibours] != -1 ){\\n                if( quite[ans[negibours]] < currmen[1] ) {\\n                    currmen[1]=quite[ans[negibours]];\\n                    currmen[0]=ans[negibours];\\n                }\\n            }\\n            else {\\n                int[] negiboursArray=dfs( negibours,visited,ans,quite,arr );\\n                if( negiboursArray[1] < currmen[1] ) {\\n                    currmen[1]=negiboursArray[1];\\n                    currmen[0]=negiboursArray[0];\\n                }\\n\\n            }\\n        }\\n        ans[source]=currmen[0];\\n        return currmen;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        ArrayList<Integer> arr[] = new ArrayList[quiet.length];\\n        boolean[] visited =  new boolean[quiet.length];\\n        int[] ans=new int[quiet.length];\\n        Arrays.fill(ans,-1);\\n\\n        for(int i=0;i<quiet.length;i++){\\n            arr[i]=new ArrayList<>();\\n        }\\n         for(int i=0;i<richer.length;i++){\\n            arr[richer[i][1]].add(richer[i][0]);\\n        }\\n\\n\\n        for(int i=0;i<visited.length;i++){\\n            if(!visited[i]){\\n                dfs(i,visited,ans,quiet,arr);\\n            }\\n        }\\n        return ans;\\n    }\\n \\n    int[] dfs( int source , boolean[] visited , int[] ans ,  int[] quite ,  ArrayList<Integer> arr[]){\\n        visited[source]=true;\\n        int[] currmen= { source , quite[source] };\\n        for( int negibours : arr[source] ){\\n            if( ans[negibours] != -1 ){\\n                if( quite[ans[negibours]] < currmen[1] ) {\\n                    currmen[1]=quite[ans[negibours]];\\n                    currmen[0]=ans[negibours];\\n                }\\n            }\\n            else {\\n                int[] negiboursArray=dfs( negibours,visited,ans,quite,arr );\\n                if( negiboursArray[1] < currmen[1] ) {\\n                    currmen[1]=negiboursArray[1];\\n                    currmen[0]=negiboursArray[0];\\n                }\\n\\n            }\\n        }\\n        ans[source]=currmen[0];\\n        return currmen;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741030,
                "title": "javascript-dfs-with-memoization",
                "content": "```\\n/**\\n * @param {number[][]} richer\\n * @param {number[]} quiet\\n * @return {number[]}\\n */\\nvar loudAndRich = function(richer, quiet) {\\n  const list = [];\\n  const output = [];\\n  const memo = {};\\n\\n  richer.forEach(([u,v]) => !list[v] ? list[v] = [u] : list[v].push(u));\\n\\n  for (let i = 0; i < quiet.length; i++) {\\n    output.push(dfs(i));\\n  }\\n\\n  return output;\\n  \\n  // dfs with memo DP\\n  function dfs(node) {\\n    if (node in memo) return memo[node];\\n    if (!list[node]) {\\n      memo[node] = node;\\n      return node;\\n    }\\n    let quiestNode = node;\\n    let quiestLevel = quiet[node];\\n\\n    for (const next of list[node]) {\\n      const result = dfs(next);\\n      if (quiet[result] < quiestLevel) {\\n        quiestNode = result;\\n        quiestLevel = quiet[result];\\n      }\\n    }\\n\\n    memo[node] = quiestNode;\\n    return memo[node];  \\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} richer\\n * @param {number[]} quiet\\n * @return {number[]}\\n */\\nvar loudAndRich = function(richer, quiet) {\\n  const list = [];\\n  const output = [];\\n  const memo = {};\\n\\n  richer.forEach(([u,v]) => !list[v] ? list[v] = [u] : list[v].push(u));\\n\\n  for (let i = 0; i < quiet.length; i++) {\\n    output.push(dfs(i));\\n  }\\n\\n  return output;\\n  \\n  // dfs with memo DP\\n  function dfs(node) {\\n    if (node in memo) return memo[node];\\n    if (!list[node]) {\\n      memo[node] = node;\\n      return node;\\n    }\\n    let quiestNode = node;\\n    let quiestLevel = quiet[node];\\n\\n    for (const next of list[node]) {\\n      const result = dfs(next);\\n      if (quiet[result] < quiestLevel) {\\n        quiestNode = result;\\n        quiestLevel = quiet[result];\\n      }\\n    }\\n\\n    memo[node] = quiestNode;\\n    return memo[node];  \\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3738183,
                "title": "very-easy-c-kahn-s-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int>ans(n);\\n        vector<int>adj[n];\\n        vector<int>indegree(n);\\n        for(int i=0;i<richer.size();i++){\\n           adj[richer[i][0]].push_back(richer[i][1]);\\n           indegree[richer[i][1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)q.push(i);\\n            ans[i]=i;\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto it:adj[node]){\\n//here we are looking to make poor person \"quiet\" low from rich\\n//\"node->it\" -Here \"node\" is rich and \"it\" is denoting poor\\n                if(quiet[ans[it]]>quiet[ans[node]])\\n                ans[it]=ans[node];\\n                indegree[it]--;\\n                if(indegree[it]==0)q.push(it);\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int>ans(n);\\n        vector<int>adj[n];\\n        vector<int>indegree(n);\\n        for(int i=0;i<richer.size();i++){\\n           adj[richer[i][0]].push_back(richer[i][1]);\\n           indegree[richer[i][1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)q.push(i);\\n            ans[i]=i;\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto it:adj[node]){\\n//here we are looking to make poor person \"quiet\" low from rich\\n//\"node->it\" -Here \"node\" is rich and \"it\" is denoting poor\\n                if(quiet[ans[it]]>quiet[ans[node]])\\n                ans[it]=ans[node];\\n                indegree[it]--;\\n                if(indegree[it]==0)q.push(it);\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735386,
                "title": "dfs-approach-c",
                "content": "# Intuition and approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have used the approach where graph is directed a->b such that b is richer than a. We have to find all the nodes which are richer than the current node and store the answer in answer vector where answer[i] = -1 indicates that there has been no answer filled.\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(vector<vector<int>>& graph,int node,vector<int>& quiet,vector<int>& answer)\\n    {\\n        if(answer[node] == -1)\\n        {\\n            answer[node] = node; //Initializing the answer of the node by the node itself as for nodes which have no nodes greater than it (no children), node itself is the answer.\\n            for(int i=0;i<graph[node].size();i++)\\n            {\\n                dfs(graph,graph[node][i],quiet,answer);\\n                if(quiet[answer[node]] > quiet[answer[graph[node][i]]])\\n                {\\n                    answer[node] = answer[graph[node][i]]; //comparing all the answers from child nodes( nodes which are richer ).\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>>graph(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            graph[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<int>answer(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(answer[i] == -1)\\n            {\\n                dfs(graph,i,quiet,answer);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(vector<vector<int>>& graph,int node,vector<int>& quiet,vector<int>& answer)\\n    {\\n        if(answer[node] == -1)\\n        {\\n            answer[node] = node; //Initializing the answer of the node by the node itself as for nodes which have no nodes greater than it (no children), node itself is the answer.\\n            for(int i=0;i<graph[node].size();i++)\\n            {\\n                dfs(graph,graph[node][i],quiet,answer);\\n                if(quiet[answer[node]] > quiet[answer[graph[node][i]]])\\n                {\\n                    answer[node] = answer[graph[node][i]]; //comparing all the answers from child nodes( nodes which are richer ).\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>>graph(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            graph[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<int>answer(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(answer[i] == -1)\\n            {\\n                dfs(graph,i,quiet,answer);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709712,
                "title": "toposort-bfs-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n    int v=quiet.size();\\n    vector<int>adj[v];\\n    vector<int>ans(v,INT_MAX);\\n    for(int i=0;i<richer.size();i++)\\n    {\\n        int s=richer[i][0];\\n        int t=richer[i][1];\\n        adj[s].push_back(t);\\n\\n    }\\n\\n    //vector<int>vis(v,0);\\n    vector<int>indegree(v,0);\\n    queue<int>q;\\n    for(int i=0;i<v;i++)\\n    {\\n        for(auto it:adj[i])\\n        {\\n            indegree[it]++;\\n        }\\n    }\\n    for(int i=0;i<v;i++)\\n    {\\n        ans[i]=i;\\n        if(indegree[i]==0)\\n        {\\n              q.push(i);\\n        }\\n    }\\n    vector<int>topo;\\n    while(!q.empty())\\n    {\\n        int node=q.front();\\n        q.pop();\\n       // topo.push_back(node);\\n        for(auto it:adj[node])\\n        {\\n            if(ans[it]==INT_MAX||quiet[ans[it]]>quiet[ans[node]])\\n            {\\n                ans[it]=ans[node];\\n            }\\n            indegree[it]--;\\n            if(indegree[it]==0)\\n            {\\n                q.push(it);\\n            }\\n        }\\n    }\\n    return ans;\\n    \\n        \\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n    int v=quiet.size();\\n    vector<int>adj[v];\\n    vector<int>ans(v,INT_MAX);\\n    for(int i=0;i<richer.size();i++)\\n    {\\n        int s=richer[i][0];\\n        int t=richer[i][1];\\n        adj[s].push_back(t);\\n\\n    }\\n\\n    //vector<int>vis(v,0);\\n    vector<int>indegree(v,0);\\n    queue<int>q;\\n    for(int i=0;i<v;i++)\\n    {\\n        for(auto it:adj[i])\\n        {\\n            indegree[it]++;\\n        }\\n    }\\n    for(int i=0;i<v;i++)\\n    {\\n        ans[i]=i;\\n        if(indegree[i]==0)\\n        {\\n              q.push(i);\\n        }\\n    }\\n    vector<int>topo;\\n    while(!q.empty())\\n    {\\n        int node=q.front();\\n        q.pop();\\n       // topo.push_back(node);\\n        for(auto it:adj[node])\\n        {\\n            if(ans[it]==INT_MAX||quiet[ans[it]]>quiet[ans[node]])\\n            {\\n                ans[it]=ans[node];\\n            }\\n            indegree[it]--;\\n            if(indegree[it]==0)\\n            {\\n                q.push(it);\\n            }\\n        }\\n    }\\n    return ans;\\n    \\n        \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703000,
                "title": "c-clean-code-graph-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int t(int i,vector<vector<int>>& v,vector<int>& q,vector<int>& dp)\\n    {\\n        if(dp[i]!=-1) return dp[i];\\n        int m=q[i];\\n        for(auto j : v[i])\\n          m=min(m,t(j,v,q,dp));\\n        \\n        return dp[i]=m;\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        vector<vector<int>> v(q.size());\\n        for(auto i : r)\\n        v[i[1]].push_back(i[0]);\\n\\n        map<int,int> p;\\n        for(int i=0;i<q.size();i++)\\n        p[q[i]]=i;\\n\\n        vector<int> dp(q.size(),-1);\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++)\\n        ans.push_back(p[t(i,v,q,dp)]);\\n          \\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t(int i,vector<vector<int>>& v,vector<int>& q,vector<int>& dp)\\n    {\\n        if(dp[i]!=-1) return dp[i];\\n        int m=q[i];\\n        for(auto j : v[i])\\n          m=min(m,t(j,v,q,dp));\\n        \\n        return dp[i]=m;\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        vector<vector<int>> v(q.size());\\n        for(auto i : r)\\n        v[i[1]].push_back(i[0]);\\n\\n        map<int,int> p;\\n        for(int i=0;i<q.size();i++)\\n        p[q[i]]=i;\\n\\n        vector<int> dp(q.size(),-1);\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++)\\n        ans.push_back(p[t(i,v,q,dp)]);\\n          \\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698936,
                "title": "easy-dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    int dfs(int node, vector<int> adj[], vector<int>& quiet, vector<int> &vis ){\\n        if(vis[node]!=0)return ans[node];\\n\\n        vis[node]=1;\\n        ans[node]=quiet[node];\\n        for(auto child : adj[node]){\\n            ans[node] = min(ans[node], dfs(child, adj, quiet, vis));\\n        }\\n        return ans[node];\\n\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n\\n        vector<int> adj[n];\\n        for(auto r:richer){\\n            adj[r[1]].push_back(r[0]);\\n        }\\n        ans.resize(n);\\n        vector<int> vis(n, 0);\\n        for(int i=0; i<n; i++){\\n            if(vis[i]==0){\\n                dfs(i, adj, quiet, vis);\\n            }\\n        }\\n        unordered_map<int , int> mp;\\n        for(int i = 0; i<n; i++){\\n            mp[quiet[i]]=i;\\n        }\\n        for(int i=0; i<n; i++){\\n            ans[i]=mp[ans[i]];\\n\\n        }\\n        return ans;\\n        // return vis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    int dfs(int node, vector<int> adj[], vector<int>& quiet, vector<int> &vis ){\\n        if(vis[node]!=0)return ans[node];\\n\\n        vis[node]=1;\\n        ans[node]=quiet[node];\\n        for(auto child : adj[node]){\\n            ans[node] = min(ans[node], dfs(child, adj, quiet, vis));\\n        }\\n        return ans[node];\\n\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n\\n        vector<int> adj[n];\\n        for(auto r:richer){\\n            adj[r[1]].push_back(r[0]);\\n        }\\n        ans.resize(n);\\n        vector<int> vis(n, 0);\\n        for(int i=0; i<n; i++){\\n            if(vis[i]==0){\\n                dfs(i, adj, quiet, vis);\\n            }\\n        }\\n        unordered_map<int , int> mp;\\n        for(int i = 0; i<n; i++){\\n            mp[quiet[i]]=i;\\n        }\\n        for(int i=0; i<n; i++){\\n            ans[i]=mp[ans[i]];\\n\\n        }\\n        return ans;\\n        // return vis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687928,
                "title": "c-dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int node, vector<int> &quiet, vector<vector<int>> &adj, map<int, int> &mp){\\n        if(mp[node]) return mp[node];\\n        int ans = node;\\n        for(auto it : adj[node]){\\n            int x = dfs(it, quiet, adj, mp);\\n            if(quiet[ans] >= quiet[x]) ans = x;\\n        }\\n        mp[node] = ans;\\n        return ans;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> adj(n);\\n        for(auto it : richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans;\\n        map<int, int> mp;\\n        for(int i = 0; i < n; i++){\\n            if(adj[i].size()) ans.push_back(dfs(i, quiet, adj, mp));\\n            else ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node, vector<int> &quiet, vector<vector<int>> &adj, map<int, int> &mp){\\n        if(mp[node]) return mp[node];\\n        int ans = node;\\n        for(auto it : adj[node]){\\n            int x = dfs(it, quiet, adj, mp);\\n            if(quiet[ans] >= quiet[x]) ans = x;\\n        }\\n        mp[node] = ans;\\n        return ans;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> adj(n);\\n        for(auto it : richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans;\\n        map<int, int> mp;\\n        for(int i = 0; i < n; i++){\\n            if(adj[i].size()) ans.push_back(dfs(i, quiet, adj, mp));\\n            else ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686258,
                "title": "kahn-s-algorithm-efficient-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n\\n        vector<vector<int>> adj(quiet.size());\\n        vector<int> indegree(quiet.size(),0);\\n        //create adjacency list\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            adj[richer[i][0]].push_back(richer[i][1]);\\n            indegree[richer[i][1]]++;\\n        }\\n        //all quiteness will be measured with int max initially for cases if there is no relation of richness given\\n        vector<int> ans(quiet.size(),INT_MAX);\\n        queue<int> q;\\n        for(int i=0;i<quiet.size();i++)\\n        {  \\n            ans[i]=i;//as that number will definately be equal in terms of richness\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n\\n        while(!q.empty())\\n        {\\n            int cur=q.front();\\n            // toposorted.push_back(cur);            \\n            q.pop();\\n\\n            for(auto it:adj[cur])\\n            {\\n                if(ans[it]==INT_MAX|| quiet[ans[it]]>quiet[ans[cur]])   ans[it]=ans[cur];\\n                indegree[it]--;\\n                if(indegree[it]==0) q.push(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n\\n        vector<vector<int>> adj(quiet.size());\\n        vector<int> indegree(quiet.size(),0);\\n        //create adjacency list\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            adj[richer[i][0]].push_back(richer[i][1]);\\n            indegree[richer[i][1]]++;\\n        }\\n        //all quiteness will be measured with int max initially for cases if there is no relation of richness given\\n        vector<int> ans(quiet.size(),INT_MAX);\\n        queue<int> q;\\n        for(int i=0;i<quiet.size();i++)\\n        {  \\n            ans[i]=i;//as that number will definately be equal in terms of richness\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n\\n        while(!q.empty())\\n        {\\n            int cur=q.front();\\n            // toposorted.push_back(cur);            \\n            q.pop();\\n\\n            for(auto it:adj[cur])\\n            {\\n                if(ans[it]==INT_MAX|| quiet[ans[it]]>quiet[ans[cur]])   ans[it]=ans[cur];\\n                indegree[it]--;\\n                if(indegree[it]==0) q.push(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676738,
                "title": "java-solution-topologicalsort",
                "content": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        List<List<Integer>> lt = new ArrayList<>();\\n        int[] inDegree = new int[quiet.length];\\n        int[] ans = new int[quiet.length];\\n        Queue<Integer> q = new LinkedList<>();\\n        int  min = Integer.MAX_VALUE;\\n        for(int i=0; i<quiet.length; i++){\\n            lt.add(new ArrayList<>());\\n        }\\n        \\n        for( int[] arr : richer){\\n            lt.get(arr[0]).add(arr[1]);\\n            inDegree[arr[1]]++;\\n        }\\n        int z=1;\\n        for(int i=0; i<quiet.length; i++){\\n            ans[i] = i;\\n            if(inDegree[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        while( !q.isEmpty() ){\\n            int node = q.poll();\\n            \\n            for( int n : lt.get(node)){\\n                inDegree[n]--;\\n                if( quiet[ans[node]] < quiet[ans[n]]  ){\\n                     ans[n] = ans[node];\\n                }\\n                if( inDegree[n] == 0 )\\n                    q.add(n);\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "class Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        List<List<Integer>> lt = new ArrayList<>();\\n        int[] inDegree = new int[quiet.length];\\n        int[] ans = new int[quiet.length];\\n        Queue<Integer> q = new LinkedList<>();\\n        int  min = Integer.MAX_VALUE;\\n        for(int i=0; i<quiet.length; i++){\\n            lt.add(new ArrayList<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3647050,
                "title": "python-dfs-solution-direct-checking-without-return-value",
                "content": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        \\n        \"\"\"\\n        0->1->2\\n         ->1->3->4  \\n         ->7->3->5\\n              3->6\\n        \"\"\"\\n        answer = []\\n        visited = set() \\n        graph = collections.defaultdict(list)\\n        def prepareGraph():\\n            \\n            for richEntry in richer:\\n                graph[richEntry[1]].append(richEntry[0])\\n        \\n        def dfs(node):\\n            \\n            visited.add(node)\\n            \\n            for entry in graph[node]:\\n                if entry not in visited:\\n                    dfs(entry)\\n                # while calling dfs, comparing the child node to the root node and replace if quiteness is minimum\\n                if quiet[answer[entry]]< quiet[answer[node]]:\\n                    answer[node] = answer[entry]\\n        \\n        prepareGraph()\\n        answer = [i for i in range(len(quiet))]\\n        \\n        for key in range(len(quiet)):\\n            dfs(key)\\n        return answer\\n            \\n            \\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        \\n        \"\"\"\\n        0->1->2\\n         ->1->3->4  \\n         ->7->3->5\\n              3->6\\n        \"\"\"\\n        answer = []\\n        visited = set() \\n        graph = collections.defaultdict(list)\\n        def prepareGraph():\\n            \\n            for richEntry in richer:\\n                graph[richEntry[1]].append(richEntry[0])\\n        \\n        def dfs(node):\\n            \\n            visited.add(node)\\n            \\n            for entry in graph[node]:\\n                if entry not in visited:\\n                    dfs(entry)\\n                # while calling dfs, comparing the child node to the root node and replace if quiteness is minimum\\n                if quiet[answer[entry]]< quiet[answer[node]]:\\n                    answer[node] = answer[entry]\\n        \\n        prepareGraph()\\n        answer = [i for i in range(len(quiet))]\\n        \\n        for key in range(len(quiet)):\\n            dfs(key)\\n        return answer\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642897,
                "title": "c-solution-dfs-based",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int src , vector<int> adj[] , unordered_map<int,int>&mp , vector<int>&answer , vector<int>& quiet)\\n    {\\n        if(answer[src] != -1) return quiet[answer[src]];\\n\\n        if(adj[src].size() == 0)\\n        {\\n            answer[src] = src;\\n            return quiet[src];\\n        }\\n        int result = quiet[src];\\n        for(auto node : adj[src])\\n        {\\n            result = min(result , dfs(node , adj , mp , answer , quiet));\\n        }\\n        answer[src] = mp[result];\\n        return result;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n         int n = quiet.size();\\n         unordered_map<int , int> mp;\\n         for(int i = 0 ; i < quiet.size() ; i++)mp[quiet[i]] = i;\\n         vector<int> adj[n];\\n         for(int i = 0 ; i < richer.size() ; i++)\\n         {\\n             int u = richer[i][0];\\n             int v = richer[i][1];\\n\\n             adj[v].push_back(u);\\n         }\\n         vector<int> answer(n , -1);\\n         for(int i = 0 ; i < n ; i++)\\n         {\\n             if(answer[i] == -1)\\n             {\\n                 dfs(i , adj , mp , answer , quiet);\\n             }\\n         }\\n         return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int src , vector<int> adj[] , unordered_map<int,int>&mp , vector<int>&answer , vector<int>& quiet)\\n    {\\n        if(answer[src] != -1) return quiet[answer[src]];\\n\\n        if(adj[src].size() == 0)\\n        {\\n            answer[src] = src;\\n            return quiet[src];\\n        }\\n        int result = quiet[src];\\n        for(auto node : adj[src])\\n        {\\n            result = min(result , dfs(node , adj , mp , answer , quiet));\\n        }\\n        answer[src] = mp[result];\\n        return result;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n         int n = quiet.size();\\n         unordered_map<int , int> mp;\\n         for(int i = 0 ; i < quiet.size() ; i++)mp[quiet[i]] = i;\\n         vector<int> adj[n];\\n         for(int i = 0 ; i < richer.size() ; i++)\\n         {\\n             int u = richer[i][0];\\n             int v = richer[i][1];\\n\\n             adj[v].push_back(u);\\n         }\\n         vector<int> answer(n , -1);\\n         for(int i = 0 ; i < n ; i++)\\n         {\\n             if(answer[i] == -1)\\n             {\\n                 dfs(i , adj , mp , answer , quiet);\\n             }\\n         }\\n         return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621677,
                "title": "similar-to-bellman-ford-algo-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can think it as a graph with richer as edges vector. \\n\\n# Approach\\nI thought of solving it similar to bellman ford algorithm which is used to calculate the shortest path. Update the quiet matrix and maintain another matrix \"ans\" whenever some update happens.\\n\\n# Complexity\\n- Time complexity:\\nO(n.m) , where n is total number of peoples(vertex) and m is size of richer.(edges) \\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size() ;\\n        vector<int> ans(n) ;\\n        for(int i=0;i<n;i++) ans[i] = i ;  \\n        for(int i=0 ;i<n ; i++){\\n            bool change = false;  \\n            for(auto e : richer){\\n                if(quiet[e[0]] < quiet[e[1]]){\\n                    quiet[e[1]] = quiet[e[0]] ;\\n                    ans[e[1]] = ans[e[0]] ; \\n                    change = true ; \\n                }\\n            }\\n            if(change == false) break;  \\n        }\\n\\n        return ans ; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size() ;\\n        vector<int> ans(n) ;\\n        for(int i=0;i<n;i++) ans[i] = i ;  \\n        for(int i=0 ;i<n ; i++){\\n            bool change = false;  \\n            for(auto e : richer){\\n                if(quiet[e[0]] < quiet[e[1]]){\\n                    quiet[e[1]] = quiet[e[0]] ;\\n                    ans[e[1]] = ans[e[0]] ; \\n                    change = true ; \\n                }\\n            }\\n            if(change == false) break;  \\n        }\\n\\n        return ans ; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619701,
                "title": "bfs-t-o-m-n-s-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        //cc \\n        if (richer == null) return new int[0];\\n\\n        int n = quiet.length;\\n        int[] res = new int[n];\\n\\n        // richer and more quiet people add to the result\\n\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        int[] indeg = new int[n];\\n\\n        for (int[] rich : richer) {\\n            graph.get(rich[0]).add(rich[1]);\\n            indeg[rich[1]]++;\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (indeg[i] == 0) queue.offer(i);\\n            res[i] = i;\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll(); //richer\\n\\n            for (int next : graph.get(curr)) {\\n                indeg[next]--;\\n\\n                if (quiet[res[next]] > quiet[res[curr]]) {\\n                    res[next] = res[curr];\\n                }\\n\\n                if (indeg[next] == 0) queue.offer(next);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n//T:O(m + n) S:O(m + n)\\n// n -- number of people\\n// m -- number of richer people\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        //cc \\n        if (richer == null) return new int[0];\\n\\n        int n = quiet.length;\\n        int[] res = new int[n];\\n\\n        // richer and more quiet people add to the result\\n\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        int[] indeg = new int[n];\\n\\n        for (int[] rich : richer) {\\n            graph.get(rich[0]).add(rich[1]);\\n            indeg[rich[1]]++;\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (indeg[i] == 0) queue.offer(i);\\n            res[i] = i;\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll(); //richer\\n\\n            for (int next : graph.get(curr)) {\\n                indeg[next]--;\\n\\n                if (quiet[res[next]] > quiet[res[curr]]) {\\n                    res[next] = res[curr];\\n                }\\n\\n                if (indeg[next] == 0) queue.offer(next);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n//T:O(m + n) S:O(m + n)\\n// n -- number of people\\n// m -- number of richer people\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618082,
                "title": "indegree-dfs-best-and-most-intuitive-solution-imp-general-trick-discussed",
                "content": "If indegree of any node is zero , it means they are the richest among the people they are connected to. To the people they are not connected to , we cannot say anything so their quiet values are their quiet values themselves. \\nFor the people who do not have indegree zero , we reverse the edges so that their indegree becomes zero and we do a dfs. After the dfs , the nodes they can reach are the people who are richer than them. Hence we have solved the problem\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(int node , vector<int> &a , map<int,bool> &vis , map<int,vector<int>> &m_rev)\\n    {\\n        vis[node] = true;\\n        a.push_back(node);\\n        for(auto it : m_rev[node])\\n        {\\n            if(vis[it]!=true) solve(it,a,vis,m_rev);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int> ans(quiet.size() , -1);   \\n        map<int,vector<int>> m;\\n        map<int,vector<int>> m_rev;\\n        for(int i = 0 ; i < richer.size() ; i++)\\n        {\\n            m[richer[i][0]].push_back(richer[i][1]);\\n            m_rev[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        \\n        vector<int> indegree(quiet.size() , 0);\\n        for(auto it : m)\\n        {\\n            for(auto it1 : it.second) indegree[it1]++;\\n        }\\n        \\n        for(int i = 0 ; i < indegree.size() ; i++)\\n        {\\n            if(indegree[i]==0) ans[i] = i;\\n        }\\n        vector<int> a;\\n        map<int,bool> vis;\\n        for(int i = 0 ; i < indegree.size() ; i++)\\n        {\\n            if(indegree[i]!=0)\\n            {\\n                solve(i,a,vis,m_rev);\\n                int temp_ans = 0;\\n                int mine = INT_MAX;\\n                for(int i = 0 ; i < a.size() ; i++)\\n                {\\n                    if(mine > quiet[a[i]])\\n                    {\\n                        mine = quiet[a[i]];\\n                        temp_ans = a[i];\\n                    }\\n                }\\n                ans[i] = temp_ans;\\n                a.clear();\\n                vis.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(int node , vector<int> &a , map<int,bool> &vis , map<int,vector<int>> &m_rev)\\n    {\\n        vis[node] = true;\\n        a.push_back(node);\\n        for(auto it : m_rev[node])\\n        {\\n            if(vis[it]!=true) solve(it,a,vis,m_rev);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int> ans(quiet.size() , -1);   \\n        map<int,vector<int>> m;\\n        map<int,vector<int>> m_rev;\\n        for(int i = 0 ; i < richer.size() ; i++)\\n        {\\n            m[richer[i][0]].push_back(richer[i][1]);\\n            m_rev[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        \\n        vector<int> indegree(quiet.size() , 0);\\n        for(auto it : m)\\n        {\\n            for(auto it1 : it.second) indegree[it1]++;\\n        }\\n        \\n        for(int i = 0 ; i < indegree.size() ; i++)\\n        {\\n            if(indegree[i]==0) ans[i] = i;\\n        }\\n        vector<int> a;\\n        map<int,bool> vis;\\n        for(int i = 0 ; i < indegree.size() ; i++)\\n        {\\n            if(indegree[i]!=0)\\n            {\\n                solve(i,a,vis,m_rev);\\n                int temp_ans = 0;\\n                int mine = INT_MAX;\\n                for(int i = 0 ; i < a.size() ; i++)\\n                {\\n                    if(mine > quiet[a[i]])\\n                    {\\n                        mine = quiet[a[i]];\\n                        temp_ans = a[i];\\n                    }\\n                }\\n                ans[i] = temp_ans;\\n                a.clear();\\n                vis.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602316,
                "title": "very-easy-code-bfs-kahn-s-algo-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> adj[n];\\n        vector<int> indegree(n,0);\\n        for(auto v:richer){\\n            adj[v[0]].push_back(v[1]); // v[0] -> v[1] => indegree is for v[1]\\n            indegree[v[1]]++;\\n        }\\n        queue<int> q;\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)\\n            q.push(i);\\n            ans[i]=i;\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto child:adj[node]){\\n                if(quiet[node]<quiet[child]){ // if child quiet is less than parent quiet then update quiet arr of child and also update the ans arr value \\n                    quiet[child]=quiet[node];\\n                    ans[child]=ans[node];\\n                }\\n                indegree[child]--;\\n                if(indegree[child]==0)\\n                q.push(child);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> adj[n];\\n        vector<int> indegree(n,0);\\n        for(auto v:richer){\\n            adj[v[0]].push_back(v[1]); // v[0] -> v[1] => indegree is for v[1]\\n            indegree[v[1]]++;\\n        }\\n        queue<int> q;\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)\\n            q.push(i);\\n            ans[i]=i;\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto child:adj[node]){\\n                if(quiet[node]<quiet[child]){ // if child quiet is less than parent quiet then update quiet arr of child and also update the ans arr value \\n                    quiet[child]=quiet[node];\\n                    ans[child]=ans[node];\\n                }\\n                indegree[child]--;\\n                if(indegree[child]==0)\\n                q.push(child);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588246,
                "title": "dfs-solution-explained",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code starts by building an adjacency list representation of the richer relationships. Each person is represented as a node, and an edge exists between two nodes if the person corresponding to the destination node is richer than the person corresponding to the source node.\\n\\n2. The code initializes an answer array with -1. This array will store the answer for each person, representing the least quiet person among all the people who definitely have equal to or more money than that person.\\n\\n3. The code defines a depth-first search (DFS) function called dfs. This function takes a person node, the adjacency list, the quietness array, and the answer array as parameters.\\n\\n4. Within the dfs function, the code checks if the answer for the current person node is already computed. If so, it returns the cached answer.\\n\\n5. Otherwise, the code initializes the answer for the current person node with the node itself.\\n\\n6. The code then iterates over all the neighbors of the current person node in the adjacency list and recursively calls the dfs function for each neighbor.\\n\\n7. For each neighbor, the code checks if the quietness of the candidate person is lower than the quietness of the current answer for the node. If so, it updates the answer with the candidate person, representing a quieter person who definitely has equal to or more money.\\n\\n8. Finally, the dfs function returns the answer for the current person node.\\n\\n9. The main function loudAndRich iterates over all the person nodes and calls the dfs function for each person to compute the answer.\\n\\n10. The resulting answer array is returned as the output.\\n\\nIn summary, the code uses a depth-first search (DFS) approach to traverse the richer relationships between people and find the least quiet person among all the people who definitely have equal to or more money. The answer for each person is cached to avoid redundant computations.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n   int dfs(int node, vector<vector<int>>& graph, vector<int>& quiet, vector<int>& answer) {\\n    if (answer[node] >= 0) {\\n        return answer[node]; // Return the cached answer if available\\n    }\\n    \\n    answer[node] = node; // Initialize the answer with the current node\\n    \\n    for (int neighbor : graph[node]) {\\n        int candidate = dfs(neighbor, graph, quiet, answer); // Recursive DFS call\\n        \\n        if (quiet[candidate] < quiet[answer[node]]) {\\n            answer[node] = candidate; // Update the answer if a quieter person is found\\n        }\\n    }\\n    \\n    return answer[node];\\n}\\n\\nvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n    int n = quiet.size();\\n    \\n    // Build the adjacency list\\n    vector<vector<int>> graph(n);\\n    for (const vector<int>& edge : richer) {\\n        graph[edge[1]].push_back(edge[0]);\\n    }\\n    \\n    // Initialize the answer array with -1\\n    vector<int> answer(n, -1);\\n    \\n    // Perform a depth-first search (DFS) for each person\\n    for (int i = 0; i < n; i++) {\\n        dfs(i, graph, quiet, answer);\\n    }\\n    \\n    return answer;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n   int dfs(int node, vector<vector<int>>& graph, vector<int>& quiet, vector<int>& answer) {\\n    if (answer[node] >= 0) {\\n        return answer[node]; // Return the cached answer if available\\n    }\\n    \\n    answer[node] = node; // Initialize the answer with the current node\\n    \\n    for (int neighbor : graph[node]) {\\n        int candidate = dfs(neighbor, graph, quiet, answer); // Recursive DFS call\\n        \\n        if (quiet[candidate] < quiet[answer[node]]) {\\n            answer[node] = candidate; // Update the answer if a quieter person is found\\n        }\\n    }\\n    \\n    return answer[node];\\n}\\n\\nvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n    int n = quiet.size();\\n    \\n    // Build the adjacency list\\n    vector<vector<int>> graph(n);\\n    for (const vector<int>& edge : richer) {\\n        graph[edge[1]].push_back(edge[0]);\\n    }\\n    \\n    // Initialize the answer array with -1\\n    vector<int> answer(n, -1);\\n    \\n    // Perform a depth-first search (DFS) for each person\\n    for (int i = 0; i < n; i++) {\\n        dfs(i, graph, quiet, answer);\\n    }\\n    \\n    return answer;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583845,
                "title": "simple-c-dfs-solution-by-sorting-the-quiet-array-o-n-tc",
                "content": "O(N) TC DFS solution.\\n\\ncreating a directed graph. with richer => less richer\\n\\nfor all guys we are traversing the graph and changing the minQuiet guy.\\n\\nWith a help of set we can sort quieter guys.\\n\\nand as we going from least quiet guy to louder guy we don\\'t traverse again and again. check traverse() method for more clarification\\n\\nif we encounter a guy that is more quiet than me that means all his subordinates also will have same value(minQ guy will be useless)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void traverse(vector<vector<int>>& graph,int guy,vector<int> &ans,int minQ,vector<int>& quiet){\\n        \\n        if(ans[guy]!=-1&&quiet[ans[guy]]<=quiet[minQ])return;\\n        if(quiet[guy]<quiet[minQ])minQ = guy;\\n\\n        if(ans[guy]==-1||quiet[minQ]<quiet[ans[guy]])ans[guy] = minQ;\\n\\n        for(auto nextGuy: graph[guy]){\\n            traverse(graph,nextGuy,ans,minQ,quiet);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        // make a graph and it will be a tree.\\n        // richest person at top and follows\\n        // make a directed graph\\n        // run dfs and carry the quiter guy \\n\\n        int guys = quiet.size();\\n        vector<vector<int>> graph(guys);\\n        //no need to maintain visited array as it is directed graph and there is no cycle\\n        //x > y and y > z then x > z definetely not z > x (therefore no cycles)\\n\\n        for(int ind = 0; ind < richer.size(); ind++){\\n            int guy1 = richer[ind][0];\\n            int guy2 = richer[ind][1];\\n\\n            graph[guy1].push_back(guy2);\\n        }\\n\\n        vector<int> ans(guys,-1);\\n        set<pair<int,int>> sguys;\\n        for(int ind = 0; ind < guys; ind++){\\n            sguys.insert({quiet[ind],ind});\\n        }\\n        for(auto guy: sguys){\\n            traverse(graph,guy.second,ans,guy.second,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void traverse(vector<vector<int>>& graph,int guy,vector<int> &ans,int minQ,vector<int>& quiet){\\n        \\n        if(ans[guy]!=-1&&quiet[ans[guy]]<=quiet[minQ])return;\\n        if(quiet[guy]<quiet[minQ])minQ = guy;\\n\\n        if(ans[guy]==-1||quiet[minQ]<quiet[ans[guy]])ans[guy] = minQ;\\n\\n        for(auto nextGuy: graph[guy]){\\n            traverse(graph,nextGuy,ans,minQ,quiet);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        // make a graph and it will be a tree.\\n        // richest person at top and follows\\n        // make a directed graph\\n        // run dfs and carry the quiter guy \\n\\n        int guys = quiet.size();\\n        vector<vector<int>> graph(guys);\\n        //no need to maintain visited array as it is directed graph and there is no cycle\\n        //x > y and y > z then x > z definetely not z > x (therefore no cycles)\\n\\n        for(int ind = 0; ind < richer.size(); ind++){\\n            int guy1 = richer[ind][0];\\n            int guy2 = richer[ind][1];\\n\\n            graph[guy1].push_back(guy2);\\n        }\\n\\n        vector<int> ans(guys,-1);\\n        set<pair<int,int>> sguys;\\n        for(int ind = 0; ind < guys; ind++){\\n            sguys.insert({quiet[ind],ind});\\n        }\\n        for(auto guy: sguys){\\n            traverse(graph,guy.second,ans,guy.second,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581251,
                "title": "solution-using-dfs-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int i, int parent, vector<int> &vis, vector<vector<int>> &edges, vector<vector<int>> &ansc)\\n    {\\n        vis[i]=1;\\n\\n        for(auto x: edges[i])\\n        {\\n            if(!vis[x])\\n            {\\n                dfs(x, parent, vis, edges, ansc);\\n            }\\n        }\\n\\n        if(i!=parent)\\n        {\\n            ansc[i].push_back(parent);\\n        }\\n\\n\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n= quiet.size();\\n        vector<int> ans(n);\\n        vector<vector<int>> edges(n), ansc(n);\\n\\n        for(auto x: richer)\\n        {   \\n            edges[x[0]].push_back(x[1]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {   \\n            vector<int>visited(n,0);\\n            dfs(i, i, visited, edges, ansc);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int mini= quiet[i]; int a=i;\\n            for(auto ele : ansc[i]){\\n                if(mini >= quiet[ele]){\\n                    a = ele;\\n                    mini = quiet[ele];\\n\\n        }\\n         \\n     }\\n      ans[i]=a;\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int i, int parent, vector<int> &vis, vector<vector<int>> &edges, vector<vector<int>> &ansc)\\n    {\\n        vis[i]=1;\\n\\n        for(auto x: edges[i])\\n        {\\n            if(!vis[x])\\n            {\\n                dfs(x, parent, vis, edges, ansc);\\n            }\\n        }\\n\\n        if(i!=parent)\\n        {\\n            ansc[i].push_back(parent);\\n        }\\n\\n\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n= quiet.size();\\n        vector<int> ans(n);\\n        vector<vector<int>> edges(n), ansc(n);\\n\\n        for(auto x: richer)\\n        {   \\n            edges[x[0]].push_back(x[1]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {   \\n            vector<int>visited(n,0);\\n            dfs(i, i, visited, edges, ansc);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int mini= quiet[i]; int a=i;\\n            for(auto ele : ansc[i]){\\n                if(mini >= quiet[ele]){\\n                    a = ele;\\n                    mini = quiet[ele];\\n\\n        }\\n         \\n     }\\n      ans[i]=a;\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566731,
                "title": "easy-explanation-with-detailed-approach-c-solution-using-bfs-topological-sort",
                "content": "# Intuition\\nFor any person, we look for all the person who is equally rich or richer than them and then we select the quietest among these set of richer people.\\n\\n# Approach\\nHere, we use **topological sort** to find the least quiet person among all people who definitely have equal to or more money than the person.\\n\\n![WhatsApp Image 2023-05-27 at 10.21.47.jpg](https://assets.leetcode.com/users/images/ea093f1d-efc2-4b18-af15-7828d17cd019_1685163806.2208238.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(V+E), since it is directed graph.\\n\\n- Space complexity:\\nO(3V)~O(V), since we have queue, indegree array and ans array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int>ans(n);\\n        vector<int>indeg(n,0);\\n        vector<int>adj[n];\\n\\n        for(auto it:richer){ \\n            //adjacentcy list for matrix richer\\n            adj[it[0]].push_back(it[1]);\\n            indeg[it[1]]++;\\n        }\\n\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            //assigning all ans[i] to i which will be updated later after comparision, we can also assign it to some negative number.\\n            ans[i]=i;\\n\\n            // for each i, if indegree is 0 push it into q;\\n            if(indeg[i]==0){\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n\\n            for(auto it:adj[node]){\\n                //comparing the values of adjacent node values and current node in quiet array and upadting it.\\n                if(quiet[ans[node]]<quiet[ans[it]]){\\n                    ans[it]=ans[node];\\n                }\\n                \\n                indeg[it]--;\\n                if(indeg[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int>ans(n);\\n        vector<int>indeg(n,0);\\n        vector<int>adj[n];\\n\\n        for(auto it:richer){ \\n            //adjacentcy list for matrix richer\\n            adj[it[0]].push_back(it[1]);\\n            indeg[it[1]]++;\\n        }\\n\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            //assigning all ans[i] to i which will be updated later after comparision, we can also assign it to some negative number.\\n            ans[i]=i;\\n\\n            // for each i, if indegree is 0 push it into q;\\n            if(indeg[i]==0){\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n\\n            for(auto it:adj[node]){\\n                //comparing the values of adjacent node values and current node in quiet array and upadting it.\\n                if(quiet[ans[node]]<quiet[ans[it]]){\\n                    ans[it]=ans[node];\\n                }\\n                \\n                indeg[it]--;\\n                if(indeg[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563107,
                "title": "dfs-dp-easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&adj,vector<int>& quiet,vector<int>&ans,int node,vector<int>&vis)\\n    {\\n        if(vis[node])return ans[node];\\n        vis[node]=1;\\n        int ind=node;\\n        for(auto it:adj[node])\\n        {\\n            int k=dfs(adj,quiet,ans,it,vis);\\n            if(quiet[ind]>quiet[k])ind=k;\\n        }\\n        return ans[node]=ind;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>>adj(n);\\n        for(auto it:richer)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>vis(n+1,0);\\n        vector<int>ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(adj,quiet,ans,i,vis);\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&adj,vector<int>& quiet,vector<int>&ans,int node,vector<int>&vis)\\n    {\\n        if(vis[node])return ans[node];\\n        vis[node]=1;\\n        int ind=node;\\n        for(auto it:adj[node])\\n        {\\n            int k=dfs(adj,quiet,ans,it,vis);\\n            if(quiet[ind]>quiet[k])ind=k;\\n        }\\n        return ans[node]=ind;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>>adj(n);\\n        for(auto it:richer)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>vis(n+1,0);\\n        vector<int>ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(adj,quiet,ans,i,vis);\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551153,
                "title": "java-dfs-solution-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int ans[] = new int[quiet.length];\\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\\n        for(int i=0;i<quiet.length;i++){\\n            list.add(new ArrayList<>());\\n            ans[i]=i;\\n        }\\n        for(int i=0;i<richer.length;i++){\\n            list.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        boolean vis[] = new boolean[quiet.length];\\n        for(int i=0;i<quiet.length;i++){\\n            if(vis[i]==false){\\n                dfs(i,list,vis,ans,quiet);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(int node ,ArrayList<ArrayList<Integer>> list ,boolean vis[] ,int ans[],int quiet[] ){\\n         vis[node]=true;\\n         for(int j:list.get(node)){\\n             if(vis[j]==false){\\n                 dfs(j,list,vis,ans,quiet);\\n                 if(quiet[node]>quiet[j]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }else{\\n                 if(quiet[j]<quiet[ans[node]]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }\\n         }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int ans[] = new int[quiet.length];\\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\\n        for(int i=0;i<quiet.length;i++){\\n            list.add(new ArrayList<>());\\n            ans[i]=i;\\n        }\\n        for(int i=0;i<richer.length;i++){\\n            list.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        boolean vis[] = new boolean[quiet.length];\\n        for(int i=0;i<quiet.length;i++){\\n            if(vis[i]==false){\\n                dfs(i,list,vis,ans,quiet);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(int node ,ArrayList<ArrayList<Integer>> list ,boolean vis[] ,int ans[],int quiet[] ){\\n         vis[node]=true;\\n         for(int j:list.get(node)){\\n             if(vis[j]==false){\\n                 dfs(j,list,vis,ans,quiet);\\n                 if(quiet[node]>quiet[j]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }else{\\n                 if(quiet[j]<quiet[ans[node]]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }\\n         }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530939,
                "title": "dfs-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& adj, vector<bool>& vis, int v, int& res, vector<int>& quiet){\\n        if(vis[v])\\n        return;\\n\\n        vis[v] =true;\\n        if(quiet[v] < quiet[res])\\n        {\\n            res = v;\\n        }\\n\\n        for(auto u : adj[v])\\n        {\\n            if(!vis[u])\\n            dfs(adj, vis, u, res, quiet);\\n        }\\n\\n        return;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> ans;\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n, false);\\n\\n        for(auto e : richer)\\n        {\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        int res ;\\n        for(int i=0; i<n; i++)\\n        {\\n            res = i;\\n           dfs(adj, vis,i, res, quiet );\\n           ans.push_back(res);\\n\\n           vis.assign(n, false);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& adj, vector<bool>& vis, int v, int& res, vector<int>& quiet){\\n        if(vis[v])\\n        return;\\n\\n        vis[v] =true;\\n        if(quiet[v] < quiet[res])\\n        {\\n            res = v;\\n        }\\n\\n        for(auto u : adj[v])\\n        {\\n            if(!vis[u])\\n            dfs(adj, vis, u, res, quiet);\\n        }\\n\\n        return;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> ans;\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n, false);\\n\\n        for(auto e : richer)\\n        {\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        int res ;\\n        for(int i=0; i<n; i++)\\n        {\\n            res = i;\\n           dfs(adj, vis,i, res, quiet );\\n           ans.push_back(res);\\n\\n           vis.assign(n, false);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528822,
                "title": "java",
                "content": "Take the lowest in topological orders (roots/poorest) and dfs from them up updating each node on the way, and on the way back from the recursion we update the poorer knowing already the quiet and richer amoung his topological father tree.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        List[] richerThanI = new  List[quiet.length], poorerThanI = new List[quiet.length];\\n        for (int i=0;i<quiet.length;i++)  {\\n            richerThanI[i]=new ArrayList<Integer>();\\n            poorerThanI[i]=new ArrayList<Integer>();\\n        }\\n        for (int[] edge: richer) {\\n            richerThanI[edge[1]].add(edge[0]);\\n            poorerThanI[edge[0]].add(edge[1]);\\n        }\\n\\n        int[] sol = new int [quiet.length];\\n\\n        Set<Integer> visited = new HashSet();\\n\\n        for (int i=0;i<quiet.length;i++) sol[i] = i;\\n\\n        for (int i=0;i<quiet.length;i++)\\n            if (poorerThanI[i].size() == 0) visitDfs(i, richerThanI ,sol, visited ,quiet);\\n        \\n        return sol;\\n    }\\n\\n    public void visitDfs(int poor, List[] richerThanI, int[] sol, Set<Integer> visited, int[] quiet){\\n        int min = poor;\\n        for (int richer: (List<Integer>) richerThanI[poor]) {\\n            if (!visited.contains(richer)) visitDfs(richer, richerThanI ,sol, visited ,quiet);\\n            if (quiet[sol[richer]]<quiet[min]) min = sol[richer];\\n        }\\n        visited.add(poor);\\n        sol[poor] = min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        List[] richerThanI = new  List[quiet.length], poorerThanI = new List[quiet.length];\\n        for (int i=0;i<quiet.length;i++)  {\\n            richerThanI[i]=new ArrayList<Integer>();\\n            poorerThanI[i]=new ArrayList<Integer>();\\n        }\\n        for (int[] edge: richer) {\\n            richerThanI[edge[1]].add(edge[0]);\\n            poorerThanI[edge[0]].add(edge[1]);\\n        }\\n\\n        int[] sol = new int [quiet.length];\\n\\n        Set<Integer> visited = new HashSet();\\n\\n        for (int i=0;i<quiet.length;i++) sol[i] = i;\\n\\n        for (int i=0;i<quiet.length;i++)\\n            if (poorerThanI[i].size() == 0) visitDfs(i, richerThanI ,sol, visited ,quiet);\\n        \\n        return sol;\\n    }\\n\\n    public void visitDfs(int poor, List[] richerThanI, int[] sol, Set<Integer> visited, int[] quiet){\\n        int min = poor;\\n        for (int richer: (List<Integer>) richerThanI[poor]) {\\n            if (!visited.contains(richer)) visitDfs(richer, richerThanI ,sol, visited ,quiet);\\n            if (quiet[sol[richer]]<quiet[min]) min = sol[richer];\\n        }\\n        visited.add(poor);\\n        sol[poor] = min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513653,
                "title": "c-topologicall-sorting-with-explanation",
                "content": "# Intuition\\nThe problem statement requires us to find the quietest person in the group who is richer than each person in the group. We can represent the relationships between people and their wealth as a directed graph, where each node represents a person and each edge represents a richer-than relationship.\\n\\nSince the graph is acyclic, we can use a topological sorting approach to traverse the graph and find the answer for each person. Our aim is to sort the people in their wealth and for every person in the group, we need to find the richest person that is quieter than them.\\n\\n# Approach\\nWe start by building a graph from the richer array, where an edge is directed from a richer person to a poorer person. We also count the indegree of each node in the graph.\\n\\nNext, we initialize the answer array to contain the index of each person. We then use a queue to perform a topological sort on the graph. We start by adding all nodes with an indegree of zero to the queue.\\n\\nAt each iteration, we remove a node from the queue and update the answer for each of its adjacent nodes. If the current person is quieter than the adjacent person\\'s current answer, the adjacent person\\'s answer is updated to the current person\\'s answer. Finally, the indegree of each adjacent node is decremented, and if it becomes zero, it is added to the queue.\\n\\nWe continue this process until the queue is empty, and the answer array contains the index of the quietest person that is richer than each person in the group.\\n\\n# Complexity\\nTime complexity: O(n + E), where n is the number of people and E is the number of edges in the graph. In the worst-case scenario, the number of edges can be n*(n-1)/2, which is O(n^2). However, in practice, the number of edges is likely to be much smaller.\\nSpace complexity: O(n), which is used to store the indegree and answer arrays.\\n\\nCode\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n);\\n        vector<int> answer(n);\\n        \\n        for (auto & edge: richer)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            indegree[edge[1]]++;\\n        }\\n\\n        for (int i = 0; i < n; i++) answer[i] = i;\\n        \\n        queue<int> Q;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (indegree[i] == 0)\\n                Q.push(i);\\n        }\\n\\n        while (!Q.empty())\\n        {\\n            int current = Q.front();\\n            Q.pop();\\n\\n            for (int adj : graph[current])\\n            {\\n                if (quiet[answer[current]] < quiet[answer[adj]])\\n                    answer[adj] = answer[current];\\n\\n                if (--indegree[adj] == 0)\\n                    Q.push(adj);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n);\\n        vector<int> answer(n);\\n        \\n        for (auto & edge: richer)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            indegree[edge[1]]++;\\n        }\\n\\n        for (int i = 0; i < n; i++) answer[i] = i;\\n        \\n        queue<int> Q;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (indegree[i] == 0)\\n                Q.push(i);\\n        }\\n\\n        while (!Q.empty())\\n        {\\n            int current = Q.front();\\n            Q.pop();\\n\\n            for (int adj : graph[current])\\n            {\\n                if (quiet[answer[current]] < quiet[answer[adj]])\\n                    answer[adj] = answer[current];\\n\\n                if (--indegree[adj] == 0)\\n                    Q.push(adj);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511077,
                "title": "c-solution-dfs-memoization-o-n-2",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(V+E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> g,vector<int>& quiet,vector<int>& result,int node){\\n        int x = node;\\n        for (int v : g[node]){\\n            if (result[v]!=-1){\\n                if (quiet[x] > quiet[result[v]])\\n                    x = result[v];\\n            }\\n            else{\\n                int y = dfs(g,quiet,result,v);\\n                if (quiet[x] > quiet[y])\\n                    x = y;\\n            }\\n        }\\n        return result[node] = x;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> g(n);\\n        for (auto r : richer)\\n            g[r[1]].push_back(r[0]);\\n        vector<int> result(n,-1);\\n        for (int i=0;i<n;i++){\\n            if (result[i]==-1)\\n                result[i] = dfs(g,quiet,result,i);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> g,vector<int>& quiet,vector<int>& result,int node){\\n        int x = node;\\n        for (int v : g[node]){\\n            if (result[v]!=-1){\\n                if (quiet[x] > quiet[result[v]])\\n                    x = result[v];\\n            }\\n            else{\\n                int y = dfs(g,quiet,result,v);\\n                if (quiet[x] > quiet[y])\\n                    x = y;\\n            }\\n        }\\n        return result[node] = x;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> g(n);\\n        for (auto r : richer)\\n            g[r[1]].push_back(r[0]);\\n        vector<int> result(n,-1);\\n        for (int i=0;i<n;i++){\\n            if (result[i]==-1)\\n                result[i] = dfs(g,quiet,result,i);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473721,
                "title": "dfs-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhard part: quiet[res[dfs(nei)]] < quiet[res[i]]\\n- res[i] is memo, it\\'s not i, i is the ith node, res[i] is the current lowest quiet node, it can be anyone, i is the parent of nei, dfs(nei) return a value of res[nei] is another node, if this is lower than res[i], then:\\nres[i] = res[nei]\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n, g = len(quiet), defaultdict(list)\\n        res = [-1] * n\\n        for rich, poor in richer:\\n            g[poor].append(rich)\\n\\n        def dfs(i):\\n            if res[i] != -1: \\n                return res[i]\\n            res[i] = i # first init i, then compare to find lower if possible\\n            for nei in g[i]:\\n                if quiet[res[dfs(nei)]] < quiet[res[i]]:\\n                    res[i] = res[nei]\\n            return res[i]\\n            \\n        for i in range(n):\\n            dfs(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n, g = len(quiet), defaultdict(list)\\n        res = [-1] * n\\n        for rich, poor in richer:\\n            g[poor].append(rich)\\n\\n        def dfs(i):\\n            if res[i] != -1: \\n                return res[i]\\n            res[i] = i # first init i, then compare to find lower if possible\\n            for nei in g[i]:\\n                if quiet[res[dfs(nei)]] < quiet[res[i]]:\\n                    res[i] = res[nei]\\n            return res[i]\\n            \\n        for i in range(n):\\n            dfs(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452821,
                "title": "kahn-s-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        \\n        int n = q.size();\\n        vector<vector<int>>adj(n);\\n        vector<int>ind(n, 0);\\n        for(auto it : r){\\n            adj[it[0]].push_back(it[1]);\\n            ind[it[1]]++;\\n        }\\n        queue<int>qu;\\n        vector<int>ans(n);\\n        for(int i = 0; i<n; i++){\\n            ans[i] = i;\\n            if(ind[i] == 0)\\n            qu.push(i);\\n        }\\n\\n\\n        while(!qu.empty()){\\n            int u = qu.front();\\n            qu.pop();\\n            for(auto v : adj[u]){\\n                if(q[ans[u]]  < q[ans[v]]){\\n                    ans[v] = ans[u];\\n                }\\n                --ind[v];\\n                if(ind[v] == 0)\\n                qu.push(v);\\n            }\\n        }\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        \\n        int n = q.size();\\n        vector<vector<int>>adj(n);\\n        vector<int>ind(n, 0);\\n        for(auto it : r){\\n            adj[it[0]].push_back(it[1]);\\n            ind[it[1]]++;\\n        }\\n        queue<int>qu;\\n        vector<int>ans(n);\\n        for(int i = 0; i<n; i++){\\n            ans[i] = i;\\n            if(ind[i] == 0)\\n            qu.push(i);\\n        }\\n\\n\\n        while(!qu.empty()){\\n            int u = qu.front();\\n            qu.pop();\\n            for(auto v : adj[u]){\\n                if(q[ans[u]]  < q[ans[v]]){\\n                    ans[v] = ans[u];\\n                }\\n                --ind[v];\\n                if(ind[v] == 0)\\n                qu.push(v);\\n            }\\n        }\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430268,
                "title": "topological-sorting-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nnodes will affect the results of their outgoing neighbors \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. count the in degrees of nodes\\n2. travel by tological order and update results\\n# Complexity\\n- Time complexity: $$O(m)$$ where $$m$$ is the number of edges\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m+n)$$ where $$n$$ is the number of vertices\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        unordered_map<int,vector<int>> e;\\n        unordered_map<int,int> ind;\\n        for(auto&v:richer){\\n            e[v[0]].emplace_back(v[1]);\\n            ind[v[1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            if(ind[i]) continue;\\n            q.push(i);\\n        }\\n        vector<int> result(n);\\n        iota(result.begin(),result.end(),0);\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto v:e[u]){\\n                if(quiet[result[u]]<quiet[result[v]]){\\n                    result[v]=result[u];\\n                }\\n                if(--ind[v]==0){\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        unordered_map<int,vector<int>> e;\\n        unordered_map<int,int> ind;\\n        for(auto&v:richer){\\n            e[v[0]].emplace_back(v[1]);\\n            ind[v[1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            if(ind[i]) continue;\\n            q.push(i);\\n        }\\n        vector<int> result(n);\\n        iota(result.begin(),result.end(),0);\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto v:e[u]){\\n                if(quiet[result[u]]<quiet[result[v]]){\\n                    result[v]=result[u];\\n                }\\n                if(--ind[v]==0){\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415644,
                "title": "java-easy-solution-with-dfs",
                "content": "# Approach\\nForming the adjacency list-\\nricher[i][0]----1\\nricher[i][1]----2\\nsince 1 is richer than 2 we can form a directed edge from 2 to 1\\nIn this way we can get the directed graph\\n\\nNow we can calculate the dfs traversal from each of the vertices and store the vertices traversed in an arraylist\\n\\nIf the arraylist is empty then we add the vertex itself to the ans array\\nelse\\nwe find out that number for which quiet[number] is the least, we add that number to the ans array\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        ArrayList<ArrayList<Integer>>l=new ArrayList<>();\\n        for(int i=0;i<quiet.length;i++)\\n        {\\n            l.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<richer.length;i++)\\n        {\\n            l.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        ArrayList<Integer>a=new ArrayList<>();\\n        int ans[]=new int[quiet.length];\\n        for(int i=0;i<quiet.length;i++)\\n        {\\n            a=new ArrayList<>();\\n            int v[]=new int[quiet.length];\\n            dfs(i,l,v,a);\\n            int min=i;\\n            //System.out.println(i+\" \"+a);\\n            \\n            if(a.isEmpty()==true)\\n            {\\n                ans[i]=i;\\n                continue;\\n            }\\n            for(int j=0;j<a.size();j++)\\n            {\\n                if(quiet[a.get(j)]<quiet[min])min=a.get(j);\\n            }\\n            ans[i]=min;\\n\\n        }\\n        return ans;\\n\\n    }\\n    public void dfs(int node,ArrayList<ArrayList<Integer>>l,int v[],ArrayList<Integer>a)\\n    {\\n        v[node]=1;\\n        for(Integer it:l.get(node))\\n        {\\n            if(v[it]==0)\\n            {\\n                a.add(it);\\n                dfs(it,l,v,a);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        ArrayList<ArrayList<Integer>>l=new ArrayList<>();\\n        for(int i=0;i<quiet.length;i++)\\n        {\\n            l.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<richer.length;i++)\\n        {\\n            l.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        ArrayList<Integer>a=new ArrayList<>();\\n        int ans[]=new int[quiet.length];\\n        for(int i=0;i<quiet.length;i++)\\n        {\\n            a=new ArrayList<>();\\n            int v[]=new int[quiet.length];\\n            dfs(i,l,v,a);\\n            int min=i;\\n            //System.out.println(i+\" \"+a);\\n            \\n            if(a.isEmpty()==true)\\n            {\\n                ans[i]=i;\\n                continue;\\n            }\\n            for(int j=0;j<a.size();j++)\\n            {\\n                if(quiet[a.get(j)]<quiet[min])min=a.get(j);\\n            }\\n            ans[i]=min;\\n\\n        }\\n        return ans;\\n\\n    }\\n    public void dfs(int node,ArrayList<ArrayList<Integer>>l,int v[],ArrayList<Integer>a)\\n    {\\n        v[node]=1;\\n        for(Integer it:l.get(node))\\n        {\\n            if(v[it]==0)\\n            {\\n                a.add(it);\\n                dfs(it,l,v,a);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405908,
                "title": "c-simple-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlet me clear you one thing guys here adjacent list has been created such that u->v edge is representing that u person is poorer than v\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(E+V)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(E+v) adjacency list + ans array\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int node,vector<vector<int>>& adj,vector<int>& ans,vector<int>& quiet){\\n    int res=node;\\n    int mini=quiet[node];\\n    for(int& i: adj[node]){\\n        if(ans[i]==-1){\\n            dfs(i,adj,ans,quiet);\\n        }\\n        if(mini>quiet[ans[i]]){\\n            mini=quiet[ans[i]];\\n            res=ans[i];\\n        }\\n    }\\n    ans[node]=res;\\n}\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>> adj(n);\\n        for(auto& ele: richer){\\n            adj[ele[1]].push_back(ele[0]);\\n        }\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(ans[i]==-1){\\n                dfs(i,adj,ans,quiet);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int node,vector<vector<int>>& adj,vector<int>& ans,vector<int>& quiet){\\n    int res=node;\\n    int mini=quiet[node];\\n    for(int& i: adj[node]){\\n        if(ans[i]==-1){\\n            dfs(i,adj,ans,quiet);\\n        }\\n        if(mini>quiet[ans[i]]){\\n            mini=quiet[ans[i]];\\n            res=ans[i];\\n        }\\n    }\\n    ans[node]=res;\\n}\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>> adj(n);\\n        for(auto& ele: richer){\\n            adj[ele[1]].push_back(ele[0]);\\n        }\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(ans[i]==-1){\\n                dfs(i,adj,ans,quiet);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400625,
                "title": "java-topo-sort-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a adjacentry matrix in such a that a node contains all the nodes whose quiet value \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnce you are done with adjacentry matrix than what can u do is u can create a ans array and for every index do a topos sort that will give u all the elements whose richer value is greater than than value than among those value find the one elements whose value is less than all other than place it return ans arrary .\\n\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution \\n{\\n\\n    public int[] loudAndRich(int[][] richer, int[] quiet) \\n    {\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n        int n=quiet.length;\\n        for(int i=0;i<n;i++)\\n        {\\n          adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<richer.length;i++)\\n        {\\n          adj.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        int ans[]=new int[n];\\n        Arrays.fill(ans,Integer.MAX_VALUE);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ans[i]==Integer.MAX_VALUE)\\n            {\\n             int vis[]=new int[n];\\n             Stack<Integer>stk=new Stack<Integer>();\\n             topo(i,adj,vis,stk);\\n             while(!stk.isEmpty())\\n             {\\n                 int node=stk.peek();\\n                 stk.pop();\\n                 if(ans[i]==Integer.MAX_VALUE)\\n                 {\\n                     ans[i]=node;\\n                 }\\n                 else if(quiet[node]<quiet[ans[i]])\\n                 {\\n                     ans[i]=node;\\n                 }\\n             }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    private void topo(int node,ArrayList<ArrayList<Integer>>adj,int vis[],Stack<Integer>stk)\\n    {\\n        vis[node]=1;\\n        for(int i:adj.get(node))\\n        {\\n            if(vis[i]==0)\\n             {\\n                 topo(i,adj,vis,stk);\\n             }\\n        }\\n        stk.push(node);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution \\n{\\n\\n    public int[] loudAndRich(int[][] richer, int[] quiet) \\n    {\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n        int n=quiet.length;\\n        for(int i=0;i<n;i++)\\n        {\\n          adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<richer.length;i++)\\n        {\\n          adj.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        int ans[]=new int[n];\\n        Arrays.fill(ans,Integer.MAX_VALUE);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ans[i]==Integer.MAX_VALUE)\\n            {\\n             int vis[]=new int[n];\\n             Stack<Integer>stk=new Stack<Integer>();\\n             topo(i,adj,vis,stk);\\n             while(!stk.isEmpty())\\n             {\\n                 int node=stk.peek();\\n                 stk.pop();\\n                 if(ans[i]==Integer.MAX_VALUE)\\n                 {\\n                     ans[i]=node;\\n                 }\\n                 else if(quiet[node]<quiet[ans[i]])\\n                 {\\n                     ans[i]=node;\\n                 }\\n             }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    private void topo(int node,ArrayList<ArrayList<Integer>>adj,int vis[],Stack<Integer>stk)\\n    {\\n        vis[node]=1;\\n        for(int i:adj.get(node))\\n        {\\n            if(vis[i]==0)\\n             {\\n                 topo(i,adj,vis,stk);\\n             }\\n        }\\n        stk.push(node);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380545,
                "title": "simple-solution-using-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>graph;\\n    void add_edge(int u,int v){graph[v].push_back(u);}\\n    void dfs(vector<bool>&vis,int i,vector<int>&temp)\\n    {\\n        vis[i]=true;\\n        for(auto x:graph[i])\\n        {\\n            if(vis[x]==false)\\n            {\\n                dfs(vis,x,temp);\\n            }\\n        }\\n        temp.push_back(i);\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        unordered_map<int,vector<int>>ans;\\n        for(int i=0;i<richer.size();i++) add_edge(richer[i][0],richer[i][1]);\\n        for(int i=0;i<quiet.size();i++)\\n        {\\n            vector<bool>vis(quiet.size(),false);\\n            vector<int>temp;\\n            dfs(vis,i,temp);\\n            ans[i]=temp;\\n            temp.clear();\\n        }\\n        vector<int>rslt(quiet.size());\\n        for(auto x:ans)\\n        {\\n            int mini=x.first;\\n            for(int i=0;i<x.second.size();i++)\\n            {\\n                if(quiet[mini]>quiet[x.second[i]])\\n                {\\n                    mini=x.second[i];\\n                }\\n            }\\n            rslt[x.first]=mini;\\n        }\\n        return rslt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>graph;\\n    void add_edge(int u,int v){graph[v].push_back(u);}\\n    void dfs(vector<bool>&vis,int i,vector<int>&temp)\\n    {\\n        vis[i]=true;\\n        for(auto x:graph[i])\\n        {\\n            if(vis[x]==false)\\n            {\\n                dfs(vis,x,temp);\\n            }\\n        }\\n        temp.push_back(i);\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        unordered_map<int,vector<int>>ans;\\n        for(int i=0;i<richer.size();i++) add_edge(richer[i][0],richer[i][1]);\\n        for(int i=0;i<quiet.size();i++)\\n        {\\n            vector<bool>vis(quiet.size(),false);\\n            vector<int>temp;\\n            dfs(vis,i,temp);\\n            ans[i]=temp;\\n            temp.clear();\\n        }\\n        vector<int>rslt(quiet.size());\\n        for(auto x:ans)\\n        {\\n            int mini=x.first;\\n            for(int i=0;i<x.second.size();i++)\\n            {\\n                if(quiet[mini]>quiet[x.second[i]])\\n                {\\n                    mini=x.second[i];\\n                }\\n            }\\n            rslt[x.first]=mini;\\n        }\\n        return rslt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379357,
                "title": "simple-memoization-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRight after looking the problem I knew that this was about DFS as we have to iterate all the nodes(people) which have more money. So, first of all ,I have created a graph where edges will be directed from poor person to rich which enables us to reach nodes which are only richer than the current one. I have used memoization to store node values which have least quiet value and more money that current node to avoid overlapping subproblems. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a graph (adjacency list) in which edges will be directed from poor person to richer. Then for each node traverse to richer nodes(i.e adjacent nodes) and find the node which has least quiet value in traversal. Store the node value instead of quieteness value as we ultimately need nodes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nImplementation is just as normal DFS, so time complexity is O(V+E) where V is number of vertices and E is number of edges.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(V) for one dimensional dp vector and O(E) for recursion stack space as DFS will be called E number of times. So overall space complexity is O(V+E).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>adj[],vector<int>&quiet,int i,vector<int>&dp) {\\n        if(dp[i]!=-1)return dp[i];\\n        \\n        dp[i]=i;\\n        for(auto it:adj[i]){\\n            int idx=dfs(adj,quiet,it,dp);\\n            if(quiet[idx]<quiet[dp[i]]){\\n                dp[i]=idx;\\n            }\\n        }\\n        return dp[i];\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int>dp(n,-1);\\n        vector<int>adj[n];\\n\\n        for(auto it:richer)adj[it[1]].push_back(it[0]);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==-1)\\n            {\\n                dp[i]=dfs(adj,quiet,i,dp);\\n            }\\n        }\\n\\n        return dp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>adj[],vector<int>&quiet,int i,vector<int>&dp) {\\n        if(dp[i]!=-1)return dp[i];\\n        \\n        dp[i]=i;\\n        for(auto it:adj[i]){\\n            int idx=dfs(adj,quiet,it,dp);\\n            if(quiet[idx]<quiet[dp[i]]){\\n                dp[i]=idx;\\n            }\\n        }\\n        return dp[i];\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int>dp(n,-1);\\n        vector<int>adj[n];\\n\\n        for(auto it:richer)adj[it[1]].push_back(it[0]);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==-1)\\n            {\\n                dp[i]=dfs(adj,quiet,i,dp);\\n            }\\n        }\\n\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373920,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func loudAndRich(_ richer: [[Int]], _ quiet: [Int]) -> [Int] {\\n\\n        let i = quiet\\n            .enumerated()\\n            .sorted { $0.element < $1.element }\\n            .map { $0.offset }\\n\\n        let p = richer.reduce(into: Array(repeating: [Int](), count: i.count)) {\\n            $0[$1[1]].append($1[0])\\n        }\\n        \\n        var res: [Int?] = Array(repeating: nil, count: i.count)\\n\\n        func more(_ i: Int) -> Int {\\n            if let r = res[i] {\\n                return r\\n            }\\n            else {\\n                var r = quiet[i]\\n                for x in p[i] {\\n                    r = min(r, more(x))\\n                }\\n                res[i] = r\\n                return r\\n            }\\n        }\\n\\n        for i in res.indices where res[i] == nil {\\n            more(i)\\n        }\\n\\n        return res.map { i[$0!] }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func loudAndRich(_ richer: [[Int]], _ quiet: [Int]) -> [Int] {\\n\\n        let i = quiet\\n            .enumerated()\\n            .sorted { $0.element < $1.element }\\n            .map { $0.offset }\\n\\n        let p = richer.reduce(into: Array(repeating: [Int](), count: i.count)) {\\n            $0[$1[1]].append($1[0])\\n        }\\n        \\n        var res: [Int?] = Array(repeating: nil, count: i.count)\\n\\n        func more(_ i: Int) -> Int {\\n            if let r = res[i] {\\n                return r\\n            }\\n            else {\\n                var r = quiet[i]\\n                for x in p[i] {\\n                    r = min(r, more(x))\\n                }\\n                res[i] = r\\n                return r\\n            }\\n        }\\n\\n        for i in res.indices where res[i] == nil {\\n            more(i)\\n        }\\n\\n        return res.map { i[$0!] }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360373,
                "title": "c-dfs-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int start,unordered_map<int,vector<int>>&ourmap,unordered_map<int,bool>&visited,vector<int>&quiet,int&mini,int&minnode){\\n        \\n        visited[start]=true;\\n        if(quiet[start]<mini){\\n            mini=quiet[start];\\n            minnode=start;\\n        }\\n        vector<int> temp=ourmap[start];\\n        for(int i=0;i<temp.size();i++){\\n            if(visited[temp[i]]!=true){\\n                dfs(temp[i],ourmap,visited,quiet,mini,minnode);\\n            }\\n        }\\n        \\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        unordered_map<int,vector<int>>ourmap;\\n        for(int i=0;i<richer.size();i++){\\n            int a=richer[i][0];\\n            int b=richer[i][1];\\n            ourmap[b].push_back(a);\\n        }\\n        int n=quiet.size();\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            unordered_map<int,bool> visited(false);\\n            int mini=quiet[i];\\n            int minnode=i;\\n            dfs(i,ourmap,visited,quiet,mini,minnode);\\n            ans[i]=minnode;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    void dfs(int start,unordered_map<int,vector<int>>&ourmap,unordered_map<int,bool>&visited,vector<int>&quiet,int&mini,int&minnode){\\n        \\n        visited[start]=true;\\n        if(quiet[start]<mini){\\n            mini=quiet[start];\\n            minnode=start;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3354720,
                "title": "easy-understanding-java-solution-graph-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    List<List<Integer>>graph= new ArrayList<>();\\n    int [] output;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n=quiet.length;\\n        for(int i=0; i<n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int pair[] : richer){\\n            int u= pair[1];\\n            int v= pair[0];\\n\\n            graph.get(u).add(v);\\n        \\n\\n        }\\n        output=new int[n];\\n        Arrays.fill(output,-1);\\n        for(int i=0; i<n; i++){\\n            if(output[i]==-1){\\n                dfs(i,quiet);\\n            }\\n        }\\n        return output;\\n    }\\n    public int dfs(int person ,int[]quiet){\\n        if(output[person]!=-1) \\n        return output[person];\\n\\n        int least_quiet_person=person;\\n        int least_quietness= quiet[person];\\n        for(int nbr: graph.get(person)){\\n            int newPerson= dfs(nbr,quiet);\\n            if(quiet[newPerson]<least_quietness){\\n                least_quietness= quiet[newPerson];\\n                least_quiet_person= newPerson;\\n            }\\n        }\\n        output[person]=least_quiet_person;\\n        return least_quiet_person;\\n    }\\n}\\n```\" UPVOTE IF YOU LIKE THIS SOLUTION!!!\"",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>>graph= new ArrayList<>();\\n    int [] output;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n=quiet.length;\\n        for(int i=0; i<n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int pair[] : richer){\\n            int u= pair[1];\\n            int v= pair[0];\\n\\n            graph.get(u).add(v);\\n        \\n\\n        }\\n        output=new int[n];\\n        Arrays.fill(output,-1);\\n        for(int i=0; i<n; i++){\\n            if(output[i]==-1){\\n                dfs(i,quiet);\\n            }\\n        }\\n        return output;\\n    }\\n    public int dfs(int person ,int[]quiet){\\n        if(output[person]!=-1) \\n        return output[person];\\n\\n        int least_quiet_person=person;\\n        int least_quietness= quiet[person];\\n        for(int nbr: graph.get(person)){\\n            int newPerson= dfs(nbr,quiet);\\n            if(quiet[newPerson]<least_quietness){\\n                least_quietness= quiet[newPerson];\\n                least_quiet_person= newPerson;\\n            }\\n        }\\n        output[person]=least_quiet_person;\\n        return least_quiet_person;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341621,
                "title": "simple-java-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[] ans;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        List<List<Integer>> adj = createGraph(quiet.length, richer);\\n        ans = new int[quiet.length];\\n        Arrays.fill(ans, -1);\\n\\n        for(int i=0;i<quiet.length;i++) {\\n            ans[i] = dfs(adj, i, quiet)[0];\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int[] dfs(List<List<Integer>> adj, int start, int[] quiet) {\\n        if(ans[start]>-1) { \\n            int[] qVal = {ans[start], quiet[ans[start]]};\\n            return qVal;\\n        }\\n\\n        List<Integer> neighbors = adj.get(start);\\n        int[] qVal = {start, quiet[start]};\\n        \\n        for(int nei: neighbors) {\\n            int[] val = dfs(adj, nei, quiet);\\n            if(val[1]<qVal[1]) {\\n                qVal = val;\\n            }\\n        }\\n\\n        ans[start] = qVal[0];\\n        \\n        return qVal;\\n    }\\n\\n    public List<List<Integer>> createGraph(int n, int[][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<Integer>());\\n        for(int[] e: edges) {\\n            graph.get(e[1]).add(e[0]);\\n        }\\n        return graph;\\n    }\\n\\n    public void printGraph(List<List<Integer>> adj) {\\n        int index = 0;\\n        for(List<Integer> i: adj) {\\n            System.out.print( index + \": \" );\\n            for(int j: i) {\\n                System.out.print(j + \",\");\\n            }\\n            index++;\\n            System.out.println();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] ans;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        List<List<Integer>> adj = createGraph(quiet.length, richer);\\n        ans = new int[quiet.length];\\n        Arrays.fill(ans, -1);\\n\\n        for(int i=0;i<quiet.length;i++) {\\n            ans[i] = dfs(adj, i, quiet)[0];\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int[] dfs(List<List<Integer>> adj, int start, int[] quiet) {\\n        if(ans[start]>-1) { \\n            int[] qVal = {ans[start], quiet[ans[start]]};\\n            return qVal;\\n        }\\n\\n        List<Integer> neighbors = adj.get(start);\\n        int[] qVal = {start, quiet[start]};\\n        \\n        for(int nei: neighbors) {\\n            int[] val = dfs(adj, nei, quiet);\\n            if(val[1]<qVal[1]) {\\n                qVal = val;\\n            }\\n        }\\n\\n        ans[start] = qVal[0];\\n        \\n        return qVal;\\n    }\\n\\n    public List<List<Integer>> createGraph(int n, int[][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<Integer>());\\n        for(int[] e: edges) {\\n            graph.get(e[1]).add(e[0]);\\n        }\\n        return graph;\\n    }\\n\\n    public void printGraph(List<List<Integer>> adj) {\\n        int index = 0;\\n        for(List<Integer> i: adj) {\\n            System.out.print( index + \": \" );\\n            for(int j: i) {\\n                System.out.print(j + \",\");\\n            }\\n            index++;\\n            System.out.println();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339631,
                "title": "simple-bfs-solution-c",
                "content": "class Solution {\\npublic:\\n    \\n    int bfs(vector<vector<pair<int,int>>>& adj,int u,vector<int>& quiet)\\n    {\\n        queue<pair<int,int>> q;\\n        vector<bool> visited(quiet.size(),false);\\n        \\n        q.push({u,quiet[u]});\\n        \\n        int currquiet= quiet[u];\\n        int ans= u;\\n        \\n        while(!q.empty())\\n        {\\n            auto p= q.front();\\n            q.pop();\\n            \\n            visited[p.first]= true;\\n            int val= p.second;\\n            \\n            if(val<=currquiet)\\n            {\\n                 currquiet=val;\\n                 ans= p.first;\\n            }\\n            \\n            for(auto el: adj[p.first])\\n            {\\n                if(!visited[el.first])\\n                    q.push({el.first,el.second});\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n= quiet.size();\\n        \\n        vector<vector<pair<int,int>>> adj(n);\\n        \\n        for(auto el: richer)\\n        {\\n            int u= el[1];\\n            int v= el[0];\\n            \\n            adj[u].push_back({v,quiet[v]});\\n        }\\n        \\n        vector<int> ans(n,-1);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int h= bfs(adj,i,quiet);\\n            ans[i]= h;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int bfs(vector<vector<pair<int,int>>>& adj,int u,vector<int>& quiet)\\n    {\\n        queue<pair<int,int>> q;\\n        vector<bool> visited(quiet.size(),false);\\n        \\n        q.push({u,quiet[u]}",
                "codeTag": "Java"
            },
            {
                "id": 3338271,
                "title": "c-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> indeg(n,0),ans(n);\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            adj[richer[i][0]].push_back(richer[i][1]);\\n            indeg[richer[i][1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i]=i;\\n            if(indeg[i]==0)\\n            q.push(i);\\n        }\\n        while(!q.empty())\\n        {\\n            int temp=q.front();\\n            q.pop();\\n            for(int i:adj[temp])\\n            {\\n                if(quiet[ans[i]]>=quiet[ans[temp]])\\n                ans[i]=ans[temp];\\n                if(--indeg[i]==0)\\n                q.push(i);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> indeg(n,0),ans(n);\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            adj[richer[i][0]].push_back(richer[i][1]);\\n            indeg[richer[i][1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i]=i;\\n            if(indeg[i]==0)\\n            q.push(i);\\n        }\\n        while(!q.empty())\\n        {\\n            int temp=q.front();\\n            q.pop();\\n            for(int i:adj[temp])\\n            {\\n                if(quiet[ans[i]]>=quiet[ans[temp]])\\n                ans[i]=ans[temp];\\n                if(--indeg[i]==0)\\n                q.push(i);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1708769,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1565078,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1569845,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1968557,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1830030,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1854187,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1635588,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1932106,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1879280,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1879202,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1708769,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1565078,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1569845,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1968557,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1830030,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1854187,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1635588,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1932106,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1879280,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1879202,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            }
        ]
    }
]