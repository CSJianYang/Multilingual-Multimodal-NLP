[
    {
        "title": "Maximum Number of Non-overlapping Palindrome Substrings",
        "question_content": "You are given a string s and a positive integer k.\nSelect a set of non-overlapping substrings from the string s that satisfy the following conditions:\n\n\tThe length of each substring is at least k.\n\tEach substring is a palindrome.\n\nReturn the maximum number of substrings in an optimal selection.\nA substring is a contiguous sequence of characters within a string.\n&nbsp;\nExample 1:\n\nInput: s = \"abaccdbbd\", k = 3\nOutput: 2\nExplanation: We can select the substrings underlined in s = \"abaccdbbd\". Both \"aba\" and \"dbbd\" are palindromes and have a length of at least k = 3.\nIt can be shown that we cannot find a selection with more than two valid substrings.\n\nExample 2:\n\nInput: s = \"adbcda\", k = 2\nOutput: 0\nExplanation: There is no palindrome substring of length at least 2 in the string.\n\n&nbsp;\nConstraints:\n\n\t1 <= k <= s.length <= 2000\n\ts consists of lowercase English letters.",
        "solutions": [
            {
                "id": 2808805,
                "title": "c-java-python3-palindromic-substrings-non-overlapping-intervals",
                "content": "\\n**Explanation**\\nThis question is a combination of Palindromic Substring and Non-overlapping intervals\\nhttps://leetcode.com/problems/palindromic-substrings/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\n* First find all palindromic substrings with length >= k in O(n*k) and store their start and end in an `intervals` list\\n\\n* Then find minumum number of intervals you need to remove to make the `intervals` array non overlapping in O(n) (`intervals` is already added in sorted order.)\\n\\n**Solution1:**\\n<iframe src=\"https://leetcode.com/playground/FZexChvv/shared\" frameBorder=\"0\" width=\"1000\" height=\"510\"></iframe>\\n\\n*Time complexity = O(nk)*\\n\\n**Solution2:**\\nNo need to find non overlapping intervals just record the end of the last found palindromic substring. \\n\\n<iframe src=\"https://leetcode.com/playground/V2R8VVPx/shared\" frameBorder=\"0\" width=\"1000\" height=\"345\"></iframe>\\n\\n*Time complexity = O(nk)*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "\\n**Explanation**\\nThis question is a combination of Palindromic Substring and Non-overlapping intervals\\nhttps://leetcode.com/problems/palindromic-substrings/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\n* First find all palindromic substrings with length >= k in O(n*k) and store their start and end in an `intervals` list\\n\\n* Then find minumum number of intervals you need to remove to make the `intervals` array non overlapping in O(n) (`intervals` is already added in sorted order.)\\n\\n**Solution1:**\\n<iframe src=\"https://leetcode.com/playground/FZexChvv/shared\" frameBorder=\"0\" width=\"1000\" height=\"510\"></iframe>\\n\\n*Time complexity = O(nk)*\\n\\n**Solution2:**\\nNo need to find non overlapping intervals just record the end of the last found palindromic substring. \\n\\n<iframe src=\"https://leetcode.com/playground/V2R8VVPx/shared\" frameBorder=\"0\" width=\"1000\" height=\"345\"></iframe>\\n\\n*Time complexity = O(nk)*",
                "codeTag": "Unknown"
            },
            {
                "id": 2808897,
                "title": "dp-greedy",
                "content": "We precompute a 2d array `pal` that tells us whether a string between `i` and `j` is a palindrome (`pal[i][j] == true`).\\n\\nThis is the same DP approach as for [647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/).\\n\\nThen, we use DP to find maximum number of splits.\\n\\n**Important Optimization**\\nWe only need to check palindromes of size `k` and `k + 1`. \\n\\nThis is because if `[i - 1..i + k]` is a palindrome (with size  `k + 2`), then `[i..i + k - 1]` is also a palindome (with size `k`).\\n\\nWith this realization, we can greedily find the maximum number of splits (no \\nneed to use DP).\\n \\n ## Greedy Solution\\n **C++**\\n ```cpp\\n bool pal[2002][2002] = {};\\nint maxPalindromes(string s, int k) {\\n    if (k == 1)\\n        return s.size();\\n    for (int len = 1; len <= k + 1; ++len)\\n        for (int i = 0, j = i + len - 1; j < s.size(); ++i, ++j)\\n            pal[i][j] = (len < 3 ? true : pal[i + 1][j - 1]) && (s[i] == s[j]);\\n    int i = 0, res = 0;\\n    for (int i = 0; i + k <= s.size(); ++i) {\\n        res += pal[i][i + k - 1] || pal[i][i + k];\\n        i += pal[i][i + k - 1] ? k - 1 : pal[i][i + k] ? k : 0;\\n    }\\n    return res;\\n}\\n ```\\n \\n ## DP Solution\\n**C++**\\n```cpp\\nint dp[2001] = {};\\nbool pal[2001][2001] = {};\\nint dfs(int i, int k, string &s) {\\n    if (i + k > s.size())\\n        return 0;\\n    if (!dp[i]) {\\n        dp[i] = 1 + dfs(i + 1, k, s);\\n        if (pal[i][i + k - 1])\\n            dp[i] = max(dp[i], 2 + dfs(i + k, k, s));\\n        if (i + k < s.size() && pal[i][i + k])\\n            dp[i] = max(dp[i], 2 + dfs(i + k + 1, k, s));\\n    }\\n    return dp[i] - 1;\\n}\\nint maxPalindromes(string s, int k) {\\n    if (k == 1)\\n        return s.size();\\n    for (int len = 1; len <= k + 1; ++len)\\n        for (int i = 0, j = i + len - 1; j < s.size(); ++i, ++j)\\n            pal[i][j] = (len < 3 ? true : pal[i + 1][j - 1]) && (s[i] == s[j]);   \\n    return dfs(0, k, s);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n bool pal[2002][2002] = {};\\nint maxPalindromes(string s, int k) {\\n    if (k == 1)\\n        return s.size();\\n    for (int len = 1; len <= k + 1; ++len)\\n        for (int i = 0, j = i + len - 1; j < s.size(); ++i, ++j)\\n            pal[i][j] = (len < 3 ? true : pal[i + 1][j - 1]) && (s[i] == s[j]);\\n    int i = 0, res = 0;\\n    for (int i = 0; i + k <= s.size(); ++i) {\\n        res += pal[i][i + k - 1] || pal[i][i + k];\\n        i += pal[i][i + k - 1] ? k - 1 : pal[i][i + k] ? k : 0;\\n    }\\n    return res;\\n}\\n ```\n```cpp\\nint dp[2001] = {};\\nbool pal[2001][2001] = {};\\nint dfs(int i, int k, string &s) {\\n    if (i + k > s.size())\\n        return 0;\\n    if (!dp[i]) {\\n        dp[i] = 1 + dfs(i + 1, k, s);\\n        if (pal[i][i + k - 1])\\n            dp[i] = max(dp[i], 2 + dfs(i + k, k, s));\\n        if (i + k < s.size() && pal[i][i + k])\\n            dp[i] = max(dp[i], 2 + dfs(i + k + 1, k, s));\\n    }\\n    return dp[i] - 1;\\n}\\nint maxPalindromes(string s, int k) {\\n    if (k == 1)\\n        return s.size();\\n    for (int len = 1; len <= k + 1; ++len)\\n        for (int i = 0, j = i + len - 1; j < s.size(); ++i, ++j)\\n            pal[i][j] = (len < 3 ? true : pal[i + 1][j - 1]) && (s[i] == s[j]);   \\n    return dfs(0, k, s);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2811056,
                "title": "simplest-solution-no-dp-why-only-k-1",
                "content": "# Too much Simple\\n\\n* Main catch here was to avoid picking a palindromic substring with size greater than k+1 because if there exist a palindromic substring with size greater than k+1 then it would definitely contain a palindromic substring with size at least k ( It was just basic observation ) And we are trying to minimize the length of the palindromic string ( with size >= k ) to maximize our answer.\\n\\nSuppose,\\nstring =` abaczbzccc` & `k = 3`\\n\\nWithout break condition, answer would have been 2 `( aba, czbzc )`\\nWith break condition, answer would be 3 `( aba, zbz, ccc )`\\n\\n* Now observe the difference, instead of picking \\'czbzc\\' we pick \\'zbz\\' which allowed us to further pick \\'ccc\\' as well. I hope it clarifies your doubt.\\n```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = i; j < s.length(); j++) {\\n                int len = (j - i) + 1;\\n                if (len > k + 1) break; // this is the key \\n                if (len >= k && isPalindrome(s, i, j)) {\\n                    ans++; i = j;  break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    boolean isPalindrome(String s, int l, int r) {\\n        while (l < r) {\\n            if (s.charAt(l++) != s.charAt(r--))  return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```\\n\\ncredit : @_aka5h",
                "solutionTags": [
                    "Java",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = i; j < s.length(); j++) {\\n                int len = (j - i) + 1;\\n                if (len > k + 1) break; // this is the key \\n                if (len >= k && isPalindrome(s, i, j)) {\\n                    ans++; i = j;  break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    boolean isPalindrome(String s, int l, int r) {\\n        while (l < r) {\\n            if (s.charAt(l++) != s.charAt(r--))  return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809337,
                "title": "python-c-recursive-iterative-dp-solutions-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Dynamic Programming* approach to explore all possible non-overlapping palindromes. Time complexity is linear: **O(nk)**. Space complexity is linear: **O(n)**.\\n\\n**Comment.** If one palindrome is a substring of another palidrome then considering the second one will not increase the total number of non-overlapping palindromes. Thus, we only need to consider the minimally allowed palindromes of even and odd lengths (i.e., of  `k` and `k+1`).\\n\\n**Python #1.** Recursive solution.\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        \\n        def pal(i, j):                                        # [a] if you dare to solve hard problems then you\\n            if j > len(s) : return False                      #     probably know many ways to test palindromes;\\n            return s[i:j] == s[i:j][::-1]                     #     this one is for clarity, not for speed\\n        \\n        @lru_cache(None)                                      # [b] this recursive function finds the maximal\\n        def dfs(i):                                           #     number of non-overlapping palindroms in\\n            if i + k > len(s) : return 0                      #     the string \\'s\\' if we start at position \\'i\\';\\n            m = dfs(i+1)                                      # [c] we consider cases when there is a palindrome \\n            if pal(i,i+k)   : m = max(m, 1 + dfs(i+k))        #     of length k/k+1 at the i-th position or when\\n            if pal(i,i+k+1) : m = max(m, 1 + dfs(i+k+1))      #     there is no such palindrome (and we take the\\n            return m                                          #     number of palindromes for the i+1-th position)\\n        \\n        return dfs(0)\\n```\\n\\n**Python #2.** Iterative solution.\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        \\n        def pal(i, j):\\n            if i < 0 : return False\\n            return s[i:j] == s[i:j][::-1]\\n        \\n        dp = [0] * (len(s)+1)\\n        \\n        for i in range(k, len(s)+1):\\n            dp[i] = dp[i-1]\\n            if pal(i-k,i)   : dp[i] = max(dp[i], 1 + dp[i-k])\\n            if pal(i-k-1,i) : dp[i] = max(dp[i], 1 + dp[i-k-1])\\n        \\n        return dp[-1]\\n```\\n\\nThis solution in other languages.\\n\\n<iframe src=\"https://leetcode.com/playground/D3xsirVa/shared\" frameBorder=\"0\" width=\"800\" height=\"700\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        \\n        def pal(i, j):                                        # [a] if you dare to solve hard problems then you\\n            if j > len(s) : return False                      #     probably know many ways to test palindromes;\\n            return s[i:j] == s[i:j][::-1]                     #     this one is for clarity, not for speed\\n        \\n        @lru_cache(None)                                      # [b] this recursive function finds the maximal\\n        def dfs(i):                                           #     number of non-overlapping palindroms in\\n            if i + k > len(s) : return 0                      #     the string \\'s\\' if we start at position \\'i\\';\\n            m = dfs(i+1)                                      # [c] we consider cases when there is a palindrome \\n            if pal(i,i+k)   : m = max(m, 1 + dfs(i+k))        #     of length k/k+1 at the i-th position or when\\n            if pal(i,i+k+1) : m = max(m, 1 + dfs(i+k+1))      #     there is no such palindrome (and we take the\\n            return m                                          #     number of palindromes for the i+1-th position)\\n        \\n        return dfs(0)\\n```\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        \\n        def pal(i, j):\\n            if i < 0 : return False\\n            return s[i:j] == s[i:j][::-1]\\n        \\n        dp = [0] * (len(s)+1)\\n        \\n        for i in range(k, len(s)+1):\\n            dp[i] = dp[i-1]\\n            if pal(i-k,i)   : dp[i] = max(dp[i], 1 + dp[i-k])\\n            if pal(i-k-1,i) : dp[i] = max(dp[i], 1 + dp[i-k-1])\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808796,
                "title": "java-c-simple-dp",
                "content": "Only check substrings of length k and k + 1\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int ans = 0, n = s.length();\\n        int[] dp = new int[n + 1];\\n        for (int i = k - 1; i < n; i++) {\\n            dp[i + 1] = dp[i];\\n            if (helper(s, i-k+1, i))       dp[i + 1] = Math.max(dp[i + 1], 1 + dp[i - k + 1]);\\n            if (i-k>=0 && helper(s,i-k,i)) dp[i + 1] = Math.max(dp[i + 1], 1 + dp[i - k]);\\n        }\\n        return dp[n];\\n    }\\n    boolean helper(String s, int l, int r) {\\n        while (l < r) {\\n            if (s.charAt(l) != s.charAt(r)) return false;\\n            l++; r--;\\n        }\\n        return true;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool helper(string s, int l, int r) {\\n        while (l < r) {\\n            if (s[l] != s[r]) return false;\\n            l++; r--;\\n        }\\n        return true;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int ans = 0, n = s.length();\\n        vector<int> dp(n + 1,0);\\n        for (int i = k - 1; i < n; i++) {\\n            dp[i + 1] = dp[i];\\n            if (helper(s, i-k+1, i))       dp[i + 1] = max(dp[i + 1], 1 + dp[i - k + 1]);\\n            if (i-k>=0 && helper(s,i-k,i)) dp[i + 1] = max(dp[i + 1], 1 + dp[i - k]);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int ans = 0, n = s.length();\\n        int[] dp = new int[n + 1];\\n        for (int i = k - 1; i < n; i++) {\\n            dp[i + 1] = dp[i];\\n            if (helper(s, i-k+1, i))       dp[i + 1] = Math.max(dp[i + 1], 1 + dp[i - k + 1]);\\n            if (i-k>=0 && helper(s,i-k,i)) dp[i + 1] = Math.max(dp[i + 1], 1 + dp[i - k]);\\n        }\\n        return dp[n];\\n    }\\n    boolean helper(String s, int l, int r) {\\n        while (l < r) {\\n            if (s.charAt(l) != s.charAt(r)) return false;\\n            l++; r--;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool helper(string s, int l, int r) {\\n        while (l < r) {\\n            if (s[l] != s[r]) return false;\\n            l++; r--;\\n        }\\n        return true;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int ans = 0, n = s.length();\\n        vector<int> dp(n + 1,0);\\n        for (int i = k - 1; i < n; i++) {\\n            dp[i + 1] = dp[i];\\n            if (helper(s, i-k+1, i))       dp[i + 1] = max(dp[i + 1], 1 + dp[i - k + 1]);\\n            if (i-k>=0 && helper(s,i-k,i)) dp[i + 1] = max(dp[i + 1], 1 + dp[i - k]);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808845,
                "title": "python3-dp-with-explanations-only-check-substrings-of-length-k-and-k-1",
                "content": "**Observation**\\nGiven the constraints, a solution with quadratic time complexity suffices for this problem. The key to this problem is to note that, if a given palindromic substring has length greater or equal to `k + 2`, then we can always remove the first and last character of the substring without losing the optimality. As such, we only need to check if a substring is a palindrome that has length `k` or `k + 1`.\\n \\n**Implementation**\\nWe define a `dp` array where `dp[i]` represents the maximum number of substrings in the first `i` characters. For each possible `i`, we check whether the substring with length `k` or `k + 1` ending at the `i`-th character (1-indexed) is a valid palindrome, and update the value of `dp[i]`.\\n \\n**Complexity**\\nTime Complexity: `O(nk)`\\nSpace Complexity: `O(n)`, for the use of `dp`\\n \\n**Solution**\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n        for i in range(k, n + 1):\\n            dp[i] = dp[i - 1]\\n            for length in range(k, k + 2):\\n                j = i - length\\n                if j < 0:\\n                    break\\n                if self.isPalindrome(s, j, i):\\n                    dp[i] = max(dp[i], 1 + dp[j])\\n        return dp[-1]\\n    \\n    \\n    def isPalindrome(self, s, j, i):\\n        left, right = j, i - 1\\n        while left < right:\\n            if s[left] != s[right]:\\n                return False\\n            left += 1\\n            right -= 1\\n        return True\\n```\\n \\n **Follow-up (open question)** Can we improve the time complexity from `O(nk)` to `O(n)` by using the Manacher\\'s algorithm?",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n        for i in range(k, n + 1):\\n            dp[i] = dp[i - 1]\\n            for length in range(k, k + 2):\\n                j = i - length\\n                if j < 0:\\n                    break\\n                if self.isPalindrome(s, j, i):\\n                    dp[i] = max(dp[i], 1 + dp[j])\\n        return dp[-1]\\n    \\n    \\n    def isPalindrome(self, s, j, i):\\n        left, right = j, i - 1\\n        while left < right:\\n            if s[left] != s[right]:\\n                return False\\n            left += 1\\n            right -= 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808835,
                "title": "dp-max-meetings-in-a-room-c",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n The problem can be broken into two parts:-\\n\\n - Finding all the start and end indices of palindromes in the string such that length of palindrome is k .  *(This can be done in O(n x n) using DP similar to finding max length palindrome)*\\n\\n - Now among all these start and end indices , select maximum non overlapping indices. \\n *(This can be done in O(n log n) by a greedy approach) (this part is exactly same as maximum meetings in a single room problem )* \\n\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n int n = s.size();\\n        vector<pair<int,int>> vec;    //**** vector to store start & end indices of all valid palindromes\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        for(int i =0;i<n;i++){\\n            dp[i][i] = 1;\\n            if(k==1)\\n            vec.push_back({i,i});\\n        }\\n        \\n        \\n       for(int j = 1;j<= n;j++){   //***** dp approach to find what are the start and end indices of palindromes\\n        for(int i=0;i<n;i++){\\n            if(i+j>=n)break;\\n            if(s[i]==s[i+j]){\\n                if(i+1 <= i+j-1)\\n                    dp[i][i+j]  =dp[i+1][i+j-1];\\n                \\n                else{\\n                    dp[i][i+j] = 1;\\n                }  \\n            } \\n            if(dp[i][i+j]==1 && j>= k-1)    //** push in vec only if size of pal is >= k\\n                vec.push_back({i+j,i});    \\n        }\\n       }\\n        \\n        int res = 0;      //****  from the given palindrome indices select maximum number of non - overlapping\\n        sort(vec.begin(),vec.end());\\n        int end = -1;\\n        for(pair<int,int> &p:vec){   //*** this is a greedy way to find (same as maximum meetings in a room )\\n         if(p.second>end){\\n             end = p.first;\\n             res++;\\n          }        \\n        }\\n        \\n     \\n        return res;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n int n = s.size();\\n        vector<pair<int,int>> vec;    //**** vector to store start & end indices of all valid palindromes\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        for(int i =0;i<n;i++){\\n            dp[i][i] = 1;\\n            if(k==1)\\n            vec.push_back({i,i});\\n        }\\n        \\n        \\n       for(int j = 1;j<= n;j++){   //***** dp approach to find what are the start and end indices of palindromes\\n        for(int i=0;i<n;i++){\\n            if(i+j>=n)break;\\n            if(s[i]==s[i+j]){\\n                if(i+1 <= i+j-1)\\n                    dp[i][i+j]  =dp[i+1][i+j-1];\\n                \\n                else{\\n                    dp[i][i+j] = 1;\\n                }  \\n            } \\n            if(dp[i][i+j]==1 && j>= k-1)    //** push in vec only if size of pal is >= k\\n                vec.push_back({i+j,i});    \\n        }\\n       }\\n        \\n        int res = 0;      //****  from the given palindrome indices select maximum number of non - overlapping\\n        sort(vec.begin(),vec.end());\\n        int end = -1;\\n        for(pair<int,int> &p:vec){   //*** this is a greedy way to find (same as maximum meetings in a room )\\n         if(p.second>end){\\n             end = p.first;\\n             res++;\\n          }        \\n        }\\n        \\n     \\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2809233,
                "title": "python-dp-solution",
                "content": "# **Explanation**\\n`dp[i]` means the result for prefix string to `s[i]`.\\n`dp[i] = dp[i-1]`, means `s[i]` is not used in palindrome substrings.\\nThen we check substring with the `k` last characters,\\nwith `s[i-k+1], s[i-k+2] ... s[i]`,\\nif it\\'s palindrome we have `dp[i] = dp[i - k] + 1`\\n\\nIf the above string is not palindrome,\\nwe continue to check substring with the `k + 1` last characters,\\nif it\\'s palindrome we have `dp[i] = dp[i - k - 1] + 1`.\\n\\nNote that we don\\'t need to check string with length bigger than `k + 1`,\\nwe only need to greedily check string with length `k` and `k + 1`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n^2)`, can be improved to `O(n)` with Manacher\\nSpace `O(n)`\\n<br>\\n\\n**Python**\\n```py\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        n = len(s)\\n        dp = [0] * n\\n        for i in range(k - 1, n):\\n            dp[i] = dp[i - 1]\\n            if dp[i] <= dp[i-k] and s[i-k+1:i+1] == s[i-k+1:i+1][::-1]:\\n                dp[i] = dp[i - k] + 1\\n            elif i - k >= 0 and dp[i] <= dp[i-k-1] and s[i-k:i+1] == s[i-k:i+1][::-1]:\\n                dp[i] = dp[i - k - 1] + 1\\n        return dp[n - 1]\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        n = len(s)\\n        dp = [0] * n\\n        for i in range(k - 1, n):\\n            dp[i] = dp[i - 1]\\n            if dp[i] <= dp[i-k] and s[i-k+1:i+1] == s[i-k+1:i+1][::-1]:\\n                dp[i] = dp[i - k] + 1\\n            elif i - k >= 0 and dp[i] <= dp[i-k-1] and s[i-k:i+1] == s[i-k:i+1][::-1]:\\n                dp[i] = dp[i - k - 1] + 1\\n        return dp[n - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2809293,
                "title": "c-both-dp-greedy-solution-explained-clean-code",
                "content": "**Intuition**\\nThis question is going to mess with TLE if you don\\'t memoize it properly.\\nIt\\'s very similar to [Palindrome Paritioning](https://leetcode.com/problems/palindrome-partitioning/), but requires condition of minLength `K`.\\n\\n**Method 1: DP Solution**\\n```cpp\\nint minLen;\\nvector<vector<bool>> dp;\\nunordered_map<int, int> mp;\\n\\nint solve(string& s, int pos){\\n    int n = s.size();\\n    if(pos >= n) return 0;\\n    if(mp.count(pos)) return mp[pos];\\n\\n    int dontTake = solve(s, pos+1);\\n    int take = INT_MIN;\\n\\n    for(int j=pos+minLen-1; j < n; j++){\\n        if(dp[pos][j])\\n            take = max(take, 1 + solve(s, j+1));\\n    }\\n    return mp[pos] = max(take, dontTake);\\n}\\n\\nint maxPalindromes(string s, int minLen) {\\n    this->minLen = minLen;\\n    int n = s.size();\\n    dp.resize(n, vector<bool>(n, false));\\n\\n    // Creates DP array with s[i -> j] true if palindrome, else false\\n    for(int len=1; len <= n; len++){\\n        for(int i=0; i <= n-len; i++){\\n            int j = i+len-1;\\n            dp[i][j] = (len <= 2 ? true : dp[i+1][j-1]) && s[i] == s[j];\\n        }\\n    }\\n    return solve(s, 0);\\n}\\n```\\n\\n\\n**Method 2: Greedy Solution**\\n(Inspired from [@xil899 solution](https://leetcode.com/problems/maximum-number-of-non-overlapping-palindrome-substrings/discuss/2808845/Python3-DP-with-Explanations-or-Only-Check-Substrings-of-Length-k-and-k-%2B-1))\\n\\nSuppose we have strings - \\n* \"aa\", K length, its a palindrome\\n* \"aba\", we could also check K+1 incase odd length\\n\\nShould we check K+2?\\n* \"ab\", not a palindrome\\n* \"abb\", not a palindrome\\n* \"abba\", suppose if it\\'s a palindrome, even if we remove the first and last chars,\\nit will be \"<s>a</s>bb<s>a</s>\" -> \"bb\", which is a palindrome of len = K.\\n\\nOtherwise, think like this, we could include this K+2.\\nBut isn\\'t it same as moving to `idx+1` and taking K len substring -> \"bb\",\\nwhich will anyway happen in the loop. \\n\\nHence checking `len = K+2`  can be avoided.\\n\\n```cpp\\nint maxPalindromes(string s, int minLen) {\\n    int n = s.size();\\n    vector<vector<bool>> dp(n, vector<bool>(n, false));\\n    for(int len=1; len <= n; len++){\\n        for(int i=0; i <= n-len; i++){\\n            int j = i+len-1;\\n            dp[i][j] = (len <= 2 ? true : dp[i+1][j-1]) && s[i] == s[j];\\n        }\\n    }\\n\\n    int res = 0, i = 0;\\n    while(i < n){\\n\\t\\t// check K len substring\\n        if(i+minLen-1 < n && dp[i][i+minLen-1]){\\n            res++;\\n            i += minLen;\\n        }\\n\\t\\t// check K+1 len substring\\n        else if(i+minLen < n && dp[i][i+minLen]){\\n            res++;\\n            i = i+minLen+1;\\n        }\\n        else\\n            i++;\\n    }\\n    return res;\\n}\\n```\\n**Upvote and let\\'s learn together!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nint minLen;\\nvector<vector<bool>> dp;\\nunordered_map<int, int> mp;\\n\\nint solve(string& s, int pos){\\n    int n = s.size();\\n    if(pos >= n) return 0;\\n    if(mp.count(pos)) return mp[pos];\\n\\n    int dontTake = solve(s, pos+1);\\n    int take = INT_MIN;\\n\\n    for(int j=pos+minLen-1; j < n; j++){\\n        if(dp[pos][j])\\n            take = max(take, 1 + solve(s, j+1));\\n    }\\n    return mp[pos] = max(take, dontTake);\\n}\\n\\nint maxPalindromes(string s, int minLen) {\\n    this->minLen = minLen;\\n    int n = s.size();\\n    dp.resize(n, vector<bool>(n, false));\\n\\n    // Creates DP array with s[i -> j] true if palindrome, else false\\n    for(int len=1; len <= n; len++){\\n        for(int i=0; i <= n-len; i++){\\n            int j = i+len-1;\\n            dp[i][j] = (len <= 2 ? true : dp[i+1][j-1]) && s[i] == s[j];\\n        }\\n    }\\n    return solve(s, 0);\\n}\\n```\n```cpp\\nint maxPalindromes(string s, int minLen) {\\n    int n = s.size();\\n    vector<vector<bool>> dp(n, vector<bool>(n, false));\\n    for(int len=1; len <= n; len++){\\n        for(int i=0; i <= n-len; i++){\\n            int j = i+len-1;\\n            dp[i][j] = (len <= 2 ? true : dp[i+1][j-1]) && s[i] == s[j];\\n        }\\n    }\\n\\n    int res = 0, i = 0;\\n    while(i < n){\\n\\t\\t// check K len substring\\n        if(i+minLen-1 < n && dp[i][i+minLen-1]){\\n            res++;\\n            i += minLen;\\n        }\\n\\t\\t// check K+1 len substring\\n        else if(i+minLen < n && dp[i][i+minLen]){\\n            res++;\\n            i = i+minLen+1;\\n        }\\n        else\\n            i++;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808800,
                "title": "java-greedy-approach",
                "content": "```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int count = 0;\\n        int idx = 0;\\n        \\n        // greedily check for palindromes of length k or k + 1\\n        while (idx <= s.length() - k) {\\n            if (isPalindrome(s, idx, idx + k - 1)) {\\n                count++;\\n                idx += k;\\n            } else if (idx < s.length() - k && isPalindrome(s, idx, idx + k)) {\\n                count++;\\n                idx += k + 1;\\n            } else {\\n                idx++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private boolean isPalindrome(String s, int left, int right) {\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int count = 0;\\n        int idx = 0;\\n        \\n        // greedily check for palindromes of length k or k + 1\\n        while (idx <= s.length() - k) {\\n            if (isPalindrome(s, idx, idx + k - 1)) {\\n                count++;\\n                idx += k;\\n            } else if (idx < s.length() - k && isPalindrome(s, idx, idx + k)) {\\n                count++;\\n                idx += k + 1;\\n            } else {\\n                idx++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private boolean isPalindrome(String s, int left, int right) {\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809877,
                "title": "c-without-using-dp-and-palindrome-function",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            string str = \"\",str1=\"\";\\n            for(int j=i;j<n;j++){\\n                str += s[j];\\n                str1 = s[j] + str1;\\n                if(str.size()>=k && str==str1)\\n                {\\n                    count++;\\n                    i = j;\\n                    break;\\n                }\\n                if(str.size()>k)\\n                    break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            string str = \"\",str1=\"\";\\n            for(int j=i;j<n;j++){\\n                str += s[j];\\n                str1 = s[j] + str1;\\n                if(str.size()>=k && str==str1)\\n                {\\n                    count++;\\n                    i = j;\\n                    break;\\n                }\\n                if(str.size()>k)\\n                    break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811420,
                "title": "java-1-dimension-dp-explained",
                "content": "# Intuition\\n`dp[i]` means the amount of palindomres found up to index `i` (exclusive).\\n\\nWe will iterate over the string `s` and at every iteration the `i` index will represent the center of a palindrome.\\n\\nWe will try expanding from that center to the left and right, and if we are holding equality `A[left] == A[right]` it means we still have a palindrome, therefore we can update `dp[right + 1] = max(1 + dp[left], dp[right + 1])`.\\nThis is because we found a new palindrome that ended at index `right`, and because our dp is excluding the last index, we add +1.\\n\\nWe must also check for even palindrome, therefore run the checks when we have a center of 2 indexes.\\n\\nOdd palindrome: `left` and `right` start at the same index. i.e. left = i-j. right = i+j (assume j=0 in the beginning)\\nEven palindrome: `left` and `right` must have 1 index difference. either left-1 or right+1.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n\\n        // Base case (redundant, but for clarity)\\n        dp[0] = 0;\\n\\n        // Odd palindrome (center of 1 index)\\n        for (int i = 0; i < n; i++) {\\n            dp[i + 1] = Math.max(dp[i], dp[i + 1]);\\n            for (int j = 0; j < n; j++) {\\n                int left = i - j;\\n                int right = i + j;\\n                if (left < 0 || right >= n) break;\\n                if (s.charAt(left) != s.charAt(right)) break;\\n\\n                if (right - left + 1 >= k) {\\n                    dp[right + 1] = Math.max(dp[right + 1], dp[left] + 1);\\n                }\\n\\n            }\\n\\n            // Even palindrome (center of 2 indexes)\\n            for (int j = 0; j < n; j++) {\\n                int left = i - j - 1;\\n                int right = i + j;\\n                if (left < 0 || right >= n) break;\\n                if (s.charAt(left) != s.charAt(right)) break;\\n\\n                if (right - left + 1 >= k) {\\n                    dp[right + 1] = Math.max(dp[right + 1], dp[left] + 1);\\n                }\\n            }\\n        }\\n\\n        // for (int a : dp) System.out.print(a + \" \");\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n\\n        // Base case (redundant, but for clarity)\\n        dp[0] = 0;\\n\\n        // Odd palindrome (center of 1 index)\\n        for (int i = 0; i < n; i++) {\\n            dp[i + 1] = Math.max(dp[i], dp[i + 1]);\\n            for (int j = 0; j < n; j++) {\\n                int left = i - j;\\n                int right = i + j;\\n                if (left < 0 || right >= n) break;\\n                if (s.charAt(left) != s.charAt(right)) break;\\n\\n                if (right - left + 1 >= k) {\\n                    dp[right + 1] = Math.max(dp[right + 1], dp[left] + 1);\\n                }\\n\\n            }\\n\\n            // Even palindrome (center of 2 indexes)\\n            for (int j = 0; j < n; j++) {\\n                int left = i - j - 1;\\n                int right = i + j;\\n                if (left < 0 || right >= n) break;\\n                if (s.charAt(left) != s.charAt(right)) break;\\n\\n                if (right - left + 1 >= k) {\\n                    dp[right + 1] = Math.max(dp[right + 1], dp[left] + 1);\\n                }\\n            }\\n        }\\n\\n        // for (int a : dp) System.out.print(a + \" \");\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809578,
                "title": "c-solution-using-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int k;\\n    int n;\\n    int p[2001][2001];\\n    int memo[3000];\\n    int f(int idx)\\n    {\\n        if(idx>=n)\\n        {\\n            return 0;\\n        }\\n        if(memo[idx]!=-1)\\n        {\\n            return memo[idx];\\n        }\\n        int ans=0;\\n        for(int i=idx;i<n;i++)\\n        {\\n            if((i-idx+1>=k)&&p[idx][i])\\n            {\\n                ans=max(ans,1+f(i+1));\\n            }\\n        }\\n        ans=max(ans,f(idx+1));\\n        return memo[idx]=ans;\\n    }\\n    int maxPalindromes(string s, int K) \\n    {\\n        k=K;\\n        memset(p,0,sizeof(p));\\n        memset(memo,-1,sizeof(memo));\\n\\n        n=s.size();\\n        for(int gap=0;gap<n;gap++)\\n        {\\n            for(int i=0,j=gap;j<n;i++,j++)\\n            {\\n                if(gap==0)\\n                {\\n                    p[i][j]=1;\\n                }\\n                else if(gap==1)\\n                {\\n                    p[i][j]=(s[i]==s[j]);\\n                }\\n                else\\n                {\\n                    if(s[i]==s[j]&&p[i+1][j-1])\\n                    {\\n                        p[i][j]=1;\\n                    }\\n                }\\n                    \\n            }\\n        }     \\n        return f(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int k;\\n    int n;\\n    int p[2001][2001];\\n    int memo[3000];\\n    int f(int idx)\\n    {\\n        if(idx>=n)\\n        {\\n            return 0;\\n        }\\n        if(memo[idx]!=-1)\\n        {\\n            return memo[idx];\\n        }\\n        int ans=0;\\n        for(int i=idx;i<n;i++)\\n        {\\n            if((i-idx+1>=k)&&p[idx][i])\\n            {\\n                ans=max(ans,1+f(i+1));\\n            }\\n        }\\n        ans=max(ans,f(idx+1));\\n        return memo[idx]=ans;\\n    }\\n    int maxPalindromes(string s, int K) \\n    {\\n        k=K;\\n        memset(p,0,sizeof(p));\\n        memset(memo,-1,sizeof(memo));\\n\\n        n=s.size();\\n        for(int gap=0;gap<n;gap++)\\n        {\\n            for(int i=0,j=gap;j<n;i++,j++)\\n            {\\n                if(gap==0)\\n                {\\n                    p[i][j]=1;\\n                }\\n                else if(gap==1)\\n                {\\n                    p[i][j]=(s[i]==s[j]);\\n                }\\n                else\\n                {\\n                    if(s[i]==s[j]&&p[i+1][j-1])\\n                    {\\n                        p[i][j]=1;\\n                    }\\n                }\\n                    \\n            }\\n        }     \\n        return f(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808992,
                "title": "java-o-n-solution-dp-manacher-s-algorithm",
                "content": "I implemented two different solution during the contest and even the brute force approach can pass all the test cases.\\nThus, I guess this problem shouldn\\'t be labeled as hard.\\n\\n#### Algorithm\\n* dp[i] means the maximum number of non-overlapping palindrome substrings from cs[i...n-1]\\n* Use brute-force or manacher\\'s algorithm to find out the palindrome substring that fulfills the requirement and build up the dp array by bottom-up approach.\\n```\\nclass Solution {\\n    public int maxPalindromes(String s, int min) {\\n        char[] cs = s.toCharArray();\\n        int n = cs.length;\\n        int[] odd = new int[n], even = new int[n], dp = new int[n + 1];\\n        for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n            int k = i > r ? 1 : Math.min(odd[l + r - i], r - i + 1);\\n            while (0 <= i - k && i + k < n && cs[i - k] == cs[i + k]) k++;\\n            odd[i] = k--;\\n            if (r < i + k) {\\n                r = i + k;\\n                l = i - k;\\n            }\\n        }\\n        for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n            int k = i > r ? 0 : Math.min(even[l + r - i + 1], r - i + 1);\\n            while (0 <= i - k - 1 && i + k < n && cs[i - k - 1] == cs[i + k]) k++;\\n            even[i] = k--;\\n            if (r < i + k) {\\n                r = i + k;\\n                l = i - k - 1;\\n            }\\n        }   \\n        for (int i = n - 1; 0 <= i; --i) {\\n            int diff = odd[i] * 2 - 1 - min;\\n            if (0 <= diff) {\\n                diff /= 2;  \\n                dp[i - odd[i] + 1 + diff] = Math.max(dp[i - odd[i] + 1 + diff], 1 + dp[i + odd[i] - diff]);\\n            }\\n            diff = even[i] * 2 - min;\\n            if (0 <= diff) {\\n                diff /= 2;\\n                dp[i - even[i] + diff] = Math.max(dp[i - even[i] + diff], 1 + dp[i + even[i] - diff]);\\n            }\\n            dp[i] = Math.max(dp[i], dp[i + 1]);\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n\\n#### O(N^2) Edition\\n```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        char[] cs = s.toCharArray();\\n        int n = cs.length;\\n        int[] dp = new int[n + 1];\\n        for (int i = n - 1; 0 <= i; --i) {\\n            int l = i, r = i;\\n            while (0 <= l - 1 && r + 1 < n && cs[l - 1] == cs[r + 1] && r - l + 1 < k) {\\n                l--;\\n                r++;\\n            }\\n            if (r - l + 1 >= k) dp[l] = Math.max(dp[l], 1 + dp[r + 1]);\\n            if (0 != i && cs[i - 1] == cs[i]) {\\n                l = i - 1;\\n                r = i;\\n                while (0 <= l - 1 && r + 1 < n && cs[l - 1] == cs[r + 1] && r - l + 1 < k) {\\n                    l--;\\n                    r++;\\n                }\\n                if (r - l + 1 >= k) dp[l] = Math.max(dp[l], 1 + dp[r + 1]);\\n            }\\n            dp[i] = Math.max(dp[i], dp[i + 1]);\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPalindromes(String s, int min) {\\n        char[] cs = s.toCharArray();\\n        int n = cs.length;\\n        int[] odd = new int[n], even = new int[n], dp = new int[n + 1];\\n        for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n            int k = i > r ? 1 : Math.min(odd[l + r - i], r - i + 1);\\n            while (0 <= i - k && i + k < n && cs[i - k] == cs[i + k]) k++;\\n            odd[i] = k--;\\n            if (r < i + k) {\\n                r = i + k;\\n                l = i - k;\\n            }\\n        }\\n        for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n            int k = i > r ? 0 : Math.min(even[l + r - i + 1], r - i + 1);\\n            while (0 <= i - k - 1 && i + k < n && cs[i - k - 1] == cs[i + k]) k++;\\n            even[i] = k--;\\n            if (r < i + k) {\\n                r = i + k;\\n                l = i - k - 1;\\n            }\\n        }   \\n        for (int i = n - 1; 0 <= i; --i) {\\n            int diff = odd[i] * 2 - 1 - min;\\n            if (0 <= diff) {\\n                diff /= 2;  \\n                dp[i - odd[i] + 1 + diff] = Math.max(dp[i - odd[i] + 1 + diff], 1 + dp[i + odd[i] - diff]);\\n            }\\n            diff = even[i] * 2 - min;\\n            if (0 <= diff) {\\n                diff /= 2;\\n                dp[i - even[i] + diff] = Math.max(dp[i - even[i] + diff], 1 + dp[i + even[i] - diff]);\\n            }\\n            dp[i] = Math.max(dp[i], dp[i + 1]);\\n        }\\n        return dp[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        char[] cs = s.toCharArray();\\n        int n = cs.length;\\n        int[] dp = new int[n + 1];\\n        for (int i = n - 1; 0 <= i; --i) {\\n            int l = i, r = i;\\n            while (0 <= l - 1 && r + 1 < n && cs[l - 1] == cs[r + 1] && r - l + 1 < k) {\\n                l--;\\n                r++;\\n            }\\n            if (r - l + 1 >= k) dp[l] = Math.max(dp[l], 1 + dp[r + 1]);\\n            if (0 != i && cs[i - 1] == cs[i]) {\\n                l = i - 1;\\n                r = i;\\n                while (0 <= l - 1 && r + 1 < n && cs[l - 1] == cs[r + 1] && r - l + 1 < k) {\\n                    l--;\\n                    r++;\\n                }\\n                if (r - l + 1 >= k) dp[l] = Math.max(dp[l], 1 + dp[r + 1]);\\n            }\\n            dp[i] = Math.max(dp[i], dp[i + 1]);\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809064,
                "title": "simple-longest-palindromic-substring-brute-force-c",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust find longest palindromic substring greedly in every substring>=K\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int longestPalSubstr(string str)\\n{\\n    int n = str.size();\\n    if (n < 2)\\n        return n;\\n    int maxLength = 1, start = 0;\\n    int low, high;\\n    for (int i = 0; i < n; i++) {\\n        low = i - 1;\\n        high = i + 1;\\n        while (high < n\\n               && str[high] == str[i])\\n            high++;\\n  \\n        while (low >= 0\\n               && str[low] == str[i])\\n            low--;\\n  \\n        while (low >= 0 && high < n\\n               && str[low] == str[high]) {\\n            low--;\\n            high++;\\n        }\\n  \\n        int length = high - low - 1;\\n        if (maxLength < length) {\\n            maxLength = length;\\n            start = low + 1;\\n        }\\n    }\\n    return maxLength;\\n}\\n    \\n    int maxPalindromes(string s, int k) {\\n        int ans=0;\\n        string st=\"\";\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            st.push_back(s[i]);\\n            if(st.size()>=k){\\n                if(longestPalSubstr(st)>=k){\\n                    st=\"\";\\n                    ans+=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int longestPalSubstr(string str)\\n{\\n    int n = str.size();\\n    if (n < 2)\\n        return n;\\n    int maxLength = 1, start = 0;\\n    int low, high;\\n    for (int i = 0; i < n; i++) {\\n        low = i - 1;\\n        high = i + 1;\\n        while (high < n\\n               && str[high] == str[i])\\n            high++;\\n  \\n        while (low >= 0\\n               && str[low] == str[i])\\n            low--;\\n  \\n        while (low >= 0 && high < n\\n               && str[low] == str[high]) {\\n            low--;\\n            high++;\\n        }\\n  \\n        int length = high - low - 1;\\n        if (maxLength < length) {\\n            maxLength = length;\\n            start = low + 1;\\n        }\\n    }\\n    return maxLength;\\n}\\n    \\n    int maxPalindromes(string s, int k) {\\n        int ans=0;\\n        string st=\"\";\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            st.push_back(s[i]);\\n            if(st.size()>=k){\\n                if(longestPalSubstr(st)>=k){\\n                    st=\"\";\\n                    ans+=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808801,
                "title": "c-dp-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPal(string &s,int i, int j){\\n        while(i < j){\\n            if(s[i++] != s[j--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\t// Simple pick/notpick dp function\\n    int solve(int i, vector<pair<int,int>>&arr,vector<int>&dp){\\n        if(i == arr.size()){\\n            return 0;\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int no = solve(i + 1, arr,dp);\\n        int yes = 0;\\n\\t\\t//if you pick the ith element and consider it a candidate for a palindrome substring, find the next index in the array which has a possible palindrome and is non-overlapping\\n        int lower = lower_bound(arr.begin(),arr.end(),make_pair(arr[i].second,0)) - arr.begin();\\n        if(lower < arr.size() && arr[lower].first == arr[i].second){\\n            lower++;\\n        }\\n        yes = 1+ solve(lower, arr,dp);\\n        return dp[i] = max(yes,no);\\n    }\\n    int maxPalindromes(string s, int k) {\\n        vector<pair<int,int>>temp;\\n        int n = s.size();\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(j - i + 1 >= k && isPal(s,i,j)){  //pair the shortest palindrome starting from i and ending with j \\n                    temp.push_back({i,j});\\n                    break;\\n                }\\n            }\\n        }\\n        int sz = temp.size();\\n        vector<int>dp(sz,-1);\\n        return solve(0,temp,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPal(string &s,int i, int j){\\n        while(i < j){\\n            if(s[i++] != s[j--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\t// Simple pick/notpick dp function\\n    int solve(int i, vector<pair<int,int>>&arr,vector<int>&dp){\\n        if(i == arr.size()){\\n            return 0;\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int no = solve(i + 1, arr,dp);\\n        int yes = 0;\\n\\t\\t//if you pick the ith element and consider it a candidate for a palindrome substring, find the next index in the array which has a possible palindrome and is non-overlapping\\n        int lower = lower_bound(arr.begin(),arr.end(),make_pair(arr[i].second,0)) - arr.begin();\\n        if(lower < arr.size() && arr[lower].first == arr[i].second){\\n            lower++;\\n        }\\n        yes = 1+ solve(lower, arr,dp);\\n        return dp[i] = max(yes,no);\\n    }\\n    int maxPalindromes(string s, int k) {\\n        vector<pair<int,int>>temp;\\n        int n = s.size();\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(j - i + 1 >= k && isPal(s,i,j)){  //pair the shortest palindrome starting from i and ending with j \\n                    temp.push_back({i,j});\\n                    break;\\n                }\\n            }\\n        }\\n        int sz = temp.size();\\n        vector<int>dp(sz,-1);\\n        return solve(0,temp,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827824,
                "title": "simple-c-solution-no-dp",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we observe that if any string which size is k+2 and string is palindrome then substring of that string whose size k is also palidrome so we check for substring whose size is k or k+1.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool cal(string str)\\n\\t{\\n\\t\\tstring tmp=str;\\n\\t\\treverse(str.begin(),str.end()); \\n\\t\\treturn str==tmp;\\n\\t}\\n    int maxPalindromes(string s, int k) {\\n        \\n        int n=s.size();\\n\\t\\tstring str=\"\";\\n\\t\\tint ans=0;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tstr+=s[i];\\n\\t\\t\\tif(str.size()==k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbool flag=cal(str);\\n\\t\\t\\t\\tif(flag)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr=\"\";\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(str.size()==k+1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbool flag=cal(str);\\n\\t\\t\\t\\tif(flag)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr=\"\";\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr.erase(str.begin());\\n\\t\\t\\t\\t\\tflag=cal(str);\\n\\t\\t\\t\\t\\tif(flag)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tstr=\"\";\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool cal(string str)\\n\\t{\\n\\t\\tstring tmp=str;\\n\\t\\treverse(str.begin(),str.end()); \\n\\t\\treturn str==tmp;\\n\\t}\\n    int maxPalindromes(string s, int k) {\\n        \\n        int n=s.size();\\n\\t\\tstring str=\"\";\\n\\t\\tint ans=0;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tstr+=s[i];\\n\\t\\t\\tif(str.size()==k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbool flag=cal(str);\\n\\t\\t\\t\\tif(flag)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr=\"\";\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(str.size()==k+1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbool flag=cal(str);\\n\\t\\t\\t\\tif(flag)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr=\"\";\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr.erase(str.begin());\\n\\t\\t\\t\\t\\tflag=cal(str);\\n\\t\\t\\t\\t\\tif(flag)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tstr=\"\";\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809487,
                "title": "c-dynamic-programming-memoization-explained-with-comments",
                "content": "```\\nclass Solution {\\n    vector<vector<bool>> is; // this 2-D vector is used to check whether substring from i to j is palindrome or not.\\n    int n;\\n    vector<int> dp;\\n    int solve(string& s, int i, int k) {\\n        // if we are at end of string we have 0 ans\\n        if(i >= n) return 0;\\n        \\n        // Using memoization.\\n        int &ans = dp[i];\\n        if(ans != -1) return ans;\\n        \\n        ans = 0;\\n        // from i we will chech each substring.\\n        for(int j = i; j < n; j++) {\\n            // if substring from i to j if palindrome and its size if >= k, then 1 count will add to ans otherwise, it will consider as gap and next substring or gap will calculated from j + 1.\\n            ans = max(ans, (is[i][j] && (j - i + 1 >= k)) + solve(s, j + 1, k));\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        n = s.size();\\n        \\n        is = vector<vector<bool>>(n, vector<bool>(n, false)); // let all substring be false;\\n        \\n        // precomputing palindromes using longest palindromic substring concept.\\n        for(int g = 0; g < n; g++) { // for each gap between i & j.\\n            int j = g;\\n            for(int i = 0; j < n; i++, j++) {\\n                // if gap is 0 then only one char is there and it is palindome.\\n                if(g == 0) is[i][j] = true;\\n                \\n                // if gap is 1, then if both are equal then it is palindrome. \\n                else if(g == 1) {\\n                    if(s[i] == s[j]) is[i][j] = true;\\n                }\\n                \\n                // if gap is > 1, then if s[i] and s[j] are equal, and its inner substring is palindrome then it is also palindrome.\\n                // ie. if substr from i + 1 to j - 1 is palindrome and i & j are equal.\\n                else {\\n                    if(s[i] == s[j] && is[i + 1][j - 1]) is[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        // Initialising DP\\n        dp = vector<int>(n + 1, -1);\\n        \\n        return solve(s, 0, k);\\n    }\\n};\\n```\\n\\nPlease **upvote** if you find it helpful!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<bool>> is; // this 2-D vector is used to check whether substring from i to j is palindrome or not.\\n    int n;\\n    vector<int> dp;\\n    int solve(string& s, int i, int k) {\\n        // if we are at end of string we have 0 ans\\n        if(i >= n) return 0;\\n        \\n        // Using memoization.\\n        int &ans = dp[i];\\n        if(ans != -1) return ans;\\n        \\n        ans = 0;\\n        // from i we will chech each substring.\\n        for(int j = i; j < n; j++) {\\n            // if substring from i to j if palindrome and its size if >= k, then 1 count will add to ans otherwise, it will consider as gap and next substring or gap will calculated from j + 1.\\n            ans = max(ans, (is[i][j] && (j - i + 1 >= k)) + solve(s, j + 1, k));\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        n = s.size();\\n        \\n        is = vector<vector<bool>>(n, vector<bool>(n, false)); // let all substring be false;\\n        \\n        // precomputing palindromes using longest palindromic substring concept.\\n        for(int g = 0; g < n; g++) { // for each gap between i & j.\\n            int j = g;\\n            for(int i = 0; j < n; i++, j++) {\\n                // if gap is 0 then only one char is there and it is palindome.\\n                if(g == 0) is[i][j] = true;\\n                \\n                // if gap is 1, then if both are equal then it is palindrome. \\n                else if(g == 1) {\\n                    if(s[i] == s[j]) is[i][j] = true;\\n                }\\n                \\n                // if gap is > 1, then if s[i] and s[j] are equal, and its inner substring is palindrome then it is also palindrome.\\n                // ie. if substr from i + 1 to j - 1 is palindrome and i & j are equal.\\n                else {\\n                    if(s[i] == s[j] && is[i + 1][j - 1]) is[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        // Initialising DP\\n        dp = vector<int>(n + 1, -1);\\n        \\n        return solve(s, 0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820349,
                "title": "easiest-2d-dp-and-1d-dp",
                "content": "```\\n\\t//2d dp if number is pal or not \\n\\tint ispal[2001][2001]={0};\\n\\t//1d dp for for optimizing recursion\\n    int dp[2001];\\n    int n;//length of string\\n    int fun(int index,int k)\\n    {\\n        if(index>=n)\\n            return 0;\\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int ans=0;\\n        for(int i=index+k-1;i<n;i++)\\n            ans=max(ans,fun(i+1,k)+ispal[index][i]);\\n        ans=max(ans,fun(index+1,k));\\n        return dp[index]=ans;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        n=s.length();\\n\\t\\t//now just read carefully this part enter value of substring as 1 if palindrome and 0 if not\\n\\t\\t//like eg abaccddb then ispal[0][2]=1 because aba is a palindrome.\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=-1;\\n            ispal[i][i]=1;\\n            if(i+1<n&&s[i]==s[i+1])\\n                pal[i][i+1]=1;\\n        }\\n        int gap=2;\\n        while(gap<n)\\n        {\\n            for(int i=0;i+gap<n;i++)\\n            {\\n                if(s[i]==s[i+gap]&&ispal[i+1][i+gap-1])\\n                   ispal[i][i+gap]=1;\\n            }\\n            gap++;\\n        }\\n\\t\\t//ispal created now just return ans\\n        return fun(0,k);\\n    }\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n\\t//2d dp if number is pal or not \\n\\tint ispal[2001][2001]={0};\\n\\t//1d dp for for optimizing recursion\\n    int dp[2001];\\n    int n;//length of string\\n    int fun(int index,int k)\\n    {\\n        if(index>=n)\\n            return 0;\\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int ans=0;\\n        for(int i=index+k-1;i<n;i++)\\n            ans=max(ans,fun(i+1,k)+ispal[index][i]);\\n        ans=max(ans,fun(index+1,k));\\n        return dp[index]=ans;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        n=s.length();\\n\\t\\t//now just read carefully this part enter value of substring as 1 if palindrome and 0 if not\\n\\t\\t//like eg abaccddb then ispal[0][2]=1 because aba is a palindrome.\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=-1;\\n            ispal[i][i]=1;\\n            if(i+1<n&&s[i]==s[i+1])\\n                pal[i][i+1]=1;\\n        }\\n        int gap=2;\\n        while(gap<n)\\n        {\\n            for(int i=0;i+gap<n;i++)\\n            {\\n                if(s[i]==s[i+gap]&&ispal[i+1][i+gap-1])\\n                   ispal[i][i+gap]=1;\\n            }\\n            gap++;\\n        }\\n\\t\\t//ispal created now just return ans\\n        return fun(0,k);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2811155,
                "title": "c-recursion-memoization-dynamic-programming",
                "content": "**Approach:- Checking each possibility through recursion,and doing  memoization after that.**\\n```\\n\\u2705 C++ || recursion || memoization || dynamic programming\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool isPal(string &s,int i,int j){\\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n    int solve(int i,int j,string &s,int k){\\n        if(j>=s.size() || i>=s.size())return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(isPal(s,i,j)){\\n            return dp[i][j]=max(solve(i,j+1,s,k),max(solve(j+1,j+k,s,k)+1,solve(i+1,j+1,s,k)));\\n        }\\n        return dp[i][j]=max(solve(i+1,j+1,s,k),solve(i,j+1,s,k));\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n=s.size();\\n        if(k==1)return n;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,k-1,s,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\u2705 C++ || recursion || memoization || dynamic programming\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool isPal(string &s,int i,int j){\\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n    int solve(int i,int j,string &s,int k){\\n        if(j>=s.size() || i>=s.size())return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(isPal(s,i,j)){\\n            return dp[i][j]=max(solve(i,j+1,s,k),max(solve(j+1,j+k,s,k)+1,solve(i+1,j+1,s,k)));\\n        }\\n        return dp[i][j]=max(solve(i+1,j+1,s,k),solve(i,j+1,s,k));\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n=s.size();\\n        if(k==1)return n;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,k-1,s,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809466,
                "title": "dp-solution-o-n-2-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst approach which hit our mind is to find all palindrome substrings starting from an index.\\n\\nThen calculate maximum no. of partition, we can get considering each possible substrings for an index.\\n\\neg: `[abababcdc]` , `k = 3`\\npossible palindrome substring for index:\\n0 : `a` , `aba` , `ababa`\\n1 : `b` , `bab` , `babab`\\n2 : `a` , `aba `\\n3 : `b` , `bab `\\n4 : `a`\\n5 : `b`\\n6 : `c`, `cdc`\\n7 : `d`\\n8 : `c`\\n\\ns = `[abababcdc]`\\nstarting at index 8, maximum possible palidrome substring partioning of size>=3 : 0,\\nstarting at index 7, maximum possible palidrome substring partioning of size>=3 : 0,  \\nstarting at index 6, maximum possible palidrome substring partioning of size>=3 : 1 (**cdc**)\\nstarting at index 5 : 1 (.**cdc**), \\nstarting at index 4 : 1 (..**cdc**),\\nstarting at index 3 : 2 (**bab** **cdc**),\\nstarting at index 2 : 2 (**aba** b **cdc**),\\nstarting at index 1 : 2 (**babab** **cdc**) or (**bab** ab **cac**) \\nstarting at index 0 : 3 max (**ababa** b **cdc**) and (**aba** **bab** **cac**) \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAbove solution will give TLE $$O(n)^3$$.\\nSo to calculate possible palindrome substring we will use a property that :\\n\\n```\\nfor a substring s( i , j ) to be palindrome,\\ns( i+1 , j-1 ) must be palindrome. \\n```\\n\\nin above example `abababcdc`\\nsustring bab is palindrome because **a** is  palindrome.\\n\\n---\\n\\n\\nTake a 2-d array (**pd**) to maintain length of palindromes starting at index i and a dp array to store count of **maximum number of palindrome substring partitioning possible starting from ith index.**\\n\\nIn above example dp array will be like : `3 2 2 2 1 1 1 0 0`\\nand **pd** 2-d array be like:\\npd[0]  = `0 1 3 5`,\\npd[1]  = `0 1 3 5`,\\npd[2]  = `0 1 3`,\\npd[3]  = `0 1 3`,\\npd[4]  = `0 1`,\\npd[5]  = `0 1`, ... so on.\\n\\nSo for index i, calculate palindrome substrings by considering length (len) of palindromic substrings starting at index i+1 . Then check whether s[i]==s[ i + len + 1 ] , if yes , then push len+2 to pd[i].\\nCalculate dp[i] = max(dp[i] , 1 + dp[i+len+2])\\ndp[i+len+2] is taken because we considered one substring (i,i+len+1) so, rest are to be chosen from s(i+len+1 + 1 , n);\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.length();\\n        if(k==1)return n;\\n\\n        vector<vector<int>>pd(n+1);\\n        vector<int> dp(n+1,0);\\n        for(int i =0 ;i<=n; i++){\\n            pd[i].push_back(0);\\n            pd[i].push_back(1); \\n        }       \\n\\n        for(int i = n-2 ; i>=0 ;i--){       \\n           for(auto len : pd[i+1]){                         \\n               int toCheck = i+len+1;\\n               if(toCheck<n){\\n                   if(s[toCheck]==s[i]){                       \\n                       pd[i].push_back(len+2);\\n                       if(len+2>=k)\\n                        dp[i] = max(dp[i] , 1+dp[toCheck+1]);\\n                   }\\n               } \\n           }\\n           \\n           dp[i] = max(dp[i] , dp[i+1]);\\n        }   \\n       return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nfor a substring s( i , j ) to be palindrome,\\ns( i+1 , j-1 ) must be palindrome. \\n```\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.length();\\n        if(k==1)return n;\\n\\n        vector<vector<int>>pd(n+1);\\n        vector<int> dp(n+1,0);\\n        for(int i =0 ;i<=n; i++){\\n            pd[i].push_back(0);\\n            pd[i].push_back(1); \\n        }       \\n\\n        for(int i = n-2 ; i>=0 ;i--){       \\n           for(auto len : pd[i+1]){                         \\n               int toCheck = i+len+1;\\n               if(toCheck<n){\\n                   if(s[toCheck]==s[i]){                       \\n                       pd[i].push_back(len+2);\\n                       if(len+2>=k)\\n                        dp[i] = max(dp[i] , 1+dp[toCheck+1]);\\n                   }\\n               } \\n           }\\n           \\n           dp[i] = max(dp[i] , dp[i+1]);\\n        }   \\n       return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809034,
                "title": "c-dp-recursion-memoization-easy-to-understand-o-n-n",
                "content": "## Approach\\n<hr>\\nLet us first get all the palindromic substring, to do this:\\n\\n1. Lets say we are checking palindromic substrings of length `n`, for index `i` to `j`, then, if `s[i] == s[j]` && `isPalindrome[i+1][j-1]`, we can set `isPalindrome[i][j] = 1`\\n\\nWe are essentially checking palindromes of length `n-2`, we can construct isPalindome in a bottom up manner\\n\\nBase case:\\n`isPalindrome[i][i] = 1`\\n`if s[i] == s[i+1] isPalindrome[i][i+1] = 1`\\n\\nNow that we have all the palindromic substrings, we can think of a recursive way to solve this problem. Consider the following recursive problem:\\n1. If we are at an index `i`, include a palindromic substring of `length >= k` ending at `j` and go to index `j+1`\\n2. Skip index `i`\\n\\nBase case:\\nif index `i == n`, return `0`\\n\\nLets keep a variable `ans` initialized to `0`\\ncase 1:\\n```cpp\\nfor(int j = i+k-1;j<n;j++){\\n    if(pal[i][j]){\\n        ans = max(ans, 1 + recurse(j+1));\\n    }\\n}\\n```\\ncase 2:\\n```cpp\\nans = max(ans, recurse(i+1));\\n```\\n\\nFinally we can memoize this recursion since there are repeating subproblems.\\n\\n## Code\\n<hr>\\n\\n```cpp\\nint dp[2001];\\nint recurse(int i, vector<vector<bool>>& pal, int k, int n){\\n    if(dp[i] != -1) return dp[i];\\n    if(i == n) return dp[i] = 0;\\n    int ans = 0;\\n    for(int j = i+k-1;j<n;j++){\\n        if(pal[i][j]){\\n            ans = max(ans, 1 + recurse(j+1, pal, k, n));\\n        }\\n    }\\n    ans = max(ans, recurse(i+1, pal, k, n));\\n    return dp[i] = ans;\\n}\\n\\nint maxPalindromes(string s, int k) {\\n    int n = s.length();\\n    string curr;\\n    for(int i = 0;i<2001;i++) dp[i] = -1;\\n    vector<vector<bool>> pal(n, vector<bool>(n, 0));\\n    for(int i = 0;i<n;i++) pal[i][i] = 1;\\n    for(int i = 0;i<n-1;i++){\\n        if(s[i] == s[i+1]) pal[i][i+1] = 1;\\n    }\\n    for(int i = 3;i<=n;i++){\\n        for(int j = 0;j<n-(i-1);j++){\\n            if(s[j] == s[j + i-1] && pal[j+1][j+i-2]){\\n                pal[j][j+i-1] = 1;\\n            }\\n        }\\n    }\\n    return recurse(0, pal, k, n);\\n}\\n```\\n\\nTime: `O(n*n)`\\nSpace: `O(n*n)`\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```cpp\\nfor(int j = i+k-1;j<n;j++){\\n    if(pal[i][j]){\\n        ans = max(ans, 1 + recurse(j+1));\\n    }\\n}\\n```\n```cpp\\nans = max(ans, recurse(i+1));\\n```\n```cpp\\nint dp[2001];\\nint recurse(int i, vector<vector<bool>>& pal, int k, int n){\\n    if(dp[i] != -1) return dp[i];\\n    if(i == n) return dp[i] = 0;\\n    int ans = 0;\\n    for(int j = i+k-1;j<n;j++){\\n        if(pal[i][j]){\\n            ans = max(ans, 1 + recurse(j+1, pal, k, n));\\n        }\\n    }\\n    ans = max(ans, recurse(i+1, pal, k, n));\\n    return dp[i] = ans;\\n}\\n\\nint maxPalindromes(string s, int k) {\\n    int n = s.length();\\n    string curr;\\n    for(int i = 0;i<2001;i++) dp[i] = -1;\\n    vector<vector<bool>> pal(n, vector<bool>(n, 0));\\n    for(int i = 0;i<n;i++) pal[i][i] = 1;\\n    for(int i = 0;i<n-1;i++){\\n        if(s[i] == s[i+1]) pal[i][i+1] = 1;\\n    }\\n    for(int i = 3;i<=n;i++){\\n        for(int j = 0;j<n-(i-1);j++){\\n            if(s[j] == s[j + i-1] && pal[j+1][j+i-2]){\\n                pal[j][j+i-1] = 1;\\n            }\\n        }\\n    }\\n    return recurse(0, pal, k, n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808934,
                "title": "easy-dp-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs it is a maximum/minimum type of problem with n number of solutions possible its tell us we need to use recursion and to optimize it we use dp.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to check from an given index how many strings of length k are there which are plaindrome, then we given function calls for the plaindromic strings from index j+1 given palindromic string is from index i to index j. Later we also give the function call of i+1 for skipping the current character. \\nWe need to include a check that if alll charcters in a string are same then we can directly return maximum number of possible non-overlapping substrings is length of string/k.\\n\\n# Complexity\\n- Time complexity: O(length(s))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(length(s))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        //To check if all the chaarcter in string are same\\n        HashSet<Character> set=new HashSet<Character>();\\n        for(int i=0;i<s.length();i++){\\n            set.add(s.charAt(i));\\n        }\\n        //If all characters are same we can have maximum answer\\n        if(set.size()==1){\\n            return s.length()/k;\\n        }\\n        //Initialize a dp of size 2001\\n        int[] dp=new int[2001];\\n        //Fill the dp by -1 indicating value not calculated yet\\n        Arrays.fill(dp,-1);\\n        return helper(s,dp,0,k);\\n    }\\n    public int helper(String s,int[] dp,int i,int k){\\n        //If starting index greater then length of string return 0\\n        if(i>=s.length()){\\n            return 0;\\n        }\\n        int ans=0;\\n        //If value calculated before then directly return it\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        for(int j=i+k-1;j<s.length();j++){\\n            //Check if a given substring from index i to j is a palindrome\\n            boolean palindrome=pal(s,i,j,k);\\n            //If palindrome give function call from index j+1\\n            if(palindrome){\\n                ans=Math.max(ans,1+helper(s,dp,j+1,k));\\n            }\\n        }\\n        //If we skip the current charcter then giving function call for index i+1\\n        ans=Math.max(ans,helper(s,dp,i+1,k));\\n        //Storing the maximum of all in ans and storing in dp array\\n        dp[i]=ans;\\n        return ans;\\n    }\\n    public boolean pal(String s,int a,int b,int k){\\n        //If lastIndex greater than length of string return false\\n        if(b>=s.length()){\\n            return false;\\n        }\\n        int freq=0;\\n        int length=b-a+1;\\n        //Check if string is palindrome, if palindrome return true else return false\\n        for(int j=a;j<a+length/2;j++){\\n            if(s.charAt(j)!=s.charAt(b-freq)){\\n                return false;\\n            }\\n            ++freq;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        //To check if all the chaarcter in string are same\\n        HashSet<Character> set=new HashSet<Character>();\\n        for(int i=0;i<s.length();i++){\\n            set.add(s.charAt(i));\\n        }\\n        //If all characters are same we can have maximum answer\\n        if(set.size()==1){\\n            return s.length()/k;\\n        }\\n        //Initialize a dp of size 2001\\n        int[] dp=new int[2001];\\n        //Fill the dp by -1 indicating value not calculated yet\\n        Arrays.fill(dp,-1);\\n        return helper(s,dp,0,k);\\n    }\\n    public int helper(String s,int[] dp,int i,int k){\\n        //If starting index greater then length of string return 0\\n        if(i>=s.length()){\\n            return 0;\\n        }\\n        int ans=0;\\n        //If value calculated before then directly return it\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        for(int j=i+k-1;j<s.length();j++){\\n            //Check if a given substring from index i to j is a palindrome\\n            boolean palindrome=pal(s,i,j,k);\\n            //If palindrome give function call from index j+1\\n            if(palindrome){\\n                ans=Math.max(ans,1+helper(s,dp,j+1,k));\\n            }\\n        }\\n        //If we skip the current charcter then giving function call for index i+1\\n        ans=Math.max(ans,helper(s,dp,i+1,k));\\n        //Storing the maximum of all in ans and storing in dp array\\n        dp[i]=ans;\\n        return ans;\\n    }\\n    public boolean pal(String s,int a,int b,int k){\\n        //If lastIndex greater than length of string return false\\n        if(b>=s.length()){\\n            return false;\\n        }\\n        int freq=0;\\n        int length=b-a+1;\\n        //Check if string is palindrome, if palindrome return true else return false\\n        for(int j=a;j<a+length/2;j++){\\n            if(s.charAt(j)!=s.charAt(b-freq)){\\n                return false;\\n            }\\n            ++freq;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808821,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    int start = 0;\\n    int count = 0;\\n    \\n    public int maxPalindromes(String s, int k) {\\n        for(int i=0; i<s.length(); i++) {\\n            helper(s, i, i, k);\\n            helper(s, i, i+1, k);\\n        }\\n        \\n        return count;\\n    }\\n    \\n    void helper(String s, int i, int j, int k) {\\n        while(i >= start && j < s.length()) {\\n            if(s.charAt(i) != s.charAt(j)) break;\\n            if(j-i+1 >= k) {\\n                count++;\\n                start = j+1;\\n                break;\\n            }\\n            i--;\\n            j++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int start = 0;\\n    int count = 0;\\n    \\n    public int maxPalindromes(String s, int k) {\\n        for(int i=0; i<s.length(); i++) {\\n            helper(s, i, i, k);\\n            helper(s, i, i+1, k);\\n        }\\n        \\n        return count;\\n    }\\n    \\n    void helper(String s, int i, int j, int k) {\\n        while(i >= start && j < s.length()) {\\n            if(s.charAt(i) != s.charAt(j)) break;\\n            if(j-i+1 >= k) {\\n                count++;\\n                start = j+1;\\n                break;\\n            }\\n            i--;\\n            j++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316975,
                "title": "c-sliding-window-approach-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    bool isPalindrome(string s, int i, int j){\\n        while(i<j){\\n            if(s[i++]!=s[j--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int ans = 0;\\n        for(int i=0; i<s.length(); i++){\\n            for(int j=i; j<s.length(); j++){\\n                int len= j-i+1;\\n                if(len>k+1){\\n                    break;\\n                }\\n                if(len>=k and isPalindrome(s, i, j)){\\n                    ans++; \\n                    i=j;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    bool isPalindrome(string s, int i, int j){\\n        while(i<j){\\n            if(s[i++]!=s[j--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int ans = 0;\\n        for(int i=0; i<s.length(); i++){\\n            for(int j=i; j<s.length(); j++){\\n                int len= j-i+1;\\n                if(len>k+1){\\n                    break;\\n                }\\n                if(len>=k and isPalindrome(s, i, j)){\\n                    ans++; \\n                    i=j;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832974,
                "title": "python3-memoization",
                "content": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        n=len(s)\\n        def checkIfPalindrome(i,j):\\n            while i<j:\\n                if s[i]!=s[j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        @lru_cache(2000)\\n        def dp(i,j):\\n            if i>=n or j>=n or (j-i)>k+1:\\n                return 0\\n            if s[i]==s[j]:\\n                if checkIfPalindrome(i,j):\\n                    return 1+dp(j+1,j+k)\\n            return max(dp(i,j+1),dp(i+1,j+1))\\n        return dp(0,k-1)\\n    \\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        n=len(s)\\n        def checkIfPalindrome(i,j):\\n            while i<j:\\n                if s[i]!=s[j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        @lru_cache(2000)\\n        def dp(i,j):\\n            if i>=n or j>=n or (j-i)>k+1:\\n                return 0\\n            if s[i]==s[j]:\\n                if checkIfPalindrome(i,j):\\n                    return 1+dp(j+1,j+k)\\n            return max(dp(i,j+1),dp(i+1,j+1))\\n        return dp(0,k-1)\\n    \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821912,
                "title": "c-dp-greedy-most-intuitive-solution-easy-to-understand",
                "content": "You can check for each index ```j``` what all are the index ```i``` for which ```i-j``` is a palindrome and store it in a map ```(O(n^2))```. Now using top down, check for each index ```i``` what can be a possible selection of ```j``` using the map, and call again recursively on ```j-1``` (Note that if ```j-1<0``` then you need to return ```0```). You also need to consider the case where you can\\'t or you don\\'t use the character at place ```i```. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    unordered_map<int,vector<int>> mp;\\n    vector<int> mem;\\n    \\n    bool isPal(int i, int j, string &s){\\n        if(i==j){\\n            return dp[i][j] = 1;\\n        }\\n        if(i==j-1){\\n            return dp[i][j] = s[i]==s[j];\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(s[i]==s[j]){\\n            return dp[i][j] = isPal(i+1,j-1,s);\\n        }\\n        return dp[i][j] = 0;\\n    }\\n    \\n    int solve(int i, string &s){\\n        if(i<0){\\n            return 0;\\n        }\\n        if(mem[i]!=-1){\\n            return mem[i];\\n        }\\n        if(mp.count(i)){\\n            int ans = 0;\\n            for(int j : mp[i]){\\n                ans = max(ans,solve(j-1,s)+1);\\n            }\\n            ans = max(ans,solve(i-1,s));\\n            return mem[i] = ans;\\n        }else{\\n            return mem[i] = solve(i-1,s);\\n        }\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n = s.length();\\n        dp.resize(n+1, vector<int>(n+1,-1));\\n        mp.clear();\\n        for(int i = 0; i<n; i++){\\n            for(int j = i; j<n; j++){\\n                if(isPal(i,j,s) && j-i+1>=k){\\n                    mp[j].push_back(i);\\n                }\\n            }\\n        }\\n        mem.resize(n,-1);\\n        return solve(n-1,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```j```\n```i```\n```i-j```\n```(O(n^2))```\n```i```\n```j```\n```j-1```\n```j-1<0```\n```0```\n```i```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    unordered_map<int,vector<int>> mp;\\n    vector<int> mem;\\n    \\n    bool isPal(int i, int j, string &s){\\n        if(i==j){\\n            return dp[i][j] = 1;\\n        }\\n        if(i==j-1){\\n            return dp[i][j] = s[i]==s[j];\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(s[i]==s[j]){\\n            return dp[i][j] = isPal(i+1,j-1,s);\\n        }\\n        return dp[i][j] = 0;\\n    }\\n    \\n    int solve(int i, string &s){\\n        if(i<0){\\n            return 0;\\n        }\\n        if(mem[i]!=-1){\\n            return mem[i];\\n        }\\n        if(mp.count(i)){\\n            int ans = 0;\\n            for(int j : mp[i]){\\n                ans = max(ans,solve(j-1,s)+1);\\n            }\\n            ans = max(ans,solve(i-1,s));\\n            return mem[i] = ans;\\n        }else{\\n            return mem[i] = solve(i-1,s);\\n        }\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n = s.length();\\n        dp.resize(n+1, vector<int>(n+1,-1));\\n        mp.clear();\\n        for(int i = 0; i<n; i++){\\n            for(int j = i; j<n; j++){\\n                if(isPal(i,j,s) && j-i+1>=k){\\n                    mp[j].push_back(i);\\n                }\\n            }\\n        }\\n        mem.resize(n,-1);\\n        return solve(n-1,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814448,
                "title": "simplest-greedy-python-solution-o-1-space-o-n-k-time",
                "content": "# Intuition\\nIf there is a substring of size k + 2 which is a palindrome, then for sure there is a substring of size k which is a palindrome. Similarly, if there is a substring of size k + 3 which is a palindrome, then there is a substring of size k + 1 which is a palindrome.\\n\\n# Approach\\nSo we can **greedily** start from 0th index and check for a substring of size k which is a palindrome, if not then size k + 1. *Then our new start index is either k or k + 1 based on which is a palindrome* and we can proceed similarly. *If both are not a palindrome then for sure we can\\'t find any palindrome starting from that index*, so we move to next index.\\n\\n# Complexity\\n- Time complexity:\\n    **O(nk)**\\n    O(n) for traversing the string and a factor of **\"k\" on each index** for checking whether s[i to i + k] its a palindrome or not by using the valid function.\\n\\n- Space complexity:\\n    **O(1)**\\n\\n# Code\\n```\\nclass Solution:\\n    \\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        n = len(s)\\n        # function to check whether substring is a palindrome\\n        def valid(i, j):\\n            # if end index is greater then length of string\\n            if j > len(s):\\n                return False\\n            if s[i : j] == s[i : j][::-1]:\\n                return True\\n            return False\\n        maxSubstrings = 0\\n        start = 0\\n        while start < n:\\n            if valid(start, start + k):\\n                maxSubstrings += 1\\n                start += k\\n            elif valid(start, start + k + 1):\\n                maxSubstrings += 1\\n                start += k + 1\\n            else:\\n                # when there is no palindrome starting at that particular index   \\n                start += 1\\n        return maxSubstrings\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        n = len(s)\\n        # function to check whether substring is a palindrome\\n        def valid(i, j):\\n            # if end index is greater then length of string\\n            if j > len(s):\\n                return False\\n            if s[i : j] == s[i : j][::-1]:\\n                return True\\n            return False\\n        maxSubstrings = 0\\n        start = 0\\n        while start < n:\\n            if valid(start, start + k):\\n                maxSubstrings += 1\\n                start += k\\n            elif valid(start, start + k + 1):\\n                maxSubstrings += 1\\n                start += k + 1\\n            else:\\n                # when there is no palindrome starting at that particular index   \\n                start += 1\\n        return maxSubstrings\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811830,
                "title": "python-very-simple-solution-o-n-no-dp",
                "content": "## Intuition\\nSimilar to 647 https://leetcode.com/problems/palindromic-substrings/\\nJust need to add the constraint - non-overlapping\\n\\n## Approach\\nExpand from centers to make the time complexity O(N), space complexity O(1)\\nOnly count the palindrome with shortest length (>=k)\\nKeep track of the last end position to avoid overlapping\\n\\n## Code\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        res = 0\\n        lastp = -1\\n\\n        def helper(l, r):\\n            nonlocal lastp, res\\n            while l >= 0 and r < len(s) and s[l] == s[r] and l > lastp:\\n                if r-l+1 >= k:\\n                    res += 1\\n                    lastp = r\\n                    break # find the shortest palindrome\\n                else:\\n                    l -= 1\\n                    r += 1\\n        \\n        for i in range(len(s)):\\n            helper(i, i)  # odd length\\n            helper(i, i+1)  # even length\\n        return res          \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        res = 0\\n        lastp = -1\\n\\n        def helper(l, r):\\n            nonlocal lastp, res\\n            while l >= 0 and r < len(s) and s[l] == s[r] and l > lastp:\\n                if r-l+1 >= k:\\n                    res += 1\\n                    lastp = r\\n                    break # find the shortest palindrome\\n                else:\\n                    l -= 1\\n                    r += 1\\n        \\n        for i in range(len(s)):\\n            helper(i, i)  # odd length\\n            helper(i, i+1)  # even length\\n        return res          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809882,
                "title": "o-n-solution-with-manacher-s-algorithm-checking-the-shortest-palindrome-of-any-given-center",
                "content": "# Intuition\\n[Manacher\\'s algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher\\'s_algorithm) computes the longest palindrome of all possible centers in linear time. Combined with the fact that the shortest palindrome that starts later and ends earlier is always preferred since the answer up to an index increases monotonically, we get O(n) solution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Call `manacher(s)`\\n2. Go through the returned list. For centers whose palindromes can be at least `k` characters long, update the last neighbor of end index `i + length // 2`.\\n3. Construct `dp`, padded to make sure that index `-1` refers to the answer up to an empty string (zero), one index at a time by taking the `max()` between the prior index and `1 + dp[last_neighbor]` if applicable.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\ndef manacher(s):\\n    t = \\'#\\'.join(\\'^\\' + s + \\'\\n```)\\n    p = [0] * len(t)\\n    c = r = 0\\n    for i in range(2, len(t) - 2):\\n        p[i] = int(r > i) and min(r - i, p[2 * c - i])\\n        while t[i + p[i] + 1] == t[i - p[i] - 1]:\\n            p[i] += 1\\n        if i + p[i] > r:\\n            c, r = i, i + p[i]\\n    return p\\n\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        p = manacher(s)[2:-2]\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n        adj = [-math.inf] * n\\n        for j in range(len(p)):\\n            i = j // 2\\n            if not j % 2:\\n                length = k + (not k % 2)\\n                if length <= p[j]:\\n                    adj[i + length // 2] = max(adj[i + length // 2], i - length // 2 - 1)\\n            else:\\n                length = k + k % 2\\n                if length <= p[j]:\\n                    adj[i + length // 2] = max(adj[i + length // 2], i - length // 2)\\n        for i in range(n):\\n            dp[i] = max(dp[i - 1], 1 + dp[adj[i]] if adj[i] > -math.inf else 0)\\n        return dp[n - 1]\\n                    \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef manacher(s):\\n    t = \\'#\\'.join(\\'^\\' + s + \\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2808831,
                "title": "dp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<bool>> isPalindrome(string& s){\\n        int n = s.size();\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        \\n        for(int i=0; i<n; i++){\\n            dp[i][i] = true;\\n        }\\n        \\n        for(int i=0; i<n-1; i++){\\n            if(s[i] == s[i+1]){\\n                dp[i][i+1] = true;\\n            }\\n        }\\n        \\n        int k = 2;\\n        \\n        while(k < n){\\n            int i=0;\\n            int j=k;\\n            \\n            while(j<n){\\n                if(s[i] == s[j] and dp[i+1][j-1]){\\n                    dp[i][j] = true;\\n                }\\n                \\n                i++;\\n                j++;\\n            }\\n            \\n            k++;\\n        }\\n        \\n        return dp;\\n    }\\n    \\n    int maxPalindromes(string s, int k) {\\n        // get the dp table for palindrome\\n        vector<vector<bool>> isPalin = isPalindrome(s);\\n        vector<int> memo(s.size()+1, -1);\\n        \\n        function<int(int)> solve = [&](int i) {\\n            // base cases\\n            if(i >= s.size()) return 0;\\n            if(memo[i] != -1) return memo[i];\\n            \\n            // skip the current index\\n            int result = solve(i+1);\\n            \\n            // consider segments having length greater than or equal to k\\n            for(int j=i+k; j<=s.size(); j++) {\\n                if(isPalin[i][j-1]) result = max(result, solve(j)+1);\\n            }\\n            \\n            return memo[i] = result;\\n        };\\n        \\n        return solve(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<bool>> isPalindrome(string& s){\\n        int n = s.size();\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        \\n        for(int i=0; i<n; i++){\\n            dp[i][i] = true;\\n        }\\n        \\n        for(int i=0; i<n-1; i++){\\n            if(s[i] == s[i+1]){\\n                dp[i][i+1] = true;\\n            }\\n        }\\n        \\n        int k = 2;\\n        \\n        while(k < n){\\n            int i=0;\\n            int j=k;\\n            \\n            while(j<n){\\n                if(s[i] == s[j] and dp[i+1][j-1]){\\n                    dp[i][j] = true;\\n                }\\n                \\n                i++;\\n                j++;\\n            }\\n            \\n            k++;\\n        }\\n        \\n        return dp;\\n    }\\n    \\n    int maxPalindromes(string s, int k) {\\n        // get the dp table for palindrome\\n        vector<vector<bool>> isPalin = isPalindrome(s);\\n        vector<int> memo(s.size()+1, -1);\\n        \\n        function<int(int)> solve = [&](int i) {\\n            // base cases\\n            if(i >= s.size()) return 0;\\n            if(memo[i] != -1) return memo[i];\\n            \\n            // skip the current index\\n            int result = solve(i+1);\\n            \\n            // consider segments having length greater than or equal to k\\n            for(int j=i+k; j<=s.size(); j++) {\\n                if(isPalin[i][j-1]) result = max(result, solve(j)+1);\\n            }\\n            \\n            return memo[i] = result;\\n        };\\n        \\n        return solve(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881998,
                "title": "recursion-memoization-1d-dp",
                "content": "# Complexity\\n- Time complexity:\\n    O (n * k)\\n\\n- Space complexity:\\n    O (n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f (int i, int j, int &k, string &s, vector <bool> &dp)\\n    {\\n        if (i < 0 || j >= s.size ())\\n            return 0;    //Out of bounds base case\\n\\n        if (s [i] != s [j] || dp [i] || dp [j])\\n            return 0;    //Not a valid option if ith and jth char don\\'t match or overlap with another already found palindrome\\n\\n        if (j - i + 1 >= k)\\n        {\\n            for (int x = i; x <= j; x++)\\n                dp [x] = true;\\n            return 1;   //Obtain a palindrome string of size at least k\\n        }\\n\\n        return f (i - 1, j + 1, k, s, dp); //Recursive call\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int cnt = 0;\\n        int n = s.size ();\\n        vector <bool> dp (n, false);\\n\\n        for (int i = 0; i < n; i++)\\n        {   \\n            if (!dp [i])\\n                cnt += f (i, i, k, s, dp);     //Odd length palindrome\\n            if (i < n - 1 && (s [i] == s [i + 1]) && !dp [i] && !dp [i + 1])\\n                cnt += f (i, i + 1, k, s, dp); //Even length palindrome\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f (int i, int j, int &k, string &s, vector <bool> &dp)\\n    {\\n        if (i < 0 || j >= s.size ())\\n            return 0;    //Out of bounds base case\\n\\n        if (s [i] != s [j] || dp [i] || dp [j])\\n            return 0;    //Not a valid option if ith and jth char don\\'t match or overlap with another already found palindrome\\n\\n        if (j - i + 1 >= k)\\n        {\\n            for (int x = i; x <= j; x++)\\n                dp [x] = true;\\n            return 1;   //Obtain a palindrome string of size at least k\\n        }\\n\\n        return f (i - 1, j + 1, k, s, dp); //Recursive call\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int cnt = 0;\\n        int n = s.size ();\\n        vector <bool> dp (n, false);\\n\\n        for (int i = 0; i < n; i++)\\n        {   \\n            if (!dp [i])\\n                cnt += f (i, i, k, s, dp);     //Odd length palindrome\\n            if (i < n - 1 && (s [i] == s [i + 1]) && !dp [i] && !dp [i + 1])\\n                cnt += f (i, i + 1, k, s, dp); //Even length palindrome\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689117,
                "title": "beautiful-code-optimizing-palindrome-substring-count-with-memoization",
                "content": "\\n# Intuition\\nNote: here curr substring means (start - end),i wrote code so that it can be understood by everyone just by reading it\\n\\nThere are three action we can take at any possible moment \\n1. curr substring as ans and increase the count make curr substring empty \\n2. add char in curr substring and recurive on that\\n3. make curr substrig empty and check for substring after than curr substring\\n\\n\\noption 1 is only possible when curr substring is palindrome \\n\\n\\n# Complexity\\n- Time complexity: \\n-The solve function is called recursively. In the worst case, it can be called for each substring of s, starting from every position start and ending at every position end. This results in a total of O(N^2) recursive calls, where N is the length of the string s.\\nFor each recursive call, the function checks if the result is already present in the dp array in constant time, resulting in a time complexity of O(1) for the memoization lookup.\\nIf the result is not already present in the dp array, the function performs some operations:\\nChecking if the substring is a palindrome takes O(k) time, where k is the length of the substring being checked.\\nThe function makes recursive calls based on different conditions, resulting in a total of O(1) recursive calls.\\nthe time complexity of the solution can be expressed as O(N^2 * k), where N is the length of the string s and k is the maximum length of a palindrome substring to be considered.\\n\\n\\n- Space complexity:\\nO(n*n) here n is size of the string s \\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool palindrome(string &s,int i,int j,int k){ \\n        while(i<j) if(s[i++]!=s[j--]) return false;\\n        return true;\\n    }\\n    int solve(vector<vector<int>>&dp,string &s,int start, int end,int ans,int k ){\\n        if(start >= s.size() || end>=s.size()) return 0;\\n        if(dp[start][end]!=-1) return dp[start][end];\\n\\n        int count =0,notCount =0,slideWindow=0;    \\n        if(palindrome(s,start,end,k)){\\n            count       = 1 + solve(dp,s,end+1,  end+k,ans+1,k);\\n            notCount    = 0 + solve(dp,s,start,  end+1,ans,  k);\\n            slideWindow = 0 + solve(dp,s,start+1,end+1,ans,  k);\\n            return dp[start][end] =  max(count,max(notCount,slideWindow));\\n        }\\n\\n        notCount    = solve(dp,s,start,  end+1,ans,k);\\n        slideWindow = solve(dp,s,start+1,end+1,ans,k);\\n        return dp[start][end] = max(notCount,slideWindow);\\n    \\n    }\\n    int maxPalindromes(string s, int k) {\\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\\n        if(k==1) return s.size();\\n        return solve(dp,s,0,k-1,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool palindrome(string &s,int i,int j,int k){ \\n        while(i<j) if(s[i++]!=s[j--]) return false;\\n        return true;\\n    }\\n    int solve(vector<vector<int>>&dp,string &s,int start, int end,int ans,int k ){\\n        if(start >= s.size() || end>=s.size()) return 0;\\n        if(dp[start][end]!=-1) return dp[start][end];\\n\\n        int count =0,notCount =0,slideWindow=0;    \\n        if(palindrome(s,start,end,k)){\\n            count       = 1 + solve(dp,s,end+1,  end+k,ans+1,k);\\n            notCount    = 0 + solve(dp,s,start,  end+1,ans,  k);\\n            slideWindow = 0 + solve(dp,s,start+1,end+1,ans,  k);\\n            return dp[start][end] =  max(count,max(notCount,slideWindow));\\n        }\\n\\n        notCount    = solve(dp,s,start,  end+1,ans,k);\\n        slideWindow = solve(dp,s,start+1,end+1,ans,k);\\n        return dp[start][end] = max(notCount,slideWindow);\\n    \\n    }\\n    int maxPalindromes(string s, int k) {\\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\\n        if(k==1) return s.size();\\n        return solve(dp,s,0,k-1,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166035,
                "title": "easy-to-understand-solution-in-java-using-center-expansion-technique-in-o-n",
                "content": "\\n# Approach\\nUsing each element of the array as center keep on building the pallindrome as soon as it reaches the min length criteria just stop the operation and return index next to it because it is already used in the pallindrome once and we dont want overlapping pallindromes. \\nMaintain a used array to track whether the character is used or not. if not used then only take it in the next pallindrome to be considered.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n\\n[can be decreased to O(1) with the help of a pointer which points to the last location of the last counted pallindrome. initialize the pointer to -1]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  \\n    int k;\\n    boolean[] used;\\n    public int maxPalindromes(String s, int k) {\\n        this.k=k;\\n        used= new boolean[s.length()];\\n        Arrays.fill(used,false);\\n        if(k==1) return s.length();\\n        int res=0;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            int oddLength = centerExpansion(i,i,s);\\n            int evenLength = centerExpansion(i,i+1,s);\\n            if(oddLength==i && evenLength==i) \\n            {\\n                i++;\\n            }\\n            else if( oddLength==i || evenLength==i)\\n            {\\n                i=oddLength==i?evenLength:oddLength;\\n                used[i]=true;\\n                res=res+1;\\n                i=i+1;\\n            }\\n            else \\n            {\\n                i=Math.min(oddLength,evenLength);\\n                used[i]=true;\\n                i=i+1;\\n                res=res+1;\\n            }\\n        }\\n        return res;\\n    }\\n    int centerExpansion(int l, int r, String s)\\n    {\\n       int count=0;\\n       int ol=l;\\n        while(l>=0 && r<s.length())\\n        {\\n            if(s.charAt(l)==s.charAt(r))\\n            {\\n                if(r-l+1>=k && !used[l]) {\\n                    \\n                    return r;\\n                }\\n            }\\n            else\\n            {\\n                return ol;\\n            }\\n            r++;\\n            l--;\\n        }\\n        return ol;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  \\n    int k;\\n    boolean[] used;\\n    public int maxPalindromes(String s, int k) {\\n        this.k=k;\\n        used= new boolean[s.length()];\\n        Arrays.fill(used,false);\\n        if(k==1) return s.length();\\n        int res=0;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            int oddLength = centerExpansion(i,i,s);\\n            int evenLength = centerExpansion(i,i+1,s);\\n            if(oddLength==i && evenLength==i) \\n            {\\n                i++;\\n            }\\n            else if( oddLength==i || evenLength==i)\\n            {\\n                i=oddLength==i?evenLength:oddLength;\\n                used[i]=true;\\n                res=res+1;\\n                i=i+1;\\n            }\\n            else \\n            {\\n                i=Math.min(oddLength,evenLength);\\n                used[i]=true;\\n                i=i+1;\\n                res=res+1;\\n            }\\n        }\\n        return res;\\n    }\\n    int centerExpansion(int l, int r, String s)\\n    {\\n       int count=0;\\n       int ol=l;\\n        while(l>=0 && r<s.length())\\n        {\\n            if(s.charAt(l)==s.charAt(r))\\n            {\\n                if(r-l+1>=k && !used[l]) {\\n                    \\n                    return r;\\n                }\\n            }\\n            else\\n            {\\n                return ol;\\n            }\\n            r++;\\n            l--;\\n        }\\n        return ol;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968462,
                "title": "c-easy-solution-two-pointer-runtime-0-ms-beats-100",
                "content": "# Intuition\\nGiven string contains a palindrome substring or not.\\n[Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/description/) - Try to solve this question with two pointer approach.\\n\\n# Approach\\nTraverse a string for every character of the string, inzilate two pointers (L and R), and move L to the left and R to the right till a[L] == a[R]. R-L+1>=k, then the substring from L to R has a length greater than or equal to k, and it is a palindrome.\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string a, int k) {\\n        int n = a.size(), lowerBound = 0 ,oddL, oddR, oddFlag, evenL, evenR, evenFlag , ans =0, i=0;\\n        while(i<n){\\n            oddL = i;\\n            oddR = i;\\n            oddFlag = 0;\\n            while(oddL>=lowerBound&&oddR<n&&a[oddL]==a[oddR]){\\n                if(oddR-oddL+1>=k){\\n                    oddFlag =1;\\n                    break;\\n                }\\n                oddL--;\\n                oddR++;\\n            }\\n            evenL = i;\\n            evenR = i+1;\\n            evenFlag = 0;\\n            while(evenL>=lowerBound&&evenR<n&&a[evenL]==a[evenR]){\\n                if(evenR-evenL+1>=k){\\n                    evenFlag = 1;\\n                    break;\\n                }\\n                evenL--;\\n                evenR++;\\n            }\\n            if(evenFlag==0&&oddFlag==0) i++;\\n            else if(evenFlag==1&&oddFlag==1){\\n                ans++;\\n                lowerBound = min(oddR,evenR)+1;\\n                i = lowerBound;\\n            }\\n            else if(evenFlag==1){\\n                ans++;\\n                lowerBound = evenR+1;\\n                i = lowerBound;\\n            }\\n            else{\\n                ans++;\\n                lowerBound = oddR+1;\\n                i = lowerBound;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string a, int k) {\\n        int n = a.size(), lowerBound = 0 ,oddL, oddR, oddFlag, evenL, evenR, evenFlag , ans =0, i=0;\\n        while(i<n){\\n            oddL = i;\\n            oddR = i;\\n            oddFlag = 0;\\n            while(oddL>=lowerBound&&oddR<n&&a[oddL]==a[oddR]){\\n                if(oddR-oddL+1>=k){\\n                    oddFlag =1;\\n                    break;\\n                }\\n                oddL--;\\n                oddR++;\\n            }\\n            evenL = i;\\n            evenR = i+1;\\n            evenFlag = 0;\\n            while(evenL>=lowerBound&&evenR<n&&a[evenL]==a[evenR]){\\n                if(evenR-evenL+1>=k){\\n                    evenFlag = 1;\\n                    break;\\n                }\\n                evenL--;\\n                evenR++;\\n            }\\n            if(evenFlag==0&&oddFlag==0) i++;\\n            else if(evenFlag==1&&oddFlag==1){\\n                ans++;\\n                lowerBound = min(oddR,evenR)+1;\\n                i = lowerBound;\\n            }\\n            else if(evenFlag==1){\\n                ans++;\\n                lowerBound = evenR+1;\\n                i = lowerBound;\\n            }\\n            else{\\n                ans++;\\n                lowerBound = oddR+1;\\n                i = lowerBound;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815435,
                "title": "breaking-problem-into-sub-problems-and-taking-only-k-k-1-length-palindromic-substrings",
                "content": "If we break down the problems into sub problems we can easily solve it\\nFirst find all the palindromic substrings using gap strategy and while doing that keep the start and end indices of all the substrings that have length k and k+1\\nWhy k and k+1, because the substrings with length k+2 will have strings of length k inside them So it\\'ll be optimanl to just take substrings of length k only\\nSame goes for k+1 length\\n\\nNow the problem comes down to [Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/) Remove minimum number of intervals so that all other are non overlaping\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        \\n        int n = s.size();\\n        \\n        vector<vector<bool>> dp(n, vector<bool> (n, false));\\n        \\n        vector<vector<int>> a;\\n        \\n        for(int g = 0 ; g < n ; g++){//g is the gap between i & j\\n            \\n            for(int i = 0, j = g ; j < n ; i++, j++){\\n                \\n                if(g == 0)\\n                    dp[i][j] = true;\\n                else if(g == 1)\\n                    dp[i][j] = s[i] == s[j];\\n                else    \\n                    dp[i][j] = ((s[i] == s[j]) && dp[i+1][j-1]);\\n                \\n                if(dp[i][j] && (g==k-1 || g==k))\\n                    a.push_back({i,j});\\n                \\n            }\\n            \\n        }\\n        \\n        int count = 0;//count denotes the number of intervals we need to remove\\n        \\n        sort(a.begin(), a.end());\\n        \\n        int l = 0,r = 1;\\n        \\n        n = a.size();\\n        \\n        while(r < n){\\n            \\n            if(a[l][1] < a[r][0]){\\n                l = r;\\n                r++;\\n            }else if(a[l][1] <= a[r][1]){\\n                count++;\\n                r++;\\n            }else if(a[l][1] > a[r][1]){\\n                l = r;\\n                count++;\\n                r++;\\n            }\\n            \\n        }\\n        \\n        return a.size() - count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        \\n        int n = s.size();\\n        \\n        vector<vector<bool>> dp(n, vector<bool> (n, false));\\n        \\n        vector<vector<int>> a;\\n        \\n        for(int g = 0 ; g < n ; g++){//g is the gap between i & j\\n            \\n            for(int i = 0, j = g ; j < n ; i++, j++){\\n                \\n                if(g == 0)\\n                    dp[i][j] = true;\\n                else if(g == 1)\\n                    dp[i][j] = s[i] == s[j];\\n                else    \\n                    dp[i][j] = ((s[i] == s[j]) && dp[i+1][j-1]);\\n                \\n                if(dp[i][j] && (g==k-1 || g==k))\\n                    a.push_back({i,j});\\n                \\n            }\\n            \\n        }\\n        \\n        int count = 0;//count denotes the number of intervals we need to remove\\n        \\n        sort(a.begin(), a.end());\\n        \\n        int l = 0,r = 1;\\n        \\n        n = a.size();\\n        \\n        while(r < n){\\n            \\n            if(a[l][1] < a[r][0]){\\n                l = r;\\n                r++;\\n            }else if(a[l][1] <= a[r][1]){\\n                count++;\\n                r++;\\n            }else if(a[l][1] > a[r][1]){\\n                l = r;\\n                count++;\\n                r++;\\n            }\\n            \\n        }\\n        \\n        return a.size() - count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813798,
                "title": "detailed-explanation-dynamic-programming-solution-o-n-n",
                "content": "# Intuition\\nI found out the find maximum number of valid substrings in every interval \\n[i,n-1], where i vary from (0 to n-1)\\nand dp[0] is the answer\\n\\n# Approach\\nWe iterated over the string and for each character \\'i\\', we stored the result of \\'maximum number of valid substrings it can make in range i to n-1\\' in dp[i];\\n\\nTo do that,\\n\\nfor evry i I iterated over the remaining portion of string using pointer j\\ni.e from i to n-1 \\n\\nand I checked whether i to j is palindrom or not?\\n\\nIf it is palindrom then I added dp[j+1] to answer and added 1 to it additionally..\\n(((added 1 beacause we have i to j as palindromic and then added maximum valid string in range j+1 to n-1 i.e. dp[j+1])))\\n.\\nif(it is not palindromic) then we just add the reult of dp[j+1];\\n```\\ntransition is : \\n    if(substring(i to j) is palindrome)\\n        dp[i]=max(dp[i],dp[j+1]**+1**);\\n    else\\n        dp[i]=max(dp[i],dp[j+1]);\\n```\\n\\nTo reduce time complexity to O(N*N):\\nWe precalculated whether a string in range i to j is palindromic or not\\n\\n# Complexity\\n\\n- Time complexity: O(N*N)\\n\\n\\n- Space complexity: O(N*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string a, int k) {\\n        int n=a.size();\\n        // p[i][j] -> true if string in i to j is palindromic\\n        vector<vector<bool>>p(n+5,vector<bool>(n+5,false));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=i;j<n;j++){\\n                if(i==j)\\n                    p[i][j]=true;\\n                else if(a[i]==a[j]&&(j-i==1||p[i+1][j-1]))\\n                    p[i][j]=true;\\n            }\\n        }\\n        // dp[i] -> maximum number of valid substrings in range i to n-1\\n        vector<int>dp(n+5,0);\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=i;j<n;j++){\\n                int len=j-i+1;\\n                dp[i]=max(dp[i],dp[j+1]+(len>=k?p[i][j]:0));\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ntransition is : \\n    if(substring(i to j) is palindrome)\\n        dp[i]=max(dp[i],dp[j+1]**+1**);\\n    else\\n        dp[i]=max(dp[i],dp[j+1]);\\n```\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string a, int k) {\\n        int n=a.size();\\n        // p[i][j] -> true if string in i to j is palindromic\\n        vector<vector<bool>>p(n+5,vector<bool>(n+5,false));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=i;j<n;j++){\\n                if(i==j)\\n                    p[i][j]=true;\\n                else if(a[i]==a[j]&&(j-i==1||p[i+1][j-1]))\\n                    p[i][j]=true;\\n            }\\n        }\\n        // dp[i] -> maximum number of valid substrings in range i to n-1\\n        vector<int>dp(n+5,0);\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=i;j<n;j++){\\n                int len=j-i+1;\\n                dp[i]=max(dp[i],dp[j+1]+(len>=k?p[i][j]:0));\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811265,
                "title": "c-greedy-approach-easy-and-simplified-2-approach",
                "content": "\\n# Solution 1\\n```\\nclass Solution {\\npublic:\\n    bool ispal(string s,int l,int r){\\n        while(l<r){\\n            if(s[l]!=s[r]){\\n                return false;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n=s.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                int len=(j-i)+1;\\n                if(len>=k and ispal(s,i,j)){\\n                    ans++;\\n                    i=j;\\n                    break;\\n                }\\n                if(len>k+1){\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Solution 2\\n```\\nclass Solution {\\npublic:\\n    bool ispal(string s){\\n        int l=0;\\n        int r=s.size()-1;\\n        while(l<r){\\n            if(s[l]!=s[r]){\\n                return false;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n=s.size();\\n        int ans=0;\\n        string str=\"\";\\n        int i=0,j=0,t=0;\\n        while(i<=n-k){\\n            j=i;\\n            str=\"\";\\n            t=i+1;\\n            while(j<n){\\n                str+=s[j];\\n                if(str.size()>k+1){\\n                    break;\\n                }\\n                if(str.size()>=k){\\n                    if(ispal(str)){\\n                        ans++;\\n                        t=j+1;\\n                        str=\"\";\\n                    }\\n                }\\n                j++;\\n            }\\n            i=t;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ispal(string s,int l,int r){\\n        while(l<r){\\n            if(s[l]!=s[r]){\\n                return false;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n=s.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                int len=(j-i)+1;\\n                if(len>=k and ispal(s,i,j)){\\n                    ans++;\\n                    i=j;\\n                    break;\\n                }\\n                if(len>k+1){\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool ispal(string s){\\n        int l=0;\\n        int r=s.size()-1;\\n        while(l<r){\\n            if(s[l]!=s[r]){\\n                return false;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n=s.size();\\n        int ans=0;\\n        string str=\"\";\\n        int i=0,j=0,t=0;\\n        while(i<=n-k){\\n            j=i;\\n            str=\"\";\\n            t=i+1;\\n            while(j<n){\\n                str+=s[j];\\n                if(str.size()>k+1){\\n                    break;\\n                }\\n                if(str.size()>=k){\\n                    if(ispal(str)){\\n                        ans++;\\n                        t=j+1;\\n                        str=\"\";\\n                    }\\n                }\\n                j++;\\n            }\\n            i=t;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811157,
                "title": "python3-cutting-short-is-always-better-than-cutting-long",
                "content": "If the minimum cutting length k==3, then we always find palindrome of length 3 or 4, even if the actual palindrome is much longer. Because long or short, each palindrome can only contribute +1 to the result, and short palindrome can offer more possibilities for the rest parts.\\n\\n**dp(i)** means the max number of valid palindromes before i.\\nWe can either choose to cut a palindrome ended at i, or not.\\nIf we don\\'t cut, dp(i)=dp(i-1)\\nIf we cut, then we can either cut a palindrome of length k, or length k+1. \\ndp(i)=dp(i-k)+1\\ndp(i)=dp(i-k-1)+1\\n\"+1\" here is the contribution of the palindrome we cut.\\n\\nWe choose the biggest of the three ways as the result of dp(i).\\nDon\\'t cut palindrome longer than k+1 as discussed above.\\n\\nisPalin(i,j) indicates whether s[i:j+1] is a palindrome or not.\\nUsing cached recursive \"isPalin\" function is much faster than iterative way, as we need to check all palindromes.\\n\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        @cache\\n        def isPalin(i,j):\\n            if i>=j: return True\\n            return s[i]==s[j] and isPalin(i+1,j-1)\\n        dp = [0]*len(s)\\n        for j in range(k-1,len(s)):\\n            dp[j]=dp[j-1]\\n            for i in [j-k+1,j-k]:\\n                if i>=0 and isPalin(i,j):\\n                    dp[j]=max(dp[j],dp[i-1]+1)\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        @cache\\n        def isPalin(i,j):\\n            if i>=j: return True\\n            return s[i]==s[j] and isPalin(i+1,j-1)\\n        dp = [0]*len(s)\\n        for j in range(k-1,len(s)):\\n            dp[j]=dp[j-1]\\n            for i in [j-k+1,j-k]:\\n                if i>=0 and isPalin(i,j):\\n                    dp[j]=max(dp[j],dp[i-1]+1)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811088,
                "title": "true-o-n-dp-manacher",
                "content": "We use Manacher to check if a substring is a palindrome in O(1)\\n- `Manacher(s)` preprocessing is O(n)\\n- `palin(i,i+k)` checks if `s[i:i+k]` is palindrome in O(1)\\n- `dp` is `O(n)`\\n\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        def Manacher(s):\\n            T = \\'$#\\'+\\'#\\'.join(s)+\\'#&\\'\\n            P = [0]*len(T)\\n            C,R = 0,0\\n            for i in range(len(T)-1):\\n                if R > i: \\n                    P[i] = min(R-i,P[2*C-i])\\n                while T[i+P[i]+1] == T[i-P[i]-1]:\\n                    P[i] += 1\\n                if R < i+P[i]:\\n                    C,R = i,i+P[i]\\n            return P[2:-2]\\n        \\n        def palin(i,j):\\n            if j > len(s): return False\\n            l = j-i\\n            c = 2*((i+j)//2)-(l%2==0)\\n            return P[c] >= l\\n        \\n        @cache\\n        def dp(i):\\n            if i+k > len(s): return 0\\n            val = dp(i+1)\\n            if palin(i,i+k): val = max(val,1+dp(i+k))\\n            if palin(i,i+k+1):  val = max(val,1+dp(i+k+1))\\n            return val\\n        P = Manacher(s)\\n        return dp(0)\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        def Manacher(s):\\n            T = \\'$#\\'+\\'#\\'.join(s)+\\'#&\\'\\n            P = [0]*len(T)\\n            C,R = 0,0\\n            for i in range(len(T)-1):\\n                if R > i: \\n                    P[i] = min(R-i,P[2*C-i])\\n                while T[i+P[i]+1] == T[i-P[i]-1]:\\n                    P[i] += 1\\n                if R < i+P[i]:\\n                    C,R = i,i+P[i]\\n            return P[2:-2]\\n        \\n        def palin(i,j):\\n            if j > len(s): return False\\n            l = j-i\\n            c = 2*((i+j)//2)-(l%2==0)\\n            return P[c] >= l\\n        \\n        @cache\\n        def dp(i):\\n            if i+k > len(s): return 0\\n            val = dp(i+1)\\n            if palin(i,i+k): val = max(val,1+dp(i+k))\\n            if palin(i,i+k+1):  val = max(val,1+dp(i+k+1))\\n            return val\\n        P = Manacher(s)\\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809467,
                "title": "javascript-simple-and-fast-brute-force",
                "content": "1. If there is a palindrome string of length N where N > k + 1, the string can be always \"trimmed\" to a substring of length k or k + 1. E.g. for k = 3, ab**cddc**ba =>cddc; or abc**ded**cba => ded\\n2. As far as we need to find a maximum number of substrings in an optimal selection we can ignore all palindromes longer than k + 1, due to the fact that all longer palindromes will have their \"shorter\" version of length k or k + 1.\\n3. So, starting from the very first chat of string, check all string of length k and k + 1 if it\\'s a palindrome. If so, skip next k/k+1 chars.\\n\\n\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxPalindromes = function(s, k) {\\n    let ans = 0 \\n\\t\\n    const isPalindrome = (str) => {\\n        let start = 0\\n        let end = str.length - 1\\n        while (start < end) {\\n            if (str[start] !== str[end]) return false\\n            start++\\n            end--\\n        }\\n        return true\\n    }\\n    \\n    let len = s.length\\n    let i = 0\\n    \\n    while (i + k <= len) {\\n        let step = 1\\n        if (isPalindrome(s.substring(i, i + k) )) {\\n            ans++\\n            step = k\\n        } else if (i + k + 1 <= len) {\\n            if (isPalindrome(s.substring(i, i + k + 1))) {\\n                ans++\\n                step = k + 1\\n            } \\n        }\\n        i += step\\n    }\\n    return ans\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "1. If there is a palindrome string of length N where N > k + 1, the string can be always \"trimmed\" to a substring of length k or k + 1. E.g. for k = 3, ab**cddc**ba =>cddc; or abc**ded**cba => ded\\n2. As far as we need to find a maximum number of substrings in an optimal selection we can ignore all palindromes longer than k + 1, due to the fact that all longer palindromes will have their \"shorter\" version of length k or k + 1.\\n3. So, starting from the very first chat of string, check all string of length k and k + 1 if it\\'s a palindrome. If so, skip next k/k+1 chars.\\n\\n\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxPalindromes = function(s, k) {\\n    let ans = 0 \\n\\t\\n    const isPalindrome = (str) => {\\n        let start = 0\\n        let end = str.length - 1\\n        while (start < end) {\\n            if (str[start] !== str[end]) return false\\n            start++\\n            end--\\n        }\\n        return true\\n    }\\n    \\n    let len = s.length\\n    let i = 0\\n    \\n    while (i + k <= len) {\\n        let step = 1\\n        if (isPalindrome(s.substring(i, i + k) )) {\\n            ans++\\n            step = k\\n        } else if (i + k + 1 <= len) {\\n            if (isPalindrome(s.substring(i, i + k + 1))) {\\n                ans++\\n                step = k + 1\\n            } \\n        }\\n        i += step\\n    }\\n    return ans\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2809407,
                "title": "c-simple-o-n-solution-manacher-s-algorithm",
                "content": "**Pre-requisite:** Learn about [Manacher\\'s algorithm](https://cp-algorithms.com/string/manacher.html/)\\n```\\nclass Solution {\\npublic:\\n    vector<int> manachers(string s){\\n        string str = \"#\";\\n        for(char ch: s){\\n            str += ch;\\n            str += \"#\";\\n        }\\n        int c = 0, r = 0;\\n        vector<int> P(str.size(), 0);\\n\\t\\t\\n        for(int i=1; i<str.size()-1; i++){\\n            if(i <= r){\\n                int imirror = (2*c)-i;\\n                P[i] = min(P[imirror], r-i);\\n            }\\n            \\n            int j = i+P[i]+1, k = i-P[i]-1;\\n            while(j<str.size() && k>=0 && str[j] == str[k]){\\n                P[i]++;\\n                j++;\\n                k--;\\n            }\\n            if(k-1 > r){\\n                c = i;\\n                r = k-1;\\n            }\\n        }\\n        return P;\\n    }\\n    \\n    int maxPalindromes(string s, int k) {\\n        // Find the palindrome length centered around each index using manacher\\'s algorithm\\n        vector<int> P = manachers(s);\\n        \\n        // Stores the ending index of the previous palindrome substring\\n        int prev = -1;\\n        \\n        int ans = 0;\\n        for(int i=0; i<P.size(); i++){\\n            int len = P[i];\\n            // Palindrome length centered around index i is less than k\\n            if(len < k){\\n                continue;\\n            }\\n            // Now, we try to take only smallest palindrome which is atleast k \\n            if(k%2 == 0){\\n                if(len%2 == 0){\\n                    len = k;\\n                }\\n                else{\\n                    len = k+1;\\n                }\\n            }\\n            else{\\n                if(len%2 == 0){\\n                    len = k+1;\\n                }\\n                else{\\n                    len = k;\\n                }\\n            }\\n            \\n            // Starting index of the current palindrome\\n            int start = (i-len)/2;\\n            \\n            // Overlapping with previous palindrome\\n            if(start <= prev){\\n                continue;\\n            }\\n            \\n            ans++;\\n            int end = start+len-1;\\n            prev = end;\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> manachers(string s){\\n        string str = \"#\";\\n        for(char ch: s){\\n            str += ch;\\n            str += \"#\";\\n        }\\n        int c = 0, r = 0;\\n        vector<int> P(str.size(), 0);\\n\\t\\t\\n        for(int i=1; i<str.size()-1; i++){\\n            if(i <= r){\\n                int imirror = (2*c)-i;\\n                P[i] = min(P[imirror], r-i);\\n            }\\n            \\n            int j = i+P[i]+1, k = i-P[i]-1;\\n            while(j<str.size() && k>=0 && str[j] == str[k]){\\n                P[i]++;\\n                j++;\\n                k--;\\n            }\\n            if(k-1 > r){\\n                c = i;\\n                r = k-1;\\n            }\\n        }\\n        return P;\\n    }\\n    \\n    int maxPalindromes(string s, int k) {\\n        // Find the palindrome length centered around each index using manacher\\'s algorithm\\n        vector<int> P = manachers(s);\\n        \\n        // Stores the ending index of the previous palindrome substring\\n        int prev = -1;\\n        \\n        int ans = 0;\\n        for(int i=0; i<P.size(); i++){\\n            int len = P[i];\\n            // Palindrome length centered around index i is less than k\\n            if(len < k){\\n                continue;\\n            }\\n            // Now, we try to take only smallest palindrome which is atleast k \\n            if(k%2 == 0){\\n                if(len%2 == 0){\\n                    len = k;\\n                }\\n                else{\\n                    len = k+1;\\n                }\\n            }\\n            else{\\n                if(len%2 == 0){\\n                    len = k+1;\\n                }\\n                else{\\n                    len = k;\\n                }\\n            }\\n            \\n            // Starting index of the current palindrome\\n            int start = (i-len)/2;\\n            \\n            // Overlapping with previous palindrome\\n            if(start <= prev){\\n                continue;\\n            }\\n            \\n            ans++;\\n            int end = start+len-1;\\n            prev = end;\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2809291,
                "title": "map-dp-comments-explanation",
                "content": "Read the maxPalindromes function first.\\n \\nsolve function-> returns max number of non overlapping palindrome strings up to index currentIndx\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int>dp;\\n    //dp[i] stores the max number of non overlapping palindrome strings upto index i  \\n    map<int,int>StartingPoint;\\n    // Let (i,j) be an element of the map\\n    // Then if a string ends with \\'i\\'th index, its starting point is \\'j\\'th index;\\n    \\n    bool IsPalindrome(int i, int j, string &s){\\n        while(i<=j){\\n            if(s[i]!=s[j]) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    int solve(int currentIndx){\\n        if(currentIndx<0) return 0;\\n        if(dp[currentIndx]!=-1) return dp[currentIndx];\\n        int startingIndx= StartingPoint[currentIndx];\\n        if(startingIndx==-1) return dp[currentIndx]=solve(currentIndx-1);\\n        dp[currentIndx]=max(1+solve(startingIndx-1), solve(currentIndx-1));\\n        return dp[currentIndx];\\n    }\\n    \\n    int maxPalindromes(string s, int k) {\\n        int n=s.size();\\n        dp.resize(n,-1);\\n        for(int i=n-1;i>=0;i--){\\n            StartingPoint[i]=-1;\\n            // -1 as a starting point indicates that no palindrome string ending at index \\'i\\' was found;\\n            for(int j=i-k+1;j>=0;j--){\\n                if(IsPalindrome(j, i, s)){\\n                    // Greedily for every index we select the smallest possible palindromic string ending at that index\\n                    // Thats why we break if Palindrome is found\\n                    StartingPoint[i]=j;\\n                    break;\\n                }\\n            }\\n        }\\n        solve(n-1);\\n        return dp[n-1];\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int>dp;\\n    //dp[i] stores the max number of non overlapping palindrome strings upto index i  \\n    map<int,int>StartingPoint;\\n    // Let (i,j) be an element of the map\\n    // Then if a string ends with \\'i\\'th index, its starting point is \\'j\\'th index;\\n    \\n    bool IsPalindrome(int i, int j, string &s){\\n        while(i<=j){\\n            if(s[i]!=s[j]) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    int solve(int currentIndx){\\n        if(currentIndx<0) return 0;\\n        if(dp[currentIndx]!=-1) return dp[currentIndx];\\n        int startingIndx= StartingPoint[currentIndx];\\n        if(startingIndx==-1) return dp[currentIndx]=solve(currentIndx-1);\\n        dp[currentIndx]=max(1+solve(startingIndx-1), solve(currentIndx-1));\\n        return dp[currentIndx];\\n    }\\n    \\n    int maxPalindromes(string s, int k) {\\n        int n=s.size();\\n        dp.resize(n,-1);\\n        for(int i=n-1;i>=0;i--){\\n            StartingPoint[i]=-1;\\n            // -1 as a starting point indicates that no palindrome string ending at index \\'i\\' was found;\\n            for(int j=i-k+1;j>=0;j--){\\n                if(IsPalindrome(j, i, s)){\\n                    // Greedily for every index we select the smallest possible palindromic string ending at that index\\n                    // Thats why we break if Palindrome is found\\n                    StartingPoint[i]=j;\\n                    break;\\n                }\\n            }\\n        }\\n        solve(n-1);\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809266,
                "title": "python3-greedy-only-check-length-k-and-k-1",
                "content": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        ans = 0\\n        l = 0\\n        while l<len(s):\\n            cdd1 = s[l:l+k]\\n            if len(cdd1)>=k and cdd1 == cdd1[::-1]:\\n                ans += 1\\n                l = l+k\\n                continue\\n            cdd2 = s[l:l+k+1]\\n            if len(cdd2)>=k and cdd2 == cdd2[::-1]:\\n                ans += 1\\n                l = l+k+1\\n                continue\\n            l += 1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        ans = 0\\n        l = 0\\n        while l<len(s):\\n            cdd1 = s[l:l+k]\\n            if len(cdd1)>=k and cdd1 == cdd1[::-1]:\\n                ans += 1\\n                l = l+k\\n                continue\\n            cdd2 = s[l:l+k+1]\\n            if len(cdd2)>=k and cdd2 == cdd2[::-1]:\\n                ans += 1\\n                l = l+k+1\\n                continue\\n            l += 1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809214,
                "title": "c-dp",
                "content": "```\\n\\nclass Solution {\\npublic:\\n   \\n    int recc(vector<vector<int>>& adj, int i , int k, vector<int>& dpp)\\n    {\\n        if(i>=adj.size())\\n            return 0;\\n        \\n        if(dpp[i]!=-1)\\n        {\\n            return dpp[i];\\n        }\\n        int ans  = 0;\\n        for(int j = i+k-1;j<adj.size();j++)\\n        {\\n            if(adj[i][j]==1)\\n            {\\n                ans = max(ans, recc(adj,j+1,k, dpp)+1);\\n            }\\n        }\\n         ans = max(ans, recc(adj,i+1,k, dpp));\\n        return dpp[i] = ans ;\\n    } \\n\\n    int maxPalindromes(string s, int k)\\n    {\\n          int len  = s.length();\\n    \\n       \\n       vector<vector<int>>dp(len, vector<int>(len,0));\\n        for(int i =  0;i<len;i++)\\n        {\\n            dp[i][i]= 1;\\n        }\\n        for(int i  = len-2;i>=0;i--)\\n        {\\n            int st = len-1;\\n            for(int  j = i;j>=0 && st;j--)\\n            {\\n                int x  = j;\\n                int y = st;\\n                if(y-x==1)\\n                {\\n                    if(s[x]==s[y])\\n                    dp[x][y] = 1;\\n                }\\n               else if(s[x]==s[y] && dp[x+1][y-1]==1)\\n                {\\n                    dp[x][y] = 1;\\n                }\\n                st--;\\n                \\n            }\\n        }\\n        vector<int>dpp(len,-1);\\n       return recc(dp,0,k, dpp);\\n     \\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n   \\n    int recc(vector<vector<int>>& adj, int i , int k, vector<int>& dpp)\\n    {\\n        if(i>=adj.size())\\n            return 0;\\n        \\n        if(dpp[i]!=-1)\\n        {\\n            return dpp[i];\\n        }\\n        int ans  = 0;\\n        for(int j = i+k-1;j<adj.size();j++)\\n        {\\n            if(adj[i][j]==1)\\n            {\\n                ans = max(ans, recc(adj,j+1,k, dpp)+1);\\n            }\\n        }\\n         ans = max(ans, recc(adj,i+1,k, dpp));\\n        return dpp[i] = ans ;\\n    } \\n\\n    int maxPalindromes(string s, int k)\\n    {\\n          int len  = s.length();\\n    \\n       \\n       vector<vector<int>>dp(len, vector<int>(len,0));\\n        for(int i =  0;i<len;i++)\\n        {\\n            dp[i][i]= 1;\\n        }\\n        for(int i  = len-2;i>=0;i--)\\n        {\\n            int st = len-1;\\n            for(int  j = i;j>=0 && st;j--)\\n            {\\n                int x  = j;\\n                int y = st;\\n                if(y-x==1)\\n                {\\n                    if(s[x]==s[y])\\n                    dp[x][y] = 1;\\n                }\\n               else if(s[x]==s[y] && dp[x+1][y-1]==1)\\n                {\\n                    dp[x][y] = 1;\\n                }\\n                st--;\\n                \\n            }\\n        }\\n        vector<int>dpp(len,-1);\\n       return recc(dp,0,k, dpp);\\n     \\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809196,
                "title": "precalculate-palindromic-substrings-and-then-solve-independent-intervals",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* We already know a standard way to precalculate which substrings are palindromes in $$O(N^2)$$ time. \\n* Notice that intervals are independent of each other\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n* Let $$f(i)$$ be the maximum number of palindromic substrings ending at $$i$$. \\n\\n* $$f(i) = \\\\max(f(i - 1), 1 + f(j - 1)),  \\\\forall j$$ such that $$S[j, i]$$ is a palindrome \\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n[GitHub](https://github.com/MathProgrammer/LeetCode/tree/master/Contests/Weekly%20Contest%20319)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string S, int k) \\n    {\\n        vector <vector <int> > is_palindrome(S.size(), vector <int> (S.size(), 0));  \\n        for(int length = 1; length <= S.size(); length++)\\n        {\\n            for(int left = 0, right = left + length - 1; right < S.size(); left++, right++)\\n            {\\n                if(length == 1)\\n                {\\n                    is_palindrome[left][right] = true;\\n                }\\n                else if(length == 2)\\n                {\\n                    is_palindrome[left][right] = (S[left] == S[right]);\\n                }\\n                else\\n                {\\n                    is_palindrome[left][right] = ( (S[left] == S[right])&is_palindrome[left + 1][right - 1]);\\n                }\\n            }\\n        }\\n        \\n        vector <int> maximum_palindromes_till(S.size(), 0);\\n        for(int i = k - 1; i < S.size(); i++)\\n        {\\n            maximum_palindromes_till[i] = is_palindrome[0][i];\\n            \\n            if(i >= 1)\\n            {\\n                maximum_palindromes_till[i] = max(maximum_palindromes_till[i - 1], is_palindrome[0][i]);\\n            }\\n            \\n            for(int j = i - k + 1; j > 0; j--)\\n            {\\n                if(is_palindrome[j][i])\\n                {\\n                    //cout << \"F(\" << i << \") = max (\" << maximum_palindromes_till[i] << \",\";\\n                        \\n                    maximum_palindromes_till[i] = max(maximum_palindromes_till[i], 1 + maximum_palindromes_till[j - 1]);\\n                    \\n                    //cout << j - 1 << \" = \"  << maximum_palindromes_till[j - 1] << \"\\\\n\";\\n                }\\n            }\\n            \\n            //cout << \"F(\" << i << \") = \" << maximum_palindromes_till[i] << \"\\\\n\";\\n        }\\n        \\n        return maximum_palindromes_till[S.size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string S, int k) \\n    {\\n        vector <vector <int> > is_palindrome(S.size(), vector <int> (S.size(), 0));  \\n        for(int length = 1; length <= S.size(); length++)\\n        {\\n            for(int left = 0, right = left + length - 1; right < S.size(); left++, right++)\\n            {\\n                if(length == 1)\\n                {\\n                    is_palindrome[left][right] = true;\\n                }\\n                else if(length == 2)\\n                {\\n                    is_palindrome[left][right] = (S[left] == S[right]);\\n                }\\n                else\\n                {\\n                    is_palindrome[left][right] = ( (S[left] == S[right])&is_palindrome[left + 1][right - 1]);\\n                }\\n            }\\n        }\\n        \\n        vector <int> maximum_palindromes_till(S.size(), 0);\\n        for(int i = k - 1; i < S.size(); i++)\\n        {\\n            maximum_palindromes_till[i] = is_palindrome[0][i];\\n            \\n            if(i >= 1)\\n            {\\n                maximum_palindromes_till[i] = max(maximum_palindromes_till[i - 1], is_palindrome[0][i]);\\n            }\\n            \\n            for(int j = i - k + 1; j > 0; j--)\\n            {\\n                if(is_palindrome[j][i])\\n                {\\n                    //cout << \"F(\" << i << \") = max (\" << maximum_palindromes_till[i] << \",\";\\n                        \\n                    maximum_palindromes_till[i] = max(maximum_palindromes_till[i], 1 + maximum_palindromes_till[j - 1]);\\n                    \\n                    //cout << j - 1 << \" = \"  << maximum_palindromes_till[j - 1] << \"\\\\n\";\\n                }\\n            }\\n            \\n            //cout << \"F(\" << i << \") = \" << maximum_palindromes_till[i] << \"\\\\n\";\\n        }\\n        \\n        return maximum_palindromes_till[S.size() - 1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2809128,
                "title": "c-simple-non-dp-solution-0ms-beats-100",
                "content": "https://leetcode.com/submissions/detail/842418022/\\nRuntime: 0 ms\\nTime complexity: O(k\\xB7n)\\nSpace complexity: O(1)\\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        const int n = s.size();\\n        int count = 0;\\n        int len = 0; // the shortest prefix length having _count_ substrings\\n        for (int i = 0; i < n; ++i) {\\n            int new_len = INT_MAX;\\n            for (int j = 0; i-j >= len && i+j < n && s[i-j] == s[i+j]; ++j) {\\n                if (2*j + 1 >= k) {\\n                    new_len = min(new_len, i + j + 1);\\n                    break;\\n                }\\n            }\\n            for (int j = 0; i-j >= len && i+j+1 < n && s[i-j] == s[i+j+1]; ++j) {\\n                if (2*j + 2 >= k) {\\n                    new_len = min(new_len, i + j + 2);\\n                    break;\\n                }\\n            }\\n            if (new_len < INT_MAX) {\\n                len = new_len;\\n                ++count;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        const int n = s.size();\\n        int count = 0;\\n        int len = 0; // the shortest prefix length having _count_ substrings\\n        for (int i = 0; i < n; ++i) {\\n            int new_len = INT_MAX;\\n            for (int j = 0; i-j >= len && i+j < n && s[i-j] == s[i+j]; ++j) {\\n                if (2*j + 1 >= k) {\\n                    new_len = min(new_len, i + j + 1);\\n                    break;\\n                }\\n            }\\n            for (int j = 0; i-j >= len && i+j+1 < n && s[i-j] == s[i+j+1]; ++j) {\\n                if (2*j + 2 >= k) {\\n                    new_len = min(new_len, i + j + 2);\\n                    break;\\n                }\\n            }\\n            if (new_len < INT_MAX) {\\n                len = new_len;\\n                ++count;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809048,
                "title": "longest-palindromic-substring-easy-to-understand-java-expanding-around-a-fixed-pivot",
                "content": "The **intution of the problem can be very well driven from the idea** of the [Longest Palindromic Substring](http://leetcode.com/problems/longest-palindromic-substring/) problem.\\n\\nLets first review the code for the longest palindromic substring:\\n```\\nclass Solution {\\n    public int expand(int left, int right, String s)\\n    {\\n\\t   // Expading the boundaries around the fixed pivot\\n        while(left>=0 && right<s.length() && s.charAt(left)==s.charAt(right))\\n        {\\n            left--;\\n            right++;\\n        }\\n        return right-left-1;\\n    }\\n    public String longestPalindrome(String s) {\\n        int left = 0;\\n        int right = 0;\\n        \\n        for(int i = 0;i<s.length();i++)\\n        {\\n            int len1 = expand(i,i,s);  // For the substring having the length odd\\n            int len2 = expand(i,i+1,s); // For the substring having the length even\\n            \\n            int len = Math.max(len1,len2);\\n            if(len>(right-left))\\n            {\\n                left = i-(len-1)/2;\\n                right = i+ (len)/2;\\n            }\\n        }\\n        \\n        return s.substring(left,right+1);\\n    }\\n}\\n```\\n\\nThe idea for this problem is very much similar. All we need to **consider the following constraints**: \\n```\\n1 - Palindromic Substrings should be non overlapping (i.e the right boundary of previous palindromic substring should be less than the left boundary of current palindromic substring).\\n\\n2 - The length of the palindromic substring should be >= k.\\n\\n```\\n\\nThe implementation for the above algorithmic intuition is described in the code given below.\\n```\\nclass Solution {\\n    public boolean getLen(int[] Ar, String s, int left, int k)\\n    {\\n\\t    // Expanding the boundaries around fixed pivot with given constraints\\n        while(Ar[0]>=left && Ar[1]<s.length() && s.charAt(Ar[0])==s.charAt(Ar[1]))\\n        {\\n            \\n            if((Ar[1]-Ar[0]+1)>=k)\\n                return true;\\n            Ar[0]--;\\n            Ar[1]++;\\n        }\\n        return false;\\n    }\\n    public int maxPalindromes(String s, int k) {\\n        \\n        int left = 0;\\n        int[] Ar = new int[2];\\n        int cnt = 0;\\n        //0-> Left\\n        //1-> Right\\n        for(int right = 0;right<s.length();right++)\\n        {\\n            boolean isPossible = false;\\n            Ar[0] = right;\\n            Ar[1] = right;\\n            isPossible = getLen(Ar,s,left,k); // For odd length substring\\n            if(isPossible)\\n            {\\n                left = Ar[1]+1;\\n                cnt++;\\n            }\\n            else\\n            {\\n                Ar[0] = right;\\n                Ar[1] = right+1;\\n                isPossible = getLen(Ar,s,left,k); // For substring of even length\\n                if(isPossible)\\n                {\\n                    left = Ar[1]+1;\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```\\n\\n```\\nThe dry for the sample test just for better understanding of the algorithm:\\n\\ns = \"abaccdbbd\", k = 3\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/f925f6c9-fd80-4404-878c-555893ad7a44_1668312795.840287.png)\\n\\n\\n**Palindromic Substring Count** : 2\\n\\nHope this helps. Have an awesome day folks \\uD83D\\uDE0A\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int expand(int left, int right, String s)\\n    {\\n\\t   // Expading the boundaries around the fixed pivot\\n        while(left>=0 && right<s.length() && s.charAt(left)==s.charAt(right))\\n        {\\n            left--;\\n            right++;\\n        }\\n        return right-left-1;\\n    }\\n    public String longestPalindrome(String s) {\\n        int left = 0;\\n        int right = 0;\\n        \\n        for(int i = 0;i<s.length();i++)\\n        {\\n            int len1 = expand(i,i,s);  // For the substring having the length odd\\n            int len2 = expand(i,i+1,s); // For the substring having the length even\\n            \\n            int len = Math.max(len1,len2);\\n            if(len>(right-left))\\n            {\\n                left = i-(len-1)/2;\\n                right = i+ (len)/2;\\n            }\\n        }\\n        \\n        return s.substring(left,right+1);\\n    }\\n}\\n```\n```\\n1 - Palindromic Substrings should be non overlapping (i.e the right boundary of previous palindromic substring should be less than the left boundary of current palindromic substring).\\n\\n2 - The length of the palindromic substring should be >= k.\\n\\n```\n```\\nclass Solution {\\n    public boolean getLen(int[] Ar, String s, int left, int k)\\n    {\\n\\t    // Expanding the boundaries around fixed pivot with given constraints\\n        while(Ar[0]>=left && Ar[1]<s.length() && s.charAt(Ar[0])==s.charAt(Ar[1]))\\n        {\\n            \\n            if((Ar[1]-Ar[0]+1)>=k)\\n                return true;\\n            Ar[0]--;\\n            Ar[1]++;\\n        }\\n        return false;\\n    }\\n    public int maxPalindromes(String s, int k) {\\n        \\n        int left = 0;\\n        int[] Ar = new int[2];\\n        int cnt = 0;\\n        //0-> Left\\n        //1-> Right\\n        for(int right = 0;right<s.length();right++)\\n        {\\n            boolean isPossible = false;\\n            Ar[0] = right;\\n            Ar[1] = right;\\n            isPossible = getLen(Ar,s,left,k); // For odd length substring\\n            if(isPossible)\\n            {\\n                left = Ar[1]+1;\\n                cnt++;\\n            }\\n            else\\n            {\\n                Ar[0] = right;\\n                Ar[1] = right+1;\\n                isPossible = getLen(Ar,s,left,k); // For substring of even length\\n                if(isPossible)\\n                {\\n                    left = Ar[1]+1;\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```\n```\\nThe dry for the sample test just for better understanding of the algorithm:\\n\\ns = \"abaccdbbd\", k = 3\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809000,
                "title": "java-rolling-hash-dynamic-programming",
                "content": "```\\nclass Solution {\\n    private int[] record;\\n    private final int p = 31, mod1 = (int) (1e9 + 7);\\n    private int[] dp;\\n    public int maxPalindromes(String s, int k) {\\n\\n        int n = s.length();\\n        record = new int[n];\\n        Arrays.fill(record, -1);\\n        util(s, n, k);\\n\\n        dp = new int[n];\\n        Arrays.fill(dp, -1);\\n        return getMax(0, n);\\n    }\\n\\n    private int getMax(int i, int n) {\\n        if (i >= n) return 0;\\n\\n        if (dp[i] != -1) return dp[i];\\n\\n        int ans = getMax(i + 1, n);\\n        if (record[i] != -1) ans = Math.max(ans, 1 + getMax(i + record[i], n));\\n        return dp[i] = ans;\\n    }\\n\\n    private void util(String s, int n, int k) {\\n        for (int ii = 0; ii < n; ii++) {\\n            long hashff = 0, hashss = 0, power = 1;\\n            for (int i = ii; i < n; i++) {\\n                int ascii = s.charAt(i) - \\'a\\' + 1;\\n                hashff = (hashff + ((ascii * power) % mod1)) % mod1;\\n                hashss = (hashss * p) % mod1;\\n                hashss = (hashss + ascii) % mod1;\\n                power = (power * p) % mod1;\\n\\n                if (hashff == hashss && (i - ii + 1) >= k) {\\n                    record[ii] = i - ii + 1;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\n    private int[] record;\\n    private final int p = 31, mod1 = (int) (1e9 + 7);\\n    private int[] dp;\\n    public int maxPalindromes(String s, int k) {\\n\\n        int n = s.length();\\n        record = new int[n];\\n        Arrays.fill(record, -1);\\n        util(s, n, k);\\n\\n        dp = new int[n];\\n        Arrays.fill(dp, -1);\\n        return getMax(0, n);\\n    }\\n\\n    private int getMax(int i, int n) {\\n        if (i >= n) return 0;\\n\\n        if (dp[i] != -1) return dp[i];\\n\\n        int ans = getMax(i + 1, n);\\n        if (record[i] != -1) ans = Math.max(ans, 1 + getMax(i + record[i], n));\\n        return dp[i] = ans;\\n    }\\n\\n    private void util(String s, int n, int k) {\\n        for (int ii = 0; ii < n; ii++) {\\n            long hashff = 0, hashss = 0, power = 1;\\n            for (int i = ii; i < n; i++) {\\n                int ascii = s.charAt(i) - \\'a\\' + 1;\\n                hashff = (hashff + ((ascii * power) % mod1)) % mod1;\\n                hashss = (hashss * p) % mod1;\\n                hashss = (hashss + ascii) % mod1;\\n                power = (power * p) % mod1;\\n\\n                if (hashff == hashss && (i - ii + 1) >= k) {\\n                    record[ii] = i - ii + 1;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808981,
                "title": "simple-linear-dp-0-n2",
                "content": "class Solution {\\npublic:\\n    int maxPalindromes(string str, int k) {\\n        \\n         int n = str.length();\\n         \\n         int dp[n];\\n         \\n         for(int i = 0; i < n; i++)\\n         {\\n             dp[i]  = 0;\\n         }\\n         \\n         for(int i = n-k; i >= 0 ; i--)\\n         {\\n             deque<char> dq1;\\n             \\n             deque<char> dq2;\\n             \\n             for(int j = i; j <= n-1; j++)\\n             {\\n                 dq1.push_front(str[j]);\\n                 \\n                 dq2.push_back(str[j]);\\n                 \\n                 if(dq1 == dq2 and j - i + 1 >= k)\\n                 {\\n                     dp[i] = 1 + (j + 1 < n ? dp[j+1] : 0);\\n                     \\n                     break;\\n                 }\\n             }\\n             \\n             dp[i] = max(dp[i],i + 1 < n ? dp[i+1] : 0);\\n         }\\n         \\n         return dp[0];\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maxPalindromes(string str, int k) {\\n        \\n         int n = str.length();\\n         \\n         int dp[n];\\n         \\n         for(int i = 0; i < n; i++)\\n         {\\n             dp[i]  = 0;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2808923,
                "title": "short-c-prefix-xor-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is_palin(int i, int j, string& s){\\n        while(i <= j){\\n             if(s[i] != s[j])\\n                  return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n         \\n    }\\n    int maxPalindromes(string s, int k) {\\n        int temp = 0,ans = 0;\\n        unordered_map<int,vector<int>>mp;\\n        if(k == 1)\\n             return s.size();\\n        for(int i = 0; i < s.size(); i++){\\n               temp = temp || (1 << (s[i] - \\'a\\'));\\n            int check = 0;\\n            if(mp.find(temp) != mp.end())\\n              for(int j = 0; j < mp[temp].size(); j++){\\n                  \\n                  if(__builtin_popcount(temp) <= 1 && abs(mp[temp][j] - i) + 1 >= k && is_palin(mp[temp][j],i,s)){\\n                      ans++;\\n                      mp.erase(mp.begin());\\n                      check = 1;\\n                  }     \\n              }\\n            if(check == 0)\\n                mp[temp].push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_palin(int i, int j, string& s){\\n        while(i <= j){\\n             if(s[i] != s[j])\\n                  return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n         \\n    }\\n    int maxPalindromes(string s, int k) {\\n        int temp = 0,ans = 0;\\n        unordered_map<int,vector<int>>mp;\\n        if(k == 1)\\n             return s.size();\\n        for(int i = 0; i < s.size(); i++){\\n               temp = temp || (1 << (s[i] - \\'a\\'));\\n            int check = 0;\\n            if(mp.find(temp) != mp.end())\\n              for(int j = 0; j < mp[temp].size(); j++){\\n                  \\n                  if(__builtin_popcount(temp) <= 1 && abs(mp[temp][j] - i) + 1 >= k && is_palin(mp[temp][j],i,s)){\\n                      ans++;\\n                      mp.erase(mp.begin());\\n                      check = 1;\\n                  }     \\n              }\\n            if(check == 0)\\n                mp[temp].push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808903,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\nll n, k;\\nstring s;\\nvi(vi(ll))dp, memo;\\nbool palin(ll l, ll r){\\n    if(l>=r){\\n        return 1;\\n    }\\n    ll&ans=memo[l][r];\\n    if(ans==-1){\\n        ans=palin(l+1, r-1) && s[l]==s[r];\\n    }\\n    return ans;\\n}\\nll func(ll in, ll pre){\\n    if(in==n){\\n        return (in-pre>=k && palin(pre, in-1));\\n    }\\n    ll&ans=dp[pre][in];\\n    if(ans==-1){\\n        ll take=func(in+1, pre), dont=(in-pre+1>=k && palin(pre, in))+func(in+1, in+1);\\n        ans=max(take, dont);\\n    }\\n    return ans;\\n}\\n    int maxPalindromes(const string&str, int K) {\\n        s=move(str), n=s.size(), k=K, dp.assign(n, vi(ll)(n, -1)), memo.assign(n, vi(ll)(n, -1));\\n        return func(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\nll n, k;\\nstring s;\\nvi(vi(ll))dp, memo;\\nbool palin(ll l, ll r){\\n    if(l>=r){\\n        return 1;\\n    }\\n    ll&ans=memo[l][r];\\n    if(ans==-1){\\n        ans=palin(l+1, r-1) && s[l]==s[r];\\n    }\\n    return ans;\\n}\\nll func(ll in, ll pre){\\n    if(in==n){\\n        return (in-pre>=k && palin(pre, in-1));\\n    }\\n    ll&ans=dp[pre][in];\\n    if(ans==-1){\\n        ll take=func(in+1, pre), dont=(in-pre+1>=k && palin(pre, in))+func(in+1, in+1);\\n        ans=max(take, dont);\\n    }\\n    return ans;\\n}\\n    int maxPalindromes(const string&str, int K) {\\n        s=move(str), n=s.size(), k=K, dp.assign(n, vi(ll)(n, -1)), memo.assign(n, vi(ll)(n, -1));\\n        return func(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808826,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int result = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (isPalindrome(s, i, i + k - 1)) {\\n                result++;\\n                i = i + k - 1;\\n            } else if (isPalindrome(s, i, i + k)) {\\n                result++;\\n                i = i + k;\\n            }\\n        }\\n        return result;\\n    }\\n    public boolean isPalindrome(String s, int startIndex, int endIndex) {\\n        if (endIndex >= s.length()) {\\n            return false;\\n        }\\n        while (startIndex <= endIndex) {\\n            char startChar = s.charAt(startIndex);\\n            char endChar = s.charAt(endIndex);\\n            if (startChar != endChar) {\\n                return false;\\n            }\\n            startIndex++;\\n            endIndex--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int result = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (isPalindrome(s, i, i + k - 1)) {\\n                result++;\\n                i = i + k - 1;\\n            } else if (isPalindrome(s, i, i + k)) {\\n                result++;\\n                i = i + k;\\n            }\\n        }\\n        return result;\\n    }\\n    public boolean isPalindrome(String s, int startIndex, int endIndex) {\\n        if (endIndex >= s.length()) {\\n            return false;\\n        }\\n        while (startIndex <= endIndex) {\\n            char startChar = s.charAt(startIndex);\\n            char endChar = s.charAt(endIndex);\\n            if (startChar != endChar) {\\n                return false;\\n            }\\n            startIndex++;\\n            endIndex--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808810,
                "title": "c-dp-sorting-greedy",
                "content": "# Approach\\nstep 1. determin the substring s[i : j] is palindrome or not for all 0<=i, j< n.\\nstep 2. record start point and end point of all palindrome substring whose size greater or eqaul to k. \\nstep 3. sort it by the end points in increasing order.\\nstep 4. traverse all intervals. Greedily pick current interval if it will not cause confliction.\\n\\n# Complexity\\n- Time complexity:\\ndetermin it is palindrome for all substring: O(n^2)\\nsorting: O(nlog n)\\n=> total O(n^2)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        if (k==1) return s.size();\\n        \\n        int n=s.size();\\n        vector<pair<int,int>> intervals;\\n        vector<vector<bool>> dp(n, vector<bool>(n, true));\\n        \\n        for (int diff=1; diff<n; ++diff) {\\n            for (int i=0, j=diff; j<n; ++i, ++j) {\\n                dp[i][j]=dp[i+1][j-1] && s[i]==s[j];\\n                \\n                if (dp[i][j] && diff+1>=k) intervals.push_back({i, j});\\n            }\\n        }\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int res=0;\\n        for (int i=0, cur=-1; i<intervals.size(); ++i) {\\n            if (cur < intervals[i].first) {\\n                cur=intervals[i].second;\\n                ++res;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    static bool compare(pair<int,int>& a, pair<int,int>& b) {\\n        return a.second<b.second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        if (k==1) return s.size();\\n        \\n        int n=s.size();\\n        vector<pair<int,int>> intervals;\\n        vector<vector<bool>> dp(n, vector<bool>(n, true));\\n        \\n        for (int diff=1; diff<n; ++diff) {\\n            for (int i=0, j=diff; j<n; ++i, ++j) {\\n                dp[i][j]=dp[i+1][j-1] && s[i]==s[j];\\n                \\n                if (dp[i][j] && diff+1>=k) intervals.push_back({i, j});\\n            }\\n        }\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int res=0;\\n        for (int i=0, cur=-1; i<intervals.size(); ++i) {\\n            if (cur < intervals[i].first) {\\n                cur=intervals[i].second;\\n                ++res;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    static bool compare(pair<int,int>& a, pair<int,int>& b) {\\n        return a.second<b.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059146,
                "title": "python-3-reduce-to-intervals-problem-o-n-2",
                "content": "# Intuition\\nIf all valid substrings are intervals then our task is to choose the maximum number of non-overlapping intervals\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        intervals = []\\n        for i in range(len(s)):\\n            # palindrome: ... s[i] ...\\n            for radius in range(min(i, len(s)-i-1)+1):\\n                l, r = i-radius, i+radius\\n                if s[l] != s[r]: break\\n                if r - l + 1 >= k:\\n                    intervals.append((l, r))\\n            # palindrome: ... s[i] s[i+1] ...                    \\n            if i + 1 < len(s) and s[i] == s[i+1]:\\n                for radius in range(min(i, len(s)-i-2)+1):\\n                    l, r = i-radius, i+1+radius\\n                    if s[l] != s[r]: break\\n                    if r - l + 1 >= k:\\n                        intervals.append((l, r))\\n        intervals.sort(key=lambda i: i[1])\\n        ans = 0\\n        last_end = -1\\n        for start, end in intervals:\\n            if start > last_end:\\n                ans += 1\\n                last_end = end\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        intervals = []\\n        for i in range(len(s)):\\n            # palindrome: ... s[i] ...\\n            for radius in range(min(i, len(s)-i-1)+1):\\n                l, r = i-radius, i+radius\\n                if s[l] != s[r]: break\\n                if r - l + 1 >= k:\\n                    intervals.append((l, r))\\n            # palindrome: ... s[i] s[i+1] ...                    \\n            if i + 1 < len(s) and s[i] == s[i+1]:\\n                for radius in range(min(i, len(s)-i-2)+1):\\n                    l, r = i-radius, i+1+radius\\n                    if s[l] != s[r]: break\\n                    if r - l + 1 >= k:\\n                        intervals.append((l, r))\\n        intervals.sort(key=lambda i: i[1])\\n        ans = 0\\n        last_end = -1\\n        for start, end in intervals:\\n            if start > last_end:\\n                ans += 1\\n                last_end = end\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965758,
                "title": "simple-c-solution-beats-93-81-in-time-96-39-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n=s.length();\\n        int ans=0;\\n        int prevind=-1;\\n        for(int i=0;i<n;i++){\\n            // for odd length substring\\n            int left=i, right=i;\\n            while(left>=0 && right<n && left>prevind && s[left]==s[right]){\\n                if(right-left+1>=k){\\n                     ans++;\\n                     i=right;\\n                     prevind=right;\\n                     break;\\n                }\\n                left--,   right++;\\n            }\\n            // for even length substring\\n            left=i, right=i+1;\\n            while(left>=0 && right<n && left>prevind && s[left]==s[right]){\\n                if(right-left+1>=k){\\n                     ans++;\\n                     i=right;\\n                     prevind=right;\\n                     break;\\n\\n                }\\n                left--, right++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n=s.length();\\n        int ans=0;\\n        int prevind=-1;\\n        for(int i=0;i<n;i++){\\n            // for odd length substring\\n            int left=i, right=i;\\n            while(left>=0 && right<n && left>prevind && s[left]==s[right]){\\n                if(right-left+1>=k){\\n                     ans++;\\n                     i=right;\\n                     prevind=right;\\n                     break;\\n                }\\n                left--,   right++;\\n            }\\n            // for even length substring\\n            left=i, right=i+1;\\n            while(left>=0 && right<n && left>prevind && s[left]==s[right]){\\n                if(right-left+1>=k){\\n                     ans++;\\n                     i=right;\\n                     prevind=right;\\n                     break;\\n\\n                }\\n                left--, right++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957206,
                "title": "21ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string& s, int k) {\\n        int dp[2001]={0},n=s.size();\\n        for(int i=0,p=0;i<s.size();i++)\\n        {\\n            int l=i,r=i;\\n            p=0;\\n            while(l>=0&&r<n&&s[l]==s[r])\\n            {\\n                p=r-l+1;\\n                if(p>=k)\\n                dp[r+1]=max(dp[r],dp[l]+1);\\n                r++,l--;\\n            }\\n            l=i,r=i+1;\\n            while(l>=0&&r<n&&s[l]==s[r])\\n            {\\n                p=r-l+1;\\n                if(p>=k)\\n                dp[r+1]=max(dp[r],dp[l]+1);\\n                r++,l--;\\n            }\\n            if(i)dp[i+1]=max(dp[i+1],dp[i]);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string& s, int k) {\\n        int dp[2001]={0},n=s.size();\\n        for(int i=0,p=0;i<s.size();i++)\\n        {\\n            int l=i,r=i;\\n            p=0;\\n            while(l>=0&&r<n&&s[l]==s[r])\\n            {\\n                p=r-l+1;\\n                if(p>=k)\\n                dp[r+1]=max(dp[r],dp[l]+1);\\n                r++,l--;\\n            }\\n            l=i,r=i+1;\\n            while(l>=0&&r<n&&s[l]==s[r])\\n            {\\n                p=r-l+1;\\n                if(p>=k)\\n                dp[r+1]=max(dp[r],dp[l]+1);\\n                r++,l--;\\n            }\\n            if(i)dp[i+1]=max(dp[i+1],dp[i]);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936949,
                "title": "c-beats-100-1d-dp-memoisation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int isPallindrome(string &s,int i,int k,int prev)\\n    {   int j=1;\\n        if(k==1)\\n        return i;\\n        \\n        //odd length pallindrome\\n\\n        while(i-j>prev && i+j<s.length() && s[i-j]==s[i+j])\\n        {\\n            cout<<i<<endl;\\n            cout<<\",\";\\n            if(j>=k/2)\\n            {\\n                cout<<\"odd\";\\n                cout<<i-j<<\" \"<<i+j<<endl;\\n                return i+j;\\n            }\\n            \\n            j++;\\n        }\\n\\n\\n        //even length pallindrome\\n        int l=i,r=i+1;\\n        while(l>prev && r<=s.length() && s[l]==s[r])\\n        {\\n            \\n            if(r-l+1>=k)\\n            {\\n                cout<<\"even:\";\\n                cout<<r<<\" \"<<l<<endl;\\n                return r;\\n            }\\n            \\n            l--;\\n            r++;\\n        }\\n        \\n        \\n\\n        return -2;\\n    }\\n    int f(string &s, int k,vector<int> &dp,int i,int prev)\\n    {\\n        if(i>=s.length())\\n        return 0;\\n\\n        if(dp[i]!=-1)\\n        return dp[i];\\n\\n        int z=isPallindrome(s,i,k,prev);\\n        if(z!=-2)\\n        {\\n            return dp[i]=(1+f(s,k,dp,i+k,z));\\n        }\\n        return dp[i]=f(s,k,dp,i+1,prev);\\n    }\\n    int maxPalindromes(string s, int k) {\\n        vector<int> dp(s.length(),-1);\\n        f(s,k,dp,0,-1);\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int isPallindrome(string &s,int i,int k,int prev)\\n    {   int j=1;\\n        if(k==1)\\n        return i;\\n        \\n        //odd length pallindrome\\n\\n        while(i-j>prev && i+j<s.length() && s[i-j]==s[i+j])\\n        {\\n            cout<<i<<endl;\\n            cout<<\",\";\\n            if(j>=k/2)\\n            {\\n                cout<<\"odd\";\\n                cout<<i-j<<\" \"<<i+j<<endl;\\n                return i+j;\\n            }\\n            \\n            j++;\\n        }\\n\\n\\n        //even length pallindrome\\n        int l=i,r=i+1;\\n        while(l>prev && r<=s.length() && s[l]==s[r])\\n        {\\n            \\n            if(r-l+1>=k)\\n            {\\n                cout<<\"even:\";\\n                cout<<r<<\" \"<<l<<endl;\\n                return r;\\n            }\\n            \\n            l--;\\n            r++;\\n        }\\n        \\n        \\n\\n        return -2;\\n    }\\n    int f(string &s, int k,vector<int> &dp,int i,int prev)\\n    {\\n        if(i>=s.length())\\n        return 0;\\n\\n        if(dp[i]!=-1)\\n        return dp[i];\\n\\n        int z=isPallindrome(s,i,k,prev);\\n        if(z!=-2)\\n        {\\n            return dp[i]=(1+f(s,k,dp,i+k,z));\\n        }\\n        return dp[i]=f(s,k,dp,i+1,prev);\\n    }\\n    int maxPalindromes(string s, int k) {\\n        vector<int> dp(s.length(),-1);\\n        f(s,k,dp,0,-1);\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3925266,
                "title": "easy-to-understand-dp",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n=s.length();\\n        vector<vector<bool>> check(n,vector<bool>(n,false));\\n        for(int i=0;i<n;i++){\\n            check[i][i]=true;\\n        }\\n        for(int len=2;len<=n;len++){\\n            for(int i=0;i+len<=n;i++){\\n                int l=i,r=i+len-1;\\n                if(l+1>r-1){\\n                    check[l][r]=(s[l]==s[r]);\\n                }else{\\n                    if(s[l]==s[r]){\\n                        check[l][r]=check[l+1][r-1];\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> dp(n,0);\\n        for(int i=0;i<n;i++){\\n            if(i-1>=0) dp[i]=dp[i-1];\\n            if(i-k+1<0) continue;\\n            if(i-k+1==0){\\n                if(check[i-k+1][i]==1) dp[i]=1;\\n            }\\n            for(int j=i-k;j>=0;j--){\\n                dp[i]=max(dp[i],dp[j]+(check[j+1][i]==1?1:0));\\n            }\\n            if(check[0][i]==1) dp[i]=max(dp[i],1);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n=s.length();\\n        vector<vector<bool>> check(n,vector<bool>(n,false));\\n        for(int i=0;i<n;i++){\\n            check[i][i]=true;\\n        }\\n        for(int len=2;len<=n;len++){\\n            for(int i=0;i+len<=n;i++){\\n                int l=i,r=i+len-1;\\n                if(l+1>r-1){\\n                    check[l][r]=(s[l]==s[r]);\\n                }else{\\n                    if(s[l]==s[r]){\\n                        check[l][r]=check[l+1][r-1];\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> dp(n,0);\\n        for(int i=0;i<n;i++){\\n            if(i-1>=0) dp[i]=dp[i-1];\\n            if(i-k+1<0) continue;\\n            if(i-k+1==0){\\n                if(check[i-k+1][i]==1) dp[i]=1;\\n            }\\n            for(int j=i-k;j>=0;j--){\\n                dp[i]=max(dp[i],dp[j]+(check[j+1][i]==1?1:0));\\n            }\\n            if(check[0][i]==1) dp[i]=max(dp[i],1);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918655,
                "title": "recursive-memorization-greedy",
                "content": "\\n* **Time Complexcity: O(NxN)**\\n* **space Complexcity: O(N)**\\n\\nIDEA: \\n\\n**1st option  :** don\\'t take it...\\n\\njust move to idx+1 bcz may be if we start from current index it  can happen that we might not get optimal solution bcz of these reasons..\\n\\n1) may be palindrome formed is very large and contains multiple palindromes of length>=k so here we wil get only one palindrome but bcz we started from this index we got only one  palindrome\\n2) may be no palindrome is formed\\n\\n**2nd option : take it...**\\njust start from idx and  && keep checking the current substring is a palindrome & ahve length >=k if yes we need to break beacuse we want to maximize the count so we try to get minimum possble length substring which satisfies all criteria so that we can have maximum no of palindrome. \\n\\ntake maximum of both solutions...\\nand at the end just memoize the  recursive approach :)\\n```\\n UPVOTE  :)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int k=0;\\n    string s=\"\";\\n    int n=0;\\n    int dp[2001];\\n    bool safe(int l, int r)\\n    {\\n        while(l<r)\\n        {\\n            if(s[l]!=s[r]) return false;\\n            l++;\\n            r--;\\n        }\\n        \\n        return true;\\n    }\\n    int solve(int idx)\\n    {\\n        if(idx==n) return 0;\\n        \\n        if(dp[idx]!=-1) return dp[idx];\\n\\t\\t\\n        int ans=solve(idx+1);   // don\\'t take it\\n       \\n        for(int i=idx; i<n; i++)\\n        {\\n            if(i-idx+1>=k)\\n            {\\n                if(safe(idx,i))\\n                {\\n                   ans= max(ans, solve(i+1)+1);// take it... and break it bcz we want maximum\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[idx]=ans;\\n    }\\n    \\n    int maxPalindromes(string s1, int k1) \\n    {\\n        s=s1;\\n        k=k1;\\n        n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n UPVOTE  :)\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int k=0;\\n    string s=\"\";\\n    int n=0;\\n    int dp[2001];\\n    bool safe(int l, int r)\\n    {\\n        while(l<r)\\n        {\\n            if(s[l]!=s[r]) return false;\\n            l++;\\n            r--;\\n        }\\n        \\n        return true;\\n    }\\n    int solve(int idx)\\n    {\\n        if(idx==n) return 0;\\n        \\n        if(dp[idx]!=-1) return dp[idx];\\n\\t\\t\\n        int ans=solve(idx+1);   // don\\'t take it\\n       \\n        for(int i=idx; i<n; i++)\\n        {\\n            if(i-idx+1>=k)\\n            {\\n                if(safe(idx,i))\\n                {\\n                   ans= max(ans, solve(i+1)+1);// take it... and break it bcz we want maximum\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[idx]=ans;\\n    }\\n    \\n    int maxPalindromes(string s1, int k1) \\n    {\\n        s=s1;\\n        k=k1;\\n        n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768291,
                "title": "simple-greedy-without-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever maximum non-overlapping is asked, it can be solved using Greedy approach(Ex- Max Meetings in a room). We just need to find the possible candidates and then we can apply the same approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need all the possible palindromic substrings that can be possible answer. \\nBut, do we really need all? \\nLet\\'s see with an example \"aba\", k=2\\nThis has 2 Palindromic substrings of length>=k \"ab\" and \"aba\"\\nBut we only need shortes one. Why? We need to maximize the number of substrings in our answer.\\nTherefore these substrings can be obtained by simple Brute Force and pruning(after first valid substring, break).\\nAfter this simply apply max meetings in a room algo.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &s)\\n    {\\n        int l=0,r=s.length()-1;\\n        while(l<=r)\\n            if(s[l++]!=s[r--])\\n                return false;\\n        return true;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n=s.length();\\n        vector<pair<int,int>> vec;\\n        for(int i=0;i<=n-k;i++)\\n        {\\n            string temp=s.substr(i,k);\\n            if(isPalindrome(temp))\\n            {\\n                vec.push_back({i+k-1,i});\\n                continue;\\n            }\\n            for(int j=i+k;j<n;j++)\\n            {\\n                temp+=s[j];\\n                if(isPalindrome(temp))\\n                {\\n                    vec.push_back({j,i});\\n                    break;\\n                }\\n            }\\n        }\\n        sort(vec.begin(),vec.end());\\n        int last=-1;\\n        int cnt=0;\\n        for(auto &each:vec)\\n        {\\n            if(each.second>last)\\n            {\\n                last=each.first;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &s)\\n    {\\n        int l=0,r=s.length()-1;\\n        while(l<=r)\\n            if(s[l++]!=s[r--])\\n                return false;\\n        return true;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n=s.length();\\n        vector<pair<int,int>> vec;\\n        for(int i=0;i<=n-k;i++)\\n        {\\n            string temp=s.substr(i,k);\\n            if(isPalindrome(temp))\\n            {\\n                vec.push_back({i+k-1,i});\\n                continue;\\n            }\\n            for(int j=i+k;j<n;j++)\\n            {\\n                temp+=s[j];\\n                if(isPalindrome(temp))\\n                {\\n                    vec.push_back({j,i});\\n                    break;\\n                }\\n            }\\n        }\\n        sort(vec.begin(),vec.end());\\n        int last=-1;\\n        int cnt=0;\\n        for(auto &each:vec)\\n        {\\n            if(each.second>last)\\n            {\\n                last=each.first;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761264,
                "title": "memoization-partition-dp-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // O(n^2)\\n    bool isPall(int i, int j, string &s, vector<vector<int>> &dp1){\\n        if(i >= j) return 1;\\n        if(dp1[i][j] != -1) return dp1[i][j];\\n        if(s[i] == s[j])\\n            return dp1[i][j] = isPall(i + 1, j- 1, s, dp1);\\n        return dp1[i][j] = 0;    \\n    }\\n\\n    // O(n^2)\\n    int solve(int ind, int k, string &s, vector<int> &dp2, vector<vector<int>> &dp1){\\n        if(ind == s.size())\\n            return 0;\\n        \\n        if(dp2[ind] != -1) return dp2[ind];\\n\\n        int res = 0;\\n\\n        // take \\n        for(int i = ind + k - 1; i < s.size(); i++){\\n            if(isPall(ind, i, s, dp1)){\\n                int temp = 1 + solve(i + 1, k, s, dp2, dp1);\\n                res = max(res, temp);\\n            }\\n        }\\n        // not take\\n        res = max(res, solve(ind + 1, k, s, dp2, dp1));\\n\\n        return dp2[ind] = res;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>> dp1(n + 1, vector<int>(n + 1, -1));\\n        vector<int> dp2(n + 1, -1);\\n\\n        return solve(0, k, s, dp2, dp1);\\n    }\\n};\\n\\n// TIME : O(n^2 + n^2)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // O(n^2)\\n    bool isPall(int i, int j, string &s, vector<vector<int>> &dp1){\\n        if(i >= j) return 1;\\n        if(dp1[i][j] != -1) return dp1[i][j];\\n        if(s[i] == s[j])\\n            return dp1[i][j] = isPall(i + 1, j- 1, s, dp1);\\n        return dp1[i][j] = 0;    \\n    }\\n\\n    // O(n^2)\\n    int solve(int ind, int k, string &s, vector<int> &dp2, vector<vector<int>> &dp1){\\n        if(ind == s.size())\\n            return 0;\\n        \\n        if(dp2[ind] != -1) return dp2[ind];\\n\\n        int res = 0;\\n\\n        // take \\n        for(int i = ind + k - 1; i < s.size(); i++){\\n            if(isPall(ind, i, s, dp1)){\\n                int temp = 1 + solve(i + 1, k, s, dp2, dp1);\\n                res = max(res, temp);\\n            }\\n        }\\n        // not take\\n        res = max(res, solve(ind + 1, k, s, dp2, dp1));\\n\\n        return dp2[ind] = res;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>> dp1(n + 1, vector<int>(n + 1, -1));\\n        vector<int> dp2(n + 1, -1);\\n\\n        return solve(0, k, s, dp2, dp1);\\n    }\\n};\\n\\n// TIME : O(n^2 + n^2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729047,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    int maxPalindromes(string s, int k) {\\n        int prev = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            prev = extendpalindorme(s,i,i,k,prev);\\n            prev = extendpalindorme(s,i,i+1,k,prev);\\n        }\\n        return cnt;\\n    }\\n\\n    int extendpalindorme(string s, int l, int r, int k, int prev) {\\n        int newp = prev;\\n        while(l >= prev and r < s.size() and s[l] == s[r]) {\\n            if(r-l+1 >= k) {\\n                cnt++;\\n                newp = r+1;\\n                break;\\n            }\\n            l--;r++;\\n        }\\n        return newp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    int maxPalindromes(string s, int k) {\\n        int prev = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            prev = extendpalindorme(s,i,i,k,prev);\\n            prev = extendpalindorme(s,i,i+1,k,prev);\\n        }\\n        return cnt;\\n    }\\n\\n    int extendpalindorme(string s, int l, int r, int k, int prev) {\\n        int newp = prev;\\n        while(l >= prev and r < s.size() and s[l] == s[r]) {\\n            if(r-l+1 >= k) {\\n                cnt++;\\n                newp = r+1;\\n                break;\\n            }\\n            l--;r++;\\n        }\\n        return newp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712097,
                "title": "dp-2-o-n-2-time-o-n-2-space",
                "content": "# Complexity\\n- Time complexity:\\n 2 * O(n^2)\\n\\n- Space complexity:\\nO(n ^ 2)\\n\\n# Code\\n```\\nclass Solution {\\n  public int maxPalindromes(String s, int k) {\\n    if (k == 1) {\\n      return s.length();\\n    }\\n\\n    if (k > s.length()) {\\n      return 0;\\n    }\\n\\n    if (s.length() == 2 && k == 2) {\\n      return s.charAt(0) == s.charAt(1) ? 1 : 0;\\n    }\\n\\n    boolean[][] dp = new boolean[s.length()][s.length()];\\n\\n    for (int i = s.length() - 1; i >= 0; i--) {\\n      for (int j = i; j < s.length(); j++) {\\n        if (j - i == 0) {\\n          dp[i][j] = true;\\n        } else if (j - i == 1) {\\n          dp[i][j] = s.charAt(i) == s.charAt(j);\\n        } else {\\n          dp[i][j] = s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1];\\n        }\\n      }\\n    }\\n\\n    int tail = 0;\\n    int maxNos = 0;\\n    for (int i = k - 1; i < s.length(); i++) {\\n      int m = tail;\\n      while (i - m + 1 >= k) {\\n        if (dp[m][i]) {\\n          maxNos++;\\n          tail = i + 1;\\n          break;\\n        }\\n\\n        m++;\\n      }\\n    }\\n\\n    return maxNos;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n  public int maxPalindromes(String s, int k) {\\n    if (k == 1) {\\n      return s.length();\\n    }\\n\\n    if (k > s.length()) {\\n      return 0;\\n    }\\n\\n    if (s.length() == 2 && k == 2) {\\n      return s.charAt(0) == s.charAt(1) ? 1 : 0;\\n    }\\n\\n    boolean[][] dp = new boolean[s.length()][s.length()];\\n\\n    for (int i = s.length() - 1; i >= 0; i--) {\\n      for (int j = i; j < s.length(); j++) {\\n        if (j - i == 0) {\\n          dp[i][j] = true;\\n        } else if (j - i == 1) {\\n          dp[i][j] = s.charAt(i) == s.charAt(j);\\n        } else {\\n          dp[i][j] = s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1];\\n        }\\n      }\\n    }\\n\\n    int tail = 0;\\n    int maxNos = 0;\\n    for (int i = k - 1; i < s.length(); i++) {\\n      int m = tail;\\n      while (i - m + 1 >= k) {\\n        if (dp[m][i]) {\\n          maxNos++;\\n          tail = i + 1;\\n          break;\\n        }\\n\\n        m++;\\n      }\\n    }\\n\\n    return maxNos;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708287,
                "title": "backtracking-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy intuition is\\'t pure recursion problem. The only issue with number of all the possible variants to go through. So to improve performance here we are going to use dynamic programming approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInner function `backtrack(start: Int)` here is to run actual recursion. It will provide maximum number of non overlapping palindromes starting from position `start`. `maxMap: HashMap` here is to cache previous results of `backtrack` function (keys are start position, values are max number of non overlapping palindromes starting from key start position).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxPalindromes(s: String, k: Int): Int {\\n        val length = s.length\\n        val maxMap = HashMap<Int, Int>()\\n\\n        fun backtrack(start: Int): Int {\\n            if (start + k > length) return 0\\n            maxMap[start]?.let { return it }\\n\\n            var max = backtrack(start + 1)\\n            for (count in k..(length - start)) {\\n                max = Math.max(max, s.isPalindrome(start, count) + backtrack(start + count))\\n            }\\n\\n            maxMap[start] = max\\n            return max\\n        }\\n\\n        return backtrack(0)\\n    }\\n\\n    private fun String.isPalindrome(start: Int, count: Int): Int {\\n        if (count < 0) return 0\\n        if (count < 2) return 1\\n\\n        var s = start\\n        var e = start + count - 1\\n\\n        while (s < e) {\\n            if (this[s] != this[e]) return 0\\n            s++\\n            e--\\n        }\\n\\n        return 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    fun maxPalindromes(s: String, k: Int): Int {\\n        val length = s.length\\n        val maxMap = HashMap<Int, Int>()\\n\\n        fun backtrack(start: Int): Int {\\n            if (start + k > length) return 0\\n            maxMap[start]?.let { return it }\\n\\n            var max = backtrack(start + 1)\\n            for (count in k..(length - start)) {\\n                max = Math.max(max, s.isPalindrome(start, count) + backtrack(start + count))\\n            }\\n\\n            maxMap[start] = max\\n            return max\\n        }\\n\\n        return backtrack(0)\\n    }\\n\\n    private fun String.isPalindrome(start: Int, count: Int): Int {\\n        if (count < 0) return 0\\n        if (count < 2) return 1\\n\\n        var s = start\\n        var e = start + count - 1\\n\\n        while (s < e) {\\n            if (this[s] != this[e]) return 0\\n            s++\\n            e--\\n        }\\n\\n        return 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702979,
                "title": "preprocess-the-palindrome-substring-dp-memorization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> dp;\\n    void create(string&s){\\n        int n = s.length();\\n        dp = vector<vector<int>> (n+1,vector<int>(n+1,0));\\n        for(int i=0; i<n; i++){\\n            dp[i][i] = 1;\\n            if(i+1<n && s[i]==s[i+1]){\\n                dp[i][i+1] = 1;\\n            }\\n        }\\n        for(int l=3; l<=n; l++){\\n            for(int i=0; i<n; i++){\\n                int j = i + l - 1;\\n                if(i+1<n && j-1<n && dp[i+1][j-1] && s[i]==s[j]){\\n                    dp[i][j] = 1;\\n                    // dp[j][i] = 1;\\n                }\\n            }\\n        }\\n    }\\n    int solve(string&s, int index,int k,vector<int>& dp1){\\n        if(index+k-1>=s.length()){\\n            return 0;\\n        }\\n        if(dp1[index]!=-1){\\n            return dp1[index];\\n        }\\n        int first = solve(s,index+1,k,dp1);\\n        for(int len=k; len<=s.length(); len++){\\n            int j = index + len-1;\\n            if(j<s.length() && dp[index][j]){\\n                first = max(first,1 + solve(s,j+1,k,dp1));\\n            }\\n        }\\n        return dp1[index] = first;\\n    }\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        create(s);\\n        int n = s.length();\\n        vector<int> dp1(n,-1);\\n        return solve(s,0,k,dp1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> dp;\\n    void create(string&s){\\n        int n = s.length();\\n        dp = vector<vector<int>> (n+1,vector<int>(n+1,0));\\n        for(int i=0; i<n; i++){\\n            dp[i][i] = 1;\\n            if(i+1<n && s[i]==s[i+1]){\\n                dp[i][i+1] = 1;\\n            }\\n        }\\n        for(int l=3; l<=n; l++){\\n            for(int i=0; i<n; i++){\\n                int j = i + l - 1;\\n                if(i+1<n && j-1<n && dp[i+1][j-1] && s[i]==s[j]){\\n                    dp[i][j] = 1;\\n                    // dp[j][i] = 1;\\n                }\\n            }\\n        }\\n    }\\n    int solve(string&s, int index,int k,vector<int>& dp1){\\n        if(index+k-1>=s.length()){\\n            return 0;\\n        }\\n        if(dp1[index]!=-1){\\n            return dp1[index];\\n        }\\n        int first = solve(s,index+1,k,dp1);\\n        for(int len=k; len<=s.length(); len++){\\n            int j = index + len-1;\\n            if(j<s.length() && dp[index][j]){\\n                first = max(first,1 + solve(s,j+1,k,dp1));\\n            }\\n        }\\n        return dp1[index] = first;\\n    }\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        create(s);\\n        int n = s.length();\\n        vector<int> dp1(n,-1);\\n        return solve(s,0,k,dp1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674750,
                "title": "c-solution-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int i, string&s, vector<int>&dp,int k){\\n        if(i==s.size()){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int ans=0;\\n        for(int j=i; j<s.size(); j++){\\n            if(j-i+1>=k and ispalindrome(s,i,j)){\\n                int cnt=1+find(j+1, s, dp,k);\\n                ans=max(ans, cnt);\\n            }\\n            else{\\n                 ans=max(ans, find(j+1,s,dp,k));\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n\\n    int maxPalindromes(string s, int k) {\\n        if(k==1){\\n            return s.size();\\n        }\\n        vector<int> dp(s.size()+1,-1);\\n        return find(0,s,dp,k);\\n        \\n    }\\n\\n    bool ispalindrome(string &s,int start ,int end){\\n        while(start<=end){\\n            if(s[start++]!=s[end--]){\\n                return false ;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int i, string&s, vector<int>&dp,int k){\\n        if(i==s.size()){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int ans=0;\\n        for(int j=i; j<s.size(); j++){\\n            if(j-i+1>=k and ispalindrome(s,i,j)){\\n                int cnt=1+find(j+1, s, dp,k);\\n                ans=max(ans, cnt);\\n            }\\n            else{\\n                 ans=max(ans, find(j+1,s,dp,k));\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n\\n    int maxPalindromes(string s, int k) {\\n        if(k==1){\\n            return s.size();\\n        }\\n        vector<int> dp(s.size()+1,-1);\\n        return find(0,s,dp,k);\\n        \\n    }\\n\\n    bool ispalindrome(string &s,int start ,int end){\\n        while(start<=end){\\n            if(s[start++]!=s[end--]){\\n                return false ;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655087,
                "title": "c-easy-solution-dp-memoization-optimal-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N$$*$$N)+O(N$$*$$N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N$$*$$N)+O(N$$*$$N)+(recursion stack space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dpp[2001];\\n    int find(int i,string& s,int& k,vector<vector<int>>& dp){\\n        if(i==s.size()){\\n            return 0;\\n        }\\n        if(dpp[i]!=-1){\\n            return dpp[i];\\n        }\\n        int not_take=find(i+1,s,k,dp);\\n        int take=0,maxi=0;\\n        for(int j=i;j<s.size();j++){\\n            if((j-i+1)>=k && dp[i][j]){\\n                maxi=max(maxi,1+find(j+1,s,k,dp));\\n            }\\n        }\\n        return dpp[i]=max(maxi,not_take);\\n    }\\n    int maxPalindromes(string s, int k) {\\n        memset(dpp,-1,sizeof(dpp));\\n        int n=s.size();\\n        vector<vector<int>> dp(n,vector<int>(n,false));\\n        for(int i=0;i<n;i++){\\n            dp[i][i]=1;\\n        }\\n        for(int k=1;k<n;k++){\\n            int i=k-1,j=k+1;\\n\\n            while(i>=0 && j<n && s[i]==s[j]){\\n                dp[i][j]=true;\\n                i--;j++;\\n                 \\n            }\\n            dp[i+1][j-1]=true;\\n            i=k-1,j=k;\\n            bool flag=false;\\n            while(i>=0 && j<n && s[i]==s[j]){\\n                dp[i][j]=true;\\n                i--;j++;\\n                flag=true;\\n            }\\n            if(flag){\\n                dp[i+1][j-1]=true;\\n            }\\n        }\\n        \\n        return find(0,s,k,dp);\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dpp[2001];\\n    int find(int i,string& s,int& k,vector<vector<int>>& dp){\\n        if(i==s.size()){\\n            return 0;\\n        }\\n        if(dpp[i]!=-1){\\n            return dpp[i];\\n        }\\n        int not_take=find(i+1,s,k,dp);\\n        int take=0,maxi=0;\\n        for(int j=i;j<s.size();j++){\\n            if((j-i+1)>=k && dp[i][j]){\\n                maxi=max(maxi,1+find(j+1,s,k,dp));\\n            }\\n        }\\n        return dpp[i]=max(maxi,not_take);\\n    }\\n    int maxPalindromes(string s, int k) {\\n        memset(dpp,-1,sizeof(dpp));\\n        int n=s.size();\\n        vector<vector<int>> dp(n,vector<int>(n,false));\\n        for(int i=0;i<n;i++){\\n            dp[i][i]=1;\\n        }\\n        for(int k=1;k<n;k++){\\n            int i=k-1,j=k+1;\\n\\n            while(i>=0 && j<n && s[i]==s[j]){\\n                dp[i][j]=true;\\n                i--;j++;\\n                 \\n            }\\n            dp[i+1][j-1]=true;\\n            i=k-1,j=k;\\n            bool flag=false;\\n            while(i>=0 && j<n && s[i]==s[j]){\\n                dp[i][j]=true;\\n                i--;j++;\\n                flag=true;\\n            }\\n            if(flag){\\n                dp[i+1][j-1]=true;\\n            }\\n        }\\n        \\n        return find(0,s,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610054,
                "title": "100-faster-100-in-space-intuitive-solution-o-n-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck all even and odd size palindrome also just keep a pointer start which will point to the next index of last palindrome found of size >= K\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int ans = 0, n = s.size();\\n        if(k == 1) return n;\\n        int start = 0;\\n        int low, high;\\n        for(int i = 1; i < n; ++i){\\n            //even\\n            low = i-1;\\n            high = i;\\n            while(low >= start and high < n and s[low] == s[high] ){\\n                if(high - low + 1 >= k){\\n                    start = high+1;\\n                    ans = ans + 1;\\n                }\\n                --low;\\n                ++high;\\n            }\\n\\n            //odd\\n            low = i-1;\\n            high = i+1;\\n            while(low >= start and high < n and s[low] == s[high] ){\\n                if(high - low + 1 >= k){\\n                    start = high+1;\\n                    ans = ans + 1;\\n                }\\n                --low;\\n                ++high;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int ans = 0, n = s.size();\\n        if(k == 1) return n;\\n        int start = 0;\\n        int low, high;\\n        for(int i = 1; i < n; ++i){\\n            //even\\n            low = i-1;\\n            high = i;\\n            while(low >= start and high < n and s[low] == s[high] ){\\n                if(high - low + 1 >= k){\\n                    start = high+1;\\n                    ans = ans + 1;\\n                }\\n                --low;\\n                ++high;\\n            }\\n\\n            //odd\\n            low = i-1;\\n            high = i+1;\\n            while(low >= start and high < n and s[low] == s[high] ){\\n                if(high - low + 1 >= k){\\n                    start = high+1;\\n                    ans = ans + 1;\\n                }\\n                --low;\\n                ++high;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586661,
                "title": "manacher-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass manacher\\n{\\n    vector<int> p;\\n\\npublic:\\n    manacher() {}\\n    void generatep(string s)\\n    {\\n        int n = s.length();\\n        p.resize(n, 1);\\n        int l = 1, r = 1;\\n\\n        for (int i = 1; i < n; i++)\\n        {\\n            p[i] = max(0, min(r - i, ((l + r - i) >= 0 && (l + r - i) < n) ? p[l + r - i] : INT_MAX));\\n            while ((i - p[i]) >= 0 and (i + p[i]) < n and s[i - p[i]] == s[i + p[i]])\\n            {\\n                p[i]++;  \\n            }\\n            if ((i + p[i]) > r)\\n            {\\n                l = i - p[i];\\n                r = i + p[i];\\n            }\\n        }\\n    }\\n\\n    int getmaxpalin(int cen, bool odd)\\n    {\\n        int idx = 2 * cen + 1 + !odd;\\n        return p[idx] - 1;\\n    }\\n\\n    int checkrange(int l, int r)\\n    {\\n        return (r - l + 1) <= (getmaxpalin((l + r) / 2, (l % 2) == (r % 2)));\\n    }\\n\\n    manacher(string s)\\n    {\\n        int len = s.length();\\n        string t = \"\";\\n        for (int i = 0; i < len; i++)\\n        {\\n            t += string(\"#\") + s[i];\\n        }\\n        t += string(\"#\");\\n        generatep(t); \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    int ff(manacher &m,string &s,int idx,int &n,int &k)\\n    {\\n        if(idx>=n)\\n        {\\n            return 0;\\n        }\\n\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        } \\n\\n        int maxi=0;\\n        maxi=max(maxi,ff(m,s,idx+1,n,k));\\n\\n        for(int i=idx;i<n;i++)\\n        {\\n            if(m.checkrange(idx,i) and (i-idx+1)>=k)\\n            { \\n                maxi=max(maxi,1+ff(m,s,i+1,n,k));\\n            }\\n        }\\n  \\n        return dp[idx]=maxi;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        manacher man(s);\\n        int ans=0;\\n        int n=s.length();\\n        dp.resize(n+1,-1);\\n\\n        return ff(man,s,0,n,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass manacher\\n{\\n    vector<int> p;\\n\\npublic:\\n    manacher() {}\\n    void generatep(string s)\\n    {\\n        int n = s.length();\\n        p.resize(n, 1);\\n        int l = 1, r = 1;\\n\\n        for (int i = 1; i < n; i++)\\n        {\\n            p[i] = max(0, min(r - i, ((l + r - i) >= 0 && (l + r - i) < n) ? p[l + r - i] : INT_MAX));\\n            while ((i - p[i]) >= 0 and (i + p[i]) < n and s[i - p[i]] == s[i + p[i]])\\n            {\\n                p[i]++;  \\n            }\\n            if ((i + p[i]) > r)\\n            {\\n                l = i - p[i];\\n                r = i + p[i];\\n            }\\n        }\\n    }\\n\\n    int getmaxpalin(int cen, bool odd)\\n    {\\n        int idx = 2 * cen + 1 + !odd;\\n        return p[idx] - 1;\\n    }\\n\\n    int checkrange(int l, int r)\\n    {\\n        return (r - l + 1) <= (getmaxpalin((l + r) / 2, (l % 2) == (r % 2)));\\n    }\\n\\n    manacher(string s)\\n    {\\n        int len = s.length();\\n        string t = \"\";\\n        for (int i = 0; i < len; i++)\\n        {\\n            t += string(\"#\") + s[i];\\n        }\\n        t += string(\"#\");\\n        generatep(t); \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    int ff(manacher &m,string &s,int idx,int &n,int &k)\\n    {\\n        if(idx>=n)\\n        {\\n            return 0;\\n        }\\n\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        } \\n\\n        int maxi=0;\\n        maxi=max(maxi,ff(m,s,idx+1,n,k));\\n\\n        for(int i=idx;i<n;i++)\\n        {\\n            if(m.checkrange(idx,i) and (i-idx+1)>=k)\\n            { \\n                maxi=max(maxi,1+ff(m,s,i+1,n,k));\\n            }\\n        }\\n  \\n        return dp[idx]=maxi;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        manacher man(s);\\n        int ans=0;\\n        int n=s.length();\\n        dp.resize(n+1,-1);\\n\\n        return ff(man,s,0,n,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518893,
                "title": "python-solution-using-dp-and-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        \\n        @cache\\n        def is_pal(l, r):\\n            if r <= l: return True\\n            return s[l] == s[r] and is_pal(l+1, r-1)\\n        \\n        dp = [0]\\n        for i in range(len(s)):\\n            count = 0\\n            for j in range(i-k+1, -1, -1):\\n                if s[i] == s[j] and is_pal(j+1, i-1):\\n                    count = dp[j] + 1\\n                    break\\n            \\n            dp.append(max(dp[-1], count))\\n            \\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        \\n        @cache\\n        def is_pal(l, r):\\n            if r <= l: return True\\n            return s[l] == s[r] and is_pal(l+1, r-1)\\n        \\n        dp = [0]\\n        for i in range(len(s)):\\n            count = 0\\n            for j in range(i-k+1, -1, -1):\\n                if s[i] == s[j] and is_pal(j+1, i-1):\\n                    count = dp[j] + 1\\n                    break\\n            \\n            dp.append(max(dp[-1], count))\\n            \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471441,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        \\n        int n = s.length();\\n        vector<int> dp(n + 1, 0);\\n        vector<vector<bool>> ok(n, vector<bool>(n, false));\\n        \\n        auto traverse = [&] (int left, int right) -> void {\\n            while (left >= 0 && right <= ok.size() && s[left] == s[right]) {\\n                ok[left][right] = true;\\n                left--; right++;\\n            }\\n        };\\n        \\n        for (int i = 0; i < n; i++) {\\n            traverse(i, i);\\n            traverse(i, i + 1);\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1];\\n            for (int j = 1; j <= i; j++) {\\n                if (ok[j - 1][i - 1] && i - j + 1 >= k) {\\n                    dp[i] = max(dp[i], dp[j - 1] + 1);\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n         \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        \\n        int n = s.length();\\n        vector<int> dp(n + 1, 0);\\n        vector<vector<bool>> ok(n, vector<bool>(n, false));\\n        \\n        auto traverse = [&] (int left, int right) -> void {\\n            while (left >= 0 && right <= ok.size() && s[left] == s[right]) {\\n                ok[left][right] = true;\\n                left--; right++;\\n            }\\n        };\\n        \\n        for (int i = 0; i < n; i++) {\\n            traverse(i, i);\\n            traverse(i, i + 1);\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1];\\n            for (int j = 1; j <= i; j++) {\\n                if (ok[j - 1][i - 1] && i - j + 1 >= k) {\\n                    dp[i] = max(dp[i], dp[j - 1] + 1);\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n         \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442223,
                "title": "golang-solution",
                "content": "0ms\\n\\n```\\npackage main\\n\\nfunc maxPalindromes(s string, k int) int {\\n\\tn := len(s)\\n\\n\\tinput := []byte(s)\\n\\tinput = append(input, \\'-\\')\\n\\n\\tcount := 0\\n\\tfor i := 0; i <= n-k; i++ {\\n\\t\\tif isPalindrome(input[i : i+k]) {\\n\\t\\t\\tcount++\\n\\t\\t\\ti = i + k - 1\\n\\t\\t} else if isPalindrome(input[i : i+k+1]) {\\n\\t\\t\\tcount++\\n\\t\\t\\ti = i + k\\n\\t\\t}\\n\\t}\\n\\treturn count\\n}\\n\\nfunc isPalindrome(s []byte) bool {\\n\\tfor l, r := 0, len(s)-1; l < r; l, r = l+1, r-1 {\\n\\t\\tif s[l] != s[r] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\n```\\n\\n\\n---\\n\\n\\n\\n\\nInitial Approach\\n\\n```\\nfunc maxPalindromes(s string, k int) int {\\n\\tn := len(s)\\n\\tif k == 1 {\\n\\t\\treturn n\\n\\t}\\n\\n\\tinput := []byte(s)\\n\\tinput = append(input, \\'-\\')\\n\\n\\tdp := make([]int, n+1)\\n\\n\\tfor i := n - k; i >= 0; i-- {\\n\\t\\tdp[i] = dp[i+1]\\n\\t\\tif isPalindrome(input[i : i+k]) {\\n\\t\\t\\tdp[i] = maxI(dp[i], 1+dp[i+k])\\n\\t\\t} else if isPalindrome(input[i : i+k+1]) {\\n\\t\\t\\tdp[i] = maxI(dp[i], 1+dp[i+k+1])\\n\\t\\t}\\n\\t}\\n\\treturn dp[0]\\n}\\n\\nfunc isPalindrome(s []byte) bool {\\n\\tfor l, r := 0, len(s)-1; l < r; l, r = l+1, r-1 {\\n\\t\\tif s[l] != s[r] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nfunc maxPalindromes(s string, k int) int {\\n\\tn := len(s)\\n\\n\\tinput := []byte(s)\\n\\tinput = append(input, \\'-\\')\\n\\n\\tcount := 0\\n\\tfor i := 0; i <= n-k; i++ {\\n\\t\\tif isPalindrome(input[i : i+k]) {\\n\\t\\t\\tcount++\\n\\t\\t\\ti = i + k - 1\\n\\t\\t} else if isPalindrome(input[i : i+k+1]) {\\n\\t\\t\\tcount++\\n\\t\\t\\ti = i + k\\n\\t\\t}\\n\\t}\\n\\treturn count\\n}\\n\\nfunc isPalindrome(s []byte) bool {\\n\\tfor l, r := 0, len(s)-1; l < r; l, r = l+1, r-1 {\\n\\t\\tif s[l] != s[r] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\n```\n```\\nfunc maxPalindromes(s string, k int) int {\\n\\tn := len(s)\\n\\tif k == 1 {\\n\\t\\treturn n\\n\\t}\\n\\n\\tinput := []byte(s)\\n\\tinput = append(input, \\'-\\')\\n\\n\\tdp := make([]int, n+1)\\n\\n\\tfor i := n - k; i >= 0; i-- {\\n\\t\\tdp[i] = dp[i+1]\\n\\t\\tif isPalindrome(input[i : i+k]) {\\n\\t\\t\\tdp[i] = maxI(dp[i], 1+dp[i+k])\\n\\t\\t} else if isPalindrome(input[i : i+k+1]) {\\n\\t\\t\\tdp[i] = maxI(dp[i], 1+dp[i+k+1])\\n\\t\\t}\\n\\t}\\n\\treturn dp[0]\\n}\\n\\nfunc isPalindrome(s []byte) bool {\\n\\tfor l, r := 0, len(s)-1; l < r; l, r = l+1, r-1 {\\n\\t\\tif s[l] != s[r] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3372747,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size() ;\\n        if(n == 1)\\n            return 1 ;\\n        vector<vector<bool>>isPalin(n, vector<bool>(n)) ;\\n        //len = 1\\n        for(int i = 0; i < n; i++)\\n            isPalin[i][i] = true ;\\n        //len = 2 \\n        for(int i = 0; i < n-1; i++){\\n            if(s[i] == s[i+1])\\n                isPalin[i][i+1] = true ;\\n        }\\n        for(int len = 3; len <= n; len++){\\n            for(int i = 0; i <= n-len; i++){\\n                int j = i+len-1 ;\\n                if(s[i] == s[j])\\n                    isPalin[i][j] = isPalin[i+1][j-1] ;\\n            }\\n        }\\n        \\n        vector<int>dp(n+1) ;\\n        for(int i = k-1; i < n; i++){\\n            dp[i+1] = dp[i] ;\\n            for(int j = i-k+1; j >= 0; j--){\\n                if(isPalin[j][i]){\\n                    dp[i+1] = max(dp[i+1], dp[j] + 1) ;\\n                    break ;\\n                }\\n            }\\n        }\\n        return dp[n] ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size() ;\\n        if(n == 1)\\n            return 1 ;\\n        vector<vector<bool>>isPalin(n, vector<bool>(n)) ;\\n        //len = 1\\n        for(int i = 0; i < n; i++)\\n            isPalin[i][i] = true ;\\n        //len = 2 \\n        for(int i = 0; i < n-1; i++){\\n            if(s[i] == s[i+1])\\n                isPalin[i][i+1] = true ;\\n        }\\n        for(int len = 3; len <= n; len++){\\n            for(int i = 0; i <= n-len; i++){\\n                int j = i+len-1 ;\\n                if(s[i] == s[j])\\n                    isPalin[i][j] = isPalin[i+1][j-1] ;\\n            }\\n        }\\n        \\n        vector<int>dp(n+1) ;\\n        for(int i = k-1; i < n; i++){\\n            dp[i+1] = dp[i] ;\\n            for(int j = i-k+1; j >= 0; j--){\\n                if(isPalin[j][i]){\\n                    dp[i+1] = max(dp[i+1], dp[j] + 1) ;\\n                    break ;\\n                }\\n            }\\n        }\\n        return dp[n] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319605,
                "title": "no-using-dp-not-best-but-all-right-solution-maybe-helpful-to-you",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmanacher algorithm might be helpful\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing manacher algorithm to find each palindrome substring length at least k,then deal with this problem same as schedule arrangement(max jobs in a time range)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2logN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public static int maxPalindromes(String s,int k){\\n        if(s == null || s.length() == 0 || s.length() < k){\\n            return 0;\\n        }\\n\\n        char[] str = s.toCharArray();\\n        //heap ,the same use in schedule arrangement\\n        PriorityQueue<Node> pq = new PriorityQueue<>(new NodeComparator());\\n        //manacher algorithm below\\n        char[] chs = new char[(str.length << 1) | 1];\\n        int newLen = chs.length;\\n        for (int i = 0;i < newLen;i++){\\n            if ((i & 1) == 0){\\n                chs[i] = \\'#\\';\\n            }else{\\n                chs[i] = str[i >>> 1];\\n            }\\n        }\\n        int c = -1;\\n        int r = -1;\\n        int[] pArr = new int[newLen];\\n        for (int i = 0;i < newLen;i++){\\n            int sym = (c << 1) - i;\\n            int l = (c << 1) - r;\\n            if (i > r || sym - pArr[sym] + 1 == l){\\n                int left = i - 1;\\n                int right = i + 1;\\n                while(left >= 0 && right < newLen && chs[left] == chs[right]){\\n                    left--;\\n                    right++;\\n                }\\n                pArr[i] = right - i;\\n                if (right - 1 > r){\\n                    c = i;\\n                    r = right - 1;\\n                }\\n            }else if (sym - pArr[sym] + 1 < l){\\n                pArr[i] = r - i + 1;\\n            }else{\\n                pArr[i] = pArr[sym];\\n            }\\n            if (pArr[i] - 1 >= k){\\n                int len = pArr[i] - 1;\\n                while(len - 2 >= k){\\n                    len -= 2;\\n                }\\n                pq.add(new Node(i - len,i + len));\\n            }\\n        }\\n        //same as schedule arrangement below \\n        int ans = 0;\\n        int start = 0;\\n        while(!pq.isEmpty()){\\n            Node node = pq.poll();\\n            if (node.s >= start){\\n                ans++;\\n                start = node.e;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public static class Node{\\n        public int s;\\n        public int e;\\n        public Node(int s,int e){\\n            this.s = s;\\n            this.e = e;\\n        }\\n    }\\n\\n    public static class NodeComparator implements Comparator<Node> {\\n\\n        @Override\\n        public int compare(Node o1, Node o2) {\\n            int res = Integer.compare(o1.e,o2.e);\\n            return res != 0 ? res : Integer.compare(o2.s,o1.s);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public static int maxPalindromes(String s,int k){\\n        if(s == null || s.length() == 0 || s.length() < k){\\n            return 0;\\n        }\\n\\n        char[] str = s.toCharArray();\\n        //heap ,the same use in schedule arrangement\\n        PriorityQueue<Node> pq = new PriorityQueue<>(new NodeComparator());\\n        //manacher algorithm below\\n        char[] chs = new char[(str.length << 1) | 1];\\n        int newLen = chs.length;\\n        for (int i = 0;i < newLen;i++){\\n            if ((i & 1) == 0){\\n                chs[i] = \\'#\\';\\n            }else{\\n                chs[i] = str[i >>> 1];\\n            }\\n        }\\n        int c = -1;\\n        int r = -1;\\n        int[] pArr = new int[newLen];\\n        for (int i = 0;i < newLen;i++){\\n            int sym = (c << 1) - i;\\n            int l = (c << 1) - r;\\n            if (i > r || sym - pArr[sym] + 1 == l){\\n                int left = i - 1;\\n                int right = i + 1;\\n                while(left >= 0 && right < newLen && chs[left] == chs[right]){\\n                    left--;\\n                    right++;\\n                }\\n                pArr[i] = right - i;\\n                if (right - 1 > r){\\n                    c = i;\\n                    r = right - 1;\\n                }\\n            }else if (sym - pArr[sym] + 1 < l){\\n                pArr[i] = r - i + 1;\\n            }else{\\n                pArr[i] = pArr[sym];\\n            }\\n            if (pArr[i] - 1 >= k){\\n                int len = pArr[i] - 1;\\n                while(len - 2 >= k){\\n                    len -= 2;\\n                }\\n                pq.add(new Node(i - len,i + len));\\n            }\\n        }\\n        //same as schedule arrangement below \\n        int ans = 0;\\n        int start = 0;\\n        while(!pq.isEmpty()){\\n            Node node = pq.poll();\\n            if (node.s >= start){\\n                ans++;\\n                start = node.e;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public static class Node{\\n        public int s;\\n        public int e;\\n        public Node(int s,int e){\\n            this.s = s;\\n            this.e = e;\\n        }\\n    }\\n\\n    public static class NodeComparator implements Comparator<Node> {\\n\\n        @Override\\n        public int compare(Node o1, Node o2) {\\n            int res = Integer.compare(o1.e,o2.e);\\n            return res != 0 ? res : Integer.compare(o2.s,o1.s);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298908,
                "title": "easy-c-solution",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int p[2001][2001];\\n    int dp[2000];\\n    string str;\\n\\n    /* bool isPalindrome(string s) // TLE\\n    {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        return s == t; \\n    } */\\n\\n    int solve(int ind, int n, int k)\\n    {\\n        if(ind == n) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        int maxi = 0;\\n        for(int i = ind; i < n; i++) {\\n            if(i - ind + 1 >= k and p[ind][i])\\n                maxi = max(maxi, 1 + solve(i + 1, n, k));\\n        }\\n\\n        maxi = max(maxi, solve(ind + 1, n, k));\\n        return dp[ind] = maxi;\\n    }\\n\\n    int maxPalindromes(string s, int k) \\n    {\\n        int n = s.size();\\n        str = s;\\n\\n        /* vector<vector<int>> p(n + 1, vector<int> (n + 1, 0));\\n        vector<int> dp(n + 1, -1); */\\n        memset(p, 0, sizeof(p));\\n        memset(dp, -1, sizeof(dp));\\n        \\n        for(int gap = 0; gap < n; gap++) {\\n            for(int i = 0, j = gap; j < n; i++, j++) {\\n                if(gap == 0) p[i][j] = 1;\\n                else if(gap == 1) p[i][j] = s[i] == s[j];\\n                else {\\n                    if(s[i] == s[j] and p[i + 1][j - 1]) // aba a == b and i + 1 and j - 1 = b; gap 2\\n                        p[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        return solve(0, n, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int p[2001][2001];\\n    int dp[2000];\\n    string str;\\n\\n    /* bool isPalindrome(string s) // TLE\\n    {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        return s == t; \\n    } */\\n\\n    int solve(int ind, int n, int k)\\n    {\\n        if(ind == n) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        int maxi = 0;\\n        for(int i = ind; i < n; i++) {\\n            if(i - ind + 1 >= k and p[ind][i])\\n                maxi = max(maxi, 1 + solve(i + 1, n, k));\\n        }\\n\\n        maxi = max(maxi, solve(ind + 1, n, k));\\n        return dp[ind] = maxi;\\n    }\\n\\n    int maxPalindromes(string s, int k) \\n    {\\n        int n = s.size();\\n        str = s;\\n\\n        /* vector<vector<int>> p(n + 1, vector<int> (n + 1, 0));\\n        vector<int> dp(n + 1, -1); */\\n        memset(p, 0, sizeof(p));\\n        memset(dp, -1, sizeof(dp));\\n        \\n        for(int gap = 0; gap < n; gap++) {\\n            for(int i = 0, j = gap; j < n; i++, j++) {\\n                if(gap == 0) p[i][j] = 1;\\n                else if(gap == 1) p[i][j] = s[i] == s[j];\\n                else {\\n                    if(s[i] == s[j] and p[i + 1][j - 1]) // aba a == b and i + 1 and j - 1 = b; gap 2\\n                        p[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        return solve(0, n, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284996,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        const int n = s.size();\\n        auto isPalin = vector(n, vector(n+1, false)); //i, len\\n        auto dp = vector(n+1, 0); \\n\\n        for(int i=0;i<n;i++){\\n            for(auto j : {i, i+1}){\\n                for(int d=0;i-d>=0 && j+d<n;d++){\\n                    int len = j+d - (i-d) + 1;\\n                    if(s[i-d] == s[j+d]) {\\n                        if(len >= k){\\n                            isPalin[i-d][len] = true;\\n                        }                        \\n                    }\\n                    else break;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            dp[i+1] = dp[i];\\n            for(int j=i-k+1;j>=0;j--){\\n                int len = i-j+1;\\n                if(isPalin[j][len]) \\n                    dp[i+1] = max(dp[i+1], 1+dp[j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        const int n = s.size();\\n        auto isPalin = vector(n, vector(n+1, false)); //i, len\\n        auto dp = vector(n+1, 0); \\n\\n        for(int i=0;i<n;i++){\\n            for(auto j : {i, i+1}){\\n                for(int d=0;i-d>=0 && j+d<n;d++){\\n                    int len = j+d - (i-d) + 1;\\n                    if(s[i-d] == s[j+d]) {\\n                        if(len >= k){\\n                            isPalin[i-d][len] = true;\\n                        }                        \\n                    }\\n                    else break;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            dp[i+1] = dp[i];\\n            for(int j=i-k+1;j>=0;j--){\\n                int len = i-j+1;\\n                if(isPalin[j][len]) \\n                    dp[i+1] = max(dp[i+1], 1+dp[j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240014,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint rec(vector<vector<int>>&dp,int ind,string &s,vector<int>&d,int k)\\n{\\n    if (ind==s.size()) return 0;\\n    if (d[ind]!=-1) return d[ind];\\n    int ans=-1;\\n    ans=rec(dp,ind+1,s,d,k);\\n    for (int end=ind+k-1;end<s.size();end++)\\n    {\\n        if (dp[ind][end])\\n        {\\n            ans=max(ans,1+rec(dp,end+1,s,d,k));\\n        }\\n    }\\n    return d[ind]=ans;\\n\\n}\\n    int maxPalindromes(string s, int k) \\n    {\\n        int n=s.size();\\n       vector<vector<int>>dp(n,vector<int>(n,0));\\n        for (int i=0;i<n;i++)\\n        {\\n            dp[i][i]=1;\\n        }\\n        for (int i=0;i<n-1;i++)\\n        {\\n            if (s[i]==s[i+1])\\n            {\\n                dp[i][i+1]=1;\\n            }\\n        }\\n        for (int len=3;len<=n;len++)\\n        {\\n           for (int i=0;i<=n-len;i++)\\n           {\\n               int j=i+len-1;\\n               if (dp[i+1][j-1] && s[i]==s[j])\\n               {\\n                   dp[i][j]=1;\\n               }\\n           }\\n        }\\n        vector<int>d(n,-1);\\n        return rec(dp,0,s,d,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint rec(vector<vector<int>>&dp,int ind,string &s,vector<int>&d,int k)\\n{\\n    if (ind==s.size()) return 0;\\n    if (d[ind]!=-1) return d[ind];\\n    int ans=-1;\\n    ans=rec(dp,ind+1,s,d,k);\\n    for (int end=ind+k-1;end<s.size();end++)\\n    {\\n        if (dp[ind][end])\\n        {\\n            ans=max(ans,1+rec(dp,end+1,s,d,k));\\n        }\\n    }\\n    return d[ind]=ans;\\n\\n}\\n    int maxPalindromes(string s, int k) \\n    {\\n        int n=s.size();\\n       vector<vector<int>>dp(n,vector<int>(n,0));\\n        for (int i=0;i<n;i++)\\n        {\\n            dp[i][i]=1;\\n        }\\n        for (int i=0;i<n-1;i++)\\n        {\\n            if (s[i]==s[i+1])\\n            {\\n                dp[i][i+1]=1;\\n            }\\n        }\\n        for (int len=3;len<=n;len++)\\n        {\\n           for (int i=0;i<=n-len;i++)\\n           {\\n               int j=i+len-1;\\n               if (dp[i+1][j-1] && s[i]==s[j])\\n               {\\n                   dp[i][j]=1;\\n               }\\n           }\\n        }\\n        vector<int>d(n,-1);\\n        return rec(dp,0,s,d,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207940,
                "title": "modified-count-palindromes-o-n-2-beats-100-time-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDefining a substring\\'s start and end pos and then checking if it is a palindrome would take n^3 time.\\n(2 nested loops for strt and end and 1 for ispalindrome).\\n\\nBut we can start from the center of a substring and traverse outwards, if we find a left and right index for which s[left]!=s[right] we break out.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOdd palindromes start from l=r=i\\nEven palindromes start from l=i, r=i+1\\nNow check if right+1-left>=k, if it is set i to right+k/2.\\nFor Odd case, set i to r+floor(k/2)\\nFor Even case, set i to r+floor(k/2)-1\\n\\nAlso, to avoid overlapping substrings, if last substring taken was odd, next should not be even unless i is incremented by 1 and vice versa.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        \\n        n = len(s)\\n        count = 0\\n        i = k//2-1\\n        lasteven=False\\n        lastodd=False\\n        while i<n:\\n            # odd pal\\n            l,r = i,i\\n            lastodd=False\\n            while not lasteven and l>=0 and r<n and s[l]==s[r]:\\n                if r-l>=k-1:\\n                    lastodd=True\\n                    i=r+k//2\\n                    count+=1\\n                    break\\n                l-=1\\n                r+=1\\n            # even pal\\n            l,r = i,i+1\\n            lasteven=False\\n            while not lastodd and l>=0 and r<n and s[l]==s[r]:\\n                if r-l>=k-1:\\n                    lasteven=True\\n                    i=r+k//2-1\\n                    count+=1\\n                    break\\n                l-=1\\n                r+=1\\n            i+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        \\n        n = len(s)\\n        count = 0\\n        i = k//2-1\\n        lasteven=False\\n        lastodd=False\\n        while i<n:\\n            # odd pal\\n            l,r = i,i\\n            lastodd=False\\n            while not lasteven and l>=0 and r<n and s[l]==s[r]:\\n                if r-l>=k-1:\\n                    lastodd=True\\n                    i=r+k//2\\n                    count+=1\\n                    break\\n                l-=1\\n                r+=1\\n            # even pal\\n            l,r = i,i+1\\n            lasteven=False\\n            while not lastodd and l>=0 and r<n and s[l]==s[r]:\\n                if r-l>=k-1:\\n                    lasteven=True\\n                    i=r+k//2-1\\n                    count+=1\\n                    break\\n                l-=1\\n                r+=1\\n            i+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191678,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int k;\\n    int n;\\n    int p[2001][2001];\\n    int memo[3000];\\n    int f(int idx)\\n    {\\n        if(idx>=n)\\n        {\\n            return 0;\\n        }\\n        if(memo[idx]!=-1)\\n        {\\n            return memo[idx];\\n        }\\n        int ans=0;\\n        for(int i=idx;i<n;i++)\\n        {\\n            if((i-idx+1>=k)&&p[idx][i])\\n            {\\n                ans=max(ans,1+f(i+1));\\n            }\\n        }\\n        ans=max(ans,f(idx+1));\\n        return memo[idx]=ans;\\n    }\\n    int maxPalindromes(string s, int K) \\n    {\\n        k=K;\\n        memset(p,0,sizeof(p));\\n        memset(memo,-1,sizeof(memo));\\n\\n        n=s.size();\\n        for(int gap=0;gap<n;gap++)\\n        {\\n            for(int i=0,j=gap;j<n;i++,j++)\\n            {\\n                if(gap==0)\\n                {\\n                    p[i][j]=1;\\n                }\\n                else if(gap==1)\\n                {\\n                    p[i][j]=(s[i]==s[j]);\\n                }\\n                else\\n                {\\n                    if(s[i]==s[j]&&p[i+1][j-1])\\n                    {\\n                        p[i][j]=1;\\n                    }\\n                }\\n                    \\n            }\\n        }     \\n        return f(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int k;\\n    int n;\\n    int p[2001][2001];\\n    int memo[3000];\\n    int f(int idx)\\n    {\\n        if(idx>=n)\\n        {\\n            return 0;\\n        }\\n        if(memo[idx]!=-1)\\n        {\\n            return memo[idx];\\n        }\\n        int ans=0;\\n        for(int i=idx;i<n;i++)\\n        {\\n            if((i-idx+1>=k)&&p[idx][i])\\n            {\\n                ans=max(ans,1+f(i+1));\\n            }\\n        }\\n        ans=max(ans,f(idx+1));\\n        return memo[idx]=ans;\\n    }\\n    int maxPalindromes(string s, int K) \\n    {\\n        k=K;\\n        memset(p,0,sizeof(p));\\n        memset(memo,-1,sizeof(memo));\\n\\n        n=s.size();\\n        for(int gap=0;gap<n;gap++)\\n        {\\n            for(int i=0,j=gap;j<n;i++,j++)\\n            {\\n                if(gap==0)\\n                {\\n                    p[i][j]=1;\\n                }\\n                else if(gap==1)\\n                {\\n                    p[i][j]=(s[i]==s[j]);\\n                }\\n                else\\n                {\\n                    if(s[i]==s[j]&&p[i+1][j-1])\\n                    {\\n                        p[i][j]=1;\\n                    }\\n                }\\n                    \\n            }\\n        }     \\n        return f(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169486,
                "title": "dp-solution-explained-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first save if s[l,r] is palindrome or not , then recursively solve for index i.e if we find any palindrome then we break as we need more palindromes and also ans will be compared with 1 + solve for next index and if we do not get palindrome then we try to solve for next index \\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> dp; // ind , ans\\n    int sol(string &s, int& k,vector<vector<bool>> &pal, int ind){\\n        if(ind == s.length()) return 0;\\n        if(dp.find(ind) != dp.end()) return dp[ind];\\n        int ans = 0;\\n        // we only have to solve for at least k length and palindrome\\n        ans = max(ans,sol(s,k,pal,ind+1));\\n        for(int i=ind;i<s.length();i++){\\n            if(pal[ind][i] && i >= ind+k-1){ ans = max(ans, 1 + sol(s,k,pal,i+1)); break; }\\n        }\\n        return dp[ind] = ans;\\n    }\\n\\n    int maxPalindromes(string s, int k) {\\n        vector<vector<bool>> pal(s.length(),vector<bool>(s.length(),0));\\n        for(int i=0;i<s.length();i++){\\n            for(int r = 0, c = i; c < s.length(); c++, r++){\\n                if(r == c || (s[r] == s[c] && (pal[r+1][c-1] || r+1 >= c-1))) pal[r][c] = 1;\\n            }\\n        }\\n        // Now we have palindromes\\n        return sol(s,k,pal,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> dp; // ind , ans\\n    int sol(string &s, int& k,vector<vector<bool>> &pal, int ind){\\n        if(ind == s.length()) return 0;\\n        if(dp.find(ind) != dp.end()) return dp[ind];\\n        int ans = 0;\\n        // we only have to solve for at least k length and palindrome\\n        ans = max(ans,sol(s,k,pal,ind+1));\\n        for(int i=ind;i<s.length();i++){\\n            if(pal[ind][i] && i >= ind+k-1){ ans = max(ans, 1 + sol(s,k,pal,i+1)); break; }\\n        }\\n        return dp[ind] = ans;\\n    }\\n\\n    int maxPalindromes(string s, int k) {\\n        vector<vector<bool>> pal(s.length(),vector<bool>(s.length(),0));\\n        for(int i=0;i<s.length();i++){\\n            for(int r = 0, c = i; c < s.length(); c++, r++){\\n                if(r == c || (s[r] == s[c] && (pal[r+1][c-1] || r+1 >= c-1))) pal[r][c] = 1;\\n            }\\n        }\\n        // Now we have palindromes\\n        return sol(s,k,pal,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153617,
                "title": "python-rolling-hash-to-detect-palindromes-dp",
                "content": "\\t\\tn = len(s)\\n        \\n\\t\\t# dp[i] is the number of non-overlapping palindromes at position i-1\\n\\t\\t# in the string s:\\n\\t\\tdp = [0]*(n+1)\\n        \\n\\t\\t# set-up for performing rolling hash. Using python pow() function\\n\\t\\t# for fast evaluation of the powers of the prime p in rh:\\n        letters = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        index = {char:(ind+1) for ind, char in enumerate(letters)}\\n        p, mod = 31, 10**9+7\\n        powers = {ii: pow(p, ii, mod) for ii in range(n)}\\n        \\n        for ii in range(n):\\n\\t\\t\\thh_f, hh_r = 0, 0\\n            dp[ii+1] = dp[ii]\\n            \\n            l = 0\\n            for jj in range(ii, -1, -1):\\n                char = s[jj]\\n                \\n\\t\\t\\t\\t# rolling hash hh_f is the value performed right->left starting at \\n\\t\\t\\t\\t# index ii and hash_r is the value performed left->right. When \\n\\t\\t\\t\\t# they are equal, then we have identified a palindrome:\\n\\t\\t\\t\\thh_f = (hh_f + index[char]*powers[l]) % mod\\n                hh_r = (hh_r*p + index[char]) % mod\\n                l += 1\\n                \\n\\t\\t\\t\\t# if our palindrome is at least length k, then update dp with\\n\\t\\t\\t\\t# a new palindrome. note position dp[jj] in our dp matrix is the\\n\\t\\t\\t\\t# value of dp that is one position to the left of the end of \\n\\t\\t\\t\\t# the pali we discovered:\\n                if hh_f == hh_r and l >= k:\\n                    dp[ii+1] = max(dp[ii+1], dp[jj]+1)\\n                    break\\n         \\n        ans = dp[-1]\\n        return(ans)",
                "solutionTags": [],
                "code": "\\t\\tn = len(s)\\n        \\n\\t\\t# dp[i] is the number of non-overlapping palindromes at position i-1\\n\\t\\t# in the string s:\\n\\t\\tdp = [0]*(n+1)\\n        \\n\\t\\t# set-up for performing rolling hash. Using python pow() function\\n\\t\\t# for fast evaluation of the powers of the prime p in rh:\\n        letters = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        index = {char:(ind+1) for ind, char in enumerate(letters)}\\n        p, mod = 31, 10**9+7\\n        powers = {ii: pow(p, ii, mod) for ii in range(n)}\\n        \\n        for ii in range(n):\\n\\t\\t\\thh_f, hh_r = 0, 0\\n            dp[ii+1] = dp[ii]\\n            \\n            l = 0\\n            for jj in range(ii, -1, -1):\\n                char = s[jj]\\n                \\n\\t\\t\\t\\t# rolling hash hh_f is the value performed right->left starting at \\n\\t\\t\\t\\t# index ii and hash_r is the value performed left->right. When \\n\\t\\t\\t\\t# they are equal, then we have identified a palindrome:\\n\\t\\t\\t\\thh_f = (hh_f + index[char]*powers[l]) % mod\\n                hh_r = (hh_r*p + index[char]) % mod\\n                l += 1\\n                \\n\\t\\t\\t\\t# if our palindrome is at least length k, then update dp with\\n\\t\\t\\t\\t# a new palindrome. note position dp[jj] in our dp matrix is the\\n\\t\\t\\t\\t# value of dp that is one position to the left of the end of \\n\\t\\t\\t\\t# the pali we discovered:\\n                if hh_f == hh_r and l >= k:\\n                    dp[ii+1] = max(dp[ii+1], dp[jj]+1)\\n                    break\\n         \\n        ans = dp[-1]\\n        return(ans)",
                "codeTag": "Unknown"
            },
            {
                "id": 3150049,
                "title": "python-sliding-window-dp",
                "content": "maintain sliding window. I use a deque() here\\nsliding window length will be k+1\\nCheck if length k or k+1 starting from end of window if it is a palindrome\\nIf palindrome, then check first previous index that is not part of window and +1 to the maximum number of palindromes\\n\\nOnly need to check k or k+1 because it does not help if to be a longer palindrome. But you can help form other palindromes if there are alphabets they need if this was shorter.\\n\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n     \\n        matrix=[0]*(len(s)+1)\\n        queue=deque()\\n        for i in range(k):\\n            queue.append(s[i])\\n        if ispalindrome(queue,0,len(queue)-1):\\n            matrix[k]=1\\n\\n    \\n        for i in range(k,len(s)):\\n            queue.append(s[i])\\n            matrix[i+1]=matrix[i]\\n            if ispalindrome(queue,1,len(queue)-1):\\n                matrix[i+1]=max(matrix[i+1-k]+1,matrix[i+1])\\n            \\n            if ispalindrome(queue,0,len(queue)-1):\\n                matrix[i+1]=max(matrix[i+1-k-1]+1,matrix[i+1]) \\n                \\n            queue.popleft()\\n            \\n        return matrix[-1]\\n    \\n    \\n    \\ndef ispalindrome(array,start,end):\\n    while start<end:\\n        if array[start]!=array[end]:\\n            return False\\n        start+=1\\n        end-=1\\n    return True",
                "solutionTags": [],
                "code": "maintain sliding window. I use a deque() here\\nsliding window length will be k+1\\nCheck if length k or k+1 starting from end of window if it is a palindrome\\nIf palindrome, then check first previous index that is not part of window and +1 to the maximum number of palindromes\\n\\nOnly need to check k or k+1 because it does not help if to be a longer palindrome. But you can help form other palindromes if there are alphabets they need if this was shorter.\\n\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n     \\n        matrix=[0]*(len(s)+1)\\n        queue=deque()\\n        for i in range(k):\\n            queue.append(s[i])\\n        if ispalindrome(queue,0,len(queue)-1):\\n            matrix[k]=1\\n\\n    \\n        for i in range(k,len(s)):\\n            queue.append(s[i])\\n            matrix[i+1]=matrix[i]\\n            if ispalindrome(queue,1,len(queue)-1):\\n                matrix[i+1]=max(matrix[i+1-k]+1,matrix[i+1])\\n            \\n            if ispalindrome(queue,0,len(queue)-1):\\n                matrix[i+1]=max(matrix[i+1-k-1]+1,matrix[i+1]) \\n                \\n            queue.popleft()\\n            \\n        return matrix[-1]\\n    \\n    \\n    \\ndef ispalindrome(array,start,end):\\n    while start<end:\\n        if array[start]!=array[end]:\\n            return False\\n        start+=1\\n        end-=1\\n    return True",
                "codeTag": "Java"
            },
            {
                "id": 3120384,
                "title": "easiest-solution",
                "content": "\\n```\\nclass Solution {\\n    fun maxPalindromes(s: String, k: Int): Int {\\n        val N = s.length\\n        // invalid: -1 , not palindrome: 0, is palindrome: 1 \\n        val palindromeMatrix = Array(N + 1) { IntArray(N + 1) { -1 } }\\n        for (i in 0 until N) {\\n            for (j in i until N) {\\n                createValidPalindromeMatrix(palindromeMatrix, i, j, s)\\n            }\\n        }\\n\\n        val validPalindromeRightIndex = HashMap<Int, Int>()\\n        for (i in 0 until N) {\\n            for (j in i until N) {\\n                if (palindromeMatrix[i][j] == 1 && (j - i + 1 >= k)) {\\n                    validPalindromeRightIndex[i] = j\\n                    break\\n                }\\n            }\\n        }\\n\\n        val maxPalindromes = IntArray(N) { -1 }\\n        return getMaxNumberOfPalindromes(validPalindromeRightIndex, maxPalindromes, 0)\\n    }\\n\\n    fun createValidPalindromeMatrix(palindromeMatrix: Array<IntArray>, i: Int, j: Int, s: String): Int {\\n        if (i >= j) {\\n            palindromeMatrix[i][j] = 1\\n            return 1\\n        }\\n\\n        if (palindromeMatrix[i][j] != -1) return palindromeMatrix[i][j]\\n\\n        if (s[i] == s[j] && createValidPalindromeMatrix(palindromeMatrix, i + 1, j - 1, s) == 1) {\\n            palindromeMatrix[i][j] = 1\\n        } else {\\n            palindromeMatrix[i][j] = 0\\n        }\\n\\n        return palindromeMatrix[i][j]\\n    }\\n\\n    fun getMaxNumberOfPalindromes(validPalindromeRightIndex: HashMap<Int, Int>, maxPalindromes: IntArray, i: Int): Int {\\n        if (i >= maxPalindromes.size) return 0\\n        if (!validPalindromeRightIndex.containsKey(i)) return getMaxNumberOfPalindromes(validPalindromeRightIndex, maxPalindromes, i + 1)\\n        if (maxPalindromes[i] != -1) return maxPalindromes[i]\\n\\n        val result1 = getMaxNumberOfPalindromes(validPalindromeRightIndex, maxPalindromes, i + 1)\\n        val j = validPalindromeRightIndex[i]!!\\n        val result2 = getMaxNumberOfPalindromes(validPalindromeRightIndex, maxPalindromes, j + 1) + 1\\n        maxPalindromes[i] = maxOf(result1, result2)\\n\\n        return maxPalindromes[i]\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maxPalindromes(s: String, k: Int): Int {\\n        val N = s.length\\n        // invalid: -1 , not palindrome: 0, is palindrome: 1 \\n        val palindromeMatrix = Array(N + 1) { IntArray(N + 1) { -1 } }\\n        for (i in 0 until N) {\\n            for (j in i until N) {\\n                createValidPalindromeMatrix(palindromeMatrix, i, j, s)\\n            }\\n        }\\n\\n        val validPalindromeRightIndex = HashMap<Int, Int>()\\n        for (i in 0 until N) {\\n            for (j in i until N) {\\n                if (palindromeMatrix[i][j] == 1 && (j - i + 1 >= k)) {\\n                    validPalindromeRightIndex[i] = j\\n                    break\\n                }\\n            }\\n        }\\n\\n        val maxPalindromes = IntArray(N) { -1 }\\n        return getMaxNumberOfPalindromes(validPalindromeRightIndex, maxPalindromes, 0)\\n    }\\n\\n    fun createValidPalindromeMatrix(palindromeMatrix: Array<IntArray>, i: Int, j: Int, s: String): Int {\\n        if (i >= j) {\\n            palindromeMatrix[i][j] = 1\\n            return 1\\n        }\\n\\n        if (palindromeMatrix[i][j] != -1) return palindromeMatrix[i][j]\\n\\n        if (s[i] == s[j] && createValidPalindromeMatrix(palindromeMatrix, i + 1, j - 1, s) == 1) {\\n            palindromeMatrix[i][j] = 1\\n        } else {\\n            palindromeMatrix[i][j] = 0\\n        }\\n\\n        return palindromeMatrix[i][j]\\n    }\\n\\n    fun getMaxNumberOfPalindromes(validPalindromeRightIndex: HashMap<Int, Int>, maxPalindromes: IntArray, i: Int): Int {\\n        if (i >= maxPalindromes.size) return 0\\n        if (!validPalindromeRightIndex.containsKey(i)) return getMaxNumberOfPalindromes(validPalindromeRightIndex, maxPalindromes, i + 1)\\n        if (maxPalindromes[i] != -1) return maxPalindromes[i]\\n\\n        val result1 = getMaxNumberOfPalindromes(validPalindromeRightIndex, maxPalindromes, i + 1)\\n        val j = validPalindromeRightIndex[i]!!\\n        val result2 = getMaxNumberOfPalindromes(validPalindromeRightIndex, maxPalindromes, j + 1) + 1\\n        maxPalindromes[i] = maxOf(result1, result2)\\n\\n        return maxPalindromes[i]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087716,
                "title": "fcuk-u-my-ex",
                "content": "# Intuition\\nThat\\'s what she said\\n\\n# Approach\\nNever approach her first(............I did and now I regret)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\nShe said we need some space.. and left me\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pal;\\n    vector<int> dp;\\n    int k;\\n    int rec(int idx,string &s){\\n        if(idx>=s.size()) return 0;\\n        if(dp[idx]!=-1) return dp[idx];\\n        int ans = 0;\\n        for(int j=idx;j<s.size();j++){\\n            if(pal[idx][j]){\\n                ans=max(ans,(j-idx+1>=k?1:0) + rec(j+1,s));\\n            }\\n        }\\n        return dp[idx] = ans;\\n    }\\n    int maxPalindromes(string s, int K) {\\n        int n =s.size();\\n        k=K;\\n        pal=vector<vector<int>>(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            int j=i-1,k=i+1;\\n            pal[i][i] =1;\\n            while(j>=0 and k<n and s[j]==s[k]){\\n                pal[j][k] = 1;\\n                j--;\\n                k++;\\n            }\\n            j=i,k=i+1;\\n            while(j>=0 and k<n and s[j]==s[k]){\\n                pal[j][k] = 1;\\n                j--;\\n                k++;\\n            }\\n        }\\n        dp=vector<int>(n,-1);\\n        return rec(0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pal;\\n    vector<int> dp;\\n    int k;\\n    int rec(int idx,string &s){\\n        if(idx>=s.size()) return 0;\\n        if(dp[idx]!=-1) return dp[idx];\\n        int ans = 0;\\n        for(int j=idx;j<s.size();j++){\\n            if(pal[idx][j]){\\n                ans=max(ans,(j-idx+1>=k?1:0) + rec(j+1,s));\\n            }\\n        }\\n        return dp[idx] = ans;\\n    }\\n    int maxPalindromes(string s, int K) {\\n        int n =s.size();\\n        k=K;\\n        pal=vector<vector<int>>(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            int j=i-1,k=i+1;\\n            pal[i][i] =1;\\n            while(j>=0 and k<n and s[j]==s[k]){\\n                pal[j][k] = 1;\\n                j--;\\n                k++;\\n            }\\n            j=i,k=i+1;\\n            while(j>=0 and k<n and s[j]==s[k]){\\n                pal[j][k] = 1;\\n                j--;\\n                k++;\\n            }\\n        }\\n        dp=vector<int>(n,-1);\\n        return rec(0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086853,
                "title": "simple-python-solution-o-n-with-explanation",
                "content": "# Approach\\n\\n\\n![Untitled-2023-01-11-1852(19).png](https://assets.leetcode.com/users/images/e7f8ad35-20db-40f0-9feb-e3a3f2477c83_1674401980.0501544.png)\\n\\nPalindromic substring cannot overlap, this means\\n\\n`max_count(0, i) = max_count(0, j) + max_count(j, i)`\\n\\nwhere `0 <= j <= i`\\n\\nNow, \\n\\n* we have to maximise `max_count(0, j)` and `max_count(j, i)`\\n    * `max_count(0, j)` is a sub-problem of our equation (the DP way)\\n    * but how to solve for `max_count(j, i)` ?\\n* lets simplify this \\n    * if `max_count(j, i)` can have value 0 or 1 \\n        * 1 in case `str[j:i+1]` is a palindrome, \\n    * we will only have to maximise `max_count(0, j)`\\n    * we can run two nested for-loops (for `i` and `j`) to solve the simplied dp equation \\n    * the time complexity is $$O(n^2)$$, and `n<=2000`, which means this could still give us TLE (Time Limit Exceeded)\\n* lets simplify further for `max_count(j, i)`\\n    * first time we will get maximum `max_count(j, i)` value ie one when a palindrome subsequence ends at `i`\\n    * since we have the condition of min length `k`, we have to check if there is a palindrome with length `k` or `k+1` ending at `i`\\n        * `k` and `k+1` to cover for odd and even palindromes\\n        * any other palindrome greater than `k+1` and ending at `i` is already covered in previous iterations\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n\\n# Code (`O(n)`)\\n``` python []\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n\\n        n = len(s)\\n\\n        def isPalindrome(i, j):\\n            if j < 0:\\n                return False\\n\\n            str = s[j : i + 1]\\n            rev_str = s[i : j - 1 : -1] if j > 0 else s[i::-1]\\n\\n            return str == rev_str\\n\\n        def getMaxPalindromes():\\n            mem = [0] * n\\n\\n            for i in range(k - 1, n):\\n                mem[i] = mem[i - 1] if i > 0 else 0\\n\\n                if isPalindrome(i, i - k + 1):\\n                    mem[i] = max(mem[i], mem[i - k] + 1)\\n\\n                if isPalindrome(i, i - k):\\n                    mem[i] = max(mem[i], mem[i - k - 1] + 1)\\n\\n            return mem[n - 1]\\n\\n        return getMaxPalindromes()\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "``` python []\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n\\n        n = len(s)\\n\\n        def isPalindrome(i, j):\\n            if j < 0:\\n                return False\\n\\n            str = s[j : i + 1]\\n            rev_str = s[i : j - 1 : -1] if j > 0 else s[i::-1]\\n\\n            return str == rev_str\\n\\n        def getMaxPalindromes():\\n            mem = [0] * n\\n\\n            for i in range(k - 1, n):\\n                mem[i] = mem[i - 1] if i > 0 else 0\\n\\n                if isPalindrome(i, i - k + 1):\\n                    mem[i] = max(mem[i], mem[i - k] + 1)\\n\\n                if isPalindrome(i, i - k):\\n                    mem[i] = max(mem[i], mem[i - k - 1] + 1)\\n\\n            return mem[n - 1]\\n\\n        return getMaxPalindromes()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047610,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPalindromes(self, s, k):\\n        n = len(s)\\n\\n        @lru_cache(None)\\n        def dfs(i):\\n            if i + k > n:\\n                return 0\\n\\n            max_val = dfs(i+1)\\n\\n            if s[i:i+k] == s[i:i+k][::-1]: max_val = max(max_val,1 + dfs(i+k))\\n            if s[i:i+k+1] == s[i:i+k+1][::-1]: max_val = max(max_val,1 + dfs(i+k+1))\\n\\n            return max_val\\n\\n        return dfs(0)\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s, k):\\n        n = len(s)\\n\\n        @lru_cache(None)\\n        def dfs(i):\\n            if i + k > n:\\n                return 0\\n\\n            max_val = dfs(i+1)\\n\\n            if s[i:i+k] == s[i:i+k][::-1]: max_val = max(max_val,1 + dfs(i+k))\\n            if s[i:i+k+1] == s[i:i+k+1][::-1]: max_val = max(max_val,1 + dfs(i+k+1))\\n\\n            return max_val\\n\\n        return dfs(0)\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030630,
                "title": "python3-find-smallest-palindromes",
                "content": "# Intuition\\nSmallest palindromes will be most in number\\n\\n# Approach\\nJust iterate over the string and find smallest possible palindrome for each index. Maintain a variable to keep track of last palindrome and make sure you don\\'t include it in next palindrome\\n\\n# Complexity\\n- Time complexity:\\nO(n*k)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        ans = 0\\n        last_result = -1\\n        i = 0\\n        while i < len(s):\\n            l, r = i, i + 1\\n            cur_last = inf\\n            seen = False\\n            while l > last_result and r < len(s):\\n                if s[l] == s[r]:\\n                    if r - l + 1 >= k:\\n                        cur_last = r\\n                        seen = True\\n                        break\\n                    l -= 1\\n                    r += 1\\n                else:\\n                    break\\n\\n            l, r = i, i\\n            while l > last_result and r < len(s):\\n                if s[l] == s[r]:\\n                    if r - l + 1 >= k:\\n                        cur_last = min(cur_last, r)\\n                        seen = True\\n                        break\\n                    l -= 1\\n                    r += 1\\n                else:\\n                    break\\n            if seen:\\n                last_result = cur_last\\n                i = cur_last + 1\\n                ans += 1\\n            else:\\n                i += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        ans = 0\\n        last_result = -1\\n        i = 0\\n        while i < len(s):\\n            l, r = i, i + 1\\n            cur_last = inf\\n            seen = False\\n            while l > last_result and r < len(s):\\n                if s[l] == s[r]:\\n                    if r - l + 1 >= k:\\n                        cur_last = r\\n                        seen = True\\n                        break\\n                    l -= 1\\n                    r += 1\\n                else:\\n                    break\\n\\n            l, r = i, i\\n            while l > last_result and r < len(s):\\n                if s[l] == s[r]:\\n                    if r - l + 1 >= k:\\n                        cur_last = min(cur_last, r)\\n                        seen = True\\n                        break\\n                    l -= 1\\n                    r += 1\\n                else:\\n                    break\\n            if seen:\\n                last_result = cur_last\\n                i = cur_last + 1\\n                ans += 1\\n            else:\\n                i += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013027,
                "title": "golang-search-with-memoization",
                "content": "\\n\\n# Code\\n```\\nfunc maxPalindromes(s string, k int) int {\\n    var list [][2]int\\n    for i := 0; i < len(s); i++ {\\n        for j := 0; j < len(s); j++ {\\n            if j * 2 + 2 >= k && isPali(s, i - j, i + 1 + j) {\\n                list = append(list, [2]int{i - j, i + 1 + j})\\n                break\\n            }\\n        }\\n        for j := 0; j < len(s); j++ {\\n            if j * 2 + 1 >= k && isPali(s, i - j, i + j) {\\n                list = append(list, [2]int{i - j, i + j})\\n                break\\n            }\\n        }\\n    }\\n\\n    sort.Slice(list, func(i int, j int) bool {\\n        if list[i][0] == list[j][0] {\\n            return list[i][1] < list[j][1]\\n        }\\n        return list[i][0] < list[j][0]\\n    })\\n\\n    memo := make([]int, len(list) + 1)\\n    for i := 0; i < len(memo); i++ {\\n        memo[i] = -1\\n    }\\n    return dfs(list, memo)\\n}\\n\\nfunc dfs(list [][2]int, memo []int) int {\\n    if len(list) == 0 {\\n        return 0\\n    }\\n\\n    if memo[len(list)] != -1 {\\n        return memo[len(list)]\\n    }\\n\\n    res := dfs(list[1:], memo)\\n    index := sort.Search(len(list), func(i int) bool {\\n        return list[i][0] > list[0][1]\\n    })\\n    res = max(res, 1 + dfs(list[index:], memo))\\n\\n    memo[len(list)] = res\\n  //  fmt.Println(list, res)\\n    return res\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc isPali(s string, a int, b int) bool {\\n    if a < 0 || b >= len(s) {\\n        return false\\n    }\\n    for a < b {\\n        if s[a] != s[b] {\\n            return false\\n        }\\n        a++\\n        b--\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxPalindromes(s string, k int) int {\\n    var list [][2]int\\n    for i := 0; i < len(s); i++ {\\n        for j := 0; j < len(s); j++ {\\n            if j * 2 + 2 >= k && isPali(s, i - j, i + 1 + j) {\\n                list = append(list, [2]int{i - j, i + 1 + j})\\n                break\\n            }\\n        }\\n        for j := 0; j < len(s); j++ {\\n            if j * 2 + 1 >= k && isPali(s, i - j, i + j) {\\n                list = append(list, [2]int{i - j, i + j})\\n                break\\n            }\\n        }\\n    }\\n\\n    sort.Slice(list, func(i int, j int) bool {\\n        if list[i][0] == list[j][0] {\\n            return list[i][1] < list[j][1]\\n        }\\n        return list[i][0] < list[j][0]\\n    })\\n\\n    memo := make([]int, len(list) + 1)\\n    for i := 0; i < len(memo); i++ {\\n        memo[i] = -1\\n    }\\n    return dfs(list, memo)\\n}\\n\\nfunc dfs(list [][2]int, memo []int) int {\\n    if len(list) == 0 {\\n        return 0\\n    }\\n\\n    if memo[len(list)] != -1 {\\n        return memo[len(list)]\\n    }\\n\\n    res := dfs(list[1:], memo)\\n    index := sort.Search(len(list), func(i int) bool {\\n        return list[i][0] > list[0][1]\\n    })\\n    res = max(res, 1 + dfs(list[index:], memo))\\n\\n    memo[len(list)] = res\\n  //  fmt.Println(list, res)\\n    return res\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc isPali(s string, a int, b int) bool {\\n    if a < 0 || b >= len(s) {\\n        return false\\n    }\\n    for a < b {\\n        if s[a] != s[b] {\\n            return false\\n        }\\n        a++\\n        b--\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3002061,
                "title": "longest-palindromic-substring-non-overlapping-intervals",
                "content": "```\\nclass Solution {\\nprivate:\\n    int countNonOverlappingIntervals(vector<pair<int,int>> &nums) {\\n        int n = nums.size();\\n        int count = 0;\\n        int i=0, j=1;\\n        \\n        while(j < n) {\\n            // Non-overlapping Events\\n            if(nums[i].second < nums[j].first) {\\n                i=j;\\n                j++;\\n            }\\n            \\n            // Overlapping intervals.\\n            \\n            // Case 1 : when first and second interval are overlapping in middle then discard second interval.\\n            else if(nums[i].second <= nums[j].second) {\\n                count++;\\n                j++;\\n            }\\n            \\n            // Case 2 : when first and second interval are overlapping and first is greater than second then discard first interval.\\n            else if(nums[i].second > nums[j].second) {\\n                count++;\\n                i=j;\\n                j++;\\n            }\\n        }\\n        return n - count;\\n    }\\n    \\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        int count = 0;\\n        vector<pair<int,int>> idx;\\n        \\n        if(k == 1) {\\n            for(int i=0;i<n;i++) {\\n                idx.push_back({i,i});\\n            }\\n        }\\n        \\n        // Check for even length substring.\\n        for(int i=1;i<n;i++) {\\n            int start = i-1, end = i;\\n            while(start>=0 && end<n && s[start] == s[end]) {\\n                if(end - start + 1 >= k) idx.push_back({start,end});\\n                start--;\\n                end++;\\n            }\\n        }\\n        \\n        // Check for odd length substring\\n        for(int i=1;i<n-1;i++) {\\n            int start = i-1, end = i+1;\\n            while(start>=0 && end<n && s[start] == s[end]) {\\n                if(end - start + 1 >= k) idx.push_back({start,end});\\n                start--;\\n                end++;\\n            }\\n        }\\n\\n        sort(idx.begin(), idx.end());\\n        return countNonOverlappingIntervals(idx);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int countNonOverlappingIntervals(vector<pair<int,int>> &nums) {\\n        int n = nums.size();\\n        int count = 0;\\n        int i=0, j=1;\\n        \\n        while(j < n) {\\n            // Non-overlapping Events\\n            if(nums[i].second < nums[j].first) {\\n                i=j;\\n                j++;\\n            }\\n            \\n            // Overlapping intervals.\\n            \\n            // Case 1 : when first and second interval are overlapping in middle then discard second interval.\\n            else if(nums[i].second <= nums[j].second) {\\n                count++;\\n                j++;\\n            }\\n            \\n            // Case 2 : when first and second interval are overlapping and first is greater than second then discard first interval.\\n            else if(nums[i].second > nums[j].second) {\\n                count++;\\n                i=j;\\n                j++;\\n            }\\n        }\\n        return n - count;\\n    }\\n    \\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        int count = 0;\\n        vector<pair<int,int>> idx;\\n        \\n        if(k == 1) {\\n            for(int i=0;i<n;i++) {\\n                idx.push_back({i,i});\\n            }\\n        }\\n        \\n        // Check for even length substring.\\n        for(int i=1;i<n;i++) {\\n            int start = i-1, end = i;\\n            while(start>=0 && end<n && s[start] == s[end]) {\\n                if(end - start + 1 >= k) idx.push_back({start,end});\\n                start--;\\n                end++;\\n            }\\n        }\\n        \\n        // Check for odd length substring\\n        for(int i=1;i<n-1;i++) {\\n            int start = i-1, end = i+1;\\n            while(start>=0 && end<n && s[start] == s[end]) {\\n                if(end - start + 1 >= k) idx.push_back({start,end});\\n                start--;\\n                end++;\\n            }\\n        }\\n\\n        sort(idx.begin(), idx.end());\\n        return countNonOverlappingIntervals(idx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965836,
                "title": "python-easy-to-read-and-understand-mcm",
                "content": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, l: int) -> int:\\n        n = len(s)\\n        t = [[[0,0] for _ in range(n)] for _ in range(n)]\\n        \\n        for g in range(n):\\n            i = 0\\n            for j in range(g, n):\\n                if g == 0:\\n                    t[i][j][1] = 1\\n                elif g == 1:\\n                    if s[i] == s[j]:\\n                        t[i][j][1] = 1\\n                else:\\n                    if s[i] == s[j] and t[i+1][j-1][1] == 1:\\n                        t[i][j][1] = 1\\n                if g >= l-1:\\n                    temp = 0\\n                    for k in range(i, j):\\n                        temp = max(temp, t[i][k][0]+t[k+1][j][0])\\n                    t[i][j][0] = max(t[i][j][1], temp)\\n                i += 1\\n        \\'\\'\\'\\n        for val in t:\\n            print(val)\\n        \\'\\'\\'\\n        return t[0][n-1][0]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, l: int) -> int:\\n        n = len(s)\\n        t = [[[0,0] for _ in range(n)] for _ in range(n)]\\n        \\n        for g in range(n):\\n            i = 0\\n            for j in range(g, n):\\n                if g == 0:\\n                    t[i][j][1] = 1\\n                elif g == 1:\\n                    if s[i] == s[j]:\\n                        t[i][j][1] = 1\\n                else:\\n                    if s[i] == s[j] and t[i+1][j-1][1] == 1:\\n                        t[i][j][1] = 1\\n                if g >= l-1:\\n                    temp = 0\\n                    for k in range(i, j):\\n                        temp = max(temp, t[i][k][0]+t[k+1][j][0])\\n                    t[i][j][0] = max(t[i][j][1], temp)\\n                i += 1\\n        \\'\\'\\'\\n        for val in t:\\n            print(val)\\n        \\'\\'\\'\\n        return t[0][n-1][0]",
                "codeTag": "Java"
            },
            {
                "id": 2943517,
                "title": "c-fast-simple-dp-o-n-2-self-explanatory",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &dp, string &s, int k, int idx, vector<vector<bool>> &IsPal)\\n    {\\n        int n = s.size();\\n        if(idx == n)return 0;\\n        if(dp[idx]!=-1)return dp[idx];\\n        int ans = solve(dp, s, k, idx+1, IsPal);\\n        for(int i=idx+k-1;i<n;i++)if(IsPal[idx][i])ans = max(ans, 1 + solve(dp, s, k, i+1,IsPal));\\n        return dp[idx] = ans;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        vector<vector<bool>> IsPal(n, vector<bool> (n, false));\\n        vector<int> dp(n+1, -1);\\n        for(int i=0;i<n;i++)IsPal[i][i]=true;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(s[i] == s[j])\\n                {\\n                    if(j == i+1)IsPal[i][j] = true;\\n                    else IsPal[i][j] = IsPal[i+1][j-1];\\n                }\\n            }\\n        }\\n        return solve(dp, s, k, 0, IsPal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &dp, string &s, int k, int idx, vector<vector<bool>> &IsPal)\\n    {\\n        int n = s.size();\\n        if(idx == n)return 0;\\n        if(dp[idx]!=-1)return dp[idx];\\n        int ans = solve(dp, s, k, idx+1, IsPal);\\n        for(int i=idx+k-1;i<n;i++)if(IsPal[idx][i])ans = max(ans, 1 + solve(dp, s, k, i+1,IsPal));\\n        return dp[idx] = ans;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        vector<vector<bool>> IsPal(n, vector<bool> (n, false));\\n        vector<int> dp(n+1, -1);\\n        for(int i=0;i<n;i++)IsPal[i][i]=true;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(s[i] == s[j])\\n                {\\n                    if(j == i+1)IsPal[i][j] = true;\\n                    else IsPal[i][j] = IsPal[i+1][j-1];\\n                }\\n            }\\n        }\\n        return solve(dp, s, k, 0, IsPal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900347,
                "title": "easy-dp-memoization-solution-java",
                "content": "# Intuition\\nSince The Question says clearly that we want Non-overlapping Palindrome Substrings, so for that we have to apply dp approch\\n\\n# Approach\\ns = \"abaccdbbd\", k = 3\\n\\nIn the first example we will start by atleast taking k length string\\nso intial we will take \"aba\" and checks whether it\\'s a palindrome or not and then update aur dp array accordingly\\n# Code\\n```\\nclass Solution {\\n    static int dp[];\\n    static boolean palin[][];\\n    static boolean calc[][];\\n    public int maxPalindromes(String s, int k) {\\n        int n=s.length();\\n        dp=new int[n];\\n        Arrays.fill(dp,-1);\\n        palin=new boolean[n][n];\\n        calc=new boolean[n][n];\\n        for(int i=0;i<palin.length;i++){\\n            for(int j=0;j<palin.length;j++){\\n                palin[i][j]=false;\\n            }\\n        }\\n        for(int i=0;i<palin.length;i++){\\n            for(int j=0;j<palin.length;j++){\\n                calc[i][j]=false;\\n            }\\n        }\\n        \\n        return dp_help(0,k,s);\\n    }\\n    public int dp_help(int idx,int k,String s){\\n        if(idx==s.length()){\\n            //means if i reached at the end\\n            return 0;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        dp[idx]=dp_help(idx+1,k,s);\\n        for(int j=idx+k-1;j<s.length();j++){\\n            //starting pair must be of length k //example 1->aba\\n            if(palin_check(s,idx,j)){\\n                dp[idx]=Math.max(dp[idx],1+dp_help(j+1,k,s));\\n            }\\n        }\\n        return dp[idx];\\n    }\\n    public boolean palin_check(String s,int left,int right){\\n        if(left>=right){\\n            return true;\\n        }\\n        if(calc[left][right]==true){\\n            return palin[left][right];\\n        }\\n        calc[left][right]=true;\\n        if(s.charAt(left)==s.charAt(right)){\\n            palin[left][right]=palin_check(s,left+1,right-1);\\n        }else{\\n            palin[left][right]=false;\\n        }\\n        return palin[left][right];\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int dp[];\\n    static boolean palin[][];\\n    static boolean calc[][];\\n    public int maxPalindromes(String s, int k) {\\n        int n=s.length();\\n        dp=new int[n];\\n        Arrays.fill(dp,-1);\\n        palin=new boolean[n][n];\\n        calc=new boolean[n][n];\\n        for(int i=0;i<palin.length;i++){\\n            for(int j=0;j<palin.length;j++){\\n                palin[i][j]=false;\\n            }\\n        }\\n        for(int i=0;i<palin.length;i++){\\n            for(int j=0;j<palin.length;j++){\\n                calc[i][j]=false;\\n            }\\n        }\\n        \\n        return dp_help(0,k,s);\\n    }\\n    public int dp_help(int idx,int k,String s){\\n        if(idx==s.length()){\\n            //means if i reached at the end\\n            return 0;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        dp[idx]=dp_help(idx+1,k,s);\\n        for(int j=idx+k-1;j<s.length();j++){\\n            //starting pair must be of length k //example 1->aba\\n            if(palin_check(s,idx,j)){\\n                dp[idx]=Math.max(dp[idx],1+dp_help(j+1,k,s));\\n            }\\n        }\\n        return dp[idx];\\n    }\\n    public boolean palin_check(String s,int left,int right){\\n        if(left>=right){\\n            return true;\\n        }\\n        if(calc[left][right]==true){\\n            return palin[left][right];\\n        }\\n        calc[left][right]=true;\\n        if(s.charAt(left)==s.charAt(right)){\\n            palin[left][right]=palin_check(s,left+1,right-1);\\n        }else{\\n            palin[left][right]=false;\\n        }\\n        return palin[left][right];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887850,
                "title": "c-dp-with-precomputation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool dp[2001][2001];\\n    int memo[2001];\\n    int func(string&s,int idx,int k,int n){\\n        if(idx==n) return 0;\\n        if(memo[idx]!=-1) return memo[idx];\\n        int ans=0;\\n        ans=func(s,idx+1,k,n);\\n        for(int i=idx+k-1;i<n;i++){\\n            if(dp[idx][i]) {ans=max(ans,1+func(s,i+1,k,n));break;}\\n        }\\n        return memo[idx]=ans;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        memset(memo,-1,sizeof(memo));\\n        int n=s.length();\\n        dp[0][0]=1;\\n        for(int i=1;i<n;i++){\\n            dp[i][i]=1;\\n            if(s[i]==s[i-1]) dp[i-1][i]=1;\\n        }\\n        for(int i=n-3;i>=0;i--){\\n            for(int j=i+2;j<n;j++){\\n                if(s[i]==s[j]&&dp[i+1][j-1]) dp[i][j]=1;\\n            }\\n        }\\n        return func(s,0,k,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dp[2001][2001];\\n    int memo[2001];\\n    int func(string&s,int idx,int k,int n){\\n        if(idx==n) return 0;\\n        if(memo[idx]!=-1) return memo[idx];\\n        int ans=0;\\n        ans=func(s,idx+1,k,n);\\n        for(int i=idx+k-1;i<n;i++){\\n            if(dp[idx][i]) {ans=max(ans,1+func(s,i+1,k,n));break;}\\n        }\\n        return memo[idx]=ans;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        memset(memo,-1,sizeof(memo));\\n        int n=s.length();\\n        dp[0][0]=1;\\n        for(int i=1;i<n;i++){\\n            dp[i][i]=1;\\n            if(s[i]==s[i-1]) dp[i-1][i]=1;\\n        }\\n        for(int i=n-3;i>=0;i--){\\n            for(int j=i+2;j<n;j++){\\n                if(s[i]==s[j]&&dp[i+1][j-1]) dp[i][j]=1;\\n            }\\n        }\\n        return func(s,0,k,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881810,
                "title": "dp-algorithm-with-greedy-as-optimization-100x-acceleration-to-pass-tight-time-limit",
                "content": "This question is more like an optimization than a DP problem. IMH the time limit is set too tight. Even the DP algorithm is correct, it can not pass without the tricky optimization.  \\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        n = len(s)\\n        @lru_cache(None)\\n        def isPalin(start, end):\\n            if start == end: return True\\n            if start + 1 == end: return s[start] == s[end]\\n            return s[start] == s[end] and isPalin(start + 1, end - 1)\\n\\n        @lru_cache(None)\\n        def dp(i):\\n            if i < 0: return 0\\n            ma = 0\\n            # Most important optimization, reduce large testcase\\'s running time from 1000ms to 10ms\\n            # check palindrome of size k and k+1 only\\n            # The k+2 case is greedily worse than k case\\n            # E.g. \\'cabac\\' is greedily worse than \\'aba\\'\\n            # \\'aba\\' is already covered in dp(i-1), so we skip checking \\'cabac\\' in this loop\\n            for j in range(i - k+1,max(-1, i-k-1),-1): \\n                if isPalin(j, i): \\n                    ma = max(ma, dp(j-1) + 1)\\n            ma = max(ma, dp(i-1))\\n            return ma\\n        \\n        return dp(len(s) - 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        n = len(s)\\n        @lru_cache(None)\\n        def isPalin(start, end):\\n            if start == end: return True\\n            if start + 1 == end: return s[start] == s[end]\\n            return s[start] == s[end] and isPalin(start + 1, end - 1)\\n\\n        @lru_cache(None)\\n        def dp(i):\\n            if i < 0: return 0\\n            ma = 0\\n            # Most important optimization, reduce large testcase\\'s running time from 1000ms to 10ms\\n            # check palindrome of size k and k+1 only\\n            # The k+2 case is greedily worse than k case\\n            # E.g. \\'cabac\\' is greedily worse than \\'aba\\'\\n            # \\'aba\\' is already covered in dp(i-1), so we skip checking \\'cabac\\' in this loop\\n            for j in range(i - k+1,max(-1, i-k-1),-1): \\n                if isPalin(j, i): \\n                    ma = max(ma, dp(j-1) + 1)\\n            ma = max(ma, dp(i-1))\\n            return ma\\n        \\n        return dp(len(s) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876244,
                "title": "dp-recursion-c-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cache[2001][2001];\\n    int cache2[2001];\\n    int is_palin(int i, int j, string &s) {\\n        if(i > j) {\\n            return true;\\n        }\\n        if(cache[i][j] != -1) {\\n            return cache[i][j];\\n        }\\n        int ans = (s[i] == s[j]);\\n        ans &= is_palin(i + 1, j - 1, s);\\n        return cache[i][j] = ans;\\n    }\\n\\n\\n    int dp(int i, int& k, string& s) {\\n        if(i == (int) s.size()) {\\n            return 0;\\n        }\\n        int& ans = cache2[i];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n        ans = 0;\\n        // either choose this\\n        for(int j = i + k - 1; j < (int) s.size(); j++) {\\n            if(is_palin(i, j, s)) {\\n                ans = max(ans, 1 + dp(j + 1, k, s));\\n            }\\n        }\\n        // either not choose this\\n        ans = max(ans, dp(i + 1, k, s));\\n        return ans;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        memset(cache, -1, sizeof(cache));\\n        memset(cache2, -1, sizeof(cache2));\\n        for(int i = 0; i < (int) s.size(); i++) {\\n            for(int j = i; j < (int) s.size(); j++) {\\n                is_palin(i, j, s);\\n            }\\n        }\\n        int ans = dp(0, k, s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cache[2001][2001];\\n    int cache2[2001];\\n    int is_palin(int i, int j, string &s) {\\n        if(i > j) {\\n            return true;\\n        }\\n        if(cache[i][j] != -1) {\\n            return cache[i][j];\\n        }\\n        int ans = (s[i] == s[j]);\\n        ans &= is_palin(i + 1, j - 1, s);\\n        return cache[i][j] = ans;\\n    }\\n\\n\\n    int dp(int i, int& k, string& s) {\\n        if(i == (int) s.size()) {\\n            return 0;\\n        }\\n        int& ans = cache2[i];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n        ans = 0;\\n        // either choose this\\n        for(int j = i + k - 1; j < (int) s.size(); j++) {\\n            if(is_palin(i, j, s)) {\\n                ans = max(ans, 1 + dp(j + 1, k, s));\\n            }\\n        }\\n        // either not choose this\\n        ans = max(ans, dp(i + 1, k, s));\\n        return ans;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        memset(cache, -1, sizeof(cache));\\n        memset(cache2, -1, sizeof(cache2));\\n        for(int i = 0; i < (int) s.size(); i++) {\\n            for(int j = i; j < (int) s.size(); j++) {\\n                is_palin(i, j, s);\\n            }\\n        }\\n        int ans = dp(0, k, s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865487,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def compare(self, left, right,s,  palindromes, k):\\n        while left >= 0 and right < len(s) and s[left] == s[right]:\\n            if right-left + 1 >= k:   \\n                palindromes[right] = max(palindromes[left-1] + 1, palindromes[right-1], palindromes[right])\\n            else:\\n                palindromes[right] = max(palindromes[left-1], palindromes[right])\\n                \\n            left -= 1\\n            right += 1\\n```\\n            \\n    \\n\\t\\n\\t``def maxPalindromes(self, s: str, k: int) -> int:\\n        \\n        palindromes = [0]*(len(s)+1)\\n        \\n        for i in range( len(s)):\\n            self.compare(i,i, s, palindromes, k)\\n            self.compare(i,i+1,s, palindromes, k)\\n\\n        return palindromes[-2]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def compare(self, left, right,s,  palindromes, k):\\n        while left >= 0 and right < len(s) and s[left] == s[right]:\\n            if right-left + 1 >= k:   \\n                palindromes[right] = max(palindromes[left-1] + 1, palindromes[right-1], palindromes[right])\\n            else:\\n                palindromes[right] = max(palindromes[left-1], palindromes[right])\\n                \\n            left -= 1\\n            right += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864351,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        unordered_map<int, int> even;\\n        unordered_map<int, int> odd;\\n        int len = s.length();\\n        for (int i = 0; i < len; ++i) {\\n            int l = i, r = i + 1;\\n            for (; l >= 0 && r < len; --l, ++r) {\\n                if (s[l] != s[r]) {\\n                    break;\\n                }\\n            }\\n            l++, r--;\\n            if (l < r) {\\n                even[i] = l;\\n            }\\n            l = i; \\n            r = i;\\n            for (; l >= 0 && r < len; --l, ++r) {\\n                if (s[l] != s[r]) {\\n                    break;\\n                }\\n            }\\n            l++, r--;\\n            if (l <= r) {\\n                odd[i] = l;\\n            }\\n        }\\n        vector<int> dp(len + 1, 0);\\n        for (int i = 1; i <= len; ++i) {\\n            dp[i] = dp[i - 1];\\n            for (int j = 0; j < i; ++j) {\\n                if (even.count(j) && j - even[j] >= i - 1 - j - 1) {\\n                    int l = j - (i - 1 - j - 1);\\n                    if (i - l >= k) {\\n                        dp[i] = max(dp[i], 1 + dp[l]);\\n                    }\\n                }\\n                if (odd.count(j) && j - odd[j] >= i - 1 - j) {\\n                    int l = j - (i - 1 - j);\\n                    if (i - l >= k) {\\n                        dp[i] = max(dp[i], 1 + dp[l]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[len];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        unordered_map<int, int> even;\\n        unordered_map<int, int> odd;\\n        int len = s.length();\\n        for (int i = 0; i < len; ++i) {\\n            int l = i, r = i + 1;\\n            for (; l >= 0 && r < len; --l, ++r) {\\n                if (s[l] != s[r]) {\\n                    break;\\n                }\\n            }\\n            l++, r--;\\n            if (l < r) {\\n                even[i] = l;\\n            }\\n            l = i; \\n            r = i;\\n            for (; l >= 0 && r < len; --l, ++r) {\\n                if (s[l] != s[r]) {\\n                    break;\\n                }\\n            }\\n            l++, r--;\\n            if (l <= r) {\\n                odd[i] = l;\\n            }\\n        }\\n        vector<int> dp(len + 1, 0);\\n        for (int i = 1; i <= len; ++i) {\\n            dp[i] = dp[i - 1];\\n            for (int j = 0; j < i; ++j) {\\n                if (even.count(j) && j - even[j] >= i - 1 - j - 1) {\\n                    int l = j - (i - 1 - j - 1);\\n                    if (i - l >= k) {\\n                        dp[i] = max(dp[i], 1 + dp[l]);\\n                    }\\n                }\\n                if (odd.count(j) && j - odd[j] >= i - 1 - j) {\\n                    int l = j - (i - 1 - j);\\n                    if (i - l >= k) {\\n                        dp[i] = max(dp[i], 1 + dp[l]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[len];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860323,
                "title": "c-dp-for-k-and-k-1-then-just-count",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size(); \\n        vector<vector<bool>> dp(n, vector<bool>(k+2, false));\\n        for (int i = 0; i < n; i++) dp[i][1] = true;\\n        for (int i = 1; i < n; i++) if (s[i-1]==s[i]) dp[i][2] = true;\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 3; j <= min(i+1, k+1); j++) {\\n                if (dp[i-1][j-2] and s[i] == s[i-j+1]) dp[i][j] = true; \\n            }\\n        }\\n        \\n        int p = -1e9;\\n        int ans = 0; \\n        for (int i = 0; i < n; i++) {\\n            if (dp[i][k]) {\\n                if (i-k>=p) {\\n                    ans++;\\n                    p = i; \\n                }\\n            }\\n            else if (dp[i][k+1]) {\\n                if (i-k-1>=p) {\\n                    ans++;\\n                    p = i; \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size(); \\n        vector<vector<bool>> dp(n, vector<bool>(k+2, false));\\n        for (int i = 0; i < n; i++) dp[i][1] = true;\\n        for (int i = 1; i < n; i++) if (s[i-1]==s[i]) dp[i][2] = true;\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 3; j <= min(i+1, k+1); j++) {\\n                if (dp[i-1][j-2] and s[i] == s[i-j+1]) dp[i][j] = true; \\n            }\\n        }\\n        \\n        int p = -1e9;\\n        int ans = 0; \\n        for (int i = 0; i < n; i++) {\\n            if (dp[i][k]) {\\n                if (i-k>=p) {\\n                    ans++;\\n                    p = i; \\n                }\\n            }\\n            else if (dp[i][k+1]) {\\n                if (i-k-1>=p) {\\n                    ans++;\\n                    p = i; \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847425,
                "title": "c-rolling-hash-dynamic-programming-o-n-2-solution",
                "content": "```\\nlong dp[2001];\\nint N;\\nclass Solution {\\npublic:\\n    long long mod = 1011001110001111;\\n    vector<int> palin[2001];\\n    int maxPalindromes(string s, int k) {\\n         N = s.size();\\n         for(int i=0; i<N; i++) {\\n              long long hashL = 0 , hashR = 0 , pw = 1 , base = 31;\\n              for(int j=i; j<N; j++) {\\n                     hashL = (hashL + (pw * (s[j] - \\'a\\' + 1))%mod) % mod;\\n                     hashR = ((hashR * base)%mod + (s[j] - \\'a\\' + 1)) % mod;\\n                     if(j-i+1>=k && hashL == hashR) palin[i].push_back(j);\\n                     pw = (pw * base) % mod;\\n              }\\n         }\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0);\\n    }\\n    long solve(int pos) {\\n         if(pos>=N) return 0;\\n         if(dp[pos]!=-1) return dp[pos];\\n         long cnt = solve(pos+1);\\n         for(int p : palin[pos]) cnt = max(cnt,1+solve(p+1));\\n         return dp[pos] = cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization",
                    "Rolling Hash"
                ],
                "code": "```\\nlong dp[2001];\\nint N;\\nclass Solution {\\npublic:\\n    long long mod = 1011001110001111;\\n    vector<int> palin[2001];\\n    int maxPalindromes(string s, int k) {\\n         N = s.size();\\n         for(int i=0; i<N; i++) {\\n              long long hashL = 0 , hashR = 0 , pw = 1 , base = 31;\\n              for(int j=i; j<N; j++) {\\n                     hashL = (hashL + (pw * (s[j] - \\'a\\' + 1))%mod) % mod;\\n                     hashR = ((hashR * base)%mod + (s[j] - \\'a\\' + 1)) % mod;\\n                     if(j-i+1>=k && hashL == hashR) palin[i].push_back(j);\\n                     pw = (pw * base) % mod;\\n              }\\n         }\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0);\\n    }\\n    long solve(int pos) {\\n         if(pos>=N) return 0;\\n         if(dp[pos]!=-1) return dp[pos];\\n         long cnt = solve(pos+1);\\n         for(int p : palin[pos]) cnt = max(cnt,1+solve(p+1));\\n         return dp[pos] = cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841058,
                "title": "naive-solution",
                "content": "1) create all substring which is >= k \\n2) check for pallindrom, if yes, then get there start and end index\\n3) now solve problem : return how many non overlapping interval are there\\n\\n```\\nclass Solution {\\n    \\n    List<int[]> store = new ArrayList<>();\\n    \\n    public int maxPalindromes(String s, int k) {\\n        \\n        int size = s.length();\\n        if(k == 0) return 0;\\n        if(k == 1) return size;\\n        \\n        \\n        for(int i = 0; i < size; i++){\\n            for(int j = i; j < size; j++){\\n                if(k+j <= size){\\n                    String str = s.substring(i, k+j);\\n                    checkPalindrome(str, i, k+j-1);\\n                }\\n            }\\n        }\\n        \\n        int interval[][] = store.toArray(new int[store.size()][2]);\\n        if(interval.length == 0) return 0;\\n        Arrays.sort(interval, (a,b)-> a[0]-b[0]);\\n        //for(int a[] : interval) System.out.println(a[0] +\" \" +a[1] );\\n        \\n        int count = 0;\\n        \\n        int i = 0; \\n        int j = 1;\\n        int palsize = store.size();\\n        while(j < palsize){\\n            \\n            int first[] = interval[i];\\n            int sec[] = interval[j];\\n            \\n            if(first[1] < sec[0]){\\n                i = j;\\n                j++;\\n            }else if(first[1] <= sec[1]){\\n                count++;\\n                j++;\\n            }else if(first[1] > sec[1]){\\n                i = j;\\n                j++;\\n                count++;\\n            }\\n            \\n        }\\n        return palsize-count;\\n    }\\n    \\n    public void checkPalindrome(String s, int f, int sec){\\n        \\n        int i = 0;\\n        int j = s.length()-1;\\n        \\n        while(i <= j){\\n            \\n            if(s.charAt(i) != s.charAt(j)){\\n                return;\\n            }else{\\n                i++;\\n                j--;\\n            }\\n        }\\n        System.out.println(f + \" \"+ sec);\\n        store.add(new int[]{f, sec});\\n        return;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<int[]> store = new ArrayList<>();\\n    \\n    public int maxPalindromes(String s, int k) {\\n        \\n        int size = s.length();\\n        if(k == 0) return 0;\\n        if(k == 1) return size;\\n        \\n        \\n        for(int i = 0; i < size; i++){\\n            for(int j = i; j < size; j++){\\n                if(k+j <= size){\\n                    String str = s.substring(i, k+j);\\n                    checkPalindrome(str, i, k+j-1);\\n                }\\n            }\\n        }\\n        \\n        int interval[][] = store.toArray(new int[store.size()][2]);\\n        if(interval.length == 0) return 0;\\n        Arrays.sort(interval, (a,b)-> a[0]-b[0]);\\n        //for(int a[] : interval) System.out.println(a[0] +\" \" +a[1] );\\n        \\n        int count = 0;\\n        \\n        int i = 0; \\n        int j = 1;\\n        int palsize = store.size();\\n        while(j < palsize){\\n            \\n            int first[] = interval[i];\\n            int sec[] = interval[j];\\n            \\n            if(first[1] < sec[0]){\\n                i = j;\\n                j++;\\n            }else if(first[1] <= sec[1]){\\n                count++;\\n                j++;\\n            }else if(first[1] > sec[1]){\\n                i = j;\\n                j++;\\n                count++;\\n            }\\n            \\n        }\\n        return palsize-count;\\n    }\\n    \\n    public void checkPalindrome(String s, int f, int sec){\\n        \\n        int i = 0;\\n        int j = s.length()-1;\\n        \\n        while(i <= j){\\n            \\n            if(s.charAt(i) != s.charAt(j)){\\n                return;\\n            }else{\\n                i++;\\n                j--;\\n            }\\n        }\\n        System.out.println(f + \" \"+ sec);\\n        store.add(new int[]{f, sec});\\n        return;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836375,
                "title": "python-greedy",
                "content": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        n, intervals, last, res = len(s), [], -inf, 0\\n        for center in range(2*n - 1):\\n            left = center//2\\n            right = left + center%2\\n            while left >= 0 and right < n and s[left] == s[right]:\\n                if right + 1 - left >= k:\\n                    intervals.append((left,right + 1))\\n                    break\\n                left -= 1\\n                right += 1\\n        intervals.sort(key = lambda x: x[1])\\n        for x, y in intervals:\\n            if x >= last:\\n                last = y\\n                res += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        n, intervals, last, res = len(s), [], -inf, 0\\n        for center in range(2*n - 1):\\n            left = center//2\\n            right = left + center%2\\n            while left >= 0 and right < n and s[left] == s[right]:\\n                if right + 1 - left >= k:\\n                    intervals.append((left,right + 1))\\n                    break\\n                left -= 1\\n                right += 1\\n        intervals.sort(key = lambda x: x[1])\\n        for x, y in intervals:\\n            if x >= last:\\n                last = y\\n                res += 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2833418,
                "title": "c-code-without-using-extra-space",
                "content": "# Intuition\\nstarting from the 1st character try to find the smallest polindrome substring of size greater than eual to k. \\n\\n# Approach\\nfor every I check if there is substring of size greater than equal to k. \\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n class Solution {\\n public:\\n    int ispolindrime(string str)\\n    {\\n        int n = str.size()-1;\\n        int start = 0;\\n        while(start < n)\\n        {\\n            if(str[start++] != str[n--])\\n                return false;\\n        }\\n        return true;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        int ans = 0;\\n        if(k == 1)\\n            return n;\\n        for(int i=0;i<=n-k;)\\n        {\\n            for(int j=(i+k-1);j<n;j++)\\n            {\\n                string temp = s.substr(i,(j-i+1)); \\n                if(temp.size()>k+1)\\n                    break;             \\n                if(ispolindrime(temp))\\n                {\\n                     ans++;\\n                     i = j;\\n                     break;\\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n };\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n class Solution {\\n public:\\n    int ispolindrime(string str)\\n    {\\n        int n = str.size()-1;\\n        int start = 0;\\n        while(start < n)\\n        {\\n            if(str[start++] != str[n--])\\n                return false;\\n        }\\n        return true;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        int ans = 0;\\n        if(k == 1)\\n            return n;\\n        for(int i=0;i<=n-k;)\\n        {\\n            for(int j=(i+k-1);j<n;j++)\\n            {\\n                string temp = s.substr(i,(j-i+1)); \\n                if(temp.size()>k+1)\\n                    break;             \\n                if(ispolindrime(temp))\\n                {\\n                     ans++;\\n                     i = j;\\n                     break;\\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n };\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832918,
                "title": "python-dp-solution-commented-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        # Every single character is a palindrome\\n        # So, in this case, non-overlapping substrings are the characters themselves\\n        if k == 1:\\n            return len(s)\\n        # Create a memo where we can get if a substring is palindrome in O(1)\\n        # pal stores a boolean for whether s[left:right] is palindrome for all substrings\\n        # of length from 1 to k + 1\\n        pal = [[False] * (len(s) + 1) for _ in range(len(s) + 1)]\\n        for length in range(1, k + 2):\\n            left = 0\\n            while left + length - 1 < len(s):\\n                right = left + length - 1\\n                pal[left][right] = (True if length < 3 else pal[left + 1][right - 1]) and (s[left] == s[right])\\n                left += 1\\n        \\n        # This is our DP. We start from an index idx and check if we have a palindrome\\n        # of length k or k + 1\\n        @cache\\n        def dp(idx: int, k: int) -> int:\\n            nonlocal s, pal\\n            # We reach the end of the string\\n            if idx + k > len(s):\\n                return 0\\n            # Leave the current index\\n            ans = 1 + dp(idx + 1, k);\\n            # Take a substring of length k at current index\\n            if pal[idx][idx + k - 1]:\\n                ans = max(ans, 2 + dp(idx + k, k))\\n            # Take a substring of length k + 1 at current index\\n            if idx + k < len(s) and pal[idx][idx + k]:\\n                ans = max(ans, 2 + dp(idx + k + 1, k))\\n            # Return maximum of all cases\\n            return ans - 1\\n        \\n        return dp(0, k)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        # Every single character is a palindrome\\n        # So, in this case, non-overlapping substrings are the characters themselves\\n        if k == 1:\\n            return len(s)\\n        # Create a memo where we can get if a substring is palindrome in O(1)\\n        # pal stores a boolean for whether s[left:right] is palindrome for all substrings\\n        # of length from 1 to k + 1\\n        pal = [[False] * (len(s) + 1) for _ in range(len(s) + 1)]\\n        for length in range(1, k + 2):\\n            left = 0\\n            while left + length - 1 < len(s):\\n                right = left + length - 1\\n                pal[left][right] = (True if length < 3 else pal[left + 1][right - 1]) and (s[left] == s[right])\\n                left += 1\\n        \\n        # This is our DP. We start from an index idx and check if we have a palindrome\\n        # of length k or k + 1\\n        @cache\\n        def dp(idx: int, k: int) -> int:\\n            nonlocal s, pal\\n            # We reach the end of the string\\n            if idx + k > len(s):\\n                return 0\\n            # Leave the current index\\n            ans = 1 + dp(idx + 1, k);\\n            # Take a substring of length k at current index\\n            if pal[idx][idx + k - 1]:\\n                ans = max(ans, 2 + dp(idx + k, k))\\n            # Take a substring of length k + 1 at current index\\n            if idx + k < len(s) and pal[idx][idx + k]:\\n                ans = max(ans, 2 + dp(idx + k + 1, k))\\n            # Return maximum of all cases\\n            return ans - 1\\n        \\n        return dp(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832685,
                "title": "optimal-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<bool>> is_palindrome;\\n    vector<vector<bool>> is_calculated;\\n    \\n    vector<int> max_palindromes;\\n    string s;\\n    \\n    bool IsPalindrome (int st, int ed) {\\n        if (st >= ed) return true;\\n        if (is_calculated[st][ed]) return is_palindrome[st][ed];\\n        \\n        is_calculated[st][ed] = true;\\n        \\n        if (s[st] == s[ed])\\n            is_palindrome[st][ed] = IsPalindrome(st+1, ed-1);\\n        else \\n            is_palindrome[st][ed] = false;\\n        \\n        return is_palindrome[st][ed];\\n    }\\n    \\n    int MaxPalindromes (int ind, const int k, const string& s) {\\n        int n = s.length();\\n        if (ind == n) return 0;\\n        \\n        int &ans = max_palindromes[ind];\\n        if (ans != -1) return ans;\\n        \\n        ans = MaxPalindromes(ind+1, k, s);\\n        \\n        for (int ed = ind+k-1; ed < n; ed ++) {\\n            if (IsPalindrome(ind, ed)) ans = max (ans, 1+MaxPalindromes(ed+1, k, s));\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int maxPalindromes(string _s, int k) {\\n        int n = _s.length();\\n        is_palindrome.resize(n, vector<bool>(n, false));\\n        is_calculated.resize(n, vector<bool>(n, false));\\n        max_palindromes.resize(n, -1);\\n        \\n        s = _s;\\n        return MaxPalindromes(0, k, s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<bool>> is_palindrome;\\n    vector<vector<bool>> is_calculated;\\n    \\n    vector<int> max_palindromes;\\n    string s;\\n    \\n    bool IsPalindrome (int st, int ed) {\\n        if (st >= ed) return true;\\n        if (is_calculated[st][ed]) return is_palindrome[st][ed];\\n        \\n        is_calculated[st][ed] = true;\\n        \\n        if (s[st] == s[ed])\\n            is_palindrome[st][ed] = IsPalindrome(st+1, ed-1);\\n        else \\n            is_palindrome[st][ed] = false;\\n        \\n        return is_palindrome[st][ed];\\n    }\\n    \\n    int MaxPalindromes (int ind, const int k, const string& s) {\\n        int n = s.length();\\n        if (ind == n) return 0;\\n        \\n        int &ans = max_palindromes[ind];\\n        if (ans != -1) return ans;\\n        \\n        ans = MaxPalindromes(ind+1, k, s);\\n        \\n        for (int ed = ind+k-1; ed < n; ed ++) {\\n            if (IsPalindrome(ind, ed)) ans = max (ans, 1+MaxPalindromes(ed+1, k, s));\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int maxPalindromes(string _s, int k) {\\n        int n = _s.length();\\n        is_palindrome.resize(n, vector<bool>(n, false));\\n        is_calculated.resize(n, vector<bool>(n, false));\\n        max_palindromes.resize(n, -1);\\n        \\n        s = _s;\\n        return MaxPalindromes(0, k, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830776,
                "title": "c-check-k-and-k-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int ans = 0, n = size(s);\\n        for (int i = 0; i < n; i++) {\\n            for (int sz = k; sz <= k+1 && i+sz <= n; sz++) {\\n                if (equal(begin(s)+i, begin(s)+i+sz/2, rbegin(s)+n-i-sz)) {\\n                    ans++, i = i+sz-1;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int ans = 0, n = size(s);\\n        for (int i = 0; i < n; i++) {\\n            for (int sz = k; sz <= k+1 && i+sz <= n; sz++) {\\n                if (equal(begin(s)+i, begin(s)+i+sz/2, rbegin(s)+n-i-sz)) {\\n                    ans++, i = i+sz-1;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830733,
                "title": "palindrome-partitioning-2-length-of-substring-is-atleast-k",
                "content": "## Palindrome Partitioning 2 (MCM) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        if(k == 1)\\n        {\\n            return s.length();\\n        }\\n        int n = s.length();\\n        vector<vector<bool>> pal(n, vector<bool> (n, false));\\n\\n        for(int g = 0; g < n; g++)\\n        {\\n            for(int i = 0, j = g; i < n && j < n; i++, j++)\\n            {\\n                if(g == 0)\\n                {\\n                    pal[i][j] = true;\\n                }\\n                else if(g == 1)\\n                {\\n                    char c1 = s[i];\\n                    char c2 = s[j];\\n                    if(c1 == c2)\\n                    {\\n                        pal[i][j] = true;\\n                    }\\n                    else\\n                    {\\n                        pal[i][j] = false;\\n                    }\\n                }\\n                else\\n                {\\n                    char c1 = s[i];\\n                    char c2 = s[j];\\n                    \\n                    if(c1 == c2)\\n                    {\\n                        pal[i][j] = pal[i][j] || pal[i+1][j-1];\\n                    }\\n                    else\\n                    {\\n                        pal[i][j] = false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<int> arr(n, 0);\\n        arr[0] = 0;\\n        int max_ans = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int val = arr[i-1];\\n            if(pal[0][i] && i + 1 >= k)\\n            {\\n                val = max(val, 1);\\n            }\\n            for(int j = 1; j <= i; j++)\\n            {\\n                if(i - j + 1 >= k && pal[j][i] == true)\\n                {\\n                    val = max(val, 1 + arr[j - 1]);\\n                }\\n            }\\n            arr[i] = max(arr[i], val);\\n        }\\n\\n        return arr[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        if(k == 1)\\n        {\\n            return s.length();\\n        }\\n        int n = s.length();\\n        vector<vector<bool>> pal(n, vector<bool> (n, false));\\n\\n        for(int g = 0; g < n; g++)\\n        {\\n            for(int i = 0, j = g; i < n && j < n; i++, j++)\\n            {\\n                if(g == 0)\\n                {\\n                    pal[i][j] = true;\\n                }\\n                else if(g == 1)\\n                {\\n                    char c1 = s[i];\\n                    char c2 = s[j];\\n                    if(c1 == c2)\\n                    {\\n                        pal[i][j] = true;\\n                    }\\n                    else\\n                    {\\n                        pal[i][j] = false;\\n                    }\\n                }\\n                else\\n                {\\n                    char c1 = s[i];\\n                    char c2 = s[j];\\n                    \\n                    if(c1 == c2)\\n                    {\\n                        pal[i][j] = pal[i][j] || pal[i+1][j-1];\\n                    }\\n                    else\\n                    {\\n                        pal[i][j] = false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<int> arr(n, 0);\\n        arr[0] = 0;\\n        int max_ans = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int val = arr[i-1];\\n            if(pal[0][i] && i + 1 >= k)\\n            {\\n                val = max(val, 1);\\n            }\\n            for(int j = 1; j <= i; j++)\\n            {\\n                if(i - j + 1 >= k && pal[j][i] == true)\\n                {\\n                    val = max(val, 1 + arr[j - 1]);\\n                }\\n            }\\n            arr[i] = max(arr[i], val);\\n        }\\n\\n        return arr[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829202,
                "title": "c-simple-solution-easy-explanation-tc-o-n-sc-o-1",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCheck the comments of the code. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string &s, int k) {\\n        int cnt = 0, start = 0;\\n\\n        for(int i = 0; i < s.size(); i++){\\n            // Check for odd length palindrome substring.\\n            int L = i, R = i, len = 0;\\n            // Check between [start to s.size()]\\n            while(L >= start && R <= s.size() && s[L] == s[R]){\\n                // Calculate the current length of the substring.\\n                len = R - L + 1;\\n                // When we found a minimum k size palindromic substring then break.\\n                // Because we need to find the maximum number of NON-OVERLAPPING\\n                // subsstring.\\n                if(len >= k)\\n                    break;\\n\\n                // Expand the boundaries.\\n                L--; R++;\\n            }\\n            // If we found a palindromic subsstring.\\n            if(len >= k){\\n                // Increment the answer.\\n                cnt++;\\n                // Move the STARTING position to R + 1 (REMEMBER: Non-Overlapping)\\n                // We dont want to recalculate the same subsstring over again.\\n                // That\\'s why it\\'s O(n) TC\\n                start = R + 1;\\n            }\\n\\n\\n            // Check for even length palindromic subsstring.\\n            L = i, R = i + 1, len = 0;\\n            // Check between [start to s.size()]\\n            while(L >= start && R <= s.size() && s[L] == s[R]){\\n                // Calculate the current length of the substring.\\n                len = R - L + 1;\\n\\n                // When we found a minimum k size palindromic substring then break.\\n                // Because we need to find the maximum number of NON-OVERLAPPING\\n                // subsstring.\\n                if(len >= k)\\n                    break;\\n\\n                // Expand the boundaries.\\n                L--; R++;\\n            }\\n            // If we found a palindromic subsstring.\\n            if(len >= k){\\n                // Increment the answer.\\n                cnt++;\\n                // Move the STARTING position to R + 1 (REMEMBER: Non-Overlapping)\\n                // We dont want to recalculate the same subsstring over again.  \\n                // That\\'s why it\\'s O(n) TC\\n                start = R + 1;\\n            }\\n        }\\n\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string &s, int k) {\\n        int cnt = 0, start = 0;\\n\\n        for(int i = 0; i < s.size(); i++){\\n            // Check for odd length palindrome substring.\\n            int L = i, R = i, len = 0;\\n            // Check between [start to s.size()]\\n            while(L >= start && R <= s.size() && s[L] == s[R]){\\n                // Calculate the current length of the substring.\\n                len = R - L + 1;\\n                // When we found a minimum k size palindromic substring then break.\\n                // Because we need to find the maximum number of NON-OVERLAPPING\\n                // subsstring.\\n                if(len >= k)\\n                    break;\\n\\n                // Expand the boundaries.\\n                L--; R++;\\n            }\\n            // If we found a palindromic subsstring.\\n            if(len >= k){\\n                // Increment the answer.\\n                cnt++;\\n                // Move the STARTING position to R + 1 (REMEMBER: Non-Overlapping)\\n                // We dont want to recalculate the same subsstring over again.\\n                // That\\'s why it\\'s O(n) TC\\n                start = R + 1;\\n            }\\n\\n\\n            // Check for even length palindromic subsstring.\\n            L = i, R = i + 1, len = 0;\\n            // Check between [start to s.size()]\\n            while(L >= start && R <= s.size() && s[L] == s[R]){\\n                // Calculate the current length of the substring.\\n                len = R - L + 1;\\n\\n                // When we found a minimum k size palindromic substring then break.\\n                // Because we need to find the maximum number of NON-OVERLAPPING\\n                // subsstring.\\n                if(len >= k)\\n                    break;\\n\\n                // Expand the boundaries.\\n                L--; R++;\\n            }\\n            // If we found a palindromic subsstring.\\n            if(len >= k){\\n                // Increment the answer.\\n                cnt++;\\n                // Move the STARTING position to R + 1 (REMEMBER: Non-Overlapping)\\n                // We dont want to recalculate the same subsstring over again.  \\n                // That\\'s why it\\'s O(n) TC\\n                start = R + 1;\\n            }\\n        }\\n\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829133,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ispal(string s){\\n        string p=s;\\n        reverse(s.begin(),s.end());\\n        return s==p;\\n    }\\n    int maxPalindromes(string s, int k) {\\n       int n=s.size();\\n       \\n        int dp[n+1];\\n        for(int i=0;i<n+1;i++){\\n            dp[i]=0;\\n        }\\n       \\n        for(int i=k-1;i<n;i++){\\n            for(int j=i-k+1;j>=0;j--){\\n                string s1=s.substr(j,i-j+1);\\n               if(dp[j]+1<dp[i]){\\n                   break;\\n               }\\n               else  if(ispal(s1)){\\n                    if(j!=0){\\n                    dp[i+1]=max(dp[j]+1,dp[i+1]);\\n                    }else{\\n                          dp[i+1]=max(1,dp[i+1]);\\n                    }\\n                }\\n            }\\n            if(dp[i+1]==0){\\n                dp[i+1]=dp[i];\\n            }\\n        }\\n         \\n        return dp[n];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    bool ispal(string s){\\n        string p=s;\\n        reverse(s.begin(),s.end());\\n        return s==p;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2827326,
                "title": "c-not-hard-solution-simple-solution-like-longest-palindrom-string",
                "content": "# Approach\\nWe will check palindrom at each index by going left and right side until size less than equal to k and found palindrom string\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n         int len=s.size();\\n        if(k==1) return len;\\n        int leftBreak=0;\\n        int ans=0;\\n        for(int i=0;i<len;i++){\\n            int start=i,end=i;\\n            \\n            while(start>=leftBreak && start>=0 && end<len && s[start]==s[end]){\\n                if(end-start+1>=k) {\\n                    ans++;\\n                    i=end;\\n                    leftBreak = end+1;\\n                    break;\\n                }\\n                start--;\\n                end++;\\n            }\\n            \\n            start=i,end=i+1;\\n            while(start>=leftBreak && start>=0 && end<len && s[start]==s[end]){\\n                \\n                if(end-start+1>=k ) {\\n                    ans++;\\n                    i=end;\\n                    leftBreak = end+1;\\n                    break;\\n                }\\n                start--;\\n                end++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n         int len=s.size();\\n        if(k==1) return len;\\n        int leftBreak=0;\\n        int ans=0;\\n        for(int i=0;i<len;i++){\\n            int start=i,end=i;\\n            \\n            while(start>=leftBreak && start>=0 && end<len && s[start]==s[end]){\\n                if(end-start+1>=k) {\\n                    ans++;\\n                    i=end;\\n                    leftBreak = end+1;\\n                    break;\\n                }\\n                start--;\\n                end++;\\n            }\\n            \\n            start=i,end=i+1;\\n            while(start>=leftBreak && start>=0 && end<len && s[start]==s[end]){\\n                \\n                if(end-start+1>=k ) {\\n                    ans++;\\n                    i=end;\\n                    leftBreak = end+1;\\n                    break;\\n                }\\n                start--;\\n                end++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826450,
                "title": "c-greedy-solution",
                "content": "class Solution {\\n    \\n    bool palin(string &s) {\\n        for(int i = 0; i < s.length() / 2; i++) {\\n            if(s[i] != s[s.length() - i - 1])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n\\tpublic:\\n    int maxPalindromes(string s, int k) {\\n        \\n        int n = s.length();\\n        int ans = 0;\\n        for(int i = 0; i + k <= n; i++) {\\n            \\n            string a = s.substr(i, k);\\n            if(palin(a)) {\\n                ans++;\\n                i += k - 1;\\n                continue;\\n            }\\n            \\n            if(i + k < n) {\\n                a += s[i + k];\\n                if(palin(a)) {\\n                    ans++;\\n                    i += k;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\n    \\n    bool palin(string &s) {\\n        for(int i = 0; i < s.length() / 2; i++) {\\n            if(s[i] != s[s.length() - i - 1])\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2826414,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.length();\\n        int dp[n+1];\\n        memset(dp, 0, sizeof(dp));\\n        bool pal[n+1][n+1];\\n        memset(pal, 0, sizeof(pal));\\n        for(int i=0;i<n;++i)pal[i][i]=1;\\n        for(int k=2;k<=n;++k){\\n            for(int i=0;i<=n-k;++i){\\n                int j=i+k-1;\\n                if(k==2){\\n                    pal[i][j]=(s[i]==s[j]);\\n                    continue;\\n                }\\n                pal[i][j]=(pal[i+1][j-1] &&(s[i]==s[j]));\\n            }\\n        }\\n        for(int i=1;i<=n;++i) {\\n            dp[i]=dp[i-1];\\n            for(int j=k;j<=i;++j) {\\n                int p = i-1;\\n                if(pal[p-j+1][p]) {\\n                    dp[i]=max(dp[i], dp[i-j]+1);\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.length();\\n        int dp[n+1];\\n        memset(dp, 0, sizeof(dp));\\n        bool pal[n+1][n+1];\\n        memset(pal, 0, sizeof(pal));\\n        for(int i=0;i<n;++i)pal[i][i]=1;\\n        for(int k=2;k<=n;++k){\\n            for(int i=0;i<=n-k;++i){\\n                int j=i+k-1;\\n                if(k==2){\\n                    pal[i][j]=(s[i]==s[j]);\\n                    continue;\\n                }\\n                pal[i][j]=(pal[i+1][j-1] &&(s[i]==s[j]));\\n            }\\n        }\\n        for(int i=1;i<=n;++i) {\\n            dp[i]=dp[i-1];\\n            for(int j=k;j<=i;++j) {\\n                int p = i-1;\\n                if(pal[p-j+1][p]) {\\n                    dp[i]=max(dp[i], dp[i-j]+1);\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825825,
                "title": "java-dp-o-n-2-simple",
                "content": "```java\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        // pre-process g[i][j] :  s[i, j] is palindrome or not\\n        int n = s.length();\\n        boolean[][] g = new boolean[n + 1][n + 1];\\n        \\n        for (int len = 1; len <= n; len++) {\\n            for (int i = 1; i + len - 1 <= n; i++) {\\n                int j = i + len - 1;\\n                if (len == 1) g[i][j] = true;\\n                else if (s.charAt(i - 1) == s.charAt(j - 1) && (g[i + 1][j - 1] || len == 2))\\n                    g[i][j] = true;\\n            }\\n        }\\n        \\n        int[] f = new int[n + 1];\\n        \\n        for (int i = 1; i <= n; i++) {\\n            f[i] = f[i - 1];\\n            for (int j = i - k; j >= 0; j--) {\\n                if (g[j + 1][i]) {\\n                    f[i] = Math.max(f[i], f[j] + 1);\\n                }\\n            }\\n        }\\n        return f[n];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        // pre-process g[i][j] :  s[i, j] is palindrome or not\\n        int n = s.length();\\n        boolean[][] g = new boolean[n + 1][n + 1];\\n        \\n        for (int len = 1; len <= n; len++) {\\n            for (int i = 1; i + len - 1 <= n; i++) {\\n                int j = i + len - 1;\\n                if (len == 1) g[i][j] = true;\\n                else if (s.charAt(i - 1) == s.charAt(j - 1) && (g[i + 1][j - 1] || len == 2))\\n                    g[i][j] = true;\\n            }\\n        }\\n        \\n        int[] f = new int[n + 1];\\n        \\n        for (int i = 1; i <= n; i++) {\\n            f[i] = f[i - 1];\\n            for (int j = i - k; j >= 0; j--) {\\n                if (g[j + 1][i]) {\\n                    f[i] = Math.max(f[i], f[j] + 1);\\n                }\\n            }\\n        }\\n        return f[n];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823929,
                "title": "c-ac-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    bool valid(int start, int end, string &s){\\n        while(start<end){\\n            if(s[start]==s[end]){\\n                start++;\\n                end--;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void getPalen(string s, unordered_map<int,int> &m, int &k){\\n        for(int i=0;i<s.size();i++){\\n            for(int j=i;j<s.size();j++){\\n                if(j-i+1>=k and valid(i, j, s)){\\n                    m[i]=j;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int getSol(int index, unordered_map<int,int> &m, string &s, vector<int> &dp){\\n        if(index>=s.size()){\\n            return 0;\\n        }\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        int ans=0;\\n        if(m.find(index)!=m.end() and m[index]<s.size())\\n            ans=getSol(m[index]+1, m, s, dp)+1;\\n        ans=max(getSol(index+1, m, s, dp), ans);\\n        dp[index]=ans;\\n        return dp[index];\\n    }\\n    \\n    int maxPalindromes(string s, int k) {\\n        unordered_map<int,int> m;\\n        getPalen(s, m, k);\\n        vector<int> dp(s.size(), -1);\\n        return getSol(0, m, s, dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool valid(int start, int end, string &s){\\n        while(start<end){\\n            if(s[start]==s[end]){\\n                start++;\\n                end--;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void getPalen(string s, unordered_map<int,int> &m, int &k){\\n        for(int i=0;i<s.size();i++){\\n            for(int j=i;j<s.size();j++){\\n                if(j-i+1>=k and valid(i, j, s)){\\n                    m[i]=j;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int getSol(int index, unordered_map<int,int> &m, string &s, vector<int> &dp){\\n        if(index>=s.size()){\\n            return 0;\\n        }\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        int ans=0;\\n        if(m.find(index)!=m.end() and m[index]<s.size())\\n            ans=getSol(m[index]+1, m, s, dp)+1;\\n        ans=max(getSol(index+1, m, s, dp), ans);\\n        dp[index]=ans;\\n        return dp[index];\\n    }\\n    \\n    int maxPalindromes(string s, int k) {\\n        unordered_map<int,int> m;\\n        getPalen(s, m, k);\\n        vector<int> dp(s.size(), -1);\\n        return getSol(0, m, s, dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823580,
                "title": "easiest-dp-solution-using-recursion-and-memoization",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Integer[] dp;\\n    public int maxPalindromes(String s, int k) {\\n\\n        Set<Character> set = new HashSet<>();\\n        for(char c : s.toCharArray()) set.add(c);\\n        if(set.size() == 1) return s.length()/k;\\n\\n        dp = new Integer[s.length()];\\n        return helper(s, 0, k);   \\n    }\\n    public int helper(String s, int index, int k) {\\n        if(index == s.length()) return 0;\\n        if(dp[index] != null) return dp[index];\\n\\n        int max = 0;\\n        for(int i=index+k; i<=s.length(); i++) {\\n            if(isPalindrome(s, index, i-1)) {\\n                max = Math.max(max, helper(s, i, k)+1);\\n            }\\n        }\\n        return dp[index] = Math.max(max, helper(s, index+1, k));\\n    }\\n    public boolean isPalindrome(String s, int start, int end) {\\n\\n        while(start<end) {\\n            if(s.charAt(start++) != s.charAt(end--)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Integer[] dp;\\n    public int maxPalindromes(String s, int k) {\\n\\n        Set<Character> set = new HashSet<>();\\n        for(char c : s.toCharArray()) set.add(c);\\n        if(set.size() == 1) return s.length()/k;\\n\\n        dp = new Integer[s.length()];\\n        return helper(s, 0, k);   \\n    }\\n    public int helper(String s, int index, int k) {\\n        if(index == s.length()) return 0;\\n        if(dp[index] != null) return dp[index];\\n\\n        int max = 0;\\n        for(int i=index+k; i<=s.length(); i++) {\\n            if(isPalindrome(s, index, i-1)) {\\n                max = Math.max(max, helper(s, i, k)+1);\\n            }\\n        }\\n        return dp[index] = Math.max(max, helper(s, index+1, k));\\n    }\\n    public boolean isPalindrome(String s, int start, int end) {\\n\\n        while(start<end) {\\n            if(s.charAt(start++) != s.charAt(end--)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823350,
                "title": "java-easy-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int maxPalindromes(String s, int k) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tboolean[][] dp = new boolean[n][n];\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t\\tdp[i][i] = true;\\n\\n\\t\\t\\tfor(int i = 1; i < n; i++) {\\n\\t\\t\\t\\tfor(int j = i; j < n; j++) {\\n\\t\\t\\t\\t\\tif(s.charAt(j - i) == s.charAt(j) ) {\\n\\t\\t\\t\\t\\t\\tif(dp[j - i + 1][j - 1] || i == 1)\\n\\t\\t\\t\\t\\t\\t\\tdp[j - i][j] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint[] count = new int[n];\\n\\n\\t\\t\\tfor(int i = k - 1; i < n; i++) {\\n\\t\\t\\t\\tfor(int j = i; j >= k - 1; j--) {\\n\\t\\t\\t\\t\\tif(dp[j - (k - 1)][i]) {\\n\\t\\t\\t\\t\\t\\tint prev = j - k >= 0 ? count[j - k] : 0;\\n\\t\\t\\t\\t\\t\\tcount[i] = Math.max(count[i], 1 + prev);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcount[i] = Math.max(count[i], i > 0 ? count[i - 1] : 0);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn Arrays.stream(count).max().getAsInt();\\n\\t\\t}\\n\\t}\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\t\\tpublic int maxPalindromes(String s, int k) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tboolean[][] dp = new boolean[n][n];\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t\\tdp[i][i] = true;\\n\\n\\t\\t\\tfor(int i = 1; i < n; i++) {\\n\\t\\t\\t\\tfor(int j = i; j < n; j++) {\\n\\t\\t\\t\\t\\tif(s.charAt(j - i) == s.charAt(j) ) {\\n\\t\\t\\t\\t\\t\\tif(dp[j - i + 1][j - 1] || i == 1)\\n\\t\\t\\t\\t\\t\\t\\tdp[j - i][j] = true;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2821123,
                "title": "c-easy-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size(), ans = 0;\\n        vector<int> dp(n + 1);\\n        for (int i = (k - 1) / 2; i <= n - (k / 2 + 1); i++) {\\n            dp[i + 1] = max(dp[i + 1], dp[i]);\\n\\t\\t\\t\\n\\t\\t\\t// odd length palindromes\\n            for (int l = i, r = i; l >= 0 && r < n; l--, r++) {\\n                if (s[l] == s[r]) {\\n                    if (r - l + 1 >= k) {\\n                        dp[r + 1] = max(dp[r + 1], dp[l] + 1);\\n                        ans = max(ans, dp[r + 1]);\\n\\t\\t\\t\\t\\t\\tbreak;\\n                    }\\n                }\\n                else break;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// even length palindromes\\n            for (int l = i, r = i + 1; l >= 0 && r < n; l--, r++) {\\n                if (s[l] == s[r]) {\\n                    if (r - l + 1 >= k) {\\n                        dp[r + 1] = max(dp[r + 1], dp[l] + 1);\\n                        ans = max(ans, dp[r + 1]);\\n\\t\\t\\t\\t\\t\\tbreak;\\n                    }\\n                }\\n                else break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nFeel free to ask if you have any doubts :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size(), ans = 0;\\n        vector<int> dp(n + 1);\\n        for (int i = (k - 1) / 2; i <= n - (k / 2 + 1); i++) {\\n            dp[i + 1] = max(dp[i + 1], dp[i]);\\n\\t\\t\\t\\n\\t\\t\\t// odd length palindromes\\n            for (int l = i, r = i; l >= 0 && r < n; l--, r++) {\\n                if (s[l] == s[r]) {\\n                    if (r - l + 1 >= k) {\\n                        dp[r + 1] = max(dp[r + 1], dp[l] + 1);\\n                        ans = max(ans, dp[r + 1]);\\n\\t\\t\\t\\t\\t\\tbreak;\\n                    }\\n                }\\n                else break;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// even length palindromes\\n            for (int l = i, r = i + 1; l >= 0 && r < n; l--, r++) {\\n                if (s[l] == s[r]) {\\n                    if (r - l + 1 >= k) {\\n                        dp[r + 1] = max(dp[r + 1], dp[l] + 1);\\n                        ans = max(ans, dp[r + 1]);\\n\\t\\t\\t\\t\\t\\tbreak;\\n                    }\\n                }\\n                else break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820775,
                "title": "c-manacher-s-algorithm-greedy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.length(),\\n            ans = 0;\\n        \\n        // Manacher\\'s Algorithm (O(n))\\n        n = (n << 1) | 1;\\n        int L[n];\\n        L[0] = 0;\\n        for(int i=1, C=0, R=0; i<n; ++i){\\n            L[i] = i < R ? min(L[(C<<1) - i], R - i)\\n                         : 0;\\n            while(\\n                i + L[i] < n &&\\n                i - L[i] > 0 &&\\n                (\\n                    !((i + L[i] + 1) & 1) ||\\n                    s[(i + L[i] + 1) >> 1] == s[(i - L[i] - 1) >> 1]\\n                )\\n            )\\n                L[i]++;\\n            \\n            if(i + L[i] > R){\\n                C = i;\\n                R = i + L[i];\\n            }\\n        }\\n        \\n        // Greedy\\n        for(int i=0, prevR=-1, R=n>>1; i<n; ++i){\\n            if(L[i] < k)\\n                continue;\\n            L[i] = k + ((L[i]&1) ^ (k&1));\\n            \\n            int left = (i - L[i]) >> 1,\\n                right = left + L[i] - 1;\\n            \\n            if(left <= prevR)\\n                continue;\\n            \\n            R = min(R, right);\\n            \\n            if(left > prevR){\\n                ++ans;\\n                prevR = R;\\n                R = n >> 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.length(),\\n            ans = 0;\\n        \\n        // Manacher\\'s Algorithm (O(n))\\n        n = (n << 1) | 1;\\n        int L[n];\\n        L[0] = 0;\\n        for(int i=1, C=0, R=0; i<n; ++i){\\n            L[i] = i < R ? min(L[(C<<1) - i], R - i)\\n                         : 0;\\n            while(\\n                i + L[i] < n &&\\n                i - L[i] > 0 &&\\n                (\\n                    !((i + L[i] + 1) & 1) ||\\n                    s[(i + L[i] + 1) >> 1] == s[(i - L[i] - 1) >> 1]\\n                )\\n            )\\n                L[i]++;\\n            \\n            if(i + L[i] > R){\\n                C = i;\\n                R = i + L[i];\\n            }\\n        }\\n        \\n        // Greedy\\n        for(int i=0, prevR=-1, R=n>>1; i<n; ++i){\\n            if(L[i] < k)\\n                continue;\\n            L[i] = k + ((L[i]&1) ^ (k&1));\\n            \\n            int left = (i - L[i]) >> 1,\\n                right = left + L[i] - 1;\\n            \\n            if(left <= prevR)\\n                continue;\\n            \\n            R = min(R, right);\\n            \\n            if(left > prevR){\\n                ++ans;\\n                prevR = R;\\n                R = n >> 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820286,
                "title": "fast-brute-force",
                "content": "# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res=0;\\n    int maxPalindromes(string s, int k) {\\n        for(int i=0; i<s.size(); ++i){\\n            checkPalindrome(i, i, k, s);       // Odd palindrome\\n            checkPalindrome(i, i+1, k, s);     // Even palindrome\\n        }\\n        return res;\\n    }\\n\\n    void checkPalindrome(int l, int r, int k, string &s){\\n        while(l>=0 && r<s.size() && (s[l]==s[r]) &&\\n            (s[l]>=\\'a\\') && (s[l]<=\\'z\\') &&\\n            (s[r]>=\\'a\\') && (s[r]<=\\'z\\')){\\n            if(r-l+1>=k){\\n                ++res;\\n                s[l]=\\'#\\';\\n                s[r]=\\'#\\';\\n                // for(auto x:s) cout << x;\\n                // cout <<endl;\\n                break;          // Stop to find larger palindrome.\\n            }\\n            --l, ++r;\\n        }\\n    }\\n};\\n\\n/*\\n# Idea\\n    Brute force, start search from center character\\n    - Even/Odd palindrome\\n    - Mark found palindrome edge with other character \"#\"\\n\\nReference:\\n    https://leetcode.com/problems/maximum-number-of-non-overlapping-palindrome-substrings/solutions/2808793/\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    int maxPalindromes(string s, int k) {\\n        for(int i=0; i<s.size(); ++i){\\n            checkPalindrome(i, i, k, s);       // Odd palindrome\\n            checkPalindrome(i, i+1, k, s);     // Even palindrome\\n        }\\n        return res;\\n    }\\n\\n    void checkPalindrome(int l, int r, int k, string &s){\\n        while(l>=0 && r<s.size() && (s[l]==s[r]) &&\\n            (s[l]>=\\'a\\') && (s[l]<=\\'z\\') &&\\n            (s[r]>=\\'a\\') && (s[r]<=\\'z\\')){\\n            if(r-l+1>=k){\\n                ++res;\\n                s[l]=\\'#\\';\\n                s[r]=\\'#\\';\\n                // for(auto x:s) cout << x;\\n                // cout <<endl;\\n                break;          // Stop to find larger palindrome.\\n            }\\n            --l, ++r;\\n        }\\n    }\\n};\\n\\n/*\\n# Idea\\n    Brute force, start search from center character\\n    - Even/Odd palindrome\\n    - Mark found palindrome edge with other character \"#\"\\n\\nReference:\\n    https://leetcode.com/problems/maximum-number-of-non-overlapping-palindrome-substrings/solutions/2808793/\\n\\n\\n*/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2819983,
                "title": "c-1d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    int cnt[2000];\\n    int maxPalindromes(string s, int k) {\\n        int n = s.length();\\n        int len = 0;\\n        int l, r;\\n        int ans = 0;\\n        \\n        for (int i=0; i<n; ++i) {            \\n            len = 1;       \\n            l = i, r = i;\\n            if (i > 0) cnt[i] = max(cnt[i], cnt[i-1]);\\n            while(l >= 0 && r < n) {\\n                if(s[l] != s[r]) break;                \\n                if(len >= k){\\n                    if(l != 0) {\\n                        cnt[r] = max(cnt[r], cnt[l-1] + 1);                        \\n                    }\\n                    else {\\n                        cnt[r] = max(cnt[r], 1);\\n                    }                    \\n                    break;\\n                }                \\n                --l;\\n                ++r;\\n                len += 2;\\n            }\\n                        \\n            len = 2;\\n            l = i, r = i+1;\\n            while(l >= 0 && r < n) {                \\n                if(s[l] != s[r]) break;\\n                if(len >= k){\\n                    if(l != 0) {\\n                        cnt[r] = max(cnt[r], cnt[l-1] + 1);                        \\n                    }\\n                    else {\\n                        cnt[r] = max(cnt[r], 1);\\n                    }                    \\n                    \\n                    break;\\n                }                \\n                --l;\\n                ++r;\\n                len += 2;\\n            }\\n        }        \\n        \\n        return cnt[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int cnt[2000];\\n    int maxPalindromes(string s, int k) {\\n        int n = s.length();\\n        int len = 0;\\n        int l, r;\\n        int ans = 0;\\n        \\n        for (int i=0; i<n; ++i) {            \\n            len = 1;       \\n            l = i, r = i;\\n            if (i > 0) cnt[i] = max(cnt[i], cnt[i-1]);\\n            while(l >= 0 && r < n) {\\n                if(s[l] != s[r]) break;                \\n                if(len >= k){\\n                    if(l != 0) {\\n                        cnt[r] = max(cnt[r], cnt[l-1] + 1);                        \\n                    }\\n                    else {\\n                        cnt[r] = max(cnt[r], 1);\\n                    }                    \\n                    break;\\n                }                \\n                --l;\\n                ++r;\\n                len += 2;\\n            }\\n                        \\n            len = 2;\\n            l = i, r = i+1;\\n            while(l >= 0 && r < n) {                \\n                if(s[l] != s[r]) break;\\n                if(len >= k){\\n                    if(l != 0) {\\n                        cnt[r] = max(cnt[r], cnt[l-1] + 1);                        \\n                    }\\n                    else {\\n                        cnt[r] = max(cnt[r], 1);\\n                    }                    \\n                    \\n                    break;\\n                }                \\n                --l;\\n                ++r;\\n                len += 2;\\n            }\\n        }        \\n        \\n        return cnt[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819876,
                "title": "c-dp-matrix-solution",
                "content": "**Approcach**\\n* create dp matrix of size n * n where store **1** in dp[i][j] if substring i to j is palindrome\\n* Now check for each i to j if they are palindrome with needed size if found so move i to j+1 so **overlapping problem get solved**\\n\\n**C++ code**\\n```\\nvoid makePalindromedp(string s, vector<vector<int>> &dp, int n){\\n        \\n        for(int g=0;g<n;g++){\\n            for(int i=0,j=g;i<n && j<n;i++,j++){\\n                if(g==0){\\n                    dp[i][j]=1;\\n                    continue;\\n                }\\n                if(g==1){\\n                    if(s[i]==s[j]){\\n                        dp[i][j]=1;\\n                    }\\n                    continue;\\n                }\\n                if(s[i]==s[j] && dp[i+1][j-1]==1){\\n                    dp[i][j]=1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int maxPalindromes(string s, int k) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        \\n        makePalindromedp(s,dp,n);\\n        \\n        int i=0,ans=0;\\n        \\n       for(int j=k-1;j<n;j++){\\n           for(int idx=i;idx<n;idx++){\\n               if(j-idx+1<k){\\n                   break;\\n               }\\n               if(dp[idx][j]==1 && j-idx+1>=k){\\n                   //cout<<idx<<\" \"<<j<<\" \"<<s.substr(idx,j-idx+1)<<endl;\\n                   ans++;\\n                   i=j+1;\\n                   break;\\n               }\\n           }\\n       }\\n        return ans;\\n    }\\n\\t//code by sachin\\n```\\n**Upvote if solution was helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nvoid makePalindromedp(string s, vector<vector<int>> &dp, int n){\\n        \\n        for(int g=0;g<n;g++){\\n            for(int i=0,j=g;i<n && j<n;i++,j++){\\n                if(g==0){\\n                    dp[i][j]=1;\\n                    continue;\\n                }\\n                if(g==1){\\n                    if(s[i]==s[j]){\\n                        dp[i][j]=1;\\n                    }\\n                    continue;\\n                }\\n                if(s[i]==s[j] && dp[i+1][j-1]==1){\\n                    dp[i][j]=1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int maxPalindromes(string s, int k) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        \\n        makePalindromedp(s,dp,n);\\n        \\n        int i=0,ans=0;\\n        \\n       for(int j=k-1;j<n;j++){\\n           for(int idx=i;idx<n;idx++){\\n               if(j-idx+1<k){\\n                   break;\\n               }\\n               if(dp[idx][j]==1 && j-idx+1>=k){\\n                   //cout<<idx<<\" \"<<j<<\" \"<<s.substr(idx,j-idx+1)<<endl;\\n                   ans++;\\n                   i=j+1;\\n                   break;\\n               }\\n           }\\n       }\\n        return ans;\\n    }\\n\\t//code by sachin\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2819678,
                "title": "2-solution-1-simple-non-dp-o-nk-and-other-dp-solution-c",
                "content": "```\\n/ Idea is check for max k or k+1 palindrome only as higher size i.e K+2 and beyond means k size for sure\\n// exists as k or k+1 will be subset of all palindrome beyond k+2.. so no point checking beyond k/k+1 , so just checking for k and k+1 palindrome for each location is good enough for us to see if we can get optimal palindrome from given position and move ahead.\\nclass Solution {\\npublic:\\n    public:\\n    bool isPalindrome(string &s, int left, int right) {\\n        while(left < right)\\n            if (s[left++] != s[right--])\\n                return false;\\n        return true;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        int result = 0;\\n        for (int i = 0; (i+k < n); i++) {\\n            // check for even size palindrome\\n            if (isPalindrome(s,i,i+k-1)) {\\n                result++;\\n                i = i+k-1;\\n            } else if (((i+k) < n) && isPalindrome(s,i,i+k)) {\\n                // check for odd size palindrome\\n                result++;\\n                i = i+k;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n    \\n};\\n\\nclass Solution2 {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        int result = 0;\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = 1;\\n            if (i+1 < n) {\\n                if (s[i] == s[i+1])\\n                    dp[i][i+1] = 1;\\n            }\\n        }\\n        \\n        // Create table for all possible palindromes from i to j\\n        for (int l = 3; l <= k+1; l++) {\\n            for (int i = 0; i < n-l+1; i++) {\\n                int j = i + l-1;\\n                if ((s[i] == s[j]) && (dp[i+1][j-1]))\\n                    dp[i][j] = 1;\\n            }\\n        }\\n        \\n       \\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n-k+1; j++) {\\n                // check for even palindrome\\n                if (dp[i][i+k-1]) {\\n                    result++;\\n                    i = i+k-1;\\n                    break;\\n                }\\n                // check for odd palindrome\\n                if (i+k < n && (dp[i][i+k])){ \\n                    result++;\\n                    i = i+k;\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/ Idea is check for max k or k+1 palindrome only as higher size i.e K+2 and beyond means k size for sure\\n// exists as k or k+1 will be subset of all palindrome beyond k+2.. so no point checking beyond k/k+1 , so just checking for k and k+1 palindrome for each location is good enough for us to see if we can get optimal palindrome from given position and move ahead.\\nclass Solution {\\npublic:\\n    public:\\n    bool isPalindrome(string &s, int left, int right) {\\n        while(left < right)\\n            if (s[left++] != s[right--])\\n                return false;\\n        return true;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        int result = 0;\\n        for (int i = 0; (i+k < n); i++) {\\n            // check for even size palindrome\\n            if (isPalindrome(s,i,i+k-1)) {\\n                result++;\\n                i = i+k-1;\\n            } else if (((i+k) < n) && isPalindrome(s,i,i+k)) {\\n                // check for odd size palindrome\\n                result++;\\n                i = i+k;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n    \\n};\\n\\nclass Solution2 {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        int result = 0;\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = 1;\\n            if (i+1 < n) {\\n                if (s[i] == s[i+1])\\n                    dp[i][i+1] = 1;\\n            }\\n        }\\n        \\n        // Create table for all possible palindromes from i to j\\n        for (int l = 3; l <= k+1; l++) {\\n            for (int i = 0; i < n-l+1; i++) {\\n                int j = i + l-1;\\n                if ((s[i] == s[j]) && (dp[i+1][j-1]))\\n                    dp[i][j] = 1;\\n            }\\n        }\\n        \\n       \\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n-k+1; j++) {\\n                // check for even palindrome\\n                if (dp[i][i+k-1]) {\\n                    result++;\\n                    i = i+k-1;\\n                    break;\\n                }\\n                // check for odd palindrome\\n                if (i+k < n && (dp[i][i+k])){ \\n                    result++;\\n                    i = i+k;\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818981,
                "title": "java-easy-2ms-no-dp",
                "content": "How about we consider chars from 0(i) to k length(j) on the input string and check if it is palindrom, if not just check if including next char(by incrementing j) on the input string makes it palindrom, and so on. If not increment the i and check if the palindrom charset is found, if not we do this until we have at least k chars, if yes, we just reset i to j+1;\\nAlso, let\\'s just handle cases like k=0 and k=length of input string.\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic int maxPalindromes(String s, int k) {\\n\\t\\t\\tint len=s.length();\\n\\t\\t\\tif(k == 1) return len; //If k is 1, each character is palindrom\\n\\t\\t\\tif(k == len) return palim(s, 0, len-1) ? 1:0; //If k is len, check if whole string palindrom\\n\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint lastPalimFoundAt=0;\\n\\t\\t\\twhile(lastPalimFoundAt<len){\\n\\t\\t\\t\\tint j=lastPalimFoundAt+k-1;\\n\\t\\t\\t\\tint prevPalimFoundAt = lastPalimFoundAt;\\n\\t\\t\\t\\twhile(j<len){\\n\\n\\t\\t\\t\\t\\t//palindrom check i to j by incrementing j\\n\\t\\t\\t\\t\\tif(palim(s, lastPalimFoundAt, j)){\\n\\t\\t\\t\\t\\t\\tlastPalimFoundAt=j;\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t//palindrom check i to j by decrementing i\\n\\t\\t\\t\\t\\tboolean found = false;\\n\\t\\t\\t\\t\\twhile(j-lastPalimFoundAt >= k){\\n\\t\\t\\t\\t\\t\\tlastPalimFoundAt++;\\n\\t\\t\\t\\t\\t\\tif(palim(s, lastPalimFoundAt, j)){\\n\\t\\t\\t\\t\\t\\t\\tlastPalimFoundAt=j;\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(found) break;\\n\\n\\t\\t\\t\\t\\tlastPalimFoundAt = prevPalimFoundAt;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlastPalimFoundAt++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\n\\t\\tpublic boolean palim(String s, int i, int j){ \\n\\t\\t\\twhile(i<j){\\n\\t\\t\\t\\tif(s.charAt(i++) != s.charAt(j--)) return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\t\\tpublic int maxPalindromes(String s, int k) {\\n\\t\\t\\tint len=s.length();\\n\\t\\t\\tif(k == 1) return len; //If k is 1, each character is palindrom\\n\\t\\t\\tif(k == len) return palim(s, 0, len-1) ? 1:0; //If k is len, check if whole string palindrom\\n\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint lastPalimFoundAt=0;\\n\\t\\t\\twhile(lastPalimFoundAt<len){\\n\\t\\t\\t\\tint j=lastPalimFoundAt+k-1;\\n\\t\\t\\t\\tint prevPalimFoundAt = lastPalimFoundAt;\\n\\t\\t\\t\\twhile(j<len){\\n\\n\\t\\t\\t\\t\\t//palindrom check i to j by incrementing j\\n\\t\\t\\t\\t\\tif(palim(s, lastPalimFoundAt, j)){\\n\\t\\t\\t\\t\\t\\tlastPalimFoundAt=j;\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2816814,
                "title": "java-dp-remove-overlapping-intervals",
                "content": "```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int len = s.length();\\n        //dp array which stores if substring(i,j) j inclusive is a phalindrome\\n        boolean[][] dp = new boolean[len][len];\\n        List<int[]> list = new ArrayList<>();\\n        // i decrements and j increments because : dp[i][j] = dp[i+1][j-1];\\n        for(int i=len-1;i>=0;i--){\\n            for(int j=i;j<len;j++){\\n                if(s.charAt(i)==s.charAt(j)){\\n                    if(j-i<=1)\\n                        dp[i][j] = true;\\n                    else{\\n                        dp[i][j] = dp[i+1][j-1];\\n                    }\\n                    if(dp[i][j] && j-i+1>=k)\\n                        list.add(new int[]{i,j});\\n                }\\n            }\\n        }\\n        int ans =0;\\n        \\n        Collections.sort(list, (a,b)-> a[1]-b[1]);\\n        int i=0, cnt=0;\\n        //we greedly select a substring which ends first and remove a substring if it overlaps with previous\\n        for(int j=1;j<list.size();j++){\\n            if(list.get(j)[0]<=list.get(i)[1])\\n                cnt++;\\n            else\\n                i=j;\\n        }\\n        return list.size()-cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int len = s.length();\\n        //dp array which stores if substring(i,j) j inclusive is a phalindrome\\n        boolean[][] dp = new boolean[len][len];\\n        List<int[]> list = new ArrayList<>();\\n        // i decrements and j increments because : dp[i][j] = dp[i+1][j-1];\\n        for(int i=len-1;i>=0;i--){\\n            for(int j=i;j<len;j++){\\n                if(s.charAt(i)==s.charAt(j)){\\n                    if(j-i<=1)\\n                        dp[i][j] = true;\\n                    else{\\n                        dp[i][j] = dp[i+1][j-1];\\n                    }\\n                    if(dp[i][j] && j-i+1>=k)\\n                        list.add(new int[]{i,j});\\n                }\\n            }\\n        }\\n        int ans =0;\\n        \\n        Collections.sort(list, (a,b)-> a[1]-b[1]);\\n        int i=0, cnt=0;\\n        //we greedly select a substring which ends first and remove a substring if it overlaps with previous\\n        for(int j=1;j<list.size();j++){\\n            if(list.get(j)[0]<=list.get(i)[1])\\n                cnt++;\\n            else\\n                i=j;\\n        }\\n        return list.size()-cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816769,
                "title": "o-n-n-beats-70",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n * n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPal(string &s){\\n        int n = s.length();\\n        for(int i = 0 ; i < n/2 ; i++){\\n            if(s[i] != s[n - i - 1])\\n                return false;\\n        }\\n        return true;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n = s.length();\\n        string st;\\n        int res = 0 ;\\n        for(int i = 0 ; i < n ; i++){\\n            st += s[i];\\n            if(st.length() >= k){\\n                string first ;\\n                for(int j = st.length()-k ; j < st.length() ; j++)\\n                    first += st[j];\\n                if(isPal(first)){\\n                    // cout<<res<<\" \"<<first<<endl;\\n                    res++;\\n                    st.clear();\\n                }\\n            }\\n            if(st.length() > k){\\n                string first ;\\n                for(int j = st.length()- k - 1 ; j < st.length() ; j++)first += st[j];\\n                if(isPal(first)){\\n                    // cout<<res<<\" \"<<first<<endl;\\n                    res++;\\n                    st.clear();\\n                }\\n                // cout<<1<<endl;\\n            }\\n            // cout<<st<<endl;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPal(string &s){\\n        int n = s.length();\\n        for(int i = 0 ; i < n/2 ; i++){\\n            if(s[i] != s[n - i - 1])\\n                return false;\\n        }\\n        return true;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n = s.length();\\n        string st;\\n        int res = 0 ;\\n        for(int i = 0 ; i < n ; i++){\\n            st += s[i];\\n            if(st.length() >= k){\\n                string first ;\\n                for(int j = st.length()-k ; j < st.length() ; j++)\\n                    first += st[j];\\n                if(isPal(first)){\\n                    // cout<<res<<\" \"<<first<<endl;\\n                    res++;\\n                    st.clear();\\n                }\\n            }\\n            if(st.length() > k){\\n                string first ;\\n                for(int j = st.length()- k - 1 ; j < st.length() ; j++)first += st[j];\\n                if(isPal(first)){\\n                    // cout<<res<<\" \"<<first<<endl;\\n                    res++;\\n                    st.clear();\\n                }\\n                // cout<<1<<endl;\\n            }\\n            // cout<<st<<endl;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2816429,
                "title": "python-two-dp-o-nk",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        n = len(s)\\n        if k == 1: return n\\n        ispalindromes, palidxs = [[True] * n for _ in range(n)], [[] for _ in range(n + 1)]\\n        for step in range(1, k + 2):\\n            for i in range(n - step):\\n                ispalindromes[i][i + step] = (ispalindromes[i + 1][i + step - 1] and s[i] == s[i + step])\\n                if step + 1 >= k and ispalindromes[i][i + step]: palidxs[i + step + 1].append(i)\\n        dp = [0] * (n + 1)\\n        for i in range(n + 1):\\n            if i > 0: dp[i] = max(dp[i], dp[i - 1])\\n            for j in palidxs[i]: dp[i] = max(dp[i], dp[j] + 1)\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        n = len(s)\\n        if k == 1: return n\\n        ispalindromes, palidxs = [[True] * n for _ in range(n)], [[] for _ in range(n + 1)]\\n        for step in range(1, k + 2):\\n            for i in range(n - step):\\n                ispalindromes[i][i + step] = (ispalindromes[i + 1][i + step - 1] and s[i] == s[i + step])\\n                if step + 1 >= k and ispalindromes[i][i + step]: palidxs[i + step + 1].append(i)\\n        dp = [0] * (n + 1)\\n        for i in range(n + 1):\\n            if i > 0: dp[i] = max(dp[i], dp[i - 1])\\n            for j in palidxs[i]: dp[i] = max(dp[i], dp[j] + 1)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816404,
                "title": "c-simple-greedy-approach-intuitive-approach-100-faster-runtime-80-less-memory",
                "content": "```cpp\\n\\nclass Solution {\\npublic:\\n    int ans = 0;//calculating answer\\n\\t\\n\\t//gets palindrome string which has len>=k and as minimal as possible\\n    int find_palin_center(int st,int c,string& str,int k){\\n        //odd len palindrome centered at \\'c\\'\\n        int p = c,q = c;\\n        while(p>=st && q<str.size() && q-p-1<k && str[p]==str[q]){\\n            p--,q++;\\n        }\\n\\t\\t\\n\\t\\t//if found minimal palindrome at center of given index then we can return new\\n\\t\\t//st index as q\\n        if(q-p-1 >= k){\\n            ans++;\\n            return q;\\n        }\\n        \\n        //even len palindrome centered at \\'c\\' and \\'c+1\\'\\n        p = c,q = c+1;\\n        while(p>=st && q<str.size() && q-p-1<k && str[p]==str[q]){\\n            p--,q++;\\n        }\\n        if(q-p-1 >= k){\\n            ans++;\\n            return q;\\n        }\\n        return st;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int st = 0;\\n        ans = 0;\\n        for(int i = 0; i < s.size();i++){\\n            if(st>i)continue;\\n            st = find_palin_center(st,i,s,k);            \\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n## Intuition behind greedy approach\\nNot a formal proof but the intuition is that taking shorter palindrome of atleast k size is always beneficial than taking longer palindrome of size>=k.\\n\\nVisualize palindromes as strings having center characters and expanding both from left and right where left pointer (of center) char == right pointer char :  <----\\'c\\'----> \\nabcdcba ==> here d is the center (c = c,b = b,a = a)\\ncbbc ==> here bb is the center (c = c)\\nKeep this in mind\\n\\nNow the problem, it is just based on fact that for making max number of palindrome substrings we have to use less characters and make palindrome which has center word as left as possible.\\nEg. aaababbb, k = 2\\n\\nTaking the starting \"aa\" is better than taking \"aaa\" because as third \\'a\\' is not used in former case we can use that third \\'a\\' for making \"aba\" i.e. second palindrome starting from index 2 and center character as \\'b\\' (0 based indexing)\\n\\nE.g. accaacba , k = 4\\n\"acca\" can be palindrome where center is \"cc\" and \"caac\" can be palindrome where \"aa\" is center. But choosing the former will not make ans worse if not improve it because we would have more characters remaining to make palindrome substrings.\\n\\nAlso the fact that if some substring is not making palindrome at length >= k then it will never make palindrome because for palindrome with start,end indices [s,e] := indices [s+1,e-1] has to be palindrome so if shorter words are not palindrome then we can easily stop expading around the center character.\\n\\nThis is like event scheduling where in for maximizing events we take events which end as early as possible i.e. as much as on the left(if you can visualize the timings as line intervals)\\n\\n## What am i doing in find_palin_center?\\nI am not good in giving names to functions so that weird name. Now in that i am trying to find palindrome substring from center **\\'i\\'** (for all i, 0 <= \\'i\\' < s.size()). If found the function returns new start index **st**. \\nThis is because we have to find non over lapping substring, we cannot take same character multiple times. \\nSo for every substring created we have to make sure that the index is not again taken.\\n\\nE.g. aaababbb, k = 2\\nHere st = 0 (initially)\\n==> Then we try the center as \\'a\\' but cannot expand. \\n==> Then we try the center \"aa\" (even len palindrome) and we found one with k length.\\n**Now we cannot take characters having indices <= 1 (end index of last palindrome substring)\\nHence now st = 2 because we can take characters only from 2nd index.**\\n==> Then we will try center as index 1 but as **st>i** we will continue\\n==> Then we will try to center index 2 (\\'a\\'),but cannot expand as prev[a] = a !== next[a] = b so will break\\n==> Then we wiil try to center index 2,3 (\"ab\") but cannot as a != b\\n==> Then we will try to center index 3. Prev[b] = a = next[b] and so we have found palindrome >= k and for making it of minimum length, we will not expand further and increment the ans.\\nAlso we will return new st = 5 as \"aba\" (index 2,3,4) is taken. \\nThis will continue...",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```cpp\\n\\nclass Solution {\\npublic:\\n    int ans = 0;//calculating answer\\n\\t\\n\\t//gets palindrome string which has len>=k and as minimal as possible\\n    int find_palin_center(int st,int c,string& str,int k){\\n        //odd len palindrome centered at \\'c\\'\\n        int p = c,q = c;\\n        while(p>=st && q<str.size() && q-p-1<k && str[p]==str[q]){\\n            p--,q++;\\n        }\\n\\t\\t\\n\\t\\t//if found minimal palindrome at center of given index then we can return new\\n\\t\\t//st index as q\\n        if(q-p-1 >= k){\\n            ans++;\\n            return q;\\n        }\\n        \\n        //even len palindrome centered at \\'c\\' and \\'c+1\\'\\n        p = c,q = c+1;\\n        while(p>=st && q<str.size() && q-p-1<k && str[p]==str[q]){\\n            p--,q++;\\n        }\\n        if(q-p-1 >= k){\\n            ans++;\\n            return q;\\n        }\\n        return st;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int st = 0;\\n        ans = 0;\\n        for(int i = 0; i < s.size();i++){\\n            if(st>i)continue;\\n            st = find_palin_center(st,i,s,k);            \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815116,
                "title": "javascript-o-k-n-array-without-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nif `[i, i+k-1]` is palindrome, then any larger range `[i-10, i+k+10]` is also palindrome, so checking the optimal `[i,i+k] or [i, i+k-1]` is enough for the optimal minimal split.\\n\\n# Complexity\\n- Time complexity: O(k*n) = O(k) check palindrome * O(n) array scan\\n\\n\\n\\n# Code\\n```\\nvar maxPalindromes = function(s, k) {\\n    let res = 0;\\n    const n = s.length;\\n    for(let i = 0; i<= n-k; i++) {\\n        if(isPalindrome(s, i, i+k-1))  {\\n            res++;\\n            i += k-1;\\n            continue;\\n        }\\n        if(isPalindrome(s, i, i+k)) {\\n            res++;\\n            i +=k;\\n            continue;\\n        }\\n    }\\n    return res;\\n    \\n};\\nfunction isPalindrome( s,  l,  r) {\\n    if(r >= s.length) {\\n        return false;\\n    }\\n    while (l < r) {\\n        if (s[l++] != s[r--])  {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```\\n\\nAlternative DP solution: (code is longer)\\n```\\nvar maxPalindromes = function(s, k) {\\n    const n = s.length;\\n    const dp = new Array(n+2).fill(0).map(el=>new Array(n+2).fill(false));\\n    for(let len =1; len<=Math.min(k+1,n); len++)\\n        for(let i=0, j= i+len-1; j<n;j++,i++) {\\n            if(len===1) {\\n                dp[i][j] = true;\\n            }\\n            else if(len===2 && s[i] ===s[j]) {\\n                dp[i][j] = true;\\n            }\\n            else {\\n                dp[i][j] = dp[i+1][j-1] && (s[i] === s[j]) ;\\n            }\\n        }\\n\\n    let res = 0;\\n    for(let i = 0; i + k <= n; i++) {\\n        if(dp[i][i+k-1] || dp[i][i+k]) {\\n            res++;\\n        }\\n        i += dp[i][i+k-1] ? k-1 : (dp[i][i+k] ? k : 0);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar maxPalindromes = function(s, k) {\\n    let res = 0;\\n    const n = s.length;\\n    for(let i = 0; i<= n-k; i++) {\\n        if(isPalindrome(s, i, i+k-1))  {\\n            res++;\\n            i += k-1;\\n            continue;\\n        }\\n        if(isPalindrome(s, i, i+k)) {\\n            res++;\\n            i +=k;\\n            continue;\\n        }\\n    }\\n    return res;\\n    \\n};\\nfunction isPalindrome( s,  l,  r) {\\n    if(r >= s.length) {\\n        return false;\\n    }\\n    while (l < r) {\\n        if (s[l++] != s[r--])  {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```\n```\\nvar maxPalindromes = function(s, k) {\\n    const n = s.length;\\n    const dp = new Array(n+2).fill(0).map(el=>new Array(n+2).fill(false));\\n    for(let len =1; len<=Math.min(k+1,n); len++)\\n        for(let i=0, j= i+len-1; j<n;j++,i++) {\\n            if(len===1) {\\n                dp[i][j] = true;\\n            }\\n            else if(len===2 && s[i] ===s[j]) {\\n                dp[i][j] = true;\\n            }\\n            else {\\n                dp[i][j] = dp[i+1][j-1] && (s[i] === s[j]) ;\\n            }\\n        }\\n\\n    let res = 0;\\n    for(let i = 0; i + k <= n; i++) {\\n        if(dp[i][i+k-1] || dp[i][i+k]) {\\n            res++;\\n        }\\n        i += dp[i][i+k-1] ? k-1 : (dp[i][i+k] ? k : 0);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2814368,
                "title": "python3-memoization",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        @cache\\n        def dp(ind):\\n            if ind >= n-k+1:\\n                return 0\\n            val = 0\\n            for i in range(k,k+2):\\n                if s[ind:ind+i] == s[ind:ind+i][::-1]:\\n                    val = max(val,1 + dp(ind+i))\\n                    break\\n            val = max(val,dp(ind+1))\\n            return val\\n        n = len(s)\\n        return dp(0)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        @cache\\n        def dp(ind):\\n            if ind >= n-k+1:\\n                return 0\\n            val = 0\\n            for i in range(k,k+2):\\n                if s[ind:ind+i] == s[ind:ind+i][::-1]:\\n                    val = max(val,1 + dp(ind+i))\\n                    break\\n            val = max(val,dp(ind+1))\\n            return val\\n        n = len(s)\\n        return dp(0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814167,
                "title": "java-recursive-dp-with-memoization",
                "content": "In this problem we only need to find palindrome with length k and k+1 (palindrome with even and odd length) to find max number of qualified substring.\\nWith memoization array dp[] we can simply bypass visited subroutine with stored value dp[i] which is max number of substring start with index i of main string.\\n```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int[] dp=new int[s.length()];//dp[i] is max number of qualified substring in s.substring(i)\\n        Arrays.fill(dp,-1);\\n        return dfs(s,dp,k,0);\\n    }\\n    public int dfs(String s,int[] dp, int k, int start){\\n        if(start>=s.length())return 0;\\n        if(dp[start]!=-1)return dp[start];\\n        int ans=0;\\n        for(int n=0;n<=1;n++){\\n            for(int i=start;i<=s.length()-k-n;i++){\\n                int left=i,right=i+k+n-1;\\n                while(left<right){\\n                    if(s.charAt(left)!=s.charAt(right))break;\\n                    left++;\\n                    right--;\\n                }\\n                if(left>=right){\\n                    ans=Math.max(ans,1+dfs(s,dp,k,i+k+n));\\n                    break;\\n                }\\n            }\\n        }\\n        dp[start]=ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int[] dp=new int[s.length()];//dp[i] is max number of qualified substring in s.substring(i)\\n        Arrays.fill(dp,-1);\\n        return dfs(s,dp,k,0);\\n    }\\n    public int dfs(String s,int[] dp, int k, int start){\\n        if(start>=s.length())return 0;\\n        if(dp[start]!=-1)return dp[start];\\n        int ans=0;\\n        for(int n=0;n<=1;n++){\\n            for(int i=start;i<=s.length()-k-n;i++){\\n                int left=i,right=i+k+n-1;\\n                while(left<right){\\n                    if(s.charAt(left)!=s.charAt(right))break;\\n                    left++;\\n                    right--;\\n                }\\n                if(left>=right){\\n                    ans=Math.max(ans,1+dfs(s,dp,k,i+k+n));\\n                    break;\\n                }\\n            }\\n        }\\n        dp[start]=ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814151,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    bool isPal( string str )\\n{\\n        int i= 0 , j = str.length()-1; \\n    while(i<j)\\n    {\\n        if(str[i]!=str[j])\\n            return false ;\\n        i++ ; \\n        j-- ; \\n    }\\n    return true ; \\n}\\n    \\n    int maxPalindromes(string s, int k) {\\n        int n = s.length() ;\\n       int ans= 0 ; \\n        int maxi = 0; \\n        int i =0 , j=0 , t ; \\n        string str ;\\n        while(i<=n-k)\\n        {\\n            j = i ;\\n            t = i+1;\\n             str= \"\" ;\\n            while(j<n)\\n            {\\n                str+=s[j] ;\\n                if(str.length()>=k && isPal(str))\\n                {\\n                    ans++; \\n                    t = j+1 ;\\n                    str= \"\" ;\\n                }\\n                if(str.length()>k)\\n                    break ;\\n                j++; \\n            }\\n            i=t ;\\n        }\\n       return ans  ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    bool isPal( string str )\\n{\\n        int i= 0 , j = str.length()-1; \\n    while(i<j)\\n    {\\n        if(str[i]!=str[j])\\n            return false ;\\n        i++ ; \\n        j-- ; \\n    }\\n    return true ; \\n}\\n    \\n    int maxPalindromes(string s, int k) {\\n        int n = s.length() ;\\n       int ans= 0 ; \\n        int maxi = 0; \\n        int i =0 , j=0 , t ; \\n        string str ;\\n        while(i<=n-k)\\n        {\\n            j = i ;\\n            t = i+1;\\n             str= \"\" ;\\n            while(j<n)\\n            {\\n                str+=s[j] ;\\n                if(str.length()>=k && isPal(str))\\n                {\\n                    ans++; \\n                    t = j+1 ;\\n                    str= \"\" ;\\n                }\\n                if(str.length()>k)\\n                    break ;\\n                j++; \\n            }\\n            i=t ;\\n        }\\n       return ans  ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814073,
                "title": "python-two-pointer-greedy",
                "content": "the two pointer part is very similar to https://leetcode.com/problems/longest-palindromic-substring/\\n\\nTC: O(NK) + O(NlogN)\\nSC: O(N)\\n\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        if k ==1:\\n            return len(s)\\n        self.resIdx = []\\n        \\n        def findShortestPaliLenOverK(L, R):\\n            shift = 0\\n            while L-shift >= 0 and R+shift < len(s) and s[L-shift] == s[R+shift]:\\n                if R-L+1+2*shift >=k:\\n                    self.ans = s[L-shift:R+shift+1]\\n                    self.resIdx.append([L-shift, R+shift+1])\\n                    return True\\n                else:\\n                    shift+=1\\n            return False\\n        \\n        for idx in range(len(s)-1):\\n            findShortestPaliLenOverK(idx, idx)\\n            findShortestPaliLenOverK(idx, idx+1)\\n                \\n        \\n        self.resIdx.sort()\\n        # print(self.resIdx)\\n        curEnd = -1\\n        res = 0\\n        for s,e in self.resIdx:\\n            if s>=curEnd:\\n                curEnd=e\\n                res+=1\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        if k ==1:\\n            return len(s)\\n        self.resIdx = []\\n        \\n        def findShortestPaliLenOverK(L, R):\\n            shift = 0\\n            while L-shift >= 0 and R+shift < len(s) and s[L-shift] == s[R+shift]:\\n                if R-L+1+2*shift >=k:\\n                    self.ans = s[L-shift:R+shift+1]\\n                    self.resIdx.append([L-shift, R+shift+1])\\n                    return True\\n                else:\\n                    shift+=1\\n            return False\\n        \\n        for idx in range(len(s)-1):\\n            findShortestPaliLenOverK(idx, idx)\\n            findShortestPaliLenOverK(idx, idx+1)\\n                \\n        \\n        self.resIdx.sort()\\n        # print(self.resIdx)\\n        curEnd = -1\\n        res = 0\\n        for s,e in self.resIdx:\\n            if s>=curEnd:\\n                curEnd=e\\n                res+=1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813720,
                "title": "c-solution-lps",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        if (k == 1) {\\n            return n;\\n        }\\n        vector<vector<bool>> dp(n, vector<bool> (n));\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = true;\\n        }\\n        vector<int> minLen(n, INF);\\n        for (int L = n - 1; L >= 0; L--) {\\n            for (int R = L + 1; R < n; R++) {\\n                if (s[L] == s[R]) {\\n                    if (L + 1 == R) {\\n                        if (R - L + 1 >= k) {\\n                            minLen[L] = min(minLen[L], R - L + 1);\\n                        }\\n                        dp[L][R] = true;\\n                    } else if (dp[L + 1][R - 1]) {\\n                        if (R - L + 1 >= k) {\\n                            minLen[L] = min(minLen[L], R - L + 1);\\n                        }\\n                        dp[L][R] = true;\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> dp1(n + 1);\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (minLen[i] != INF) {\\n                dp1[i] = max(dp1[i], dp1[i + minLen[i]] + 1);\\n            }\\n            dp1[i] = max(dp1[i], dp1[i + 1]);\\n        }\\n        return dp1[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        if (k == 1) {\\n            return n;\\n        }\\n        vector<vector<bool>> dp(n, vector<bool> (n));\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = true;\\n        }\\n        vector<int> minLen(n, INF);\\n        for (int L = n - 1; L >= 0; L--) {\\n            for (int R = L + 1; R < n; R++) {\\n                if (s[L] == s[R]) {\\n                    if (L + 1 == R) {\\n                        if (R - L + 1 >= k) {\\n                            minLen[L] = min(minLen[L], R - L + 1);\\n                        }\\n                        dp[L][R] = true;\\n                    } else if (dp[L + 1][R - 1]) {\\n                        if (R - L + 1 >= k) {\\n                            minLen[L] = min(minLen[L], R - L + 1);\\n                        }\\n                        dp[L][R] = true;\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> dp1(n + 1);\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (minLen[i] != INF) {\\n                dp1[i] = max(dp1[i], dp1[i + minLen[i]] + 1);\\n            }\\n            dp1[i] = max(dp1[i], dp1[i + 1]);\\n        }\\n        return dp1[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813563,
                "title": "c-easy-using-concept-of-longest-palindromic-substring",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(string s) {\\n        int n=s.size();\\n        string res=\"\";\\n        int leni=1,lenj=1,i,j;\\n        int dp[n+1][n+1];\\n        for(i=0;i<n+1;i++)\\n        {\\n            dp[0][i]=1;\\n            dp[1][i]=1;\\n        }\\n        for(i=2;i<=n;i++)\\n        {\\n            for(j=i;j<=n;j++)\\n            {\\n                if(s[j-1]==s[j-i]&&dp[i-2][j-1]==1)\\n                    dp[i][j]=1,leni=i,lenj=j;\\n                else\\n                    dp[i][j]=0;\\n            }\\n        }\\n        for(i=lenj-leni;i<lenj;i++)\\n            res.push_back(s[i]);\\n        \\n        return res.size();\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int ans = 0;\\n        string str = \"\";\\n        int n = s.size();\\n        for(int i = 0; i< n ; i++)\\n        {\\n            str.push_back(s[i]);\\n            if(str.size() >=k)\\n            {\\n                if(longestPalindrome(str) >=k)\\n                {\\n                    ans++;\\n                    str= \"\";\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(string s) {\\n        int n=s.size();\\n        string res=\"\";\\n        int leni=1,lenj=1,i,j;\\n        int dp[n+1][n+1];\\n        for(i=0;i<n+1;i++)\\n        {\\n            dp[0][i]=1;\\n            dp[1][i]=1;\\n        }\\n        for(i=2;i<=n;i++)\\n        {\\n            for(j=i;j<=n;j++)\\n            {\\n                if(s[j-1]==s[j-i]&&dp[i-2][j-1]==1)\\n                    dp[i][j]=1,leni=i,lenj=j;\\n                else\\n                    dp[i][j]=0;\\n            }\\n        }\\n        for(i=lenj-leni;i<lenj;i++)\\n            res.push_back(s[i]);\\n        \\n        return res.size();\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int ans = 0;\\n        string str = \"\";\\n        int n = s.size();\\n        for(int i = 0; i< n ; i++)\\n        {\\n            str.push_back(s[i]);\\n            if(str.size() >=k)\\n            {\\n                if(longestPalindrome(str) >=k)\\n                {\\n                    ans++;\\n                    str= \"\";\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813269,
                "title": "c-simple-solution-self-explained",
                "content": "```\\nclass Solution {\\n    unordered_map<int,int> cache;\\npublic:\\n    bool isPalindrome(string &s, int start, int end){\\n        while(start <= end){\\n            if(s[start] != s[end]){\\n                return false;\\n            }\\n            ++start, --end;\\n        }\\n        return true;\\n    }\\n    int solve(string s, int start, int k){\\n        if(start >= s.length()){\\n            return 0;\\n        }\\n        if(cache.find(start) != cache.end()){\\n            return cache[start];\\n        }\\n        int ans1 = solve(s, start+1, k);\\n        int ans2 = 0;\\n        for(int end = start+k-1; end < s.length(); end++){\\n            if(isPalindrome(s, start, end)){\\n                ++ans2;\\n                ans2 += solve(s,end+1, k);\\n                break;\\n            }\\n        }\\n        \\n        return cache[start] = max(ans1, ans2);\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n = s.length();\\n        int ans = 0;\\n        ans = solve(s, 0, k);\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int,int> cache;\\npublic:\\n    bool isPalindrome(string &s, int start, int end){\\n        while(start <= end){\\n            if(s[start] != s[end]){\\n                return false;\\n            }\\n            ++start, --end;\\n        }\\n        return true;\\n    }\\n    int solve(string s, int start, int k){\\n        if(start >= s.length()){\\n            return 0;\\n        }\\n        if(cache.find(start) != cache.end()){\\n            return cache[start];\\n        }\\n        int ans1 = solve(s, start+1, k);\\n        int ans2 = 0;\\n        for(int end = start+k-1; end < s.length(); end++){\\n            if(isPalindrome(s, start, end)){\\n                ++ans2;\\n                ans2 += solve(s,end+1, k);\\n                break;\\n            }\\n        }\\n        \\n        return cache[start] = max(ans1, ans2);\\n    }\\n    int maxPalindromes(string s, int k) {\\n        int n = s.length();\\n        int ans = 0;\\n        ans = solve(s, 0, k);\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813129,
                "title": "recursive-with-memorization",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        if (n < k) {\\n            return 0;\\n        }\\n        \\n        vector<vector<bool>> isPalindrome(n, vector<bool>(n, false));\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                isPalindrome[i][j] = (s[i] == s[j]) && (j - i <= 1 || isPalindrome[i + 1][j - 1]);\\n            }\\n        }\\n        \\n\\n        vector<int> memo(n, -1);\\n        function<int(int)> dfs = [&](int start) {\\n            if (start > n - k) {\\n                return 0;\\n            }\\n\\n            if (memo[start] == -1) {\\n                // skip start, to check next.\\n                int total = dfs(start + 1);\\n                \\n                // or, with start, check [start ... start + k - 1]\\n                for (int end = start + k - 1; end <= n - 1; end++) {\\n                    // s[start...end]\\n                    // find the shortest palindrome, we explore further.\\n                    total = max(total, (isPalindrome[start][end] ? 1 : 0) + dfs(end + 1));\\n                }\\n                memo[start] = total;\\n            }\\n\\n            return memo[start];\\n        };\\n        \\n        return dfs(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        int n = s.size();\\n        if (n < k) {\\n            return 0;\\n        }\\n        \\n        vector<vector<bool>> isPalindrome(n, vector<bool>(n, false));\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                isPalindrome[i][j] = (s[i] == s[j]) && (j - i <= 1 || isPalindrome[i + 1][j - 1]);\\n            }\\n        }\\n        \\n\\n        vector<int> memo(n, -1);\\n        function<int(int)> dfs = [&](int start) {\\n            if (start > n - k) {\\n                return 0;\\n            }\\n\\n            if (memo[start] == -1) {\\n                // skip start, to check next.\\n                int total = dfs(start + 1);\\n                \\n                // or, with start, check [start ... start + k - 1]\\n                for (int end = start + k - 1; end <= n - 1; end++) {\\n                    // s[start...end]\\n                    // find the shortest palindrome, we explore further.\\n                    total = max(total, (isPalindrome[start][end] ? 1 : 0) + dfs(end + 1));\\n                }\\n                memo[start] = total;\\n            }\\n\\n            return memo[start];\\n        };\\n        \\n        return dfs(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813030,
                "title": "c-dp-solution",
                "content": "\"The length of each substring is at least k\", \\nso it means the length of substring should be k or k + 1, \\nBecause if it has k + 2 length and it\\'s a palindrome, you can delete one letter on both sides that can make substirng shorter, shorter substring means more item in the string,\\nin other words, shorter substring is an optimal selection.\\n\\nAnd now, you can easyly solve this by using dp,\\ndp[i] means maximum number of non-overlapping palindrome substrings of s[0..i],\\ndp[dp.Length - 1] is the answer.\\n\\nForgive my poor English description...\\n# Code\\n```c#\\npublic class Solution {\\n    public int MaxPalindromes(string s, int k) {\\n        int[] dp = new int[s.Length];\\n        dp[k-1] = IsPal(0, k - 1, s);\\n        if(k < s.Length){\\n            dp[k] = Math.Max(Math.Max(dp[0] + IsPal(1, k, s), IsPal(0, k, s)), dp[k - 1]);\\n        }\\n        for(int i = k + 1; i < dp.Length; i++){\\n            dp[i] = Math.Max(Math.Max(dp[i - k] + IsPal(i - k + 1, i, s), dp[i - k - 1] + IsPal(i - k, i, s)), dp[i - 1]);\\n        }\\n        return dp[^1];\\n    }\\n\\n    public int IsPal(int left, int right, string s){\\n        while(left < right){\\n            if(s[left] != s[right]){\\n                return 0;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```c#\\npublic class Solution {\\n    public int MaxPalindromes(string s, int k) {\\n        int[] dp = new int[s.Length];\\n        dp[k-1] = IsPal(0, k - 1, s);\\n        if(k < s.Length){\\n            dp[k] = Math.Max(Math.Max(dp[0] + IsPal(1, k, s), IsPal(0, k, s)), dp[k - 1]);\\n        }\\n        for(int i = k + 1; i < dp.Length; i++){\\n            dp[i] = Math.Max(Math.Max(dp[i - k] + IsPal(i - k + 1, i, s), dp[i - k - 1] + IsPal(i - k, i, s)), dp[i - 1]);\\n        }\\n        return dp[^1];\\n    }\\n\\n    public int IsPal(int left, int right, string s){\\n        while(left < right){\\n            if(s[left] != s[right]){\\n                return 0;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812775,
                "title": "java-easy-to-understand-with-explanation",
                "content": "Intution:\\n1. This problem is combination of 2 sub-problems. (a) https://leetcode.com/problems/palindromic-substrings/\\n(b)https://leetcode.com/problems/non-overlapping-intervals/\\n\\nApproach:\\n1.For finding pallindromic substring, we will use dp(gap strategy).\\n2.we will collect all the pallindromic substring, whose length>=k, as a Pair(i,j)\\n3.Now, we will use maximum non-overlapping strategy to find non-overlapping intervals, in this first we will sort all the Pairs(i,j), with respect to ending of intervals, now we will count the non-overlapping substring.\\n\\n\\n```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int len=s.length();\\n        boolean dp[][]=new boolean[len][len];\\n        List<Pair>list=new ArrayList<>();\\n        for(int gap=0;gap<len;gap++){\\n            for(int i=0,j=gap;j<len;i++,j++){\\n                if(gap==0){\\n                    dp[i][j]=true;\\n                }else if(gap==1 && s.charAt(i)==s.charAt(j)){\\n                    dp[i][j]=true;\\n                }else if(gap>1){\\n                    if(s.charAt(i)==s.charAt(j) && dp[i+1][j-1]==true){\\n                        dp[i][j]=true;\\n                    }\\n                }\\n\\t\\t\\t\\t// adding all the pairs, which is pallindrom and length is >=k\\n                if(dp[i][j]==true && (gap+1)>=k){\\n                    list.add(new Pair(i,j));\\n                }\\n            }\\n        }\\n        if(list.size()==0 || list.size()==1){\\n            return list.size();\\n        }\\n        return countNonOverlapping(list);\\n    }\\n    public int countNonOverlapping(List<Pair>list){\\n        int count=1;\\n\\t\\t// sort all the intervals.\\n        Collections.sort(list,new Comparator<Pair>(){\\n            public int compare(Pair p1,Pair p2){\\n                return p1.end-p2.end;\\n            }\\n        });\\n\\t\\t// count all the non-overlapping intervals\\n        int end=list.get(0).end;\\n        for(int i=1;i<list.size();i++){\\n            Pair p=list.get(i);\\n            if(p.str>end){\\n                count++;\\n                end=p.end;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nclass Pair{\\n    int str;\\n    int end;\\n    Pair(int str,int end){\\n        this.str=str;\\n        this.end=end;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int len=s.length();\\n        boolean dp[][]=new boolean[len][len];\\n        List<Pair>list=new ArrayList<>();\\n        for(int gap=0;gap<len;gap++){\\n            for(int i=0,j=gap;j<len;i++,j++){\\n                if(gap==0){\\n                    dp[i][j]=true;\\n                }else if(gap==1 && s.charAt(i)==s.charAt(j)){\\n                    dp[i][j]=true;\\n                }else if(gap>1){\\n                    if(s.charAt(i)==s.charAt(j) && dp[i+1][j-1]==true){\\n                        dp[i][j]=true;\\n                    }\\n                }\\n\\t\\t\\t\\t// adding all the pairs, which is pallindrom and length is >=k\\n                if(dp[i][j]==true && (gap+1)>=k){\\n                    list.add(new Pair(i,j));\\n                }\\n            }\\n        }\\n        if(list.size()==0 || list.size()==1){\\n            return list.size();\\n        }\\n        return countNonOverlapping(list);\\n    }\\n    public int countNonOverlapping(List<Pair>list){\\n        int count=1;\\n\\t\\t// sort all the intervals.\\n        Collections.sort(list,new Comparator<Pair>(){\\n            public int compare(Pair p1,Pair p2){\\n                return p1.end-p2.end;\\n            }\\n        });\\n\\t\\t// count all the non-overlapping intervals\\n        int end=list.get(0).end;\\n        for(int i=1;i<list.size();i++){\\n            Pair p=list.get(i);\\n            if(p.str>end){\\n                count++;\\n                end=p.end;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nclass Pair{\\n    int str;\\n    int end;\\n    Pair(int str,int end){\\n        this.str=str;\\n        this.end=end;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812636,
                "title": "c-greedy",
                "content": "# Intuition\\n1. Start from k-1 , to look back to see if there is a valid palindrome ends at this position.\\nIf there is no valid palindrome, move current position forward 1.\\n2. If there is one valid palindrome,then increase count 1, and then move current position forward, restart from current position + k , then repeat  1. \\n3. Because there is no overlapping, when look back , not pass found valid positions any more\\n\\n# Approach\\nGreedy\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxPalindromes(string s, int k) {\\n        Dictionary<char,List<int>> D = new();\\n        int start = 0;\\n        int res = 0;\\n        int end = k-1;\\n        while(end<s.Length)\\n        {\\n            if(FindP(start, end, s,k))\\n            {\\n                start = end+1;\\n                end = start + k - 1;\\n                res++;\\n            }\\n            else\\n                end++;\\n                \\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    public bool FindP(int start, int end, string s, int k)\\n    {\\n        for(int i=end-k+1;i>=start;i--)\\n        {\\n            if(IsP(i, end, s)) return true;\\n        }\\n        return false;\\n    }\\n    public bool IsP(int start, int end, string s)\\n    {\\n        while(start<end){\\n            if(s[start++]!=s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxPalindromes(string s, int k) {\\n        Dictionary<char,List<int>> D = new();\\n        int start = 0;\\n        int res = 0;\\n        int end = k-1;\\n        while(end<s.Length)\\n        {\\n            if(FindP(start, end, s,k))\\n            {\\n                start = end+1;\\n                end = start + k - 1;\\n                res++;\\n            }\\n            else\\n                end++;\\n                \\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    public bool FindP(int start, int end, string s, int k)\\n    {\\n        for(int i=end-k+1;i>=start;i--)\\n        {\\n            if(IsP(i, end, s)) return true;\\n        }\\n        return false;\\n    }\\n    public bool IsP(int start, int end, string s)\\n    {\\n        while(start<end){\\n            if(s[start++]!=s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812622,
                "title": "dp-and-greedy",
                "content": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        \\n        def find_palindrome_odd(index):    \\n            \\n            l = r = index\\n            while s[l] == s[r] and r - l + 1 < k:\\n                l -= 1\\n                r += 1\\n                if l < 0 or r >= m or s[l] != s[r]:\\n                    return [-1, -1]\\n                \\n            return [l, r]\\n        \\n        def find_palindrome_even(index):    \\n            \\n            if index == m - 1:\\n                return [-1, -1]\\n            \\n            l = index\\n            r = index + 1\\n            \\n            if s[l] != s[r]:\\n                return [-1, -1]\\n            \\n            while s[l] == s[r] and r - l + 1 < k:\\n                l -= 1\\n                r += 1\\n                if l < 0 or r >= m or s[l] != s[r]:\\n                    return [-1, -1]\\n            \\n            return [l, r]\\n                \\n             \\n        m = len(s)\\n        dp = [0] * m\\n        \\n        for i in range(m):\\n            \\n            #find the smallest palindrome\\n            l = r = -1\\n            l1, r1 = find_palindrome_odd(i)\\n            if l1 != -1:\\n                l, r = l1, r1\\n            l2, r2 = find_palindrome_even(i)\\n            if l2 != -1 and (r2 <= r1 or l == -1):\\n                l, r = l2, r2\\n            \\n            \\n            if l == -1:\\n                if i:\\n                    dp[i] = max(dp[i], dp[i - 1])\\n                continue\\n            \\n            if not l:\\n                if i:\\n                    dp[i] = max(dp[i], dp[i - 1])\\n                dp[r] = max(dp[r], 1)\\n            else:\\n                if i:\\n                    dp[i] = max(dp[i], dp[i - 1])\\n                dp[r] = max(dp[r], dp[l - 1] + 1)\\n\\n        return dp[m - 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        \\n        def find_palindrome_odd(index):    \\n            \\n            l = r = index\\n            while s[l] == s[r] and r - l + 1 < k:\\n                l -= 1\\n                r += 1\\n                if l < 0 or r >= m or s[l] != s[r]:\\n                    return [-1, -1]\\n                \\n            return [l, r]\\n        \\n        def find_palindrome_even(index):    \\n            \\n            if index == m - 1:\\n                return [-1, -1]\\n            \\n            l = index\\n            r = index + 1\\n            \\n            if s[l] != s[r]:\\n                return [-1, -1]\\n            \\n            while s[l] == s[r] and r - l + 1 < k:\\n                l -= 1\\n                r += 1\\n                if l < 0 or r >= m or s[l] != s[r]:\\n                    return [-1, -1]\\n            \\n            return [l, r]\\n                \\n             \\n        m = len(s)\\n        dp = [0] * m\\n        \\n        for i in range(m):\\n            \\n            #find the smallest palindrome\\n            l = r = -1\\n            l1, r1 = find_palindrome_odd(i)\\n            if l1 != -1:\\n                l, r = l1, r1\\n            l2, r2 = find_palindrome_even(i)\\n            if l2 != -1 and (r2 <= r1 or l == -1):\\n                l, r = l2, r2\\n            \\n            \\n            if l == -1:\\n                if i:\\n                    dp[i] = max(dp[i], dp[i - 1])\\n                continue\\n            \\n            if not l:\\n                if i:\\n                    dp[i] = max(dp[i], dp[i - 1])\\n                dp[r] = max(dp[r], 1)\\n            else:\\n                if i:\\n                    dp[i] = max(dp[i], dp[i - 1])\\n                dp[r] = max(dp[r], dp[l - 1] + 1)\\n\\n        return dp[m - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812578,
                "title": "no-bp-no-dfs-just-go-through-one-single-time",
                "content": "first of all make a quick judgement. If k is 1, the return the length of the string. ( provement ignored)\\nIf k equals the length of the string, just check if it is a palindrome.\\n\\nIt will be able to proved that any palindrome longer than k+1 make no different than its substring.\\n\\nso only k and k+1 length of palindrome will be checked. \\n\\nif there are two possition a, b got same maximum number, the larger one could be just simplely ignored.\\n\\n\\nfull code\\n```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        if k == 1:\\n            return len(s)\\n        if k == len(s):\\n            return 1 if s[:k//2] == s[-1:-1-k//2:-1] else 0\\n        # well, I got TLE. \\n        a = (0,0)\\n        if s[:k//2] == s[k-1:k-1-k//2:-1]:\\n            a = min(a, (-1, k))\\n        for i, c in enumerate(s[k:], k):\\n            if i - a[1] >= k - 1:\\n                if s[i-k+1:i-k+1+k//2] == s[i:i-k//2:-1]:\\n                    a = min(a, (a[0] - 1, i + 1))\\n                elif i - a[1] >= k:\\n                    if s[i- k:i- k+(k+1)//2] == s[i:i-(k+1)//2:-1]:\\n                        a = min(a, (a[0] - 1, i + 1))\\n        return -a[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        if k == 1:\\n            return len(s)\\n        if k == len(s):\\n            return 1 if s[:k//2] == s[-1:-1-k//2:-1] else 0\\n        # well, I got TLE. \\n        a = (0,0)\\n        if s[:k//2] == s[k-1:k-1-k//2:-1]:\\n            a = min(a, (-1, k))\\n        for i, c in enumerate(s[k:], k):\\n            if i - a[1] >= k - 1:\\n                if s[i-k+1:i-k+1+k//2] == s[i:i-k//2:-1]:\\n                    a = min(a, (a[0] - 1, i + 1))\\n                elif i - a[1] >= k:\\n                    if s[i- k:i- k+(k+1)//2] == s[i:i-(k+1)//2:-1]:\\n                        a = min(a, (a[0] - 1, i + 1))\\n        return -a[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812429,
                "title": "c-simple-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string str, int k) {\\n         const int n = str.size();\\n  \\n    bool table[n][n]; // table indicating whether str[i..j] is a palindrome\\n  \\n    memset(table, 0, sizeof(table));\\n  \\n  \\n    for (int i = 0; i < n; i++) // any single character string is a palindrome\\n        table[i][i] = true;\\n  \\n    // check for sub-string of length 2.\\n    for (int i = 0; i < n - 1; ++i) {\\n        if (str[i] == str[i + 1]) {\\n            table[i][i + 1] = true;\\n        }\\n    }\\n  \\n    // Check for lengths greater than 2.\\n    // k is length of substring\\n    for (int k = 3; k <= n; ++k) {\\n        // Fix the starting index\\n        for (int i = 0; i < n - k + 1; ++i) {\\n            // Get the ending index of substring from\\n            // starting index i and length k\\n            int j = i + k - 1;\\n  \\n            // checking for sub-string from ith index to\\n            // jth index iff str[i+1] to str[j-1] is a\\n            // palindrome\\n            if (table[i + 1][j - 1] && str[i] == str[j]) {\\n                table[i][j] = true;\\n            }\\n        }\\n    }\\n        \\n    vector<int> dp(n+1); // answer for the string consisting of characters 1..i (1-based) \\n    for (int i = 1; i <= n;  i++) { // for each character\\n        dp[i] = dp[i-1]; // it is at least the previous answer\\n        for (int j = i - k + 1; j >= 1; j--) {\\n            if (table[j-1][i-1]) { // we have a palindrome of size at least k ending at position i\\n                dp[i] = max(dp[i], 1 + dp[j - 1]); \\n            }\\n        }\\n    }\\n    \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string str, int k) {\\n         const int n = str.size();\\n  \\n    bool table[n][n]; // table indicating whether str[i..j] is a palindrome\\n  \\n    memset(table, 0, sizeof(table));\\n  \\n  \\n    for (int i = 0; i < n; i++) // any single character string is a palindrome\\n        table[i][i] = true;\\n  \\n    // check for sub-string of length 2.\\n    for (int i = 0; i < n - 1; ++i) {\\n        if (str[i] == str[i + 1]) {\\n            table[i][i + 1] = true;\\n        }\\n    }\\n  \\n    // Check for lengths greater than 2.\\n    // k is length of substring\\n    for (int k = 3; k <= n; ++k) {\\n        // Fix the starting index\\n        for (int i = 0; i < n - k + 1; ++i) {\\n            // Get the ending index of substring from\\n            // starting index i and length k\\n            int j = i + k - 1;\\n  \\n            // checking for sub-string from ith index to\\n            // jth index iff str[i+1] to str[j-1] is a\\n            // palindrome\\n            if (table[i + 1][j - 1] && str[i] == str[j]) {\\n                table[i][j] = true;\\n            }\\n        }\\n    }\\n        \\n    vector<int> dp(n+1); // answer for the string consisting of characters 1..i (1-based) \\n    for (int i = 1; i <= n;  i++) { // for each character\\n        dp[i] = dp[i-1]; // it is at least the previous answer\\n        for (int j = i - k + 1; j >= 1; j--) {\\n            if (table[j-1][i-1]) { // we have a palindrome of size at least k ending at position i\\n                dp[i] = max(dp[i], 1 + dp[j - 1]); \\n            }\\n        }\\n    }\\n    \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812282,
                "title": "easiest-and-most-straightforward-solution-no-dp-needed",
                "content": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        def isPaling(queue):\\n            return queue == queue[::-1]\\n        queue = []\\n        ans = 0\\n        for i in s:\\n            queue.append(i)\\n            \\n            basesys = queue[::-1]\\n            tempBatch = []\\n            for g in basesys:\\n                tempBatch.append(g)\\n                \\n                if len(tempBatch) >= k:\\n                    if isPaling(tempBatch):\\n                        ans += 1\\n                        queue = []\\n                        break\\n        return ans\\n                    \\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        def isPaling(queue):\\n            return queue == queue[::-1]\\n        queue = []\\n        ans = 0\\n        for i in s:\\n            queue.append(i)\\n            \\n            basesys = queue[::-1]\\n            tempBatch = []\\n            for g in basesys:\\n                tempBatch.append(g)\\n                \\n                if len(tempBatch) >= k:\\n                    if isPaling(tempBatch):\\n                        ans += 1\\n                        queue = []\\n                        break\\n        return ans\\n                    \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2812150,
                "title": "c-88-89-efficient-with-proof",
                "content": "![image](https://assets.leetcode.com/users/images/1017ead5-eff8-4cf9-8322-0ed1770cd8ba_1668371552.2726128.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxPalindromes(string s, int k) {\\n\\t\\t\\tint n = s.size(), last = INT_MIN, ans = 0;\\n\\t\\t\\tvector<vector<int>> intervals;\\n\\n\\t\\t\\tfor (int center = 0; center < 2*n; center++){\\n\\t\\t\\t\\tint left = center/2;\\n\\t\\t\\t\\tint right = left + center % 2;\\n\\t\\t\\t\\twhile (left >= 0 && right < n && s[left] == s[right]){\\n\\t\\t\\t\\t\\tif (right + 1 - left >= k){\\n\\t\\t\\t\\t\\t\\tintervals.push_back({left, right+1});\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tleft--; right++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (vector<int>& v: intervals){\\n\\t\\t\\t\\tif (v[0] >= last){\\n\\t\\t\\t\\t\\tlast = v[1];\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t}else if (v[1] < last)\\n\\t\\t\\t\\t\\t\\tlast = v[1];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxPalindromes(string s, int k) {\\n\\t\\t\\tint n = s.size(), last = INT_MIN, ans = 0;\\n\\t\\t\\tvector<vector<int>> intervals;\\n\\n\\t\\t\\tfor (int center = 0; center < 2*n; center++){\\n\\t\\t\\t\\tint left = center/2;\\n\\t\\t\\t\\tint right = left + center % 2;\\n\\t\\t\\t\\twhile (left >= 0 && right < n && s[left] == s[right]){\\n\\t\\t\\t\\t\\tif (right + 1 - left >= k){\\n\\t\\t\\t\\t\\t\\tintervals.push_back({left, right+1}",
                "codeTag": "Java"
            },
            {
                "id": 2812053,
                "title": "non-overlapping-intervals",
                "content": "This problem can be reduced to finding the largest number of non-overlapping palindromes in `s`. Hence, we just need to break it down into:\\n1. Finding all palindromes in `s` - let `dp[i][j]` denote whether the substring `s[i:j]` (inclusive) is a palindrome.\\n2. For all intervals `[i,j]` where `j>=i+k-1` and `dp[i][j] == 1`, find the maximum number of non-overlapping intervals.\\n\\nTechniques can be borrowed from these two problems:\\n* [1745. Palindrome Partitioning IV](https://leetcode.com/problems/palindrome-partitioning-iv/)\\n* [435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)\\n\\n**Space**: O(n^2)\\n**Time**: O(n^2 + n^2log(n^2))\\n\\n```c++\\ntypedef vector<int> vi;\\ntypedef pair<int,int>ii;\\n\\nclass Solution {\\npublic:  \\n    int maxPalindromes(string& s, int k) {\\n        int n=s.length();\\n        vector<vector<bool>>dp=vector<vector<bool>>(n,vector<bool>(n,false));\\n        int a,b;\\n\\t\\t\\n        for(int i=0;i<n;++i){\\n\\t\\t    // Find all odd-length palindromes\\n            a=i,b=i;\\n            while(a>=0&&b<n&&s[a]==s[b]){\\n                dp[a][b]=true;\\n                a--;b++;\\n            }\\n\\t\\t\\t\\n            if(i+1<n&&s[i]==s[i+1]){\\n\\t\\t\\t    // Find all even-length palindromes\\n                a=i,b=i+1;\\n                while(a>=0&&b<n&&s[a]==s[b]){\\n                    dp[a][b]=true;\\n                    a--;b++;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Get all valid intervals (length of at least k)\\n        vector<ii>intervals;\\n        for(int i=0;i<n;++i){\\n            for(int j=i+k-1;j<n;++j){\\n                if(dp[i][j])\\n                    intervals.push_back({i,j});\\n            }\\n        }\\n       \\n\\t    // Max. non-overlapping intervals\\n        sort(intervals.begin(),intervals.end(), [](const auto& a, const auto& b){\\n            return a.second < b.second;\\n        });\\n        if(!intervals.size())\\n            return 0;\\n        int ans=1, prevend=intervals[0].second;\\n        for(int i=1;i<intervals.size();++i){\\n            if(intervals[i].first > prevend){\\n                ans++;\\n                prevend=intervals[i].second;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```c++\\ntypedef vector<int> vi;\\ntypedef pair<int,int>ii;\\n\\nclass Solution {\\npublic:  \\n    int maxPalindromes(string& s, int k) {\\n        int n=s.length();\\n        vector<vector<bool>>dp=vector<vector<bool>>(n,vector<bool>(n,false));\\n        int a,b;\\n\\t\\t\\n        for(int i=0;i<n;++i){\\n\\t\\t    // Find all odd-length palindromes\\n            a=i,b=i;\\n            while(a>=0&&b<n&&s[a]==s[b]){\\n                dp[a][b]=true;\\n                a--;b++;\\n            }\\n\\t\\t\\t\\n            if(i+1<n&&s[i]==s[i+1]){\\n\\t\\t\\t    // Find all even-length palindromes\\n                a=i,b=i+1;\\n                while(a>=0&&b<n&&s[a]==s[b]){\\n                    dp[a][b]=true;\\n                    a--;b++;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Get all valid intervals (length of at least k)\\n        vector<ii>intervals;\\n        for(int i=0;i<n;++i){\\n            for(int j=i+k-1;j<n;++j){\\n                if(dp[i][j])\\n                    intervals.push_back({i,j});\\n            }\\n        }\\n       \\n\\t    // Max. non-overlapping intervals\\n        sort(intervals.begin(),intervals.end(), [](const auto& a, const auto& b){\\n            return a.second < b.second;\\n        });\\n        if(!intervals.size())\\n            return 0;\\n        int ans=1, prevend=intervals[0].second;\\n        for(int i=1;i<intervals.size();++i){\\n            if(intervals[i].first > prevend){\\n                ans++;\\n                prevend=intervals[i].second;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812021,
                "title": "java-intuitive-dp-memoization-easy-to-understand",
                "content": "```\\nclass Solution {    \\n    int n;\\n    public int maxPalindromes(String s, int k) { \\n        n = s.length();\\n        \\n        dp = new Integer[n];\\n        dpPal = new Boolean[n][n];\\n\\n        return solve(s, 0, k);        \\n    }\\n\\n    Integer dp[];\\n    public int solve(String s, int idx, int k){\\n\\n        if(idx >= n) return 0;\\n\\n        if(dp[idx] != null) return dp[idx];\\n\\n        int notPick = solve(s, idx +1, k); // calculating pal ss from next idx\\n\\n        int pick = 0;\\n        for(int i=idx+k-1; i<n; i++){ // exploring full string for palindrome\\n\\n            if(isPal(s, idx, i))\\n                pick = Math.max(pick, 1 + solve(s, i +1, k)); // if found then partition it from there\\n        }\\n\\n        return dp[idx] = Math.max(pick, notPick);\\n    }\\n\\n    Boolean dpPal[][];    \\n    public boolean isPal(String s, int i, int j){\\n\\n        if(i >= j) return true;\\n\\n        if(dpPal[i][j] != null) return dpPal[i][j];\\n\\n        if(s.charAt(i) == s.charAt(j))\\n            return dpPal[i][j] = isPal(s, i+1, j-1);\\n        else \\n            return dpPal[i][j] = false;        \\n    }\\n    // Palindromes are calculated in somewhat amortized fashion, eventually O(1);\\n    // So the complexity will remain n^2 only.\\n    // To be precise, (n^2) + (n^2)\\n}        \\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {    \\n    int n;\\n    public int maxPalindromes(String s, int k) { \\n        n = s.length();\\n        \\n        dp = new Integer[n];\\n        dpPal = new Boolean[n][n];\\n\\n        return solve(s, 0, k);        \\n    }\\n\\n    Integer dp[];\\n    public int solve(String s, int idx, int k){\\n\\n        if(idx >= n) return 0;\\n\\n        if(dp[idx] != null) return dp[idx];\\n\\n        int notPick = solve(s, idx +1, k); // calculating pal ss from next idx\\n\\n        int pick = 0;\\n        for(int i=idx+k-1; i<n; i++){ // exploring full string for palindrome\\n\\n            if(isPal(s, idx, i))\\n                pick = Math.max(pick, 1 + solve(s, i +1, k)); // if found then partition it from there\\n        }\\n\\n        return dp[idx] = Math.max(pick, notPick);\\n    }\\n\\n    Boolean dpPal[][];    \\n    public boolean isPal(String s, int i, int j){\\n\\n        if(i >= j) return true;\\n\\n        if(dpPal[i][j] != null) return dpPal[i][j];\\n\\n        if(s.charAt(i) == s.charAt(j))\\n            return dpPal[i][j] = isPal(s, i+1, j-1);\\n        else \\n            return dpPal[i][j] = false;        \\n    }\\n    // Palindromes are calculated in somewhat amortized fashion, eventually O(1);\\n    // So the complexity will remain n^2 only.\\n    // To be precise, (n^2) + (n^2)\\n}        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811890,
                "title": "c-memoization-1d",
                "content": "First Solve : https://leetcode.com/problems/palindromic-substrings/\\nSolution : https://leetcode.com/submissions/detail/842725112/\\n\\nNow Solve This: \\n\\n```\\nclass Solution {\\npublic:\\n    int dp[2002];\\n    int solve(string & s,int idx,int k)\\n    {\\n        int res = 0;\\n        int len =  s.length();\\n        if(dp[idx]!=-1) return dp[idx];\\n        for(int i = idx;i<len;i++)\\n        {\\n            int x = i-1;\\n            int y = i+1;\\n            while(x>=idx && y<len && s[x]==s[y])\\n            {\\n                if((y+1 - x) >=k)\\n                {\\n                    res =  max(res,solve(s,y+1,k) + 1);\\n                    break; // main trick\\n                }\\n                x--;y++;\\n            }\\n            \\n            x=i-1; y = i;\\n            \\n            while(x>=idx && y<len && s[x]==s[y])\\n            {\\n                if((y+1 - x) >=k)\\n                {\\n                    res =  max(res,solve(s,y+1,k) + 1);\\n                    break; // main trick\\n                }\\n                x--;y++;\\n            }\\n            \\n        }\\n        return dp[idx] = res;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        if(k==1) return s.length();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[2002];\\n    int solve(string & s,int idx,int k)\\n    {\\n        int res = 0;\\n        int len =  s.length();\\n        if(dp[idx]!=-1) return dp[idx];\\n        for(int i = idx;i<len;i++)\\n        {\\n            int x = i-1;\\n            int y = i+1;\\n            while(x>=idx && y<len && s[x]==s[y])\\n            {\\n                if((y+1 - x) >=k)\\n                {\\n                    res =  max(res,solve(s,y+1,k) + 1);\\n                    break; // main trick\\n                }\\n                x--;y++;\\n            }\\n            \\n            x=i-1; y = i;\\n            \\n            while(x>=idx && y<len && s[x]==s[y])\\n            {\\n                if((y+1 - x) >=k)\\n                {\\n                    res =  max(res,solve(s,y+1,k) + 1);\\n                    break; // main trick\\n                }\\n                x--;y++;\\n            }\\n            \\n        }\\n        return dp[idx] = res;\\n    }\\n    int maxPalindromes(string s, int k) {\\n        if(k==1) return s.length();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811760,
                "title": "c-non-overlapping-intervals-palindromic-substring-start-end",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        return maxPalindromesUtil(s , k);\\n    }\\n    \\n    \\n    int maxPalindromesUtil(string &s , int k){\\n        vector<pair<int , int>> Intervals;\\n        for(int i=0;i<s.length();i++){\\n            \\n            //For odd length palindromic substring;\\n            int start = i;\\n            int end = i;\\n            \\n            while(start >= 0 && end < s.length() && s[start] == s[end]){\\n                if((end - start + 1) >= k) Intervals.push_back({start , end});\\n                start--;\\n                end++;\\n            }\\n            \\n            //For even length palindromic substring;\\n            start = i;\\n            end = i + 1;\\n            \\n            while(start >=0 && end < s.length() && s[start] == s[end]){\\n                if((end - start + 1) >= k) Intervals.push_back({start , end});\\n                start --;\\n                end ++;\\n                \\n            }\\n        }\\n        \\n        return maxNonOverlappingIntervals(Intervals);;\\n    }\\n    \\n    static bool cmp(pair<int, int>& p, pair<int, int>& q){\\n        return (p.second < q.second);\\n    }\\n\\n \\n    int maxNonOverlappingIntervals(vector<pair<int, int> > &vec)\\n    {\\n        sort(vec.begin(), vec.end(), cmp);  \\n        int count = 1;\\n        int right = 0;\\n        if(vec.size() >= 1){\\n            right = vec[0].second;\\n        } \\n        else{\\n            count--;\\n        }\\n    \\n        for (int i = 1; i < vec.size(); i++) {\\n            int left = vec[i].first;\\n            int rt = vec[i].second;\\n            if (left > right) {\\n                count++;\\n                right = rt;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        return maxPalindromesUtil(s , k);\\n    }\\n    \\n    \\n    int maxPalindromesUtil(string &s , int k){\\n        vector<pair<int , int>> Intervals;\\n        for(int i=0;i<s.length();i++){\\n            \\n            //For odd length palindromic substring;\\n            int start = i;\\n            int end = i;\\n            \\n            while(start >= 0 && end < s.length() && s[start] == s[end]){\\n                if((end - start + 1) >= k) Intervals.push_back({start , end});\\n                start--;\\n                end++;\\n            }\\n            \\n            //For even length palindromic substring;\\n            start = i;\\n            end = i + 1;\\n            \\n            while(start >=0 && end < s.length() && s[start] == s[end]){\\n                if((end - start + 1) >= k) Intervals.push_back({start , end});\\n                start --;\\n                end ++;\\n                \\n            }\\n        }\\n        \\n        return maxNonOverlappingIntervals(Intervals);;\\n    }\\n    \\n    static bool cmp(pair<int, int>& p, pair<int, int>& q){\\n        return (p.second < q.second);\\n    }\\n\\n \\n    int maxNonOverlappingIntervals(vector<pair<int, int> > &vec)\\n    {\\n        sort(vec.begin(), vec.end(), cmp);  \\n        int count = 1;\\n        int right = 0;\\n        if(vec.size() >= 1){\\n            right = vec[0].second;\\n        } \\n        else{\\n            count--;\\n        }\\n    \\n        for (int i = 1; i < vec.size(); i++) {\\n            int left = vec[i].first;\\n            int rt = vec[i].second;\\n            if (left > right) {\\n                count++;\\n                right = rt;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811654,
                "title": "non-overlapping-intervals-greedy-python3",
                "content": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        intervals = []\\n        n = len(s)\\n        for i in range(n):\\n            j = 0\\n            while i - j > -1 and i + j < n and s[i - j] == s[i + j]:\\n                st, e = i - j, i + j\\n                if e - st + 1 >= k:\\n                    intervals.append([st, e])\\n                j += 1\\n        for i in range(n - 1):\\n            j = 0\\n            while i - j > -1 and i + 1 + j < n and s[i - j] == s[i + 1 + j]:\\n                st, e = i - j, i + 1 + j\\n                if e - st + 1 >= k:\\n                    intervals.append([st, e])\\n                    break\\n                j += 1\\n        intervals.sort(key = lambda x: x[1])\\n        t = -1\\n        ans = 0\\n        for s, e in intervals:\\n            if s > t:\\n                t = e\\n                ans += 1\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        intervals = []\\n        n = len(s)\\n        for i in range(n):\\n            j = 0\\n            while i - j > -1 and i + j < n and s[i - j] == s[i + j]:\\n                st, e = i - j, i + j\\n                if e - st + 1 >= k:\\n                    intervals.append([st, e])\\n                j += 1\\n        for i in range(n - 1):\\n            j = 0\\n            while i - j > -1 and i + 1 + j < n and s[i - j] == s[i + 1 + j]:\\n                st, e = i - j, i + 1 + j\\n                if e - st + 1 >= k:\\n                    intervals.append([st, e])\\n                    break\\n                j += 1\\n        intervals.sort(key = lambda x: x[1])\\n        t = -1\\n        ans = 0\\n        for s, e in intervals:\\n            if s > t:\\n                t = e\\n                ans += 1\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811394,
                "title": "optimal-dp-approach",
                "content": "**Expliaination**\\nFirst create a palindrome  table of n X n  size that will be marked as true at (i,j)\\nif subtring (i,j) of s is palindrome;\\nFor every index take two pointers i && j go to its left and right while s[i]==s[j]\\nmark pal[i][j]=true if(i==j) it will mark odd length substrings and if i==j-1 it will mark even length substrings\\n\\nNow use palindromic partition pattern of dp \\nto find the answer.\\nTime Complexity: ***O(NN)***\\n\\n**CODE**\\n\\'\\'\\'     \\n     \\n    void pal_form(int i,int j,string &s,vector<vector<bool>> &pal){\\n        \\n        while(i>=0 && j<=s.size()-1){\\n            if(s[i]==s[j]){\\n                pal[i][j]=true;\\n            }\\n            else break;\\n            i--; j++;\\n        }\\n        \\n        \\n    } \\n    int fun(int id,int n,int k,vector<int> &dp,vector<vector<bool>> &pal){\\n        \\n        if(id==n)\\n            return 0;\\n\\n        int ans=0;\\n        \\n        if(dp[id]!=-1)\\n            return dp[id];\\n        \\n        for(int i=id;i<n;i++){\\n    \\n            if(pal[id][i] && i-id+1>=k){    // if the substring is palindrome and its length is greater than k then \\n\\t\\t\\t\\n                ans=max(ans,1+fun(i+1,n,k,dp,pal)); // it may contribute 1 to answer\\n                    \\n            }\\n            else \\n\\t\\t\\t  ans=max(ans,fun(i+1,n,k,dp,pal)); \\n                \\n            \\n        }\\n        \\n        return dp[id]=ans;\\n    }\\n    int maxPalindromes(string s, int k) {\\n\\t\\n        int n=s.size();\\n        vector<int> dp(n,-1);\\n        vector<vector<bool>> pal(n,vector<bool>(n,false));\\n        \\n        for(int i=0;i<n;i++)    // To mark odd substrings\\n            pal_form(i,i,s,pal);\\n        \\n         for(int i=0;i<n-1;i++)  // To mark even substrings\\n            pal_form(i,i+1,s,pal);\\n        \\n        \\n        return fun(0,n,k,dp,pal);\\n        \\n    }   \\n\\t\\n\\n\\n \\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "**Expliaination**\\nFirst create a palindrome  table of n X n  size that will be marked as true at (i,j)\\nif subtring (i,j) of s is palindrome;\\nFor every index take two pointers i && j go to its left and right while s[i]==s[j]\\nmark pal[i][j]=true if(i==j) it will mark odd length substrings and if i==j-1 it will mark even length substrings\\n\\nNow use palindromic partition pattern of dp \\nto find the answer.\\nTime Complexity: ***O(NN)***\\n\\n**CODE**\\n\\'\\'\\'     \\n     \\n    void pal_form(int i,int j,string &s,vector<vector<bool>> &pal){\\n        \\n        while(i>=0 && j<=s.size()-1){\\n            if(s[i]==s[j]){\\n                pal[i][j]=true;\\n            }\\n            else break;\\n            i--; j++;\\n        }\\n        \\n        \\n    } \\n    int fun(int id,int n,int k,vector<int> &dp,vector<vector<bool>> &pal){\\n        \\n        if(id==n)\\n            return 0;\\n\\n        int ans=0;\\n        \\n        if(dp[id]!=-1)\\n            return dp[id];\\n        \\n        for(int i=id;i<n;i++){\\n    \\n            if(pal[id][i] && i-id+1>=k){    // if the substring is palindrome and its length is greater than k then \\n\\t\\t\\t\\n                ans=max(ans,1+fun(i+1,n,k,dp,pal)); // it may contribute 1 to answer\\n                    \\n            }\\n            else \\n\\t\\t\\t  ans=max(ans,fun(i+1,n,k,dp,pal)); \\n                \\n            \\n        }\\n        \\n        return dp[id]=ans;\\n    }\\n    int maxPalindromes(string s, int k) {\\n\\t\\n        int n=s.size();\\n        vector<int> dp(n,-1);\\n        vector<vector<bool>> pal(n,vector<bool>(n,false));\\n        \\n        for(int i=0;i<n;i++)    // To mark odd substrings\\n            pal_form(i,i,s,pal);\\n        \\n         for(int i=0;i<n-1;i++)  // To mark even substrings\\n            pal_form(i,i+1,s,pal);\\n        \\n        \\n        return fun(0,n,k,dp,pal);\\n        \\n    }   \\n\\t\\n\\n\\n \\n",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1681887,
                "content": [
                    {
                        "username": "arthur_g",
                        "content": "I wrote two versions of the same code - once in Py and another in CPP. The Py version will  time out but CPP will pass :( \\n\\nI think Big O wise, the code should be fine. I think the Py time limits should be extended. \\n\\n\\n`class Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        vector<vector<bool>> is_pal(s.size(),vector<bool>(s.size(), false));\\n        for(int l = 0;l<s.size();l++){\\n            for(int start = 0;start<s.size();start++){\\n                auto end = start + l;\\n                if(end >= s.size()){\\n                    break;\\n                }else if (start == end || start + 1 == end){\\n                // cout << start << \" \" << end << endl;\\n                    is_pal[start][end] = s[start] == s[end];\\n                } else{\\n                // cout << start << \" \" << end << endl;\\n                    is_pal[start][end] = (s[start] == s[end] && is_pal[start+1][end-1]);\\n                }\\n            }\\n        }\\n        vector<int> dp(s.size()+1, 0);\\n        for(int i = 0;i<s.size();i++){\\n            dp[i+1] = max(dp[i], dp[i+1]);\\n            for(int end = i+k-1;end<s.size();end++){\\n                if(is_pal[i][end]){\\n                    // t << i << \" \" << end << endl;\\n                    dp[end+1] = max(dp[end+1], dp[i]+1);\\n                    break;\\n                }\\n            }\\n            \\n        } \\n        // t << dp.size() << endl;\\n        return dp[s.size()];\\n    }\\n};`\\n\\n\\n`class Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        is_pal = [[False] * len(s) for let in s]\\n        for l in range(len(s)):\\n            for start in range(len(s)):\\n                end = start + l\\n                if end >= len(s):\\n                    break\\n                elif start == end or start+1 == end:\\n                    is_pal[start][end] = s[start] == s[end]\\n                else:\\n                    is_pal[start][end] = s[start] == s[end] and is_pal[start+1][end-1]\\n            \\n        dp = [0] * (len(s) + 1)\\n        for i in range(len(s)):\\n            dp[i+1] = max(dp[i], dp[i+1]) \\n            \\n            for end in range(i+k-1, len(s)):\\n                if is_pal[i][end]:\\n                    # print(\"Found\", start, end)\\n                    dp[end+1] = max(dp[end+1], dp[i] + 1)\\n                    break\\n        \\n        # print(dp)\\n        return dp[-1]`"
                    },
                    {
                        "username": "raggzy",
                        "content": "Same for me. Had to rewrite python3 code in java to get AC :/ Both versions O(n*n). \\nIt\\'s a pity there is no option for PyPy compiler here, since standard Python3 (Cython) is slow for even simple basic for loops with bits of math."
                    },
                    {
                        "username": "Abhinandan__22",
                        "content": "How to find given string contains a palindrome substring or not in O(N^2).\\n[Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/description/) - Try to solve this question with two pointer approach.\\n\\n[My Solution Post](https://leetcode.com/problems/maximum-number-of-non-overlapping-palindrome-substrings/solutions/2968462/c-easy-solution-two-pointer-runtime-0-ms-beats-100/)"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "My code is failing this test case and I can\\'t find the bug (P.S. yes I am a rookie):\\n\"sjbxiufnaanqkwsqswkqrcznzcddhtuhtthuttjfuufjtcfywgecegwyhhnnhtozczirynhhnyrire\"\\n\\n `\\nint maxPalindromes(string s, int k) {\\n        \\n        if (s.size() < k)\\n            return 0;\\n\\n        if (k == 1)\\n            return s.size();\\n\\n        int left = 0, right = 0, count = 0;\\n        while (left < s.size() && right < s.size())\\n        {\\n            while (right < s.size())\\n            {\\n                while (right < s.size() && right - left < k - 1)\\n                    right++;\\n\\n                if (s[left] == s[right])\\n                {\\n                    int inLeft = left, inRight = right;\\n                    bool isPalin = true;\\n                    while (inLeft < inRight)\\n                    {\\n                        if (s[inLeft] != s[inRight])\\n                        {\\n                            isPalin = false;\\n                            break;\\n                        }\\n                        inLeft++;\\n                        inRight--;\\n                    }\\n                    if (isPalin)\\n                    {\\n                        count++;\\n                        left = right + 1;\\n                    }\\n                }\\n                right++;\\n            }\\n            left++;\\n            right = left + 1;\\n        }\\n        return count;\\n    }\\n`"
                    },
                    {
                        "username": "alokyadav_88",
                        "content": "Question was to find maximum no. of non-overlapping substring so i thing for this input ans should be 6 instead of 4.\\n\\n `Input: \"fttfjofpnpfydwdwdnns\"\\n2\\nOutput: 6\\nExpected: 4\\nStdout: fttf\\nfpnpf\\ndwd\\nwdw\\ndwd\\nnn\\n`"
                    },
                    {
                        "username": "biltharesatyendra",
                        "content": "dwd  , wdw  and dwd are overlapping, so you can take only 1 of these 3 at a time.\n\nfttfjofpnpfy<b>dwdwd</b>nns"
                    }
                ]
            },
            {
                "id": 1733342,
                "content": [
                    {
                        "username": "arthur_g",
                        "content": "I wrote two versions of the same code - once in Py and another in CPP. The Py version will  time out but CPP will pass :( \\n\\nI think Big O wise, the code should be fine. I think the Py time limits should be extended. \\n\\n\\n`class Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        vector<vector<bool>> is_pal(s.size(),vector<bool>(s.size(), false));\\n        for(int l = 0;l<s.size();l++){\\n            for(int start = 0;start<s.size();start++){\\n                auto end = start + l;\\n                if(end >= s.size()){\\n                    break;\\n                }else if (start == end || start + 1 == end){\\n                // cout << start << \" \" << end << endl;\\n                    is_pal[start][end] = s[start] == s[end];\\n                } else{\\n                // cout << start << \" \" << end << endl;\\n                    is_pal[start][end] = (s[start] == s[end] && is_pal[start+1][end-1]);\\n                }\\n            }\\n        }\\n        vector<int> dp(s.size()+1, 0);\\n        for(int i = 0;i<s.size();i++){\\n            dp[i+1] = max(dp[i], dp[i+1]);\\n            for(int end = i+k-1;end<s.size();end++){\\n                if(is_pal[i][end]){\\n                    // t << i << \" \" << end << endl;\\n                    dp[end+1] = max(dp[end+1], dp[i]+1);\\n                    break;\\n                }\\n            }\\n            \\n        } \\n        // t << dp.size() << endl;\\n        return dp[s.size()];\\n    }\\n};`\\n\\n\\n`class Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        is_pal = [[False] * len(s) for let in s]\\n        for l in range(len(s)):\\n            for start in range(len(s)):\\n                end = start + l\\n                if end >= len(s):\\n                    break\\n                elif start == end or start+1 == end:\\n                    is_pal[start][end] = s[start] == s[end]\\n                else:\\n                    is_pal[start][end] = s[start] == s[end] and is_pal[start+1][end-1]\\n            \\n        dp = [0] * (len(s) + 1)\\n        for i in range(len(s)):\\n            dp[i+1] = max(dp[i], dp[i+1]) \\n            \\n            for end in range(i+k-1, len(s)):\\n                if is_pal[i][end]:\\n                    # print(\"Found\", start, end)\\n                    dp[end+1] = max(dp[end+1], dp[i] + 1)\\n                    break\\n        \\n        # print(dp)\\n        return dp[-1]`"
                    },
                    {
                        "username": "raggzy",
                        "content": "Same for me. Had to rewrite python3 code in java to get AC :/ Both versions O(n*n). \\nIt\\'s a pity there is no option for PyPy compiler here, since standard Python3 (Cython) is slow for even simple basic for loops with bits of math."
                    },
                    {
                        "username": "Abhinandan__22",
                        "content": "How to find given string contains a palindrome substring or not in O(N^2).\\n[Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/description/) - Try to solve this question with two pointer approach.\\n\\n[My Solution Post](https://leetcode.com/problems/maximum-number-of-non-overlapping-palindrome-substrings/solutions/2968462/c-easy-solution-two-pointer-runtime-0-ms-beats-100/)"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "My code is failing this test case and I can\\'t find the bug (P.S. yes I am a rookie):\\n\"sjbxiufnaanqkwsqswkqrcznzcddhtuhtthuttjfuufjtcfywgecegwyhhnnhtozczirynhhnyrire\"\\n\\n `\\nint maxPalindromes(string s, int k) {\\n        \\n        if (s.size() < k)\\n            return 0;\\n\\n        if (k == 1)\\n            return s.size();\\n\\n        int left = 0, right = 0, count = 0;\\n        while (left < s.size() && right < s.size())\\n        {\\n            while (right < s.size())\\n            {\\n                while (right < s.size() && right - left < k - 1)\\n                    right++;\\n\\n                if (s[left] == s[right])\\n                {\\n                    int inLeft = left, inRight = right;\\n                    bool isPalin = true;\\n                    while (inLeft < inRight)\\n                    {\\n                        if (s[inLeft] != s[inRight])\\n                        {\\n                            isPalin = false;\\n                            break;\\n                        }\\n                        inLeft++;\\n                        inRight--;\\n                    }\\n                    if (isPalin)\\n                    {\\n                        count++;\\n                        left = right + 1;\\n                    }\\n                }\\n                right++;\\n            }\\n            left++;\\n            right = left + 1;\\n        }\\n        return count;\\n    }\\n`"
                    },
                    {
                        "username": "alokyadav_88",
                        "content": "Question was to find maximum no. of non-overlapping substring so i thing for this input ans should be 6 instead of 4.\\n\\n `Input: \"fttfjofpnpfydwdwdnns\"\\n2\\nOutput: 6\\nExpected: 4\\nStdout: fttf\\nfpnpf\\ndwd\\nwdw\\ndwd\\nnn\\n`"
                    },
                    {
                        "username": "biltharesatyendra",
                        "content": "dwd  , wdw  and dwd are overlapping, so you can take only 1 of these 3 at a time.\n\nfttfjofpnpfy<b>dwdwd</b>nns"
                    }
                ]
            },
            {
                "id": 1893799,
                "content": [
                    {
                        "username": "arthur_g",
                        "content": "I wrote two versions of the same code - once in Py and another in CPP. The Py version will  time out but CPP will pass :( \\n\\nI think Big O wise, the code should be fine. I think the Py time limits should be extended. \\n\\n\\n`class Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        vector<vector<bool>> is_pal(s.size(),vector<bool>(s.size(), false));\\n        for(int l = 0;l<s.size();l++){\\n            for(int start = 0;start<s.size();start++){\\n                auto end = start + l;\\n                if(end >= s.size()){\\n                    break;\\n                }else if (start == end || start + 1 == end){\\n                // cout << start << \" \" << end << endl;\\n                    is_pal[start][end] = s[start] == s[end];\\n                } else{\\n                // cout << start << \" \" << end << endl;\\n                    is_pal[start][end] = (s[start] == s[end] && is_pal[start+1][end-1]);\\n                }\\n            }\\n        }\\n        vector<int> dp(s.size()+1, 0);\\n        for(int i = 0;i<s.size();i++){\\n            dp[i+1] = max(dp[i], dp[i+1]);\\n            for(int end = i+k-1;end<s.size();end++){\\n                if(is_pal[i][end]){\\n                    // t << i << \" \" << end << endl;\\n                    dp[end+1] = max(dp[end+1], dp[i]+1);\\n                    break;\\n                }\\n            }\\n            \\n        } \\n        // t << dp.size() << endl;\\n        return dp[s.size()];\\n    }\\n};`\\n\\n\\n`class Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        is_pal = [[False] * len(s) for let in s]\\n        for l in range(len(s)):\\n            for start in range(len(s)):\\n                end = start + l\\n                if end >= len(s):\\n                    break\\n                elif start == end or start+1 == end:\\n                    is_pal[start][end] = s[start] == s[end]\\n                else:\\n                    is_pal[start][end] = s[start] == s[end] and is_pal[start+1][end-1]\\n            \\n        dp = [0] * (len(s) + 1)\\n        for i in range(len(s)):\\n            dp[i+1] = max(dp[i], dp[i+1]) \\n            \\n            for end in range(i+k-1, len(s)):\\n                if is_pal[i][end]:\\n                    # print(\"Found\", start, end)\\n                    dp[end+1] = max(dp[end+1], dp[i] + 1)\\n                    break\\n        \\n        # print(dp)\\n        return dp[-1]`"
                    },
                    {
                        "username": "raggzy",
                        "content": "Same for me. Had to rewrite python3 code in java to get AC :/ Both versions O(n*n). \\nIt\\'s a pity there is no option for PyPy compiler here, since standard Python3 (Cython) is slow for even simple basic for loops with bits of math."
                    },
                    {
                        "username": "Abhinandan__22",
                        "content": "How to find given string contains a palindrome substring or not in O(N^2).\\n[Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/description/) - Try to solve this question with two pointer approach.\\n\\n[My Solution Post](https://leetcode.com/problems/maximum-number-of-non-overlapping-palindrome-substrings/solutions/2968462/c-easy-solution-two-pointer-runtime-0-ms-beats-100/)"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "My code is failing this test case and I can\\'t find the bug (P.S. yes I am a rookie):\\n\"sjbxiufnaanqkwsqswkqrcznzcddhtuhtthuttjfuufjtcfywgecegwyhhnnhtozczirynhhnyrire\"\\n\\n `\\nint maxPalindromes(string s, int k) {\\n        \\n        if (s.size() < k)\\n            return 0;\\n\\n        if (k == 1)\\n            return s.size();\\n\\n        int left = 0, right = 0, count = 0;\\n        while (left < s.size() && right < s.size())\\n        {\\n            while (right < s.size())\\n            {\\n                while (right < s.size() && right - left < k - 1)\\n                    right++;\\n\\n                if (s[left] == s[right])\\n                {\\n                    int inLeft = left, inRight = right;\\n                    bool isPalin = true;\\n                    while (inLeft < inRight)\\n                    {\\n                        if (s[inLeft] != s[inRight])\\n                        {\\n                            isPalin = false;\\n                            break;\\n                        }\\n                        inLeft++;\\n                        inRight--;\\n                    }\\n                    if (isPalin)\\n                    {\\n                        count++;\\n                        left = right + 1;\\n                    }\\n                }\\n                right++;\\n            }\\n            left++;\\n            right = left + 1;\\n        }\\n        return count;\\n    }\\n`"
                    },
                    {
                        "username": "alokyadav_88",
                        "content": "Question was to find maximum no. of non-overlapping substring so i thing for this input ans should be 6 instead of 4.\\n\\n `Input: \"fttfjofpnpfydwdwdnns\"\\n2\\nOutput: 6\\nExpected: 4\\nStdout: fttf\\nfpnpf\\ndwd\\nwdw\\ndwd\\nnn\\n`"
                    },
                    {
                        "username": "biltharesatyendra",
                        "content": "dwd  , wdw  and dwd are overlapping, so you can take only 1 of these 3 at a time.\n\nfttfjofpnpfy<b>dwdwd</b>nns"
                    }
                ]
            },
            {
                "id": 1682218,
                "content": [
                    {
                        "username": "arthur_g",
                        "content": "I wrote two versions of the same code - once in Py and another in CPP. The Py version will  time out but CPP will pass :( \\n\\nI think Big O wise, the code should be fine. I think the Py time limits should be extended. \\n\\n\\n`class Solution {\\npublic:\\n    int maxPalindromes(string s, int k) {\\n        vector<vector<bool>> is_pal(s.size(),vector<bool>(s.size(), false));\\n        for(int l = 0;l<s.size();l++){\\n            for(int start = 0;start<s.size();start++){\\n                auto end = start + l;\\n                if(end >= s.size()){\\n                    break;\\n                }else if (start == end || start + 1 == end){\\n                // cout << start << \" \" << end << endl;\\n                    is_pal[start][end] = s[start] == s[end];\\n                } else{\\n                // cout << start << \" \" << end << endl;\\n                    is_pal[start][end] = (s[start] == s[end] && is_pal[start+1][end-1]);\\n                }\\n            }\\n        }\\n        vector<int> dp(s.size()+1, 0);\\n        for(int i = 0;i<s.size();i++){\\n            dp[i+1] = max(dp[i], dp[i+1]);\\n            for(int end = i+k-1;end<s.size();end++){\\n                if(is_pal[i][end]){\\n                    // t << i << \" \" << end << endl;\\n                    dp[end+1] = max(dp[end+1], dp[i]+1);\\n                    break;\\n                }\\n            }\\n            \\n        } \\n        // t << dp.size() << endl;\\n        return dp[s.size()];\\n    }\\n};`\\n\\n\\n`class Solution:\\n    def maxPalindromes(self, s: str, k: int) -> int:\\n        is_pal = [[False] * len(s) for let in s]\\n        for l in range(len(s)):\\n            for start in range(len(s)):\\n                end = start + l\\n                if end >= len(s):\\n                    break\\n                elif start == end or start+1 == end:\\n                    is_pal[start][end] = s[start] == s[end]\\n                else:\\n                    is_pal[start][end] = s[start] == s[end] and is_pal[start+1][end-1]\\n            \\n        dp = [0] * (len(s) + 1)\\n        for i in range(len(s)):\\n            dp[i+1] = max(dp[i], dp[i+1]) \\n            \\n            for end in range(i+k-1, len(s)):\\n                if is_pal[i][end]:\\n                    # print(\"Found\", start, end)\\n                    dp[end+1] = max(dp[end+1], dp[i] + 1)\\n                    break\\n        \\n        # print(dp)\\n        return dp[-1]`"
                    },
                    {
                        "username": "raggzy",
                        "content": "Same for me. Had to rewrite python3 code in java to get AC :/ Both versions O(n*n). \\nIt\\'s a pity there is no option for PyPy compiler here, since standard Python3 (Cython) is slow for even simple basic for loops with bits of math."
                    },
                    {
                        "username": "Abhinandan__22",
                        "content": "How to find given string contains a palindrome substring or not in O(N^2).\\n[Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/description/) - Try to solve this question with two pointer approach.\\n\\n[My Solution Post](https://leetcode.com/problems/maximum-number-of-non-overlapping-palindrome-substrings/solutions/2968462/c-easy-solution-two-pointer-runtime-0-ms-beats-100/)"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "My code is failing this test case and I can\\'t find the bug (P.S. yes I am a rookie):\\n\"sjbxiufnaanqkwsqswkqrcznzcddhtuhtthuttjfuufjtcfywgecegwyhhnnhtozczirynhhnyrire\"\\n\\n `\\nint maxPalindromes(string s, int k) {\\n        \\n        if (s.size() < k)\\n            return 0;\\n\\n        if (k == 1)\\n            return s.size();\\n\\n        int left = 0, right = 0, count = 0;\\n        while (left < s.size() && right < s.size())\\n        {\\n            while (right < s.size())\\n            {\\n                while (right < s.size() && right - left < k - 1)\\n                    right++;\\n\\n                if (s[left] == s[right])\\n                {\\n                    int inLeft = left, inRight = right;\\n                    bool isPalin = true;\\n                    while (inLeft < inRight)\\n                    {\\n                        if (s[inLeft] != s[inRight])\\n                        {\\n                            isPalin = false;\\n                            break;\\n                        }\\n                        inLeft++;\\n                        inRight--;\\n                    }\\n                    if (isPalin)\\n                    {\\n                        count++;\\n                        left = right + 1;\\n                    }\\n                }\\n                right++;\\n            }\\n            left++;\\n            right = left + 1;\\n        }\\n        return count;\\n    }\\n`"
                    },
                    {
                        "username": "alokyadav_88",
                        "content": "Question was to find maximum no. of non-overlapping substring so i thing for this input ans should be 6 instead of 4.\\n\\n `Input: \"fttfjofpnpfydwdwdnns\"\\n2\\nOutput: 6\\nExpected: 4\\nStdout: fttf\\nfpnpf\\ndwd\\nwdw\\ndwd\\nnn\\n`"
                    },
                    {
                        "username": "biltharesatyendra",
                        "content": "dwd  , wdw  and dwd are overlapping, so you can take only 1 of these 3 at a time.\n\nfttfjofpnpfy<b>dwdwd</b>nns"
                    }
                ]
            }
        ]
    }
]