[
    {
        "title": "Department Highest Salary",
        "question_content": "Table: Employee\n\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| id           | int     |\n| name         | varchar |\n| salary       | int     |\n| departmentId | int     |\n+--------------+---------+\nid is the primary key (column with unique values) for this table.\ndepartmentId is a foreign key (reference columns) of the ID from the Department table.\nEach row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department.\n\n&nbsp;\nTable: Department\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table. It is guaranteed that department name is not NULL.\nEach row of this table indicates the ID of a department and its name.\n\n&nbsp;\nWrite a solution to find employees who have the highest salary in each of the departments.\nReturn the result table in any order.\nThe result format is in the following example.\n&nbsp;\nExample 1:\n\nInput: \nEmployee table:\n+----+-------+--------+--------------+\n| id | name  | salary | departmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 70000  | 1            |\n| 2  | Jim   | 90000  | 1            |\n| 3  | Henry | 80000  | 2            |\n| 4  | Sam   | 60000  | 2            |\n| 5  | Max   | 90000  | 1            |\n+----+-------+--------+--------------+\nDepartment table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | IT    |\n| 2  | Sales |\n+----+-------+\nOutput: \n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Jim      | 90000  |\n| Sales      | Henry    | 80000  |\n| IT         | Max      | 90000  |\n+------------+----------+--------+\nExplanation: Max and Jim both have the highest salary in the IT department and Henry has the highest salary in the Sales department.",
        "solutions": [
            {
                "id": 53607,
                "title": "three-accpeted-solutions",
                "content": "    SELECT D.Name AS Department ,E.Name AS Employee ,E.Salary \\n    FROM\\n    \\tEmployee E,\\n    \\t(SELECT DepartmentId,max(Salary) as max FROM Employee GROUP BY DepartmentId) T,\\n    \\tDepartment D\\n    WHERE E.DepartmentId = T.DepartmentId \\n      AND E.Salary = T.max\\n      AND E.DepartmentId = D.id\\n\\n    SELECT D.Name,A.Name,A.Salary \\n    FROM \\n    \\tEmployee A,\\n    \\tDepartment D   \\n    WHERE A.DepartmentId = D.Id \\n      AND NOT EXISTS \\n      (SELECT 1 FROM Employee B WHERE B.Salary > A.Salary AND A.DepartmentId = B.DepartmentId) \\n\\n    SELECT D.Name AS Department ,E.Name AS Employee ,E.Salary \\n    from \\n    \\tEmployee E,\\n    \\tDepartment D \\n    WHERE E.DepartmentId = D.id \\n      AND (DepartmentId,Salary) in \\n      (SELECT DepartmentId,max(Salary) as max FROM Employee GROUP BY DepartmentId)",
                "solutionTags": [],
                "code": "    SELECT D.Name AS Department ,E.Name AS Employee ,E.Salary \\n    FROM\\n    \\tEmployee E,\\n    \\t(SELECT DepartmentId,max(Salary) as max FROM Employee GROUP BY DepartmentId) T,\\n    \\tDepartment D\\n    WHERE E.DepartmentId = T.DepartmentId \\n      AND E.Salary = T.max\\n      AND E.DepartmentId = D.id\\n\\n    SELECT D.Name,A.Name,A.Salary \\n    FROM \\n    \\tEmployee A,\\n    \\tDepartment D   \\n    WHERE A.DepartmentId = D.Id \\n      AND NOT EXISTS \\n      (SELECT 1 FROM Employee B WHERE B.Salary > A.Salary AND A.DepartmentId = B.DepartmentId) \\n\\n    SELECT D.Name AS Department ,E.Name AS Employee ,E.Salary \\n    from \\n    \\tEmployee E,\\n    \\tDepartment D \\n    WHERE E.DepartmentId = D.id \\n      AND (DepartmentId,Salary) in \\n      (SELECT DepartmentId,max(Salary) as max FROM Employee GROUP BY DepartmentId)",
                "codeTag": "Unknown"
            },
            {
                "id": 2457422,
                "title": "solution-with-detail-explanation-easy-to-understand",
                "content": "**Please upvote Me ^ Thanks.**\\nIT IS SIMPLE \\n\\nfirst identify highest salary by \\n`SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId`\\n\\nThen JOIN both table by\\n`SELECT Department.name AS Department ,Employee.name AS Employee, Employee.salary\\nFROM Department  JOIN Employee  ON Employee.departmentId=Department.id `\\n\\nThen put Condition by\\n`WHERE(departmentId, salary) IN\\n(SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId) ;`\\n\\n**Code**\\n\\n```\\nSELECT Department.name AS Department ,Employee.name AS Employee, Employee.salary\\nFROM Department  JOIN Employee  ON Employee.departmentId=Department.id \\nWHERE(departmentId, salary) IN\\n(SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId) ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Department.name AS Department ,Employee.name AS Employee, Employee.salary\\nFROM Department  JOIN Employee  ON Employee.departmentId=Department.id \\nWHERE(departmentId, salary) IN\\n(SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId) ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3861495,
                "title": "pandas-very-simple-step-by-step-process-detailed",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach involves merging the DataFrames, grouping by department, and then finding the employees with the highest salary within each group using the max function and boolean indexing. The function handles empty table scenarios and correctly renames the columns as specified.\\n\\n# Detailed procedure\\n- Check if either the employee or department DataFrame is empty. If either of them is empty, return an empty DataFrame with the column names [\\'Department\\', \\'Employee\\', \\'Salary\\'].\\n```\\n    if employee.empty or department.empty:\\n        return pd.DataFrame(columns=[\\'Department\\',\\'Employee\\', \\'Salary\\'])\\n```\\n- Merge the employee and department DataFrames on \\'departmentId\\' and \\'id\\' columns, respectively, using the merge function.\\n```\\n    merged_df = employee.merge(department, left_on=\\'departmentId\\', right_on=\\'id\\', suffixes=(\\'_employee\\', \\'_department\\'))\\n```\\n- Use the groupby function to group data in merged_df by \\'departmentId\\' and apply a lambda function to find employees with the highest salary in each group.\\n```\\n    highest_salary_df = merged_df.groupby(\\'departmentId\\').apply(lambda x: x[x[\\'salary\\'] == x[\\'salary\\'].max()])\\n```\\n- Reset the index of highest_salary_df to remove the group labels and obtain a flat DataFrame.\\n```\\n    highest_salary_df = highest_salary_df.reset_index(drop=True)\\n```\\n- Select the required columns \\'name_department\\', \\'name_employee\\', and \\'salary\\' from highest_salary_df to get the department name, employee name, and salary of employees with the highest salary in each department.\\n```\\n    result_df = highest_salary_df[[\\'name_department\\', \\'name_employee\\', \\'salary\\']]\\n```\\n- Rename the columns of the resulting DataFrame to [\\'Department\\', \\'Employee\\', \\'Salary\\'] as specified.\\n```\\n    result_df.columns = [\\'Department\\',\\'Employee\\', \\'Salary\\']\\n```\\n- Return the resulting DataFrame result_df containing employees with the highest salary in each department.\\n\\n\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef department_highest_salary(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    if employee.empty or department.empty:\\n        return pd.DataFrame(columns=[\\'Department\\',\\'Employee\\', \\'Salary\\'])\\n    \\n    # Merge the employee and department DataFrames on \\'departmentId\\' and \\'id\\' columns\\n    merged_df = employee.merge(department, left_on=\\'departmentId\\', right_on=\\'id\\', suffixes=(\\'_employee\\', \\'_department\\'))\\n    \\n    # Use groupby to group data by \\'departmentId\\' and apply a lambda function to get employees with highest salary in each group\\n    highest_salary_df = merged_df.groupby(\\'departmentId\\').apply(lambda x: x[x[\\'salary\\'] == x[\\'salary\\'].max()])\\n    \\n    # Drop the duplicate \\'departmentId\\' column and reset the index\\n    highest_salary_df = highest_salary_df.reset_index(drop=True)\\n    \\n    # Select the required columns and return the result\\n    result_df = highest_salary_df[[\\'name_department\\', \\'name_employee\\', \\'salary\\']]\\n    \\n    # Rename the columns as specified\\n    result_df.columns = [\\'Department\\',\\'Employee\\', \\'Salary\\']\\n    \\n    return result_df\\n```\\n\\n# Please upvote the solution which motivates me to share high quality solutions like this \\uD83E\\uDD7A Thank You \\u2764\\uFE0F.",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\n    if employee.empty or department.empty:\\n        return pd.DataFrame(columns=[\\'Department\\',\\'Employee\\', \\'Salary\\'])\\n```\n```\\n    merged_df = employee.merge(department, left_on=\\'departmentId\\', right_on=\\'id\\', suffixes=(\\'_employee\\', \\'_department\\'))\\n```\n```\\n    highest_salary_df = merged_df.groupby(\\'departmentId\\').apply(lambda x: x[x[\\'salary\\'] == x[\\'salary\\'].max()])\\n```\n```\\n    highest_salary_df = highest_salary_df.reset_index(drop=True)\\n```\n```\\n    result_df = highest_salary_df[[\\'name_department\\', \\'name_employee\\', \\'salary\\']]\\n```\n```\\n    result_df.columns = [\\'Department\\',\\'Employee\\', \\'Salary\\']\\n```\n```\\nimport pandas as pd\\n\\ndef department_highest_salary(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    if employee.empty or department.empty:\\n        return pd.DataFrame(columns=[\\'Department\\',\\'Employee\\', \\'Salary\\'])\\n    \\n    # Merge the employee and department DataFrames on \\'departmentId\\' and \\'id\\' columns\\n    merged_df = employee.merge(department, left_on=\\'departmentId\\', right_on=\\'id\\', suffixes=(\\'_employee\\', \\'_department\\'))\\n    \\n    # Use groupby to group data by \\'departmentId\\' and apply a lambda function to get employees with highest salary in each group\\n    highest_salary_df = merged_df.groupby(\\'departmentId\\').apply(lambda x: x[x[\\'salary\\'] == x[\\'salary\\'].max()])\\n    \\n    # Drop the duplicate \\'departmentId\\' column and reset the index\\n    highest_salary_df = highest_salary_df.reset_index(drop=True)\\n    \\n    # Select the required columns and return the result\\n    result_df = highest_salary_df[[\\'name_department\\', \\'name_employee\\', \\'salary\\']]\\n    \\n    # Rename the columns as specified\\n    result_df.columns = [\\'Department\\',\\'Employee\\', \\'Salary\\']\\n    \\n    return result_df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 53608,
                "title": "simple-solution-easy-to-understand",
                "content": "    SELECT dep.Name as Department, emp.Name as Employee, emp.Salary \\n    from Department dep, Employee emp \\n    where emp.DepartmentId=dep.Id \\n    and emp.Salary=(Select max(Salary) from Employee e2 where e2.DepartmentId=dep.Id)",
                "solutionTags": [],
                "code": "    SELECT dep.Name as Department, emp.Name as Employee, emp.Salary \\n    from Department dep, Employee emp \\n    where emp.DepartmentId=dep.Id \\n    and emp.Salary=(Select max(Salary) from Employee e2 where e2.DepartmentId=dep.Id)",
                "codeTag": "Unknown"
            },
            {
                "id": 3827264,
                "title": "100-easy-fast-clean-solution",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT DEPT.name AS Department, EMP.name AS Employee, EMP.salary AS \\n\\nSalary FROM Department DEPT, Employee EMP WHERE\\n\\nEMP.departmentId = DEPT.id AND (EMP.departmentId, salary) IN \\n\\n(SELECT departmentId, MAX (salary) FROM Employee GROUP BY \\n\\ndepartmentId)\\n```\\nIF THIS WILL BE HELPFUL TO YOU,PLEASE UPVOTE !\\n\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/c29d80c7-fd85-4816-8171-ebf71ef130fa_1690526222.9120727.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT DEPT.name AS Department, EMP.name AS Employee, EMP.salary AS \\n\\nSalary FROM Department DEPT, Employee EMP WHERE\\n\\nEMP.departmentId = DEPT.id AND (EMP.departmentId, salary) IN \\n\\n(SELECT departmentId, MAX (salary) FROM Employee GROUP BY \\n\\ndepartmentId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53670,
                "title": "sharing-my-simple-solution",
                "content": "    Select Department.Name, emp1.Name, emp1.Salary from \\n    Employee emp1 join Department on emp1.DepartmentId = Department.Id\\n    where emp1.Salary = (Select Max(Salary) from Employee emp2 where emp2.DepartmentId = emp1.DepartmentId);",
                "solutionTags": [],
                "code": "    Select Department.Name, emp1.Name, emp1.Salary from \\n    Employee emp1 join Department on emp1.DepartmentId = Department.Id\\n    where emp1.Salary = (Select Max(Salary) from Employee emp2 where emp2.DepartmentId = emp1.DepartmentId);",
                "codeTag": "Unknown"
            },
            {
                "id": 53612,
                "title": "group-by-having-not-working-for-multiple-highest-salary-why",
                "content": "`SELECT b.Name as Department, a.Name as Employee, a.Salary\\nFROM Employee a\\nJOIN Department b\\nON a.DepartmentId = b.Id\\nGROUP BY Department\\nHAVING a.Salary = max(a.Salary)`\\n\\nThis way it was not able to return multiple rows with same highest salary. I can't figure why, please help!",
                "solutionTags": [],
                "code": "`SELECT b.Name as Department, a.Name as Employee, a.Salary\\nFROM Employee a\\nJOIN Department b\\nON a.DepartmentId = b.Id\\nGROUP BY Department\\nHAVING a.Salary = max(a.Salary)`\\n\\nThis way it was not able to return multiple rows with same highest salary. I can't figure why, please help!",
                "codeTag": "Unknown"
            },
            {
                "id": 631832,
                "title": "mysql-partition-by-with-join-solution-with-explaination",
                "content": "```\\nSELECT b.Name AS Department, a.Name AS Employee, Salary FROM\\n(SELECT *, MAX(Salary) OVER(PARTITION BY DepartmentId) AS max_val\\nFROM Employee) a\\nJOIN Department b\\nON a.DepartmentId = b.Id\\nWHERE Salary = max_val;\\n```\\nLogic here: add a column to the original Employee table of max salary within that department (that is what over partition by do)\\nThen we select the ones that match max with its value to filter out the people with max salary of his / her department\\nThen we join on the Department table to get the require information",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT b.Name AS Department, a.Name AS Employee, Salary FROM\\n(SELECT *, MAX(Salary) OVER(PARTITION BY DepartmentId) AS max_val\\nFROM Employee) a\\nJOIN Department b\\nON a.DepartmentId = b.Id\\nWHERE Salary = max_val;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53609,
                "title": "why-cannot-we-just-use-max-with-group-by",
                "content": "    select D.name as Department, E.name as Employee, max(salary) as Salary \\n        from Employee E , Department D \\n        where E.DepartmentId = D.Id  \\n        group by D.id\\n\\nI tried to use something like this, but it did not pass. When two departments has the same max salary, it only outputs one row.\\n\\nHowever, this is not how it works in my local mysql.\\n\\nWhy is this wrong?",
                "solutionTags": [],
                "code": "    select D.name as Department, E.name as Employee, max(salary) as Salary \\n        from Employee E , Department D \\n        where E.DepartmentId = D.Id  \\n        group by D.id\\n\\nI tried to use something like this, but it did not pass. When two departments has the same max salary, it only outputs one row.\\n\\nHowever, this is not how it works in my local mysql.\\n\\nWhy is this wrong?",
                "codeTag": "Unknown"
            },
            {
                "id": 3214824,
                "title": "184-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLet\\'s go through the steps:\\n\\nJoin the Employee and Department tables on the departmentId column to get the name of the department for each employee.\\nUse a subquery to get the maximum salary for each department. The subquery first groups the employees by departmentId, and then gets the maximum salary for each group using the MAX function.\\nJoin the result of the subquery with the Employee table on the departmentId and salary columns to get the employees who have the maximum salary for their department.\\nSelect the Department, Employee, and Salary columns from the result.\\nThis query will return the department name, employee name, and their salary for each department where at least one employee has the highest salary. The result will be ordered by department name, but the order of the rows within each department is not specified.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nTo find the employees who have the highest salary in each of the departments, we can use a subquery to get the maximum salary for each department, and then join it with the employee table to get the employees who have the maximum salary for their department.\\n\\nHere\\'s the SQL query:\\n\\n```\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM Employee e\\nJOIN Department d ON e.departmentId = d.id\\nWHERE (e.departmentId, e.salary) IN\\n    (SELECT departmentId, MAX(salary)\\n     FROM Employee\\n     GROUP BY departmentId)\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM Employee e\\nJOIN Department d ON e.departmentId = d.id\\nWHERE (e.departmentId, e.salary) IN\\n    (SELECT departmentId, MAX(salary)\\n     FROM Employee\\n     GROUP BY departmentId)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3019487,
                "title": "95-beats-mysql-solution",
                "content": "\\n# Code\\n```\\nselect Department,e.name as Employee,e.salary as Salary \\nfrom employee e,\\n(\\n    select d.id department_id,d.name as Department,max(e.salary) as max \\n    from department d left join employee e \\n    on  d.id=e.departmentId \\n    group by d.id\\n) as MaxSalaries \\nwhere e.departmentId=department_id and e.salary = max;\\n```\\n\\n```\\nplease upvote, if you find it useful\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect Department,e.name as Employee,e.salary as Salary \\nfrom employee e,\\n(\\n    select d.id department_id,d.name as Department,max(e.salary) as max \\n    from department d left join employee e \\n    on  d.id=e.departmentId \\n    group by d.id\\n) as MaxSalaries \\nwhere e.departmentId=department_id and e.salary = max;\\n```\n```\\nplease upvote, if you find it useful\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2163234,
                "title": "mysql-solution-using-join",
                "content": "```\\nSELECT D.NAME AS DEPARTMENT,\\nE.NAME AS EMPLOYEE,\\nE.SALARY\\nFROM EMPLOYEE E\\nJOIN DEPARTMENT D ON \\nE.DEPARTMENTID = D.ID\\nWHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE WHERE D.ID = EMPLOYEE.DEPARTMENTID);\\n```\\n\\nPlease upvote if you find it useful.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT D.NAME AS DEPARTMENT,\\nE.NAME AS EMPLOYEE,\\nE.SALARY\\nFROM EMPLOYEE E\\nJOIN DEPARTMENT D ON \\nE.DEPARTMENTID = D.ID\\nWHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE WHERE D.ID = EMPLOYEE.DEPARTMENTID);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867312,
                "title": "pandas-vs-sql-elegant-short-all-30-days-of-pandas-solutions",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```Python []\\ndef department_highest_salary(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    return employee.merge(\\n        department, left_on=\\'departmentId\\', right_on=\\'id\\', suffixes=(\\'_employee\\', \\'_department\\')\\n    ).groupby(\\n        \\'departmentId\\'\\n    ).apply(\\n        lambda x: x[x[\\'salary\\'] == x[\\'salary\\'].max()]\\n    ).reset_index(drop=True)[\\n        [\\'name_department\\', \\'name_employee\\', \\'salary\\']\\n    ].rename(columns={\\n        \\'name_department\\': \\'Department\\',\\n        \\'name_employee\\': \\'Employee\\',\\n        \\'salary\\': \\'Salary\\',\\n    })\\n```\\n```SQL []\\nWITH cte AS (\\n    SELECT d.name AS department,\\n           e.name AS employee,\\n           e.salary,\\n           max(e.salary) OVER (PARTITION BY d.id) AS max_salary\\n      FROM Employee e\\n          JOIN Department d\\n              ON e.departmentId = d.id\\n)\\nSELECT department,\\n       employee,\\n       salary\\n  FROM cte\\n WHERE salary = max_salary;\\n```\\n\\n# Important!\\n###### If you like the solution or find it useful, feel free to **upvote** for it, it will support me in creating high quality solutions)\\n\\n# 30 Days of Pandas solutions\\n\\n### Data Filtering \\u2705\\n- [Big Countries](https://leetcode.com/problems/big-countries/solutions/3848474/pandas-elegant-short-1-line/)\\n- [Recyclable and Low Fat Products](https://leetcode.com/problems/recyclable-and-low-fat-products/solutions/3848500/pandas-elegant-short-1-line/)\\n- [Customers Who Never Order](https://leetcode.com/problems/customers-who-never-order/solutions/3848527/pandas-elegant-short-1-line/)\\n- [Article Views I](https://leetcode.com/problems/article-views-i/solutions/3867192/pandas-elegant-short-1-line/)\\n\\n\\n### String Methods \\u2705\\n- [Invalid Tweets](https://leetcode.com/problems/invalid-tweets/solutions/3849121/pandas-elegant-short-1-line/)\\n- [Calculate Special Bonus](https://leetcode.com/problems/calculate-special-bonus/solutions/3867209/pandas-elegant-short-1-line/)\\n- [Fix Names in a Table](https://leetcode.com/problems/fix-names-in-a-table/solutions/3849167/pandas-elegant-short-1-line/)\\n- [Find Users With Valid E-Mails](https://leetcode.com/problems/find-users-with-valid-e-mails/solutions/3849177/pandas-elegant-short-1-line/)\\n- [Patients With a Condition](https://leetcode.com/problems/patients-with-a-condition/solutions/3849196/pandas-elegant-short-1-line-regex/)\\n\\n\\n### Data Manipulation \\u2705\\n- [Nth Highest Salary](https://leetcode.com/problems/nth-highest-salary/solutions/3867257/pandas-elegant-short-1-line/)\\n- [Second Highest Salary](https://leetcode.com/problems/second-highest-salary/solutions/3867278/pandas-elegant-short/)\\n- [Department Highest Salary](https://leetcode.com/problems/department-highest-salary/solutions/3867312/pandas-elegant-short-1-line/)\\n- [Rank Scores](https://leetcode.com/problems/rank-scores/solutions/3872817/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Delete Duplicate Emails](https://leetcode.com/problems/delete-duplicate-emails/solutions/3849211/pandas-elegant-short/)\\n- [Rearrange Products Table](https://leetcode.com/problems/rearrange-products-table/solutions/3849226/pandas-elegant-short-1-line/)\\n\\n\\n### Statistics \\u2705\\n- [The Number of Rich Customers](https://leetcode.com/problems/the-number-of-rich-customers/solutions/3849251/pandas-elegant-short-1-line/)\\n- [Immediate Food Delivery I](https://leetcode.com/problems/immediate-food-delivery-i/solutions/3872719/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Count Salary Categories](https://leetcode.com/problems/count-salary-categories/solutions/3872801/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Find Total Time Spent by Each Employee](https://leetcode.com/problems/find-total-time-spent-by-each-employee/solutions/3872715/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Game Play Analysis I](https://leetcode.com/problems/game-play-analysis-i/solutions/3863223/pandas-elegant-short-1-line/)\\n- [Number of Unique Subjects Taught by Each Teacher](https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/solutions/3863239/pandas-elegant-short-1-line/)\\n- [Classes More Than 5 Students](https://leetcode.com/problems/classes-more-than-5-students/solutions/3863249/pandas-elegant-short/)\\n- [Customer Placing the Largest Number of Orders](https://leetcode.com/problems/customer-placing-the-largest-number-of-orders/solutions/3863257/pandas-elegant-short-1-line/)\\n- [Group Sold Products By The Date](https://leetcode.com/problems/group-sold-products-by-the-date/solutions/3863267/pandas-elegant-short-1-line/)\\n- [Daily Leads and Partners](https://leetcode.com/problems/daily-leads-and-partners/solutions/3863279/pandas-elegant-short-1-line/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Actors and Directors Who Cooperated At Least Three Times](https://leetcode.com/problems/actors-and-directors-who-cooperated-at-least-three-times/solutions/3863309/pandas-elegant-short/)\\n- [Replace Employee ID With The Unique Identifier](https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier/solutions/3872822/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Students and Examinations](https://leetcode.com/problems/students-and-examinations/solutions/3872699/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Managers with at Least 5 Direct Reports](https://leetcode.com/problems/managers-with-at-least-5-direct-reports/solutions/3872861/pandas-elegant-short/)\\n- [Sales Person](https://leetcode.com/problems/sales-person/solutions/3872712/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "MySQL",
                    "Pandas"
                ],
                "code": "```Python []\\ndef department_highest_salary(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    return employee.merge(\\n        department, left_on=\\'departmentId\\', right_on=\\'id\\', suffixes=(\\'_employee\\', \\'_department\\')\\n    ).groupby(\\n        \\'departmentId\\'\\n    ).apply(\\n        lambda x: x[x[\\'salary\\'] == x[\\'salary\\'].max()]\\n    ).reset_index(drop=True)[\\n        [\\'name_department\\', \\'name_employee\\', \\'salary\\']\\n    ].rename(columns={\\n        \\'name_department\\': \\'Department\\',\\n        \\'name_employee\\': \\'Employee\\',\\n        \\'salary\\': \\'Salary\\',\\n    })\\n```\n```SQL []\\nWITH cte AS (\\n    SELECT d.name AS department,\\n           e.name AS employee,\\n           e.salary,\\n           max(e.salary) OVER (PARTITION BY d.id) AS max_salary\\n      FROM Employee e\\n          JOIN Department d\\n              ON e.departmentId = d.id\\n)\\nSELECT department,\\n       employee,\\n       salary\\n  FROM cte\\n WHERE salary = max_salary;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 53647,
                "title": "a-simple-solution-use-one-join",
                "content": "select d.Name Department, e.Name Employee, Salary\\nfrom Department d join Employee e on d.Id=e.DepartmentId\\nwhere (Salary,d.id) in (select max(Salary),DepartmentId from Employee group by DepartmentId);",
                "solutionTags": [],
                "code": "select d.Name Department, e.Name Employee, Salary\\nfrom Department d join Employee e on d.Id=e.DepartmentId\\nwhere (Salary,d.id) in (select max(Salary),DepartmentId from Employee group by DepartmentId);",
                "codeTag": "Unknown"
            },
            {
                "id": 53610,
                "title": "my-best-solution-super-clean-no-subquery-no-max",
                "content": "Oftentimes those interviewers won't allow you to write subquery~\\n\\n**Return the highest salary for each department**\\n\\n      SELECT D.Name as Department, E.Name as Employee, E.Salary \\n      FROM Department D, Employee E, Employee E2  \\n      WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n      E.Salary <= E2.Salary\\n      group by D.ID,E.Name having count(distinct E2.Salary) = 1\\n      order by D.Name desc\\n\\n**Follow up, return the secondary salary for each department**\\n\\n       SELECT D.Name as Department, E.Name as Employee, E.Salary \\n       FROM Department D, Employee E, Employee E2  \\n       WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n       E.Salary < E2.Salary\\n       group by D.ID,E.Name having count(distinct E2.Salary) = 1\\n       order by D.Name desc",
                "solutionTags": [],
                "code": "Oftentimes those interviewers won't allow you to write subquery~\\n\\n**Return the highest salary for each department**\\n\\n      SELECT D.Name as Department, E.Name as Employee, E.Salary \\n      FROM Department D, Employee E, Employee E2  \\n      WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n      E.Salary <= E2.Salary\\n      group by D.ID,E.Name having count(distinct E2.Salary) = 1\\n      order by D.Name desc\\n\\n**Follow up, return the secondary salary for each department**\\n\\n       SELECT D.Name as Department, E.Name as Employee, E.Salary \\n       FROM Department D, Employee E, Employee E2  \\n       WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n       E.Salary < E2.Salary\\n       group by D.ID,E.Name having count(distinct E2.Salary) = 1\\n       order by D.Name desc",
                "codeTag": "Unknown"
            },
            {
                "id": 2421075,
                "title": "mysql-2-different-approach-easy-understanding-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**.*\\n______________________\\n\\u2705 **MySQL Code :**\\n***Approach 1:***\\n```\\nSELECT t1.Department, t1.Employee, t1.Salary\\nFROM(SELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\n,RANK()OVER(PARTITION BY d.id ORDER BY salary DESC) AS rk\\nFROM Department AS d\\nJOIN Employee AS e ON E.departmentId = d.id) AS t1\\nWHERE rk = 1\\n```\\n__________________________________\\n***Approach 2***:\\n\\n```\\nSELECT D.Name AS Department ,E.Name AS Employee ,E.Salary \\nFROM\\n\\tEmployee E,\\n\\t(SELECT DepartmentId,max(Salary) as max FROM Employee GROUP BY DepartmentId) T,\\n\\tDepartment D\\nWHERE E.DepartmentId = T.DepartmentId \\n  AND E.Salary = T.max\\n  AND E.DepartmentId = D.id\\n```\\n______________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT t1.Department, t1.Employee, t1.Salary\\nFROM(SELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\n,RANK()OVER(PARTITION BY d.id ORDER BY salary DESC) AS rk\\nFROM Department AS d\\nJOIN Employee AS e ON E.departmentId = d.id) AS t1\\nWHERE rk = 1\\n```\n```\\nSELECT D.Name AS Department ,E.Name AS Employee ,E.Salary \\nFROM\\n\\tEmployee E,\\n\\t(SELECT DepartmentId,max(Salary) as max FROM Employee GROUP BY DepartmentId) T,\\n\\tDepartment D\\nWHERE E.DepartmentId = T.DepartmentId \\n  AND E.Salary = T.max\\n  AND E.DepartmentId = D.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 914390,
                "title": "mysql-find-the-highest-salary-with-rank-function",
                "content": "We can either group table by `DepartmentId` and get the highest salary with `max(salary)`, or use window function `rank`. \n\n```sql\nSELECT department, employee, salary\nFROM ( SELECT a.name AS employee\n        , b.name AS department\n        , salary\n        , RANK() OVER (PARTITION BY b.name ORDER BY a.salary DESC) AS dr\n    FROM employee a JOIN department b ON a.departmentid = b.id ) tmp\n    WHERE dr = 1\n```",
                "solutionTags": [],
                "code": "```sql\nSELECT department, employee, salary\nFROM ( SELECT a.name AS employee\n        , b.name AS department\n        , salary\n        , RANK() OVER (PARTITION BY b.name ORDER BY a.salary DESC) AS dr\n    FROM employee a JOIN department b ON a.departmentid = b.id ) tmp\n    WHERE dr = 1\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53676,
                "title": "share-my-simple-query-using-all",
                "content": "<PRE><CODE>\\nselect Department.Name as Department, e1.Name as Employee, Salary\\nfrom Employee e1, Department\\nwhere e1.DepartmentId = Department.Id \\nand\\nSalary >= ALL (select Salary from Employee e2 where e2.DepartmentId = e1.DepartmentId);\\n</CODE></PRE>",
                "solutionTags": [],
                "code": "<PRE><CODE>\\nselect Department.Name as Department, e1.Name as Employee, Salary\\nfrom Employee e1, Department\\nwhere e1.DepartmentId = Department.Id \\nand\\nSalary >= ALL (select Salary from Employee e2 where e2.DepartmentId = e1.DepartmentId);\\n</CODE></PRE>",
                "codeTag": "Unknown"
            },
            {
                "id": 3880019,
                "title": "pandas-3-line-solution-beats-90",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe could do this using a series of group-by, apply and merge operations, but we can do it quickly utilizing group-by and transform. Documentation is here: https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.transform.html\\n\\nIf you can\\'t really understand the documentation (I couldn\\'t), using transform in conjunction with a group-by operation in this situation is (informally)\\n1) Performing the group-by operation specified (in this case, grouping by department).\\n2) Calling [\\'Salary\\'] is extracting the salary series while maintaing the group-by information.\\n3) .transform(max) is taking the maximum of salaries by group, and converting it back into a series of the same length that preserves indexes from merged_df. In this context, it returns a series of salaries where each entry is the maximum salary in a particular department, and entries are duplicated and arranged such that the order matches up with each observation in the original dataframe (merged_df). Intuitively, if you added this series to the dataframe, it\\'s like adding an attribute to each individual which tells us the highest salary in their department.\\n\\nIn the end, we use this series to filter for the rows in the orignal dataframe which have the maximum salary. Amazingly, it accounts for ties in the maximum salary due to how we are able to filter using this series. \\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef department_highest_salary(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    #First, we merge the employee and department dataframes \\n    #using an inner join (default for merge)\\n    merged_df = employee.merge(department, left_on = \\'departmentId\\', right_on = \\'id\\')\\n\\n    #Second, we rename the columns \\n    #and take only the department, employee, and salary columns\\n    merged_df = merged_df.rename(columns = {\\'name_x\\': \\'Employee\\', \\'name_y\\': \\'Department\\', \\'salary\\': \\'Salary\\'})[[\\'Department\\', \\'Employee\\', \\'Salary\\']]\\n    \\n    return merged_df[merged_df[\\'Salary\\'] == merged_df.groupby(\\'Department\\')[\\'Salary\\'].transform(max)]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef department_highest_salary(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    #First, we merge the employee and department dataframes \\n    #using an inner join (default for merge)\\n    merged_df = employee.merge(department, left_on = \\'departmentId\\', right_on = \\'id\\')\\n\\n    #Second, we rename the columns \\n    #and take only the department, employee, and salary columns\\n    merged_df = merged_df.rename(columns = {\\'name_x\\': \\'Employee\\', \\'name_y\\': \\'Department\\', \\'salary\\': \\'Salary\\'})[[\\'Department\\', \\'Employee\\', \\'Salary\\']]\\n    \\n    return merged_df[merged_df[\\'Salary\\'] == merged_df.groupby(\\'Department\\')[\\'Salary\\'].transform(max)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1008243,
                "title": "six-ways-to-solve-this",
                "content": "Start with defining a common table expression for the join which I\\'ll reuse for all solutions\\n```\\nwith DepartmentSalary\\nas\\n(\\nselect d.Name as Department, e.Name as Employee, e.Salary as Salary\\nfrom Employee e join Department d on\\n    e.DepartmentId = d.Id\\n)\\n```\\n\\nSolution 1: \\n```\\nselect * from DepartmentSalary ds\\nwhere not Salary < ANY (select Salary from DepartmentSalary where Department = ds.Department)\\n```\\n\\nSolution 2:\\n```\\nselect * from DepartmentSalary ds\\nwhere Salary >= All (select Salary from DepartmentSalary where Department = ds.Department)\\n```\\n\\nSolution 3:\\n```\\nselect * from DepartmentSalary ds\\nwhere Salary = (select max(Salary) from DepartmentSalary where Department = ds.Department)\\n```\\n\\nSolution 4: \\nThis is probably the most optimal, since this will only do 1 scan of the table (Others will need to rely on the query optimizer, which if it\\'s smart will hopefully figure out how to rewrite the query to a similar form). \\n```\\nselect Department, Employee, Salary from (\\nselect *, max(Salary) over (partition by Department) maxSalary from DepartmentSalary\\n)tmp where Salary = maxSalary\\n```\\n\\nSolution 5:\\n```\\nselect * from DepartmentSalary ds\\nwhere Salary = (select max(Salary) from DepartmentSalary where Department = ds.Department)\\n```\\n\\nSolution 6:\\n```\\nselect ds.* from DepartmentSalary ds\\njoin\\n(\\n    select Department, max(Salary) maxSalary from DepartmentSalary\\n    group by Department \\n) maxSalary\\non\\nds.Department = maxSalary.Department\\nand\\nds.Salary = maxSalary.maxSalary\\n```",
                "solutionTags": [],
                "code": "```\\nwith DepartmentSalary\\nas\\n(\\nselect d.Name as Department, e.Name as Employee, e.Salary as Salary\\nfrom Employee e join Department d on\\n    e.DepartmentId = d.Id\\n)\\n```\n```\\nselect * from DepartmentSalary ds\\nwhere not Salary < ANY (select Salary from DepartmentSalary where Department = ds.Department)\\n```\n```\\nselect * from DepartmentSalary ds\\nwhere Salary >= All (select Salary from DepartmentSalary where Department = ds.Department)\\n```\n```\\nselect * from DepartmentSalary ds\\nwhere Salary = (select max(Salary) from DepartmentSalary where Department = ds.Department)\\n```\n```\\nselect Department, Employee, Salary from (\\nselect *, max(Salary) over (partition by Department) maxSalary from DepartmentSalary\\n)tmp where Salary = maxSalary\\n```\n```\\nselect * from DepartmentSalary ds\\nwhere Salary = (select max(Salary) from DepartmentSalary where Department = ds.Department)\\n```\n```\\nselect ds.* from DepartmentSalary ds\\njoin\\n(\\n    select Department, max(Salary) maxSalary from DepartmentSalary\\n    group by Department \\n) maxSalary\\non\\nds.Department = maxSalary.Department\\nand\\nds.Salary = maxSalary.maxSalary\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1559069,
                "title": "faster-than-99-29-using-mysql-windowing-functions-with-detailed-explanation",
                "content": "Runtime: 457 ms, faster than 99.29% of MySQL online submissions for Department Highest Salary.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Department Highest Salary.\\n\\nExplanation: I\\'m using concept of Windowing, which is [well supported by MySQL](https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html). Together with Windowing I\\'m using [`RANK()`](https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank) function, which ranks all the salaries grouped by `e.departmentId` (`PARTITION BY e.departmentId`) and the rank is calculated descending based on the salary value (`ORDER BY e.salary DESC`). We could, of course, use [`DENSE_RANK()`](https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_dense-rank).\\n\\nChacteristing of `RANK()` is that if two or more values have the same rank (1st in our case), they will have the same value, therefore we can select them safely in the final `SELECT` using `WHERE sr.srank = 1`.\\n\\nNotes:\\n\\n1. I like to name columns explicitly, so there is no \"figuring out\" how the column is named and from where does it come from, hence the additional code.\\n2. I prefer to use `WITH` (so called [`Common Table Expressions`](https://dev.mysql.com/doc/refman/8.0/en/with.html)) instead of nested queries. Why? Code is more readable, easier to understand, easier to maintain and develop. It\\'s also reflecting more how we think from a perspective of preparing data for a final `SELECT`, breaking subqueries into logical steps. It especially works with longer queries.\\n\\n```sql\\n# Write your MySQL query statement below\\nWITH salaries_ranked AS (\\n    SELECT\\n        e.departmentId id,\\n        e.name name,\\n        e.salary salary,\\n        RANK() OVER(\\n            PARTITION BY e.departmentId\\n            ORDER BY e.salary DESC\\n        ) srank\\n    FROM Employee e\\n)\\nSELECT\\n    d.name Department,\\n    sr.name Employee,\\n    sr.salary\\nFROM salaries_ranked sr\\nJOIN Department d ON d.id = sr.id\\nWHERE sr.srank = 1;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "```sql\\n# Write your MySQL query statement below\\nWITH salaries_ranked AS (\\n    SELECT\\n        e.departmentId id,\\n        e.name name,\\n        e.salary salary,\\n        RANK() OVER(\\n            PARTITION BY e.departmentId\\n            ORDER BY e.salary DESC\\n        ) srank\\n    FROM Employee e\\n)\\nSELECT\\n    d.name Department,\\n    sr.name Employee,\\n    sr.salary\\nFROM salaries_ranked sr\\nJOIN Department d ON d.id = sr.id\\nWHERE sr.srank = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3082984,
                "title": "rank-window-function",
                "content": "# Intuition\\nuse rank() to rank salary partition by departments, then select rank = 1 rows\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nWITH joined as(\\nSELECT d.name Department,\\ne.name as Employee, \\ne.salary as Salary,\\nRANK() over (PARTITION BY d.name ORDER BY e.salary DESC) rank \\nFROM Department d \\nJOIN Employee e on d.id = e.departmentId\\n) \\n\\nselect \\nDepartment,Employee, Salary\\nfrom joined \\nWHERE rank = 1\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nWITH joined as(\\nSELECT d.name Department,\\ne.name as Employee, \\ne.salary as Salary,\\nRANK() over (PARTITION BY d.name ORDER BY e.salary DESC) rank \\nFROM Department d \\nJOIN Employee e on d.id = e.departmentId\\n) \\n\\nselect \\nDepartment,Employee, Salary\\nfrom joined \\nWHERE rank = 1\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2717605,
                "title": "simple-logic-no-advance-function-used",
                "content": "```\\nSELECT    D.name AS DEPARTMENT , \\n          E.name AS EMPLOYEE , \\n\\t\\t  E.salary\\n     FROM EMPLOYEE AS E \\n\\t               JOIN \\n\\t\\t\\t\\t   DEPARTMENT AS D \\n\\t\\t\\t\\t   ON E.departmentId = D.id\\n     WHERE E.salary =   ( SELECT MAX(salary) # this subquery gives max salary  of an department so that we can generate all employees who have max salary in that department.\\n                                 FROM EMPLOYEE\\n                                 WHERE departmentID = E.departmentID);\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT    D.name AS DEPARTMENT , \\n          E.name AS EMPLOYEE , \\n\\t\\t  E.salary\\n     FROM EMPLOYEE AS E \\n\\t               JOIN \\n\\t\\t\\t\\t   DEPARTMENT AS D \\n\\t\\t\\t\\t   ON E.departmentId = D.id\\n     WHERE E.salary =   ( SELECT MAX(salary) # this subquery gives max salary  of an department so that we can generate all employees who have max salary in that department.\\n                                 FROM EMPLOYEE\\n                                 WHERE departmentID = E.departmentID);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2525723,
                "title": "simplest-solution",
                "content": "```\\nselect d.name as Department ,e.name as Employee ,e.salary \\nfrom Employee e, Department d \\nwhere e.DepartmentId = d.id and (DepartmentId,Salary) in \\n(select DepartmentId,max(Salary) as max from Employee group by DepartmentId)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect d.name as Department ,e.name as Employee ,e.salary \\nfrom Employee e, Department d \\nwhere e.DepartmentId = d.id and (DepartmentId,Salary) in \\n(select DepartmentId,max(Salary) as max from Employee group by DepartmentId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1069024,
                "title": "clean-code-i-was-upset-about-the-discussion-none-was-clear",
                "content": "Upvote if you like the cleanliness!! \\n\\nwith cte as(\\nselect d.Name as Department, \\n    e.Name as Employee, \\n    e.Salary as Salary,\\n    rank() over(partition by d.Name Order by Salary desc) as ranks\\n    from Employee e inner join Department d on d.Id = e.Departmentid)\\n    \\nselect \\nDepartment,\\nEmployee, \\nSalary\\nfrom cte\\nWhere ranks = 1",
                "solutionTags": [],
                "code": "Upvote if you like the cleanliness!! \\n\\nwith cte as(\\nselect d.Name as Department, \\n    e.Name as Employee, \\n    e.Salary as Salary,\\n    rank() over(partition by d.Name Order by Salary desc) as ranks\\n    from Employee e inner join Department d on d.Id = e.Departmentid)\\n    \\nselect \\nDepartment,\\nEmployee, \\nSalary\\nfrom cte\\nWhere ranks = 1",
                "codeTag": "Unknown"
            },
            {
                "id": 2996402,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect Department.name as \\'Department\\', Employee.name as \\'Employee\\', Salary\\nfrom Employee join Department on Employee.DepartmentId = Department.Id\\nwhere (Employee.DepartmentId, Salary) in (\\nselect DepartmentId, max(Salary) from Employee group by DepartmentId);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Department.name as \\'Department\\', Employee.name as \\'Employee\\', Salary\\nfrom Employee join Department on Employee.DepartmentId = Department.Id\\nwhere (Employee.DepartmentId, Salary) in (\\nselect DepartmentId, max(Salary) from Employee group by DepartmentId);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875758,
                "title": "ms-sql-two-approach-subquery-group-by-join",
                "content": "Approach 1\\n```\\nselect d.name as Department, e.name as Employee, e.salary as Salary \\nfrom Employee e join Department d on e.departmentId = d.id\\nwhere 1 > (select count(salary) \\n            from Employee e1 \\n            where e1.salary > e.salary and e1.departmentId = e.departmentId);\\n\\n```\\n\\nApproach 2\\n\\n```\\nselect d.name as Department, e.name as Employee, e.salary as Salary \\nfrom Employee e join Department d on e.departmentId = d.id\\nwhere e.salary = (select max(salary) \\n                from Employee e1 group by e1.departmentId having e1.departmentId = e.departmentId);\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect d.name as Department, e.name as Employee, e.salary as Salary \\nfrom Employee e join Department d on e.departmentId = d.id\\nwhere 1 > (select count(salary) \\n            from Employee e1 \\n            where e1.salary > e.salary and e1.departmentId = e.departmentId);\\n\\n```\n```\\nselect d.name as Department, e.name as Employee, e.salary as Salary \\nfrom Employee e join Department d on e.departmentId = d.id\\nwhere e.salary = (select max(salary) \\n                from Employee e1 group by e1.departmentId having e1.departmentId = e.departmentId);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53658,
                "title": "easy-solution-no-joins-group-by-is-enough-916ms",
                "content": "    select\\n    d.Name, e.Name, e.Salary\\n    from\\n    Department d,\\n    Employee e,\\n    (select MAX(Salary) as Salary,  DepartmentId as DepartmentId from Employee GROUP BY DepartmentId) h\\n    where\\n    e.Salary = h.Salary and\\n    e.DepartmentId = h.DepartmentId and\\n    e.DepartmentId = d.Id;",
                "solutionTags": [],
                "code": "    select\\n    d.Name, e.Name, e.Salary\\n    from\\n    Department d,\\n    Employee e,\\n    (select MAX(Salary) as Salary,  DepartmentId as DepartmentId from Employee GROUP BY DepartmentId) h\\n    where\\n    e.Salary = h.Salary and\\n    e.DepartmentId = h.DepartmentId and\\n    e.DepartmentId = d.Id;",
                "codeTag": "Unknown"
            },
            {
                "id": 3927506,
                "title": "pandas-beginner-friendly-solution",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nimport pandas as pd\\n\\ndef department_highest_salary(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    \\n    merged_df = employee.merge(department, left_on = \\'departmentId\\', right_on = \\'id\\')\\n    \\n    merged_df = merged_df.rename(columns = {\\'name_x\\': \\'Employee\\', \\'name_y\\': \\'Department\\', \\'salary\\': \\'Salary\\'})[[\\'Department\\', \\'Employee\\', \\'Salary\\']]\\n    \\n    return merged_df[merged_df[\\'Salary\\'] == merged_df.groupby(\\'Department\\')[\\'Salary\\'].transform(max)]\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef department_highest_salary(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    \\n    merged_df = employee.merge(department, left_on = \\'departmentId\\', right_on = \\'id\\')\\n    \\n    merged_df = merged_df.rename(columns = {\\'name_x\\': \\'Employee\\', \\'name_y\\': \\'Department\\', \\'salary\\': \\'Salary\\'})[[\\'Department\\', \\'Employee\\', \\'Salary\\']]\\n    \\n    return merged_df[merged_df[\\'Salary\\'] == merged_df.groupby(\\'Department\\')[\\'Salary\\'].transform(max)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3496337,
                "title": "easy-peasy-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect d.name as department,e.name as employee ,e.salary from employee as e \\njoin \\ndepartment as d on e.departmentId=d.id \\n    where (e.departmentId,e.salary) in (\\n    select departmentId , max(salary) from employee\\n    group by departmentId\\n);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect d.name as department,e.name as employee ,e.salary from employee as e \\njoin \\ndepartment as d on e.departmentId=d.id \\n    where (e.departmentId,e.salary) in (\\n    select departmentId , max(salary) from employee\\n    group by departmentId\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3323167,
                "title": "easy-mysql-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT D.name AS Department, E.name AS Employee,E.salary AS Salary from Employee E,Department D\\nwhere D.id=E.departmentId and E.salary=(SELECT max(salary) from Employee E where E.departmentId=D.id);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT D.name AS Department, E.name AS Employee,E.salary AS Salary from Employee E,Department D\\nwhere D.id=E.departmentId and E.salary=(SELECT max(salary) from Employee E where E.departmentId=D.id);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1869199,
                "title": "simple-mysql-querry",
                "content": "```\\nSELECT \\n    dep.Name as Department,\\n    emp.Name as Employee,\\n    emp.Salary \\nfrom \\n    Department dep,\\n    Employee emp \\nwhere \\n    emp.DepartmentId = dep.Id \\nand \\n    emp.Salary=\\n        (Select \\n            max(Salary) \\n         from \\n            Employee emp2 \\n         where \\n            emp2.DepartmentId=dep.Id)\\n```\\n\\nPlease comment if there is any doubt in the above querry.\\n\\nPlease **Upvote** if you like the solution.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    dep.Name as Department,\\n    emp.Name as Employee,\\n    emp.Salary \\nfrom \\n    Department dep,\\n    Employee emp \\nwhere \\n    emp.DepartmentId = dep.Id \\nand \\n    emp.Salary=\\n        (Select \\n            max(Salary) \\n         from \\n            Employee emp2 \\n         where \\n            emp2.DepartmentId=dep.Id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1346210,
                "title": "group-by-and-having-oracle",
                "content": "```\\n/* Write your PL/SQL query statement below */\\nselect d.name department,e.name employee ,e.salary salary from employee e,department d where e.departmentid=d.id and\\ne.salary=(select max(distinct salary) from employee group by departmentid having departmentid=e.departmentid);\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect d.name department,e.name employee ,e.salary salary from employee e,department d where e.departmentid=d.id and\\ne.salary=(select max(distinct salary) from employee group by departmentid having departmentid=e.departmentid);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442426,
                "title": "simple-mysql-query",
                "content": "```\\nSELECT \\n    d.Name AS Department, e.Name AS Employee, e.Salary AS Salary\\nFROM \\n    Employee AS e, Department AS d\\nWHERE \\n    e.DepartmentID = d.Id\\n    AND\\n    e.Salary = (SELECT \\n                    MAX(Salary) \\n               FROM \\n                    Employee\\n               WHERE\\n                    DepartmentId = d.Id)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    d.Name AS Department, e.Name AS Employee, e.Salary AS Salary\\nFROM \\n    Employee AS e, Department AS d\\nWHERE \\n    e.DepartmentID = d.Id\\n    AND\\n    e.Salary = (SELECT \\n                    MAX(Salary) \\n               FROM \\n                    Employee\\n               WHERE\\n                    DepartmentId = d.Id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 348175,
                "title": "mssql-window-function",
                "content": "```\\nSELECT\\n    d.Name AS Department,\\n    Sel.Name AS Employee,\\n    Sel.Salary AS Salary\\nFROM\\n(\\n    SELECT\\n        Name,\\n        Salary,\\n        DepartmentId,\\n        DENSE_RANK() OVER (PARTITION BY DepartmentId ORDER BY Salary DESC) AS dr\\n    FROM Employee \\n) AS Sel\\nINNER JOIN Department d ON d.Id = Sel.DepartmentId\\nWHERE Sel.dr = 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    d.Name AS Department,\\n    Sel.Name AS Employee,\\n    Sel.Salary AS Salary\\nFROM\\n(\\n    SELECT\\n        Name,\\n        Salary,\\n        DepartmentId,\\n        DENSE_RANK() OVER (PARTITION BY DepartmentId ORDER BY Salary DESC) AS dr\\n    FROM Employee \\n) AS Sel\\nINNER JOIN Department d ON d.Id = Sel.DepartmentId\\nWHERE Sel.dr = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555659,
                "title": "184-department-highest-salary",
                "content": "```\\nSELECT dept.Name AS Department, Employee.Name AS Employee, Salary\\nFROM Employee\\n\\nINNER JOIN Department AS dept ON Employee.DepartmentId=dept.Id\\n\\nwhere (dept.Id, Salary) IN (SELECT DepartmentId, max(Salary)\\n                         FROM Employee GROUP BY DepartmentId);",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT dept.Name AS Department, Employee.Name AS Employee, Salary\\nFROM Employee\\n\\nINNER JOIN Department AS dept ON Employee.DepartmentId=dept.Id\\n\\nwhere (dept.Id, Salary) IN (SELECT DepartmentId, max(Salary)\\n                         FROM Employee GROUP BY DepartmentId);",
                "codeTag": "Unknown"
            },
            {
                "id": 977945,
                "title": "accepted-simple-oracle",
                "content": "oracle\\n```\\nselect d.Name as Department, e.Name as Employee, e.Salary\\nfrom Department d inner join Employee e on d.Id = e.DepartmentId\\nwhere (e.Salary, e.DepartmentId)  in (select max(Salary), DepartmentId from Employee group by DepartmentId)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect d.Name as Department, e.Name as Employee, e.Salary\\nfrom Department d inner join Employee e on d.Id = e.DepartmentId\\nwhere (e.Salary, e.DepartmentId)  in (select max(Salary), DepartmentId from Employee group by DepartmentId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878427,
                "title": "pandas-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEasy Solution you will understand once you see the code\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef department_highest_salary(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    if employee.empty or department.empty:\\n        return pd.DataFrame(columns=[\\'Department\\', \\'Employee\\', \\'Salary\\'])\\n\\n    # Merge the employee and department DataFrames on \\'departmentId\\' and \\'id\\' columns\\n    merged_df = employee.merge(department, left_on=\\'departmentId\\', right_on=\\'id\\', suffixes= (\\'_employee\\', \\'_department\\'))\\n\\n    # Find the maximum salary in each department\\n    max_salaries = merged_df.groupby(\\'departmentId\\')[\\'salary\\'].transform(\\'max\\')\\n\\n    # Filter for employees with maximum salary in each department\\n    highest_salary_df = merged_df[merged_df[\\'salary\\'] == max_salaries]\\n\\n    # Select the required columns\\n    result_df = highest_salary_df[[\\'name_department\\', \\'name_employee\\', \\'salary\\']]\\n\\n    # Rename the columns as specified\\n    result_df.columns = [\\'Department\\', \\'Employee\\', \\'Salary\\']\\n\\n    return result_df\\n\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef department_highest_salary(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    if employee.empty or department.empty:\\n        return pd.DataFrame(columns=[\\'Department\\', \\'Employee\\', \\'Salary\\'])\\n\\n    # Merge the employee and department DataFrames on \\'departmentId\\' and \\'id\\' columns\\n    merged_df = employee.merge(department, left_on=\\'departmentId\\', right_on=\\'id\\', suffixes= (\\'_employee\\', \\'_department\\'))\\n\\n    # Find the maximum salary in each department\\n    max_salaries = merged_df.groupby(\\'departmentId\\')[\\'salary\\'].transform(\\'max\\')\\n\\n    # Filter for employees with maximum salary in each department\\n    highest_salary_df = merged_df[merged_df[\\'salary\\'] == max_salaries]\\n\\n    # Select the required columns\\n    result_df = highest_salary_df[[\\'name_department\\', \\'name_employee\\', \\'salary\\']]\\n\\n    # Rename the columns as specified\\n    result_df.columns = [\\'Department\\', \\'Employee\\', \\'Salary\\']\\n\\n    return result_df\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3850664,
                "title": "best-solutions-mysql-pandas-beats-100",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT D.Name AS Department, E.Name AS Employee, E.Salary \\nFROM Employee E, Department D \\nWHERE E.DepartmentId = D.id AND (DepartmentId,Salary) in \\n  (SELECT DepartmentId,max(Salary) as max FROM Employee GROUP BY DepartmentId)\\n```\\n```\\nimport pandas as pd\\n\\ndef department_highest_salary(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    data = pd.merge(employee, department, left_on = \\'departmentId\\', right_on = \\'id\\', how = \\'left\\')\\n    df = data.groupby(\\'name_y\\').apply(lambda x: x[x.salary == x.salary.max()])\\n    df = df.rename(columns={\\'name_y\\': \\'Department\\', \\'name_x\\': \\'Employee\\'})\\n    df = df.drop(columns=[\\'id_x\\', \\'id_y\\']).reset_index()\\n    return df[[\\'Department\\',\\'Employee\\',\\'salary\\']]\\n```",
                "solutionTags": [
                    "MySQL",
                    "Pandas"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT D.Name AS Department, E.Name AS Employee, E.Salary \\nFROM Employee E, Department D \\nWHERE E.DepartmentId = D.id AND (DepartmentId,Salary) in \\n  (SELECT DepartmentId,max(Salary) as max FROM Employee GROUP BY DepartmentId)\\n```\n```\\nimport pandas as pd\\n\\ndef department_highest_salary(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    data = pd.merge(employee, department, left_on = \\'departmentId\\', right_on = \\'id\\', how = \\'left\\')\\n    df = data.groupby(\\'name_y\\').apply(lambda x: x[x.salary == x.salary.max()])\\n    df = df.rename(columns={\\'name_y\\': \\'Department\\', \\'name_x\\': \\'Employee\\'})\\n    df = df.drop(columns=[\\'id_x\\', \\'id_y\\']).reset_index()\\n    return df[[\\'Department\\',\\'Employee\\',\\'salary\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3759714,
                "title": "easy-mysql-solution",
                "content": "\\n\\n# Code\\n```\\nSELECT D.Name AS Department ,E.Name AS Employee ,E.Salary \\nfrom \\n\\tEmployee E,\\n\\tDepartment D \\nWHERE E.DepartmentId = D.id \\n  AND (DepartmentId,Salary) in \\n  (SELECT DepartmentId,max(Salary) as max FROM Employee GROUP BY DepartmentId)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT D.Name AS Department ,E.Name AS Employee ,E.Salary \\nfrom \\n\\tEmployee E,\\n\\tDepartment D \\nWHERE E.DepartmentId = D.id \\n  AND (DepartmentId,Salary) in \\n  (SELECT DepartmentId,max(Salary) as max FROM Employee GROUP BY DepartmentId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3710755,
                "title": "mysql-solution-for-department-highest-salary-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to find employees who have the highest salary in each department. To achieve this, we need to compare the salary of each employee within their respective department and select the ones with the maximum salary.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to join the Employee and Department tables based on the departmentId foreign key. By performing this join, we can access the department name for each employee. Then, we use a subquery to calculate the maximum salary for each department. Finally, we filter the results by selecting only the employees whose department and salary match the maximum values.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution depends on the size of the Employee table. Let\\'s denote m as the number of rows in the Employee table. The subquery that calculates the maximum salary for each department has a complexity of O(m). The join operation and filtering have a complexity of O(m) as well. Therefore, the overall time complexity is O(m).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is determined by the number of rows returned in the result table. If there are k departments and each department has one employee with the highest salary, the result will have k rows. Therefore, the space complexity is O(k).\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT d.name AS Department, e.name AS Employee, e.Salary\\nFROM Employee e\\nINNER JOIN Department d ON e.departmentId = d.id\\nWHERE (e.departmentId, e.salary) IN (\\n    SELECT departmentId, MAX(salary)\\n    FROM Employee\\n    GROUP BY departmentId\\n);\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT d.name AS Department, e.name AS Employee, e.Salary\\nFROM Employee e\\nINNER JOIN Department d ON e.departmentId = d.id\\nWHERE (e.departmentId, e.salary) IN (\\n    SELECT departmentId, MAX(salary)\\n    FROM Employee\\n    GROUP BY departmentId\\n);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3276114,
                "title": "simple-and-easy-to-understand-solution-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT dept.name AS Department, emp.name AS Employee, emp.salary AS Salary\\nFROM Department dept, Employee emp\\nWHERE emp.departmentId = dept.id\\nAND emp.salary = (SELECT MAX(Salary) FROM Employee emp WHERE emp.departmentId = dept.id)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT dept.name AS Department, emp.name AS Employee, emp.salary AS Salary\\nFROM Department dept, Employee emp\\nWHERE emp.departmentId = dept.id\\nAND emp.salary = (SELECT MAX(Salary) FROM Employee emp WHERE emp.departmentId = dept.id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2815559,
                "title": "sql-multiple-approaches-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/department-highest-salary.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\nSELECT d.name AS Department, e.Employee, e.Salary\\nFROM Department d\\nLEFT JOIN (\\n        SELECT \\n            departmentId, \\n            salary AS Salary,\\n            name AS Employee,\\n            DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) AS \\'salary_rank\\'\\n        FROM Employee) e\\nON d.id = e.departmentId\\nWHERE salary_rank = 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT d.name AS Department, e.Employee, e.Salary\\nFROM Department d\\nLEFT JOIN (\\n        SELECT \\n            departmentId, \\n            salary AS Salary,\\n            name AS Employee,\\n            DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) AS \\'salary_rank\\'\\n        FROM Employee) e\\nON d.id = e.departmentId\\nWHERE salary_rank = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2813583,
                "title": "93-faster",
                "content": "![image](https://assets.leetcode.com/users/images/5a4bea54-9e8e-4929-9709-77afb82be822_1668422497.2098377.png)\\n\\n\\n```\\nSELECT Department, Employee, Salary \\nFROM ( \\n        SELECT *, rank() over(PARTITION BY Department ORDER BY Salary DESC) AS Highest_Salaries \\n        FROM (\\n                SELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\n                FROM Department d\\n                INNER JOIN Employee e\\n                ON d.id = e.departmentId\\n            ) AS x         \\n    ) AS y\\nWHERE Highest_Salaries < 2;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Department, Employee, Salary \\nFROM ( \\n        SELECT *, rank() over(PARTITION BY Department ORDER BY Salary DESC) AS Highest_Salaries \\n        FROM (\\n                SELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\n                FROM Department d\\n                INNER JOIN Employee e\\n                ON d.id = e.departmentId\\n            ) AS x         \\n    ) AS y\\nWHERE Highest_Salaries < 2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2704795,
                "title": "mysql-subquery-easy-to-understand",
                "content": "```\\nselect d.name as department,e.name as employee,salary\\nfrom department d\\njoin employee e\\non d.id = e.departmentid\\nwhere (departmentid,salary ) in\\n(select departmentid,max(salary) from employee group by departmentid);\\n```\\nBreaking the code\\n\\n1 inside the subquerry, we can get the max salary for each department using the \\n```\\n(select departmentid,max(salary) from employee group by departmentid)\\n```\\n\\n2 select the multiple condtion where clause to select the max salary by department using \\n```\\nwhere (departmentid,salary ) in\\n(select departmentid,max(salary) from employee group by departmentid)\\n```\\n\\n3  Rest of the code is to join the tables and select the required column\\n\\nupvote if helps, ping if need help.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect d.name as department,e.name as employee,salary\\nfrom department d\\njoin employee e\\non d.id = e.departmentid\\nwhere (departmentid,salary ) in\\n(select departmentid,max(salary) from employee group by departmentid);\\n```\n```\\n(select departmentid,max(salary) from employee group by departmentid)\\n```\n```\\nwhere (departmentid,salary ) in\\n(select departmentid,max(salary) from employee group by departmentid)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976460,
                "title": "inner-join-where-group-by-70-20-time",
                "content": "```\\n# Write your MySQL query statement below\\nselect Department.name as Department, Employee.name as Employee, Employee.salary as salary\\nfrom Employee\\ninner join Department on\\nemployee.departmentId = department.id\\nwhere \\n(employee.departmentId, salary) IN (\\n    select DepartmentId, max(salary)\\n    from Employee\\n    group by departmentId\\n);\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect Department.name as Department, Employee.name as Employee, Employee.salary as salary\\nfrom Employee\\ninner join Department on\\nemployee.departmentId = department.id\\nwhere \\n(employee.departmentId, salary) IN (\\n    select DepartmentId, max(salary)\\n    from Employee\\n    group by departmentId\\n);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822982,
                "title": "correlated-subqueries",
                "content": "SELECT d.name AS Department, e.name AS Employee, Salary\\nFROM Employee e\\nJOIN department d ON e.departmentId = d.id\\nWHERE salary = (SELECT MAX(salary) FROM employee WHERE departmentId = e.departmentId )\\n\\nI learned that from Mosh",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT d.name AS Department, e.name AS Employee, Salary\\nFROM Employee e\\nJOIN department d ON e.departmentId = d.id\\nWHERE salary = (SELECT MAX(salary) FROM employee WHERE departmentId = e.departmentId )\\n\\nI learned that from Mosh",
                "codeTag": "Unknown"
            },
            {
                "id": 1522483,
                "title": "solution-with-explanation-using-rank-in-mysql",
                "content": "This query can  be written using INNER JOIN and/or Sub-query. This solution shows a way of writing it using `RANK()` function.\\n\\n**`Step 1`**\\nWe need to rank the employees based on their salaries for each department\\n\\n```\\nSELECT\\n\\td.Name AS Department,\\n\\te.Name as Employee,\\n\\te.Salary,\\n\\t/* Ranking employee based on salary for each department(d.Name)*/\\n\\tRANK() OVER (PARTITION BY d.Name ORDER BY e.Salary DESC) AS emp_rank #\\nFROM employee e\\nJOIN department d ON d.Id = e.DepartmentId\\n```\\n\\n**`Step 2`** \\nThe ranking above is done in descending order of salary and partitioned by department so the highest salary for each department should always have `rank = 1`. All we need is to just select the ones whose `rank = 1`.\\n\\nWe can write a CTE(Common Table Expression) for the first step and simply select the necessary columns in second step from the CTE table. \\n\\nThe full query should look like this:\\n```\\nWITH employee_rank AS(\\n    SELECT\\n        d.Name AS Department,\\n        e.Name as Employee,\\n        e.Salary,\\n        RANK() OVER (PARTITION BY d.Name ORDER BY e.Salary DESC) AS emp_rank\\n    FROM employee e\\n    JOIN department d ON d.Id = e.DepartmentId\\n)\\n\\nSELECT\\n    Department,\\n    Employee,\\n    Salary\\nFROM employee_rank\\nWHERE emp_rank = 1;\\n```\\n\\n\\n**N. B.:** We can also use `DENSE_RANK()` instead of `RANK()` here which will give us the exact same result for this problem as we are only considering the highest salary here.\\n\\nThis query gives the following runtime and memory usage after successful submission\\n```\\nRuntime: 505 ms, faster than 88.21% of MySQL online submissions for Department Highest Salary.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Department Highest Salary.\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n\\td.Name AS Department,\\n\\te.Name as Employee,\\n\\te.Salary,\\n\\t/* Ranking employee based on salary for each department(d.Name)*/\\n\\tRANK() OVER (PARTITION BY d.Name ORDER BY e.Salary DESC) AS emp_rank #\\nFROM employee e\\nJOIN department d ON d.Id = e.DepartmentId\\n```\n```\\nWITH employee_rank AS(\\n    SELECT\\n        d.Name AS Department,\\n        e.Name as Employee,\\n        e.Salary,\\n        RANK() OVER (PARTITION BY d.Name ORDER BY e.Salary DESC) AS emp_rank\\n    FROM employee e\\n    JOIN department d ON d.Id = e.DepartmentId\\n)\\n\\nSELECT\\n    Department,\\n    Employee,\\n    Salary\\nFROM employee_rank\\nWHERE emp_rank = 1;\\n```\n```\\nRuntime: 505 ms, faster than 88.21% of MySQL online submissions for Department Highest Salary.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Department Highest Salary.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1476469,
                "title": "intuitive-solution",
                "content": "Approach/Steps:\\n1. Calculate department wise highest salaries\\n\\t```\\n\\tselect DepartmentId, max(Salary) from Employee group by DepartmentId\\n\\t```\\n2. Fetch all Employees which are getting highest salary in the department\\n\\t```\\n\\tselect * from Employee\\n\\twhere (DepartmentId, Salary) in \\n\\t(select DepartmentId, max(Salary) from Employee group by DepartmentId)\\n\\t```\\n3. Join the Employee and Department tables to get the department name in the result (Final Solution)\\n\\t```\\n\\tselect d.Name as Department, e.Name as Employee, Salary from Employee e join Department d on\\n\\te.DepartmentId = d.Id\\n\\twhere (e.DepartmentId, e.Salary) in \\n\\t(select DepartmentId, max(Salary) from Employee group by DepartmentId)\\n\\t```\\n\\nRuntime: 506 ms, faster than 87.68% submissions",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\tselect DepartmentId, max(Salary) from Employee group by DepartmentId\\n\\t```\n```\\n\\tselect * from Employee\\n\\twhere (DepartmentId, Salary) in \\n\\t(select DepartmentId, max(Salary) from Employee group by DepartmentId)\\n\\t```\n```\\n\\tselect d.Name as Department, e.Name as Employee, Salary from Employee e join Department d on\\n\\te.DepartmentId = d.Id\\n\\twhere (e.DepartmentId, e.Salary) in \\n\\t(select DepartmentId, max(Salary) from Employee group by DepartmentId)\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1468065,
                "title": "using-subquery",
                "content": "```\\nselect max(e2.salary) from employee e2 where e2.departmentid = e.departmentid\\n```\\nthis query will give maximum salary for one departmentId\\nand use this result to our main query so the result will be like below:\\n\\n```\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d , Employee e\\nwhere e.departmentId = d.id\\nand e.salary = (\\n    select max(e2.salary) from employee e2 where e2.departmentid = e.departmentid\\n);\\n```\\nHit like if you find this helpful!\\n",
                "solutionTags": [],
                "code": "```\\nselect max(e2.salary) from employee e2 where e2.departmentid = e.departmentid\\n```\n```\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d , Employee e\\nwhere e.departmentId = d.id\\nand e.salary = (\\n    select max(e2.salary) from employee e2 where e2.departmentid = e.departmentid\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1357856,
                "title": "using-inner-join-easy-to-understand",
                "content": "```\\nSELECT Department.Name AS Department, Employee.Name AS Employee, Employee.Salary AS Salary\\nFROM Employee INNER JOIN Department\\nON Employee.DepartmentId =Department.Id\\nWHERE Employee.Salary=\\n    (\\n        SELECT MAX(Salary) FROM Employee  \\n        WHERE Employee.DepartmentId=Department.Id\\n    );\\n\\t```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Department.Name AS Department, Employee.Name AS Employee, Employee.Salary AS Salary\\nFROM Employee INNER JOIN Department\\nON Employee.DepartmentId =Department.Id\\nWHERE Employee.Salary=\\n    (\\n        SELECT MAX(Salary) FROM Employee  \\n        WHERE Employee.DepartmentId=Department.Id\\n    );\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1290764,
                "title": "mysql-simple-window-function",
                "content": "```\\nselect b.Name as Department, a.Name as Employee, Salary\\nfrom \\n# rank Salary in department\\n(select *, dense_rank () over (partition by DepartmentId order by Salary desc) as salaryRank\\nfrom Employee) a \\njoin Department b \\non a.DepartmentId = b.Id and a.salaryRank = 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect b.Name as Department, a.Name as Employee, Salary\\nfrom \\n# rank Salary in department\\n(select *, dense_rank () over (partition by DepartmentId order by Salary desc) as salaryRank\\nfrom Employee) a \\njoin Department b \\non a.DepartmentId = b.Id and a.salaryRank = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261602,
                "title": "simple-solution-using-where-and-and",
                "content": "```\\nSELECT D.NAME AS Department, E.NAME AS Employee, E.SALARY AS Salary\\nFROM EMPLOYEE AS E, DEPARTMENT AS D\\nWHERE D.ID = E.DEPARTMENTID\\nAND E.SALARY = \\n    (SELECT MAX(SALARY) \\n     FROM EMPLOYEE AS E2 \\n     WHERE E2.DEPARTMENTID = D.ID)\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nSELECT D.NAME AS Department, E.NAME AS Employee, E.SALARY AS Salary\\nFROM EMPLOYEE AS E, DEPARTMENT AS D\\nWHERE D.ID = E.DEPARTMENTID\\nAND E.SALARY = \\n    (SELECT MAX(SALARY) \\n     FROM EMPLOYEE AS E2 \\n     WHERE E2.DEPARTMENTID = D.ID)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 875946,
                "title": "use-dense-rank-and-inner-join",
                "content": "```\\nSELECT Department, Employee, Salary\\nFROM (SELECT D.Name AS Department, E.Name AS Employee, E.Salary AS Salary , DENSE_RANK() OVER(PARTITION BY E.DepartmentId ORDER BY E.Salary DESC) RN\\n     FROM Employee E\\n     INNER JOIN Department D\\n     ON E.DepartmentId = D.Id)\\nWHERE RN=1\\n```\\n\\u4E00\\u5F00\\u59CB\\u60F3\\u7528group by\\u6765\\u7740\\uFF0C\\u53D1\\u73B0\\u5206\\u7EC4\\u7684\\u65F6\\u5019\\u8981\\u4E48\\u8003\\u8651\\u5B50\\u67E5\\u8BE2\\u8981\\u4E48\\u4E0D\\u597D\\u7EC4\\u5185\\u6392\\u5E8F\\n\\u7528\\u4E86\\u5206\\u6790\\u51FD\\u6570\\u6765\\u5B9E\\u73B0\\u5206\\u7EC4\\u6392\\u5E8F\\u548C\\u83B7\\u53D6\\u5206\\u7EC4\\u6392\\u540D\\u987A\\u5E8F\\n\\u4E00\\u5F00\\u59CB\\u7528\\u4E86\\u5DE6\\u8FDE\\u63A5\\uFF0Csubmission\\u7684\\u65F6\\u5019\\u53D1\\u73B0\\u6709\\u53EF\\u80FD\\u5B58\\u5728\\u7A7A\\u503C\\u7684\\u60C5\\u51B5\\uFF0C\\u6539\\u6210\\u4E86\\u5185\\u8FDE\\u63A5\\uFF0C\\u6EE4\\u6389\\u5DE6\\u8868\\u53EF\\u80FD\\u5339\\u914D\\u4E0D\\u5230departmentid\\u7684\\u60C5\\u51B5\\n\\u6700\\u540E\\u8FD8\\u662F\\u7528\\u4E86\\u5B50\\u67E5\\u8BE2\\u2026\\u2026",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT Department, Employee, Salary\\nFROM (SELECT D.Name AS Department, E.Name AS Employee, E.Salary AS Salary , DENSE_RANK() OVER(PARTITION BY E.DepartmentId ORDER BY E.Salary DESC) RN\\n     FROM Employee E\\n     INNER JOIN Department D\\n     ON E.DepartmentId = D.Id)\\nWHERE RN=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 642894,
                "title": "mysql-using-inner-join",
                "content": "```\\nselect d.Name as Department,\\ne.Name as Employee,\\ne.Salary\\nfrom Employee e inner join Department d\\non e.DepartmentId = d.Id\\nwhere e.Salary = (select max(salary) from Employee where departmentId = d.Id);\\n```",
                "solutionTags": [],
                "code": "```\\nselect d.Name as Department,\\ne.Name as Employee,\\ne.Salary\\nfrom Employee e inner join Department d\\non e.DepartmentId = d.Id\\nwhere e.Salary = (select max(salary) from Employee where departmentId = d.Id);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201053,
                "title": "248ms-ans-beats-99-and-illustration",
                "content": "The most tricky part is to get the actual name of each department. Otherwise it is a simple question\\nFirst we find the max price from the employee table of each departmentID\\nSecond, join the filtered employee table and department table and get the name of department\\n```\\nselect Department.Name as Department, a.Name as Employee,  a.Salary as Salary\\nfrom Department\\njoin (select Name, Salary, DepartmentId from Employee \\n      where (DepartmentId, Salary) in (\\n          select DepartmentId, max(Salary)   # find the max price  of each departmentID\\n          from Employee\\n          group by DepartmentId)) as a \\n     on Department.Id = a.DepartmentId\\n```",
                "solutionTags": [],
                "code": "```\\nselect Department.Name as Department, a.Name as Employee,  a.Salary as Salary\\nfrom Department\\njoin (select Name, Salary, DepartmentId from Employee \\n      where (DepartmentId, Salary) in (\\n          select DepartmentId, max(Salary)   # find the max price  of each departmentID\\n          from Employee\\n          group by DepartmentId)) as a \\n     on Department.Id = a.DepartmentId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53616,
                "title": "what-s-wrong-with-my-code",
                "content": "select Department.Name Department ,Employee.Name Employee, max(Salary) Salary\\nfrom  Employee join Department on Employee.DepartmentId = Department.ID \\ngroup by Department.ID\\norder by  Department.ID\\n\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 70000, 1], [2, \"Henry\", 80000, 2], [3, \"Sam\", 60000, 2], [4, \"Max\", 90000, 1]], \"Department\": [[1, \"IT\"], [2, \"Sales\"]]}}\\n\\nmy output: \\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Joe\", 90000], [\"Sales\", \"Henry\", 80000]]}\\n\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"Sales\", \"Henry\", 80000], [\"IT\", \"Max\", 90000]]}",
                "solutionTags": [],
                "code": "select Department.Name Department ,Employee.Name Employee, max(Salary) Salary\\nfrom  Employee join Department on Employee.DepartmentId = Department.ID \\ngroup by Department.ID\\norder by  Department.ID\\n\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 70000, 1], [2, \"Henry\", 80000, 2], [3, \"Sam\", 60000, 2], [4, \"Max\", 90000, 1]], \"Department\": [[1, \"IT\"], [2, \"Sales\"]]}}\\n\\nmy output: \\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Joe\", 90000], [\"Sales\", \"Henry\", 80000]]}\\n\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"Sales\", \"Henry\", 80000], [\"IT\", \"Max\", 90000]]}",
                "codeTag": "Unknown"
            },
            {
                "id": 53682,
                "title": "accepted-solution-without-using-max-function",
                "content": "    select b.Name Department, a.Name Employee, a.Salary from\\n    (\\n        select a.Name, a.Salary, a.DepartmentId \\n        from Employee a left outer join Employee b\\n        on a.DepartmentId = b.DepartmentId \\n        and a.Salary < b.Salary\\n        where b.Id is null\\n    ) a join Department b\\n    on a.DepartmentId = b.Id;",
                "solutionTags": [],
                "code": "    select b.Name Department, a.Name Employee, a.Salary from\\n    (\\n        select a.Name, a.Salary, a.DepartmentId \\n        from Employee a left outer join Employee b\\n        on a.DepartmentId = b.DepartmentId \\n        and a.Salary < b.Salary\\n        where b.Id is null\\n    ) a join Department b\\n    on a.DepartmentId = b.Id;",
                "codeTag": "Unknown"
            },
            {
                "id": 3977256,
                "title": "184-department-highest-salary",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT DEPT.name AS Department, EMP.name AS Employee, EMP.salary AS Salary \\nFROM Department DEPT, Employee EMP WHERE\\nEMP.departmentId = DEPT.id AND (EMP.departmentId, salary) IN \\n(SELECT departmentId, MAX(salary) FROM Employee GROUP BY departmentId)\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DEPT.name AS Department, EMP.name AS Employee, EMP.salary AS Salary \\nFROM Department DEPT, Employee EMP WHERE\\nEMP.departmentId = DEPT.id AND (EMP.departmentId, salary) IN \\n(SELECT departmentId, MAX(salary) FROM Employee GROUP BY departmentId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872647,
                "title": "mysql-eassy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT Department.name AS Department ,Employee.name AS Employee, Employee.salary FROM Department  JOIN Employee  ON Employee.departmentId=Department.id WHERE(departmentId, salary) IN (SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId) ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Department.name AS Department ,Employee.name AS Employee, Employee.salary FROM Department  JOIN Employee  ON Employee.departmentId=Department.id WHERE(departmentId, salary) IN (SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId) ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850809,
                "title": "clear-solution",
                "content": "-- We can write an inner query to get max salary department wise. \\n-- After that we can use that result and join it with employee and department\\n-- to get department name, employee name and max salary. \\n\\n/* Write your T-SQL query statement below */\\n```\\nselect d.name Department, emp.name Employee, temp.salary Salary from \\n(select dept.id as deptid, max(emp.salary) as salary\\nfrom employee emp inner join department dept\\non emp.departmentId = dept.id\\ngroup by dept.id) temp\\ninner join employee emp on emp.departmentId = temp.deptid\\nand temp.salary = emp.salary\\ninner join Department d on d.id = temp.deptid\\n```\\n\\n-- --Other possible solutions\\n```\\n-- SELECT D.Name,A.Name,A.Salary \\n-- FROM \\n-- \\tEmployee A,\\n-- \\tDepartment D   \\n-- WHERE A.DepartmentId = D.Id \\n--   AND NOT EXISTS \\n--   (SELECT 1 FROM Employee B WHERE B.Salary > A.Salary AND A.DepartmentId = B.DepartmentId) \\n```\\n-- -- \\n```\\n-- SELECT D.Name AS Department ,E.Name AS Employee ,E.Salary \\n-- from \\n-- \\tEmployee E,\\n-- \\tDepartment D \\n-- WHERE E.DepartmentId = D.id \\n--   AND (DepartmentId,Salary) in \\n--   (SELECT DepartmentId,max(Salary) as max FROM Employee GROUP BY DepartmentId)\\n ```",
                "solutionTags": [],
                "code": "```\\nselect d.name Department, emp.name Employee, temp.salary Salary from \\n(select dept.id as deptid, max(emp.salary) as salary\\nfrom employee emp inner join department dept\\non emp.departmentId = dept.id\\ngroup by dept.id) temp\\ninner join employee emp on emp.departmentId = temp.deptid\\nand temp.salary = emp.salary\\ninner join Department d on d.id = temp.deptid\\n```\n```\\n-- SELECT D.Name,A.Name,A.Salary \\n-- FROM \\n-- \\tEmployee A,\\n-- \\tDepartment D   \\n-- WHERE A.DepartmentId = D.Id \\n--   AND NOT EXISTS \\n--   (SELECT 1 FROM Employee B WHERE B.Salary > A.Salary AND A.DepartmentId = B.DepartmentId) \\n```\n```\\n-- SELECT D.Name AS Department ,E.Name AS Employee ,E.Salary \\n-- from \\n-- \\tEmployee E,\\n-- \\tDepartment D \\n-- WHERE E.DepartmentId = D.id \\n--   AND (DepartmentId,Salary) in \\n--   (SELECT DepartmentId,max(Salary) as max FROM Employee GROUP BY DepartmentId)\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545420,
                "title": "solution-with-window-function-sql-server",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\nWITH CTE AS (SELECT\\r\\n    *,\\r\\n    DENSE_RANK() OVER(PARTITION BY DepartmentID ORDER BY salary DESC) RANKED\\r\\nFROM\\r\\n    Employee\\r\\n)\\r\\nSELECT\\r\\n    d.name Department ,\\r\\n    c.name Employee,\\r\\n    c.salary\\r\\nFROM\\r\\n    CTE c\\r\\nINNER JOIN\\r\\n    Department d on c.departmentid = d.id\\r\\nWHERE\\r\\n    EXISTS (\\r\\n\\r\\n        SELECT 1\\r\\n        FROM\\r\\n            CTE C1\\r\\n        WHERE\\r\\n            c.id = c1.id\\r\\n        AND\\r\\n            c.departmentid = c1.departmentid\\r\\n        AND\\r\\n            C1.RANKED = 1\\r\\n    )\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\nWITH CTE AS (SELECT\\r\\n    *,\\r\\n    DENSE_RANK() OVER(PARTITION BY DepartmentID ORDER BY salary DESC) RANKED\\r\\nFROM\\r\\n    Employee\\r\\n)\\r\\nSELECT\\r\\n    d.name Department ,\\r\\n    c.name Employee,\\r\\n    c.salary\\r\\nFROM\\r\\n    CTE c\\r\\nINNER JOIN\\r\\n    Department d on c.departmentid = d.id\\r\\nWHERE\\r\\n    EXISTS (\\r\\n\\r\\n        SELECT 1\\r\\n        FROM\\r\\n            CTE C1\\r\\n        WHERE\\r\\n            c.id = c1.id\\r\\n        AND\\r\\n            c.departmentid = c1.departmentid\\r\\n        AND\\r\\n            C1.RANKED = 1\\r\\n    )\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531504,
                "title": "solved-via-cte",
                "content": "# Code\\n```\\n;WITH emp as (\\n  select Max(salary) as maxSalary, departmentId from Employee\\n  group by\\n  departmentId\\n)\\n\\nselect e.name as Employee, e.salary as Salary, d.name as Department from Employee e \\ninner join Department d\\non d.id = e.departmentId\\ninner join emp\\non emp.maxSalary = e.salary and emp.departmentId = d.id\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n;WITH emp as (\\n  select Max(salary) as maxSalary, departmentId from Employee\\n  group by\\n  departmentId\\n)\\n\\nselect e.name as Employee, e.salary as Salary, d.name as Department from Employee e \\ninner join Department d\\non d.id = e.departmentId\\ninner join emp\\non emp.maxSalary = e.salary and emp.departmentId = d.id\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3430702,
                "title": "mssql-solution-with-dense-rank",
                "content": "\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT\\n    Department, Employee, Salary\\nFROM\\n(SELECT\\n    D.NAME AS Department,\\n    E.NAME AS Employee,\\n    E.SALARY AS Salary,\\n    DENSE_RANK() OVER(PARTITION BY D.NAME ORDER BY E.SALARY DESC) AS rank\\nFROM \\n    EMPLOYEE E\\nJOIN \\n    DEPARTMENT D ON D.ID = E.DEPARTMENTID) AS R\\nWHERE R.rank = 1;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT\\n    Department, Employee, Salary\\nFROM\\n(SELECT\\n    D.NAME AS Department,\\n    E.NAME AS Employee,\\n    E.SALARY AS Salary,\\n    DENSE_RANK() OVER(PARTITION BY D.NAME ORDER BY E.SALARY DESC) AS rank\\nFROM \\n    EMPLOYEE E\\nJOIN \\n    DEPARTMENT D ON D.ID = E.DEPARTMENTID) AS R\\nWHERE R.rank = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3429187,
                "title": "easy-to-understand-step-by-step-explanation-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nYou can solve this problem by using a combination of `GROUP BY` and `MAX(salary)`. The tricky part is that more than one employee may have the maximum department salary. This means that we have to split the search process into several steps.\\n\\n1. Find the maximum salary for each department.\\n2. Find the employees whose salary and department match the results from step 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThis is your starting point. You can see that the highest salary for the IT department is 90000 and that Max and Jim both have this salary.\\n\\n```\\nEmployee table:\\n+----+-------+--------+--------------+\\n| id | name  | salary | departmentId |\\n+----+-------+--------+--------------+\\n| 1  | Joe   | 70000  | 1            |\\n| 2  | Jim   | 90000  | 1            | <-- highest in IT\\n| 3  | Henry | 80000  | 2            | <-- highest in Sales\\n| 4  | Sam   | 60000  | 2            |\\n| 5  | Max   | 90000  | 1            | <-- highest in IT\\n+----+-------+--------+--------------+\\n\\nDepartment table:\\n+----+-------+\\n| id | name  |\\n+----+-------+\\n| 1  | IT    |\\n| 2  | Sales |\\n+----+-------+\\n```\\n\\n### Step 1 - Find the maximum salary for each department\\n\\nYou can use `GROUP BY` in combination with `MAX(salary)` to find the highest salary per department.\\n\\n```\\n| departmentId | maxSalary |\\n| ------------ | --------- |\\n| 1            | 90000     |\\n| 2            | 80000     |\\n```\\n\\n### Step 2 - Find the employees whose salary and department match the results from step 1\\n\\nJoin the Employee and Department tables with the MaxSalary table on the shared departmentId column, then filter out all rows where the employee\\'s salary does not equal the maximum salary value. This is similar to asking for a list of employees who have the maximum salary for their department.\\n\\n(Rename the columns to get the correct answer.)\\n\\n```\\n| departmentId | maxSalary | Department.name | Employee.name | Employee.salary |\\n| ------------ | --------- | --------------- | ------------- | --------------- |\\n| 1            | 90000     | IT              | Jim           | 90000           |\\n| 2            | 80000     | Sales           | Henry         | 80000           |\\n| 1            | 90000     | IT              | Max           | 90000           |\\n```\\n\\n# Code\\n```\\n--\\n-- Step 1 - Find the maximum salary for each department\\n--\\nWITH\\n  MaxSalary AS (\\n  SELECT\\n    Department.id departmentId,\\n    MAX(salary) maxSalary\\n  FROM\\n    Employee\\n  INNER JOIN\\n    Department\\n  ON\\n    Employee.departmentId = Department.id\\n  GROUP BY\\n    Department.id\\n)\\n--\\n-- Step 2 - Find the employees whose salary and department match the results from step 1\\n--\\nSELECT\\n  Department.name Department,\\n  Employee.name Employee,\\n  Employee.salary Salary\\nFROM\\n  Employee\\nINNER JOIN\\n  MaxSalary\\nON\\n  Employee.departmentId = MaxSalary.departmentId\\nINNER JOIN\\n  Department\\nON\\n  Employee.departmentId = Department.id\\nWHERE\\n  Employee.salary = maxSalary\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nEmployee table:\\n+----+-------+--------+--------------+\\n| id | name  | salary | departmentId |\\n+----+-------+--------+--------------+\\n| 1  | Joe   | 70000  | 1            |\\n| 2  | Jim   | 90000  | 1            | <-- highest in IT\\n| 3  | Henry | 80000  | 2            | <-- highest in Sales\\n| 4  | Sam   | 60000  | 2            |\\n| 5  | Max   | 90000  | 1            | <-- highest in IT\\n+----+-------+--------+--------------+\\n\\nDepartment table:\\n+----+-------+\\n| id | name  |\\n+----+-------+\\n| 1  | IT    |\\n| 2  | Sales |\\n+----+-------+\\n```\n```\\n| departmentId | maxSalary |\\n| ------------ | --------- |\\n| 1            | 90000     |\\n| 2            | 80000     |\\n```\n```\\n| departmentId | maxSalary | Department.name | Employee.name | Employee.salary |\\n| ------------ | --------- | --------------- | ------------- | --------------- |\\n| 1            | 90000     | IT              | Jim           | 90000           |\\n| 2            | 80000     | Sales           | Henry         | 80000           |\\n| 1            | 90000     | IT              | Max           | 90000           |\\n```\n```\\n--\\n-- Step 1 - Find the maximum salary for each department\\n--\\nWITH\\n  MaxSalary AS (\\n  SELECT\\n    Department.id departmentId,\\n    MAX(salary) maxSalary\\n  FROM\\n    Employee\\n  INNER JOIN\\n    Department\\n  ON\\n    Employee.departmentId = Department.id\\n  GROUP BY\\n    Department.id\\n)\\n--\\n-- Step 2 - Find the employees whose salary and department match the results from step 1\\n--\\nSELECT\\n  Department.name Department,\\n  Employee.name Employee,\\n  Employee.salary Salary\\nFROM\\n  Employee\\nINNER JOIN\\n  MaxSalary\\nON\\n  Employee.departmentId = MaxSalary.departmentId\\nINNER JOIN\\n  Department\\nON\\n  Employee.departmentId = Department.id\\nWHERE\\n  Employee.salary = maxSalary\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2908445,
                "title": "using-subquery-group-by-max",
                "content": "# Query\\n```\\nSELECT d.name AS \\'Department\\', e.name AS \\'Employee\\', salary AS \\'Salary\\'\\nFROM Employee e JOIN Department d\\nON e.departmentId = d.id\\nWHERE (e.departmentId, e.salary) IN\\n(SELECT departmentId, MAX(salary)\\nFROM Employee\\nGROUP BY departmentId);\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT d.name AS \\'Department\\', e.name AS \\'Employee\\', salary AS \\'Salary\\'\\nFROM Employee e JOIN Department d\\nON e.departmentId = d.id\\nWHERE (e.departmentId, e.salary) IN\\n(SELECT departmentId, MAX(salary)\\nFROM Employee\\nGROUP BY departmentId);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2611911,
                "title": "just-join-and-dense-rank",
                "content": "select Department, Employee, salary from(\\nselect d.name as Department,e.name as Employee, e.salary as salary, \\ndense_rank() over(partition by e.departmentId order by e.salary desc) as salaryRank\\nfrom employee e, department d\\nwhere e.departmentId=d.id)\\nwhere salaryRank=1",
                "solutionTags": [],
                "code": "select Department, Employee, salary from(\\nselect d.name as Department,e.name as Employee, e.salary as salary, \\ndense_rank() over(partition by e.departmentId order by e.salary desc) as salaryRank\\nfrom employee e, department d\\nwhere e.departmentId=d.id)\\nwhere salaryRank=1",
                "codeTag": "Unknown"
            },
            {
                "id": 2601962,
                "title": "simple-clean-with-rank-and-partition-by",
                "content": "```\\nwith T as (\\nselect *, \\n    rank() over(partition by departmentId order by salary desc) as rnk\\nfrom Employee)\\n\\nselect d.name as Department, t.name as Employee, salary as Salary\\nfrom T t\\nleft join Department d\\non t.departmentId = d.id\\nwhere t.rnk = 1\\n```",
                "solutionTags": [],
                "code": "```\\nwith T as (\\nselect *, \\n    rank() over(partition by departmentId order by salary desc) as rnk\\nfrom Employee)\\n\\nselect d.name as Department, t.name as Employee, salary as Salary\\nfrom T t\\nleft join Department d\\non t.departmentId = d.id\\nwhere t.rnk = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2601104,
                "title": "mysql-very-easy-solutiojn-62",
                "content": "```\\nselect dp.name as Department, em.name as Employee, em.salary as Salary \\n\\tfrom employee em \\n\\t\\tinner join department dp \\n\\t\\t\\ton dp.id = em.departmentid \\n\\t\\t\\t\\twhere (em.departmentid, em.salary) \\n\\t\\t\\t\\t\\tin \\n\\t\\t\\t\\t\\t\\t(select departmentid, max(salary) from employee group by departmentid);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect dp.name as Department, em.name as Employee, em.salary as Salary \\n\\tfrom employee em \\n\\t\\tinner join department dp \\n\\t\\t\\ton dp.id = em.departmentid \\n\\t\\t\\t\\twhere (em.departmentid, em.salary) \\n\\t\\t\\t\\t\\tin \\n\\t\\t\\t\\t\\t\\t(select departmentid, max(salary) from employee group by departmentid);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2504412,
                "title": "2-solutions-for-t-sql",
                "content": "Solution 1:\\n```\\nselect  d.name as Department, \\n        e.name as Employee, \\n        salary as Salary\\nfrom Employee e\\njoin Department d on e.departmentId = d.id\\njoin (select max(salary) as max_sal, departmentId\\n      from Employee\\n      group by departmentId) t\\non e.salary = t.max_sal\\nand e.departmentId = t.departmentId\\n```\\nSolution 2:\\n```\\nselect Department, Employee, Salary\\nfrom (\\n    select  d.name as Department,\\n            e.name as Employee,\\n            salary as Salary,\\n            dense_rank() over(partition by departmentId order by salary desc) as rnk\\n    from Employee e\\n    join Department d on e.departmentId = d.id\\n    ) t\\nwhere rnk = 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect  d.name as Department, \\n        e.name as Employee, \\n        salary as Salary\\nfrom Employee e\\njoin Department d on e.departmentId = d.id\\njoin (select max(salary) as max_sal, departmentId\\n      from Employee\\n      group by departmentId) t\\non e.salary = t.max_sal\\nand e.departmentId = t.departmentId\\n```\n```\\nselect Department, Employee, Salary\\nfrom (\\n    select  d.name as Department,\\n            e.name as Employee,\\n            salary as Salary,\\n            dense_rank() over(partition by departmentId order by salary desc) as rnk\\n    from Employee e\\n    join Department d on e.departmentId = d.id\\n    ) t\\nwhere rnk = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2491220,
                "title": "max-with-window",
                "content": "\\tSELECT department,\\n\\t\\t   employee,\\n\\t\\t   salary\\n\\t  FROM (\\n\\t\\tSELECT d.name AS department,\\n\\t\\t\\t   e.name AS employee,\\n\\t\\t\\t   e.salary,\\n\\t\\t\\t   MAX(e.salary) OVER (PARTITION BY d.id) AS max_salary\\n\\t\\t  FROM Employee e JOIN Department d\\n\\t\\t\\t  ON e.departmentId = d.id\\n\\t) AS _\\n\\t WHERE salary = max_salary;\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tSELECT department,\\n\\t\\t   employee,\\n\\t\\t   salary\\n\\t  FROM (\\n\\t\\tSELECT d.name AS department,\\n\\t\\t\\t   e.name AS employee,\\n\\t\\t\\t   e.salary,\\n\\t\\t\\t   MAX(e.salary) OVER (PARTITION BY d.id) AS max_salary\\n\\t\\t  FROM Employee e JOIN Department d\\n\\t\\t\\t  ON e.departmentId = d.id\\n\\t) AS _\\n\\t WHERE salary = max_salary;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2355332,
                "title": "mysql-dense-rank-left-join-with-subquery-cte-common-table-expression",
                "content": "### 1. Using CTE\\n```\\nWITH cte \\nAS(\\n    SELECT \\n        departmentId, \\n        salary AS Salary,\\n        name AS Employee,\\n        DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) AS \\'salary_rank\\'\\n    FROM Employee)\\n\\nSELECT d.name AS Department, e.Employee, e.Salary\\nFROM Department d\\nLEFT JOIN cte e\\nON d.id = e.departmentId\\nWHERE salary_rank = 1\\n```\\n### 2. Using Subquery\\n```\\nSELECT d.name AS Department, e.Employee, e.Salary\\nFROM Department d\\nLEFT JOIN (\\n        SELECT \\n            departmentId, \\n            salary AS Salary,\\n            name AS Employee,\\n            DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) AS \\'salary_rank\\'\\n        FROM Employee) e\\nON d.id = e.departmentId\\nWHERE salary_rank = 1\\n```\\n\\nBoth are similar approach.\\n\\n##### NOTE: \\nIt doesn\\'t make a difference whether to use `DENSE_RANK()` OR `RANK()` here, since the question had asked about just the highest salary. But if it was about Nth Highest salary, then use `DENSE_RANK()`, so as to not leave gaps in ranking and just change `WHERE salary_rank = 1` to `WHERE salary_rank = N`\\n\\n\\n##### Further Readings:\\n1. [MySQL 8.0 Reference Manual: 13.2.15 WITH (Common Table Expressions)](https://dev.mysql.com/doc/refman/8.0/en/with.html)\\n2. [An Introduction to MySQL CTE](https://www.mysqltutorial.org/mysql-cte/)\\n3. [Is there a performance difference between CTE , Sub-Query, Temporary Table or Table Variable?](https://stackoverflow.com/questions/11169550/is-there-a-performance-difference-between-cte-sub-query-temporary-table-or-ta#:~:text=The%20performance%20of%20CTEs%20and,stored%20and%20read%20multiple%20times.)\\n4. [RANK() vs DENSE_RANK() vs ROW_NUMBER() - StackOverFlow](https://stackoverflow.com/a/22081083)\\n\\nThanks for reading! \\nIf there\\'s any error or doubt, do comment. Feedbacks are always appreciated!!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH cte \\nAS(\\n    SELECT \\n        departmentId, \\n        salary AS Salary,\\n        name AS Employee,\\n        DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) AS \\'salary_rank\\'\\n    FROM Employee)\\n\\nSELECT d.name AS Department, e.Employee, e.Salary\\nFROM Department d\\nLEFT JOIN cte e\\nON d.id = e.departmentId\\nWHERE salary_rank = 1\\n```\n```\\nSELECT d.name AS Department, e.Employee, e.Salary\\nFROM Department d\\nLEFT JOIN (\\n        SELECT \\n            departmentId, \\n            salary AS Salary,\\n            name AS Employee,\\n            DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) AS \\'salary_rank\\'\\n        FROM Employee) e\\nON d.id = e.departmentId\\nWHERE salary_rank = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2345235,
                "title": "mysql-explained-step-by-step-join-group-by-max",
                "content": "```\\n/*\\n \\n this will select ,max salary from each group:\\n1) SELECT MAX(Salary) AS Salary FROM Employee GROUP BY departmentId\\n\\n\\n\\nthe given below query will be wrong becuase we are not \\nspecifying the id in the inner query therefore it will give wrong \\nanswers for the dept whose salary are same ,\\ntherefore we need to specify id in the inner query\\n2) \\nSELECT d.name AS Department, e.name AS Employee , e.salary AS Salary\\nFROM Employee as e INNER JOIN Department as d on e.departmentId=d.id \\nWHERE SALARY IN (SELECT  MAX(Salary) AS Salary FROM Employee GROUP BY departmentId)\\n\\n\\n\\ntherefore we need to change the inner id :\\n\\nSELECT departmentId ,  MAX(Salary) AS Salary FROM Employee GROUP BY departmentId\\n\\n3) and final query:\\n*/\\n\\n\\nSELECT d.name AS Department, e.name AS Employee , e.salary AS Salary \\nFROM Employee as e INNER JOIN Department as d on e.departmentId=d.id \\nWHERE (d.id,Salary)  \\nIN (SELECT  departmentId, MAX(Salary) AS Salary FROM Employee GROUP BY departmentId)\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n/*\\n \\n this will select ,max salary from each group:\\n1) SELECT MAX(Salary) AS Salary FROM Employee GROUP BY departmentId\\n\\n\\n\\nthe given below query will be wrong becuase we are not \\nspecifying the id in the inner query therefore it will give wrong \\nanswers for the dept whose salary are same ,\\ntherefore we need to specify id in the inner query\\n2) \\nSELECT d.name AS Department, e.name AS Employee , e.salary AS Salary\\nFROM Employee as e INNER JOIN Department as d on e.departmentId=d.id \\nWHERE SALARY IN (SELECT  MAX(Salary) AS Salary FROM Employee GROUP BY departmentId)\\n\\n\\n\\ntherefore we need to change the inner id :\\n\\nSELECT departmentId ,  MAX(Salary) AS Salary FROM Employee GROUP BY departmentId\\n\\n3) and final query:\\n*/\\n\\n\\nSELECT d.name AS Department, e.name AS Employee , e.salary AS Salary \\nFROM Employee as e INNER JOIN Department as d on e.departmentId=d.id \\nWHERE (d.id,Salary)  \\nIN (SELECT  departmentId, MAX(Salary) AS Salary FROM Employee GROUP BY departmentId)\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2237191,
                "title": "simplest-oracle-solution-using-subquery",
                "content": "select D1.name as Department,E2.name as Employee, E1.Salary from (\\nselect E.departmentId as DepartmentId,max(E.salary) as Salary\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\ngroup by E.departmentId\\n) E1, Employee E2, Department D1\\nwhere E1.departmentId = E2.departmentId\\nand E1.Salary = E2.Salary\\nand E1.departmentId=D1.id",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "select D1.name as Department,E2.name as Employee, E1.Salary from (\\nselect E.departmentId as DepartmentId,max(E.salary) as Salary\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\ngroup by E.departmentId\\n) E1, Employee E2, Department D1\\nwhere E1.departmentId = E2.departmentId\\nand E1.Salary = E2.Salary\\nand E1.departmentId=D1.id",
                "codeTag": "Unknown"
            },
            {
                "id": 2173246,
                "title": "using-dense-rank-good-performance-and-flexible-for-2nd-highest-salary",
                "content": "SELECT B.name as \"Department\", A.name as \"Employee\", A.salary as \"Salary\"\\nFROM (SELECT *, (dense_rank() over(Partition by C.departmentId order by C.salary DESC)) as \"RNK\" FROM Employee C) A\\nLEFT JOIN Department B ON A.departmentId=B.id\\nWHERE A.RNK=1\\n\\n",
                "solutionTags": [],
                "code": "SELECT B.name as \"Department\", A.name as \"Employee\", A.salary as \"Salary\"\\nFROM (SELECT *, (dense_rank() over(Partition by C.departmentId order by C.salary DESC)) as \"RNK\" FROM Employee C) A\\nLEFT JOIN Department B ON A.departmentId=B.id\\nWHERE A.RNK=1\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1976146,
                "title": "mysql-sol-only-dense-rank-easy",
                "content": "Super easy, using only dense_rank() \\n```\\nselect t.dp_name as Department, t.ename as Employee,  t.salary as Salary\\nfrom \\n(\\nSELECT e.id, e.name as ename, e.salary, d.name as dp_name, DENSE_RANK() OVER(PARTITION BY e.departmentid ORDER BY e.salary desc) as rnk\\nfrom\\nemployee e join department d\\non (e.departmentid = d.id)\\n) t\\nwhere rnk = 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect t.dp_name as Department, t.ename as Employee,  t.salary as Salary\\nfrom \\n(\\nSELECT e.id, e.name as ename, e.salary, d.name as dp_name, DENSE_RANK() OVER(PARTITION BY e.departmentid ORDER BY e.salary desc) as rnk\\nfrom\\nemployee e join department d\\non (e.departmentid = d.id)\\n) t\\nwhere rnk = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969159,
                "title": "mysql-by-using-dense-rank-easy-to-understand",
                "content": "```\\nWITH Cal  as (\\nselect e.name Employee, e.salary Salary, e.departmentId, DENSE_RANK() over(partition by departmentId order by salary desc)   sal_rank from Employee e\\n)\\n   select d.name Department, c.Employee, c.Salary \\n       from Cal c join Department d\\n           on c.departmentId = d.id \\n               where sal_rank = 1;\\n```\\n**If Helpful Please Like And Upvoke **",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nWITH Cal  as (\\nselect e.name Employee, e.salary Salary, e.departmentId, DENSE_RANK() over(partition by departmentId order by salary desc)   sal_rank from Employee e\\n)\\n   select d.name Department, c.Employee, c.Salary \\n       from Cal c join Department d\\n           on c.departmentId = d.id \\n               where sal_rank = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1741945,
                "title": "simple-dense-ranked-solution",
                "content": "```\\nselect department, employee, salary\\nfrom (select d.name as department,\\n             e.name as employee,\\n             e.salary as salary,\\n             DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) ranked\\n        from Employee e\\n        join Department d on e.departmentId = d.id) as temp\\nwhere ranked = 1\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nselect department, employee, salary\\nfrom (select d.name as department,\\n             e.name as employee,\\n             e.salary as salary,\\n             DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) ranked\\n        from Employee e\\n        join Department d on e.departmentId = d.id) as temp\\nwhere ranked = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1673311,
                "title": "clear-solution-using-over-partition-by",
                "content": "```\\nSELECT\\n    D.name AS Department,\\n    E.name AS Employee,\\n    E.salary AS Salary\\nFROM\\n    (SELECT *, MAX(salary) OVER (PARTITION BY departmentId) AS max_sal FROM Employee) E\\n    JOIN Department D\\n    ON E.departmentId = D.id\\n    WHERE E.salary = max_sal;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    D.name AS Department,\\n    E.name AS Employee,\\n    E.salary AS Salary\\nFROM\\n    (SELECT *, MAX(salary) OVER (PARTITION BY departmentId) AS max_sal FROM Employee) E\\n    JOIN Department D\\n    ON E.departmentId = D.id\\n    WHERE E.salary = max_sal;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1672005,
                "title": "mysql-easy-explanation",
                "content": "We need to get max salary for each department, and then print all employees for that salary.\\nHow can we get max salary for each department ?\\n```\\nSELECT departmentId, MAX(Salary) FROM Employee\\nGROUP BY departmentId\\n```\\nLet\\'s store it as maxSalaries\\n```\\n(SELECT departmentId, MAX(Salary) as salary FROM Employee\\nGROUP BY departmentId) as maxSalaries\\n```\\nNow we need to fetch all the rows in Employee table where it\\'s department has maximum salary..\\nSo, join the above table with Employee and try to fetch result\\n```\\nSELECT departmentId as Department, name as Employee, Salary FROM Employee e\\nJOIN\\n(SELECT departmentId, MAX(salary) as salary FROM Employee\\nGROUP BY departmentId) as maxSalaries\\nUSING (salary, departmentId )\\n```\\n\\n\\nNow we just need to replace our department ids with \\nrespective department names. So, join the above with department table and use respective alias name\\n```\\nSELECT d.name as Department, e.name as Employee, Salary FROM Employee e\\nJOIN\\n(SELECT departmentId, MAX(salary) as salary FROM Employee\\nGROUP BY departmentId) as maxSalaries\\nUSING (salary, departmentId )\\n\\nJOIN\\n\\nDepartment d\\nON (d.id=e.departmentId)\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT departmentId, MAX(Salary) FROM Employee\\nGROUP BY departmentId\\n```\n```\\n(SELECT departmentId, MAX(Salary) as salary FROM Employee\\nGROUP BY departmentId) as maxSalaries\\n```\n```\\nSELECT departmentId as Department, name as Employee, Salary FROM Employee e\\nJOIN\\n(SELECT departmentId, MAX(salary) as salary FROM Employee\\nGROUP BY departmentId) as maxSalaries\\nUSING (salary, departmentId )\\n```\n```\\nSELECT d.name as Department, e.name as Employee, Salary FROM Employee e\\nJOIN\\n(SELECT departmentId, MAX(salary) as salary FROM Employee\\nGROUP BY departmentId) as maxSalaries\\nUSING (salary, departmentId )\\n\\nJOIN\\n\\nDepartment d\\nON (d.id=e.departmentId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1542515,
                "title": "simple-mysql-faster-than-98",
                "content": "```\\nWITH cte AS (\\n    SELECT d.name AS \\'Department\\', e.name AS \\'Employee\\', e.Salary,\\n    DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.Salary DESC) AS \\'rank\\'\\n    FROM Department d INNER JOIN Employee e\\n    ON e.departmentId = d.id\\n)\\nSELECT Department, Employee, Salary\\nFROM cte\\nWHERE cte.rank = 1\\nORDER BY 1, 3 DESC, 2",
                "solutionTags": [],
                "code": "```\\nWITH cte AS (\\n    SELECT d.name AS \\'Department\\', e.name AS \\'Employee\\', e.Salary,\\n    DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.Salary DESC) AS \\'rank\\'\\n    FROM Department d INNER JOIN Employee e\\n    ON e.departmentId = d.id\\n)\\nSELECT Department, Employee, Salary\\nFROM cte\\nWHERE cte.rank = 1\\nORDER BY 1, 3 DESC, 2",
                "codeTag": "Unknown"
            },
            {
                "id": 1514949,
                "title": "using-inner-join-simplest-code",
                "content": "```\\nSELECT D.NAME DEPARTMENT,E.NAME EMPLOYEE,E.SALARY SALARY FROM EMPLOYEE E\\nINNER JOIN DEPARTMENT D\\nON E.DEPARTMENTID=D.ID\\nGROUP BY D.ID,E.NAME,E.SALARY\\nHAVING E.SALARY>=(SELECT MAX(SALARY)FROM EMPLOYEE E WHERE E.DEPARTMENTID=D.ID)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT D.NAME DEPARTMENT,E.NAME EMPLOYEE,E.SALARY SALARY FROM EMPLOYEE E\\nINNER JOIN DEPARTMENT D\\nON E.DEPARTMENTID=D.ID\\nGROUP BY D.ID,E.NAME,E.SALARY\\nHAVING E.SALARY>=(SELECT MAX(SALARY)FROM EMPLOYEE E WHERE E.DEPARTMENTID=D.ID)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1496851,
                "title": "simple-solution",
                "content": "```\\nSELECT d.Name Department, e.Name Employee, e.Salary FROM Employee e, Department d\\nWHERE d.Id = e.DepartmentId AND (e.DepartmentId, e.Salary) IN \\n(SELECT DepartmentId, MAX(Salary) FROM Employee \\n GROUP BY DepartmentId)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT d.Name Department, e.Name Employee, e.Salary FROM Employee e, Department d\\nWHERE d.Id = e.DepartmentId AND (e.DepartmentId, e.Salary) IN \\n(SELECT DepartmentId, MAX(Salary) FROM Employee \\n GROUP BY DepartmentId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1445407,
                "title": "using-cte-dense-rank",
                "content": "```\\nwith tbl1 as (\\n\\tSELECT d.name as Department,\\n\\t   e.name as Employee,\\n\\t   e.salary as Salary,\\n\\t   DENSE_RANK() OVER (PARTITION BY e.DepartmentId ORDER BY e.salary desc) as ranked_salary\\nFROM employee e\\nJOIN Department d\\nON (d.id = e.DepartmentId)\\n\\n)\\n\\nSELECT department,\\n\\t   employee,\\n\\t   salary\\nFROM tbl1\\nWHERE ranked_salary = 1\\n```",
                "solutionTags": [],
                "code": "```\\nwith tbl1 as (\\n\\tSELECT d.name as Department,\\n\\t   e.name as Employee,\\n\\t   e.salary as Salary,\\n\\t   DENSE_RANK() OVER (PARTITION BY e.DepartmentId ORDER BY e.salary desc) as ranked_salary\\nFROM employee e\\nJOIN Department d\\nON (d.id = e.DepartmentId)\\n\\n)\\n\\nSELECT department,\\n\\t   employee,\\n\\t   salary\\nFROM tbl1\\nWHERE ranked_salary = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1422683,
                "title": "mysql-mssql-using-join",
                "content": "MySQL:\\n\\n\\tSELECT DISTINCT S.Department, E.Name Employee, E.Salary\\n\\tFROM Employee E\\n\\tJOIN (\\n\\t\\tSELECT D.Id, D.Name Department, Max(Salary) Salary\\n\\t\\tFROM Employee E\\n\\t\\tJOIN Department D ON E.DepartmentId = D.Id\\n\\t\\tGROUP BY D.Id\\n\\t) S\\n\\tON E.Salary = S.Salary AND E.DepartmentId = S.Id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT DISTINCT S.Department, E.Name Employee, E.Salary\\n\\tFROM Employee E\\n\\tJOIN (\\n\\t\\tSELECT D.Id, D.Name Department, Max(Salary) Salary\\n\\t\\tFROM Employee E\\n\\t\\tJOIN Department D ON E.DepartmentId = D.Id\\n\\t\\tGROUP BY D.Id, D.Name\\n\\t) S\\n\\tON E.Salary = S.Salary AND E.DepartmentId = S.Id",
                "solutionTags": [],
                "code": "MySQL:\\n\\n\\tSELECT DISTINCT S.Department, E.Name Employee, E.Salary\\n\\tFROM Employee E\\n\\tJOIN (\\n\\t\\tSELECT D.Id, D.Name Department, Max(Salary) Salary\\n\\t\\tFROM Employee E\\n\\t\\tJOIN Department D ON E.DepartmentId = D.Id\\n\\t\\tGROUP BY D.Id\\n\\t) S\\n\\tON E.Salary = S.Salary AND E.DepartmentId = S.Id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT DISTINCT S.Department, E.Name Employee, E.Salary\\n\\tFROM Employee E\\n\\tJOIN (\\n\\t\\tSELECT D.Id, D.Name Department, Max(Salary) Salary\\n\\t\\tFROM Employee E\\n\\t\\tJOIN Department D ON E.DepartmentId = D.Id\\n\\t\\tGROUP BY D.Id, D.Name\\n\\t) S\\n\\tON E.Salary = S.Salary AND E.DepartmentId = S.Id",
                "codeTag": "Unknown"
            },
            {
                "id": 1214874,
                "title": "simple-solution-with-window-function",
                "content": "```\\nWITH CTE AS (\\nSELECT DEPARTMENTID,NAME,SALARY,RANK() OVER(PARTITION BY DEPARTMENTID ORDER BY SALARY DESC) as r\\nFROM EMPLOYEE\\n    )\\n    SELECT D.NAME AS Department,C.NAME AS Employee,c.salary as Salary\\n    FROM CTE C JOIN DEPARTMENT D \\n    ON C.DEPARTMENTID = D.ID\\n    where c.r=1\\n\\t```",
                "solutionTags": [],
                "code": "```\\nWITH CTE AS (\\nSELECT DEPARTMENTID,NAME,SALARY,RANK() OVER(PARTITION BY DEPARTMENTID ORDER BY SALARY DESC) as r\\nFROM EMPLOYEE\\n    )\\n    SELECT D.NAME AS Department,C.NAME AS Employee,c.salary as Salary\\n    FROM CTE C JOIN DEPARTMENT D \\n    ON C.DEPARTMENTID = D.ID\\n    where c.r=1\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1212350,
                "title": "easy-to-understand-solution-using-subquery",
                "content": "SELECT d.name as Department, e.Name as Employee, e.Salary FROM Employee e INNER JOIN\\nDepartment d ON e.DepartmentId = d.Id\\nWHERE e.Salary IN\\n(\\nSELECT MAX(e1.Salary) FROM employee e1 INNER JOIN Department d1\\n    ON e1.DepartmentId = d1.Id\\n    WHERE e1.DepartmentId = e.DepartmentId\\n    GROUP BY d1.Name\\n)",
                "solutionTags": [],
                "code": "SELECT d.name as Department, e.Name as Employee, e.Salary FROM Employee e INNER JOIN\\nDepartment d ON e.DepartmentId = d.Id\\nWHERE e.Salary IN\\n(\\nSELECT MAX(e1.Salary) FROM employee e1 INNER JOIN Department d1\\n    ON e1.DepartmentId = d1.Id\\n    WHERE e1.DepartmentId = e.DepartmentId\\n    GROUP BY d1.Name\\n)",
                "codeTag": "Unknown"
            },
            {
                "id": 1086086,
                "title": "mysql-window-functions-can-be-intimidating-that-is-why-i-give-them-cute-names",
                "content": "\\tselect \\n        a.Department, \\n        a.Employee,\\n        a.Salary \\n    from\\n        (\\n            select \\n                d.name as Department,\\n                e.name as Employee,\\n                e.salary as Salary,\\n                DENSE_RANK() over (partition by d.id order by e.salary desc) as rankie\\n            from\\n                employee e \\n\\t\\t\\tjoin \\n\\t\\t\\t\\tdepartment d \\n\\t\\t\\ton \\n\\t\\t\\t\\te.departmentId = d.id\\n        ) a\\n        \\n    where a.rankie = 1;",
                "solutionTags": [],
                "code": "\\tselect \\n        a.Department, \\n        a.Employee,\\n        a.Salary \\n    from\\n        (\\n            select \\n                d.name as Department,\\n                e.name as Employee,\\n                e.salary as Salary,\\n                DENSE_RANK() over (partition by d.id order by e.salary desc) as rankie\\n            from\\n                employee e \\n\\t\\t\\tjoin \\n\\t\\t\\t\\tdepartment d \\n\\t\\t\\ton \\n\\t\\t\\t\\te.departmentId = d.id\\n        ) a\\n        \\n    where a.rankie = 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1023990,
                "title": "dense-rank",
                "content": "```\\nWITH tab1 AS (SELECT\\n                    d.name AS department,\\n                    e.name AS employee,\\n                    e.salary,\\n                    DENSE_RANK() OVER (PARTITION BY d.name ORDER BY e.salary DESC) as DRANK\\n                FROM\\n                    employee AS e\\n                JOIN \\n                    department AS d\\n                ON\\n                    e.departmentid = d.id)\\n                \\n                \\nSELECT department, employee, salary\\nFROM tab1\\nWHERE DRANK = 1\\n```",
                "solutionTags": [],
                "code": "```\\nWITH tab1 AS (SELECT\\n                    d.name AS department,\\n                    e.name AS employee,\\n                    e.salary,\\n                    DENSE_RANK() OVER (PARTITION BY d.name ORDER BY e.salary DESC) as DRANK\\n                FROM\\n                    employee AS e\\n                JOIN \\n                    department AS d\\n                ON\\n                    e.departmentid = d.id)\\n                \\n                \\nSELECT department, employee, salary\\nFROM tab1\\nWHERE DRANK = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788682,
                "title": "easy-understand",
                "content": "```\\nSELECT b.Name as Department,a.Name as Employee,a.Salary from Employee a join Department b on a.DepartmentId=b.Id\\nwhere a.Salary=(select max(Salary) from Employee where DepartmentId=b.Id)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT b.Name as Department,a.Name as Employee,a.Salary from Employee a join Department b on a.DepartmentId=b.Id\\nwhere a.Salary=(select max(Salary) from Employee where DepartmentId=b.Id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 755737,
                "title": "mysql-dense-rank",
                "content": "```\\nSELECT d.Name as Department, Employee, Salary\\nFROM\\n(\\nSELECT Name as Employee, DepartmentId, Salary, dense_rank() over(partition by DepartmentId order by Salary DESC) as rk\\nFROM Employee) rk_table inner join Department d on rk = 1 and DepartmentId = d.Id\\n```\\n\\nThe runtime is lower than using where clause but I think the idea is more generalized.",
                "solutionTags": [],
                "code": "```\\nSELECT d.Name as Department, Employee, Salary\\nFROM\\n(\\nSELECT Name as Employee, DepartmentId, Salary, dense_rank() over(partition by DepartmentId order by Salary DESC) as rk\\nFROM Employee) rk_table inner join Department d on rk = 1 and DepartmentId = d.Id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 738552,
                "title": "mysql-solution-with-exp",
                "content": "First join Employee and Department table.\\nThen for selected departmentID, get the maximum of the salary in that department\\nOutput the entry condition on the salary equals within department maximum salary.\\n\\n\\n```\\n# Write your MySQL query statement below\\nselect D.Name as Department, E.Name as Employee, E.Salary\\nfrom Department D\\njoin\\nEmployee E\\non D.Id = E.DepartmentId\\nwhere E.Salary = (select max(E2.Salary) from Employee E2 where E2.DepartmentId = E.DepartmentId)\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect D.Name as Department, E.Name as Employee, E.Salary\\nfrom Department D\\njoin\\nEmployee E\\non D.Id = E.DepartmentId\\nwhere E.Salary = (select max(E2.Salary) from Employee E2 where E2.DepartmentId = E.DepartmentId)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506788,
                "title": "mysql-90-using-double-join",
                "content": "```\\nSelect a.Name as Department ,e2.Name as Employee,e2.Salary as Salary \\nFROM Employee e2 \\nJOIN (Select d.Id,d.Name,max(e1.Salary) as max_dep_salary \\nFROM Employee e1 \\nJOIN Department d ON e1.DepartmentId=d.id GROUP By d.Id,d.name) a \\nON (e2.DepartmentId=a.Id AND e2.Salary=a.max_dep_salary)\\n```",
                "solutionTags": [],
                "code": "```\\nSelect a.Name as Department ,e2.Name as Employee,e2.Salary as Salary \\nFROM Employee e2 \\nJOIN (Select d.Id,d.Name,max(e1.Salary) as max_dep_salary \\nFROM Employee e1 \\nJOIN Department d ON e1.DepartmentId=d.id GROUP By d.Id,d.name) a \\nON (e2.DepartmentId=a.Id AND e2.Salary=a.max_dep_salary)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 180385,
                "title": "oracle-rank-solution",
                "content": "```\\nSELECT \\nd.Name \"Department\",\\na.Name \"Employee\",\\na.Salary \"Salary\"\\nFROM(\\nSELECT\\n    RANK() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS rank,\\n    Salary,\\n    Name,\\n    DepartmentId\\n    FROM Employee\\n) a\\nJOIN Department d\\n    ON a.DepartmentId = d.Id\\nWHERE a.rank = 1\\nORDER BY \"Salary\";\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\nd.Name \"Department\",\\na.Name \"Employee\",\\na.Salary \"Salary\"\\nFROM(\\nSELECT\\n    RANK() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS rank,\\n    Salary,\\n    Name,\\n    DepartmentId\\n    FROM Employee\\n) a\\nJOIN Department d\\n    ON a.DepartmentId = d.Id\\nWHERE a.rank = 1\\nORDER BY \"Salary\";\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972657,
                "title": "100-easy-and-clean-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT DEPT.name AS Department, EMP.name AS Employee, EMP.salary AS Salary \\nFROM Department DEPT, Employee EMP WHERE\\nEMP.departmentId = DEPT.id AND (EMP.departmentId, salary) IN \\n(SELECT departmentId, MAX(salary) FROM Employee GROUP BY departmentId)\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DEPT.name AS Department, EMP.name AS Employee, EMP.salary AS Salary \\nFROM Department DEPT, Employee EMP WHERE\\nEMP.departmentId = DEPT.id AND (EMP.departmentId, salary) IN \\n(SELECT departmentId, MAX(salary) FROM Employee GROUP BY departmentId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907064,
                "title": "pandas-code",
                "content": "\\n# Code\\n```\\nimport pandas as pd\\n\\ndef department_highest_salary(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    merged_df = employee.merge(department, left_on = \\'departmentId\\', right_on = \\'id\\')\\n    merged_df = merged_df.rename(columns = {\\'name_x\\': \\'Employee\\', \\'name_y\\': \\'Department\\', \\'salary\\': \\'Salary\\'})[[\\'Department\\', \\'Employee\\', \\'Salary\\']]\\n    return merged_df[merged_df[\\'Salary\\'] == merged_df.groupby(\\'Department\\')[\\'Salary\\'].transform(max)]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef department_highest_salary(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    merged_df = employee.merge(department, left_on = \\'departmentId\\', right_on = \\'id\\')\\n    merged_df = merged_df.rename(columns = {\\'name_x\\': \\'Employee\\', \\'name_y\\': \\'Department\\', \\'salary\\': \\'Salary\\'})[[\\'Department\\', \\'Employee\\', \\'Salary\\']]\\n    return merged_df[merged_df[\\'Salary\\'] == merged_df.groupby(\\'Department\\')[\\'Salary\\'].transform(max)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3867386,
                "title": "cte-first-val",
                "content": "```\\nwith temporary_table(name,salary,departmentId,top_salary) as\\n(select e.name,e.salary,e.departmentId,FIRST_VALUE(e.salary) over(partition by departmentId order by salary desc) as      top_salary from Employee e)\\n\\n\\nselect d.name as Department, t.name as Employee, t.salary as Salary \\nfrom temporary_table t inner join Department d\\non t.departmentId=d.id\\nwhere t.salary=t.top_salary;\\n```",
                "solutionTags": [],
                "code": "```\\nwith temporary_table(name,salary,departmentId,top_salary) as\\n(select e.name,e.salary,e.departmentId,FIRST_VALUE(e.salary) over(partition by departmentId order by salary desc) as      top_salary from Employee e)\\n\\n\\nselect d.name as Department, t.name as Employee, t.salary as Salary \\nfrom temporary_table t inner join Department d\\non t.departmentId=d.id\\nwhere t.salary=t.top_salary;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3662564,
                "title": "easy-solution-sql-server",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT T2.name as \\'Department\\', T1.name as \\'Employee\\', T1.salary \\'Salary\\' FROM Employee T1 \\nINNER JOIN Department T2 ON T1.departmentId = T2.Id\\nWHERE T1.salary = (SELECT MAX(T3.salary) FROM Employee T3 \\nWHERE T2.Id = T3.departmentId) \\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT T2.name as \\'Department\\', T1.name as \\'Employee\\', T1.salary \\'Salary\\' FROM Employee T1 \\nINNER JOIN Department T2 ON T1.departmentId = T2.Id\\nWHERE T1.salary = (SELECT MAX(T3.salary) FROM Employee T3 \\nWHERE T2.Id = T3.departmentId) \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2653450,
                "title": "using-dense-rank-and-cte",
                "content": "# Approach\\nHi, here have tried to solve this problem using Dense Rank and CTE (Common Table expression).\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH temp_table(rank_salary,Department, Employee, Salary) as (select DENSE_RANK() OVER(partition by depart.name order by em.salary desc) as rank_salary,depart.name as \"Department\", em.name as \"Employee\", em.salary as \"Salary\"\\nfrom Employee em join Department depart on em.departmentId=depart.id)\\n\\n\\nselect Department, Employee, Salary from temp_table where rank_salary = 1\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH temp_table(rank_salary,Department, Employee, Salary) as (select DENSE_RANK() OVER(partition by depart.name order by em.salary desc) as rank_salary,depart.name as \"Department\", em.name as \"Employee\", em.salary as \"Salary\"\\nfrom Employee em join Department depart on em.departmentId=depart.id)\\n\\n\\nselect Department, Employee, Salary from temp_table where rank_salary = 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2594193,
                "title": "window-function-solution",
                "content": "select t2.department as department, t2.employee as employee, t2.salary as salary\\nfrom\\n(select t1.department as department, t1.employee as employee, t1.salary as salary, \\ndense_rank() over (partition by t1.department order by t1.salary desc) as r\\nfrom\\n(select d.name as department, e.name as employee, e.salary as salary\\nfrom employee e\\njoin department d\\non e.departmentid = d.id) as t1) as t2\\nwhere t2.r = 1",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select t2.department as department, t2.employee as employee, t2.salary as salary\\nfrom\\n(select t1.department as department, t1.employee as employee, t1.salary as salary, \\ndense_rank() over (partition by t1.department order by t1.salary desc) as r\\nfrom\\n(select d.name as department, e.name as employee, e.salary as salary\\nfrom employee e\\njoin department d\\non e.departmentid = d.id) as t1) as t2\\nwhere t2.r = 1",
                "codeTag": "Unknown"
            },
            {
                "id": 2590774,
                "title": "easy-sql-solution",
                "content": "```\\nSELECT Department, Employee, Salary\\nFROM (\\n    SELECT d.name AS Department, e.name AS Employee, e.salary AS Salary, \\n    RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) AS s_rank\\n    FROM Employee e \\n    JOIN Department d ON d.id = e.departmentId\\n) AS T \\nWHERE s_rank = 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Department, Employee, Salary\\nFROM (\\n    SELECT d.name AS Department, e.name AS Employee, e.salary AS Salary, \\n    RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) AS s_rank\\n    FROM Employee e \\n    JOIN Department d ON d.id = e.departmentId\\n) AS T \\nWHERE s_rank = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575949,
                "title": "dense-rank-mysql",
                "content": "\\tselect depName as Department, empName as Employee ,salary as Salary from (select d.name as depName,e.name as empName,e.salary,DENSE_RANK() over (partition by d.name order by e.salary desc) as r from Employee e,Department d where e.departmentId=d.id)as t where t.r=1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tselect depName as Department, empName as Employee ,salary as Salary from (select d.name as depName,e.name as empName,e.salary,DENSE_RANK() over (partition by d.name order by e.salary desc) as r from Employee e,Department d where e.departmentId=d.id)as t where t.r=1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2561643,
                "title": "using-rank",
                "content": "```\\nSELECT T.Department, T.Employee, T.Salary\\nFROM (SELECT D.name as \\'Department\\', E.name as \\'Employee\\', E.salary as \\'Salary\\', RANK() OVER (PARTITION BY D.id ORDER BY E.salary DESC) as \\'rank\\'\\nFROM Employee E\\nLEFT JOIN Department D\\nON E.departmentId=D.id) T\\nWHERE T.rank =1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT T.Department, T.Employee, T.Salary\\nFROM (SELECT D.name as \\'Department\\', E.name as \\'Employee\\', E.salary as \\'Salary\\', RANK() OVER (PARTITION BY D.id ORDER BY E.salary DESC) as \\'rank\\'\\nFROM Employee E\\nLEFT JOIN Department D\\nON E.departmentId=D.id) T\\nWHERE T.rank =1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2515027,
                "title": "subquery-and-window-functions",
                "content": "Select Department,\\n      Employee,\\n      Salary FROM (\\n                Select d.name as Department,\\n                e.name as Employee,\\n                e.salary as Salary,\\n                DENSE_RANK() OVER (PARTITION BY d.name ORDER BY e.salary DESC) as rnk\\n                FROM  Employee e\\n                JOIN Department d \\n                on e.departmentId = d.id\\n                 ) temp_table                   \\nWHERE rnk = 1",
                "solutionTags": [],
                "code": "Select Department,\\n      Employee,\\n      Salary FROM (\\n                Select d.name as Department,\\n                e.name as Employee,\\n                e.salary as Salary,\\n                DENSE_RANK() OVER (PARTITION BY d.name ORDER BY e.salary DESC) as rnk\\n                FROM  Employee e\\n                JOIN Department d \\n                on e.departmentId = d.id\\n                 ) temp_table                   \\nWHERE rnk = 1",
                "codeTag": "Unknown"
            },
            {
                "id": 2450671,
                "title": "dense-rank",
                "content": "```\\nSELECT Department , Employee, Salary FROM\\n(\\nSELECT D.name as Department , E.name as Employee , E.salary as Salary, DENSE_RANK() OVER (PARTITION BY E.departmentId order by E.salary desc) as rank\\nFROM Employee as E inner join Department as D on E.departmentId = D.id\\n) temp\\nwhere rank = 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Department , Employee, Salary FROM\\n(\\nSELECT D.name as Department , E.name as Employee , E.salary as Salary, DENSE_RANK() OVER (PARTITION BY E.departmentId order by E.salary desc) as rank\\nFROM Employee as E inner join Department as D on E.departmentId = D.id\\n) temp\\nwhere rank = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2402632,
                "title": "easy-solution-using-basic-concepts-only",
                "content": "select  d.name as\"Department\" , e.name as\"Employee\", salary as \"Salary\"from Employee e\\njoin Department d \\non e.departmentId=d.id\\nwhere  (e.salary, e.departmentId) in (select max(salary), departmentId from employee group by departmentId)\\n",
                "solutionTags": [],
                "code": "select  d.name as\"Department\" , e.name as\"Employee\", salary as \"Salary\"from Employee e\\njoin Department d \\non e.departmentId=d.id\\nwhere  (e.salary, e.departmentId) in (select max(salary), departmentId from employee group by departmentId)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2398627,
                "title": "easy-solution-of-department-highest-salary-mysql",
                "content": "```\\nselect Department.name as Department , Employee.name as Employee, Employee.salary as Salary from Department \\n        join Employee \\n            on Employee.departmentId = Department.id \\n                and Employee.salary = (select max(salary) from Employee \\n                                            where Employee.departmentId = Department.id);",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect Department.name as Department , Employee.name as Employee, Employee.salary as Salary from Department \\n        join Employee \\n            on Employee.departmentId = Department.id \\n                and Employee.salary = (select max(salary) from Employee \\n                                            where Employee.departmentId = Department.id);",
                "codeTag": "Unknown"
            },
            {
                "id": 2327349,
                "title": "simple-approach-using-window-functions",
                "content": "```\\nselect e.department, e.employee, e.salary from (select d.*, rank() over(partition by d.department order by d.salary desc) as rank_number from (select a.name Employee , a.salary, b.name department from Employee a join Department b on a.departmentid = b.id) d) e where e.rank_number=1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect e.department, e.employee, e.salary from (select d.*, rank() over(partition by d.department order by d.salary desc) as rank_number from (select a.name Employee , a.salary, b.name department from Employee a join Department b on a.departmentid = b.id) d) e where e.rank_number=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2320629,
                "title": "mysql-2-solns-subquery-using-join-vs-cte-using-rank",
                "content": "CTE using Dense Rank\\n```\\nWITH TempTable AS (\\n    SELECT \\n        name,\\n        salary,\\n        departmentId,\\n        DENSE_RANK() OVER (\\n            PARTITION BY departmentId\\n            ORDER BY salary DESC\\n        ) AS denseRank\\n    FROM Employee\\n)\\n\\nSELECT T2.name AS Department, T1.name AS Employee, T1.salary AS salary\\nFROM TempTable AS T1\\nJOIN Department AS T2\\nON T1.departmentId = T2.id\\nWHERE T1.denseRank = 1\\n```\\n\\nSubquery using Join\\n```\\nSELECT D.name AS Department, E.name AS Employee, E.salary AS Salary\\nFROM Employee AS E\\nJOIN Department AS D\\nON E.departmentId = D.id\\nWHERE E.salary = (\\n    SELECT MAX(T.Salary)\\n    FROM Employee AS T\\n    WHERE T.departmentId = E.departmentId\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH TempTable AS (\\n    SELECT \\n        name,\\n        salary,\\n        departmentId,\\n        DENSE_RANK() OVER (\\n            PARTITION BY departmentId\\n            ORDER BY salary DESC\\n        ) AS denseRank\\n    FROM Employee\\n)\\n\\nSELECT T2.name AS Department, T1.name AS Employee, T1.salary AS salary\\nFROM TempTable AS T1\\nJOIN Department AS T2\\nON T1.departmentId = T2.id\\nWHERE T1.denseRank = 1\\n```\n```\\nSELECT D.name AS Department, E.name AS Employee, E.salary AS Salary\\nFROM Employee AS E\\nJOIN Department AS D\\nON E.departmentId = D.id\\nWHERE E.salary = (\\n    SELECT MAX(T.Salary)\\n    FROM Employee AS T\\n    WHERE T.departmentId = E.departmentId\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2310496,
                "title": "mysql-easy-solution",
                "content": "select department.name as department, employee.name as employee, employee.salary as salary\\nfrom employee join department on employee.departmentId = department.id\\nwhere(employee.departmentId, employee.salary) in\\n (select departmentId, MAX(salary) as salary\\nfrom employee\\ngroup by departmentId)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select department.name as department, employee.name as employee, employee.salary as salary\\nfrom employee join department on employee.departmentId = department.id\\nwhere(employee.departmentId, employee.salary) in\\n (select departmentId, MAX(salary) as salary\\nfrom employee\\ngroup by departmentId)",
                "codeTag": "Unknown"
            },
            {
                "id": 2306035,
                "title": "mysql-2-solutions-subquery-rank-or-cte-rank-with-explainations",
                "content": "**SOLUTION 1**\\n```\\nselect Department, Employee, Salary\\nfrom (\\n    select d.name as Department, e.name as Employee, e.salary as Salary,\\n    rank() over (partition by d.name order by e.salary desc) as rnk\\n    from employee e join department d on e.departmentId = d.id) a\\nwhere a.rnk = 1\\n```\\n\\nHere are the steps:\\n1.   We want to find the highest salary employee in each department\\n`select d.name as Department, e.name as Employee, e.salary as Salary,\\n    rank() over (partition by d.name order by e.salary desc) as rnk\\n    from employee e join department d on e.departmentId = d.id`\\n\\n2. Adding the top part to display the columns that we want only to be displayed and from to get the data from the previous query\\n`select Department, Employee, Salary from`\\n\\n3. Since the query needs to retun to the highest employee\\'s salary on each department, we want to add *where* function\\n`where a.rnk = 1`\\n\\nNote: when using a subquery, the derived table needs to have an alias; hence, I use a for it is alias.\\n\\n------------------------------------\\n\\n**SOLUTION 2**\\n```\\nwith highest_salary as\\n    (select d.name as Department, e.name as Employee, e.salary as Salary, \\n     rank() over (partition by d.name order by e.salary desc) as rnk\\n     from employee e join department d on e.departmentId = d.id)\\n    \\nselect Department, Employee, Salary\\nfrom highest_salary\\nwhere rnk = 1\\n```\\n\\nHere are the steps:\\n1. We want to find the highest salary employee in each department\\n`\\n\\tselect d.name as Department, e.name as Employee, e.salary as Salary, \\n     rank() over (partition by d.name order by e.salary desc) as rnk\\n     from employee e join department d on e.departmentId = d.id\\n`\\n\\n2. Then, we want to create a temporary table; hence, we need to add *with* function\\n`with highest_salary as\\n    (select d.name as Department, e.name as Employee, e.salary as Salary, \\n     rank() over (partition by d.name order by e.salary desc) as rnk\\n     from employee e join department d on e.departmentId = d.id)`\\n\\t\\n3. In order to return to the highest salary on each department, we want to set a rank = 1 filter.\\n`select Department, Employee, Salary\\nfrom highest_salary\\nwhere rnk = 1`",
                "solutionTags": [],
                "code": "```\\nselect Department, Employee, Salary\\nfrom (\\n    select d.name as Department, e.name as Employee, e.salary as Salary,\\n    rank() over (partition by d.name order by e.salary desc) as rnk\\n    from employee e join department d on e.departmentId = d.id) a\\nwhere a.rnk = 1\\n```\n```\\nwith highest_salary as\\n    (select d.name as Department, e.name as Employee, e.salary as Salary, \\n     rank() over (partition by d.name order by e.salary desc) as rnk\\n     from employee e join department d on e.departmentId = d.id)\\n    \\nselect Department, Employee, Salary\\nfrom highest_salary\\nwhere rnk = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2289968,
                "title": "sql-for-dummies",
                "content": "\\tSELECT D.NAME AS Department, E.NAME AS Employee, E.SALARY AS Salary\\n\\tFROM EMPLOYEE E JOIN DEPARTMENT D\\n\\tON D.ID = E.DEPARTMENTID\\n\\tWHERE (E.SALARY, E.DEPARTMENTID) IN(\\n\\tSELECT MAX(SALARY), DEPARTMENTID\\n\\tFROM EMPLOYEE\\n\\tGROUP BY DEPARTMENTID   )",
                "solutionTags": [],
                "code": "\\tSELECT D.NAME AS Department, E.NAME AS Employee, E.SALARY AS Salary\\n\\tFROM EMPLOYEE E JOIN DEPARTMENT D\\n\\tON D.ID = E.DEPARTMENTID\\n\\tWHERE (E.SALARY, E.DEPARTMENTID) IN(\\n\\tSELECT MAX(SALARY), DEPARTMENTID\\n\\tFROM EMPLOYEE\\n\\tGROUP BY DEPARTMENTID   )",
                "codeTag": "Unknown"
            },
            {
                "id": 2262483,
                "title": "subquery-and-inner-join",
                "content": "```\\nselect department.name as Department, employee.name as Employee, employee.salary\\nfrom employee join \\n\\t(select d.id, max(e.salary) as Salary\\n\\tfrom employee e join department d\\n\\ton e.departmentId = d.id\\n\\tgroup by d.id)\\n\\tas Data\\non employee.departmentId = Data.id\\njoin department\\non Data.id = department.id\\nwhere employee.salary = Data.salary\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect department.name as Department, employee.name as Employee, employee.salary\\nfrom employee join \\n\\t(select d.id, max(e.salary) as Salary\\n\\tfrom employee e join department d\\n\\ton e.departmentId = d.id\\n\\tgroup by d.id)\\n\\tas Data\\non employee.departmentId = Data.id\\njoin department\\non Data.id = department.id\\nwhere employee.salary = Data.salary\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261035,
                "title": "subquery",
                "content": "```\\nselect D.name as Department,E.name as Employee,E.salary as Salary \\nfrom Employee as E,Department as D\\nwhere E.departmentId=D.id\\nand E.salary=(select max(salary) from Employee where DepartmentId=D.id)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect D.name as Department,E.name as Employee,E.salary as Salary \\nfrom Employee as E,Department as D\\nwhere E.departmentId=D.id\\nand E.salary=(select max(salary) from Employee where DepartmentId=D.id)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2243863,
                "title": "faster-than-96-96-easy-to-understand-solution",
                "content": "```\\nSELECT\\n    Department,\\n    Employee,\\n    Salary\\nFROM\\n    (\\n        SELECT\\n            d.name AS Department,\\n            e.name AS Employee,\\n            e.salary AS Salary,\\n            RANK() OVER(\\n                PARTITION BY d.name\\n                ORDER BY\\n                    e.salary DESC\\n            ) AS rnk\\n        FROM\\n            employee e\\n            INNER JOIN Department d ON e.departmentid = d.id\\n    ) AS temp\\nWHERE\\n    rnk = 1;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/169a78ea-ccc4-48f5-be4c-9fc402b0d909_1657075683.5302362.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    Department,\\n    Employee,\\n    Salary\\nFROM\\n    (\\n        SELECT\\n            d.name AS Department,\\n            e.name AS Employee,\\n            e.salary AS Salary,\\n            RANK() OVER(\\n                PARTITION BY d.name\\n                ORDER BY\\n                    e.salary DESC\\n            ) AS rnk\\n        FROM\\n            employee e\\n            INNER JOIN Department d ON e.departmentid = d.id\\n    ) AS temp\\nWHERE\\n    rnk = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2225830,
                "title": "mysql-solution",
                "content": "```\\nSELECT\\n    dep.name AS `Department`,\\n    emp.name AS `Employee`,\\n    salary\\nFROM\\n    Employee emp\\nINNER JOIN\\n    Department dep\\n    ON\\n    dep.id = emp.departmentId\\nWHERE\\n    salary = (SELECT MAX(salary) FROM Employee WHERE departmentId = emp.departmentId GROUP BY departmentId);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    dep.name AS `Department`,\\n    emp.name AS `Employee`,\\n    salary\\nFROM\\n    Employee emp\\nINNER JOIN\\n    Department dep\\n    ON\\n    dep.id = emp.departmentId\\nWHERE\\n    salary = (SELECT MAX(salary) FROM Employee WHERE departmentId = emp.departmentId GROUP BY departmentId);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2202241,
                "title": "mysql-97-fastest-solution-dense-rank-partition-left-join",
                "content": "```\\n# Write your MySQL query statement below\\nselect Department,Employee,Salary from(\\nselect e.name as Employee, d.name as Department, e.salary, dense_rank() over(partition by departmentId order by salary DESC) as RNK from Employee e\\nLEFT JOIN Department d\\non e.departmentId = d.id\\ngroup by d.name,e.name\\norder by e.name\\n)a\\nwhere a.RNK =1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Department,Employee,Salary from(\\nselect e.name as Employee, d.name as Department, e.salary, dense_rank() over(partition by departmentId order by salary DESC) as RNK from Employee e\\nLEFT JOIN Department d\\non e.departmentId = d.id\\ngroup by d.name,e.name\\norder by e.name\\n)a\\nwhere a.RNK =1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2184936,
                "title": "elegant-sql",
                "content": "```\\nwith CTE (Department, DepartmentId, Salary) AS(\\n  select \\n    d.name, e.departmentId, max(e.salary) as Salary \\n  from Employee e \\n  join Department d on(d.id = e.departmentId) \\n  group by e.departmentId\\n) \\nSELECT \\n  CTE.Department, \\n  e.name as Employee, \\n  CTE.Salary \\nFROM CTE \\njoin Employee e on (\\n    e.salary = CTE.salary \\n    and e.departmentId = CTE.DepartmentId\\n  )\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nwith CTE (Department, DepartmentId, Salary) AS(\\n  select \\n    d.name, e.departmentId, max(e.salary) as Salary \\n  from Employee e \\n  join Department d on(d.id = e.departmentId) \\n  group by e.departmentId\\n) \\nSELECT \\n  CTE.Department, \\n  e.name as Employee, \\n  CTE.Salary \\nFROM CTE \\njoin Employee e on (\\n    e.salary = CTE.salary \\n    and e.departmentId = CTE.DepartmentId\\n  )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2183943,
                "title": "where-in-code",
                "content": "```\\nSELECT d.name as Department\\n      ,e.name as Employee\\n      ,e.salary \\nFROM Employee e\\n     LEFT JOIN Department d ON e.departmentid=d.id\\nWHERE (e.departmentid,e.salary) IN (\\n                                    SELECT departmentid\\n                                    ,MAX(salary) as salary\\n                                     FROM Employee  \\n                                     GROUP BY departmentid \\n                                     )",
                "solutionTags": [],
                "code": "```\\nSELECT d.name as Department\\n      ,e.name as Employee\\n      ,e.salary \\nFROM Employee e\\n     LEFT JOIN Department d ON e.departmentid=d.id\\nWHERE (e.departmentid,e.salary) IN (\\n                                    SELECT departmentid\\n                                    ,MAX(salary) as salary\\n                                     FROM Employee  \\n                                     GROUP BY departmentid \\n                                     )",
                "codeTag": "Unknown"
            },
            {
                "id": 2181142,
                "title": "quick-and-simple-solution",
                "content": "select c.name as Department,b.name as Employee, b.salary as Salary from\\n(select a.* from\\n(select id, name, salary, departmentid, rank() over(partition by departmentid order by salary desc) as rn from employee) a\\nwhere a.rn=1) b join department c\\non b.departmentid=c.id",
                "solutionTags": [],
                "code": "select c.name as Department,b.name as Employee, b.salary as Salary from\\n(select a.* from\\n(select id, name, salary, departmentid, rank() over(partition by departmentid order by salary desc) as rn from employee) a\\nwhere a.rn=1) b join department c\\non b.departmentid=c.id",
                "codeTag": "Unknown"
            },
            {
                "id": 2171434,
                "title": "use-dense-rank-to-solve-this-type-of-problems-n-highest",
                "content": "```\\nselect Department, Employee, salary as \\'Salary\\'\\nfrom (\\n    select e.name as \\'Employee\\', salary, d.name as \\'Department\\',\\n    dense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\'\\n    from Employee as e\\n    left join Department as d\\n    on departmentId = d.id\\n) as t\\nwhere t.rnk = 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect Department, Employee, salary as \\'Salary\\'\\nfrom (\\n    select e.name as \\'Employee\\', salary, d.name as \\'Department\\',\\n    dense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\'\\n    from Employee as e\\n    left join Department as d\\n    on departmentId = d.id\\n) as t\\nwhere t.rnk = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2066919,
                "title": "mysql-easy-to-understand",
                "content": "```\\nselect t1.Department, t1.Employee, t1.Salary\\nfrom\\n(select d.name as Department, e.name as Employee, e.salary as Salary\\n,RANK()OVER(partition by d.id order by salary desc) as rk\\nfrom Department AS d\\njoin Employee AS e on E.departmentId = d.id) as t1\\nwhere rk = 1\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect t1.Department, t1.Employee, t1.Salary\\nfrom\\n(select d.name as Department, e.name as Employee, e.salary as Salary\\n,RANK()OVER(partition by d.id order by salary desc) as rk\\nfrom Department AS d\\njoin Employee AS e on E.departmentId = d.id) as t1\\nwhere rk = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2032905,
                "title": "solution-using-two-join",
                "content": "WITH TEMP AS(\\n    SELECT  MAX(SALARY) AS SALARY, MAX(departmentId) AS DEPARRMENTID FROM EMPLOYEE\\n    GROUP BY departmentId\\n)\\nSELECT DISTINCT D.NAME AS \\'DEPARTMENT\\', E.NAME AS \\'EMPLOYEE\\', T.SALARY FROM EMPLOYEE E JOIN DEPARTMENT D\\nON E.departmentId = D.ID JOIN TEMP T\\nON T.DEPARRMENTID = D.ID\\nWHERE E.SALARY = T.SALARY AND T.DEPARRMENTID = D.ID\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "WITH TEMP AS(\\n    SELECT  MAX(SALARY) AS SALARY, MAX(departmentId) AS DEPARRMENTID FROM EMPLOYEE\\n    GROUP BY departmentId\\n)\\nSELECT DISTINCT D.NAME AS \\'DEPARTMENT\\', E.NAME AS \\'EMPLOYEE\\', T.SALARY FROM EMPLOYEE E JOIN DEPARTMENT D\\nON E.departmentId = D.ID JOIN TEMP T\\nON T.DEPARRMENTID = D.ID\\nWHERE E.SALARY = T.SALARY AND T.DEPARRMENTID = D.ID\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2030628,
                "title": "using-rank-function-and-a-cte",
                "content": "```\\n# Write your MySQL query statement below\\nwith cte as(\\nselect \\n    d.name as Department, \\n    e.name as Employee,\\n    e.salary as Salary,\\n    rank() over (partition by d.name order by e.salary desc) as rank_\\nfrom Employee e\\ninner join Department d on d.id=e.departmentId\\n    )\\n    \\nselect \\n    Department,\\n    Employee,\\n    Salary\\nfrom cte\\nwhere rank_=1",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte as(\\nselect \\n    d.name as Department, \\n    e.name as Employee,\\n    e.salary as Salary,\\n    rank() over (partition by d.name order by e.salary desc) as rank_\\nfrom Employee e\\ninner join Department d on d.id=e.departmentId\\n    )\\n    \\nselect \\n    Department,\\n    Employee,\\n    Salary\\nfrom cte\\nwhere rank_=1",
                "codeTag": "Unknown"
            },
            {
                "id": 2006022,
                "title": "mysql-solution",
                "content": "```\\nSELECT\\n    Department.name AS \\'Department\\',\\n    Employee.name AS \\'Employee\\',\\n    Salary\\nFROM\\n    Employee\\n        JOIN\\n    Department ON Employee.DepartmentId = Department.Id\\nWHERE\\n    (Employee.DepartmentId , Salary) IN\\n    (SELECT\\n         DepartmentId, MAX(Salary)\\n     FROM\\n         Employee\\n     GROUP BY DepartmentId\\n    );\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    Department.name AS \\'Department\\',\\n    Employee.name AS \\'Employee\\',\\n    Salary\\nFROM\\n    Employee\\n        JOIN\\n    Department ON Employee.DepartmentId = Department.Id\\nWHERE\\n    (Employee.DepartmentId , Salary) IN\\n    (SELECT\\n         DepartmentId, MAX(Salary)\\n     FROM\\n         Employee\\n     GROUP BY DepartmentId\\n    );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1986253,
                "title": "solution-using-window-function-dense-rank",
                "content": "```\\nselect rnk.Department as \\'Department\\',rnk.Employee as \\'Employee\\',rnk.Salary as \\'Salary\\' from\\n(select d.name as \\'Department\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',\\ndense_rank() over(partition by d.name order by e.salary desc) as rnk_id\\nfrom Employee e, Department d where d.id=e.departmentId) as rnk\\nwhere rnk.rnk_id=1; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect rnk.Department as \\'Department\\',rnk.Employee as \\'Employee\\',rnk.Salary as \\'Salary\\' from\\n(select d.name as \\'Department\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',\\ndense_rank() over(partition by d.name order by e.salary desc) as rnk_id\\nfrom Employee e, Department d where d.id=e.departmentId) as rnk\\nwhere rnk.rnk_id=1; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969708,
                "title": "mysql-solution",
                "content": "# Solution\\n```\\nSELECT Department, Employee, Salary\\nFROM (\\n    SELECT Department.name as Department, Employee.name as Employee, Salary, \\n    RANK() OVER(PARTITION BY Department.name ORDER BY Salary DESC) as rn\\n    FROM Employee\\n    inner join Department on Department.id = Employee.departmentId\\n) sub_select\\nWHERE rn = 1\\n```\\nThe **RANK()** function is a window function that assigns a rank to each row within a partition of a result set.\\nThe rows within a partition that have the same values will receive the same rank. The rank of the first row within a partition is one. The **RANK()** function adds the number of tied rows to the tied rank to calculate the rank of the next row, therefore, the ranks may not be consecutive.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Department, Employee, Salary\\nFROM (\\n    SELECT Department.name as Department, Employee.name as Employee, Salary, \\n    RANK() OVER(PARTITION BY Department.name ORDER BY Salary DESC) as rn\\n    FROM Employee\\n    inner join Department on Department.id = Employee.departmentId\\n) sub_select\\nWHERE rn = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1930376,
                "title": "fast-and-easy-mysql-using-group-by-and-subquery",
                "content": "SELECT de.name  Department,  emp.name  Employee, emp.salary  Salary\\nFROM\\nEmployee  emp\\nJOIN\\nDepartment  de\\nON\\nemp.departmentId = de.id\\nWHERE\\n(emp.departmentId,emp.salary)\\nIN(SELECT emp.departmentId,max(emp.salary)    FROM Employee emp GROUP BY emp.departmentId)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT de.name  Department,  emp.name  Employee, emp.salary  Salary\\nFROM\\nEmployee  emp\\nJOIN\\nDepartment  de\\nON\\nemp.departmentId = de.id\\nWHERE\\n(emp.departmentId,emp.salary)\\nIN(SELECT emp.departmentId,max(emp.salary)    FROM Employee emp GROUP BY emp.departmentId)",
                "codeTag": "Unknown"
            },
            {
                "id": 1929580,
                "title": "rank-window-function",
                "content": "SELECT Department, Employee, salary\\nFROM(\\nSELECT d.name AS `Department`, e.name AS `Employee`,\\n       e.salary,\\n       RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) AS rnk\\nFROM Employee e\\nLEFT JOIN Department d\\nON e.departmentID = d.id) t\\nWHERE rnk = 1;\\n\\n",
                "solutionTags": [],
                "code": "SELECT Department, Employee, salary\\nFROM(\\nSELECT d.name AS `Department`, e.name AS `Employee`,\\n       e.salary,\\n       RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) AS rnk\\nFROM Employee e\\nLEFT JOIN Department d\\nON e.departmentID = d.id) t\\nWHERE rnk = 1;\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1912926,
                "title": "mysql-faster-than-85-65-elegant-solution",
                "content": "```\\nSELECT \\n    t.Department,\\n    t.Employee,\\n    t.Salary\\nFROM (\\n    SELECT \\n        d.name AS Department, \\n        e.name AS Employee, \\n        e.salary AS Salary,\\n        DENSE_RANK() OVER(PARTITION BY d.id ORDER BY e.salary DESC) AS DenseRank\\n    FROM Employee AS e \\n    LEFT JOIN Department AS d ON e.departmentId = d.id\\n) AS t\\nWHERE t.DenseRank = 1;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/854b8248-4aa9-4937-b97f-4d780ef9b8ed_1649058444.234964.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    t.Department,\\n    t.Employee,\\n    t.Salary\\nFROM (\\n    SELECT \\n        d.name AS Department, \\n        e.name AS Employee, \\n        e.salary AS Salary,\\n        DENSE_RANK() OVER(PARTITION BY d.id ORDER BY e.salary DESC) AS DenseRank\\n    FROM Employee AS e \\n    LEFT JOIN Department AS d ON e.departmentId = d.id\\n) AS t\\nWHERE t.DenseRank = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1706284,
                "title": "using-dense-rank-in-mssql",
                "content": "select sl.Department, sl.Employee, sl.Salary\\nfrom\\n(select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary,\\nDENSE_RANK() OVER(Partition BY d.name order by e.salary desc) r\\nfrom Employee e\\nleft join Department d\\non e.departmentID=d.id) as sl\\nwhere sl.r=1",
                "solutionTags": [],
                "code": "select sl.Department, sl.Employee, sl.Salary\\nfrom\\n(select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary,\\nDENSE_RANK() OVER(Partition BY d.name order by e.salary desc) r\\nfrom Employee e\\nleft join Department d\\non e.departmentID=d.id) as sl\\nwhere sl.r=1",
                "codeTag": "Unknown"
            },
            {
                "id": 1698358,
                "title": "3-easiest-sqls",
                "content": "Classic [from the BigData world....]\\n```\\nWITH src AS\\n(\\n    SELECT MAX(e.salary)   AS salary\\n         , e.departmentId  AS departmentId\\n      FROM Employee e\\n     GROUP BY e.departmentId\\n)\\nSELECT d.name       AS Department\\n     , e.name       AS Employee\\n     , e.salary     AS Salary\\n  FROM employee   e\\n       INNER JOIN\\n       src\\n        ON e.salary       = src.salary\\n       AND e.departmentId = src.departmentId\\n       INNER JOIN\\n       department d\\n        ON e.departmentId = d.id\\n```\\nsecond idea\\n```\\nWITH src AS (\\n    SELECT d.name       AS Department\\n         , e.name       AS Employee\\n         , e.salary     AS Salary\\n         , RANK() OVER(PARTITION BY e.departmentId ORDER BY e.salary DESC) AS rn\\n      FROM employee   e\\n           INNER JOIN\\n           department d\\n            ON e.departmentId = d.id\\n)\\nSELECT s.Department\\n     , s.Employee\\n     , s.Salary\\n  FROM src s\\n WHERE s.rn = 1\\n```\\n3th idea\\n```\\nSELECT d.name       AS Department\\n     , e.name       AS Employee\\n     , e.salary     AS Salary\\n  FROM employee   e\\n       INNER JOIN\\n       department d\\n        ON e.departmentId = d.id\\n WHERE NOT EXISTS (\\n                    SELECT 1\\n                      FROM employee t\\n                     WHERE t.salary > e.salary\\n                       AND t.departmentId = e.departmentId\\n                  )\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nWITH src AS\\n(\\n    SELECT MAX(e.salary)   AS salary\\n         , e.departmentId  AS departmentId\\n      FROM Employee e\\n     GROUP BY e.departmentId\\n)\\nSELECT d.name       AS Department\\n     , e.name       AS Employee\\n     , e.salary     AS Salary\\n  FROM employee   e\\n       INNER JOIN\\n       src\\n        ON e.salary       = src.salary\\n       AND e.departmentId = src.departmentId\\n       INNER JOIN\\n       department d\\n        ON e.departmentId = d.id\\n```\n```\\nWITH src AS (\\n    SELECT d.name       AS Department\\n         , e.name       AS Employee\\n         , e.salary     AS Salary\\n         , RANK() OVER(PARTITION BY e.departmentId ORDER BY e.salary DESC) AS rn\\n      FROM employee   e\\n           INNER JOIN\\n           department d\\n            ON e.departmentId = d.id\\n)\\nSELECT s.Department\\n     , s.Employee\\n     , s.Salary\\n  FROM src s\\n WHERE s.rn = 1\\n```\n```\\nSELECT d.name       AS Department\\n     , e.name       AS Employee\\n     , e.salary     AS Salary\\n  FROM employee   e\\n       INNER JOIN\\n       department d\\n        ON e.departmentId = d.id\\n WHERE NOT EXISTS (\\n                    SELECT 1\\n                      FROM employee t\\n                     WHERE t.salary > e.salary\\n                       AND t.departmentId = e.departmentId\\n                  )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678227,
                "title": "department-highest-salary",
                "content": "SELECT D.NAME \"Department\", E1.NAME \"Employee\", E1.SALARY \"Salary\"\\nFROM EMPLOYEE E1 , DEPARTMENT D \\nWHERE (DEPARTMENTID , SALARY ) IN \\n(SELECT DEPARTMENTID , MAX(E.SALARY) FROM EMPLOYEE E GROUP BY E.DEPARTMENTID ) \\nAND E1.DEPARTMENTID = D.ID",
                "solutionTags": [],
                "code": "SELECT D.NAME \"Department\", E1.NAME \"Employee\", E1.SALARY \"Salary\"\\nFROM EMPLOYEE E1 , DEPARTMENT D \\nWHERE (DEPARTMENTID , SALARY ) IN \\n(SELECT DEPARTMENTID , MAX(E.SALARY) FROM EMPLOYEE E GROUP BY E.DEPARTMENTID ) \\nAND E1.DEPARTMENTID = D.ID",
                "codeTag": "Unknown"
            },
            {
                "id": 1660808,
                "title": "clear-solution-faster-than-76",
                "content": "```sql\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON e.departmentId = d.id\\nWHERE e.salary = (SELECT MAX(salary) FROM Employee WHERE departmentId = d.id)\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON e.departmentId = d.id\\nWHERE e.salary = (SELECT MAX(salary) FROM Employee WHERE departmentId = d.id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1656832,
                "title": "mssql-dense-rank",
                "content": "Logic:\\n\\nUse DENSE_RANK on salary in desc order and  partition on departmentId.\\nThen on where clause choose rank of 1\\n\\n```\\nSELECT d.name as Department, rs.name as Employee, rs.salary as Salary\\nfrom (\\nSELECT name, departmentId, salary,\\n        DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary desc) as ranking\\n    FROM Employee )rs JOIN Department d ON rs.departmentId = d.id\\nwhere ranking = 1\\n```\\n\\nRuntime: 1154 ms, faster than 54.89% of MS SQL Server online submissions for Department Highest Salary.\\n\\n",
                "solutionTags": [],
                "code": "```\\nSELECT d.name as Department, rs.name as Employee, rs.salary as Salary\\nfrom (\\nSELECT name, departmentId, salary,\\n        DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary desc) as ranking\\n    FROM Employee )rs JOIN Department d ON rs.departmentId = d.id\\nwhere ranking = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581914,
                "title": "solution-using-join-and-window-functions",
                "content": "```\\nWITH CTE AS \\n(\\n    SELECT DEPARTMENT.name as DEPARTMENT, EMPLOYEE.name AS Employee, EMPLOYEE.salary AS SALARY FROM EMPLOYEE LEFT JOIN DEPARTMENT ON EMPLOYEE.departmentID = DEPARTMENT.id\\n)\\n\\nSELECT DEPARTMENT, EMPLOYEE, SALARY FROM\\n(\\nSELECT DEPARTMENT, EMPLOYEE, SALARY, DENSE_RANK() OVER (PARTITION BY DEPARTMENT ORDER BY SALARY DESC) AS RANK_DESC FROM CTE\\n) a\\nWHERE RANK_DESC = 1;\\n\\n```\\n\\nThe logic here is, I first join the tables, with only the data I care about. The joined table is stored in a form of a Common Table Expression, and the names in the select query correspond to their respective columns. \\n\\nThen, we select the correct value from the sub-query, and make sure we partition over `DEPARTMENT` and we order the salaries in a descending order. \\n\\nOne very useful feature of this solution is you can extend this to the problem for finding the top 3 salaries by just modifying the last statement to `<= 3` instead of `=1`.",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nWITH CTE AS \\n(\\n    SELECT DEPARTMENT.name as DEPARTMENT, EMPLOYEE.name AS Employee, EMPLOYEE.salary AS SALARY FROM EMPLOYEE LEFT JOIN DEPARTMENT ON EMPLOYEE.departmentID = DEPARTMENT.id\\n)\\n\\nSELECT DEPARTMENT, EMPLOYEE, SALARY FROM\\n(\\nSELECT DEPARTMENT, EMPLOYEE, SALARY, DENSE_RANK() OVER (PARTITION BY DEPARTMENT ORDER BY SALARY DESC) AS RANK_DESC FROM CTE\\n) a\\nWHERE RANK_DESC = 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1558035,
                "title": "simple-group-by-mysql",
                "content": "```\\nselect a1.department, a1.employee, a1.salary\\nfrom (select t1.name as employee, salary, departmentID, t2.name as department\\n      from employee as t1\\n      left join department as t2\\n      on t1.departmentID = t2.id) as a1 \\n      \\ninner join (select id, name, max(salary) as max_salary\\n            from (select tt1.id, tt1.name, salary\\n                  from department as tt1\\n                  left join employee as tt2\\n                  on tt1.id = tt2.departmentID) as tt0\\n            group by id, name) as a2\\non a1.departmentID = a2.id\\nand a1.salary = a2.max_salary\\n```",
                "solutionTags": [],
                "code": "```\\nselect a1.department, a1.employee, a1.salary\\nfrom (select t1.name as employee, salary, departmentID, t2.name as department\\n      from employee as t1\\n      left join department as t2\\n      on t1.departmentID = t2.id) as a1 \\n      \\ninner join (select id, name, max(salary) as max_salary\\n            from (select tt1.id, tt1.name, salary\\n                  from department as tt1\\n                  left join employee as tt2\\n                  on tt1.id = tt2.departmentID) as tt0\\n            group by id, name) as a2\\non a1.departmentID = a2.id\\nand a1.salary = a2.max_salary\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1548394,
                "title": "simple-mysql-solution",
                "content": "```\\nselect d.name as Department,e.name as Employee,e.salary as Salary\\nfrom employee as e,department as d\\nwhere e.departmentId=d.id and\\n(departmentId,salary) in\\n(select departmentId,max(salary) from employee group by departmentId);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect d.name as Department,e.name as Employee,e.salary as Salary\\nfrom employee as e,department as d\\nwhere e.departmentId=d.id and\\n(departmentId,salary) in\\n(select departmentId,max(salary) from employee group by departmentId);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1545506,
                "title": "simple-solution",
                "content": "\\n```\\nselect d.name as Department,R.name as Employee,R.salary as Salary \\nfrom \\n(select name,salary,departmentId \\n from employee \\n where (departmentId,salary) \\n in(select departmentId,max(salary) \\n    from employee group by departmentId)) as r,\\nDepartment as d \\nwhere R.departmentId = d.id;\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect d.name as Department,R.name as Employee,R.salary as Salary \\nfrom \\n(select name,salary,departmentId \\n from employee \\n where (departmentId,salary) \\n in(select departmentId,max(salary) \\n    from employee group by departmentId)) as r,\\nDepartment as d \\nwhere R.departmentId = d.id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1545332,
                "title": "2-step-basic-solution-for-beginners",
                "content": "# Two Step Solution\\n### **1.**Find highest salary using group by on departmentId present in Employee Table.\\n**Solution**\\n* ` select name,salary,departmentId from employee where (departmentId,salary) in(select departmentId,max(salary) from employee group by departmentId)`*\\n### **2**.Since the solution contain the Department name which is present in other table so we have join these two table( **table obtained in Step 1 and Department Table** ) in order to fetch the Department name.\\n**Final Solution**\\n```\\nselect d.name as Department,R.name as Employee,R.salary as Salary from \\n(select name,salary,departmentId from employee where (departmentId,salary) in(select departmentId,max(salary) from employee group by departmentId)) as r,\\nDepartment as d where R.departmentId = d.id;\\n```\\n**:-;** Thank You",
                "solutionTags": [],
                "code": "```\\nselect d.name as Department,R.name as Employee,R.salary as Salary from \\n(select name,salary,departmentId from employee where (departmentId,salary) in(select departmentId,max(salary) from employee group by departmentId)) as r,\\nDepartment as d where R.departmentId = d.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1511880,
                "title": "faster-than-99-6",
                "content": "SELECT t.Department, t.Employee, t.Salary\\nFROM (SELECT d.Name AS Department, e.Name AS Employee, Salary,\\n              MAX(Salary) OVER(PARTITION BY d.Id) \"MaxSalary\"\\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON e.DepartmentId = d.Id) AS t\\nWHERE t.Salary = t.MaxSalary;",
                "solutionTags": [],
                "code": "SELECT t.Department, t.Employee, t.Salary\\nFROM (SELECT d.Name AS Department, e.Name AS Employee, Salary,\\n              MAX(Salary) OVER(PARTITION BY d.Id) \"MaxSalary\"\\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON e.DepartmentId = d.Id) AS t\\nWHERE t.Salary = t.MaxSalary;",
                "codeTag": "Unknown"
            },
            {
                "id": 1498822,
                "title": "simple-inner-join-accepted-solution",
                "content": "```\\n(SELECT D.Name as Department,E.Name as Employee,e.Salary As Salary\\nFROM EMPLOYEE AS E INNER JOIN DEPARTMENT AS D \\nON D.Id = E.DepartmentId \\nGROUP BY D.Id, E.Name, E.Salary\\nhaving E.salary >= (select max(salary) from Employee where DepartmentId = D.Id))\\n\\n#naveen Kumar Vadlamudi\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n(SELECT D.Name as Department,E.Name as Employee,e.Salary As Salary\\nFROM EMPLOYEE AS E INNER JOIN DEPARTMENT AS D \\nON D.Id = E.DepartmentId \\nGROUP BY D.Id, E.Name, E.Salary\\nhaving E.salary >= (select max(salary) from Employee where DepartmentId = D.Id))\\n\\n#naveen Kumar Vadlamudi\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1458505,
                "title": "using-sub-query",
                "content": "```\\n# Write your MySQL query statement below\\nSelect Department.Name as Department, \\n       e1.Name as Employee, \\n       e1.Salary \\nfrom Employee e1 \\njoin Department d on e1.DepartmentId = d.Id\\n\\nwhere e1.Salary = \\n    (Select Max(Salary) \\n     from Employee e2 \\n     where e2.DepartmentId = e1.DepartmentId)\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSelect Department.Name as Department, \\n       e1.Name as Employee, \\n       e1.Salary \\nfrom Employee e1 \\njoin Department d on e1.DepartmentId = d.Id\\n\\nwhere e1.Salary = \\n    (Select Max(Salary) \\n     from Employee e2 \\n     where e2.DepartmentId = e1.DepartmentId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1448447,
                "title": "can-anyone-tell-me-why-this-code-is-wrong-confused",
                "content": "```\\nselect d.name as department, e.name as employee, e.salary\\nfrom employee e, department d\\nwhere e.departmentid = d.id\\ngroup by e.departmentid\\nhaving e.salary = max(e.salary)\\n```",
                "solutionTags": [],
                "code": "```\\nselect d.name as department, e.name as employee, e.salary\\nfrom employee e, department d\\nwhere e.departmentid = d.id\\ngroup by e.departmentid\\nhaving e.salary = max(e.salary)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1441911,
                "title": "184-department-highest-salary-step-by-step-solution-with-comments",
                "content": "\\n# 1. get the highest salary department wise \\n\\n#   SELECT DepartmentId,MAX(Salary)\\n#   FROM Employee\\n#   GROUP BY DepartmentId\\n\\n# WILL UTILISE IT AS SUBQUERY IN 3\\n\\n# 2.\\n#IN OUTPUT WE WANT Department, Employee, Salary\\n# SO WE WILL JOIN TABLE Employee and Department\\n\\n#SELECT Department.Name AS Department, Employee.Name  AS Employee, Employee.Salary AS Salary\\n#FROM Employee JOIN Department ON Employee.DepartmentId =Department.ID \\n\\n# 3. IN 1 we have max salary department wise, in 2 we have joined 2 tables lets combine thwse 2 to get results\\n# for combining it we will use condition in where\\n#########.  FINAL SOLUTION ###################\\n\\nSELECT Department.Name AS Department, Employee.Name  AS Employee, Employee.Salary AS Salary\\nFROM Employee JOIN Department ON Employee.DepartmentId =Department.ID \\nWHERE (DepartmentId, Salary)  IN \\n(\\nSELECT DepartmentId,MAX(Salary)\\nFROM Employee\\nGROUP BY DepartmentId\\n)\\n###############################################",
                "solutionTags": [],
                "code": "\\n# 1. get the highest salary department wise \\n\\n#   SELECT DepartmentId,MAX(Salary)\\n#   FROM Employee\\n#   GROUP BY DepartmentId\\n\\n# WILL UTILISE IT AS SUBQUERY IN 3\\n\\n# 2.\\n#IN OUTPUT WE WANT Department, Employee, Salary\\n# SO WE WILL JOIN TABLE Employee and Department\\n\\n#SELECT Department.Name AS Department, Employee.Name  AS Employee, Employee.Salary AS Salary\\n#FROM Employee JOIN Department ON Employee.DepartmentId =Department.ID \\n\\n# 3. IN 1 we have max salary department wise, in 2 we have joined 2 tables lets combine thwse 2 to get results\\n# for combining it we will use condition in where\\n#########.  FINAL SOLUTION ###################\\n\\nSELECT Department.Name AS Department, Employee.Name  AS Employee, Employee.Salary AS Salary\\nFROM Employee JOIN Department ON Employee.DepartmentId =Department.ID \\nWHERE (DepartmentId, Salary)  IN \\n(\\nSELECT DepartmentId,MAX(Salary)\\nFROM Employee\\nGROUP BY DepartmentId\\n)\\n###############################################",
                "codeTag": "Unknown"
            },
            {
                "id": 1424701,
                "title": "mssql-using-join-and-subquery-simple-and-fast",
                "content": "```Select d1.Name as Department, e1.Name as Employee, e1.Salary as Salary ```\\n```from Department d1```\\n```inner join Employee e1 on d1.Id = e1.DepartmentId```\\n```where e1.Salary in```\\n```(```\\n    ```select max(e2.Salary)```\\n   ```from Employee e2```\\n   ``` where e2.DepartmentId = d1.Id```\\n```)```",
                "solutionTags": [],
                "code": "```Select d1.Name as Department, e1.Name as Employee, e1.Salary as Salary ```\n```from Department d1```\n```inner join Employee e1 on d1.Id = e1.DepartmentId```\n```where e1.Salary in```\n```(```\n```select max(e2.Salary)```\n```from Employee e2```\n``` where e2.DepartmentId = d1.Id```\n```)```",
                "codeTag": "Unknown"
            },
            {
                "id": 1401604,
                "title": "simple-solution-without-rank-or-dense-rank",
                "content": "```\\nSELECT D.Name AS Department ,E.Name AS Employee ,E.Salary \\nfrom Employee E, Department D \\nWHERE E.DepartmentId = D.id \\nAND (DepartmentId,Salary) in \\n(SELECT DepartmentId,max(Salary) FROM Employee GROUP BY DepartmentId)",
                "solutionTags": [],
                "code": "```\\nSELECT D.Name AS Department ,E.Name AS Employee ,E.Salary \\nfrom Employee E, Department D \\nWHERE E.DepartmentId = D.id \\nAND (DepartmentId,Salary) in \\n(SELECT DepartmentId,max(Salary) FROM Employee GROUP BY DepartmentId)",
                "codeTag": "Unknown"
            },
            {
                "id": 1401034,
                "title": "simplest-solution-using-dense-rank",
                "content": "```\\n# Write your MySQL query statement below\\nselect \\n        Department,Employee,Salary\\n        from (\\n                select\\n                    D.Name as Department,\\n                    E.Name as Employee,\\n                    E.Salary AS Salary, \\n                    dense_rank() over(\\n                                        partition by E.DepartmentID \\n                                        order by Salary DESC\\n                                        ) as R\\n                    from Employee E , Department D \\n                    Where E.DepartmentId = D.Id\\n            ) as TMP \\n        where TMP.R = 1",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\n        Department,Employee,Salary\\n        from (\\n                select\\n                    D.Name as Department,\\n                    E.Name as Employee,\\n                    E.Salary AS Salary, \\n                    dense_rank() over(\\n                                        partition by E.DepartmentID \\n                                        order by Salary DESC\\n                                        ) as R\\n                    from Employee E , Department D \\n                    Where E.DepartmentId = D.Id\\n            ) as TMP \\n        where TMP.R = 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1373195,
                "title": "ms-sql-simple-solution",
                "content": "```\\nwith temp as \\n(select DepartmentId\\n      ,Name\\n      ,salary\\n      ,dense_rank() over (Partition by DepartmentID order by Salary desc) as rank\\nfrom employee\\n)      \\n\\nselect D.Name as Department,temp.name as employee,temp.salary\\nfrom temp \\njoin Department D\\non D.id = temp.DepartmentId\\nwhere rank = 1\\norder by DepartmentId,Salary",
                "solutionTags": [],
                "code": "```\\nwith temp as \\n(select DepartmentId\\n      ,Name\\n      ,salary\\n      ,dense_rank() over (Partition by DepartmentID order by Salary desc) as rank\\nfrom employee\\n)      \\n\\nselect D.Name as Department,temp.name as employee,temp.salary\\nfrom temp \\njoin Department D\\non D.id = temp.DepartmentId\\nwhere rank = 1\\norder by DepartmentId,Salary",
                "codeTag": "Unknown"
            },
            {
                "id": 1359106,
                "title": "simple-code-with-ravi-department-highest-sallary-sql",
                "content": "# Write your MySQL query statement below\\n```\\nselect d.name department,e.name employee ,e.salary salary from employee e,department d where e.departmentid=d.id and\\ne.salary=(select max(distinct salary) from employee group by departmentid having departmentid=e.departmentid);  \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect d.name department,e.name employee ,e.salary salary from employee e,department d where e.departmentid=d.id and\\ne.salary=(select max(distinct salary) from employee group by departmentid having departmentid=e.departmentid);  \\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1575029,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1570374,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1576810,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1574371,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1575588,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1723282,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1576527,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1574884,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1573400,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1573177,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1575029,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1570374,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1576810,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1574371,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1575588,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1723282,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1576527,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1574884,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1573400,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 1573177,
                "content": [
                    {
                        "username": "tr1328",
                        "content": "\\'\\'\\'\\nSELECT D.Name as Department, E.Name as Employee, Salary FROM Employee E inner join Department D on E.DepartmentId = D.Id WHERE (DepartmentId,Salary) in(SELECT DepartmentId, MAX(Salary) FROM Employee group by DepartmentId)\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "this is not good because problem not limit total result, so you don\\'t have to include departmentId in query result\\n# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n"
                    },
                    {
                        "username": "JYu89828",
                        "content": "\\t/* Write your T-SQL query statement below */\\n\\tselect c.Department, c.Employee, c.Salary\\n\\tfrom\\n\\t(select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\n\\tfrom Employee e join Department d on e.DepartmentId=d.Id) as c\\n\\twhere rank=1\\n"
                    },
                    {
                        "username": "AbdelrahmanDwedar",
                        "content": "you don\\'t need to make a rank for it, you could just use the max() function in this case."
                    },
                    {
                        "username": "pratibhaga8",
                        "content": "[@hailing_liu](/hailing_liu) not working ...subquery is not working"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "When I change the last sentense to \"where c.rank=1\", it works. "
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect d.Name as Department, e.Name as Employee, e.salary as salary \\nfrom Employee e , Department d \\nwhere \\n       e.DepartmentId = d.Id\\nand \\n      (e.DepartmentId, e.Salary)  in \\n  (select e.DepartmentId, max(e.Salary) from Employee e group by e.DepartmentId);\\n\\n"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT d.Name AS Department, e.Name As Employee, e.Salary AS Salary\\nFROM Employee AS e\\nLEFT JOIN Department AS d\\nON e.DepartmentId = d.Id\\nWHERE (d.Id, e.Salary) in (SELECT DepartmentId, max(Salary)\\n                          FROM Employee\\n                          GROUP BY DepartmentId)\\n;\\n"
                    },
                    {
                        "username": "obence09",
                        "content": "The task says thet the row order does not matter.\\nMy Query works but it fails to pass the test due to the fact thet in my query the order of the rows are different than in the result set but the result is the same....\\nPlease fix this!!\\n\\n\\'\\'\\'SELECT d.Name AS \\'Department\\',e.Name AS \\'Emloyee\\', e.Salary   \\nFROM (SELECT Name, Salary, DepartmentId,\\n      dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS \\'rank\\' FROM Employee) AS e \\nJOIN Department AS d ON e.DepartmentId = d.Id\\nWHERE e.rank = 1;\\'\\'\\'\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\\nrank() over(partition by e.departmentId order by salary desc) as rn\\nfrom Employee e\\njoin Department d\\non e.departmentId = d.id\\norder by e.id\\n) sq\\nwhere sq.rn = 1"
                    },
                    {
                        "username": "vineetatrivedi",
                        "content": "\\'\\'\\'\\n;with cte \\nas (\\nSelect max(salary) salary , departmentid, d.name departmentname\\nfrom Employee e \\ninner join department d on e.departmentid =d.id\\ngroup by e.departmentid, d.name\\n)\\nselect departmentname department, e.name Employee , e.Salary\\nfrom employee e\\ninner join cte on e.departmentid =cte.departmentid\\n                and cte.salary =e.salary\\n\\'\\'\\'"
                    },
                    {
                        "username": "adxyadxy",
                        "content": "\\nselect Department, name as \"Employee\",  salary as \"Salary\" from \\n(select d.name as \"Department\", e.salary, e.name, dense_rank() over (partition by e.departmentid order by e.salary desc) as salary_rank \\nfrom employee e\\ninner join department d on e.departmentid=d.id) as temp\\nwhere salary_rank=1"
                    },
                    {
                        "username": "SolmanRaj",
                        "content": "Thank You it Helped me.."
                    },
                    {
                        "username": "mymay",
                        "content": "\\'\\'\\'\\nselect D.Name Department, E.Name Employee, E.Salary from Employee E, Department D\\nwhere E.DepartmentId = D.Id and (DepartmentId, Salary) in \\n(select DepartmentId, max(Salary) from Employee\\n group by DepartmentId)\\n \\'\\'\\'"
                    },
                    {
                        "username": "faisal0901",
                        "content": "little bit confusing where the JOIN ?\\n"
                    },
                    {
                        "username": "Adamevans",
                        "content": "with max as \\n(select max(salary) as maxSalary,\\ndepartmentId\\nfrom Employee e\\ngroup by DepartmentId)\\n\\nselect d.name as Department,\\ne.name as Employee,\\ne.Salary from\\nEmployee e \\ninner join department d on d.id = e.DepartmentId\\nwhere e.salary in (select maxSalary from max where departmentId = e.departmentId)"
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "WITH CTE AS\\n(\\n    Select d.name as Department,e.name as Employee,e.salary as Salary,\\n    dense_rank() over (partition by d.name order by e.salary desc) as rnk \\n     from Employee e\\n    left join Department d\\n    on e.departmentId = d.id\\n)\\n\\nSelect Department,Employee,Salary from CTE where rnk = 1\\n"
                    }
                ]
            },
            {
                "id": 2072043,
                "content": [
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL using subqueries:\\n\\n/* Write your T-SQL query statement below */\\n\\nSELECT Department.name AS Department, Employee.name AS Employee, Employee.salary AS Salary FROM\\n((SELECT departmentId, MAX(salary) AS maxSalary FROM Employee GROUP BY departmentId) sub LEFT JOIN Employee on sub.maxSalary = Employee.salary AND sub.departmentId = Employee.departmentId)  INNER JOIN Department ON Employee.departmentId = Department.id;"
                    },
                    {
                        "username": "aryan1113",
                        "content": "Why is the discussion section flooded with solutions :/"
                    },
                    {
                        "username": "Jasskaran0007",
                        "content": "While doing this question I came across a very important concept of GROUP BY clause, which can be ignored when first time coming across the GROUP BY clause, which is, that the columns which are not included in the GROUP BY clause must be a part of aggregate functions like MAX, MIN, SUM, AVG, otherwise it can lead to an error.\\nWhich means queries like, \\nSELECT Department.name AS Department, Employee.name AS Employee, MAX(salary) AS Salary FROM Employee JOIN Department ON Employee.departmentId=Department.id GROUP BY Department.id.\\nwont work.\\n\\n\\nHope I am not the only one."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Always remember, programming is just like life. It might seem hard at first, but every mistake is an opportunity to learn and grow. Don\\'t be discouraged by errors or unexpected results. Just keep trying, and with each attempt, you\\'re getting closer to your goal. The sky is the limit, so dream big and keep coding!\"\\n- Barbie"
                    },
                    {
                        "username": "shouvik32",
                        "content": "#VERY Easy to UNDERSTAND\\n#UPVOTE IF YOU LIKE \\n\\nSELECT Department.name AS Department,Employee.name AS Employee,salary\\nFROM Employee\\nINNER JOIN Department ON Employee.departmentId=Department.id \\nWHERE(departmentId,Salary) IN \\n(\\nSELECT departmentId, MAX(Salary) FROM Employee\\nGROUP BY departmentId\\n)"
                    },
                    {
                        "username": "alfej136",
                        "content": "did anyone had written the query in T-SQL ? if yes then can you please reply the answer...."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT RANK () OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS rank, e.name AS Employee, d.name AS Department, e.salary AS Salary\\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON e.departmentid = d.id)\\n\\nSELECT Employee, Department, Salary\\nFROM CTE\\nWHERE rank = 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n)"
                    },
                    {
                        "username": "user8428J",
                        "content": "select d.name as Department,e.Employee,e.Salary\\nfrom\\n((select name as Employee,departmentId, Salary, rank() over(partition by departmentId order by salary desc) as \\'rank\\'\\nfrom employee) as e inner join department as d\\non e.departmentId = d.id)\\nwhere e.rank=1\\norder by e.rank"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n  select b.name as dept,a.name,a.salary from Employee a inner join Department b on a.departmentId = b.id\\n),\\ncte1 as(\\n  select *, dense_rank() over(partition by dept order by salary desc) as rnk from cte\\n)\\n\\nselect dept as Department, name as Employee, salary from cte1 where rnk = 1;"
                    }
                ]
            },
            {
                "id": 2025116,
                "content": [
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL using subqueries:\\n\\n/* Write your T-SQL query statement below */\\n\\nSELECT Department.name AS Department, Employee.name AS Employee, Employee.salary AS Salary FROM\\n((SELECT departmentId, MAX(salary) AS maxSalary FROM Employee GROUP BY departmentId) sub LEFT JOIN Employee on sub.maxSalary = Employee.salary AND sub.departmentId = Employee.departmentId)  INNER JOIN Department ON Employee.departmentId = Department.id;"
                    },
                    {
                        "username": "aryan1113",
                        "content": "Why is the discussion section flooded with solutions :/"
                    },
                    {
                        "username": "Jasskaran0007",
                        "content": "While doing this question I came across a very important concept of GROUP BY clause, which can be ignored when first time coming across the GROUP BY clause, which is, that the columns which are not included in the GROUP BY clause must be a part of aggregate functions like MAX, MIN, SUM, AVG, otherwise it can lead to an error.\\nWhich means queries like, \\nSELECT Department.name AS Department, Employee.name AS Employee, MAX(salary) AS Salary FROM Employee JOIN Department ON Employee.departmentId=Department.id GROUP BY Department.id.\\nwont work.\\n\\n\\nHope I am not the only one."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Always remember, programming is just like life. It might seem hard at first, but every mistake is an opportunity to learn and grow. Don\\'t be discouraged by errors or unexpected results. Just keep trying, and with each attempt, you\\'re getting closer to your goal. The sky is the limit, so dream big and keep coding!\"\\n- Barbie"
                    },
                    {
                        "username": "shouvik32",
                        "content": "#VERY Easy to UNDERSTAND\\n#UPVOTE IF YOU LIKE \\n\\nSELECT Department.name AS Department,Employee.name AS Employee,salary\\nFROM Employee\\nINNER JOIN Department ON Employee.departmentId=Department.id \\nWHERE(departmentId,Salary) IN \\n(\\nSELECT departmentId, MAX(Salary) FROM Employee\\nGROUP BY departmentId\\n)"
                    },
                    {
                        "username": "alfej136",
                        "content": "did anyone had written the query in T-SQL ? if yes then can you please reply the answer...."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT RANK () OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS rank, e.name AS Employee, d.name AS Department, e.salary AS Salary\\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON e.departmentid = d.id)\\n\\nSELECT Employee, Department, Salary\\nFROM CTE\\nWHERE rank = 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n)"
                    },
                    {
                        "username": "user8428J",
                        "content": "select d.name as Department,e.Employee,e.Salary\\nfrom\\n((select name as Employee,departmentId, Salary, rank() over(partition by departmentId order by salary desc) as \\'rank\\'\\nfrom employee) as e inner join department as d\\non e.departmentId = d.id)\\nwhere e.rank=1\\norder by e.rank"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n  select b.name as dept,a.name,a.salary from Employee a inner join Department b on a.departmentId = b.id\\n),\\ncte1 as(\\n  select *, dense_rank() over(partition by dept order by salary desc) as rnk from cte\\n)\\n\\nselect dept as Department, name as Employee, salary from cte1 where rnk = 1;"
                    }
                ]
            },
            {
                "id": 2016757,
                "content": [
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL using subqueries:\\n\\n/* Write your T-SQL query statement below */\\n\\nSELECT Department.name AS Department, Employee.name AS Employee, Employee.salary AS Salary FROM\\n((SELECT departmentId, MAX(salary) AS maxSalary FROM Employee GROUP BY departmentId) sub LEFT JOIN Employee on sub.maxSalary = Employee.salary AND sub.departmentId = Employee.departmentId)  INNER JOIN Department ON Employee.departmentId = Department.id;"
                    },
                    {
                        "username": "aryan1113",
                        "content": "Why is the discussion section flooded with solutions :/"
                    },
                    {
                        "username": "Jasskaran0007",
                        "content": "While doing this question I came across a very important concept of GROUP BY clause, which can be ignored when first time coming across the GROUP BY clause, which is, that the columns which are not included in the GROUP BY clause must be a part of aggregate functions like MAX, MIN, SUM, AVG, otherwise it can lead to an error.\\nWhich means queries like, \\nSELECT Department.name AS Department, Employee.name AS Employee, MAX(salary) AS Salary FROM Employee JOIN Department ON Employee.departmentId=Department.id GROUP BY Department.id.\\nwont work.\\n\\n\\nHope I am not the only one."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Always remember, programming is just like life. It might seem hard at first, but every mistake is an opportunity to learn and grow. Don\\'t be discouraged by errors or unexpected results. Just keep trying, and with each attempt, you\\'re getting closer to your goal. The sky is the limit, so dream big and keep coding!\"\\n- Barbie"
                    },
                    {
                        "username": "shouvik32",
                        "content": "#VERY Easy to UNDERSTAND\\n#UPVOTE IF YOU LIKE \\n\\nSELECT Department.name AS Department,Employee.name AS Employee,salary\\nFROM Employee\\nINNER JOIN Department ON Employee.departmentId=Department.id \\nWHERE(departmentId,Salary) IN \\n(\\nSELECT departmentId, MAX(Salary) FROM Employee\\nGROUP BY departmentId\\n)"
                    },
                    {
                        "username": "alfej136",
                        "content": "did anyone had written the query in T-SQL ? if yes then can you please reply the answer...."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT RANK () OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS rank, e.name AS Employee, d.name AS Department, e.salary AS Salary\\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON e.departmentid = d.id)\\n\\nSELECT Employee, Department, Salary\\nFROM CTE\\nWHERE rank = 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n)"
                    },
                    {
                        "username": "user8428J",
                        "content": "select d.name as Department,e.Employee,e.Salary\\nfrom\\n((select name as Employee,departmentId, Salary, rank() over(partition by departmentId order by salary desc) as \\'rank\\'\\nfrom employee) as e inner join department as d\\non e.departmentId = d.id)\\nwhere e.rank=1\\norder by e.rank"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n  select b.name as dept,a.name,a.salary from Employee a inner join Department b on a.departmentId = b.id\\n),\\ncte1 as(\\n  select *, dense_rank() over(partition by dept order by salary desc) as rnk from cte\\n)\\n\\nselect dept as Department, name as Employee, salary from cte1 where rnk = 1;"
                    }
                ]
            },
            {
                "id": 2004439,
                "content": [
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL using subqueries:\\n\\n/* Write your T-SQL query statement below */\\n\\nSELECT Department.name AS Department, Employee.name AS Employee, Employee.salary AS Salary FROM\\n((SELECT departmentId, MAX(salary) AS maxSalary FROM Employee GROUP BY departmentId) sub LEFT JOIN Employee on sub.maxSalary = Employee.salary AND sub.departmentId = Employee.departmentId)  INNER JOIN Department ON Employee.departmentId = Department.id;"
                    },
                    {
                        "username": "aryan1113",
                        "content": "Why is the discussion section flooded with solutions :/"
                    },
                    {
                        "username": "Jasskaran0007",
                        "content": "While doing this question I came across a very important concept of GROUP BY clause, which can be ignored when first time coming across the GROUP BY clause, which is, that the columns which are not included in the GROUP BY clause must be a part of aggregate functions like MAX, MIN, SUM, AVG, otherwise it can lead to an error.\\nWhich means queries like, \\nSELECT Department.name AS Department, Employee.name AS Employee, MAX(salary) AS Salary FROM Employee JOIN Department ON Employee.departmentId=Department.id GROUP BY Department.id.\\nwont work.\\n\\n\\nHope I am not the only one."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Always remember, programming is just like life. It might seem hard at first, but every mistake is an opportunity to learn and grow. Don\\'t be discouraged by errors or unexpected results. Just keep trying, and with each attempt, you\\'re getting closer to your goal. The sky is the limit, so dream big and keep coding!\"\\n- Barbie"
                    },
                    {
                        "username": "shouvik32",
                        "content": "#VERY Easy to UNDERSTAND\\n#UPVOTE IF YOU LIKE \\n\\nSELECT Department.name AS Department,Employee.name AS Employee,salary\\nFROM Employee\\nINNER JOIN Department ON Employee.departmentId=Department.id \\nWHERE(departmentId,Salary) IN \\n(\\nSELECT departmentId, MAX(Salary) FROM Employee\\nGROUP BY departmentId\\n)"
                    },
                    {
                        "username": "alfej136",
                        "content": "did anyone had written the query in T-SQL ? if yes then can you please reply the answer...."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT RANK () OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS rank, e.name AS Employee, d.name AS Department, e.salary AS Salary\\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON e.departmentid = d.id)\\n\\nSELECT Employee, Department, Salary\\nFROM CTE\\nWHERE rank = 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n)"
                    },
                    {
                        "username": "user8428J",
                        "content": "select d.name as Department,e.Employee,e.Salary\\nfrom\\n((select name as Employee,departmentId, Salary, rank() over(partition by departmentId order by salary desc) as \\'rank\\'\\nfrom employee) as e inner join department as d\\non e.departmentId = d.id)\\nwhere e.rank=1\\norder by e.rank"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n  select b.name as dept,a.name,a.salary from Employee a inner join Department b on a.departmentId = b.id\\n),\\ncte1 as(\\n  select *, dense_rank() over(partition by dept order by salary desc) as rnk from cte\\n)\\n\\nselect dept as Department, name as Employee, salary from cte1 where rnk = 1;"
                    }
                ]
            },
            {
                "id": 1993143,
                "content": [
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL using subqueries:\\n\\n/* Write your T-SQL query statement below */\\n\\nSELECT Department.name AS Department, Employee.name AS Employee, Employee.salary AS Salary FROM\\n((SELECT departmentId, MAX(salary) AS maxSalary FROM Employee GROUP BY departmentId) sub LEFT JOIN Employee on sub.maxSalary = Employee.salary AND sub.departmentId = Employee.departmentId)  INNER JOIN Department ON Employee.departmentId = Department.id;"
                    },
                    {
                        "username": "aryan1113",
                        "content": "Why is the discussion section flooded with solutions :/"
                    },
                    {
                        "username": "Jasskaran0007",
                        "content": "While doing this question I came across a very important concept of GROUP BY clause, which can be ignored when first time coming across the GROUP BY clause, which is, that the columns which are not included in the GROUP BY clause must be a part of aggregate functions like MAX, MIN, SUM, AVG, otherwise it can lead to an error.\\nWhich means queries like, \\nSELECT Department.name AS Department, Employee.name AS Employee, MAX(salary) AS Salary FROM Employee JOIN Department ON Employee.departmentId=Department.id GROUP BY Department.id.\\nwont work.\\n\\n\\nHope I am not the only one."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Always remember, programming is just like life. It might seem hard at first, but every mistake is an opportunity to learn and grow. Don\\'t be discouraged by errors or unexpected results. Just keep trying, and with each attempt, you\\'re getting closer to your goal. The sky is the limit, so dream big and keep coding!\"\\n- Barbie"
                    },
                    {
                        "username": "shouvik32",
                        "content": "#VERY Easy to UNDERSTAND\\n#UPVOTE IF YOU LIKE \\n\\nSELECT Department.name AS Department,Employee.name AS Employee,salary\\nFROM Employee\\nINNER JOIN Department ON Employee.departmentId=Department.id \\nWHERE(departmentId,Salary) IN \\n(\\nSELECT departmentId, MAX(Salary) FROM Employee\\nGROUP BY departmentId\\n)"
                    },
                    {
                        "username": "alfej136",
                        "content": "did anyone had written the query in T-SQL ? if yes then can you please reply the answer...."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT RANK () OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS rank, e.name AS Employee, d.name AS Department, e.salary AS Salary\\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON e.departmentid = d.id)\\n\\nSELECT Employee, Department, Salary\\nFROM CTE\\nWHERE rank = 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n)"
                    },
                    {
                        "username": "user8428J",
                        "content": "select d.name as Department,e.Employee,e.Salary\\nfrom\\n((select name as Employee,departmentId, Salary, rank() over(partition by departmentId order by salary desc) as \\'rank\\'\\nfrom employee) as e inner join department as d\\non e.departmentId = d.id)\\nwhere e.rank=1\\norder by e.rank"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n  select b.name as dept,a.name,a.salary from Employee a inner join Department b on a.departmentId = b.id\\n),\\ncte1 as(\\n  select *, dense_rank() over(partition by dept order by salary desc) as rnk from cte\\n)\\n\\nselect dept as Department, name as Employee, salary from cte1 where rnk = 1;"
                    }
                ]
            },
            {
                "id": 1985404,
                "content": [
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL using subqueries:\\n\\n/* Write your T-SQL query statement below */\\n\\nSELECT Department.name AS Department, Employee.name AS Employee, Employee.salary AS Salary FROM\\n((SELECT departmentId, MAX(salary) AS maxSalary FROM Employee GROUP BY departmentId) sub LEFT JOIN Employee on sub.maxSalary = Employee.salary AND sub.departmentId = Employee.departmentId)  INNER JOIN Department ON Employee.departmentId = Department.id;"
                    },
                    {
                        "username": "aryan1113",
                        "content": "Why is the discussion section flooded with solutions :/"
                    },
                    {
                        "username": "Jasskaran0007",
                        "content": "While doing this question I came across a very important concept of GROUP BY clause, which can be ignored when first time coming across the GROUP BY clause, which is, that the columns which are not included in the GROUP BY clause must be a part of aggregate functions like MAX, MIN, SUM, AVG, otherwise it can lead to an error.\\nWhich means queries like, \\nSELECT Department.name AS Department, Employee.name AS Employee, MAX(salary) AS Salary FROM Employee JOIN Department ON Employee.departmentId=Department.id GROUP BY Department.id.\\nwont work.\\n\\n\\nHope I am not the only one."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Always remember, programming is just like life. It might seem hard at first, but every mistake is an opportunity to learn and grow. Don\\'t be discouraged by errors or unexpected results. Just keep trying, and with each attempt, you\\'re getting closer to your goal. The sky is the limit, so dream big and keep coding!\"\\n- Barbie"
                    },
                    {
                        "username": "shouvik32",
                        "content": "#VERY Easy to UNDERSTAND\\n#UPVOTE IF YOU LIKE \\n\\nSELECT Department.name AS Department,Employee.name AS Employee,salary\\nFROM Employee\\nINNER JOIN Department ON Employee.departmentId=Department.id \\nWHERE(departmentId,Salary) IN \\n(\\nSELECT departmentId, MAX(Salary) FROM Employee\\nGROUP BY departmentId\\n)"
                    },
                    {
                        "username": "alfej136",
                        "content": "did anyone had written the query in T-SQL ? if yes then can you please reply the answer...."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT RANK () OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS rank, e.name AS Employee, d.name AS Department, e.salary AS Salary\\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON e.departmentid = d.id)\\n\\nSELECT Employee, Department, Salary\\nFROM CTE\\nWHERE rank = 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n)"
                    },
                    {
                        "username": "user8428J",
                        "content": "select d.name as Department,e.Employee,e.Salary\\nfrom\\n((select name as Employee,departmentId, Salary, rank() over(partition by departmentId order by salary desc) as \\'rank\\'\\nfrom employee) as e inner join department as d\\non e.departmentId = d.id)\\nwhere e.rank=1\\norder by e.rank"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n  select b.name as dept,a.name,a.salary from Employee a inner join Department b on a.departmentId = b.id\\n),\\ncte1 as(\\n  select *, dense_rank() over(partition by dept order by salary desc) as rnk from cte\\n)\\n\\nselect dept as Department, name as Employee, salary from cte1 where rnk = 1;"
                    }
                ]
            },
            {
                "id": 1975666,
                "content": [
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL using subqueries:\\n\\n/* Write your T-SQL query statement below */\\n\\nSELECT Department.name AS Department, Employee.name AS Employee, Employee.salary AS Salary FROM\\n((SELECT departmentId, MAX(salary) AS maxSalary FROM Employee GROUP BY departmentId) sub LEFT JOIN Employee on sub.maxSalary = Employee.salary AND sub.departmentId = Employee.departmentId)  INNER JOIN Department ON Employee.departmentId = Department.id;"
                    },
                    {
                        "username": "aryan1113",
                        "content": "Why is the discussion section flooded with solutions :/"
                    },
                    {
                        "username": "Jasskaran0007",
                        "content": "While doing this question I came across a very important concept of GROUP BY clause, which can be ignored when first time coming across the GROUP BY clause, which is, that the columns which are not included in the GROUP BY clause must be a part of aggregate functions like MAX, MIN, SUM, AVG, otherwise it can lead to an error.\\nWhich means queries like, \\nSELECT Department.name AS Department, Employee.name AS Employee, MAX(salary) AS Salary FROM Employee JOIN Department ON Employee.departmentId=Department.id GROUP BY Department.id.\\nwont work.\\n\\n\\nHope I am not the only one."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Always remember, programming is just like life. It might seem hard at first, but every mistake is an opportunity to learn and grow. Don\\'t be discouraged by errors or unexpected results. Just keep trying, and with each attempt, you\\'re getting closer to your goal. The sky is the limit, so dream big and keep coding!\"\\n- Barbie"
                    },
                    {
                        "username": "shouvik32",
                        "content": "#VERY Easy to UNDERSTAND\\n#UPVOTE IF YOU LIKE \\n\\nSELECT Department.name AS Department,Employee.name AS Employee,salary\\nFROM Employee\\nINNER JOIN Department ON Employee.departmentId=Department.id \\nWHERE(departmentId,Salary) IN \\n(\\nSELECT departmentId, MAX(Salary) FROM Employee\\nGROUP BY departmentId\\n)"
                    },
                    {
                        "username": "alfej136",
                        "content": "did anyone had written the query in T-SQL ? if yes then can you please reply the answer...."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT RANK () OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS rank, e.name AS Employee, d.name AS Department, e.salary AS Salary\\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON e.departmentid = d.id)\\n\\nSELECT Employee, Department, Salary\\nFROM CTE\\nWHERE rank = 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n)"
                    },
                    {
                        "username": "user8428J",
                        "content": "select d.name as Department,e.Employee,e.Salary\\nfrom\\n((select name as Employee,departmentId, Salary, rank() over(partition by departmentId order by salary desc) as \\'rank\\'\\nfrom employee) as e inner join department as d\\non e.departmentId = d.id)\\nwhere e.rank=1\\norder by e.rank"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n  select b.name as dept,a.name,a.salary from Employee a inner join Department b on a.departmentId = b.id\\n),\\ncte1 as(\\n  select *, dense_rank() over(partition by dept order by salary desc) as rnk from cte\\n)\\n\\nselect dept as Department, name as Employee, salary from cte1 where rnk = 1;"
                    }
                ]
            },
            {
                "id": 1967834,
                "content": [
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL using subqueries:\\n\\n/* Write your T-SQL query statement below */\\n\\nSELECT Department.name AS Department, Employee.name AS Employee, Employee.salary AS Salary FROM\\n((SELECT departmentId, MAX(salary) AS maxSalary FROM Employee GROUP BY departmentId) sub LEFT JOIN Employee on sub.maxSalary = Employee.salary AND sub.departmentId = Employee.departmentId)  INNER JOIN Department ON Employee.departmentId = Department.id;"
                    },
                    {
                        "username": "aryan1113",
                        "content": "Why is the discussion section flooded with solutions :/"
                    },
                    {
                        "username": "Jasskaran0007",
                        "content": "While doing this question I came across a very important concept of GROUP BY clause, which can be ignored when first time coming across the GROUP BY clause, which is, that the columns which are not included in the GROUP BY clause must be a part of aggregate functions like MAX, MIN, SUM, AVG, otherwise it can lead to an error.\\nWhich means queries like, \\nSELECT Department.name AS Department, Employee.name AS Employee, MAX(salary) AS Salary FROM Employee JOIN Department ON Employee.departmentId=Department.id GROUP BY Department.id.\\nwont work.\\n\\n\\nHope I am not the only one."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Always remember, programming is just like life. It might seem hard at first, but every mistake is an opportunity to learn and grow. Don\\'t be discouraged by errors or unexpected results. Just keep trying, and with each attempt, you\\'re getting closer to your goal. The sky is the limit, so dream big and keep coding!\"\\n- Barbie"
                    },
                    {
                        "username": "shouvik32",
                        "content": "#VERY Easy to UNDERSTAND\\n#UPVOTE IF YOU LIKE \\n\\nSELECT Department.name AS Department,Employee.name AS Employee,salary\\nFROM Employee\\nINNER JOIN Department ON Employee.departmentId=Department.id \\nWHERE(departmentId,Salary) IN \\n(\\nSELECT departmentId, MAX(Salary) FROM Employee\\nGROUP BY departmentId\\n)"
                    },
                    {
                        "username": "alfej136",
                        "content": "did anyone had written the query in T-SQL ? if yes then can you please reply the answer...."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT RANK () OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS rank, e.name AS Employee, d.name AS Department, e.salary AS Salary\\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON e.departmentid = d.id)\\n\\nSELECT Employee, Department, Salary\\nFROM CTE\\nWHERE rank = 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n)"
                    },
                    {
                        "username": "user8428J",
                        "content": "select d.name as Department,e.Employee,e.Salary\\nfrom\\n((select name as Employee,departmentId, Salary, rank() over(partition by departmentId order by salary desc) as \\'rank\\'\\nfrom employee) as e inner join department as d\\non e.departmentId = d.id)\\nwhere e.rank=1\\norder by e.rank"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n  select b.name as dept,a.name,a.salary from Employee a inner join Department b on a.departmentId = b.id\\n),\\ncte1 as(\\n  select *, dense_rank() over(partition by dept order by salary desc) as rnk from cte\\n)\\n\\nselect dept as Department, name as Employee, salary from cte1 where rnk = 1;"
                    }
                ]
            },
            {
                "id": 1883127,
                "content": [
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL using subqueries:\\n\\n/* Write your T-SQL query statement below */\\n\\nSELECT Department.name AS Department, Employee.name AS Employee, Employee.salary AS Salary FROM\\n((SELECT departmentId, MAX(salary) AS maxSalary FROM Employee GROUP BY departmentId) sub LEFT JOIN Employee on sub.maxSalary = Employee.salary AND sub.departmentId = Employee.departmentId)  INNER JOIN Department ON Employee.departmentId = Department.id;"
                    },
                    {
                        "username": "aryan1113",
                        "content": "Why is the discussion section flooded with solutions :/"
                    },
                    {
                        "username": "Jasskaran0007",
                        "content": "While doing this question I came across a very important concept of GROUP BY clause, which can be ignored when first time coming across the GROUP BY clause, which is, that the columns which are not included in the GROUP BY clause must be a part of aggregate functions like MAX, MIN, SUM, AVG, otherwise it can lead to an error.\\nWhich means queries like, \\nSELECT Department.name AS Department, Employee.name AS Employee, MAX(salary) AS Salary FROM Employee JOIN Department ON Employee.departmentId=Department.id GROUP BY Department.id.\\nwont work.\\n\\n\\nHope I am not the only one."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Always remember, programming is just like life. It might seem hard at first, but every mistake is an opportunity to learn and grow. Don\\'t be discouraged by errors or unexpected results. Just keep trying, and with each attempt, you\\'re getting closer to your goal. The sky is the limit, so dream big and keep coding!\"\\n- Barbie"
                    },
                    {
                        "username": "shouvik32",
                        "content": "#VERY Easy to UNDERSTAND\\n#UPVOTE IF YOU LIKE \\n\\nSELECT Department.name AS Department,Employee.name AS Employee,salary\\nFROM Employee\\nINNER JOIN Department ON Employee.departmentId=Department.id \\nWHERE(departmentId,Salary) IN \\n(\\nSELECT departmentId, MAX(Salary) FROM Employee\\nGROUP BY departmentId\\n)"
                    },
                    {
                        "username": "alfej136",
                        "content": "did anyone had written the query in T-SQL ? if yes then can you please reply the answer...."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT RANK () OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS rank, e.name AS Employee, d.name AS Department, e.salary AS Salary\\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON e.departmentid = d.id)\\n\\nSELECT Employee, Department, Salary\\nFROM CTE\\nWHERE rank = 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n)"
                    },
                    {
                        "username": "user8428J",
                        "content": "select d.name as Department,e.Employee,e.Salary\\nfrom\\n((select name as Employee,departmentId, Salary, rank() over(partition by departmentId order by salary desc) as \\'rank\\'\\nfrom employee) as e inner join department as d\\non e.departmentId = d.id)\\nwhere e.rank=1\\norder by e.rank"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n  select b.name as dept,a.name,a.salary from Employee a inner join Department b on a.departmentId = b.id\\n),\\ncte1 as(\\n  select *, dense_rank() over(partition by dept order by salary desc) as rnk from cte\\n)\\n\\nselect dept as Department, name as Employee, salary from cte1 where rnk = 1;"
                    }
                ]
            },
            {
                "id": 1873440,
                "content": [
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL using subqueries:\\n\\n/* Write your T-SQL query statement below */\\n\\nSELECT Department.name AS Department, Employee.name AS Employee, Employee.salary AS Salary FROM\\n((SELECT departmentId, MAX(salary) AS maxSalary FROM Employee GROUP BY departmentId) sub LEFT JOIN Employee on sub.maxSalary = Employee.salary AND sub.departmentId = Employee.departmentId)  INNER JOIN Department ON Employee.departmentId = Department.id;"
                    },
                    {
                        "username": "aryan1113",
                        "content": "Why is the discussion section flooded with solutions :/"
                    },
                    {
                        "username": "Jasskaran0007",
                        "content": "While doing this question I came across a very important concept of GROUP BY clause, which can be ignored when first time coming across the GROUP BY clause, which is, that the columns which are not included in the GROUP BY clause must be a part of aggregate functions like MAX, MIN, SUM, AVG, otherwise it can lead to an error.\\nWhich means queries like, \\nSELECT Department.name AS Department, Employee.name AS Employee, MAX(salary) AS Salary FROM Employee JOIN Department ON Employee.departmentId=Department.id GROUP BY Department.id.\\nwont work.\\n\\n\\nHope I am not the only one."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Always remember, programming is just like life. It might seem hard at first, but every mistake is an opportunity to learn and grow. Don\\'t be discouraged by errors or unexpected results. Just keep trying, and with each attempt, you\\'re getting closer to your goal. The sky is the limit, so dream big and keep coding!\"\\n- Barbie"
                    },
                    {
                        "username": "shouvik32",
                        "content": "#VERY Easy to UNDERSTAND\\n#UPVOTE IF YOU LIKE \\n\\nSELECT Department.name AS Department,Employee.name AS Employee,salary\\nFROM Employee\\nINNER JOIN Department ON Employee.departmentId=Department.id \\nWHERE(departmentId,Salary) IN \\n(\\nSELECT departmentId, MAX(Salary) FROM Employee\\nGROUP BY departmentId\\n)"
                    },
                    {
                        "username": "alfej136",
                        "content": "did anyone had written the query in T-SQL ? if yes then can you please reply the answer...."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT RANK () OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS rank, e.name AS Employee, d.name AS Department, e.salary AS Salary\\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON e.departmentid = d.id)\\n\\nSELECT Employee, Department, Salary\\nFROM CTE\\nWHERE rank = 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom department d left join employee e on xxqd.id = e.departmentId\\nwhere e.salary = (\\n  select max(salary) \\n  from employee \\n  where departmentId = d.id\\n)"
                    },
                    {
                        "username": "user8428J",
                        "content": "select d.name as Department,e.Employee,e.Salary\\nfrom\\n((select name as Employee,departmentId, Salary, rank() over(partition by departmentId order by salary desc) as \\'rank\\'\\nfrom employee) as e inner join department as d\\non e.departmentId = d.id)\\nwhere e.rank=1\\norder by e.rank"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n  select b.name as dept,a.name,a.salary from Employee a inner join Department b on a.departmentId = b.id\\n),\\ncte1 as(\\n  select *, dense_rank() over(partition by dept order by salary desc) as rnk from cte\\n)\\n\\nselect dept as Department, name as Employee, salary from cte1 where rnk = 1;"
                    }
                ]
            },
            {
                "id": 1872239,
                "content": [
                    {
                        "username": "user9299fG",
                        "content": "Running the query gives the result as Accepted but When submitting it the results shows as Wrong Answer and the Input and the Expected output are showing results of a different database"
                    },
                    {
                        "username": "shivamj11",
                        "content": "try to use dense_rank function, join, \\n\\n[solution](https://leetcode.com/problems/department-highest-salary/solutions/3430521/mysql-dense-rank/)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "should be tagged easy!\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Department.name as Department, Employee.name as Employee,\\n (Employee.salary) as Salary from\\nEmployee inner join\\n Department on Employee.departmentId=Department.id\\n where (departmentId ,salary ) in\\n (select departmentId ,max(salary) as salary from Employee group by departmentId)\\n\\n\\nfirst you perform the inner join operation than extract max(salary) and group by department id \\n"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "--Oracle\\nwith sachin as\\n(select d.Name as Department, e.Name as Employee, e.Salary as Salary, \\nrank() over(PARTITION by d.Name order by Salary desc) as rank\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from sachin where rank=1;"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select departmentId ,name,salary from Employee),\\ncte2 as (select id,name from Department)\\n\\nselect  Department, Employee, Salary\\nfrom (select \\nb.name as Department,a.name Employee,a.salary as Salary,dense_rank() over (partition by b.name  order by a.salary desc)  as rnk\\nfrom \\ncte a \\nleft join cte2 b on \\na.departmentId = b.id\\n) a where rnk=1\\n"
                    },
                    {
                        "username": "shubhradeep23",
                        "content": "Simple solution WITHOUT JOIN\\n\\n\\nSELECT Department.name AS Department ,Employee.name AS Employee, Employee.salary\\nFROM Department,Employee  \\nWHERE Employee.departmentId=Department.id and (departmentId, salary) IN\\n(SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId) ;"
                    },
                    {
                        "username": "michaelm926",
                        "content": "Can someone correct my code please, i\\'m just a beginner, have not come across the MAX and GROUP BY syntax, SO I wanted to use UNION, below is my code:\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId ASC, salary DESC\\nLIMIT 2\\nUNION\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId DESC, salary DESC\\nLIMIT 1;\\n\\nI keep getting a run error over the \"union\" syntax, I dont know what\\'s wrong"
                    },
                    {
                        "username": "jjjho",
                        "content": "[why this didn\\'t work]\\nselect b.name as department, a.name as employee, salary\\nfrom (\\nselect *, rank() over (partition by departmentid order by salary desc) as rank \\nfrom employee\\n) a \\nleft join department b on a.departmentid = b.id\\nwhere a.rank = 1"
                    },
                    {
                        "username": "endocsc",
                        "content": "select Department, Employee, Salary\\nfrom (\\n    select d.name as Department, e.name as Employee, e.salary as Salary,   \\n    dense_rank() over(partition by e.departmentId order by e.salary desc) as \\'rank_salary\\'\\n    from Employee e \\n    left join Department d on e.departmentId = d.id) as A\\nwhere rank_salary = 1"
                    }
                ]
            },
            {
                "id": 1867467,
                "content": [
                    {
                        "username": "user9299fG",
                        "content": "Running the query gives the result as Accepted but When submitting it the results shows as Wrong Answer and the Input and the Expected output are showing results of a different database"
                    },
                    {
                        "username": "shivamj11",
                        "content": "try to use dense_rank function, join, \\n\\n[solution](https://leetcode.com/problems/department-highest-salary/solutions/3430521/mysql-dense-rank/)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "should be tagged easy!\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Department.name as Department, Employee.name as Employee,\\n (Employee.salary) as Salary from\\nEmployee inner join\\n Department on Employee.departmentId=Department.id\\n where (departmentId ,salary ) in\\n (select departmentId ,max(salary) as salary from Employee group by departmentId)\\n\\n\\nfirst you perform the inner join operation than extract max(salary) and group by department id \\n"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "--Oracle\\nwith sachin as\\n(select d.Name as Department, e.Name as Employee, e.Salary as Salary, \\nrank() over(PARTITION by d.Name order by Salary desc) as rank\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from sachin where rank=1;"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select departmentId ,name,salary from Employee),\\ncte2 as (select id,name from Department)\\n\\nselect  Department, Employee, Salary\\nfrom (select \\nb.name as Department,a.name Employee,a.salary as Salary,dense_rank() over (partition by b.name  order by a.salary desc)  as rnk\\nfrom \\ncte a \\nleft join cte2 b on \\na.departmentId = b.id\\n) a where rnk=1\\n"
                    },
                    {
                        "username": "shubhradeep23",
                        "content": "Simple solution WITHOUT JOIN\\n\\n\\nSELECT Department.name AS Department ,Employee.name AS Employee, Employee.salary\\nFROM Department,Employee  \\nWHERE Employee.departmentId=Department.id and (departmentId, salary) IN\\n(SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId) ;"
                    },
                    {
                        "username": "michaelm926",
                        "content": "Can someone correct my code please, i\\'m just a beginner, have not come across the MAX and GROUP BY syntax, SO I wanted to use UNION, below is my code:\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId ASC, salary DESC\\nLIMIT 2\\nUNION\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId DESC, salary DESC\\nLIMIT 1;\\n\\nI keep getting a run error over the \"union\" syntax, I dont know what\\'s wrong"
                    },
                    {
                        "username": "jjjho",
                        "content": "[why this didn\\'t work]\\nselect b.name as department, a.name as employee, salary\\nfrom (\\nselect *, rank() over (partition by departmentid order by salary desc) as rank \\nfrom employee\\n) a \\nleft join department b on a.departmentid = b.id\\nwhere a.rank = 1"
                    },
                    {
                        "username": "endocsc",
                        "content": "select Department, Employee, Salary\\nfrom (\\n    select d.name as Department, e.name as Employee, e.salary as Salary,   \\n    dense_rank() over(partition by e.departmentId order by e.salary desc) as \\'rank_salary\\'\\n    from Employee e \\n    left join Department d on e.departmentId = d.id) as A\\nwhere rank_salary = 1"
                    }
                ]
            },
            {
                "id": 1861291,
                "content": [
                    {
                        "username": "user9299fG",
                        "content": "Running the query gives the result as Accepted but When submitting it the results shows as Wrong Answer and the Input and the Expected output are showing results of a different database"
                    },
                    {
                        "username": "shivamj11",
                        "content": "try to use dense_rank function, join, \\n\\n[solution](https://leetcode.com/problems/department-highest-salary/solutions/3430521/mysql-dense-rank/)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "should be tagged easy!\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Department.name as Department, Employee.name as Employee,\\n (Employee.salary) as Salary from\\nEmployee inner join\\n Department on Employee.departmentId=Department.id\\n where (departmentId ,salary ) in\\n (select departmentId ,max(salary) as salary from Employee group by departmentId)\\n\\n\\nfirst you perform the inner join operation than extract max(salary) and group by department id \\n"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "--Oracle\\nwith sachin as\\n(select d.Name as Department, e.Name as Employee, e.Salary as Salary, \\nrank() over(PARTITION by d.Name order by Salary desc) as rank\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from sachin where rank=1;"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select departmentId ,name,salary from Employee),\\ncte2 as (select id,name from Department)\\n\\nselect  Department, Employee, Salary\\nfrom (select \\nb.name as Department,a.name Employee,a.salary as Salary,dense_rank() over (partition by b.name  order by a.salary desc)  as rnk\\nfrom \\ncte a \\nleft join cte2 b on \\na.departmentId = b.id\\n) a where rnk=1\\n"
                    },
                    {
                        "username": "shubhradeep23",
                        "content": "Simple solution WITHOUT JOIN\\n\\n\\nSELECT Department.name AS Department ,Employee.name AS Employee, Employee.salary\\nFROM Department,Employee  \\nWHERE Employee.departmentId=Department.id and (departmentId, salary) IN\\n(SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId) ;"
                    },
                    {
                        "username": "michaelm926",
                        "content": "Can someone correct my code please, i\\'m just a beginner, have not come across the MAX and GROUP BY syntax, SO I wanted to use UNION, below is my code:\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId ASC, salary DESC\\nLIMIT 2\\nUNION\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId DESC, salary DESC\\nLIMIT 1;\\n\\nI keep getting a run error over the \"union\" syntax, I dont know what\\'s wrong"
                    },
                    {
                        "username": "jjjho",
                        "content": "[why this didn\\'t work]\\nselect b.name as department, a.name as employee, salary\\nfrom (\\nselect *, rank() over (partition by departmentid order by salary desc) as rank \\nfrom employee\\n) a \\nleft join department b on a.departmentid = b.id\\nwhere a.rank = 1"
                    },
                    {
                        "username": "endocsc",
                        "content": "select Department, Employee, Salary\\nfrom (\\n    select d.name as Department, e.name as Employee, e.salary as Salary,   \\n    dense_rank() over(partition by e.departmentId order by e.salary desc) as \\'rank_salary\\'\\n    from Employee e \\n    left join Department d on e.departmentId = d.id) as A\\nwhere rank_salary = 1"
                    }
                ]
            },
            {
                "id": 1856474,
                "content": [
                    {
                        "username": "user9299fG",
                        "content": "Running the query gives the result as Accepted but When submitting it the results shows as Wrong Answer and the Input and the Expected output are showing results of a different database"
                    },
                    {
                        "username": "shivamj11",
                        "content": "try to use dense_rank function, join, \\n\\n[solution](https://leetcode.com/problems/department-highest-salary/solutions/3430521/mysql-dense-rank/)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "should be tagged easy!\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Department.name as Department, Employee.name as Employee,\\n (Employee.salary) as Salary from\\nEmployee inner join\\n Department on Employee.departmentId=Department.id\\n where (departmentId ,salary ) in\\n (select departmentId ,max(salary) as salary from Employee group by departmentId)\\n\\n\\nfirst you perform the inner join operation than extract max(salary) and group by department id \\n"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "--Oracle\\nwith sachin as\\n(select d.Name as Department, e.Name as Employee, e.Salary as Salary, \\nrank() over(PARTITION by d.Name order by Salary desc) as rank\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from sachin where rank=1;"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select departmentId ,name,salary from Employee),\\ncte2 as (select id,name from Department)\\n\\nselect  Department, Employee, Salary\\nfrom (select \\nb.name as Department,a.name Employee,a.salary as Salary,dense_rank() over (partition by b.name  order by a.salary desc)  as rnk\\nfrom \\ncte a \\nleft join cte2 b on \\na.departmentId = b.id\\n) a where rnk=1\\n"
                    },
                    {
                        "username": "shubhradeep23",
                        "content": "Simple solution WITHOUT JOIN\\n\\n\\nSELECT Department.name AS Department ,Employee.name AS Employee, Employee.salary\\nFROM Department,Employee  \\nWHERE Employee.departmentId=Department.id and (departmentId, salary) IN\\n(SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId) ;"
                    },
                    {
                        "username": "michaelm926",
                        "content": "Can someone correct my code please, i\\'m just a beginner, have not come across the MAX and GROUP BY syntax, SO I wanted to use UNION, below is my code:\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId ASC, salary DESC\\nLIMIT 2\\nUNION\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId DESC, salary DESC\\nLIMIT 1;\\n\\nI keep getting a run error over the \"union\" syntax, I dont know what\\'s wrong"
                    },
                    {
                        "username": "jjjho",
                        "content": "[why this didn\\'t work]\\nselect b.name as department, a.name as employee, salary\\nfrom (\\nselect *, rank() over (partition by departmentid order by salary desc) as rank \\nfrom employee\\n) a \\nleft join department b on a.departmentid = b.id\\nwhere a.rank = 1"
                    },
                    {
                        "username": "endocsc",
                        "content": "select Department, Employee, Salary\\nfrom (\\n    select d.name as Department, e.name as Employee, e.salary as Salary,   \\n    dense_rank() over(partition by e.departmentId order by e.salary desc) as \\'rank_salary\\'\\n    from Employee e \\n    left join Department d on e.departmentId = d.id) as A\\nwhere rank_salary = 1"
                    }
                ]
            },
            {
                "id": 1848258,
                "content": [
                    {
                        "username": "user9299fG",
                        "content": "Running the query gives the result as Accepted but When submitting it the results shows as Wrong Answer and the Input and the Expected output are showing results of a different database"
                    },
                    {
                        "username": "shivamj11",
                        "content": "try to use dense_rank function, join, \\n\\n[solution](https://leetcode.com/problems/department-highest-salary/solutions/3430521/mysql-dense-rank/)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "should be tagged easy!\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Department.name as Department, Employee.name as Employee,\\n (Employee.salary) as Salary from\\nEmployee inner join\\n Department on Employee.departmentId=Department.id\\n where (departmentId ,salary ) in\\n (select departmentId ,max(salary) as salary from Employee group by departmentId)\\n\\n\\nfirst you perform the inner join operation than extract max(salary) and group by department id \\n"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "--Oracle\\nwith sachin as\\n(select d.Name as Department, e.Name as Employee, e.Salary as Salary, \\nrank() over(PARTITION by d.Name order by Salary desc) as rank\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from sachin where rank=1;"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select departmentId ,name,salary from Employee),\\ncte2 as (select id,name from Department)\\n\\nselect  Department, Employee, Salary\\nfrom (select \\nb.name as Department,a.name Employee,a.salary as Salary,dense_rank() over (partition by b.name  order by a.salary desc)  as rnk\\nfrom \\ncte a \\nleft join cte2 b on \\na.departmentId = b.id\\n) a where rnk=1\\n"
                    },
                    {
                        "username": "shubhradeep23",
                        "content": "Simple solution WITHOUT JOIN\\n\\n\\nSELECT Department.name AS Department ,Employee.name AS Employee, Employee.salary\\nFROM Department,Employee  \\nWHERE Employee.departmentId=Department.id and (departmentId, salary) IN\\n(SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId) ;"
                    },
                    {
                        "username": "michaelm926",
                        "content": "Can someone correct my code please, i\\'m just a beginner, have not come across the MAX and GROUP BY syntax, SO I wanted to use UNION, below is my code:\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId ASC, salary DESC\\nLIMIT 2\\nUNION\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId DESC, salary DESC\\nLIMIT 1;\\n\\nI keep getting a run error over the \"union\" syntax, I dont know what\\'s wrong"
                    },
                    {
                        "username": "jjjho",
                        "content": "[why this didn\\'t work]\\nselect b.name as department, a.name as employee, salary\\nfrom (\\nselect *, rank() over (partition by departmentid order by salary desc) as rank \\nfrom employee\\n) a \\nleft join department b on a.departmentid = b.id\\nwhere a.rank = 1"
                    },
                    {
                        "username": "endocsc",
                        "content": "select Department, Employee, Salary\\nfrom (\\n    select d.name as Department, e.name as Employee, e.salary as Salary,   \\n    dense_rank() over(partition by e.departmentId order by e.salary desc) as \\'rank_salary\\'\\n    from Employee e \\n    left join Department d on e.departmentId = d.id) as A\\nwhere rank_salary = 1"
                    }
                ]
            },
            {
                "id": 1840390,
                "content": [
                    {
                        "username": "user9299fG",
                        "content": "Running the query gives the result as Accepted but When submitting it the results shows as Wrong Answer and the Input and the Expected output are showing results of a different database"
                    },
                    {
                        "username": "shivamj11",
                        "content": "try to use dense_rank function, join, \\n\\n[solution](https://leetcode.com/problems/department-highest-salary/solutions/3430521/mysql-dense-rank/)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "should be tagged easy!\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Department.name as Department, Employee.name as Employee,\\n (Employee.salary) as Salary from\\nEmployee inner join\\n Department on Employee.departmentId=Department.id\\n where (departmentId ,salary ) in\\n (select departmentId ,max(salary) as salary from Employee group by departmentId)\\n\\n\\nfirst you perform the inner join operation than extract max(salary) and group by department id \\n"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "--Oracle\\nwith sachin as\\n(select d.Name as Department, e.Name as Employee, e.Salary as Salary, \\nrank() over(PARTITION by d.Name order by Salary desc) as rank\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from sachin where rank=1;"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select departmentId ,name,salary from Employee),\\ncte2 as (select id,name from Department)\\n\\nselect  Department, Employee, Salary\\nfrom (select \\nb.name as Department,a.name Employee,a.salary as Salary,dense_rank() over (partition by b.name  order by a.salary desc)  as rnk\\nfrom \\ncte a \\nleft join cte2 b on \\na.departmentId = b.id\\n) a where rnk=1\\n"
                    },
                    {
                        "username": "shubhradeep23",
                        "content": "Simple solution WITHOUT JOIN\\n\\n\\nSELECT Department.name AS Department ,Employee.name AS Employee, Employee.salary\\nFROM Department,Employee  \\nWHERE Employee.departmentId=Department.id and (departmentId, salary) IN\\n(SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId) ;"
                    },
                    {
                        "username": "michaelm926",
                        "content": "Can someone correct my code please, i\\'m just a beginner, have not come across the MAX and GROUP BY syntax, SO I wanted to use UNION, below is my code:\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId ASC, salary DESC\\nLIMIT 2\\nUNION\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId DESC, salary DESC\\nLIMIT 1;\\n\\nI keep getting a run error over the \"union\" syntax, I dont know what\\'s wrong"
                    },
                    {
                        "username": "jjjho",
                        "content": "[why this didn\\'t work]\\nselect b.name as department, a.name as employee, salary\\nfrom (\\nselect *, rank() over (partition by departmentid order by salary desc) as rank \\nfrom employee\\n) a \\nleft join department b on a.departmentid = b.id\\nwhere a.rank = 1"
                    },
                    {
                        "username": "endocsc",
                        "content": "select Department, Employee, Salary\\nfrom (\\n    select d.name as Department, e.name as Employee, e.salary as Salary,   \\n    dense_rank() over(partition by e.departmentId order by e.salary desc) as \\'rank_salary\\'\\n    from Employee e \\n    left join Department d on e.departmentId = d.id) as A\\nwhere rank_salary = 1"
                    }
                ]
            },
            {
                "id": 1833864,
                "content": [
                    {
                        "username": "user9299fG",
                        "content": "Running the query gives the result as Accepted but When submitting it the results shows as Wrong Answer and the Input and the Expected output are showing results of a different database"
                    },
                    {
                        "username": "shivamj11",
                        "content": "try to use dense_rank function, join, \\n\\n[solution](https://leetcode.com/problems/department-highest-salary/solutions/3430521/mysql-dense-rank/)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "should be tagged easy!\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Department.name as Department, Employee.name as Employee,\\n (Employee.salary) as Salary from\\nEmployee inner join\\n Department on Employee.departmentId=Department.id\\n where (departmentId ,salary ) in\\n (select departmentId ,max(salary) as salary from Employee group by departmentId)\\n\\n\\nfirst you perform the inner join operation than extract max(salary) and group by department id \\n"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "--Oracle\\nwith sachin as\\n(select d.Name as Department, e.Name as Employee, e.Salary as Salary, \\nrank() over(PARTITION by d.Name order by Salary desc) as rank\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from sachin where rank=1;"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select departmentId ,name,salary from Employee),\\ncte2 as (select id,name from Department)\\n\\nselect  Department, Employee, Salary\\nfrom (select \\nb.name as Department,a.name Employee,a.salary as Salary,dense_rank() over (partition by b.name  order by a.salary desc)  as rnk\\nfrom \\ncte a \\nleft join cte2 b on \\na.departmentId = b.id\\n) a where rnk=1\\n"
                    },
                    {
                        "username": "shubhradeep23",
                        "content": "Simple solution WITHOUT JOIN\\n\\n\\nSELECT Department.name AS Department ,Employee.name AS Employee, Employee.salary\\nFROM Department,Employee  \\nWHERE Employee.departmentId=Department.id and (departmentId, salary) IN\\n(SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId) ;"
                    },
                    {
                        "username": "michaelm926",
                        "content": "Can someone correct my code please, i\\'m just a beginner, have not come across the MAX and GROUP BY syntax, SO I wanted to use UNION, below is my code:\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId ASC, salary DESC\\nLIMIT 2\\nUNION\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId DESC, salary DESC\\nLIMIT 1;\\n\\nI keep getting a run error over the \"union\" syntax, I dont know what\\'s wrong"
                    },
                    {
                        "username": "jjjho",
                        "content": "[why this didn\\'t work]\\nselect b.name as department, a.name as employee, salary\\nfrom (\\nselect *, rank() over (partition by departmentid order by salary desc) as rank \\nfrom employee\\n) a \\nleft join department b on a.departmentid = b.id\\nwhere a.rank = 1"
                    },
                    {
                        "username": "endocsc",
                        "content": "select Department, Employee, Salary\\nfrom (\\n    select d.name as Department, e.name as Employee, e.salary as Salary,   \\n    dense_rank() over(partition by e.departmentId order by e.salary desc) as \\'rank_salary\\'\\n    from Employee e \\n    left join Department d on e.departmentId = d.id) as A\\nwhere rank_salary = 1"
                    }
                ]
            },
            {
                "id": 1817099,
                "content": [
                    {
                        "username": "user9299fG",
                        "content": "Running the query gives the result as Accepted but When submitting it the results shows as Wrong Answer and the Input and the Expected output are showing results of a different database"
                    },
                    {
                        "username": "shivamj11",
                        "content": "try to use dense_rank function, join, \\n\\n[solution](https://leetcode.com/problems/department-highest-salary/solutions/3430521/mysql-dense-rank/)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "should be tagged easy!\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Department.name as Department, Employee.name as Employee,\\n (Employee.salary) as Salary from\\nEmployee inner join\\n Department on Employee.departmentId=Department.id\\n where (departmentId ,salary ) in\\n (select departmentId ,max(salary) as salary from Employee group by departmentId)\\n\\n\\nfirst you perform the inner join operation than extract max(salary) and group by department id \\n"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "--Oracle\\nwith sachin as\\n(select d.Name as Department, e.Name as Employee, e.Salary as Salary, \\nrank() over(PARTITION by d.Name order by Salary desc) as rank\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from sachin where rank=1;"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select departmentId ,name,salary from Employee),\\ncte2 as (select id,name from Department)\\n\\nselect  Department, Employee, Salary\\nfrom (select \\nb.name as Department,a.name Employee,a.salary as Salary,dense_rank() over (partition by b.name  order by a.salary desc)  as rnk\\nfrom \\ncte a \\nleft join cte2 b on \\na.departmentId = b.id\\n) a where rnk=1\\n"
                    },
                    {
                        "username": "shubhradeep23",
                        "content": "Simple solution WITHOUT JOIN\\n\\n\\nSELECT Department.name AS Department ,Employee.name AS Employee, Employee.salary\\nFROM Department,Employee  \\nWHERE Employee.departmentId=Department.id and (departmentId, salary) IN\\n(SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId) ;"
                    },
                    {
                        "username": "michaelm926",
                        "content": "Can someone correct my code please, i\\'m just a beginner, have not come across the MAX and GROUP BY syntax, SO I wanted to use UNION, below is my code:\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId ASC, salary DESC\\nLIMIT 2\\nUNION\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId DESC, salary DESC\\nLIMIT 1;\\n\\nI keep getting a run error over the \"union\" syntax, I dont know what\\'s wrong"
                    },
                    {
                        "username": "jjjho",
                        "content": "[why this didn\\'t work]\\nselect b.name as department, a.name as employee, salary\\nfrom (\\nselect *, rank() over (partition by departmentid order by salary desc) as rank \\nfrom employee\\n) a \\nleft join department b on a.departmentid = b.id\\nwhere a.rank = 1"
                    },
                    {
                        "username": "endocsc",
                        "content": "select Department, Employee, Salary\\nfrom (\\n    select d.name as Department, e.name as Employee, e.salary as Salary,   \\n    dense_rank() over(partition by e.departmentId order by e.salary desc) as \\'rank_salary\\'\\n    from Employee e \\n    left join Department d on e.departmentId = d.id) as A\\nwhere rank_salary = 1"
                    }
                ]
            },
            {
                "id": 1805118,
                "content": [
                    {
                        "username": "user9299fG",
                        "content": "Running the query gives the result as Accepted but When submitting it the results shows as Wrong Answer and the Input and the Expected output are showing results of a different database"
                    },
                    {
                        "username": "shivamj11",
                        "content": "try to use dense_rank function, join, \\n\\n[solution](https://leetcode.com/problems/department-highest-salary/solutions/3430521/mysql-dense-rank/)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "should be tagged easy!\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Department.name as Department, Employee.name as Employee,\\n (Employee.salary) as Salary from\\nEmployee inner join\\n Department on Employee.departmentId=Department.id\\n where (departmentId ,salary ) in\\n (select departmentId ,max(salary) as salary from Employee group by departmentId)\\n\\n\\nfirst you perform the inner join operation than extract max(salary) and group by department id \\n"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "--Oracle\\nwith sachin as\\n(select d.Name as Department, e.Name as Employee, e.Salary as Salary, \\nrank() over(PARTITION by d.Name order by Salary desc) as rank\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from sachin where rank=1;"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select departmentId ,name,salary from Employee),\\ncte2 as (select id,name from Department)\\n\\nselect  Department, Employee, Salary\\nfrom (select \\nb.name as Department,a.name Employee,a.salary as Salary,dense_rank() over (partition by b.name  order by a.salary desc)  as rnk\\nfrom \\ncte a \\nleft join cte2 b on \\na.departmentId = b.id\\n) a where rnk=1\\n"
                    },
                    {
                        "username": "shubhradeep23",
                        "content": "Simple solution WITHOUT JOIN\\n\\n\\nSELECT Department.name AS Department ,Employee.name AS Employee, Employee.salary\\nFROM Department,Employee  \\nWHERE Employee.departmentId=Department.id and (departmentId, salary) IN\\n(SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId) ;"
                    },
                    {
                        "username": "michaelm926",
                        "content": "Can someone correct my code please, i\\'m just a beginner, have not come across the MAX and GROUP BY syntax, SO I wanted to use UNION, below is my code:\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId ASC, salary DESC\\nLIMIT 2\\nUNION\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId DESC, salary DESC\\nLIMIT 1;\\n\\nI keep getting a run error over the \"union\" syntax, I dont know what\\'s wrong"
                    },
                    {
                        "username": "jjjho",
                        "content": "[why this didn\\'t work]\\nselect b.name as department, a.name as employee, salary\\nfrom (\\nselect *, rank() over (partition by departmentid order by salary desc) as rank \\nfrom employee\\n) a \\nleft join department b on a.departmentid = b.id\\nwhere a.rank = 1"
                    },
                    {
                        "username": "endocsc",
                        "content": "select Department, Employee, Salary\\nfrom (\\n    select d.name as Department, e.name as Employee, e.salary as Salary,   \\n    dense_rank() over(partition by e.departmentId order by e.salary desc) as \\'rank_salary\\'\\n    from Employee e \\n    left join Department d on e.departmentId = d.id) as A\\nwhere rank_salary = 1"
                    }
                ]
            },
            {
                "id": 1804485,
                "content": [
                    {
                        "username": "user9299fG",
                        "content": "Running the query gives the result as Accepted but When submitting it the results shows as Wrong Answer and the Input and the Expected output are showing results of a different database"
                    },
                    {
                        "username": "shivamj11",
                        "content": "try to use dense_rank function, join, \\n\\n[solution](https://leetcode.com/problems/department-highest-salary/solutions/3430521/mysql-dense-rank/)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "should be tagged easy!\\n"
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select Department.name as Department, Employee.name as Employee,\\n (Employee.salary) as Salary from\\nEmployee inner join\\n Department on Employee.departmentId=Department.id\\n where (departmentId ,salary ) in\\n (select departmentId ,max(salary) as salary from Employee group by departmentId)\\n\\n\\nfirst you perform the inner join operation than extract max(salary) and group by department id \\n"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "--Oracle\\nwith sachin as\\n(select d.Name as Department, e.Name as Employee, e.Salary as Salary, \\nrank() over(PARTITION by d.Name order by Salary desc) as rank\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from sachin where rank=1;"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select departmentId ,name,salary from Employee),\\ncte2 as (select id,name from Department)\\n\\nselect  Department, Employee, Salary\\nfrom (select \\nb.name as Department,a.name Employee,a.salary as Salary,dense_rank() over (partition by b.name  order by a.salary desc)  as rnk\\nfrom \\ncte a \\nleft join cte2 b on \\na.departmentId = b.id\\n) a where rnk=1\\n"
                    },
                    {
                        "username": "shubhradeep23",
                        "content": "Simple solution WITHOUT JOIN\\n\\n\\nSELECT Department.name AS Department ,Employee.name AS Employee, Employee.salary\\nFROM Department,Employee  \\nWHERE Employee.departmentId=Department.id and (departmentId, salary) IN\\n(SELECT departmentId,MAX(salary) FROM Employee GROUP BY departmentId) ;"
                    },
                    {
                        "username": "michaelm926",
                        "content": "Can someone correct my code please, i\\'m just a beginner, have not come across the MAX and GROUP BY syntax, SO I wanted to use UNION, below is my code:\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId ASC, salary DESC\\nLIMIT 2\\nUNION\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM employee e\\nJOIN department d ON e.departmentId = d.id\\nORDER BY e.departmentId DESC, salary DESC\\nLIMIT 1;\\n\\nI keep getting a run error over the \"union\" syntax, I dont know what\\'s wrong"
                    },
                    {
                        "username": "jjjho",
                        "content": "[why this didn\\'t work]\\nselect b.name as department, a.name as employee, salary\\nfrom (\\nselect *, rank() over (partition by departmentid order by salary desc) as rank \\nfrom employee\\n) a \\nleft join department b on a.departmentid = b.id\\nwhere a.rank = 1"
                    },
                    {
                        "username": "endocsc",
                        "content": "select Department, Employee, Salary\\nfrom (\\n    select d.name as Department, e.name as Employee, e.salary as Salary,   \\n    dense_rank() over(partition by e.departmentId order by e.salary desc) as \\'rank_salary\\'\\n    from Employee e \\n    left join Department d on e.departmentId = d.id) as A\\nwhere rank_salary = 1"
                    }
                ]
            },
            {
                "id": 1803042,
                "content": [
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with highest_salary as (select e.name as employee, e.salary as Salary, d.name as Department, DENSE_RANK() OVER(PARTITION BY d.name order by Salary desc) as sal_rank from Employee e join Department d on e.departmentId = d.id)\\n\\nselect Department, Employee, Salary from highest_salary where sal_rank = 1;`"
                    },
                    {
                        "username": "abhilaash31270",
                        "content": "select d.name Department ,e.name Employee,e.salary Salary from Employee e inner join Department d on e.departmentId=d.id where \\n(departmentId,salary) in (select departmentId,max(salary) from employee group by departmentId);"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "WITH ranktable AS\\n(SELECT d.name as Department ,e.name as Employee, e.salary as salary, DENSE_RANK() OVER(partition by d.name ORDER BY salary DESC ) as sranks\\nFROM employee as e\\nLEFT JOIN Department as d\\nON e.departmentid=d.id\\n)\\n\\nSELECT Department, Employee,salary\\nFROM ranktable\\nWHERE sranks = 1"
                    },
                    {
                        "username": "EdgarMartinezEsqueda",
                        "content": "`SELECT d.name 'Department', e.name 'Employee', e.salary 'Salary'\nFROM Employee e, Department d\nWHERE e.salary =  (SELECT MAX(salary) FROM Employee WHERE departmentId = d.id) AND e.departmentId = d.id;`\n\nThe 'AND' is just a validation to avoid duplicates"
                    },
                    {
                        "username": "vasanthav251995",
                        "content": "SELECT Department,Employee,Salary from\\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary,\\nDENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) RANK from Employee e\\nLEFT JOIN Department d\\nON e.DepartmentID=d.ID ) a\\nWHERE RANK<=1"
                    },
                    {
                        "username": "user5564YW",
                        "content": " `with joined_ as \\n(\\nselect e.name as Employee,e.salary as Salary ,d.name as Department  from\\nEmployee e\\nleft join\\nDepartment d\\non e.departmentId =d.id \\n) \\n\\nselect sub.Department , sub.Employee  , sub.Salary\\nfrom (\\nselect Department,Employee,Salary, dense_rank()over(partition by Department order by Salary desc) as rank_\\nfrom joined_ \\n) sub\\nwhere sub.rank_ =1;`"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH DEP AS (\\n    SELECT \\n        DISTINCT D.name AS Department, \\n        E1.name AS Employee, \\n        E1.salary AS salary\\n    FROM \\n        Employee E1 JOIN Department D ON E1.departmentId = D.id\\n    WHERE \\n        E1.salary in (SELECT MAX(salary) FROM EMPLOYEE E2 WHERE E2.departmentId = E1.departmentId)\\n)\\n\\nSELECT * FROM DEP;"
                    },
                    {
                        "username": "javedabdool13",
                        "content": "with cte as (\\nselect D.name as Department ,E.name as Employee,E.salary as Salary,\\ncase when max(E.salary) over(partition by D.name) = E.salary  then 1 else 0 end as x\\nfrom Employee E\\ninner join Department D on E.departmentId = D.id) \\n\\nselect DEpartment,Employee,Salary from cte \\nwhere x = 1\\n"
                    },
                    {
                        "username": "Ansh123",
                        "content": "`with dept as (select d.id, d.name,\\nmax(salary) as Salary\\nfrom Employee e inner join Department d on e.departmentId=d.id\\ngroup by 1,2)\\nselect d.name as Department, e.name as Employee, d.Salary from Employee e inner join dept d on e.departmentId=d.id and e.salary=d.Salary`"
                    },
                    {
                        "username": "asifanas",
                        "content": "SELECT d.name as Department, temp.name as Employee, temp.salary as Salary FROM department d inner join (SELECT e.name, temp.salary, temp.departmentid FROM employee e inner join (SELECT departmentid, max(salary) as salary FROM employee group by departmentid) as temp on(temp.departmentid=e.departmentid and e.salary=temp.salary)) as temp on(temp.departmentid=d.id);"
                    }
                ]
            },
            {
                "id": 1801465,
                "content": [
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with highest_salary as (select e.name as employee, e.salary as Salary, d.name as Department, DENSE_RANK() OVER(PARTITION BY d.name order by Salary desc) as sal_rank from Employee e join Department d on e.departmentId = d.id)\\n\\nselect Department, Employee, Salary from highest_salary where sal_rank = 1;`"
                    },
                    {
                        "username": "abhilaash31270",
                        "content": "select d.name Department ,e.name Employee,e.salary Salary from Employee e inner join Department d on e.departmentId=d.id where \\n(departmentId,salary) in (select departmentId,max(salary) from employee group by departmentId);"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "WITH ranktable AS\\n(SELECT d.name as Department ,e.name as Employee, e.salary as salary, DENSE_RANK() OVER(partition by d.name ORDER BY salary DESC ) as sranks\\nFROM employee as e\\nLEFT JOIN Department as d\\nON e.departmentid=d.id\\n)\\n\\nSELECT Department, Employee,salary\\nFROM ranktable\\nWHERE sranks = 1"
                    },
                    {
                        "username": "EdgarMartinezEsqueda",
                        "content": "`SELECT d.name 'Department', e.name 'Employee', e.salary 'Salary'\nFROM Employee e, Department d\nWHERE e.salary =  (SELECT MAX(salary) FROM Employee WHERE departmentId = d.id) AND e.departmentId = d.id;`\n\nThe 'AND' is just a validation to avoid duplicates"
                    },
                    {
                        "username": "vasanthav251995",
                        "content": "SELECT Department,Employee,Salary from\\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary,\\nDENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) RANK from Employee e\\nLEFT JOIN Department d\\nON e.DepartmentID=d.ID ) a\\nWHERE RANK<=1"
                    },
                    {
                        "username": "user5564YW",
                        "content": " `with joined_ as \\n(\\nselect e.name as Employee,e.salary as Salary ,d.name as Department  from\\nEmployee e\\nleft join\\nDepartment d\\non e.departmentId =d.id \\n) \\n\\nselect sub.Department , sub.Employee  , sub.Salary\\nfrom (\\nselect Department,Employee,Salary, dense_rank()over(partition by Department order by Salary desc) as rank_\\nfrom joined_ \\n) sub\\nwhere sub.rank_ =1;`"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH DEP AS (\\n    SELECT \\n        DISTINCT D.name AS Department, \\n        E1.name AS Employee, \\n        E1.salary AS salary\\n    FROM \\n        Employee E1 JOIN Department D ON E1.departmentId = D.id\\n    WHERE \\n        E1.salary in (SELECT MAX(salary) FROM EMPLOYEE E2 WHERE E2.departmentId = E1.departmentId)\\n)\\n\\nSELECT * FROM DEP;"
                    },
                    {
                        "username": "javedabdool13",
                        "content": "with cte as (\\nselect D.name as Department ,E.name as Employee,E.salary as Salary,\\ncase when max(E.salary) over(partition by D.name) = E.salary  then 1 else 0 end as x\\nfrom Employee E\\ninner join Department D on E.departmentId = D.id) \\n\\nselect DEpartment,Employee,Salary from cte \\nwhere x = 1\\n"
                    },
                    {
                        "username": "Ansh123",
                        "content": "`with dept as (select d.id, d.name,\\nmax(salary) as Salary\\nfrom Employee e inner join Department d on e.departmentId=d.id\\ngroup by 1,2)\\nselect d.name as Department, e.name as Employee, d.Salary from Employee e inner join dept d on e.departmentId=d.id and e.salary=d.Salary`"
                    },
                    {
                        "username": "asifanas",
                        "content": "SELECT d.name as Department, temp.name as Employee, temp.salary as Salary FROM department d inner join (SELECT e.name, temp.salary, temp.departmentid FROM employee e inner join (SELECT departmentid, max(salary) as salary FROM employee group by departmentid) as temp on(temp.departmentid=e.departmentid and e.salary=temp.salary)) as temp on(temp.departmentid=d.id);"
                    }
                ]
            },
            {
                "id": 1795189,
                "content": [
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with highest_salary as (select e.name as employee, e.salary as Salary, d.name as Department, DENSE_RANK() OVER(PARTITION BY d.name order by Salary desc) as sal_rank from Employee e join Department d on e.departmentId = d.id)\\n\\nselect Department, Employee, Salary from highest_salary where sal_rank = 1;`"
                    },
                    {
                        "username": "abhilaash31270",
                        "content": "select d.name Department ,e.name Employee,e.salary Salary from Employee e inner join Department d on e.departmentId=d.id where \\n(departmentId,salary) in (select departmentId,max(salary) from employee group by departmentId);"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "WITH ranktable AS\\n(SELECT d.name as Department ,e.name as Employee, e.salary as salary, DENSE_RANK() OVER(partition by d.name ORDER BY salary DESC ) as sranks\\nFROM employee as e\\nLEFT JOIN Department as d\\nON e.departmentid=d.id\\n)\\n\\nSELECT Department, Employee,salary\\nFROM ranktable\\nWHERE sranks = 1"
                    },
                    {
                        "username": "EdgarMartinezEsqueda",
                        "content": "`SELECT d.name 'Department', e.name 'Employee', e.salary 'Salary'\nFROM Employee e, Department d\nWHERE e.salary =  (SELECT MAX(salary) FROM Employee WHERE departmentId = d.id) AND e.departmentId = d.id;`\n\nThe 'AND' is just a validation to avoid duplicates"
                    },
                    {
                        "username": "vasanthav251995",
                        "content": "SELECT Department,Employee,Salary from\\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary,\\nDENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) RANK from Employee e\\nLEFT JOIN Department d\\nON e.DepartmentID=d.ID ) a\\nWHERE RANK<=1"
                    },
                    {
                        "username": "user5564YW",
                        "content": " `with joined_ as \\n(\\nselect e.name as Employee,e.salary as Salary ,d.name as Department  from\\nEmployee e\\nleft join\\nDepartment d\\non e.departmentId =d.id \\n) \\n\\nselect sub.Department , sub.Employee  , sub.Salary\\nfrom (\\nselect Department,Employee,Salary, dense_rank()over(partition by Department order by Salary desc) as rank_\\nfrom joined_ \\n) sub\\nwhere sub.rank_ =1;`"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH DEP AS (\\n    SELECT \\n        DISTINCT D.name AS Department, \\n        E1.name AS Employee, \\n        E1.salary AS salary\\n    FROM \\n        Employee E1 JOIN Department D ON E1.departmentId = D.id\\n    WHERE \\n        E1.salary in (SELECT MAX(salary) FROM EMPLOYEE E2 WHERE E2.departmentId = E1.departmentId)\\n)\\n\\nSELECT * FROM DEP;"
                    },
                    {
                        "username": "javedabdool13",
                        "content": "with cte as (\\nselect D.name as Department ,E.name as Employee,E.salary as Salary,\\ncase when max(E.salary) over(partition by D.name) = E.salary  then 1 else 0 end as x\\nfrom Employee E\\ninner join Department D on E.departmentId = D.id) \\n\\nselect DEpartment,Employee,Salary from cte \\nwhere x = 1\\n"
                    },
                    {
                        "username": "Ansh123",
                        "content": "`with dept as (select d.id, d.name,\\nmax(salary) as Salary\\nfrom Employee e inner join Department d on e.departmentId=d.id\\ngroup by 1,2)\\nselect d.name as Department, e.name as Employee, d.Salary from Employee e inner join dept d on e.departmentId=d.id and e.salary=d.Salary`"
                    },
                    {
                        "username": "asifanas",
                        "content": "SELECT d.name as Department, temp.name as Employee, temp.salary as Salary FROM department d inner join (SELECT e.name, temp.salary, temp.departmentid FROM employee e inner join (SELECT departmentid, max(salary) as salary FROM employee group by departmentid) as temp on(temp.departmentid=e.departmentid and e.salary=temp.salary)) as temp on(temp.departmentid=d.id);"
                    }
                ]
            },
            {
                "id": 1794080,
                "content": [
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with highest_salary as (select e.name as employee, e.salary as Salary, d.name as Department, DENSE_RANK() OVER(PARTITION BY d.name order by Salary desc) as sal_rank from Employee e join Department d on e.departmentId = d.id)\\n\\nselect Department, Employee, Salary from highest_salary where sal_rank = 1;`"
                    },
                    {
                        "username": "abhilaash31270",
                        "content": "select d.name Department ,e.name Employee,e.salary Salary from Employee e inner join Department d on e.departmentId=d.id where \\n(departmentId,salary) in (select departmentId,max(salary) from employee group by departmentId);"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "WITH ranktable AS\\n(SELECT d.name as Department ,e.name as Employee, e.salary as salary, DENSE_RANK() OVER(partition by d.name ORDER BY salary DESC ) as sranks\\nFROM employee as e\\nLEFT JOIN Department as d\\nON e.departmentid=d.id\\n)\\n\\nSELECT Department, Employee,salary\\nFROM ranktable\\nWHERE sranks = 1"
                    },
                    {
                        "username": "EdgarMartinezEsqueda",
                        "content": "`SELECT d.name 'Department', e.name 'Employee', e.salary 'Salary'\nFROM Employee e, Department d\nWHERE e.salary =  (SELECT MAX(salary) FROM Employee WHERE departmentId = d.id) AND e.departmentId = d.id;`\n\nThe 'AND' is just a validation to avoid duplicates"
                    },
                    {
                        "username": "vasanthav251995",
                        "content": "SELECT Department,Employee,Salary from\\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary,\\nDENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) RANK from Employee e\\nLEFT JOIN Department d\\nON e.DepartmentID=d.ID ) a\\nWHERE RANK<=1"
                    },
                    {
                        "username": "user5564YW",
                        "content": " `with joined_ as \\n(\\nselect e.name as Employee,e.salary as Salary ,d.name as Department  from\\nEmployee e\\nleft join\\nDepartment d\\non e.departmentId =d.id \\n) \\n\\nselect sub.Department , sub.Employee  , sub.Salary\\nfrom (\\nselect Department,Employee,Salary, dense_rank()over(partition by Department order by Salary desc) as rank_\\nfrom joined_ \\n) sub\\nwhere sub.rank_ =1;`"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH DEP AS (\\n    SELECT \\n        DISTINCT D.name AS Department, \\n        E1.name AS Employee, \\n        E1.salary AS salary\\n    FROM \\n        Employee E1 JOIN Department D ON E1.departmentId = D.id\\n    WHERE \\n        E1.salary in (SELECT MAX(salary) FROM EMPLOYEE E2 WHERE E2.departmentId = E1.departmentId)\\n)\\n\\nSELECT * FROM DEP;"
                    },
                    {
                        "username": "javedabdool13",
                        "content": "with cte as (\\nselect D.name as Department ,E.name as Employee,E.salary as Salary,\\ncase when max(E.salary) over(partition by D.name) = E.salary  then 1 else 0 end as x\\nfrom Employee E\\ninner join Department D on E.departmentId = D.id) \\n\\nselect DEpartment,Employee,Salary from cte \\nwhere x = 1\\n"
                    },
                    {
                        "username": "Ansh123",
                        "content": "`with dept as (select d.id, d.name,\\nmax(salary) as Salary\\nfrom Employee e inner join Department d on e.departmentId=d.id\\ngroup by 1,2)\\nselect d.name as Department, e.name as Employee, d.Salary from Employee e inner join dept d on e.departmentId=d.id and e.salary=d.Salary`"
                    },
                    {
                        "username": "asifanas",
                        "content": "SELECT d.name as Department, temp.name as Employee, temp.salary as Salary FROM department d inner join (SELECT e.name, temp.salary, temp.departmentid FROM employee e inner join (SELECT departmentid, max(salary) as salary FROM employee group by departmentid) as temp on(temp.departmentid=e.departmentid and e.salary=temp.salary)) as temp on(temp.departmentid=d.id);"
                    }
                ]
            },
            {
                "id": 1790502,
                "content": [
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with highest_salary as (select e.name as employee, e.salary as Salary, d.name as Department, DENSE_RANK() OVER(PARTITION BY d.name order by Salary desc) as sal_rank from Employee e join Department d on e.departmentId = d.id)\\n\\nselect Department, Employee, Salary from highest_salary where sal_rank = 1;`"
                    },
                    {
                        "username": "abhilaash31270",
                        "content": "select d.name Department ,e.name Employee,e.salary Salary from Employee e inner join Department d on e.departmentId=d.id where \\n(departmentId,salary) in (select departmentId,max(salary) from employee group by departmentId);"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "WITH ranktable AS\\n(SELECT d.name as Department ,e.name as Employee, e.salary as salary, DENSE_RANK() OVER(partition by d.name ORDER BY salary DESC ) as sranks\\nFROM employee as e\\nLEFT JOIN Department as d\\nON e.departmentid=d.id\\n)\\n\\nSELECT Department, Employee,salary\\nFROM ranktable\\nWHERE sranks = 1"
                    },
                    {
                        "username": "EdgarMartinezEsqueda",
                        "content": "`SELECT d.name 'Department', e.name 'Employee', e.salary 'Salary'\nFROM Employee e, Department d\nWHERE e.salary =  (SELECT MAX(salary) FROM Employee WHERE departmentId = d.id) AND e.departmentId = d.id;`\n\nThe 'AND' is just a validation to avoid duplicates"
                    },
                    {
                        "username": "vasanthav251995",
                        "content": "SELECT Department,Employee,Salary from\\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary,\\nDENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) RANK from Employee e\\nLEFT JOIN Department d\\nON e.DepartmentID=d.ID ) a\\nWHERE RANK<=1"
                    },
                    {
                        "username": "user5564YW",
                        "content": " `with joined_ as \\n(\\nselect e.name as Employee,e.salary as Salary ,d.name as Department  from\\nEmployee e\\nleft join\\nDepartment d\\non e.departmentId =d.id \\n) \\n\\nselect sub.Department , sub.Employee  , sub.Salary\\nfrom (\\nselect Department,Employee,Salary, dense_rank()over(partition by Department order by Salary desc) as rank_\\nfrom joined_ \\n) sub\\nwhere sub.rank_ =1;`"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH DEP AS (\\n    SELECT \\n        DISTINCT D.name AS Department, \\n        E1.name AS Employee, \\n        E1.salary AS salary\\n    FROM \\n        Employee E1 JOIN Department D ON E1.departmentId = D.id\\n    WHERE \\n        E1.salary in (SELECT MAX(salary) FROM EMPLOYEE E2 WHERE E2.departmentId = E1.departmentId)\\n)\\n\\nSELECT * FROM DEP;"
                    },
                    {
                        "username": "javedabdool13",
                        "content": "with cte as (\\nselect D.name as Department ,E.name as Employee,E.salary as Salary,\\ncase when max(E.salary) over(partition by D.name) = E.salary  then 1 else 0 end as x\\nfrom Employee E\\ninner join Department D on E.departmentId = D.id) \\n\\nselect DEpartment,Employee,Salary from cte \\nwhere x = 1\\n"
                    },
                    {
                        "username": "Ansh123",
                        "content": "`with dept as (select d.id, d.name,\\nmax(salary) as Salary\\nfrom Employee e inner join Department d on e.departmentId=d.id\\ngroup by 1,2)\\nselect d.name as Department, e.name as Employee, d.Salary from Employee e inner join dept d on e.departmentId=d.id and e.salary=d.Salary`"
                    },
                    {
                        "username": "asifanas",
                        "content": "SELECT d.name as Department, temp.name as Employee, temp.salary as Salary FROM department d inner join (SELECT e.name, temp.salary, temp.departmentid FROM employee e inner join (SELECT departmentid, max(salary) as salary FROM employee group by departmentid) as temp on(temp.departmentid=e.departmentid and e.salary=temp.salary)) as temp on(temp.departmentid=d.id);"
                    }
                ]
            },
            {
                "id": 1776128,
                "content": [
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with highest_salary as (select e.name as employee, e.salary as Salary, d.name as Department, DENSE_RANK() OVER(PARTITION BY d.name order by Salary desc) as sal_rank from Employee e join Department d on e.departmentId = d.id)\\n\\nselect Department, Employee, Salary from highest_salary where sal_rank = 1;`"
                    },
                    {
                        "username": "abhilaash31270",
                        "content": "select d.name Department ,e.name Employee,e.salary Salary from Employee e inner join Department d on e.departmentId=d.id where \\n(departmentId,salary) in (select departmentId,max(salary) from employee group by departmentId);"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "WITH ranktable AS\\n(SELECT d.name as Department ,e.name as Employee, e.salary as salary, DENSE_RANK() OVER(partition by d.name ORDER BY salary DESC ) as sranks\\nFROM employee as e\\nLEFT JOIN Department as d\\nON e.departmentid=d.id\\n)\\n\\nSELECT Department, Employee,salary\\nFROM ranktable\\nWHERE sranks = 1"
                    },
                    {
                        "username": "EdgarMartinezEsqueda",
                        "content": "`SELECT d.name 'Department', e.name 'Employee', e.salary 'Salary'\nFROM Employee e, Department d\nWHERE e.salary =  (SELECT MAX(salary) FROM Employee WHERE departmentId = d.id) AND e.departmentId = d.id;`\n\nThe 'AND' is just a validation to avoid duplicates"
                    },
                    {
                        "username": "vasanthav251995",
                        "content": "SELECT Department,Employee,Salary from\\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary,\\nDENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) RANK from Employee e\\nLEFT JOIN Department d\\nON e.DepartmentID=d.ID ) a\\nWHERE RANK<=1"
                    },
                    {
                        "username": "user5564YW",
                        "content": " `with joined_ as \\n(\\nselect e.name as Employee,e.salary as Salary ,d.name as Department  from\\nEmployee e\\nleft join\\nDepartment d\\non e.departmentId =d.id \\n) \\n\\nselect sub.Department , sub.Employee  , sub.Salary\\nfrom (\\nselect Department,Employee,Salary, dense_rank()over(partition by Department order by Salary desc) as rank_\\nfrom joined_ \\n) sub\\nwhere sub.rank_ =1;`"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH DEP AS (\\n    SELECT \\n        DISTINCT D.name AS Department, \\n        E1.name AS Employee, \\n        E1.salary AS salary\\n    FROM \\n        Employee E1 JOIN Department D ON E1.departmentId = D.id\\n    WHERE \\n        E1.salary in (SELECT MAX(salary) FROM EMPLOYEE E2 WHERE E2.departmentId = E1.departmentId)\\n)\\n\\nSELECT * FROM DEP;"
                    },
                    {
                        "username": "javedabdool13",
                        "content": "with cte as (\\nselect D.name as Department ,E.name as Employee,E.salary as Salary,\\ncase when max(E.salary) over(partition by D.name) = E.salary  then 1 else 0 end as x\\nfrom Employee E\\ninner join Department D on E.departmentId = D.id) \\n\\nselect DEpartment,Employee,Salary from cte \\nwhere x = 1\\n"
                    },
                    {
                        "username": "Ansh123",
                        "content": "`with dept as (select d.id, d.name,\\nmax(salary) as Salary\\nfrom Employee e inner join Department d on e.departmentId=d.id\\ngroup by 1,2)\\nselect d.name as Department, e.name as Employee, d.Salary from Employee e inner join dept d on e.departmentId=d.id and e.salary=d.Salary`"
                    },
                    {
                        "username": "asifanas",
                        "content": "SELECT d.name as Department, temp.name as Employee, temp.salary as Salary FROM department d inner join (SELECT e.name, temp.salary, temp.departmentid FROM employee e inner join (SELECT departmentid, max(salary) as salary FROM employee group by departmentid) as temp on(temp.departmentid=e.departmentid and e.salary=temp.salary)) as temp on(temp.departmentid=d.id);"
                    }
                ]
            },
            {
                "id": 1775001,
                "content": [
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with highest_salary as (select e.name as employee, e.salary as Salary, d.name as Department, DENSE_RANK() OVER(PARTITION BY d.name order by Salary desc) as sal_rank from Employee e join Department d on e.departmentId = d.id)\\n\\nselect Department, Employee, Salary from highest_salary where sal_rank = 1;`"
                    },
                    {
                        "username": "abhilaash31270",
                        "content": "select d.name Department ,e.name Employee,e.salary Salary from Employee e inner join Department d on e.departmentId=d.id where \\n(departmentId,salary) in (select departmentId,max(salary) from employee group by departmentId);"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "WITH ranktable AS\\n(SELECT d.name as Department ,e.name as Employee, e.salary as salary, DENSE_RANK() OVER(partition by d.name ORDER BY salary DESC ) as sranks\\nFROM employee as e\\nLEFT JOIN Department as d\\nON e.departmentid=d.id\\n)\\n\\nSELECT Department, Employee,salary\\nFROM ranktable\\nWHERE sranks = 1"
                    },
                    {
                        "username": "EdgarMartinezEsqueda",
                        "content": "`SELECT d.name 'Department', e.name 'Employee', e.salary 'Salary'\nFROM Employee e, Department d\nWHERE e.salary =  (SELECT MAX(salary) FROM Employee WHERE departmentId = d.id) AND e.departmentId = d.id;`\n\nThe 'AND' is just a validation to avoid duplicates"
                    },
                    {
                        "username": "vasanthav251995",
                        "content": "SELECT Department,Employee,Salary from\\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary,\\nDENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) RANK from Employee e\\nLEFT JOIN Department d\\nON e.DepartmentID=d.ID ) a\\nWHERE RANK<=1"
                    },
                    {
                        "username": "user5564YW",
                        "content": " `with joined_ as \\n(\\nselect e.name as Employee,e.salary as Salary ,d.name as Department  from\\nEmployee e\\nleft join\\nDepartment d\\non e.departmentId =d.id \\n) \\n\\nselect sub.Department , sub.Employee  , sub.Salary\\nfrom (\\nselect Department,Employee,Salary, dense_rank()over(partition by Department order by Salary desc) as rank_\\nfrom joined_ \\n) sub\\nwhere sub.rank_ =1;`"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH DEP AS (\\n    SELECT \\n        DISTINCT D.name AS Department, \\n        E1.name AS Employee, \\n        E1.salary AS salary\\n    FROM \\n        Employee E1 JOIN Department D ON E1.departmentId = D.id\\n    WHERE \\n        E1.salary in (SELECT MAX(salary) FROM EMPLOYEE E2 WHERE E2.departmentId = E1.departmentId)\\n)\\n\\nSELECT * FROM DEP;"
                    },
                    {
                        "username": "javedabdool13",
                        "content": "with cte as (\\nselect D.name as Department ,E.name as Employee,E.salary as Salary,\\ncase when max(E.salary) over(partition by D.name) = E.salary  then 1 else 0 end as x\\nfrom Employee E\\ninner join Department D on E.departmentId = D.id) \\n\\nselect DEpartment,Employee,Salary from cte \\nwhere x = 1\\n"
                    },
                    {
                        "username": "Ansh123",
                        "content": "`with dept as (select d.id, d.name,\\nmax(salary) as Salary\\nfrom Employee e inner join Department d on e.departmentId=d.id\\ngroup by 1,2)\\nselect d.name as Department, e.name as Employee, d.Salary from Employee e inner join dept d on e.departmentId=d.id and e.salary=d.Salary`"
                    },
                    {
                        "username": "asifanas",
                        "content": "SELECT d.name as Department, temp.name as Employee, temp.salary as Salary FROM department d inner join (SELECT e.name, temp.salary, temp.departmentid FROM employee e inner join (SELECT departmentid, max(salary) as salary FROM employee group by departmentid) as temp on(temp.departmentid=e.departmentid and e.salary=temp.salary)) as temp on(temp.departmentid=d.id);"
                    }
                ]
            },
            {
                "id": 1744587,
                "content": [
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with highest_salary as (select e.name as employee, e.salary as Salary, d.name as Department, DENSE_RANK() OVER(PARTITION BY d.name order by Salary desc) as sal_rank from Employee e join Department d on e.departmentId = d.id)\\n\\nselect Department, Employee, Salary from highest_salary where sal_rank = 1;`"
                    },
                    {
                        "username": "abhilaash31270",
                        "content": "select d.name Department ,e.name Employee,e.salary Salary from Employee e inner join Department d on e.departmentId=d.id where \\n(departmentId,salary) in (select departmentId,max(salary) from employee group by departmentId);"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "WITH ranktable AS\\n(SELECT d.name as Department ,e.name as Employee, e.salary as salary, DENSE_RANK() OVER(partition by d.name ORDER BY salary DESC ) as sranks\\nFROM employee as e\\nLEFT JOIN Department as d\\nON e.departmentid=d.id\\n)\\n\\nSELECT Department, Employee,salary\\nFROM ranktable\\nWHERE sranks = 1"
                    },
                    {
                        "username": "EdgarMartinezEsqueda",
                        "content": "`SELECT d.name 'Department', e.name 'Employee', e.salary 'Salary'\nFROM Employee e, Department d\nWHERE e.salary =  (SELECT MAX(salary) FROM Employee WHERE departmentId = d.id) AND e.departmentId = d.id;`\n\nThe 'AND' is just a validation to avoid duplicates"
                    },
                    {
                        "username": "vasanthav251995",
                        "content": "SELECT Department,Employee,Salary from\\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary,\\nDENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) RANK from Employee e\\nLEFT JOIN Department d\\nON e.DepartmentID=d.ID ) a\\nWHERE RANK<=1"
                    },
                    {
                        "username": "user5564YW",
                        "content": " `with joined_ as \\n(\\nselect e.name as Employee,e.salary as Salary ,d.name as Department  from\\nEmployee e\\nleft join\\nDepartment d\\non e.departmentId =d.id \\n) \\n\\nselect sub.Department , sub.Employee  , sub.Salary\\nfrom (\\nselect Department,Employee,Salary, dense_rank()over(partition by Department order by Salary desc) as rank_\\nfrom joined_ \\n) sub\\nwhere sub.rank_ =1;`"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH DEP AS (\\n    SELECT \\n        DISTINCT D.name AS Department, \\n        E1.name AS Employee, \\n        E1.salary AS salary\\n    FROM \\n        Employee E1 JOIN Department D ON E1.departmentId = D.id\\n    WHERE \\n        E1.salary in (SELECT MAX(salary) FROM EMPLOYEE E2 WHERE E2.departmentId = E1.departmentId)\\n)\\n\\nSELECT * FROM DEP;"
                    },
                    {
                        "username": "javedabdool13",
                        "content": "with cte as (\\nselect D.name as Department ,E.name as Employee,E.salary as Salary,\\ncase when max(E.salary) over(partition by D.name) = E.salary  then 1 else 0 end as x\\nfrom Employee E\\ninner join Department D on E.departmentId = D.id) \\n\\nselect DEpartment,Employee,Salary from cte \\nwhere x = 1\\n"
                    },
                    {
                        "username": "Ansh123",
                        "content": "`with dept as (select d.id, d.name,\\nmax(salary) as Salary\\nfrom Employee e inner join Department d on e.departmentId=d.id\\ngroup by 1,2)\\nselect d.name as Department, e.name as Employee, d.Salary from Employee e inner join dept d on e.departmentId=d.id and e.salary=d.Salary`"
                    },
                    {
                        "username": "asifanas",
                        "content": "SELECT d.name as Department, temp.name as Employee, temp.salary as Salary FROM department d inner join (SELECT e.name, temp.salary, temp.departmentid FROM employee e inner join (SELECT departmentid, max(salary) as salary FROM employee group by departmentid) as temp on(temp.departmentid=e.departmentid and e.salary=temp.salary)) as temp on(temp.departmentid=d.id);"
                    }
                ]
            },
            {
                "id": 1735105,
                "content": [
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with highest_salary as (select e.name as employee, e.salary as Salary, d.name as Department, DENSE_RANK() OVER(PARTITION BY d.name order by Salary desc) as sal_rank from Employee e join Department d on e.departmentId = d.id)\\n\\nselect Department, Employee, Salary from highest_salary where sal_rank = 1;`"
                    },
                    {
                        "username": "abhilaash31270",
                        "content": "select d.name Department ,e.name Employee,e.salary Salary from Employee e inner join Department d on e.departmentId=d.id where \\n(departmentId,salary) in (select departmentId,max(salary) from employee group by departmentId);"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "WITH ranktable AS\\n(SELECT d.name as Department ,e.name as Employee, e.salary as salary, DENSE_RANK() OVER(partition by d.name ORDER BY salary DESC ) as sranks\\nFROM employee as e\\nLEFT JOIN Department as d\\nON e.departmentid=d.id\\n)\\n\\nSELECT Department, Employee,salary\\nFROM ranktable\\nWHERE sranks = 1"
                    },
                    {
                        "username": "EdgarMartinezEsqueda",
                        "content": "`SELECT d.name 'Department', e.name 'Employee', e.salary 'Salary'\nFROM Employee e, Department d\nWHERE e.salary =  (SELECT MAX(salary) FROM Employee WHERE departmentId = d.id) AND e.departmentId = d.id;`\n\nThe 'AND' is just a validation to avoid duplicates"
                    },
                    {
                        "username": "vasanthav251995",
                        "content": "SELECT Department,Employee,Salary from\\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary,\\nDENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) RANK from Employee e\\nLEFT JOIN Department d\\nON e.DepartmentID=d.ID ) a\\nWHERE RANK<=1"
                    },
                    {
                        "username": "user5564YW",
                        "content": " `with joined_ as \\n(\\nselect e.name as Employee,e.salary as Salary ,d.name as Department  from\\nEmployee e\\nleft join\\nDepartment d\\non e.departmentId =d.id \\n) \\n\\nselect sub.Department , sub.Employee  , sub.Salary\\nfrom (\\nselect Department,Employee,Salary, dense_rank()over(partition by Department order by Salary desc) as rank_\\nfrom joined_ \\n) sub\\nwhere sub.rank_ =1;`"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH DEP AS (\\n    SELECT \\n        DISTINCT D.name AS Department, \\n        E1.name AS Employee, \\n        E1.salary AS salary\\n    FROM \\n        Employee E1 JOIN Department D ON E1.departmentId = D.id\\n    WHERE \\n        E1.salary in (SELECT MAX(salary) FROM EMPLOYEE E2 WHERE E2.departmentId = E1.departmentId)\\n)\\n\\nSELECT * FROM DEP;"
                    },
                    {
                        "username": "javedabdool13",
                        "content": "with cte as (\\nselect D.name as Department ,E.name as Employee,E.salary as Salary,\\ncase when max(E.salary) over(partition by D.name) = E.salary  then 1 else 0 end as x\\nfrom Employee E\\ninner join Department D on E.departmentId = D.id) \\n\\nselect DEpartment,Employee,Salary from cte \\nwhere x = 1\\n"
                    },
                    {
                        "username": "Ansh123",
                        "content": "`with dept as (select d.id, d.name,\\nmax(salary) as Salary\\nfrom Employee e inner join Department d on e.departmentId=d.id\\ngroup by 1,2)\\nselect d.name as Department, e.name as Employee, d.Salary from Employee e inner join dept d on e.departmentId=d.id and e.salary=d.Salary`"
                    },
                    {
                        "username": "asifanas",
                        "content": "SELECT d.name as Department, temp.name as Employee, temp.salary as Salary FROM department d inner join (SELECT e.name, temp.salary, temp.departmentid FROM employee e inner join (SELECT departmentid, max(salary) as salary FROM employee group by departmentid) as temp on(temp.departmentid=e.departmentid and e.salary=temp.salary)) as temp on(temp.departmentid=d.id);"
                    }
                ]
            },
            {
                "id": 1734308,
                "content": [
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with highest_salary as (select e.name as employee, e.salary as Salary, d.name as Department, DENSE_RANK() OVER(PARTITION BY d.name order by Salary desc) as sal_rank from Employee e join Department d on e.departmentId = d.id)\\n\\nselect Department, Employee, Salary from highest_salary where sal_rank = 1;`"
                    },
                    {
                        "username": "abhilaash31270",
                        "content": "select d.name Department ,e.name Employee,e.salary Salary from Employee e inner join Department d on e.departmentId=d.id where \\n(departmentId,salary) in (select departmentId,max(salary) from employee group by departmentId);"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "WITH ranktable AS\\n(SELECT d.name as Department ,e.name as Employee, e.salary as salary, DENSE_RANK() OVER(partition by d.name ORDER BY salary DESC ) as sranks\\nFROM employee as e\\nLEFT JOIN Department as d\\nON e.departmentid=d.id\\n)\\n\\nSELECT Department, Employee,salary\\nFROM ranktable\\nWHERE sranks = 1"
                    },
                    {
                        "username": "EdgarMartinezEsqueda",
                        "content": "`SELECT d.name 'Department', e.name 'Employee', e.salary 'Salary'\nFROM Employee e, Department d\nWHERE e.salary =  (SELECT MAX(salary) FROM Employee WHERE departmentId = d.id) AND e.departmentId = d.id;`\n\nThe 'AND' is just a validation to avoid duplicates"
                    },
                    {
                        "username": "vasanthav251995",
                        "content": "SELECT Department,Employee,Salary from\\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary,\\nDENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) RANK from Employee e\\nLEFT JOIN Department d\\nON e.DepartmentID=d.ID ) a\\nWHERE RANK<=1"
                    },
                    {
                        "username": "user5564YW",
                        "content": " `with joined_ as \\n(\\nselect e.name as Employee,e.salary as Salary ,d.name as Department  from\\nEmployee e\\nleft join\\nDepartment d\\non e.departmentId =d.id \\n) \\n\\nselect sub.Department , sub.Employee  , sub.Salary\\nfrom (\\nselect Department,Employee,Salary, dense_rank()over(partition by Department order by Salary desc) as rank_\\nfrom joined_ \\n) sub\\nwhere sub.rank_ =1;`"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH DEP AS (\\n    SELECT \\n        DISTINCT D.name AS Department, \\n        E1.name AS Employee, \\n        E1.salary AS salary\\n    FROM \\n        Employee E1 JOIN Department D ON E1.departmentId = D.id\\n    WHERE \\n        E1.salary in (SELECT MAX(salary) FROM EMPLOYEE E2 WHERE E2.departmentId = E1.departmentId)\\n)\\n\\nSELECT * FROM DEP;"
                    },
                    {
                        "username": "javedabdool13",
                        "content": "with cte as (\\nselect D.name as Department ,E.name as Employee,E.salary as Salary,\\ncase when max(E.salary) over(partition by D.name) = E.salary  then 1 else 0 end as x\\nfrom Employee E\\ninner join Department D on E.departmentId = D.id) \\n\\nselect DEpartment,Employee,Salary from cte \\nwhere x = 1\\n"
                    },
                    {
                        "username": "Ansh123",
                        "content": "`with dept as (select d.id, d.name,\\nmax(salary) as Salary\\nfrom Employee e inner join Department d on e.departmentId=d.id\\ngroup by 1,2)\\nselect d.name as Department, e.name as Employee, d.Salary from Employee e inner join dept d on e.departmentId=d.id and e.salary=d.Salary`"
                    },
                    {
                        "username": "asifanas",
                        "content": "SELECT d.name as Department, temp.name as Employee, temp.salary as Salary FROM department d inner join (SELECT e.name, temp.salary, temp.departmentid FROM employee e inner join (SELECT departmentid, max(salary) as salary FROM employee group by departmentid) as temp on(temp.departmentid=e.departmentid and e.salary=temp.salary)) as temp on(temp.departmentid=d.id);"
                    }
                ]
            },
            {
                "id": 1733827,
                "content": [
                    {
                        "username": "Deepak_3024",
                        "content": "# Write your MySQL query statement below\\nselect d.name as Department,\\ne.name as Employee,\\ne.salary as Salary\\nfrom employee e\\njoin Department d on d.id=e.departmentId\\nwhere (d.id,e.salary)in(Select departmentId,max(Salary)\\nfrom employee\\ngroup by departmentId"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "I mainly prefer temp table using with, so here is it, something different, \\n\\n/* Write your T-SQL query statement below */\\nwith reference as (\\nselect \\nE.name as Employee, E.salary as salary, D.id as id, D.name as Department, \\nrank() over (partition by D.id order by D.id, E.salary desc) as rank\\nfrom Employee E\\njoin Department D on E.departmentId = D.id)\\n\\nselect Department, Employee, Salary\\nfrom reference \\nwhere rank=1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk=1"
                    },
                    {
                        "username": "singhprajjawal",
                        "content": "select d.name as Department,e.name as Employee,\\ne.salary as Salary  from Employee e\\ninner join  Department  d on \\nd.id= e.departmentid\\nwhere e.salary>70000\\n\\nResult is accepted but submission is not getting accepted ??\\nanyone opinion?"
                    },
                    {
                        "username": "LiSLeetCode",
                        "content": "What\\'s the difference of those two queries?\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d, Employee e\\nWHERE d.id = e.departmentId;`\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d\\nJOIN Employee e\\nON d.id = e.departmentId;`"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "with temp as(select d.name as department, max(salary) as salary\\nfrom Employee e\\ninner join department d\\non d.id = e.departmentId\\ngroup by d.name)\\n\\nselect temp.Department, sumtemp.Employee, sumtemp.Salary\\nfrom(\\nselect d.name as Department, e.name as Employee, E.salary as Salary\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n) as sumtemp, temp\\nwhere temp.department = sumtemp.Department and temp.salary = sumtemp.Salary"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": " `select d.name as \"Department\" , e.name as \"Employee\" , e.Salary \\nfrom employee e\\ninner join Department d on e.departmentId=d.id \\nwhere 1 > (select count(*) from Employee e2 where d.id=e2.departmentId and e.salary < e2.salary) `"
                    },
                    {
                        "username": "Maobu",
                        "content": "Could somebody tell me why am I wrong in submitting, but right in the run?\\n\"\\'\\'\\nselect d.name as department, e.name as employee, e.salary\\nfrom employee e\\nleft JOIN department d\\non e.departmentid=d.id\\nwhere e.salary in (\\n    select max(salary)\\nfrom employee\\ngroup by departmentid)\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "with cte1 as(select d1.name as Department,e1.name as Employee, e1.salary as Salary,\\ndense_rank()over(partition by d1.name order by e1.salary desc)as rkt\\nfrom Employee e1\\njoin Department d1 \\non e1.departmentId=d1.id )\\nselect Department,Employee, Salary\\nfrom cte1 \\nwhere rkt =1;"
                    },
                    {
                        "username": "srikanthmungi",
                        "content": "with c as (select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from c where c.rank=1\\n"
                    }
                ]
            },
            {
                "id": 1719729,
                "content": [
                    {
                        "username": "Deepak_3024",
                        "content": "# Write your MySQL query statement below\\nselect d.name as Department,\\ne.name as Employee,\\ne.salary as Salary\\nfrom employee e\\njoin Department d on d.id=e.departmentId\\nwhere (d.id,e.salary)in(Select departmentId,max(Salary)\\nfrom employee\\ngroup by departmentId"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "I mainly prefer temp table using with, so here is it, something different, \\n\\n/* Write your T-SQL query statement below */\\nwith reference as (\\nselect \\nE.name as Employee, E.salary as salary, D.id as id, D.name as Department, \\nrank() over (partition by D.id order by D.id, E.salary desc) as rank\\nfrom Employee E\\njoin Department D on E.departmentId = D.id)\\n\\nselect Department, Employee, Salary\\nfrom reference \\nwhere rank=1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk=1"
                    },
                    {
                        "username": "singhprajjawal",
                        "content": "select d.name as Department,e.name as Employee,\\ne.salary as Salary  from Employee e\\ninner join  Department  d on \\nd.id= e.departmentid\\nwhere e.salary>70000\\n\\nResult is accepted but submission is not getting accepted ??\\nanyone opinion?"
                    },
                    {
                        "username": "LiSLeetCode",
                        "content": "What\\'s the difference of those two queries?\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d, Employee e\\nWHERE d.id = e.departmentId;`\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d\\nJOIN Employee e\\nON d.id = e.departmentId;`"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "with temp as(select d.name as department, max(salary) as salary\\nfrom Employee e\\ninner join department d\\non d.id = e.departmentId\\ngroup by d.name)\\n\\nselect temp.Department, sumtemp.Employee, sumtemp.Salary\\nfrom(\\nselect d.name as Department, e.name as Employee, E.salary as Salary\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n) as sumtemp, temp\\nwhere temp.department = sumtemp.Department and temp.salary = sumtemp.Salary"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": " `select d.name as \"Department\" , e.name as \"Employee\" , e.Salary \\nfrom employee e\\ninner join Department d on e.departmentId=d.id \\nwhere 1 > (select count(*) from Employee e2 where d.id=e2.departmentId and e.salary < e2.salary) `"
                    },
                    {
                        "username": "Maobu",
                        "content": "Could somebody tell me why am I wrong in submitting, but right in the run?\\n\"\\'\\'\\nselect d.name as department, e.name as employee, e.salary\\nfrom employee e\\nleft JOIN department d\\non e.departmentid=d.id\\nwhere e.salary in (\\n    select max(salary)\\nfrom employee\\ngroup by departmentid)\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "with cte1 as(select d1.name as Department,e1.name as Employee, e1.salary as Salary,\\ndense_rank()over(partition by d1.name order by e1.salary desc)as rkt\\nfrom Employee e1\\njoin Department d1 \\non e1.departmentId=d1.id )\\nselect Department,Employee, Salary\\nfrom cte1 \\nwhere rkt =1;"
                    },
                    {
                        "username": "srikanthmungi",
                        "content": "with c as (select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from c where c.rank=1\\n"
                    }
                ]
            },
            {
                "id": 1716486,
                "content": [
                    {
                        "username": "Deepak_3024",
                        "content": "# Write your MySQL query statement below\\nselect d.name as Department,\\ne.name as Employee,\\ne.salary as Salary\\nfrom employee e\\njoin Department d on d.id=e.departmentId\\nwhere (d.id,e.salary)in(Select departmentId,max(Salary)\\nfrom employee\\ngroup by departmentId"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "I mainly prefer temp table using with, so here is it, something different, \\n\\n/* Write your T-SQL query statement below */\\nwith reference as (\\nselect \\nE.name as Employee, E.salary as salary, D.id as id, D.name as Department, \\nrank() over (partition by D.id order by D.id, E.salary desc) as rank\\nfrom Employee E\\njoin Department D on E.departmentId = D.id)\\n\\nselect Department, Employee, Salary\\nfrom reference \\nwhere rank=1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk=1"
                    },
                    {
                        "username": "singhprajjawal",
                        "content": "select d.name as Department,e.name as Employee,\\ne.salary as Salary  from Employee e\\ninner join  Department  d on \\nd.id= e.departmentid\\nwhere e.salary>70000\\n\\nResult is accepted but submission is not getting accepted ??\\nanyone opinion?"
                    },
                    {
                        "username": "LiSLeetCode",
                        "content": "What\\'s the difference of those two queries?\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d, Employee e\\nWHERE d.id = e.departmentId;`\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d\\nJOIN Employee e\\nON d.id = e.departmentId;`"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "with temp as(select d.name as department, max(salary) as salary\\nfrom Employee e\\ninner join department d\\non d.id = e.departmentId\\ngroup by d.name)\\n\\nselect temp.Department, sumtemp.Employee, sumtemp.Salary\\nfrom(\\nselect d.name as Department, e.name as Employee, E.salary as Salary\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n) as sumtemp, temp\\nwhere temp.department = sumtemp.Department and temp.salary = sumtemp.Salary"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": " `select d.name as \"Department\" , e.name as \"Employee\" , e.Salary \\nfrom employee e\\ninner join Department d on e.departmentId=d.id \\nwhere 1 > (select count(*) from Employee e2 where d.id=e2.departmentId and e.salary < e2.salary) `"
                    },
                    {
                        "username": "Maobu",
                        "content": "Could somebody tell me why am I wrong in submitting, but right in the run?\\n\"\\'\\'\\nselect d.name as department, e.name as employee, e.salary\\nfrom employee e\\nleft JOIN department d\\non e.departmentid=d.id\\nwhere e.salary in (\\n    select max(salary)\\nfrom employee\\ngroup by departmentid)\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "with cte1 as(select d1.name as Department,e1.name as Employee, e1.salary as Salary,\\ndense_rank()over(partition by d1.name order by e1.salary desc)as rkt\\nfrom Employee e1\\njoin Department d1 \\non e1.departmentId=d1.id )\\nselect Department,Employee, Salary\\nfrom cte1 \\nwhere rkt =1;"
                    },
                    {
                        "username": "srikanthmungi",
                        "content": "with c as (select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from c where c.rank=1\\n"
                    }
                ]
            },
            {
                "id": 1713316,
                "content": [
                    {
                        "username": "Deepak_3024",
                        "content": "# Write your MySQL query statement below\\nselect d.name as Department,\\ne.name as Employee,\\ne.salary as Salary\\nfrom employee e\\njoin Department d on d.id=e.departmentId\\nwhere (d.id,e.salary)in(Select departmentId,max(Salary)\\nfrom employee\\ngroup by departmentId"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "I mainly prefer temp table using with, so here is it, something different, \\n\\n/* Write your T-SQL query statement below */\\nwith reference as (\\nselect \\nE.name as Employee, E.salary as salary, D.id as id, D.name as Department, \\nrank() over (partition by D.id order by D.id, E.salary desc) as rank\\nfrom Employee E\\njoin Department D on E.departmentId = D.id)\\n\\nselect Department, Employee, Salary\\nfrom reference \\nwhere rank=1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk=1"
                    },
                    {
                        "username": "singhprajjawal",
                        "content": "select d.name as Department,e.name as Employee,\\ne.salary as Salary  from Employee e\\ninner join  Department  d on \\nd.id= e.departmentid\\nwhere e.salary>70000\\n\\nResult is accepted but submission is not getting accepted ??\\nanyone opinion?"
                    },
                    {
                        "username": "LiSLeetCode",
                        "content": "What\\'s the difference of those two queries?\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d, Employee e\\nWHERE d.id = e.departmentId;`\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d\\nJOIN Employee e\\nON d.id = e.departmentId;`"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "with temp as(select d.name as department, max(salary) as salary\\nfrom Employee e\\ninner join department d\\non d.id = e.departmentId\\ngroup by d.name)\\n\\nselect temp.Department, sumtemp.Employee, sumtemp.Salary\\nfrom(\\nselect d.name as Department, e.name as Employee, E.salary as Salary\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n) as sumtemp, temp\\nwhere temp.department = sumtemp.Department and temp.salary = sumtemp.Salary"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": " `select d.name as \"Department\" , e.name as \"Employee\" , e.Salary \\nfrom employee e\\ninner join Department d on e.departmentId=d.id \\nwhere 1 > (select count(*) from Employee e2 where d.id=e2.departmentId and e.salary < e2.salary) `"
                    },
                    {
                        "username": "Maobu",
                        "content": "Could somebody tell me why am I wrong in submitting, but right in the run?\\n\"\\'\\'\\nselect d.name as department, e.name as employee, e.salary\\nfrom employee e\\nleft JOIN department d\\non e.departmentid=d.id\\nwhere e.salary in (\\n    select max(salary)\\nfrom employee\\ngroup by departmentid)\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "with cte1 as(select d1.name as Department,e1.name as Employee, e1.salary as Salary,\\ndense_rank()over(partition by d1.name order by e1.salary desc)as rkt\\nfrom Employee e1\\njoin Department d1 \\non e1.departmentId=d1.id )\\nselect Department,Employee, Salary\\nfrom cte1 \\nwhere rkt =1;"
                    },
                    {
                        "username": "srikanthmungi",
                        "content": "with c as (select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from c where c.rank=1\\n"
                    }
                ]
            },
            {
                "id": 1709048,
                "content": [
                    {
                        "username": "Deepak_3024",
                        "content": "# Write your MySQL query statement below\\nselect d.name as Department,\\ne.name as Employee,\\ne.salary as Salary\\nfrom employee e\\njoin Department d on d.id=e.departmentId\\nwhere (d.id,e.salary)in(Select departmentId,max(Salary)\\nfrom employee\\ngroup by departmentId"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "I mainly prefer temp table using with, so here is it, something different, \\n\\n/* Write your T-SQL query statement below */\\nwith reference as (\\nselect \\nE.name as Employee, E.salary as salary, D.id as id, D.name as Department, \\nrank() over (partition by D.id order by D.id, E.salary desc) as rank\\nfrom Employee E\\njoin Department D on E.departmentId = D.id)\\n\\nselect Department, Employee, Salary\\nfrom reference \\nwhere rank=1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk=1"
                    },
                    {
                        "username": "singhprajjawal",
                        "content": "select d.name as Department,e.name as Employee,\\ne.salary as Salary  from Employee e\\ninner join  Department  d on \\nd.id= e.departmentid\\nwhere e.salary>70000\\n\\nResult is accepted but submission is not getting accepted ??\\nanyone opinion?"
                    },
                    {
                        "username": "LiSLeetCode",
                        "content": "What\\'s the difference of those two queries?\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d, Employee e\\nWHERE d.id = e.departmentId;`\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d\\nJOIN Employee e\\nON d.id = e.departmentId;`"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "with temp as(select d.name as department, max(salary) as salary\\nfrom Employee e\\ninner join department d\\non d.id = e.departmentId\\ngroup by d.name)\\n\\nselect temp.Department, sumtemp.Employee, sumtemp.Salary\\nfrom(\\nselect d.name as Department, e.name as Employee, E.salary as Salary\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n) as sumtemp, temp\\nwhere temp.department = sumtemp.Department and temp.salary = sumtemp.Salary"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": " `select d.name as \"Department\" , e.name as \"Employee\" , e.Salary \\nfrom employee e\\ninner join Department d on e.departmentId=d.id \\nwhere 1 > (select count(*) from Employee e2 where d.id=e2.departmentId and e.salary < e2.salary) `"
                    },
                    {
                        "username": "Maobu",
                        "content": "Could somebody tell me why am I wrong in submitting, but right in the run?\\n\"\\'\\'\\nselect d.name as department, e.name as employee, e.salary\\nfrom employee e\\nleft JOIN department d\\non e.departmentid=d.id\\nwhere e.salary in (\\n    select max(salary)\\nfrom employee\\ngroup by departmentid)\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "with cte1 as(select d1.name as Department,e1.name as Employee, e1.salary as Salary,\\ndense_rank()over(partition by d1.name order by e1.salary desc)as rkt\\nfrom Employee e1\\njoin Department d1 \\non e1.departmentId=d1.id )\\nselect Department,Employee, Salary\\nfrom cte1 \\nwhere rkt =1;"
                    },
                    {
                        "username": "srikanthmungi",
                        "content": "with c as (select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from c where c.rank=1\\n"
                    }
                ]
            },
            {
                "id": 1705977,
                "content": [
                    {
                        "username": "Deepak_3024",
                        "content": "# Write your MySQL query statement below\\nselect d.name as Department,\\ne.name as Employee,\\ne.salary as Salary\\nfrom employee e\\njoin Department d on d.id=e.departmentId\\nwhere (d.id,e.salary)in(Select departmentId,max(Salary)\\nfrom employee\\ngroup by departmentId"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "I mainly prefer temp table using with, so here is it, something different, \\n\\n/* Write your T-SQL query statement below */\\nwith reference as (\\nselect \\nE.name as Employee, E.salary as salary, D.id as id, D.name as Department, \\nrank() over (partition by D.id order by D.id, E.salary desc) as rank\\nfrom Employee E\\njoin Department D on E.departmentId = D.id)\\n\\nselect Department, Employee, Salary\\nfrom reference \\nwhere rank=1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk=1"
                    },
                    {
                        "username": "singhprajjawal",
                        "content": "select d.name as Department,e.name as Employee,\\ne.salary as Salary  from Employee e\\ninner join  Department  d on \\nd.id= e.departmentid\\nwhere e.salary>70000\\n\\nResult is accepted but submission is not getting accepted ??\\nanyone opinion?"
                    },
                    {
                        "username": "LiSLeetCode",
                        "content": "What\\'s the difference of those two queries?\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d, Employee e\\nWHERE d.id = e.departmentId;`\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d\\nJOIN Employee e\\nON d.id = e.departmentId;`"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "with temp as(select d.name as department, max(salary) as salary\\nfrom Employee e\\ninner join department d\\non d.id = e.departmentId\\ngroup by d.name)\\n\\nselect temp.Department, sumtemp.Employee, sumtemp.Salary\\nfrom(\\nselect d.name as Department, e.name as Employee, E.salary as Salary\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n) as sumtemp, temp\\nwhere temp.department = sumtemp.Department and temp.salary = sumtemp.Salary"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": " `select d.name as \"Department\" , e.name as \"Employee\" , e.Salary \\nfrom employee e\\ninner join Department d on e.departmentId=d.id \\nwhere 1 > (select count(*) from Employee e2 where d.id=e2.departmentId and e.salary < e2.salary) `"
                    },
                    {
                        "username": "Maobu",
                        "content": "Could somebody tell me why am I wrong in submitting, but right in the run?\\n\"\\'\\'\\nselect d.name as department, e.name as employee, e.salary\\nfrom employee e\\nleft JOIN department d\\non e.departmentid=d.id\\nwhere e.salary in (\\n    select max(salary)\\nfrom employee\\ngroup by departmentid)\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "with cte1 as(select d1.name as Department,e1.name as Employee, e1.salary as Salary,\\ndense_rank()over(partition by d1.name order by e1.salary desc)as rkt\\nfrom Employee e1\\njoin Department d1 \\non e1.departmentId=d1.id )\\nselect Department,Employee, Salary\\nfrom cte1 \\nwhere rkt =1;"
                    },
                    {
                        "username": "srikanthmungi",
                        "content": "with c as (select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from c where c.rank=1\\n"
                    }
                ]
            },
            {
                "id": 1703765,
                "content": [
                    {
                        "username": "Deepak_3024",
                        "content": "# Write your MySQL query statement below\\nselect d.name as Department,\\ne.name as Employee,\\ne.salary as Salary\\nfrom employee e\\njoin Department d on d.id=e.departmentId\\nwhere (d.id,e.salary)in(Select departmentId,max(Salary)\\nfrom employee\\ngroup by departmentId"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "I mainly prefer temp table using with, so here is it, something different, \\n\\n/* Write your T-SQL query statement below */\\nwith reference as (\\nselect \\nE.name as Employee, E.salary as salary, D.id as id, D.name as Department, \\nrank() over (partition by D.id order by D.id, E.salary desc) as rank\\nfrom Employee E\\njoin Department D on E.departmentId = D.id)\\n\\nselect Department, Employee, Salary\\nfrom reference \\nwhere rank=1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk=1"
                    },
                    {
                        "username": "singhprajjawal",
                        "content": "select d.name as Department,e.name as Employee,\\ne.salary as Salary  from Employee e\\ninner join  Department  d on \\nd.id= e.departmentid\\nwhere e.salary>70000\\n\\nResult is accepted but submission is not getting accepted ??\\nanyone opinion?"
                    },
                    {
                        "username": "LiSLeetCode",
                        "content": "What\\'s the difference of those two queries?\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d, Employee e\\nWHERE d.id = e.departmentId;`\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d\\nJOIN Employee e\\nON d.id = e.departmentId;`"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "with temp as(select d.name as department, max(salary) as salary\\nfrom Employee e\\ninner join department d\\non d.id = e.departmentId\\ngroup by d.name)\\n\\nselect temp.Department, sumtemp.Employee, sumtemp.Salary\\nfrom(\\nselect d.name as Department, e.name as Employee, E.salary as Salary\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n) as sumtemp, temp\\nwhere temp.department = sumtemp.Department and temp.salary = sumtemp.Salary"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": " `select d.name as \"Department\" , e.name as \"Employee\" , e.Salary \\nfrom employee e\\ninner join Department d on e.departmentId=d.id \\nwhere 1 > (select count(*) from Employee e2 where d.id=e2.departmentId and e.salary < e2.salary) `"
                    },
                    {
                        "username": "Maobu",
                        "content": "Could somebody tell me why am I wrong in submitting, but right in the run?\\n\"\\'\\'\\nselect d.name as department, e.name as employee, e.salary\\nfrom employee e\\nleft JOIN department d\\non e.departmentid=d.id\\nwhere e.salary in (\\n    select max(salary)\\nfrom employee\\ngroup by departmentid)\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "with cte1 as(select d1.name as Department,e1.name as Employee, e1.salary as Salary,\\ndense_rank()over(partition by d1.name order by e1.salary desc)as rkt\\nfrom Employee e1\\njoin Department d1 \\non e1.departmentId=d1.id )\\nselect Department,Employee, Salary\\nfrom cte1 \\nwhere rkt =1;"
                    },
                    {
                        "username": "srikanthmungi",
                        "content": "with c as (select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from c where c.rank=1\\n"
                    }
                ]
            },
            {
                "id": 1693435,
                "content": [
                    {
                        "username": "Deepak_3024",
                        "content": "# Write your MySQL query statement below\\nselect d.name as Department,\\ne.name as Employee,\\ne.salary as Salary\\nfrom employee e\\njoin Department d on d.id=e.departmentId\\nwhere (d.id,e.salary)in(Select departmentId,max(Salary)\\nfrom employee\\ngroup by departmentId"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "I mainly prefer temp table using with, so here is it, something different, \\n\\n/* Write your T-SQL query statement below */\\nwith reference as (\\nselect \\nE.name as Employee, E.salary as salary, D.id as id, D.name as Department, \\nrank() over (partition by D.id order by D.id, E.salary desc) as rank\\nfrom Employee E\\njoin Department D on E.departmentId = D.id)\\n\\nselect Department, Employee, Salary\\nfrom reference \\nwhere rank=1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk=1"
                    },
                    {
                        "username": "singhprajjawal",
                        "content": "select d.name as Department,e.name as Employee,\\ne.salary as Salary  from Employee e\\ninner join  Department  d on \\nd.id= e.departmentid\\nwhere e.salary>70000\\n\\nResult is accepted but submission is not getting accepted ??\\nanyone opinion?"
                    },
                    {
                        "username": "LiSLeetCode",
                        "content": "What\\'s the difference of those two queries?\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d, Employee e\\nWHERE d.id = e.departmentId;`\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d\\nJOIN Employee e\\nON d.id = e.departmentId;`"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "with temp as(select d.name as department, max(salary) as salary\\nfrom Employee e\\ninner join department d\\non d.id = e.departmentId\\ngroup by d.name)\\n\\nselect temp.Department, sumtemp.Employee, sumtemp.Salary\\nfrom(\\nselect d.name as Department, e.name as Employee, E.salary as Salary\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n) as sumtemp, temp\\nwhere temp.department = sumtemp.Department and temp.salary = sumtemp.Salary"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": " `select d.name as \"Department\" , e.name as \"Employee\" , e.Salary \\nfrom employee e\\ninner join Department d on e.departmentId=d.id \\nwhere 1 > (select count(*) from Employee e2 where d.id=e2.departmentId and e.salary < e2.salary) `"
                    },
                    {
                        "username": "Maobu",
                        "content": "Could somebody tell me why am I wrong in submitting, but right in the run?\\n\"\\'\\'\\nselect d.name as department, e.name as employee, e.salary\\nfrom employee e\\nleft JOIN department d\\non e.departmentid=d.id\\nwhere e.salary in (\\n    select max(salary)\\nfrom employee\\ngroup by departmentid)\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "with cte1 as(select d1.name as Department,e1.name as Employee, e1.salary as Salary,\\ndense_rank()over(partition by d1.name order by e1.salary desc)as rkt\\nfrom Employee e1\\njoin Department d1 \\non e1.departmentId=d1.id )\\nselect Department,Employee, Salary\\nfrom cte1 \\nwhere rkt =1;"
                    },
                    {
                        "username": "srikanthmungi",
                        "content": "with c as (select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from c where c.rank=1\\n"
                    }
                ]
            },
            {
                "id": 1692717,
                "content": [
                    {
                        "username": "Deepak_3024",
                        "content": "# Write your MySQL query statement below\\nselect d.name as Department,\\ne.name as Employee,\\ne.salary as Salary\\nfrom employee e\\njoin Department d on d.id=e.departmentId\\nwhere (d.id,e.salary)in(Select departmentId,max(Salary)\\nfrom employee\\ngroup by departmentId"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "I mainly prefer temp table using with, so here is it, something different, \\n\\n/* Write your T-SQL query statement below */\\nwith reference as (\\nselect \\nE.name as Employee, E.salary as salary, D.id as id, D.name as Department, \\nrank() over (partition by D.id order by D.id, E.salary desc) as rank\\nfrom Employee E\\njoin Department D on E.departmentId = D.id)\\n\\nselect Department, Employee, Salary\\nfrom reference \\nwhere rank=1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk=1"
                    },
                    {
                        "username": "singhprajjawal",
                        "content": "select d.name as Department,e.name as Employee,\\ne.salary as Salary  from Employee e\\ninner join  Department  d on \\nd.id= e.departmentid\\nwhere e.salary>70000\\n\\nResult is accepted but submission is not getting accepted ??\\nanyone opinion?"
                    },
                    {
                        "username": "LiSLeetCode",
                        "content": "What\\'s the difference of those two queries?\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d, Employee e\\nWHERE d.id = e.departmentId;`\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d\\nJOIN Employee e\\nON d.id = e.departmentId;`"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "with temp as(select d.name as department, max(salary) as salary\\nfrom Employee e\\ninner join department d\\non d.id = e.departmentId\\ngroup by d.name)\\n\\nselect temp.Department, sumtemp.Employee, sumtemp.Salary\\nfrom(\\nselect d.name as Department, e.name as Employee, E.salary as Salary\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n) as sumtemp, temp\\nwhere temp.department = sumtemp.Department and temp.salary = sumtemp.Salary"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": " `select d.name as \"Department\" , e.name as \"Employee\" , e.Salary \\nfrom employee e\\ninner join Department d on e.departmentId=d.id \\nwhere 1 > (select count(*) from Employee e2 where d.id=e2.departmentId and e.salary < e2.salary) `"
                    },
                    {
                        "username": "Maobu",
                        "content": "Could somebody tell me why am I wrong in submitting, but right in the run?\\n\"\\'\\'\\nselect d.name as department, e.name as employee, e.salary\\nfrom employee e\\nleft JOIN department d\\non e.departmentid=d.id\\nwhere e.salary in (\\n    select max(salary)\\nfrom employee\\ngroup by departmentid)\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "with cte1 as(select d1.name as Department,e1.name as Employee, e1.salary as Salary,\\ndense_rank()over(partition by d1.name order by e1.salary desc)as rkt\\nfrom Employee e1\\njoin Department d1 \\non e1.departmentId=d1.id )\\nselect Department,Employee, Salary\\nfrom cte1 \\nwhere rkt =1;"
                    },
                    {
                        "username": "srikanthmungi",
                        "content": "with c as (select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from c where c.rank=1\\n"
                    }
                ]
            },
            {
                "id": 1681613,
                "content": [
                    {
                        "username": "Deepak_3024",
                        "content": "# Write your MySQL query statement below\\nselect d.name as Department,\\ne.name as Employee,\\ne.salary as Salary\\nfrom employee e\\njoin Department d on d.id=e.departmentId\\nwhere (d.id,e.salary)in(Select departmentId,max(Salary)\\nfrom employee\\ngroup by departmentId"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "I mainly prefer temp table using with, so here is it, something different, \\n\\n/* Write your T-SQL query statement below */\\nwith reference as (\\nselect \\nE.name as Employee, E.salary as salary, D.id as id, D.name as Department, \\nrank() over (partition by D.id order by D.id, E.salary desc) as rank\\nfrom Employee E\\njoin Department D on E.departmentId = D.id)\\n\\nselect Department, Employee, Salary\\nfrom reference \\nwhere rank=1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk=1"
                    },
                    {
                        "username": "singhprajjawal",
                        "content": "select d.name as Department,e.name as Employee,\\ne.salary as Salary  from Employee e\\ninner join  Department  d on \\nd.id= e.departmentid\\nwhere e.salary>70000\\n\\nResult is accepted but submission is not getting accepted ??\\nanyone opinion?"
                    },
                    {
                        "username": "LiSLeetCode",
                        "content": "What\\'s the difference of those two queries?\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d, Employee e\\nWHERE d.id = e.departmentId;`\\n\\n`SELECT d.name AS Department, e.name AS Employee, e.salary AS salary\\nFROM Department d\\nJOIN Employee e\\nON d.id = e.departmentId;`"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "with temp as(select d.name as department, max(salary) as salary\\nfrom Employee e\\ninner join department d\\non d.id = e.departmentId\\ngroup by d.name)\\n\\nselect temp.Department, sumtemp.Employee, sumtemp.Salary\\nfrom(\\nselect d.name as Department, e.name as Employee, E.salary as Salary\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n) as sumtemp, temp\\nwhere temp.department = sumtemp.Department and temp.salary = sumtemp.Salary"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": " `select d.name as \"Department\" , e.name as \"Employee\" , e.Salary \\nfrom employee e\\ninner join Department d on e.departmentId=d.id \\nwhere 1 > (select count(*) from Employee e2 where d.id=e2.departmentId and e.salary < e2.salary) `"
                    },
                    {
                        "username": "Maobu",
                        "content": "Could somebody tell me why am I wrong in submitting, but right in the run?\\n\"\\'\\'\\nselect d.name as department, e.name as employee, e.salary\\nfrom employee e\\nleft JOIN department d\\non e.departmentid=d.id\\nwhere e.salary in (\\n    select max(salary)\\nfrom employee\\ngroup by departmentid)\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "with cte1 as(select d1.name as Department,e1.name as Employee, e1.salary as Salary,\\ndense_rank()over(partition by d1.name order by e1.salary desc)as rkt\\nfrom Employee e1\\njoin Department d1 \\non e1.departmentId=d1.id )\\nselect Department,Employee, Salary\\nfrom cte1 \\nwhere rkt =1;"
                    },
                    {
                        "username": "srikanthmungi",
                        "content": "with c as (select d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary as \\'Salary\\', rank() over(PARTITION by d.Name order by Salary desc) as \\'rank\\'\\nfrom Employee e join Department d on e.DepartmentId=d.Id)\\nselect Department,Employee,Salary from c where c.rank=1\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Map Sum Pairs",
        "question_content": "<p>Design a map that allows you to do the following:</p>\n\n<ul>\n\t<li>Maps a string key to a given value.</li>\n\t<li>Returns the sum of the values that have a key with a prefix equal to a given string.</li>\n</ul>\n\n<p>Implement the <code>MapSum</code> class:</p>\n\n<ul>\n\t<li><code>MapSum()</code> Initializes the <code>MapSum</code> object.</li>\n\t<li><code>void insert(String key, int val)</code> Inserts the <code>key-val</code> pair into the map. If the <code>key</code> already existed, the original <code>key-value</code> pair will be overridden to the new one.</li>\n\t<li><code>int sum(string prefix)</code> Returns the sum of all the pairs&#39; value whose <code>key</code> starts with the <code>prefix</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MapSum&quot;, &quot;insert&quot;, &quot;sum&quot;, &quot;insert&quot;, &quot;sum&quot;]\n[[], [&quot;apple&quot;, 3], [&quot;ap&quot;], [&quot;app&quot;, 2], [&quot;ap&quot;]]\n<strong>Output</strong>\n[null, null, 3, null, 5]\n\n<strong>Explanation</strong>\nMapSum mapSum = new MapSum();\nmapSum.insert(&quot;apple&quot;, 3);  \nmapSum.sum(&quot;ap&quot;);           // return 3 (<u>ap</u>ple = 3)\nmapSum.insert(&quot;app&quot;, 2);    \nmapSum.sum(&quot;ap&quot;);           // return 5 (<u>ap</u>ple + <u>ap</u>p = 3 + 2 = 5)\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= key.length, prefix.length &lt;= 50</code></li>\n\t<li><code>key</code> and <code>prefix</code> consist of only lowercase English letters.</li>\n\t<li><code>1 &lt;= val &lt;= 1000</code></li>\n\t<li>At most <code>50</code> calls will be made to <code>insert</code> and <code>sum</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1371761,
                "title": "c-java-python-trie-hashmap-efficient-clean-concise",
                "content": "**Idea**\\n- Use Trie to build graph structure of all keys string.\\n- When `insert(key, val)`, the `key` string will go through nodes corresponding to characters of `key` string in the Trie structure, we increase `sum` value of the passing nodes by `diff`, where `diff` is calculated as new value - existed value, so `diff = val - self.map[key]`.\\n- Why increase `sum` value of the passing nodes by `diff` but not by `val`?\\n\\t- Because the problem said: `if the key already existed, the original key-value pair will be overridden to the new one`. So this case of existed, we need to minus the old value, and plus with the new value.\\n\\t- That\\'s why we need a HashMap structure to store the old value coressponding to string `key`.\\n- To calculate `sum(string prefix)`, we just find the node in the Trie that the `prefix` string stop and return the sum value of that node.\\n\\n<iframe src=\"https://leetcode.com/playground/Puqd87ZM/shared\" frameBorder=\"0\" width=\"100%\" height=\"590\"></iframe>\\n\\n**Complexity**\\n- Time:\\n\\t- insert: `O(K)`, where `K <= 50` is length of `key` string.\\n\\t- sum: `O(P)`, where `P <= 50` is length of `prefix` string.\\n- Space: `O(T)`, where `T` is the total of nodes after inserting all `key` string, T <= total characters of `key` strings.",
                "solutionTags": [],
                "code": "**Idea**\\n- Use Trie to build graph structure of all keys string.\\n- When `insert(key, val)`, the `key` string will go through nodes corresponding to characters of `key` string in the Trie structure, we increase `sum` value of the passing nodes by `diff`, where `diff` is calculated as new value - existed value, so `diff = val - self.map[key]`.\\n- Why increase `sum` value of the passing nodes by `diff` but not by `val`?\\n\\t- Because the problem said: `if the key already existed, the original key-value pair will be overridden to the new one`. So this case of existed, we need to minus the old value, and plus with the new value.\\n\\t- That\\'s why we need a HashMap structure to store the old value coressponding to string `key`.\\n- To calculate `sum(string prefix)`, we just find the node in the Trie that the `prefix` string stop and return the sum value of that node.\\n\\n<iframe src=\"https://leetcode.com/playground/Puqd87ZM/shared\" frameBorder=\"0\" width=\"100%\" height=\"590\"></iframe>\\n\\n**Complexity**\\n- Time:\\n\\t- insert: `O(K)`, where `K <= 50` is length of `key` string.\\n\\t- sum: `O(P)`, where `P <= 50` is length of `prefix` string.\\n- Space: `O(T)`, where `T` is the total of nodes after inserting all `key` string, T <= total characters of `key` strings.",
                "codeTag": "Unknown"
            },
            {
                "id": 107520,
                "title": "c-easy-solution-ordered-map",
                "content": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */    \\n    void insert(string key, int val) {\\n        mp[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int sum = 0, n = prefix.size();\\n        for (auto it = mp.lower_bound(prefix); it != mp.end() && it->first.substr(0, n) == prefix; it++) \\n            sum += it->second;\\n        return sum;\\n    }\\nprivate:\\n    map<string, int> mp;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */    \\n    void insert(string key, int val) {\\n        mp[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int sum = 0, n = prefix.size();\\n        for (auto it = mp.lower_bound(prefix); it != mp.end() && it->first.substr(0, n) == prefix; it++) \\n            sum += it->second;\\n        return sum;\\n    }\\nprivate:\\n    map<string, int> mp;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107513,
                "title": "java-solution-trie",
                "content": "```\\nclass MapSum {\\n    class TrieNode {\\n        Map<Character, TrieNode> children;\\n        boolean isWord;\\n        int value;\\n\\n        public TrieNode() {\\n            children = new HashMap<Character, TrieNode>();\\n            isWord = false;\\n            value = 0;\\n        }\\n    }\\n    \\n    TrieNode root;\\n    \\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        TrieNode curr = root;\\n        for (char c : key.toCharArray()) {\\n            TrieNode next = curr.children.get(c);\\n            if (next == null) {\\n                next = new TrieNode();\\n                curr.children.put(c, next);\\n            }\\n            curr = next;\\n        }\\n        curr.isWord = true;\\n        curr.value = val;\\n    }\\n    \\n    public int sum(String prefix) {\\n        TrieNode curr = root;\\n\\tfor (char c : prefix.toCharArray()) {\\n\\t    TrieNode next = curr.children.get(c);\\n\\t    if (next == null) {\\n\\t        return 0;\\n\\t    }\\n\\t    curr = next;\\n        }\\n\\t\\t\\n        return dfs(curr);\\n    }\\n    \\n    private int dfs(TrieNode root) {\\n        int sum = 0;\\n        for (char c : root.children.keySet()) {\\n            sum += dfs(root.children.get(c));\\n        }\\n        return sum + root.value;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n    class TrieNode {\\n        Map<Character, TrieNode> children;\\n        boolean isWord;\\n        int value;\\n\\n        public TrieNode() {\\n            children = new HashMap<Character, TrieNode>();\\n            isWord = false;\\n            value = 0;\\n        }\\n    }\\n    \\n    TrieNode root;\\n    \\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        TrieNode curr = root;\\n        for (char c : key.toCharArray()) {\\n            TrieNode next = curr.children.get(c);\\n            if (next == null) {\\n                next = new TrieNode();\\n                curr.children.put(c, next);\\n            }\\n            curr = next;\\n        }\\n        curr.isWord = true;\\n        curr.value = val;\\n    }\\n    \\n    public int sum(String prefix) {\\n        TrieNode curr = root;\\n\\tfor (char c : prefix.toCharArray()) {\\n\\t    TrieNode next = curr.children.get(c);\\n\\t    if (next == null) {\\n\\t        return 0;\\n\\t    }\\n\\t    curr = next;\\n        }\\n\\t\\t\\n        return dfs(curr);\\n    }\\n    \\n    private int dfs(TrieNode root) {\\n        int sum = 0;\\n        for (char c : root.children.keySet()) {\\n            sum += dfs(root.children.get(c));\\n        }\\n        return sum + root.value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107551,
                "title": "python-3-lines-solution",
                "content": "```\\nclass MapSum(object):\\n\\n    def __init__(self): \\n        self.d = {}\\n\\n    def insert(self, key, val): \\n        self.d[key] = val\\n\\n    def sum(self, prefix):\\n        return sum(self.d[i] for i in self.d if i.startswith(prefix))\\n````\\nEdited after Stefan\\'s suggestion.",
                "solutionTags": [],
                "code": "```\\nclass MapSum(object):\\n\\n    def __init__(self): \\n        self.d = {}\\n\\n    def insert(self, key, val): \\n        self.d[key] = val\\n\\n    def sum(self, prefix):\\n        return sum(self.d[i] for i in self.d if i.startswith(prefix))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107508,
                "title": "python-efficient-o-k-insert-and-sum-using-trie",
                "content": "A standard `Trie`-based solution where each node keeps track of the total count of its children. \\n\\nFor inserting, we first determine if the string already exists in the Trie. If it does, we calculate the difference in the previous and new value, and update the nodes with the difference as we traverse down the Trie nodes. \\n\\nSum is simple because each node already holds the sum of its children and we simply have to traverse to the node and obtain its count.\\n\\nThis results in both operations being O(k), where k is the length of the string/prefix.\\n\\n**\\uD83D\\uDCAF Check out https://techinterviewhandbook.org for more tips and tricks to ace your technical interview \\uD83D\\uDCAF**\\n\\n```\\nclass TrieNode():\\n    def __init__(self, count = 0):\\n        self.count = count\\n        self.children = {}\\n                \\nclass MapSum(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n        self.keys = {}\\n\\n    def insert(self, key, val):\\n        \"\"\"\\n        :type key: str\\n        :type val: int\\n        :rtype: void\\n        \"\"\"\\n        # Time: O(k)\\n        curr = self.root\\n        delta = val - self.keys.get(key, 0)\\n        self.keys[key] = val\\n        \\n        curr = self.root\\n        curr.count += delta\\n        for char in key:\\n            if char not in curr.children:\\n                curr.children[char] = TrieNode()\\n            curr = curr.children[char]\\n            curr.count += delta\\n        \\n    def sum(self, prefix):\\n        \"\"\"\\n        :type prefix: str\\n        :rtype: int\\n        \"\"\"\\n        # Time: O(k)\\n        curr = self.root\\n        for char in prefix:\\n            if char not in curr.children:\\n                return 0\\n            curr = curr.children[char]\\n        return curr.count\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode():\\n    def __init__(self, count = 0):\\n        self.count = count\\n        self.children = {}\\n                \\nclass MapSum(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n        self.keys = {}\\n\\n    def insert(self, key, val):\\n        \"\"\"\\n        :type key: str\\n        :type val: int\\n        :rtype: void\\n        \"\"\"\\n        # Time: O(k)\\n        curr = self.root\\n        delta = val - self.keys.get(key, 0)\\n        self.keys[key] = val\\n        \\n        curr = self.root\\n        curr.count += delta\\n        for char in key:\\n            if char not in curr.children:\\n                curr.children[char] = TrieNode()\\n            curr = curr.children[char]\\n            curr.count += delta\\n        \\n    def sum(self, prefix):\\n        \"\"\"\\n        :type prefix: str\\n        :rtype: int\\n        \"\"\"\\n        # Time: O(k)\\n        curr = self.root\\n        for char in prefix:\\n            if char not in curr.children:\\n                return 0\\n            curr = curr.children[char]\\n        return curr.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371884,
                "title": "pyhton-trie-solution-explained",
                "content": "When you see word `prefix` in problem formulation, you should definitely think about **trie**. What we need here is classical trie with one additional field: `freq` - frequency of each node. For example when we add word `apple` with `val = 3` we need to add this `3` to all `a, p, p, l, e` nodes. Also we need to deal with this phrase: ` If the key already existed, the original key-value pair will be overridden to the new one`, so we need to keep dictionary of pairs `key - value` to underastand if they already exist in our tree. Then we evaluate `delta = val - self.dic.get(key, 0)` is amount we need to change our values.  For `sum` function we find node in our tree and if it is not there, return `0`, if we can reach it, return frequency of this node.\\n\\n#### Complexity\\nTime complexity is `O(m)` to insert `key` of length `m` as well it is `O(m)` to evaluate `sum` for prefix of length `m`. Space complexity is `O(T)` where `T` it total length of all words.  \\n\\n#### Code\\n```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.freq = 0\\n\\nclass MapSum:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.dic = {}\\n        \\n    def insert(self, key, val):\\n        delta = val - self.dic.get(key, 0)\\n        self.dic[key] = val\\n        node = self.root\\n        node.freq += delta\\n        for symbol in key:\\n            node = node.children.setdefault(symbol, TrieNode())\\n            node.freq += delta\\n        \\n    def sum(self, prefix):\\n        node = self.root\\n        for symbol in prefix:\\n            if symbol not in node.children:\\n                return 0\\n            node = node.children[symbol]\\n        return node.freq\\n```\\n\\n#### Remark\\nNote, that there is bruteforce solution, where you generate all prefixes and put them into hash table with complexity `O(K^2)` for each insertion, but which works even faster than trie solution: the reason is that operation with strings: espacially comparison is **VERY** fast in python, it has speed similar with C/C++ languages: you can try to generate say string `aaa.... aaab` of length `1000` and compare all substrings of length `500`. You will be suprised with resut.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.freq = 0\\n\\nclass MapSum:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.dic = {}\\n        \\n    def insert(self, key, val):\\n        delta = val - self.dic.get(key, 0)\\n        self.dic[key] = val\\n        node = self.root\\n        node.freq += delta\\n        for symbol in key:\\n            node = node.children.setdefault(symbol, TrieNode())\\n            node.freq += delta\\n        \\n    def sum(self, prefix):\\n        node = self.root\\n        for symbol in prefix:\\n            if symbol not in node.children:\\n                return 0\\n            node = node.children[symbol]\\n        return node.freq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107554,
                "title": "c-o-1-9-lines-trie-hash-map",
                "content": "Hash map is to locate existing values, and trie is store the prefixes sum. Technically, the runtime complexity is affected by the size of individual strings, but here we can say O(1) as the string size is limited to 100. \\n```\\nstruct trie { trie* ch[26] = {}; int sum = 0; } root;\\nunordered_map<string, int> pairs;\\nvoid insert(string key, int val) {\\n    auto p = &root;\\n    for (auto i = 0; i < key.size(); p->sum += val - pairs[key], ++i) \\n        p = p->ch[key[i] - 'a'] = p->ch[key[i]  - 'a'] == nullptr ? new trie() : p->ch[key[i] - 'a'];\\n    pairs[key] = val;\\n}\\nint sum(string prefix) {\\n    auto p = &root;\\n    for (auto i = 0; i < prefix.size() && p != nullptr; p = p->ch[prefix[i] - 'a'], ++i) ;\\n    return p == nullptr ? 0 : p->sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct trie { trie* ch[26] = {}; int sum = 0; } root;\\nunordered_map<string, int> pairs;\\nvoid insert(string key, int val) {\\n    auto p = &root;\\n    for (auto i = 0; i < key.size(); p->sum += val - pairs[key], ++i) \\n        p = p->ch[key[i] - 'a'] = p->ch[key[i]  - 'a'] == nullptr ? new trie() : p->ch[key[i] - 'a'];\\n    pairs[key] = val;\\n}\\nint sum(string prefix) {\\n    auto p = &root;\\n    for (auto i = 0; i < prefix.size() && p != nullptr; p = p->ch[prefix[i] - 'a'], ++i) ;\\n    return p == nullptr ? 0 : p->sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151763,
                "title": "python-very-simple-trie-and-dfs",
                "content": "\"\"\"\\nclass Trie(object):\\n    \\n    def __init__(self):\\n        self.children = {}\\n        self.points = 0\\n\\n\\nclass MapSum(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = Trie()\\n        \\n\\n    def insert(self, key, val):\\n        \"\"\"\\n        :type key: str\\n        :type val: int\\n        :rtype: void\\n        \"\"\"\\n        root = self.root\\n        for i in key:\\n            if i not in root.children:\\n                root.children[i] = Trie()\\n            root = root.children[i]\\n        root.points = val\\n        \\n\\n    def sum(self, prefix):\\n        \"\"\"\\n        :type prefix: str\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        node = self.root\\n        for i in prefix:\\n            if i not in node.children:\\n                return 0\\n            node = node.children[i]\\n        stack = []\\n        stack.append(node)\\n        while stack:\\n            x  = stack.pop()\\n            res += x.points\\n            stack.extend(x.children.values())\\n        return res\\n\\n\\n\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\nclass Trie(object):\\n    \\n    def __init__(self):\\n        self.children = {}\\n        self.points = 0\\n\\n\\nclass MapSum(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = Trie()\\n        \\n\\n    def insert(self, key, val):\\n        \"\"\"\\n        :type key: str\\n        :type val: int\\n        :rtype: void\\n        \"\"\"\\n        root = self.root\\n        for i in key:\\n            if i not in root.children:\\n                root.children[i] = Trie()\\n            root = root.children[i]\\n        root.points = val\\n        \\n\\n    def sum(self, prefix):\\n        \"\"\"\\n        :type prefix: str\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        node = self.root\\n        for i in prefix:\\n            if i not in node.children:\\n                return 0\\n            node = node.children[i]\\n        stack = []\\n        stack.append(node)\\n        while stack:\\n            x  = stack.pop()\\n            res += x.points\\n            stack.extend(x.children.values())\\n        return res\\n\\n\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 107515,
                "title": "simple-java-hashmap-solution-o-1-sum-and-o-len-key-insert",
                "content": "***UPDATE : Okay, let me tell you that even though solution look so concise, why you should NOT do this. \\nIt's because of `s += c`. This operation is not O(1), it's O(String::length), which makes for loop to be k^2. And this will break when string is long. Try it yourself as learning with this input for insert - https://pastebin.com/Pjymymgh*** \\n\\nBut if the constraint is that the string are small, like dictionary words or people names, then it should be good.\\n\\nThe key idea is to keep two hash maps, one with just original strings. The other with all prefixes. \\n\\nWhen a duplicate insert is found, then update all it's prefixes with the difference of previous value of the same key(take it from original map)\\n\\nTime Complexity for sum is `O(1)`\\nTime Complexity for insert is ~~`O(len(key))`~~ `O(len(key) ^ 2)`\\n\\n\\n    /** Initialize your data structure here. */\\n    Map<String, Integer> map;\\n    Map<String, Integer> original;\\n    public MapSum() {\\n        map = new HashMap<>();\\n        original = new HashMap<>();\\n    }\\n\\n    public void insert(String key, int val) {\\n        val -= original.getOrDefault(key, 0); // calculate the diff to be added to prefixes\\n        String s = \"\";\\n        for(char c : key.toCharArray()) {\\n            s += c; // creating all prefixes\\n            map.put(s, map.getOrDefault(s, 0) + val); //update/insert all prefixes with new value\\n        }\\n        original.put(key, original.getOrDefault(key, 0) + val);\\n    }\\n\\n    public int sum(String prefix) {\\n        return map.getOrDefault(prefix, 0);\\n    }",
                "solutionTags": [],
                "code": "***UPDATE : Okay, let me tell you that even though solution look so concise, why you should NOT do this. \\nIt's because of `s += c`. This operation is not O(1), it's O(String::length), which makes for loop to be k^2. And this will break when string is long. Try it yourself as learning with this input for insert - https://pastebin.com/Pjymymgh*** \\n\\nBut if the constraint is that the string are small, like dictionary words or people names, then it should be good.\\n\\nThe key idea is to keep two hash maps, one with just original strings. The other with all prefixes. \\n\\nWhen a duplicate insert is found, then update all it's prefixes with the difference of previous value of the same key(take it from original map)\\n\\nTime Complexity for sum is `O(1)`\\nTime Complexity for insert is ~~`O(len(key))`~~ `O(len(key) ^ 2)`\\n\\n\\n    /** Initialize your data structure here. */\\n    Map<String, Integer> map;\\n    Map<String, Integer> original;\\n    public MapSum() {\\n        map = new HashMap<>();\\n        original = new HashMap<>();\\n    }\\n\\n    public void insert(String key, int val) {\\n        val -= original.getOrDefault(key, 0); // calculate the diff to be added to prefixes\\n        String s = \"\";\\n        for(char c : key.toCharArray()) {\\n            s += c; // creating all prefixes\\n            map.put(s, map.getOrDefault(s, 0) + val); //update/insert all prefixes with new value\\n        }\\n        original.put(key, original.getOrDefault(key, 0) + val);\\n    }\\n\\n    public int sum(String prefix) {\\n        return map.getOrDefault(prefix, 0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 246447,
                "title": "java-solution-faster-than-100-00-submissions-using-trie-and-hashmap",
                "content": "```\\nclass TrieNode{\\n    TrieNode[] children;\\n    int val;\\n    public TrieNode(){\\n        children = new TrieNode[26];\\n        val=0;\\n    }\\n}\\nclass MapSum {\\n    TrieNode root;\\n    HashMap<String,Integer> words;\\n    public MapSum() {\\n        root = new TrieNode();\\n        words = new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        TrieNode node = root;\\n        int add = 0;\\n        if(words.containsKey(key)){\\n            add = val-words.get(key);\\n        }\\n        else{\\n            add = val;\\n        }\\n        words.put(key,val);\\n        for(char c : key.toCharArray()){\\n            if(node.children[c-\\'a\\'] == null){\\n                node.children[c-\\'a\\'] = new TrieNode();\\n            }\\n            node = node.children[c-\\'a\\'];\\n            node.val+=add;\\n        }\\n    }\\n    \\n    public int sum(String prefix) {\\n        TrieNode node = root;\\n        for(char c : prefix.toCharArray()){\\n            if(node.children[c-\\'a\\'] == null) return 0;\\n            node = node.children[c-\\'a\\'];\\n        }\\n        return node.val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode{\\n    TrieNode[] children;\\n    int val;\\n    public TrieNode(){\\n        children = new TrieNode[26];\\n        val=0;\\n    }\\n}\\nclass MapSum {\\n    TrieNode root;\\n    HashMap<String,Integer> words;\\n    public MapSum() {\\n        root = new TrieNode();\\n        words = new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        TrieNode node = root;\\n        int add = 0;\\n        if(words.containsKey(key)){\\n            add = val-words.get(key);\\n        }\\n        else{\\n            add = val;\\n        }\\n        words.put(key,val);\\n        for(char c : key.toCharArray()){\\n            if(node.children[c-\\'a\\'] == null){\\n                node.children[c-\\'a\\'] = new TrieNode();\\n            }\\n            node = node.children[c-\\'a\\'];\\n            node.val+=add;\\n        }\\n    }\\n    \\n    public int sum(String prefix) {\\n        TrieNode node = root;\\n        for(char c : prefix.toCharArray()){\\n            if(node.children[c-\\'a\\'] == null) return 0;\\n            node = node.children[c-\\'a\\'];\\n        }\\n        return node.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169050,
                "title": "c-trie-dfs-0ms-100",
                "content": "```\\nclass TrieNode {\\n    public:\\n    int last;\\n    TrieNode *children[26];\\n    TrieNode()\\n    {\\n        last = 0;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            children[i] = nullptr;\\n        }\\n    }\\n};\\nclass MapSum {\\npublic:\\n    TrieNode *root;\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        root = new TrieNode();\\n    }\\n    \\n    void insert(string key, int val) {\\n        TrieNode *curr = root;\\n        for(int i = 0; i < key.size(); i++)\\n        {\\n            int index = key[i] - \\'a\\';\\n            if(!curr->children[index])\\n                curr->children[index] = new TrieNode;\\n            curr = curr->children[index];\\n        }\\n        curr->last = val;\\n    }\\n    void dfs(TrieNode *curr, int &sum)\\n    {\\n        if(curr->last != 0)\\n            sum+= curr->last;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            if(curr->children[i])\\n                dfs(curr->children[i], sum);\\n        }\\n    }\\n    int sum(string prefix) {\\n        TrieNode *curr = root;\\n        int res = 0;\\n        for(int i = 0; i < prefix.size(); i++)\\n        {\\n            int index = prefix[i]-\\'a\\';\\n            if(!curr->children[index])\\n                return res;\\n            curr = curr->children[index];\\n        }\\n        dfs(curr, res);\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\n    public:\\n    int last;\\n    TrieNode *children[26];\\n    TrieNode()\\n    {\\n        last = 0;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            children[i] = nullptr;\\n        }\\n    }\\n};\\nclass MapSum {\\npublic:\\n    TrieNode *root;\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        root = new TrieNode();\\n    }\\n    \\n    void insert(string key, int val) {\\n        TrieNode *curr = root;\\n        for(int i = 0; i < key.size(); i++)\\n        {\\n            int index = key[i] - \\'a\\';\\n            if(!curr->children[index])\\n                curr->children[index] = new TrieNode;\\n            curr = curr->children[index];\\n        }\\n        curr->last = val;\\n    }\\n    void dfs(TrieNode *curr, int &sum)\\n    {\\n        if(curr->last != 0)\\n            sum+= curr->last;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            if(curr->children[i])\\n                dfs(curr->children[i], sum);\\n        }\\n    }\\n    int sum(string prefix) {\\n        TrieNode *curr = root;\\n        int res = 0;\\n        for(int i = 0; i < prefix.size(); i++)\\n        {\\n            int index = prefix[i]-\\'a\\';\\n            if(!curr->children[index])\\n                return res;\\n            curr = curr->children[index];\\n        }\\n        dfs(curr, res);\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372374,
                "title": "c-simple-and-clean-intuitive-solution-4-lines-of-code-0ms-faster-than-100",
                "content": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {}\\n    \\n    void insert(string key, int val) {\\n        m[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int s = 0;\\n        for (auto [key, value] : m) if (key.find(prefix) == 0) s += value;\\n        return s;\\n    }\\n    \\nprivate:\\n    unordered_map<string, int> m;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {}\\n    \\n    void insert(string key, int val) {\\n        m[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int s = 0;\\n        for (auto [key, value] : m) if (key.find(prefix) == 0) s += value;\\n        return s;\\n    }\\n    \\nprivate:\\n    unordered_map<string, int> m;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075520,
                "title": "python-trie-solution-easy-to-understand",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.prefixCount = 0\\n        \\n        \\nclass MapSum:  \\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.dic = {}\\n\\n    def insert(self, key: str, val: int) -> None: \\n        delta = val\\n        if key in self.dic:     # key already existed, the original key-value pair will be overridden to the new one. And val - self.dic[key] does this thing\\n            delta = val - self.dic[key]\\n        self.dic[key] = val\\n        cur = self.root\\n        for c in key:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.prefixCount += delta\\n\\n    def sum(self, prefix: str) -> int:\\n        cur = self.root\\n        for c in prefix:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        return cur.prefixCount\\n\\n\\'\\'\\'\\nTime complexity: O(m) to insert key of length m as well it is O(m) to evaluate sum for prefix of length m. \\nSpace complexity: O(T) where T it total length of all words.\\n\\'\\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.prefixCount = 0\\n        \\n        \\nclass MapSum:  \\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.dic = {}\\n\\n    def insert(self, key: str, val: int) -> None: \\n        delta = val\\n        if key in self.dic:     # key already existed, the original key-value pair will be overridden to the new one. And val - self.dic[key] does this thing\\n            delta = val - self.dic[key]\\n        self.dic[key] = val\\n        cur = self.root\\n        for c in key:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.prefixCount += delta\\n\\n    def sum(self, prefix: str) -> int:\\n        cur = self.root\\n        for c in prefix:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        return cur.prefixCount\\n\\n\\'\\'\\'\\nTime complexity: O(m) to insert key of length m as well it is O(m) to evaluate sum for prefix of length m. \\nSpace complexity: O(T) where T it total length of all words.\\n\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371774,
                "title": "map-sum-pairs-c-runtime-beats-100-map-and-lower-bound",
                "content": "1. In the `insert` function: I am using **ordered map** to store the strings in sorted order always.\\n2. In the `sum` function: Using `lower_bound`, we can quickly reach a point where the prefix matches\\n3. From that point I traverse in linear fashion until the prefix matches and keep adding to `sum`\\n4. Always make sure we have not reached  `mp.end()`\\n\\n```\\nclass MapSum {\\nprivate:\\n    map<string, int> mp;\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        mp[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int sum = 0;\\n        for (auto itr = mp.lower_bound(prefix); itr != mp.end() && itr->first.compare(0, prefix.size(), prefix) == 0; ++itr)\\n        {\\n            sum += itr->second;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n**Hit upvote if you like this solution :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MapSum {\\nprivate:\\n    map<string, int> mp;\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        mp[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int sum = 0;\\n        for (auto itr = mp.lower_bound(prefix); itr != mp.end() && itr->first.compare(0, prefix.size(), prefix) == 0; ++itr)\\n        {\\n            sum += itr->second;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766687,
                "title": "python-modifying-the-standard-trie-concept",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.value = 0\\n        \\nclass MapSum:\\n    def __init__(self):\\n        self.t = TrieNode()\\n        self.m = {}\\n\\n    def insert(self, key: str, val: int) -> None:\\n        delta = val - self.m.get(key,0)\\n        self.m[key] = val\\n        node = self.t\\n        for char in key:\\n            node = node.children[char]\\n            node.value += delta\\n        \\n    def sum(self, prefix: str) -> int:\\n        node = self.t\\n        for char in prefix:\\n            node = node.children.get(char)\\n            if not node:\\n                return 0\\n        return node.value\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.value = 0\\n        \\nclass MapSum:\\n    def __init__(self):\\n        self.t = TrieNode()\\n        self.m = {}\\n\\n    def insert(self, key: str, val: int) -> None:\\n        delta = val - self.m.get(key,0)\\n        self.m[key] = val\\n        node = self.t\\n        for char in key:\\n            node = node.children[char]\\n            node.value += delta\\n        \\n    def sum(self, prefix: str) -> int:\\n        node = self.t\\n        for char in prefix:\\n            node = node.children.get(char)\\n            if not node:\\n                return 0\\n        return node.value\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 645182,
                "title": "my-c-solution-using-trie",
                "content": "```\\nclass TrieNode {\\npublic:\\n    int score = 0;\\n    TrieNode* child[26];\\n};\\nclass MapSum {\\npublic:\\n    int res = 0;\\n    /** Initialize your data structure here. */\\n    TrieNode* root;\\n    MapSum() {\\n        root = new TrieNode();\\n    }\\n    \\n    void insert(string key, int val) {\\n        TrieNode* curr = root;\\n        for(char c : key) {\\n            if(!curr->child[c-\\'a\\']) {\\n                curr->child[c-\\'a\\'] = new TrieNode();\\n            }\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n        curr->score = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        res = 0;\\n        TrieNode* curr = root;\\n        for(char c : prefix) {\\n            if(!curr->child[c-\\'a\\']) \\n                return 0;\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n        helper(curr);\\n        return res;\\n    }\\n    void helper(TrieNode* curr) {\\n        res += curr->score;\\n        for (int i = 0; i < 26; i++) {\\n            if (curr->child[i]) {\\n                helper(curr->child[i]);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\npublic:\\n    int score = 0;\\n    TrieNode* child[26];\\n};\\nclass MapSum {\\npublic:\\n    int res = 0;\\n    /** Initialize your data structure here. */\\n    TrieNode* root;\\n    MapSum() {\\n        root = new TrieNode();\\n    }\\n    \\n    void insert(string key, int val) {\\n        TrieNode* curr = root;\\n        for(char c : key) {\\n            if(!curr->child[c-\\'a\\']) {\\n                curr->child[c-\\'a\\'] = new TrieNode();\\n            }\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n        curr->score = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        res = 0;\\n        TrieNode* curr = root;\\n        for(char c : prefix) {\\n            if(!curr->child[c-\\'a\\']) \\n                return 0;\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n        helper(curr);\\n        return res;\\n    }\\n    void helper(TrieNode* curr) {\\n        res += curr->score;\\n        for (int i = 0; i < 26; i++) {\\n            if (curr->child[i]) {\\n                helper(curr->child[i]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107553,
                "title": "java-map-solution",
                "content": "```\\nclass MapSum {\\n    Map<String,Integer> map = new HashMap<>();\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        \\n    }\\n    \\n    public void insert(String key, int val) {\\n           map.put(key,val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        int sum = 0;\\n        for(String str:map.keySet()){\\n            if(str.startsWith(prefix)){\\n                sum+=map.get(str);\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n    Map<String,Integer> map = new HashMap<>();\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        \\n    }\\n    \\n    public void insert(String key, int val) {\\n           map.put(key,val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        int sum = 0;\\n        for(String str:map.keySet()){\\n            if(str.startsWith(prefix)){\\n                sum+=map.get(str);\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371803,
                "title": "c-self-explanatory-map-solution-no-trie",
                "content": "```\\n unordered_map<string, int> umap;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        umap[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int total=0;\\n        string s, sub;\\n        for(auto it= umap.begin(); it!=umap.end(); it++)\\n        {\\n            s = it->first;\\n            if(s.size() < prefix.size())\\n                continue;\\n            sub = s.substr(0, prefix.size());\\n            if(sub == prefix)\\n                total = total + it->second;            \\n        }\\n        return total;\\n    }\\n```\\nPlease UPVOTE if my approach helped you.",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n unordered_map<string, int> umap;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        umap[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int total=0;\\n        string s, sub;\\n        for(auto it= umap.begin(); it!=umap.end(); it++)\\n        {\\n            s = it->first;\\n            if(s.size() < prefix.size())\\n                continue;\\n            sub = s.substr(0, prefix.size());\\n            if(sub == prefix)\\n                total = total + it->second;            \\n        }\\n        return total;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 320237,
                "title": "simple-python-solution-trie-dfs",
                "content": "Please see and vote for my solutions for\\n[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/320224/Simple-Python-solution)\\n[1233. Remove Sub-Folders from the Filesystem](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/discuss/409075/standard-python-prefix-tree-solution)\\n[1032. Stream of Characters](https://leetcode.com/problems/stream-of-characters/discuss/320837/Standard-Python-Trie-Solution)\\n[211. Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/319361/Simple-Python-solution)\\n[676. Implement Magic Dictionary](https://leetcode.com/problems/implement-magic-dictionary/discuss/320197/Simple-Python-solution)\\n[677. Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/discuss/320237/Simple-Python-solution)\\n[745. Prefix and Suffix Search](https://leetcode.com/problems/prefix-and-suffix-search/discuss/320712/Different-Python-solutions-with-thinking-process)\\n[425. Word Squares](https://leetcode.com/problems/word-squares/discuss/320916/Easily-implemented-Python-solution%3A-Backtrack-%2B-Trie)\\n[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/322444/Python-solutions%3A-top-down-DP-Trie)\\n[212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/319071/Standard-Python-solution-with-Trie-%2B-Backtrack)\\n[336. Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/discuss/316960/Different-Python-solutions%3A-brute-force-dictionary-Trie)\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.value = None\\n\\nclass MapSum:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, key: str, val: int) -> None:\\n        node = self.root\\n        for char in key:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.value = val\\n\\n    def sum(self, prefix: str) -> int:\\n        def dfs(node, s):\\n            if node.value:\\n                s[0] += node.value\\n            for char in node.children:\\n                dfs(node.children[char], s)\\n                \\n        s = [0]\\n        node = self.root\\n        for char in prefix:\\n            if char not in node.children:\\n                return 0\\n            node = node.children[char]\\n        dfs(node, s)\\n        return s[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.value = None\\n\\nclass MapSum:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, key: str, val: int) -> None:\\n        node = self.root\\n        for char in key:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.value = val\\n\\n    def sum(self, prefix: str) -> int:\\n        def dfs(node, s):\\n            if node.value:\\n                s[0] += node.value\\n            for char in node.children:\\n                dfs(node.children[char], s)\\n                \\n        s = [0]\\n        node = self.root\\n        for char in prefix:\\n            if char not in node.children:\\n                return 0\\n            node = node.children[char]\\n        dfs(node, s)\\n        return s[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750192,
                "title": "simple-soultion-easy-to-understand-c-beats-100",
                "content": "Easy to understand solution\\n\\nI used unordered map to store the mapped value with the string.\\n\\n\\n\\tclass MapSum\\n\\t{\\n    unordered_map<string,int>mp;\\n\\tpublic:\\n    MapSum() {}\\n    \\n    void insert(string key, int val) {\\n        mp[key]=val;\\n    }\\n    \\n    int sum(string prefix) {\\n \\n        int ans=0;\\n        for(auto x:mp){\\n            size_t found = x.first.find(prefix);\\n           if (found != string::npos && found==0) //if found is 0 then add the value in the sum \\n\\t\\t   {\\n               ans+=x.second;\\n           }\\n        }\\n   \\n        return ans;\\n    }\\n\\t};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "Easy to understand solution\\n\\nI used unordered map to store the mapped value with the string.\\n\\n\\n\\tclass MapSum\\n\\t{\\n    unordered_map<string,int>mp;\\n\\tpublic:\\n    MapSum() {}\\n    \\n    void insert(string key, int val) {\\n        mp[key]=val;\\n    }\\n    \\n    int sum(string prefix) {\\n \\n        int ans=0;\\n        for(auto x:mp){\\n            size_t found = x.first.find(prefix);\\n           if (found != string::npos && found==0) //if found is 0 then add the value in the sum \\n\\t\\t   {\\n               ans+=x.second;\\n           }\\n        }\\n   \\n        return ans;\\n    }\\n\\t};\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1372373,
                "title": "map-sum-pairs-simple-trie-approach",
                "content": "Approach\\n1. Create a trie on initialization\\n2. While inserting string, mark isLeaf and store the corresponding value.\\n3. once the prefix end , do a DFS and add all the values.\\n```\\nclass MapSum {\\n    TrieNode root = null;\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        root = new TrieNode(false);\\n    }\\n    \\n    public void insert(String key, int val) {\\n        TrieNode node = root;\\n        \\n        for(int i=0;i<key.length();i++) {\\n            char s = key.charAt(i);\\n            if(node.children[s-\\'a\\'] == null)\\n                node.children[s-\\'a\\'] = new TrieNode(false);\\n            node = node.children[s-\\'a\\'];\\n        }\\n        node.isLeaf = true;\\n        node.value = val;\\n    }\\n    \\n    public int sum(String prefix) {\\n        TrieNode node = root;\\n        \\n        for(int i=0;i<prefix.length();i++) {\\n            char s = prefix.charAt(i);\\n            if(node != null) {\\n                node = node.children[s-\\'a\\'];\\n            } else {\\n                return 0;\\n            }\\n        }\\n        int sum = 0;\\n        \\n        return DFS(node);\\n        \\n    }\\n    \\n    public int DFS(TrieNode root) {\\n        if(root == null)\\n            return 0;\\n        int sum = 0;\\n        if(root.isLeaf) {\\n            sum+=root.value;\\n        } \\n        for(int i=0;i<26;i++) {\\n            if(root.children[i] != null) {\\n                sum+=DFS(root.children[i]);\\n            } \\n        }\\n        return sum;\\n    }\\n    \\n    class TrieNode {\\n        TrieNode[] children = new TrieNode[26];\\n        boolean isLeaf;\\n        int value;\\n        \\n        public TrieNode(boolean isLeaf) {\\n            this.isLeaf = isLeaf;\\n        }\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n    TrieNode root = null;\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        root = new TrieNode(false);\\n    }\\n    \\n    public void insert(String key, int val) {\\n        TrieNode node = root;\\n        \\n        for(int i=0;i<key.length();i++) {\\n            char s = key.charAt(i);\\n            if(node.children[s-\\'a\\'] == null)\\n                node.children[s-\\'a\\'] = new TrieNode(false);\\n            node = node.children[s-\\'a\\'];\\n        }\\n        node.isLeaf = true;\\n        node.value = val;\\n    }\\n    \\n    public int sum(String prefix) {\\n        TrieNode node = root;\\n        \\n        for(int i=0;i<prefix.length();i++) {\\n            char s = prefix.charAt(i);\\n            if(node != null) {\\n                node = node.children[s-\\'a\\'];\\n            } else {\\n                return 0;\\n            }\\n        }\\n        int sum = 0;\\n        \\n        return DFS(node);\\n        \\n    }\\n    \\n    public int DFS(TrieNode root) {\\n        if(root == null)\\n            return 0;\\n        int sum = 0;\\n        if(root.isLeaf) {\\n            sum+=root.value;\\n        } \\n        for(int i=0;i<26;i++) {\\n            if(root.children[i] != null) {\\n                sum+=DFS(root.children[i]);\\n            } \\n        }\\n        return sum;\\n    }\\n    \\n    class TrieNode {\\n        TrieNode[] children = new TrieNode[26];\\n        boolean isLeaf;\\n        int value;\\n        \\n        public TrieNode(boolean isLeaf) {\\n            this.isLeaf = isLeaf;\\n        }\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077334,
                "title": "java-3-solutions-using-hashmap-trie",
                "content": "#### Solution 1: Using HashMap (Optimized `insert()`)\\n\\nIn a HashMap we can store all strings and the corresponding value during `insert()` and for `sum()` we can iterate through each `String` in the Map to check if the prefix matches the current iterated key in the map and if it matches then add it to the final sum. The `insert()` is faster but the `sum()` takes more time as it needs to iterate through all the Strings inserted in the Map.\\n\\n##### Time Complexity \\n- O(1) Insert \\n- O(N) sum (N = no. of keys in HashMap)\\n\\n```\\nclass MapSum {\\n\\n    Map<String, Integer> map;\\n\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        map.put(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        int result = 0;\\n        for(String key : map.keySet()){\\n            if(key.startsWith(prefix))\\n                result += map.get(key);\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n\\n#### Solution 2: Using 2 HashMaps (Optimized `sum()`)\\n\\nWe\\'ll use 2 HashMaps heres - one HashMap to maintain the values of each String and their corresponding value, and the other one to maintain the sum of all the possible prefixes for the inserted String. The insert in this case takes more time as it needs to compute the prefixes and the corresponding sums. Hence, when a lookup is done we can use the corresponding sum from the prefix Map.\\n\\n##### Time Complexity \\n- O(K) Insert (K = length of key)\\n- O(1) sum \\n\\n```\\nclass MapSum {\\n\\n    Map<String, Integer> mapVal;\\n    Map<String, Integer> prefixSum;\\n    \\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        mapVal = new HashMap<>();\\n        prefixSum = new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        int diff = val - mapVal.getOrDefault(key, 0);\\n        mapVal.put(key, val);\\n        StringBuilder sb = new StringBuilder();\\n        for(char c: key.toCharArray()){\\n            sb.append(c);\\n            String prefix = sb.toString();\\n            prefixSum.put(prefix, prefixSum.getOrDefault(prefix, 0) + diff);\\n        }\\n    }\\n    \\n    public int sum(String prefix) {\\n        return prefixSum.getOrDefault(prefix, 0);\\n    }\\n}\\n```\\n\\n#### Solution 3: Using HashMap & Trie\\n\\nExtending the concept from Solution 2, instead of maintaining the prefix sum in a HashMap, we can do that in a TrieNode. We continue maintaining the value of each String in a HashMap of String and Integer.\\n\\n##### Time Complexity \\n- O(K) Insert (K = length of key)\\n- O(K) sum (K = length of prefix)\\n\\n```\\nclass MapSum {\\n\\n    TrieNode root;\\n    class TrieNode {\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        int sum = 0;\\n        TrieNode(int val){\\n            this.sum = val;\\n        }\\n    }\\n    Map<String, Integer> mapVal;\\n    \\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        root = new TrieNode(0);\\n        mapVal = new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        int diff = val - mapVal.getOrDefault(key, 0);\\n        mapVal.put(key, val);        \\n        TrieNode curr = root;\\n        for(char c: key.toCharArray()){            \\n            if(curr.children.containsKey(c)) \\n\\t\\t\\t\\tcurr.children.get(c).sum += diff;\\n            else curr.children.put(c, new TrieNode(diff));            \\n            curr = curr.children.get(c);\\n        }\\n    }\\n    \\n    public int sum(String prefix) {\\n        TrieNode curr = root;    \\n        for (char c : prefix.toCharArray()){\\n            curr = curr.children.get(c);\\n            if(curr == null) return 0;  \\n        }\\n        return curr.sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass MapSum {\\n\\n    Map<String, Integer> map;\\n\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        map.put(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        int result = 0;\\n        for(String key : map.keySet()){\\n            if(key.startsWith(prefix))\\n                result += map.get(key);\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass MapSum {\\n\\n    Map<String, Integer> mapVal;\\n    Map<String, Integer> prefixSum;\\n    \\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        mapVal = new HashMap<>();\\n        prefixSum = new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        int diff = val - mapVal.getOrDefault(key, 0);\\n        mapVal.put(key, val);\\n        StringBuilder sb = new StringBuilder();\\n        for(char c: key.toCharArray()){\\n            sb.append(c);\\n            String prefix = sb.toString();\\n            prefixSum.put(prefix, prefixSum.getOrDefault(prefix, 0) + diff);\\n        }\\n    }\\n    \\n    public int sum(String prefix) {\\n        return prefixSum.getOrDefault(prefix, 0);\\n    }\\n}\\n```\n```\\nclass MapSum {\\n\\n    TrieNode root;\\n    class TrieNode {\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        int sum = 0;\\n        TrieNode(int val){\\n            this.sum = val;\\n        }\\n    }\\n    Map<String, Integer> mapVal;\\n    \\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        root = new TrieNode(0);\\n        mapVal = new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        int diff = val - mapVal.getOrDefault(key, 0);\\n        mapVal.put(key, val);        \\n        TrieNode curr = root;\\n        for(char c: key.toCharArray()){            \\n            if(curr.children.containsKey(c)) \\n\\t\\t\\t\\tcurr.children.get(c).sum += diff;\\n            else curr.children.put(c, new TrieNode(diff));            \\n            curr = curr.children.get(c);\\n        }\\n    }\\n    \\n    public int sum(String prefix) {\\n        TrieNode curr = root;    \\n        for (char c : prefix.toCharArray()){\\n            curr = curr.children.get(c);\\n            if(curr == null) return 0;  \\n        }\\n        return curr.sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412778,
                "title": "java-solution-using-treemap-s-inbuilt-functions",
                "content": "\\n\\n```\\nclass MapSum {\\nTreeMap<String, Integer> map;\\n\\n\\tpublic MapSum() {\\n\\t\\tmap = new TreeMap<String, Integer>();\\n\\t}\\n\\n\\tpublic void insert(String key, int val) {\\n\\t\\tmap.put(key, val);\\n\\t}\\n\\n\\tpublic int sum(String prefix) {\\n\\t\\tif (prefix == null || prefix.length() == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint sum = 0;\\n\\t\\tString key = map.ceilingKey(prefix);\\n        while(key != null && key.startsWith(prefix)) {\\n        \\tsum += map.get(key);\\n            key = map.higherKey(key);\\n        }\\n\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\nTreeMap<String, Integer> map;\\n\\n\\tpublic MapSum() {\\n\\t\\tmap = new TreeMap<String, Integer>();\\n\\t}\\n\\n\\tpublic void insert(String key, int val) {\\n\\t\\tmap.put(key, val);\\n\\t}\\n\\n\\tpublic int sum(String prefix) {\\n\\t\\tif (prefix == null || prefix.length() == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint sum = 0;\\n\\t\\tString key = map.ceilingKey(prefix);\\n        while(key != null && key.startsWith(prefix)) {\\n        \\tsum += map.get(key);\\n            key = map.higherKey(key);\\n        }\\n\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130931,
                "title": "c-beats-100-using-stl-map",
                "content": "```\\nclass MapSum {\\npublic:\\n    map<string, int> count;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        count[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int answer = 0;\\n        for(map<string, int>::iterator i = count.begin(); i != count.end(); i++)\\n        {\\n            if(i->first.find(prefix) == 0)\\n                answer += i->second;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\npublic:\\n    map<string, int> count;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        count[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int answer = 0;\\n        for(map<string, int>::iterator i = count.begin(); i != count.end(); i++)\\n        {\\n            if(i->first.find(prefix) == 0)\\n                answer += i->second;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373615,
                "title": "c-0ms-2-approaches-go-from-naive-to-best-approach",
                "content": "```\\n//Approach-1 (Just do what\\'s mentioned in the Qn) Time : n*m\\n//where, n = number of queries, m = maximum length of a query string\\nclass MapSum {\\npublic:\\n    unordered_map<string, int> mp;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        mp[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int sum = 0;\\n        for(auto &it : mp) {\\n            if(it.first.find(prefix) == 0)\\n                sum += it.second;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Questions like these are always meant to be solved by \"Tried\" DS\\n/*\\nTime : Insertion in trie : O(n)\\n\\t\\t  Sum                   : O(total length of all insertions) I traverse whole trie\\n*/\\nclass MapSum {\\npublic:\\n\\t/*****************************************START : Trie related functions*********************************************/\\n    struct trieNode{\\n        char ch;\\n        int val = 0;\\n        trieNode* children[26];\\n    };\\n    \\n    trieNode* getTrieNode(char ch) {\\n        trieNode* temp = new trieNode;\\n        temp->ch = ch;\\n        for(int i = 0; i<26; i++) temp->children[i] = NULL;\\n        return temp;\\n    }\\n    \\n    void insertNode(string key, int val) {\\n        trieNode* pCrawl = root;\\n        \\n        for(char &ch : key) {\\n            if(pCrawl->children[ch-\\'a\\'] == NULL)\\n                pCrawl->children[ch-\\'a\\'] = getTrieNode(ch);\\n            \\n            pCrawl = pCrawl->children[ch-\\'a\\'];\\n        }\\n        \\n        pCrawl->val = val;\\n    }\\n    \\n    int findSum(trieNode* pCrawl) {\\n        if(!pCrawl)\\n            return 0;\\n        \\n        int sum = pCrawl->val;\\n        for(int i = 0; i<26; i++) {\\n            sum += findSum(pCrawl->children[i]);\\n        }\\n        return sum;\\n    }\\n    /*****************************************END : Trie related functions******************************************/\\n\\t\\n    trieNode* root = NULL;\\n    MapSum() {\\n        root = getTrieNode(\\'.\\');\\n    }\\n    \\n    void insert(string key, int val) {\\n        insertNode(key, val);\\n    }\\n    \\n    int sum(string prefix) {\\n        trieNode* pCrawl = root;\\n        for(char &ch : prefix) {\\n            if(pCrawl->children[ch-\\'a\\'] == NULL)\\n                return 0;\\n            pCrawl = pCrawl->children[ch-\\'a\\'];\\n        }\\n        \\n        return pCrawl == NULL ? 0 : findSum(pCrawl);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Just do what\\'s mentioned in the Qn) Time : n*m\\n//where, n = number of queries, m = maximum length of a query string\\nclass MapSum {\\npublic:\\n    unordered_map<string, int> mp;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        mp[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int sum = 0;\\n        for(auto &it : mp) {\\n            if(it.first.find(prefix) == 0)\\n                sum += it.second;\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\n//Approach-2 (Questions like these are always meant to be solved by \"Tried\" DS\\n/*\\nTime : Insertion in trie : O(n)\\n\\t\\t  Sum                   : O(total length of all insertions) I traverse whole trie\\n*/\\nclass MapSum {\\npublic:\\n\\t/*****************************************START : Trie related functions*********************************************/\\n    struct trieNode{\\n        char ch;\\n        int val = 0;\\n        trieNode* children[26];\\n    };\\n    \\n    trieNode* getTrieNode(char ch) {\\n        trieNode* temp = new trieNode;\\n        temp->ch = ch;\\n        for(int i = 0; i<26; i++) temp->children[i] = NULL;\\n        return temp;\\n    }\\n    \\n    void insertNode(string key, int val) {\\n        trieNode* pCrawl = root;\\n        \\n        for(char &ch : key) {\\n            if(pCrawl->children[ch-\\'a\\'] == NULL)\\n                pCrawl->children[ch-\\'a\\'] = getTrieNode(ch);\\n            \\n            pCrawl = pCrawl->children[ch-\\'a\\'];\\n        }\\n        \\n        pCrawl->val = val;\\n    }\\n    \\n    int findSum(trieNode* pCrawl) {\\n        if(!pCrawl)\\n            return 0;\\n        \\n        int sum = pCrawl->val;\\n        for(int i = 0; i<26; i++) {\\n            sum += findSum(pCrawl->children[i]);\\n        }\\n        return sum;\\n    }\\n    /*****************************************END : Trie related functions******************************************/\\n\\t\\n    trieNode* root = NULL;\\n    MapSum() {\\n        root = getTrieNode(\\'.\\');\\n    }\\n    \\n    void insert(string key, int val) {\\n        insertNode(key, val);\\n    }\\n    \\n    int sum(string prefix) {\\n        trieNode* pCrawl = root;\\n        for(char &ch : prefix) {\\n            if(pCrawl->children[ch-\\'a\\'] == NULL)\\n                return 0;\\n            pCrawl = pCrawl->children[ch-\\'a\\'];\\n        }\\n        \\n        return pCrawl == NULL ? 0 : findSum(pCrawl);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373051,
                "title": "java-using-only-hashmap-solution-easy-and-fast",
                "content": "```\\nclass MapSum {\\nHashMap <String,Integer>  MapSum;\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        MapSum= new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        if(!MapSum.containsKey(key)){\\n            MapSum.put(key,val);\\n        }\\n        else{\\n            MapSum.put(key,val);\\n        }\\n    }\\n    \\n    public int sum(String prefix) {\\n        int count=0;\\n        for(Map.Entry<String,Integer> entry: MapSum.entrySet()){\\n            if(entry.getKey().startsWith(prefix)){\\n                count+=entry.getValue();\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\nHashMap <String,Integer>  MapSum;\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        MapSum= new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        if(!MapSum.containsKey(key)){\\n            MapSum.put(key,val);\\n        }\\n        else{\\n            MapSum.put(key,val);\\n        }\\n    }\\n    \\n    public int sum(String prefix) {\\n        int count=0;\\n        for(Map.Entry<String,Integer> entry: MapSum.entrySet()){\\n            if(entry.getKey().startsWith(prefix)){\\n                count+=entry.getValue();\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372021,
                "title": "c-trie-solution-no-hashmap",
                "content": "```\\nstruct Trie {\\n    int val, sum;\\n    bool is_end;\\n    Trie *child[26];\\n    Trie(int x) : val(x), is_end(0) {};\\n    Trie() : val(0), sum(0), is_end(0) {}\\n};\\n\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    Trie *trie;\\n    MapSum() {\\n        trie = new Trie();\\n        set_null(trie);\\n    }\\n    \\n    void insert(string key, int val) {\\n        int sub = find_key(key);\\n        insert_in_trie(key, val, sub);\\n    }\\n    \\n    int sum(string prefix) {\\n        Trie* t = trie;\\n        for (auto c: prefix)    {\\n            if (t->child[c-\\'a\\'])\\n                t = t->child[c-\\'a\\'];\\n            else\\n                return 0;\\n        }\\n        return t->sum;\\n    }\\n    \\n    private:\\n    void set_null(Trie* t) {\\n        for (int i=0; i<26; ++i)\\n            t->child[i] = nullptr;\\n    }\\n    \\n    int find_key(string &key)  {\\n        Trie* t = trie;\\n        for (auto c: key)   {\\n            if (t->child[c-\\'a\\'])\\n                t = t->child[c-\\'a\\'];\\n            else\\n                return 0;\\n        }\\n        return (t->is_end) ? t->val : 0;\\n    }\\n    \\n    void insert_in_trie(string &key, int &val, int &sub)  {\\n        Trie* t = trie;\\n        for (auto c: key)   {\\n            if (t->child[c-\\'a\\'])    {\\n                t = t->child[c-\\'a\\'];\\n            }\\n            else    {\\n                t->child[c-\\'a\\'] = new Trie();\\n                t = t->child[c-\\'a\\'];\\n                set_null(t);\\n            }\\n            t->sum += val-sub;\\n        }\\n        t->val = val;\\n        t->is_end = 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Trie {\\n    int val, sum;\\n    bool is_end;\\n    Trie *child[26];\\n    Trie(int x) : val(x), is_end(0) {};\\n    Trie() : val(0), sum(0), is_end(0) {}\\n};\\n\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    Trie *trie;\\n    MapSum() {\\n        trie = new Trie();\\n        set_null(trie);\\n    }\\n    \\n    void insert(string key, int val) {\\n        int sub = find_key(key);\\n        insert_in_trie(key, val, sub);\\n    }\\n    \\n    int sum(string prefix) {\\n        Trie* t = trie;\\n        for (auto c: prefix)    {\\n            if (t->child[c-\\'a\\'])\\n                t = t->child[c-\\'a\\'];\\n            else\\n                return 0;\\n        }\\n        return t->sum;\\n    }\\n    \\n    private:\\n    void set_null(Trie* t) {\\n        for (int i=0; i<26; ++i)\\n            t->child[i] = nullptr;\\n    }\\n    \\n    int find_key(string &key)  {\\n        Trie* t = trie;\\n        for (auto c: key)   {\\n            if (t->child[c-\\'a\\'])\\n                t = t->child[c-\\'a\\'];\\n            else\\n                return 0;\\n        }\\n        return (t->is_end) ? t->val : 0;\\n    }\\n    \\n    void insert_in_trie(string &key, int &val, int &sub)  {\\n        Trie* t = trie;\\n        for (auto c: key)   {\\n            if (t->child[c-\\'a\\'])    {\\n                t = t->child[c-\\'a\\'];\\n            }\\n            else    {\\n                t->child[c-\\'a\\'] = new Trie();\\n                t = t->child[c-\\'a\\'];\\n                set_null(t);\\n            }\\n            t->sum += val-sub;\\n        }\\n        t->val = val;\\n        t->is_end = 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371893,
                "title": "c-map-sum-pair-hashmap-simple",
                "content": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<string,int>mp;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        mp[key]=val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int sum=0;\\n        for(auto x:mp){\\n            if(x.first.find(prefix)==0){\\n                sum+=x.second;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<string,int>mp;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        mp[key]=val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int sum=0;\\n        for(auto x:mp){\\n            if(x.first.find(prefix)==0){\\n                sum+=x.second;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 432439,
                "title": "javascript-feels-like-cheating-here-96-better-time-100-better-space",
                "content": "```\\nvar MapSum = function() {\\n    this.map = {};\\n};\\n\\nMapSum.prototype.insert = function(key, val) {\\n    this.map[key] = val;\\n};\\n\\nMapSum.prototype.sum = function(prefix) {\\n    return Object.keys(this.map)\\n        .filter(key=>key.startsWith(prefix))\\n        .map(key=>this.map[key])\\n        .reduce((total, curr)=>total+curr, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar MapSum = function() {\\n    this.map = {};\\n};\\n\\nMapSum.prototype.insert = function(key, val) {\\n    this.map[key] = val;\\n};\\n\\nMapSum.prototype.sum = function(prefix) {\\n    return Object.keys(this.map)\\n        .filter(key=>key.startsWith(prefix))\\n        .map(key=>this.map[key])\\n        .reduce((total, curr)=>total+curr, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 128520,
                "title": "a-few-solutions",
                "content": "**Trie:**  Store all words in each trie node and return the accumulated total `t` of those words for the sum() operation.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass MapSum() {\\n    class TrieNode {\\n        var words = mutableMapOf<String, Int>()\\n        var children = mutableMapOf<Char, TrieNode?>()\\n    }\\n    private var root: TrieNode? = TrieNode()\\n    fun insert(word: String, value: Int) {\\n        var node = root\\n        node!!.words[word] = value\\n        for (c in word) {\\n            var next = node!!.children.getOrDefault(c, TrieNode())\\n            node!!.children[c] = next\\n            next!!.words[word] = value\\n            node = next\\n        }\\n    }\\n    fun sum(word: String): Int {\\n        var node = root\\n        for (c in word)\\n            if (node != null)\\n                node = node?.children[c]\\n        return if (node != null) node!!.words.map{ (_, t) -> t }.sum() else 0\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nclass TrieNode {\\n    constructor() {\\n        this.words = new Map();\\n        this.children = new Map();\\n    }\\n}\\nclass MapSum {\\n    constructor() {\\n        this.root = new TrieNode();\\n    }\\n    insert(word, value) {\\n        let node = this.root;\\n        node.words.set(word, value);\\n        for (let c of word) {\\n            let next = node.children.get(c) || new TrieNode();\\n            next.words.set(word, value);\\n            node.children.set(c, next);\\n            node = next;\\n        }\\n    }\\n    sum(word) {\\n        let node = this.root;\\n        for (let c of word)\\n            node = node?.children.get(c);\\n        return node ? _.sum([...node.words].map(([_, t]) => t)) : 0;\\n    }\\n}\\n```\\n\\n*Python3*\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.words = {}\\n        self.children = {}\\nclass MapSum:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    def insert(self, word: str, value: int) -> None:\\n        node = self.root\\n        node.words[word] = value\\n        for c in word:\\n            next = node.children[c] if c in node.children else TrieNode()\\n            next.words[word] = value\\n            node.children[c] = next\\n            node = next\\n    def sum(self, word: str) -> int:\\n        node = self.root\\n        for c in word:\\n            if node:\\n                node = node.children[c] if c in node.children else None\\n        return sum(node.words.values()) if node else 0\\n```\\n\\n*C++*\\n```\\nstruct TrieNode;\\nusing TrieNodePtr = shared_ptr<TrieNode>;\\nstruct TrieNode {\\n    unordered_map<string, int> words;\\n    unordered_map<char, TrieNodePtr> children;\\n};\\nclass MapSum {\\n    TrieNodePtr root;\\npublic:\\n    MapSum() : root{ make_shared<TrieNode>() } {}\\n    void insert(string word, int value) {\\n        auto node = root;\\n        node->words[word] = value;\\n        for (auto c: word) {\\n            auto next = node->children.find(c) != node->children.end() ? node->children[c] : make_shared<TrieNode>();\\n            next->words[word] = value;\\n            node->children[c] = next;\\n            node = next;\\n        }\\n    }\\n    int sum(string word) {\\n        auto node = root;\\n        for (auto c: word)\\n            if (node->children.find(c) != node->children.end())\\n                node = node->children[c];\\n            else\\n                return 0;\\n        auto t = 0;\\n        for (auto& [_, value]: node->words)\\n            t += value;\\n        return t;\\n    }\\n};\\n```\\n\\n---\\n\\n**Ordered Map:** Use an ordered map `m` to perform naive insertions.  Then calculate the total `t` on demand based upon the prefix string `s`.\\n\\n---\\n\\n```\\nclass MapSum {\\n    map<string, int> m;\\npublic:\\n    void insert(string key, int value) {\\n        m[key] = value;\\n    }\\n    int sum(string s) {\\n        auto t = 0;\\n        auto n = s.size();\\n        for (auto it = m.lower_bound(s); it != m.end() && it->first.substr(0, n) == s; ++it)\\n            t += it->second;\\n        return t;\\n    }\\n};\\n```\\n\\n---\\n\\n**September 19, 2017: Legacy C++ Solutions (previously AC)**\\n\\nUse a map to keep track of each prefix sum.  Overwrite the values if the key already exists, otherwise add onto the existing prefix sums.\\n\\n```\\nclass MapSum {\\npublic:\\n    void insert(string key, int val) {\\n        bool found=K.find(key)!=K.end();\\n        K.insert(key);\\n        for (int i=1; i<=(int)key.size(); ++i){\\n            if (found)\\n                M[key.substr(0,i)]=val;\\n            else\\n                M[key.substr(0,i)]+=val;\\n        }\\n    }\\n    int sum(string prefix) {\\n        return M[prefix];\\n    }\\nprivate:\\n    unordered_map<string,int> M;\\n    unordered_set<string> K;\\n};\\n```\\n\\nRemoving a few lines, we can make this solution more concise:\\n```\\nclass MapSum {\\npublic:\\n    void insert(string key, int val) {\\n        for (int i=1,N=(int)key.size(),found=!(K.insert(key).second); i<=N; ++i)\\n            M[key.substr(0,i)]=found ? val : val+M[key.substr(0,i)];\\n    }\\n    int sum(string prefix) { return M[prefix]; }\\nprivate:\\n    unordered_map<string,int> M;\\n    unordered_set<string> K;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum() {\\n    class TrieNode {\\n        var words = mutableMapOf<String, Int>()\\n        var children = mutableMapOf<Char, TrieNode?>()\\n    }\\n    private var root: TrieNode? = TrieNode()\\n    fun insert(word: String, value: Int) {\\n        var node = root\\n        node!!.words[word] = value\\n        for (c in word) {\\n            var next = node!!.children.getOrDefault(c, TrieNode())\\n            node!!.children[c] = next\\n            next!!.words[word] = value\\n            node = next\\n        }\\n    }\\n    fun sum(word: String): Int {\\n        var node = root\\n        for (c in word)\\n            if (node != null)\\n                node = node?.children[c]\\n        return if (node != null) node!!.words.map{ (_, t) -> t }.sum() else 0\\n    }\\n}\\n```\n```\\nclass TrieNode {\\n    constructor() {\\n        this.words = new Map();\\n        this.children = new Map();\\n    }\\n}\\nclass MapSum {\\n    constructor() {\\n        this.root = new TrieNode();\\n    }\\n    insert(word, value) {\\n        let node = this.root;\\n        node.words.set(word, value);\\n        for (let c of word) {\\n            let next = node.children.get(c) || new TrieNode();\\n            next.words.set(word, value);\\n            node.children.set(c, next);\\n            node = next;\\n        }\\n    }\\n    sum(word) {\\n        let node = this.root;\\n        for (let c of word)\\n            node = node?.children.get(c);\\n        return node ? _.sum([...node.words].map(([_, t]) => t)) : 0;\\n    }\\n}\\n```\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.words = {}\\n        self.children = {}\\nclass MapSum:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    def insert(self, word: str, value: int) -> None:\\n        node = self.root\\n        node.words[word] = value\\n        for c in word:\\n            next = node.children[c] if c in node.children else TrieNode()\\n            next.words[word] = value\\n            node.children[c] = next\\n            node = next\\n    def sum(self, word: str) -> int:\\n        node = self.root\\n        for c in word:\\n            if node:\\n                node = node.children[c] if c in node.children else None\\n        return sum(node.words.values()) if node else 0\\n```\n```\\nstruct TrieNode;\\nusing TrieNodePtr = shared_ptr<TrieNode>;\\nstruct TrieNode {\\n    unordered_map<string, int> words;\\n    unordered_map<char, TrieNodePtr> children;\\n};\\nclass MapSum {\\n    TrieNodePtr root;\\npublic:\\n    MapSum() : root{ make_shared<TrieNode>() } {}\\n    void insert(string word, int value) {\\n        auto node = root;\\n        node->words[word] = value;\\n        for (auto c: word) {\\n            auto next = node->children.find(c) != node->children.end() ? node->children[c] : make_shared<TrieNode>();\\n            next->words[word] = value;\\n            node->children[c] = next;\\n            node = next;\\n        }\\n    }\\n    int sum(string word) {\\n        auto node = root;\\n        for (auto c: word)\\n            if (node->children.find(c) != node->children.end())\\n                node = node->children[c];\\n            else\\n                return 0;\\n        auto t = 0;\\n        for (auto& [_, value]: node->words)\\n            t += value;\\n        return t;\\n    }\\n};\\n```\n```\\nclass MapSum {\\n    map<string, int> m;\\npublic:\\n    void insert(string key, int value) {\\n        m[key] = value;\\n    }\\n    int sum(string s) {\\n        auto t = 0;\\n        auto n = s.size();\\n        for (auto it = m.lower_bound(s); it != m.end() && it->first.substr(0, n) == s; ++it)\\n            t += it->second;\\n        return t;\\n    }\\n};\\n```\n```\\nclass MapSum {\\npublic:\\n    void insert(string key, int val) {\\n        bool found=K.find(key)!=K.end();\\n        K.insert(key);\\n        for (int i=1; i<=(int)key.size(); ++i){\\n            if (found)\\n                M[key.substr(0,i)]=val;\\n            else\\n                M[key.substr(0,i)]+=val;\\n        }\\n    }\\n    int sum(string prefix) {\\n        return M[prefix];\\n    }\\nprivate:\\n    unordered_map<string,int> M;\\n    unordered_set<string> K;\\n};\\n```\n```\\nclass MapSum {\\npublic:\\n    void insert(string key, int val) {\\n        for (int i=1,N=(int)key.size(),found=!(K.insert(key).second); i<=N; ++i)\\n            M[key.substr(0,i)]=found ? val : val+M[key.substr(0,i)];\\n    }\\n    int sum(string prefix) { return M[prefix]; }\\nprivate:\\n    unordered_map<string,int> M;\\n    unordered_set<string> K;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734411,
                "title": "solution-using-trie-and-map-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TrieNode{\\n    public:\\n    TrieNode* children[26];\\n    int prefsum;\\n    TrieNode(){\\n        for(int i=0;i<26;i++){\\n            children[i]=NULL;\\n        }\\n        prefsum=0;\\n    }\\n};\\nclass MapSum {\\npublic:\\nTrieNode* root = new TrieNode();\\nvoid put(string s,int val){\\n    TrieNode* node = root;\\n    for(int i=0;i<s.size();i++){\\n        if(node->children[s[i]-\\'a\\']==NULL){\\n            node->children[s[i]-\\'a\\']= new TrieNode();\\n        }\\n        node = node->children[s[i]-\\'a\\'];\\n        node->prefsum += val;\\n    }\\n}\\nunordered_map<string,int> mp;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        int add =0;\\n        if(mp.count(key)>0){\\n            int prev = mp[key];\\n            if(prev==val)return ;\\n            if(prev>val){\\n                add = val-prev;\\n            }else add= val-prev;\\n            put(key,add);\\n            mp[key]= val;\\n        }else{\\n            put(key,val);\\n            mp[key]=val;\\n        }\\n    }\\n    \\n    int sum(string s) {\\n        int ans =0;\\n        TrieNode* node = root;\\n        for(int i=0;i<s.size();i++){\\n            if(node->children[s[i]-\\'a\\']==NULL)return 0;\\n            else{\\n                node = node->children[s[i]-\\'a\\'];\\n                ans = node->prefsum;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TrieNode{\\n    public:\\n    TrieNode* children[26];\\n    int prefsum;\\n    TrieNode(){\\n        for(int i=0;i<26;i++){\\n            children[i]=NULL;\\n        }\\n        prefsum=0;\\n    }\\n};\\nclass MapSum {\\npublic:\\nTrieNode* root = new TrieNode();\\nvoid put(string s,int val){\\n    TrieNode* node = root;\\n    for(int i=0;i<s.size();i++){\\n        if(node->children[s[i]-\\'a\\']==NULL){\\n            node->children[s[i]-\\'a\\']= new TrieNode();\\n        }\\n        node = node->children[s[i]-\\'a\\'];\\n        node->prefsum += val;\\n    }\\n}\\nunordered_map<string,int> mp;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        int add =0;\\n        if(mp.count(key)>0){\\n            int prev = mp[key];\\n            if(prev==val)return ;\\n            if(prev>val){\\n                add = val-prev;\\n            }else add= val-prev;\\n            put(key,add);\\n            mp[key]= val;\\n        }else{\\n            put(key,val);\\n            mp[key]=val;\\n        }\\n    }\\n    \\n    int sum(string s) {\\n        int ans =0;\\n        TrieNode* node = root;\\n        for(int i=0;i<s.size();i++){\\n            if(node->children[s[i]-\\'a\\']==NULL)return 0;\\n            else{\\n                node = node->children[s[i]-\\'a\\'];\\n                ans = node->prefsum;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430954,
                "title": "solution",
                "content": "```C++ []\\nstruct TrieNode {\\n  vector<shared_ptr<TrieNode>> children;\\n  int sum = 0;\\n  TrieNode() : children(26) {}\\n};\\nclass MapSum {\\n public:\\n  void insert(string key, int val) {\\n    const int diff = val - keyToVal[key];\\n    shared_ptr<TrieNode> node = root;\\n    for (const char c : key) {\\n      const int i = c - \\'a\\';\\n      if (node->children[i] == nullptr)\\n        node->children[i] = make_shared<TrieNode>();\\n      node = node->children[i];\\n      node->sum += diff;\\n    }\\n    keyToVal[key] = val;\\n  }\\n  int sum(string prefix) {\\n    shared_ptr<TrieNode> node = root;\\n    for (const char c : prefix) {\\n      const int i = c - \\'a\\';\\n      if (node->children[i] == nullptr)\\n        return 0;\\n      node = node->children[i];\\n    }\\n    return node->sum;\\n  }\\n private:\\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\\n  unordered_map<string, int> keyToVal;\\n};\\n```\\n\\n```Python3 []\\nclass MapSum:\\n\\n    def __init__(self):\\n        self.trie = {}\\n\\n    def insert(self, key: str, val: int) -> None:\\n        node = self.trie\\n        for ch in key:\\n            node = node.setdefault(ch, {})\\n        node[\\'val\\'] = val\\n        return\\n\\n    def sum(self, prefix: str) -> int:\\n        def traverse(node):\\n            nonlocal res\\n            if not node:\\n                return\\n            if \\'val\\' in node:\\n                res += node[\\'val\\']\\n            for child in node:\\n                if child == \\'val\\': continue\\n                traverse(node[child])\\n            return\\n            \\n        node = self.trie\\n        for ch in prefix:\\n            node = node.get(ch, {})\\n            if not node:\\n                return 0\\n        res = 0\\n        traverse(node)\\n        return res\\n```\\n\\n```Java []\\nclass MapSum {\\n    class TrieNode {\\n        TrieNode next[] = new TrieNode[26];\\n        int val = 0;\\n        int sum = 0;\\n    }\\n    TrieNode head;\\n    public MapSum() {\\n        head = new TrieNode();\\n    }\\n    public void insert(String key, int val) {\\n        int n = key.length();\\n        TrieNode tmp = head;\\n        for (int i = 0; i < n; i++) {\\n            int now = key.charAt(i) - \\'a\\';\\n            if (tmp.next[now] == null) tmp.next[now] = new TrieNode();\\n            tmp = tmp.next[now];\\n        }\\n        int diff = val - tmp.val;\\n        tmp.val = val;\\n        tmp = head;\\n\\n        for (int i = 0; i < n && diff != 0; i++) {\\n            int now = key.charAt(i) - \\'a\\';\\n            tmp.sum += diff;\\n            tmp = tmp.next[now];\\n        }\\n        tmp.sum += diff;\\n    }\\n    public int sum(String key) {\\n        int n = key.length();\\n        TrieNode tmp = head;\\n        for (int i = 0; i < n; i++) {\\n            int now = key.charAt(i) - \\'a\\';\\n            if (tmp.next[now] == null) return 0;\\n            tmp = tmp.next[now];\\n        }\\n        return tmp.sum;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nstruct TrieNode {\\n  vector<shared_ptr<TrieNode>> children;\\n  int sum = 0;\\n  TrieNode() : children(26) {}\\n};\\nclass MapSum {\\n public:\\n  void insert(string key, int val) {\\n    const int diff = val - keyToVal[key];\\n    shared_ptr<TrieNode> node = root;\\n    for (const char c : key) {\\n      const int i = c - \\'a\\';\\n      if (node->children[i] == nullptr)\\n        node->children[i] = make_shared<TrieNode>();\\n      node = node->children[i];\\n      node->sum += diff;\\n    }\\n    keyToVal[key] = val;\\n  }\\n  int sum(string prefix) {\\n    shared_ptr<TrieNode> node = root;\\n    for (const char c : prefix) {\\n      const int i = c - \\'a\\';\\n      if (node->children[i] == nullptr)\\n        return 0;\\n      node = node->children[i];\\n    }\\n    return node->sum;\\n  }\\n private:\\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\\n  unordered_map<string, int> keyToVal;\\n};\\n```\n```Python3 []\\nclass MapSum:\\n\\n    def __init__(self):\\n        self.trie = {}\\n\\n    def insert(self, key: str, val: int) -> None:\\n        node = self.trie\\n        for ch in key:\\n            node = node.setdefault(ch, {})\\n        node[\\'val\\'] = val\\n        return\\n\\n    def sum(self, prefix: str) -> int:\\n        def traverse(node):\\n            nonlocal res\\n            if not node:\\n                return\\n            if \\'val\\' in node:\\n                res += node[\\'val\\']\\n            for child in node:\\n                if child == \\'val\\': continue\\n                traverse(node[child])\\n            return\\n            \\n        node = self.trie\\n        for ch in prefix:\\n            node = node.get(ch, {})\\n            if not node:\\n                return 0\\n        res = 0\\n        traverse(node)\\n        return res\\n```\n```Java []\\nclass MapSum {\\n    class TrieNode {\\n        TrieNode next[] = new TrieNode[26];\\n        int val = 0;\\n        int sum = 0;\\n    }\\n    TrieNode head;\\n    public MapSum() {\\n        head = new TrieNode();\\n    }\\n    public void insert(String key, int val) {\\n        int n = key.length();\\n        TrieNode tmp = head;\\n        for (int i = 0; i < n; i++) {\\n            int now = key.charAt(i) - \\'a\\';\\n            if (tmp.next[now] == null) tmp.next[now] = new TrieNode();\\n            tmp = tmp.next[now];\\n        }\\n        int diff = val - tmp.val;\\n        tmp.val = val;\\n        tmp = head;\\n\\n        for (int i = 0; i < n && diff != 0; i++) {\\n            int now = key.charAt(i) - \\'a\\';\\n            tmp.sum += diff;\\n            tmp = tmp.next[now];\\n        }\\n        tmp.sum += diff;\\n    }\\n    public int sum(String key) {\\n        int n = key.length();\\n        TrieNode tmp = head;\\n        for (int i = 0; i < n; i++) {\\n            int now = key.charAt(i) - \\'a\\';\\n            if (tmp.next[now] == null) return 0;\\n            tmp = tmp.next[now];\\n        }\\n        return tmp.sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318818,
                "title": "677-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDefine a TrieNode class with two attributes: children (a dictionary mapping characters to child nodes) and value (an integer representing the sum of values stored at or below this node in the Trie).\\n\\nDefine a MapSum class with two attributes: root (a TrieNode representing the root of the Trie) and map (a dictionary mapping keys to values).\\n\\nDefine an insert method that takes a key (a string) and a value (an integer) as input. Calculate the difference between the new value and the old value for the given key (if it exists), and store the new value in the map dictionary.\\n\\nTraverse the Trie from the root to the node that represents the prefix of the key, and update the node value with the new value. Start by initializing a variable node to the root node and adding the difference to node.value. Then, iterate through each character in the key string. If the character is not in node.children, create a new TrieNode and add it to node.children. Update node to be the child node corresponding to the current character, and add the difference to node.value.\\n\\nDefine a sum method that takes a prefix (a string) as input and returns the sum of values stored in the Trie at or below the node that represents the prefix. Start by initializing a variable node to the root node. Then, iterate through each character in the prefix string. If the character is not in node.children, return 0 (indicating that no keys with this prefix exist in the Trie). Otherwise, update node to be the child node corresponding to the current character. Once the loop is finished, return node.value (the sum of values stored at or below the node representing the prefix).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.value = 0\\n\\nclass MapSum:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.map = {}\\n\\n    def insert(self, key: str, val: int) -> None:\\n        # Calculate the difference between the new value and the old value\\n        # for the given key, if it exists.\\n        diff = val - self.map.get(key, 0)\\n        self.map[key] = val\\n        \\n        # Traverse the Trie from the root to the node that represents\\n        # the prefix of the key, and update the node value with the new value.\\n        node = self.root\\n        node.value += diff\\n        for char in key:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n            node.value += diff\\n\\n    def sum(self, prefix: str) -> int:\\n        # Traverse the Trie from the root to the node that represents\\n        # the prefix, and return the value of that node.\\n        node = self.root\\n        for char in prefix:\\n            if char not in node.children:\\n                return 0\\n            node = node.children[char]\\n        return node.value\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.value = 0\\n\\nclass MapSum:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.map = {}\\n\\n    def insert(self, key: str, val: int) -> None:\\n        # Calculate the difference between the new value and the old value\\n        # for the given key, if it exists.\\n        diff = val - self.map.get(key, 0)\\n        self.map[key] = val\\n        \\n        # Traverse the Trie from the root to the node that represents\\n        # the prefix of the key, and update the node value with the new value.\\n        node = self.root\\n        node.value += diff\\n        for char in key:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n            node.value += diff\\n\\n    def sum(self, prefix: str) -> int:\\n        # Traverse the Trie from the root to the node that represents\\n        # the prefix, and return the value of that node.\\n        node = self.root\\n        for char in prefix:\\n            if char not in node.children:\\n                return 0\\n            node = node.children[char]\\n        return node.value\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046561,
                "title": "0ms-faster-than-100-c-trie-solution",
                "content": "\\n\\n# Code\\n```\\nclass Trie{\\n    public:\\n    Trie* child[26];\\n    int val;\\n    Trie(){\\n        for(int i=0;i<26;i++){\\n            child[i]=NULL;\\n        }\\n        val=0;\\n    }\\n};\\nclass MapSum {\\npublic:\\n    Trie* root=new Trie();\\n    int res=0;\\n    MapSum() {\\n        \\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        Trie* curr=root;\\n        for(int i=0;i<key.length();i++){\\n            int idx=key[i]-97;\\n            if(curr->child[idx]==NULL){\\n                curr->child[idx]=new Trie();\\n            }\\n            curr=curr->child[idx];\\n        }\\n        curr->val=val;\\n        \\n    }\\n    void helper(Trie* curr){\\n        res+=curr->val;\\n        for(int i=0;i<26;i++){\\n            if(curr->child[i]){\\n                helper(curr->child[i]);\\n            }\\n        }\\n        \\n    }\\n    \\n    int sum(string prefix) {\\n        res=0;\\n        Trie* curr=root;\\n        for(int i=0;i<prefix.size();i++){\\n            int idx=prefix[i]-97;\\n            if(curr->child[idx]==NULL){\\n                return 0;\\n            }\\n            curr=curr->child[idx];\\n\\n        }\\n        helper(curr);\\n        return res;//if its prefix then only we will check for this words value\\n    }\\n};\\n\\n\\n\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Trie{\\n    public:\\n    Trie* child[26];\\n    int val;\\n    Trie(){\\n        for(int i=0;i<26;i++){\\n            child[i]=NULL;\\n        }\\n        val=0;\\n    }\\n};\\nclass MapSum {\\npublic:\\n    Trie* root=new Trie();\\n    int res=0;\\n    MapSum() {\\n        \\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        Trie* curr=root;\\n        for(int i=0;i<key.length();i++){\\n            int idx=key[i]-97;\\n            if(curr->child[idx]==NULL){\\n                curr->child[idx]=new Trie();\\n            }\\n            curr=curr->child[idx];\\n        }\\n        curr->val=val;\\n        \\n    }\\n    void helper(Trie* curr){\\n        res+=curr->val;\\n        for(int i=0;i<26;i++){\\n            if(curr->child[i]){\\n                helper(curr->child[i]);\\n            }\\n        }\\n        \\n    }\\n    \\n    int sum(string prefix) {\\n        res=0;\\n        Trie* curr=root;\\n        for(int i=0;i<prefix.size();i++){\\n            int idx=prefix[i]-97;\\n            if(curr->child[idx]==NULL){\\n                return 0;\\n            }\\n            curr=curr->child[idx];\\n\\n        }\\n        helper(curr);\\n        return res;//if its prefix then only we will check for this words value\\n    }\\n};\\n\\n\\n\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044287,
                "title": "java-simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass MapSum {\\n    Map<String,Integer> maplist=null;\\n    public MapSum() {\\n        this.maplist=new HashMap<String,Integer>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n         maplist.put(key,val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        Set<String> setlist=maplist.keySet();\\n        int count=0;\\n        for(String s:setlist){\\n            if(s.startsWith(prefix)) count+=maplist.get(s);\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MapSum {\\n    Map<String,Integer> maplist=null;\\n    public MapSum() {\\n        this.maplist=new HashMap<String,Integer>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n         maplist.put(key,val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        Set<String> setlist=maplist.keySet();\\n        int count=0;\\n        for(String s:setlist){\\n            if(s.startsWith(prefix)) count+=maplist.get(s);\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849995,
                "title": "100-faster-using-map-easy-to-understand-c-solution",
                "content": "```\\nclass MapSum {\\npublic:\\n    unordered_map<string,int> mp;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        mp[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int ans = 0, x=  0,k;\\n        for(auto &i: mp)\\n            if(i.first.length()>=prefix.length()){\\n                x = 0;\\n                for(k = 0; k <prefix.length(); k++){\\n                    x += i.first[k]==prefix[k];\\n                }\\n                if(x==prefix.length()){\\n                    ans += i.second;\\n                }\\n            }\\n    return ans;\\n        }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass MapSum {\\npublic:\\n    unordered_map<string,int> mp;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        mp[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int ans = 0, x=  0,k;\\n        for(auto &i: mp)\\n            if(i.first.length()>=prefix.length()){\\n                x = 0;\\n                for(k = 0; k <prefix.length(); k++){\\n                    x += i.first[k]==prefix[k];\\n                }\\n                if(x==prefix.length()){\\n                    ans += i.second;\\n                }\\n            }\\n    return ans;\\n        }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612805,
                "title": "easy-cpp-solution-of-trie",
                "content": "```\\nclass node{\\n  public:\\n    node* v[26];\\n    int val=0;\\n    \\n    bool ispresent(char c){\\n        return this->v[c-\\'a\\']!=NULL;\\n    }\\n    \\n    void create(char c,node* n){\\n        this->v[c-\\'a\\']=n;\\n    }\\n    \\n    void addval(int value){\\n        this->val+=value;\\n    }\\n};\\n\\nclass trie{\\n    public:\\n    node* root=new node();\\n    \\n    void insert(string key,int val){\\n        node* r1=root;\\n        for(auto ele:key){\\n            \\n            if(!r1->ispresent(ele)){\\n                r1->create(ele,new node());    \\n            }\\n            \\n            r1=r1->v[ele-\\'a\\'];\\n            r1->addval(val);\\n        }\\n    }\\n    \\n    int countprefixsum(string prefix){\\n        node* r1=root;\\n        \\n        for(auto ele:prefix){\\n            if(!r1->ispresent(ele))return 0;\\n            r1=r1->v[ele-\\'a\\'];\\n        }\\n        return r1->val;\\n    }\\n};\\n\\nclass MapSum {\\npublic:\\n    \\n    unordered_map<string,int>m;\\n    trie* root;\\n    MapSum() {\\n        root=new trie();\\n    }\\n    \\n    void insert(string key, int val) {\\n        int a=val;\\n        if(m.find(key)!=m.end()){\\n            val-=m[key];\\n        }    \\n        m[key]=a;\\n        root->insert(key,val);\\n    }\\n    \\n    int sum(string prefix) {\\n        return root->countprefixsum(prefix);\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass node{\\n  public:\\n    node* v[26];\\n    int val=0;\\n    \\n    bool ispresent(char c){\\n        return this->v[c-\\'a\\']!=NULL;\\n    }\\n    \\n    void create(char c,node* n){\\n        this->v[c-\\'a\\']=n;\\n    }\\n    \\n    void addval(int value){\\n        this->val+=value;\\n    }\\n};\\n\\nclass trie{\\n    public:\\n    node* root=new node();\\n    \\n    void insert(string key,int val){\\n        node* r1=root;\\n        for(auto ele:key){\\n            \\n            if(!r1->ispresent(ele)){\\n                r1->create(ele,new node());    \\n            }\\n            \\n            r1=r1->v[ele-\\'a\\'];\\n            r1->addval(val);\\n        }\\n    }\\n    \\n    int countprefixsum(string prefix){\\n        node* r1=root;\\n        \\n        for(auto ele:prefix){\\n            if(!r1->ispresent(ele))return 0;\\n            r1=r1->v[ele-\\'a\\'];\\n        }\\n        return r1->val;\\n    }\\n};\\n\\nclass MapSum {\\npublic:\\n    \\n    unordered_map<string,int>m;\\n    trie* root;\\n    MapSum() {\\n        root=new trie();\\n    }\\n    \\n    void insert(string key, int val) {\\n        int a=val;\\n        if(m.find(key)!=m.end()){\\n            val-=m[key];\\n        }    \\n        m[key]=a;\\n        root->insert(key,val);\\n    }\\n    \\n    int sum(string prefix) {\\n        return root->countprefixsum(prefix);\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2078270,
                "title": "easy-c-trie-implementation",
                "content": "```\\nstruct Node{\\n    Node* links[26];\\n    int score = 0;\\n    \\n    bool containsKey(char ch){\\n        return (links[ch-\\'a\\'] != NULL);\\n    }\\n    \\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    \\n    void put(char ch, Node* node){\\n        links[ch-\\'a\\'] = node;\\n    }\\n};\\n\\nclass MapSum {\\n    Node* root;\\npublic:\\n    map<string,int> keyVal;\\n    MapSum() {\\n        root = new Node();\\n    }\\n    \\n    void insert(string key, int val) {\\n        int delta = val - keyVal[key];\\n        keyVal[key] = val;\\n        Node* node = root;\\n        \\n        for(int i=0;i<key.length();i++){\\n            char ch = key[i];\\n            if(!node->containsKey(ch)){\\n                node->put(ch, new Node());\\n            }\\n            node = node->get(ch);\\n            node->score += delta;\\n        }\\n    }\\n    \\n    int sum(string prefix) {\\n        Node* node = root;\\n        for(int i=0;i<prefix.length();i++){\\n            char ch = prefix[i];\\n            if(!node->containsKey(ch)){\\n                    return 0;\\n            }\\n            node = node->get(ch);\\n        }\\n        return node->score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* links[26];\\n    int score = 0;\\n    \\n    bool containsKey(char ch){\\n        return (links[ch-\\'a\\'] != NULL);\\n    }\\n    \\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    \\n    void put(char ch, Node* node){\\n        links[ch-\\'a\\'] = node;\\n    }\\n};\\n\\nclass MapSum {\\n    Node* root;\\npublic:\\n    map<string,int> keyVal;\\n    MapSum() {\\n        root = new Node();\\n    }\\n    \\n    void insert(string key, int val) {\\n        int delta = val - keyVal[key];\\n        keyVal[key] = val;\\n        Node* node = root;\\n        \\n        for(int i=0;i<key.length();i++){\\n            char ch = key[i];\\n            if(!node->containsKey(ch)){\\n                node->put(ch, new Node());\\n            }\\n            node = node->get(ch);\\n            node->score += delta;\\n        }\\n    }\\n    \\n    int sum(string prefix) {\\n        Node* node = root;\\n        for(int i=0;i<prefix.length();i++){\\n            char ch = prefix[i];\\n            if(!node->containsKey(ch)){\\n                    return 0;\\n            }\\n            node = node->get(ch);\\n        }\\n        return node->score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078048,
                "title": "c-accepted-code-using-trie-implemented-in-a-oop-style",
                "content": "```\\nclass Node {\\n    private:\\n    Node* links[26];\\n    int val = 0;\\n    bool flag = false;\\n    public:\\n    bool containsKey(char ch) {\\n        return links[ch-\\'a\\'] != nullptr;\\n    }\\n    void put(char ch, Node* node) {\\n        links[ch-\\'a\\'] = node;\\n    }\\n    Node* get(char ch) {\\n        return links[ch-\\'a\\'];\\n    }\\n    void setVal(int val) {\\n        this->val = val;\\n    }\\n    int getVal() {\\n        return val;\\n    }\\n    void setEnd() {\\n        flag = true;\\n    }\\n    bool getEnd() {\\n        return flag;\\n    }\\n};\\n\\nclass MapSum {\\nprivate:\\n    Node* root;\\npublic:\\n    MapSum() {\\n        root = new Node();\\n    }\\n    \\n    void insert(string key, int val) {\\n        Node* node = root;\\n        for(char ch : key) {\\n            if(!node->containsKey(ch)) {\\n                node->put(ch, new Node());\\n            }\\n            node = node->get(ch);\\n        }\\n        node->setVal(val);\\n        node->setEnd();\\n    }\\n    \\n    void dfs(Node* node, int &ans) {\\n        if(node->getEnd()) {\\n            ans += node->getVal();\\n            cout << node->getEnd() << node->getVal();\\n        }\\n        for(char ch=\\'a\\'; ch<=\\'z\\'; ch++) {\\n            if(node->containsKey(ch)) {\\n                dfs(node->get(ch), ans);\\n            }\\n        }\\n    }\\n    int sum(string prefix) {\\n        Node* node = root;\\n        int ans = 0;\\n        for(char ch : prefix) {\\n            if(!node->containsKey(ch)) return 0;\\n            node = node->get(ch);\\n        }\\n        dfs(node, ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Node {\\n    private:\\n    Node* links[26];\\n    int val = 0;\\n    bool flag = false;\\n    public:\\n    bool containsKey(char ch) {\\n        return links[ch-\\'a\\'] != nullptr;\\n    }\\n    void put(char ch, Node* node) {\\n        links[ch-\\'a\\'] = node;\\n    }\\n    Node* get(char ch) {\\n        return links[ch-\\'a\\'];\\n    }\\n    void setVal(int val) {\\n        this->val = val;\\n    }\\n    int getVal() {\\n        return val;\\n    }\\n    void setEnd() {\\n        flag = true;\\n    }\\n    bool getEnd() {\\n        return flag;\\n    }\\n};\\n\\nclass MapSum {\\nprivate:\\n    Node* root;\\npublic:\\n    MapSum() {\\n        root = new Node();\\n    }\\n    \\n    void insert(string key, int val) {\\n        Node* node = root;\\n        for(char ch : key) {\\n            if(!node->containsKey(ch)) {\\n                node->put(ch, new Node());\\n            }\\n            node = node->get(ch);\\n        }\\n        node->setVal(val);\\n        node->setEnd();\\n    }\\n    \\n    void dfs(Node* node, int &ans) {\\n        if(node->getEnd()) {\\n            ans += node->getVal();\\n            cout << node->getEnd() << node->getVal();\\n        }\\n        for(char ch=\\'a\\'; ch<=\\'z\\'; ch++) {\\n            if(node->containsKey(ch)) {\\n                dfs(node->get(ch), ans);\\n            }\\n        }\\n    }\\n    int sum(string prefix) {\\n        Node* node = root;\\n        int ans = 0;\\n        for(char ch : prefix) {\\n            if(!node->containsKey(ch)) return 0;\\n            node = node->get(ch);\\n        }\\n        dfs(node, ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1373663,
                "title": "trie-solution-without-any-explicit-hashmap-only-trie",
                "content": "This approach is very similar to [heipit](https://leetcode.com/hiepit/)\\'s [this solution with trie and hashmap](https://leetcode.com/problems/map-sum-pairs/discuss/1371761/C%2B%2BJavaPython-Trie-and-HashMap-Efficient-and-Clean-and-Concise). I would like to request to read the idea section of this post first.\\n\\nI tried to avoid the use of explicit hashmap. If any word ends at any node, it is a endPoint of the word. So in that node `endPoint` variable is set `true`, and the current input value for the word is saved in `endVal`.\\n\\n```\\nclass MapSum {\\n    struct node {\\n        int sum;\\n        bool endPoint;\\n        int endVal;\\n        node* child[26];\\n\\n        node() {\\n            sum = 0;\\n            endPoint = false;\\n            endVal = 0;\\n            for (int i = 0; i < 26; i++) {\\n                child[i] = nullptr;\\n            }\\n        }\\n    };\\n\\npublic:\\n    node* root;\\n\\n    MapSum() {\\n        root = new node();\\n    }\\n    \\n    void insert(string key, int val) {\\n        node* curr = root;\\n\\n        for (int i = 0; i < key.length(); i++) {\\n            if (curr->child[key[i]-\\'a\\'] == nullptr)  {\\n                curr->child[key[i]-\\'a\\'] = new node();\\n            }\\n            curr = curr->child[key[i]-\\'a\\'];\\n            curr->sum += val;\\n        }\\n\\n        if (curr->endPoint == true) {\\n            int prevVal = curr->endVal;\\n            int toAdd = -prevVal+val;\\n\\n            node* curr = root;\\n\\n            for (int i = 0; i < key.length(); i++) {\\n                curr = curr->child[key[i]-\\'a\\'];\\n                curr->sum -= val;\\n                curr->sum += toAdd;\\n            }\\n        }\\n\\n        curr->endPoint = true;\\n        curr->endVal = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        node *curr = root;\\n        \\n        for (int i = 0; i < prefix.length(); i++) {\\n            if (curr->child[prefix[i]-\\'a\\'] == nullptr) {\\n                return 0;\\n            }\\n            curr = curr->child[prefix[i]-\\'a\\'];\\n        }\\n\\n        return curr->sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n    struct node {\\n        int sum;\\n        bool endPoint;\\n        int endVal;\\n        node* child[26];\\n\\n        node() {\\n            sum = 0;\\n            endPoint = false;\\n            endVal = 0;\\n            for (int i = 0; i < 26; i++) {\\n                child[i] = nullptr;\\n            }\\n        }\\n    };\\n\\npublic:\\n    node* root;\\n\\n    MapSum() {\\n        root = new node();\\n    }\\n    \\n    void insert(string key, int val) {\\n        node* curr = root;\\n\\n        for (int i = 0; i < key.length(); i++) {\\n            if (curr->child[key[i]-\\'a\\'] == nullptr)  {\\n                curr->child[key[i]-\\'a\\'] = new node();\\n            }\\n            curr = curr->child[key[i]-\\'a\\'];\\n            curr->sum += val;\\n        }\\n\\n        if (curr->endPoint == true) {\\n            int prevVal = curr->endVal;\\n            int toAdd = -prevVal+val;\\n\\n            node* curr = root;\\n\\n            for (int i = 0; i < key.length(); i++) {\\n                curr = curr->child[key[i]-\\'a\\'];\\n                curr->sum -= val;\\n                curr->sum += toAdd;\\n            }\\n        }\\n\\n        curr->endPoint = true;\\n        curr->endVal = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        node *curr = root;\\n        \\n        for (int i = 0; i < prefix.length(); i++) {\\n            if (curr->child[prefix[i]-\\'a\\'] == nullptr) {\\n                return 0;\\n            }\\n            curr = curr->child[prefix[i]-\\'a\\'];\\n        }\\n\\n        return curr->sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373108,
                "title": "simple-straight-forward-trie-solutions-c",
                "content": "```\\nclass Trie\\n{\\n    public:\\n        Trie* children[26];\\n        int val,endofword;\\n        Trie():val(0),endofword(0){\\n            for(int i = 0; i < 26; ++i)\\n                children[i] = nullptr;\\n        }\\n        ~Trie(){\\n            for(int i = 0; i < 26; ++i)\\n                if(children[i]) delete children[i];\\n        }\\n        int find_val(string word){\\n            Trie* curr = this;\\n            for(char c: word)\\n            {\\n                if(curr->children[c-\\'a\\'])\\n                    curr=curr->children[c-\\'a\\'];\\n                else\\n                    return 0;\\n            }\\n            return curr->endofword;\\n        } \\n        void insert(string word,int x,int actual_value)\\n        {\\n            Trie* curr = this;\\n            for(char c: word){\\n                if(!curr->children[c-\\'a\\']) curr->children[c - \\'a\\'] = new Trie();\\n                curr = curr->children[c-\\'a\\'];\\n                curr->val += x;\\n            }\\n            curr->endofword = actual_value;\\n        }\\n        int get(string word)\\n        {\\n            Trie* curr = this;\\n            for(char c: word)\\n            {\\n                if(curr->children[c-\\'a\\'])\\n                    curr=curr->children[c-\\'a\\'];\\n                else\\n                    return 0;\\n            }\\n            return curr->val;\\n        }\\n};\\n\\n \\nclass MapSum {\\npublic:\\n    Trie trie;\\n    MapSum() {}\\n    void insert(string key, int val) {\\n        int cur_Value = trie.find_val(key); \\n        trie.insert(key,val-cur_Value,val);\\n    }\\n    int sum(string prefix) {\\n        return trie.get(prefix);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie\\n{\\n    public:\\n        Trie* children[26];\\n        int val,endofword;\\n        Trie():val(0),endofword(0){\\n            for(int i = 0; i < 26; ++i)\\n                children[i] = nullptr;\\n        }\\n        ~Trie(){\\n            for(int i = 0; i < 26; ++i)\\n                if(children[i]) delete children[i];\\n        }\\n        int find_val(string word){\\n            Trie* curr = this;\\n            for(char c: word)\\n            {\\n                if(curr->children[c-\\'a\\'])\\n                    curr=curr->children[c-\\'a\\'];\\n                else\\n                    return 0;\\n            }\\n            return curr->endofword;\\n        } \\n        void insert(string word,int x,int actual_value)\\n        {\\n            Trie* curr = this;\\n            for(char c: word){\\n                if(!curr->children[c-\\'a\\']) curr->children[c - \\'a\\'] = new Trie();\\n                curr = curr->children[c-\\'a\\'];\\n                curr->val += x;\\n            }\\n            curr->endofword = actual_value;\\n        }\\n        int get(string word)\\n        {\\n            Trie* curr = this;\\n            for(char c: word)\\n            {\\n                if(curr->children[c-\\'a\\'])\\n                    curr=curr->children[c-\\'a\\'];\\n                else\\n                    return 0;\\n            }\\n            return curr->val;\\n        }\\n};\\n\\n \\nclass MapSum {\\npublic:\\n    Trie trie;\\n    MapSum() {}\\n    void insert(string key, int val) {\\n        int cur_Value = trie.find_val(key); \\n        trie.insert(key,val-cur_Value,val);\\n    }\\n    int sum(string prefix) {\\n        return trie.get(prefix);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372616,
                "title": "c-hashmap-prefix-sum",
                "content": "Approach 1: hashmap + prefix sum\\nTime Complexity: O(N*M); N is the number of strings, M is the maximum length of all strings.\\nSpace Complexity: O(N*M)\\nIn Chinese proverb:\\n\\u5316\\u6574\\u4E3A\\u96F6 \\u96F6\\u5B58\\u6574\\u53D6 \\u662F\\u5BF9\\u4ECA\\u5929\\u8FD9\\u4E2A\\u9898\\u76EE\\u4E24\\u4E2A\\u6838\\u5FC3\\u51FD\\u6570\\u7684\\u6700\\u597D\\u6982\\u62EC\\n```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {}\\n    \\n    void insert(string key, int val) {\\n        int increament = val - _dict[key].first;\\n        _dict[key].first = val;\\n        for(int i = key.size() - 1; i > 0; i--)\\n            _dict[key.substr(0,i)].second += increament;\\n    }\\n    \\n    int sum(string prefix) {\\n        return _dict[prefix].first + _dict[prefix].second;\\n    }\\n    \\nprivate:\\n    unordered_map<string, pair<int, int> > _dict; // the value of _dict is a pair, stores current value and prefix-sum\\n};\\n ```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {}\\n    \\n    void insert(string key, int val) {\\n        int increament = val - _dict[key].first;\\n        _dict[key].first = val;\\n        for(int i = key.size() - 1; i > 0; i--)\\n            _dict[key.substr(0,i)].second += increament;\\n    }\\n    \\n    int sum(string prefix) {\\n        return _dict[prefix].first + _dict[prefix].second;\\n    }\\n    \\nprivate:\\n    unordered_map<string, pair<int, int> > _dict; // the value of _dict is a pair, stores current value and prefix-sum\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1372008,
                "title": "c-simple-trie-solution",
                "content": "```\\npublic class TrieNode\\n{\\n    public Dictionary<char, TrieNode> Children;\\n    public int Count;\\n    \\n    public TrieNode()\\n    {\\n        this.Children = new Dictionary<char, TrieNode>();\\n        this.Count = 0;\\n    }\\n}\\n\\n\\npublic class MapSum\\n{\\n    private TrieNode root;\\n    private Dictionary<string, int> mapKeyCount;\\n    \\n    /** Initialize your data structure here. */\\n    public MapSum() \\n    {\\n        this.root = new TrieNode();\\n        this.mapKeyCount = new Dictionary<string, int>();\\n    }\\n    \\n    public void Insert(string key, int val) \\n    {\\n        TrieNode node = this.root;\\n        \\n        // get delta\\n        int oldVal = 0;\\n        this.mapKeyCount.TryGetValue(key, out oldVal);\\n        int delta = val - oldVal;\\n        \\n        // update mapKeyCount\\n        this.mapKeyCount[key] = val;\\n        \\n        foreach(char c in key)\\n        {\\n            if (!node.Children.ContainsKey(c))\\n            {\\n                node.Children[c] = new TrieNode();\\n            }\\n            node = node.Children[c];\\n            node.Count += delta;\\n        }\\n    }\\n    \\n    public int Sum(string prefix) \\n    {\\n        TrieNode node = this.root;\\n        foreach(char c in prefix) \\n        {\\n            if (!node.Children.ContainsKey(c))\\n            {\\n                return 0;\\n            }\\n            node = node.Children[c];\\n        }\\n        return node.Count;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.Insert(key,val);\\n * int param_2 = obj.Sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\npublic class TrieNode\\n{\\n    public Dictionary<char, TrieNode> Children;\\n    public int Count;\\n    \\n    public TrieNode()\\n    {\\n        this.Children = new Dictionary<char, TrieNode>();\\n        this.Count = 0;\\n    }\\n}\\n\\n\\npublic class MapSum\\n{\\n    private TrieNode root;\\n    private Dictionary<string, int> mapKeyCount;\\n    \\n    /** Initialize your data structure here. */\\n    public MapSum() \\n    {\\n        this.root = new TrieNode();\\n        this.mapKeyCount = new Dictionary<string, int>();\\n    }\\n    \\n    public void Insert(string key, int val) \\n    {\\n        TrieNode node = this.root;\\n        \\n        // get delta\\n        int oldVal = 0;\\n        this.mapKeyCount.TryGetValue(key, out oldVal);\\n        int delta = val - oldVal;\\n        \\n        // update mapKeyCount\\n        this.mapKeyCount[key] = val;\\n        \\n        foreach(char c in key)\\n        {\\n            if (!node.Children.ContainsKey(c))\\n            {\\n                node.Children[c] = new TrieNode();\\n            }\\n            node = node.Children[c];\\n            node.Count += delta;\\n        }\\n    }\\n    \\n    public int Sum(string prefix) \\n    {\\n        TrieNode node = this.root;\\n        foreach(char c in prefix) \\n        {\\n            if (!node.Children.ContainsKey(c))\\n            {\\n                return 0;\\n            }\\n            node = node.Children[c];\\n        }\\n        return node.Count;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.Insert(key,val);\\n * int param_2 = obj.Sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371767,
                "title": "map-sum-pairs-easy-to-understand-c-map",
                "content": "Store key ,value in a map and just matcing prefix to all the key of map and added the val in ans. \\n\\nclass MapSum {\\npublic:\\n\\n    map<string,int> m;\\n    MapSum() {\\n        \\n    }\\n    void insert(string key, int val) {\\n        m[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int ans = 0;\\n        for(auto it:m){\\n            string s = it.first;\\n            int sz = s.size();\\n            if(sz<prefix.size()) continue;\\n            bool check = false;\\n            for(int i=0;i<prefix.size();i++){\\n                if(prefix[i]!=s[i]){\\n                    check = true;\\n                    break;\\n                }\\n            }\\n            if(!check) ans+=it.second;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "Store key ,value in a map and just matcing prefix to all the key of map and added the val in ans. \\n\\nclass MapSum {\\npublic:\\n\\n    map<string,int> m;\\n    MapSum() {\\n        \\n    }\\n    void insert(string key, int val) {\\n        m[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int ans = 0;\\n        for(auto it:m){\\n            string s = it.first;\\n            int sz = s.size();\\n            if(sz<prefix.size()) continue;\\n            bool check = false;\\n            for(int i=0;i<prefix.size();i++){\\n                if(prefix[i]!=s[i]){\\n                    check = true;\\n                    break;\\n                }\\n            }\\n            if(!check) ans+=it.second;\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1293229,
                "title": "go-trie-0ms",
                "content": "```\\ntype Trie struct {\\n    isWord      bool\\n    val         int\\n    children    [26]*Trie\\n}\\n\\ntype MapSum struct {\\n    root    *Trie\\n}\\n\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() MapSum {\\n    return MapSum{\\n        root: &Trie{},\\n    }\\n}\\n\\n\\nfunc (this *MapSum) Insert(key string, val int)  {\\n    node := this.root\\n    \\n    for len(key) > 0 {\\n        w := key[0]\\n        key = key[1:]\\n        \\n        w -= \\'a\\'\\n        if node.children[w] == nil {\\n            node.children[w] = &Trie{}\\n        }\\n        \\n        node = node.children[w]\\n    }\\n    \\n    node.isWord = true\\n    node.val = val\\n}\\n\\n\\nfunc (this *MapSum) Sum(prefix string) int {\\n    pNode := this.root\\n    \\n    for len(prefix) > 0 {\\n        w := prefix[0]\\n        prefix = prefix[1:]\\n        \\n        w -= \\'a\\'\\n        if pNode.children[w] == nil {\\n            return 0\\n        }\\n        \\n        pNode = pNode.children[w]\\n    }\\n    \\n    q := make([]*Trie, 1)\\n    q[0] = pNode\\n    output := 0\\n    \\n    for len(q) > 0 {\\n        cur := q[0]\\n        q = q[1:]\\n        \\n        if cur.isWord {\\n            output += cur.val\\n        }\\n        \\n        for i := 0; i < 26; i++ {\\n            if cur.children[i] != nil {\\n                q = append(q, cur.children[i])\\n            }\\n        }\\n    }\\n    \\n    return output\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype Trie struct {\\n    isWord      bool\\n    val         int\\n    children    [26]*Trie\\n}\\n\\ntype MapSum struct {\\n    root    *Trie\\n}\\n\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() MapSum {\\n    return MapSum{\\n        root: &Trie{},\\n    }\\n}\\n\\n\\nfunc (this *MapSum) Insert(key string, val int)  {\\n    node := this.root\\n    \\n    for len(key) > 0 {\\n        w := key[0]\\n        key = key[1:]\\n        \\n        w -= \\'a\\'\\n        if node.children[w] == nil {\\n            node.children[w] = &Trie{}\\n        }\\n        \\n        node = node.children[w]\\n    }\\n    \\n    node.isWord = true\\n    node.val = val\\n}\\n\\n\\nfunc (this *MapSum) Sum(prefix string) int {\\n    pNode := this.root\\n    \\n    for len(prefix) > 0 {\\n        w := prefix[0]\\n        prefix = prefix[1:]\\n        \\n        w -= \\'a\\'\\n        if pNode.children[w] == nil {\\n            return 0\\n        }\\n        \\n        pNode = pNode.children[w]\\n    }\\n    \\n    q := make([]*Trie, 1)\\n    q[0] = pNode\\n    output := 0\\n    \\n    for len(q) > 0 {\\n        cur := q[0]\\n        q = q[1:]\\n        \\n        if cur.isWord {\\n            output += cur.val\\n        }\\n        \\n        for i := 0; i < 26; i++ {\\n            if cur.children[i] != nil {\\n                q = append(q, cur.children[i])\\n            }\\n        }\\n    }\\n    \\n    return output\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1047308,
                "title": "java-trie-beats-97-11ms-iterative",
                "content": "\\n\\tpublic class Trie {\\n\\n\\t\\tprivate class Node {\\n\\n\\t\\t\\tchar data;\\n\\t\\t\\tint key;\\n\\t\\t\\tNode[] children;\\n\\t\\t\\tboolean isTerminal;\\n\\n\\t\\t\\tpublic Node(char data, boolean isTerminal) {\\n\\t\\t\\t\\tthis.data = data;\\n\\t\\t\\t\\tthis.isTerminal = isTerminal;\\n\\t\\t\\t\\tthis.children = new Node[26];\\n\\t\\t\\t\\tthis.key = 0;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate Node root;\\n\\n\\t\\t// O(1)\\n\\t\\tpublic Trie() {\\n\\t\\t\\tthis.root = new Node(\\'\\\\0\\', false);\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic void addWord(String word, int key, int val) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\t\\ttemp = new Node(ch, false);\\n\\t\\t\\t\\t\\tcurr.children[ch - \\'a\\'] = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp.key = temp.key - val + key;\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t\\tcurr.isTerminal = true;\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic int sum(String word) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null)\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t\\treturn curr.key;\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic boolean searchWord(String word) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t\\treturn curr.isTerminal;\\n\\t\\t}\\n\\n\\t}\\n\\nclass MapSum {\\n\\n\\t\\tTrie trie;\\n\\t\\tHashMap<String, Integer> map;\\n\\n\\t\\t// O(1)\\n\\t\\tpublic MapSum() {\\n\\t\\t\\ttrie = new Trie();\\n\\t\\t\\tmap = new HashMap<String, Integer>();\\n\\t\\t}\\n\\n\\t\\t// O(key.length)\\n\\t\\tpublic void insert(String key, int val) {\\n\\t\\t\\ttrie.addWord(key, val, map.getOrDefault(key, 0));\\n            map.put(key, val);\\n\\t\\t}\\n\\n\\t\\t// O(prefix.length)\\n\\t\\tpublic int sum(String prefix) {\\n\\t\\t\\treturn trie.sum(prefix);\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n\\tpublic class Trie {\\n\\n\\t\\tprivate class Node {\\n\\n\\t\\t\\tchar data;\\n\\t\\t\\tint key;\\n\\t\\t\\tNode[] children;\\n\\t\\t\\tboolean isTerminal;\\n\\n\\t\\t\\tpublic Node(char data, boolean isTerminal) {\\n\\t\\t\\t\\tthis.data = data;\\n\\t\\t\\t\\tthis.isTerminal = isTerminal;\\n\\t\\t\\t\\tthis.children = new Node[26];\\n\\t\\t\\t\\tthis.key = 0;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate Node root;\\n\\n\\t\\t// O(1)\\n\\t\\tpublic Trie() {\\n\\t\\t\\tthis.root = new Node(\\'\\\\0\\', false);\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic void addWord(String word, int key, int val) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\t\\ttemp = new Node(ch, false);\\n\\t\\t\\t\\t\\tcurr.children[ch - \\'a\\'] = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp.key = temp.key - val + key;\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t\\tcurr.isTerminal = true;\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic int sum(String word) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null)\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t\\treturn curr.key;\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic boolean searchWord(String word) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t\\treturn curr.isTerminal;\\n\\t\\t}\\n\\n\\t}\\n\\nclass MapSum {\\n\\n\\t\\tTrie trie;\\n\\t\\tHashMap<String, Integer> map;\\n\\n\\t\\t// O(1)\\n\\t\\tpublic MapSum() {\\n\\t\\t\\ttrie = new Trie();\\n\\t\\t\\tmap = new HashMap<String, Integer>();\\n\\t\\t}\\n\\n\\t\\t// O(key.length)\\n\\t\\tpublic void insert(String key, int val) {\\n\\t\\t\\ttrie.addWord(key, val, map.getOrDefault(key, 0));\\n            map.put(key, val);\\n\\t\\t}\\n\\n\\t\\t// O(prefix.length)\\n\\t\\tpublic int sum(String prefix) {\\n\\t\\t\\treturn trie.sum(prefix);\\n\\t\\t}\\n\\t}\\n",
                "codeTag": "Java"
            },
            {
                "id": 946683,
                "title": "c-savvy-solution-with-trie-0ms",
                "content": "Each trie node has a value attached to it, so when you have a prefix, you just need to traverse the prefix in the trie.\\n\\nTo track if words are already in the trie, we keep a hash, and when we assign new vals to the nodes, we subtract the old val and add the new value (`curr->val+= val- h;`). When `key` is not in hash, hash[key] = 0. \\n```\\nclass MapSum {\\npublic:\\n  struct Node{\\n    vector<Node*> kids;\\n    int val;\\n    Node():val(0), kids(vector<Node*>(26)){}\\n  };\\n  unordered_map<string,int> hash;\\n  Node* root;\\n  MapSum() {\\n    root= new Node();\\n  }\\n\\n  void insert(string key, int val) {\\n    auto curr=root;\\n    int h=hash[key];\\n    for(char ch:key){\\n      int c= ch-\\'a\\';\\n      // printf(\"ch=%c, curr->kids.size()=%d\\\\n\", ch, curr->kids.size());\\n      if(curr->kids[c]== nullptr){\\n        curr->kids[c]= new Node();\\n      }\\n      curr=curr->kids[c];\\n      curr->val+= val- h;\\n    }\\n    hash[key]=val;\\n  }\\n\\n  int sum(string prefix) {\\n    auto curr=root;\\n    int res=0;\\n    for(char ch: prefix){\\n      int c= ch-\\'a\\';\\n      if(curr->kids[c]== nullptr){\\n        // cout<<prefix<<endl;      \\n        return 0; // nothing has this prefix\\n      } \\n      curr=curr->kids[c];\\n      res= curr->val;\\n    }\\n    return res;\\n  }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */",
                "solutionTags": [],
                "code": "Each trie node has a value attached to it, so when you have a prefix, you just need to traverse the prefix in the trie.\\n\\nTo track if words are already in the trie, we keep a hash, and when we assign new vals to the nodes, we subtract the old val and add the new value (`curr->val+= val- h;`). When `key` is not in hash, hash[key] = 0. \\n```\\nclass MapSum {\\npublic:\\n  struct Node{\\n    vector<Node*> kids;\\n    int val;\\n    Node():val(0), kids(vector<Node*>(26)){}\\n  };\\n  unordered_map<string,int> hash;\\n  Node* root;\\n  MapSum() {\\n    root= new Node();\\n  }\\n\\n  void insert(string key, int val) {\\n    auto curr=root;\\n    int h=hash[key];\\n    for(char ch:key){\\n      int c= ch-\\'a\\';\\n      // printf(\"ch=%c, curr->kids.size()=%d\\\\n\", ch, curr->kids.size());\\n      if(curr->kids[c]== nullptr){\\n        curr->kids[c]= new Node();\\n      }\\n      curr=curr->kids[c];\\n      curr->val+= val- h;\\n    }\\n    hash[key]=val;\\n  }\\n\\n  int sum(string prefix) {\\n    auto curr=root;\\n    int res=0;\\n    for(char ch: prefix){\\n      int c= ch-\\'a\\';\\n      if(curr->kids[c]== nullptr){\\n        // cout<<prefix<<endl;      \\n        return 0; // nothing has this prefix\\n      } \\n      curr=curr->kids[c];\\n      res= curr->val;\\n    }\\n    return res;\\n  }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */",
                "codeTag": "C++"
            },
            {
                "id": 859187,
                "title": "python-trie-readable-easy-understanding",
                "content": "```\\nclass MapSum(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = {}\\n        \\n    def insert(self, key, val):\\n        \"\"\"\\n        :type key: str\\n        :type val: int\\n        :rtype: None\\n        \"\"\"\\n        root = self.root\\n        for w in key:\\n            if w not in root:\\n                root[w] = {}\\n            root = root[w]\\n        root[\"-\"] = val\\n        \\n    def get_siblings(self,prefix):\\n        root = self.root\\n        for w in prefix:\\n            if w not in root:\\n                return None\\n            root = root[w]\\n        return root\\n    \\n    def get_sum(self,root):\\n        cost = 0\\n        for w in root:\\n            if w == \"-\":\\n                cost+=root[w]\\n                continue\\n            cost+=self.get_sum(root[w])\\n        return cost\\n \\n    def sum(self, prefix):\\n        \"\"\"\\n        :type prefix: str\\n        :rtype: int\\n        \"\"\"\\n        root = self.get_siblings(prefix)\\n        if root: return self.get_sum(root)\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass MapSum(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = {}\\n        \\n    def insert(self, key, val):\\n        \"\"\"\\n        :type key: str\\n        :type val: int\\n        :rtype: None\\n        \"\"\"\\n        root = self.root\\n        for w in key:\\n            if w not in root:\\n                root[w] = {}\\n            root = root[w]\\n        root[\"-\"] = val\\n        \\n    def get_siblings(self,prefix):\\n        root = self.root\\n        for w in prefix:\\n            if w not in root:\\n                return None\\n            root = root[w]\\n        return root\\n    \\n    def get_sum(self,root):\\n        cost = 0\\n        for w in root:\\n            if w == \"-\":\\n                cost+=root[w]\\n                continue\\n            cost+=self.get_sum(root[w])\\n        return cost\\n \\n    def sum(self, prefix):\\n        \"\"\"\\n        :type prefix: str\\n        :rtype: int\\n        \"\"\"\\n        root = self.get_siblings(prefix)\\n        if root: return self.get_sum(root)\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188741,
                "title": "python-short-fast-beats-100",
                "content": "```\\nclass MapSum(object):\\n\\n    def __init__(self):\\n        self.scores = collections.defaultdict(int)\\n        self.words = {}\\n        \\n\\n    def insert(self, key, val):\\n        diff = val - self.words.get(key, 0)\\n        self.words[key] = val\\n        for i in xrange(len(key) + 1):\\n            self.scores[key[:i]] += diff\\n        \\n\\n    def sum(self, prefix):\\n        return self.scores[prefix]\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum(object):\\n\\n    def __init__(self):\\n        self.scores = collections.defaultdict(int)\\n        self.words = {}\\n        \\n\\n    def insert(self, key, val):\\n        diff = val - self.words.get(key, 0)\\n        self.words[key] = val\\n        for i in xrange(len(key) + 1):\\n            self.scores[key[:i]] += diff\\n        \\n\\n    def sum(self, prefix):\\n        return self.scores[prefix]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147574,
                "title": "c-dictionary-and-single-line-linq-query",
                "content": "```\\npublic class MapSum {    \\n    private Dictionary<string, int> _map = new Dictionary<string, int>();\\n    public MapSum() {        \\n    }\\n    \\n    public void Insert(string key, int val) {\\n        _map[key] = val;\\n    }\\n    \\n    public int Sum(string prefix) {\\n        return _map.Where(k => k.Key.StartsWith(prefix)).Select(y => y.Value).Sum();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MapSum {    \\n    private Dictionary<string, int> _map = new Dictionary<string, int>();\\n    public MapSum() {        \\n    }\\n    \\n    public void Insert(string key, int val) {\\n        _map[key] = val;\\n    }\\n    \\n    public int Sum(string prefix) {\\n        return _map.Where(k => k.Key.StartsWith(prefix)).Select(y => y.Value).Sum();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138597,
                "title": "javascript-solution-beats-100-00-runtime-52ms-build-a-trie",
                "content": "```\\nvar MapSum = function(value=\\'\\') {\\n    this.value = value;\\n    this.count = 0;\\n    this.isWord = false;\\n};\\n\\nMapSum.prototype.insert = function(key, val) {\\n    let cur = this, replace = this.search(key);\\n    if(replace===false){\\n    \\tthis.count+=val;\\n    \\tfor(let i=0, len=key.length; i<len; i++){\\n\\t    \\tif(!cur[key[i]]) cur[key[i]] = new MapSum(cur.value+key[i]);\\n\\t    \\tcur[key[i]].count+=val;\\n\\t    \\tcur = cur[key[i]];\\n\\t    }\\n\\t    cur.isWord = true;\\n\\t}\\n    else{\\n    \\tthis.count = this.count+val-replace;\\n    \\tfor(let i=0, len=key.length; i<len; i++){\\n\\t    \\tif(!cur[key[i]]) cur[key[i]] = new MapSum(cur.value+key[i]);\\n\\t    \\tcur[key[i]].count = cur[key[i]].count-replace+val;\\n\\t    \\tcur = cur[key[i]];\\n\\t    }\\n\\t}\\n};\\n\\nMapSum.prototype.sum = function(prefix) {\\n    let cur = this;\\n    for(let i=0, len=prefix.length; i<len; i++){\\n    \\tif(!cur[prefix[i]]) return 0;\\n    \\tcur = cur[prefix[i]];\\n    }\\n    return cur.count;\\n};\\n\\nMapSum.prototype.search = function(key) {\\n    let cur = this;\\n    for(let i=0, len=key.length; i<len; i++){\\n    \\tif(!cur[key[i]]) return false;\\n    \\tcur = cur[key[i]];\\n    }\\n    if(cur.isWord) return cur.count;\\n    else return false;\\n};\\n ```",
                "solutionTags": [],
                "code": "```\\nvar MapSum = function(value=\\'\\') {\\n    this.value = value;\\n    this.count = 0;\\n    this.isWord = false;\\n};\\n\\nMapSum.prototype.insert = function(key, val) {\\n    let cur = this, replace = this.search(key);\\n    if(replace===false){\\n    \\tthis.count+=val;\\n    \\tfor(let i=0, len=key.length; i<len; i++){\\n\\t    \\tif(!cur[key[i]]) cur[key[i]] = new MapSum(cur.value+key[i]);\\n\\t    \\tcur[key[i]].count+=val;\\n\\t    \\tcur = cur[key[i]];\\n\\t    }\\n\\t    cur.isWord = true;\\n\\t}\\n    else{\\n    \\tthis.count = this.count+val-replace;\\n    \\tfor(let i=0, len=key.length; i<len; i++){\\n\\t    \\tif(!cur[key[i]]) cur[key[i]] = new MapSum(cur.value+key[i]);\\n\\t    \\tcur[key[i]].count = cur[key[i]].count-replace+val;\\n\\t    \\tcur = cur[key[i]];\\n\\t    }\\n\\t}\\n};\\n\\nMapSum.prototype.sum = function(prefix) {\\n    let cur = this;\\n    for(let i=0, len=prefix.length; i<len; i++){\\n    \\tif(!cur[prefix[i]]) return 0;\\n    \\tcur = cur[prefix[i]];\\n    }\\n    return cur.count;\\n};\\n\\nMapSum.prototype.search = function(key) {\\n    let cur = this;\\n    for(let i=0, len=key.length; i<len; i++){\\n    \\tif(!cur[key[i]]) return false;\\n    \\tcur = cur[key[i]];\\n    }\\n    if(cur.isWord) return cur.count;\\n    else return false;\\n};\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 107535,
                "title": "java-o-length-key-insert-sum-trie-solution-with-clear-explanation",
                "content": "The solution is based on the standard Trie and its insert and search methods, with changes for the fields of TrieNode. TrieNode is defined as TrieNode {int val; int sum; boolean isAWord; TrieNode[] children;}. \\n\\nTo insert a pair {key, val}, in addition to the standard insert method, we update the sum as sum+=val of all the nodes along the insertion path. Notice that if the key existed in the Trie, we call insert again with {key, -old_val} so as to update the sum of all the nodes along the path again.\\n\\nTo get the sum, we just apply standard search method but return the sum.\\n```\\nclass MapSum {\\n\\tprivate TrieNode root;\\n\\n\\t/** Initialize your data structure here. */\\n\\tpublic MapSum() {\\n\\t\\troot = new TrieNode(0);\\n\\t}\\n\\n\\tpublic void insert(String key, int val) {\\n\\t\\tTrieNode node = root;\\n\\t\\tint ci;\\n\\t\\tfor (int i = 0; i < key.length(); i++) {\\n\\t\\t\\tci = key.charAt(i) - 'a';\\n\\t\\t\\tif (node.children[ci] == null)\\n\\t\\t\\t\\tnode.children[ci] = new TrieNode(val);\\n\\t\\t\\telse // update node.sum along the path\\n\\t\\t\\t\\tnode.children[ci].sum += val;\\n\\t\\t\\tnode = node.children[ci];\\n\\t\\t}\\n\\t\\tif (node.isAWord) { // key existed\\n\\t\\t\\tnode.isAWord = false;\\n\\t\\t\\tinsert(key, -node.val);\\n\\t\\t\\t// for updating all pre nodes'sum along the path\\n\\t\\t}\\n\\t\\tnode.val = val;\\n\\t\\tnode.isAWord = true;\\n\\t}\\n\\n\\tpublic int sum(String prefix) {\\n\\t\\tTrieNode node = root;\\n\\t\\tfor (int i = 0; i < prefix.length(); i++) {\\n\\t\\t\\tnode = node.children[prefix.charAt(i) - 'a'];\\n\\t\\t\\tif (node == null)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\treturn node.sum;\\n\\t}\\n}\\n\\nclass TrieNode {\\n\\tpublic int val;\\n\\tpublic int sum;\\n\\tpublic boolean isAWord;\\n\\tpublic TrieNode[] children;\\n\\n\\tpublic TrieNode(int val) {\\n\\t\\tsum = this.val = val;\\n\\t\\tisAWord = false;\\n\\t\\tchildren = new TrieNode[26];\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n\\tprivate TrieNode root;\\n\\n\\t/** Initialize your data structure here. */\\n\\tpublic MapSum() {\\n\\t\\troot = new TrieNode(0);\\n\\t}\\n\\n\\tpublic void insert(String key, int val) {\\n\\t\\tTrieNode node = root;\\n\\t\\tint ci;\\n\\t\\tfor (int i = 0; i < key.length(); i++) {\\n\\t\\t\\tci = key.charAt(i) - 'a';\\n\\t\\t\\tif (node.children[ci] == null)\\n\\t\\t\\t\\tnode.children[ci] = new TrieNode(val);\\n\\t\\t\\telse // update node.sum along the path\\n\\t\\t\\t\\tnode.children[ci].sum += val;\\n\\t\\t\\tnode = node.children[ci];\\n\\t\\t}\\n\\t\\tif (node.isAWord) { // key existed\\n\\t\\t\\tnode.isAWord = false;\\n\\t\\t\\tinsert(key, -node.val);\\n\\t\\t\\t// for updating all pre nodes'sum along the path\\n\\t\\t}\\n\\t\\tnode.val = val;\\n\\t\\tnode.isAWord = true;\\n\\t}\\n\\n\\tpublic int sum(String prefix) {\\n\\t\\tTrieNode node = root;\\n\\t\\tfor (int i = 0; i < prefix.length(); i++) {\\n\\t\\t\\tnode = node.children[prefix.charAt(i) - 'a'];\\n\\t\\t\\tif (node == null)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\treturn node.sum;\\n\\t}\\n}\\n\\nclass TrieNode {\\n\\tpublic int val;\\n\\tpublic int sum;\\n\\tpublic boolean isAWord;\\n\\tpublic TrieNode[] children;\\n\\n\\tpublic TrieNode(int val) {\\n\\t\\tsum = this.val = val;\\n\\t\\tisAWord = false;\\n\\t\\tchildren = new TrieNode[26];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107536,
                "title": "please-add-one-more-test-case",
                "content": "I misunderstood the description but still got AC.\\nPlease add this test case:\\n[\"MapSum\", \"insert\", \"insert\", \"insert\", \"sum\"]\\n[[], [\"apple\",3], [\"ap\",4], [\"apple\",5], [\"ap\"]]\\n```\\n    Map<String, Integer> valueMap;\\n    Map<String, Integer> prefixMap;\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        valueMap = new HashMap<>();\\n        prefixMap = new HashMap<>();\\n    }\\n    public void insert(String key, int val) {\\n        StringBuilder temp = new StringBuilder();\\n        for (int i = 0; i < key.length(); i++) {\\n            temp.append(key.charAt(i));\\n            prefixMap.put(temp.toString(), valueMap.containsKey(key)? val : \\n                                   prefixMap.getOrDefault(temp.toString(), 0) + val);\\n        }\\n        valueMap.put(key, val);\\n    }  \\n    public int sum(String prefix) {\\n        return prefixMap.getOrDefault(prefix, 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    Map<String, Integer> valueMap;\\n    Map<String, Integer> prefixMap;\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        valueMap = new HashMap<>();\\n        prefixMap = new HashMap<>();\\n    }\\n    public void insert(String key, int val) {\\n        StringBuilder temp = new StringBuilder();\\n        for (int i = 0; i < key.length(); i++) {\\n            temp.append(key.charAt(i));\\n            prefixMap.put(temp.toString(), valueMap.containsKey(key)? val : \\n                                   prefixMap.getOrDefault(temp.toString(), 0) + val);\\n        }\\n        valueMap.put(key, val);\\n    }  \\n    public int sum(String prefix) {\\n        return prefixMap.getOrDefault(prefix, 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570883,
                "title": "java-simple-trie-solution-100",
                "content": "```java\\nclass MapSum {\\n    private final TrieNode root;\\n\\n    public MapSum() {\\n        this.root = new TrieNode(0);\\n    }\\n    \\n    public void insert(String key, int val) {\\n        TrieNode node = this.root;\\n\\n        for(int i = 0; i < key.length(); ++i) {\\n            final int index = key.charAt(i) - \\'a\\';\\n\\n            if(node.children(index) == null)\\n                node.children(index, new TrieNode(0));\\n\\n            node = node.children(index);\\n        }\\n        \\n        node.value(val);\\n    }\\n    \\n    public int sum(final String prefix) {\\n        return sumHelper(prefix, 0, this.root);\\n    }\\n\\n    private int sumHelper(String prefix, int i, TrieNode root) {\\n        if(root == null)\\n            return 0;\\n\\n        if(i == prefix.length()) {\\n            int sum = 0;\\n\\n            for(int j = 0; j < 26; ++j) {\\n                TrieNode node = root.children(j);\\n\\n                if(node != null)\\n                    sum += sumHelper(prefix, i, node) + node.value();\\n            }\\n\\n            return sum;\\n        }\\n\\n        final int index = prefix.charAt(i) - \\'a\\';\\n\\n        if(root.children(index) != null && i == prefix.length() - 1)\\n            return sumHelper(prefix, i + 1, root.children(index)) + root.children(index).value();\\n\\n        return sumHelper(prefix, i + 1, root.children(index));\\n    }\\n\\n    private final class TrieNode {\\n        private final TrieNode[] children;\\n        private int value;\\n\\n        public TrieNode(final int value) {\\n            this.value = value;\\n            this.children = new TrieNode[26];\\n        }\\n\\n        public void value(final int value) {\\n            this.value = value;\\n        }\\n\\n        public int value() {\\n            return this.value;\\n        }\\n\\n        public void children(final int index, final TrieNode node) {\\n            this.children[index] = node;\\n        }\\n\\n        public TrieNode children(final int index) {            \\n            return this.children[index];\\n        }\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass MapSum {\\n    private final TrieNode root;\\n\\n    public MapSum() {\\n        this.root = new TrieNode(0);\\n    }\\n    \\n    public void insert(String key, int val) {\\n        TrieNode node = this.root;\\n\\n        for(int i = 0; i < key.length(); ++i) {\\n            final int index = key.charAt(i) - \\'a\\';\\n\\n            if(node.children(index) == null)\\n                node.children(index, new TrieNode(0));\\n\\n            node = node.children(index);\\n        }\\n        \\n        node.value(val);\\n    }\\n    \\n    public int sum(final String prefix) {\\n        return sumHelper(prefix, 0, this.root);\\n    }\\n\\n    private int sumHelper(String prefix, int i, TrieNode root) {\\n        if(root == null)\\n            return 0;\\n\\n        if(i == prefix.length()) {\\n            int sum = 0;\\n\\n            for(int j = 0; j < 26; ++j) {\\n                TrieNode node = root.children(j);\\n\\n                if(node != null)\\n                    sum += sumHelper(prefix, i, node) + node.value();\\n            }\\n\\n            return sum;\\n        }\\n\\n        final int index = prefix.charAt(i) - \\'a\\';\\n\\n        if(root.children(index) != null && i == prefix.length() - 1)\\n            return sumHelper(prefix, i + 1, root.children(index)) + root.children(index).value();\\n\\n        return sumHelper(prefix, i + 1, root.children(index));\\n    }\\n\\n    private final class TrieNode {\\n        private final TrieNode[] children;\\n        private int value;\\n\\n        public TrieNode(final int value) {\\n            this.value = value;\\n            this.children = new TrieNode[26];\\n        }\\n\\n        public void value(final int value) {\\n            this.value = value;\\n        }\\n\\n        public int value() {\\n            return this.value;\\n        }\\n\\n        public void children(final int index, final TrieNode node) {\\n            this.children[index] = node;\\n        }\\n\\n        public TrieNode children(final int index) {            \\n            return this.children[index];\\n        }\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348054,
                "title": "easy-fully-explained-constant-time-c-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n    - insert() function: The time complexity of inserting a key-value pair into an unordered map is generally O(1), since it involves simply computing the hash of the key and inserting the pair into the corresponding bucket. Therefore, the time complexity of insert() function is O(1).\\n    - sum() function: The sum() function needs to iterate through all the key-value pairs in the unordered_map and check whether each key starts with the given prefix. Since each key in the map has a maximum length of 50, the time complexity of checking whether a key starts with a given prefix is O(prefix length). Therefore, the time complexity of sum() function is O(N * prefix length), where N is the number of key-value pairs in the unordered_map.\\n- Space complexity:\\n    - MapSum class: The space complexity of the MapSum class is O(1), since it doesn\\'t store any additional information beyond the unordered_map itself.\\n    - insert() function: The space complexity of inserting a key-value pair into an unordered map is generally O(1), since it involves simply inserting the pair into a new node in the map.\\n    - sum() function: The space complexity of sum() function is O(1), since it doesn\\'t allocate any additional memory beyond the sum variable.\\n\\nOverall, the time complexity of the MapSum class is O(N * prefix length), and the space complexity is O(1) + O(N) = O(N), where N is the number of key-value pairs in the unordered_map.\\n\\n# Code\\n```\\nclass MapSum {\\n    private:\\n    unordered_map<string,int> umap; // an unordered_map to store key-value pairs\\n    \\npublic:\\n    MapSum() {\\n    }\\n    \\n    // insert a key-value pair into the unordered_map\\n    void insert(string key, int val) {\\n        umap[key] = val;\\n    }\\n    \\n    // compute the sum of all the values whose keys start with a given prefix\\n    int sum(string prefix) {\\n        int sum = 0;\\n        for(auto [key,value] : umap){ // iterate through all key-value pairs in the unordered_map\\n            if(key.substr(0,prefix.size()) == prefix){ // check if the key starts with the given prefix\\n                sum += value; // if yes, add the value to the sum\\n            }\\n        }\\n        return sum; // return the final sum\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Design",
                    "Trie"
                ],
                "code": "```\\nclass MapSum {\\n    private:\\n    unordered_map<string,int> umap; // an unordered_map to store key-value pairs\\n    \\npublic:\\n    MapSum() {\\n    }\\n    \\n    // insert a key-value pair into the unordered_map\\n    void insert(string key, int val) {\\n        umap[key] = val;\\n    }\\n    \\n    // compute the sum of all the values whose keys start with a given prefix\\n    int sum(string prefix) {\\n        int sum = 0;\\n        for(auto [key,value] : umap){ // iterate through all key-value pairs in the unordered_map\\n            if(key.substr(0,prefix.size()) == prefix){ // check if the key starts with the given prefix\\n                sum += value; // if yes, add the value to the sum\\n            }\\n        }\\n        return sum; // return the final sum\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241149,
                "title": "trie-beats-100",
                "content": "```\\nclass MapSum {\\n    \\n    TrieNode trie;\\n    int sum = 0;\\n    public MapSum() {\\n        trie = new TrieNode();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        TrieNode node = trie;\\n        for(char ch : key.toCharArray()){\\n            \\n            if(node.childs[ch - \\'a\\'] == null){\\n                node.childs[ch - \\'a\\'] = new TrieNode();\\n            }\\n            \\n            node = node.childs[ch - \\'a\\'];\\n            \\n        }\\n        \\n        node.isEnd = true;\\n        node.val = val;\\n    }\\n    \\n    public int sum(String prefix) {\\n        sum = 0;\\n        boolean isWordAvailableWithPrefix = true;\\n        TrieNode node = trie;\\n        for(char ch : prefix.toCharArray()){\\n             if(node.childs[ch - \\'a\\'] == null){\\n                isWordAvailableWithPrefix = false;\\n                 break;\\n            }\\n            \\n            node = node.childs[ch - \\'a\\'];\\n        }\\n        \\n        if(isWordAvailableWithPrefix){\\n            \\n            sum += node.val;\\n            getSum(node);\\n           \\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    public void getSum(TrieNode node){\\n        if(node == null){\\n            return;\\n        }\\n        for(int i = 0 ; i < 26 ; i++){\\n            TrieNode child = node.childs[i];\\n            if(child!=null && child.isEnd){\\n                sum+=child.val;\\n                //System.out.println(sum);\\n            }\\n            getSum(child);\\n        }\\n        \\n    }\\n}\\n\\nclass TrieNode{\\n    TrieNode[] childs;\\n    boolean isEnd = false;\\n    int val = 0;\\n    \\n    public TrieNode(){\\n        childs = new TrieNode[26];\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass MapSum {\\n    \\n    TrieNode trie;\\n    int sum = 0;\\n    public MapSum() {\\n        trie = new TrieNode();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        TrieNode node = trie;\\n        for(char ch : key.toCharArray()){\\n            \\n            if(node.childs[ch - \\'a\\'] == null){\\n                node.childs[ch - \\'a\\'] = new TrieNode();\\n            }\\n            \\n            node = node.childs[ch - \\'a\\'];\\n            \\n        }\\n        \\n        node.isEnd = true;\\n        node.val = val;\\n    }\\n    \\n    public int sum(String prefix) {\\n        sum = 0;\\n        boolean isWordAvailableWithPrefix = true;\\n        TrieNode node = trie;\\n        for(char ch : prefix.toCharArray()){\\n             if(node.childs[ch - \\'a\\'] == null){\\n                isWordAvailableWithPrefix = false;\\n                 break;\\n            }\\n            \\n            node = node.childs[ch - \\'a\\'];\\n        }\\n        \\n        if(isWordAvailableWithPrefix){\\n            \\n            sum += node.val;\\n            getSum(node);\\n           \\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    public void getSum(TrieNode node){\\n        if(node == null){\\n            return;\\n        }\\n        for(int i = 0 ; i < 26 ; i++){\\n            TrieNode child = node.childs[i];\\n            if(child!=null && child.isEnd){\\n                sum+=child.val;\\n                //System.out.println(sum);\\n            }\\n            getSum(child);\\n        }\\n        \\n    }\\n}\\n\\nclass TrieNode{\\n    TrieNode[] childs;\\n    boolean isEnd = false;\\n    int val = 0;\\n    \\n    public TrieNode(){\\n        childs = new TrieNode[26];\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127049,
                "title": "java-beats-100-simple-solution-via-2-maps",
                "content": "This is my simple java solution via 2 map usage:\\n- first map for values storing\\n- second map for the storing of caclculated sum of each prefix\\n\\n![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-02-01 \\u0432 14.38.37.png](https://assets.leetcode.com/users/images/23ae0c66-0afd-4466-82c5-ed30e3f52087_1675255242.9825003.png)\\n\\n\\n# Code\\n```\\nclass MapSum {\\n\\n    private final Map<String, Integer> values = new HashMap<>();\\n\\n    private final Map<String, Integer> valuesSumsForPrefixes = new HashMap<>();\\n\\n    public MapSum() {}\\n    \\n    public void insert(String key, int val) {\\n        // remove and get stored value\\n        Integer storedValue = this.values.remove(key);\\n        this.values.put(key, val);\\n        // calc sum for each key prefix sum = sum + (val - storedValue)\\n        // if storedValue was not exist, then sum = sum + val\\n        this.calcPrefixesSum(key, storedValue != null ? val - storedValue : val);\\n    }\\n\\n    private void calcPrefixesSum(String key, int val) {\\n        for (int prefixLength = 1; prefixLength <= key.length(); prefixLength++) {\\n            String prefix = key.substring(0, prefixLength);\\n            int currentSum = this.valuesSumsForPrefixes.getOrDefault(prefix, 0);\\n            this.valuesSumsForPrefixes.put(prefix, currentSum + val);\\n        }\\n    }\\n    \\n    public int sum(String prefix) {\\n        return this.valuesSumsForPrefixes.getOrDefault(prefix, 0);\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MapSum {\\n\\n    private final Map<String, Integer> values = new HashMap<>();\\n\\n    private final Map<String, Integer> valuesSumsForPrefixes = new HashMap<>();\\n\\n    public MapSum() {}\\n    \\n    public void insert(String key, int val) {\\n        // remove and get stored value\\n        Integer storedValue = this.values.remove(key);\\n        this.values.put(key, val);\\n        // calc sum for each key prefix sum = sum + (val - storedValue)\\n        // if storedValue was not exist, then sum = sum + val\\n        this.calcPrefixesSum(key, storedValue != null ? val - storedValue : val);\\n    }\\n\\n    private void calcPrefixesSum(String key, int val) {\\n        for (int prefixLength = 1; prefixLength <= key.length(); prefixLength++) {\\n            String prefix = key.substring(0, prefixLength);\\n            int currentSum = this.valuesSumsForPrefixes.getOrDefault(prefix, 0);\\n            this.valuesSumsForPrefixes.put(prefix, currentSum + val);\\n        }\\n    }\\n    \\n    public int sum(String prefix) {\\n        return this.valuesSumsForPrefixes.getOrDefault(prefix, 0);\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104608,
                "title": "java-trie-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n``` \\nclass TrieNode {\\n    TrieNode[] children; // children array\\n    int currVal; // value of current string\\n    int prefixVal; // values of all strings with current string as prefix\\n    boolean exists; // check if already exist to update \\n}\\n\\n- while inserting string we will first check if it already exist\\n- If it is then we will subtract previous value of that string \\n  and add new to each prefix.\\n- If it\\'s not then we will value to all prefixes and mark cuurent string at end as exist\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MapSum {\\n    public class TrieNode {\\n        TrieNode[] children;\\n        int currVal;\\n        int prefixVal;\\n        boolean exists;\\n\\n        TrieNode() {\\n            this.children = new TrieNode[26];\\n            this.exists = false;\\n        }\\n    }\\n\\n    TrieNode root;\\n    \\n    public MapSum() {\\n        root = new TrieNode();\\n    }\\n\\n    public void insert(String key, int val) {\\n        TrieNode curr = root;\\n        for (int i = 0; i < key.length(); i++) {\\n            int curr_ch = key.charAt(i) - \\'a\\';\\n            if(curr.children[curr_ch] == null)\\n                curr.children[curr_ch] = new TrieNode();\\n            curr = curr.children[curr_ch];\\n        }\\n        \\n        if(curr.exists) {\\n            int prev = curr.currVal;\\n            curr = root;\\n            for (int i = 0; i < key.length(); i++) {\\n                int curr_ch = key.charAt(i) - \\'a\\';\\n                curr = curr.children[curr_ch];\\n                curr.prefixVal += val - prev;\\n            }\\n            curr.currVal = val;\\n        }\\n        \\n        else {\\n            curr = root;\\n            for (int i = 0; i < key.length(); i++) {\\n                int curr_ch = key.charAt(i) - \\'a\\';\\n                curr = curr.children[curr_ch];\\n                curr.prefixVal += val;\\n            }\\n            curr.currVal = val;\\n            curr.exists = true;\\n        }\\n    }\\n\\n    public int sum(String prefix) {\\n        int sum = 0;\\n        TrieNode curr = root;\\n        for (int i = 0; i < prefix.length(); i++) {\\n            int curr_ch = prefix.charAt(i) - \\'a\\';\\n            if(curr.children[curr_ch] == null)\\n                return 0;\\n            curr = curr.children[curr_ch];\\n        }\\n        return curr == null ? 0 : curr.prefixVal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\nclass TrieNode {\\n    TrieNode[] children; // children array\\n    int currVal; // value of current string\\n    int prefixVal; // values of all strings with current string as prefix\\n    boolean exists; // check if already exist to update \\n}\\n\\n- while inserting string we will first check if it already exist\\n- If it is then we will subtract previous value of that string \\n  and add new to each prefix.\\n- If it\\'s not then we will value to all prefixes and mark cuurent string at end as exist\\n```\n```\\nclass MapSum {\\n    public class TrieNode {\\n        TrieNode[] children;\\n        int currVal;\\n        int prefixVal;\\n        boolean exists;\\n\\n        TrieNode() {\\n            this.children = new TrieNode[26];\\n            this.exists = false;\\n        }\\n    }\\n\\n    TrieNode root;\\n    \\n    public MapSum() {\\n        root = new TrieNode();\\n    }\\n\\n    public void insert(String key, int val) {\\n        TrieNode curr = root;\\n        for (int i = 0; i < key.length(); i++) {\\n            int curr_ch = key.charAt(i) - \\'a\\';\\n            if(curr.children[curr_ch] == null)\\n                curr.children[curr_ch] = new TrieNode();\\n            curr = curr.children[curr_ch];\\n        }\\n        \\n        if(curr.exists) {\\n            int prev = curr.currVal;\\n            curr = root;\\n            for (int i = 0; i < key.length(); i++) {\\n                int curr_ch = key.charAt(i) - \\'a\\';\\n                curr = curr.children[curr_ch];\\n                curr.prefixVal += val - prev;\\n            }\\n            curr.currVal = val;\\n        }\\n        \\n        else {\\n            curr = root;\\n            for (int i = 0; i < key.length(); i++) {\\n                int curr_ch = key.charAt(i) - \\'a\\';\\n                curr = curr.children[curr_ch];\\n                curr.prefixVal += val;\\n            }\\n            curr.currVal = val;\\n            curr.exists = true;\\n        }\\n    }\\n\\n    public int sum(String prefix) {\\n        int sum = 0;\\n        TrieNode curr = root;\\n        for (int i = 0; i < prefix.length(); i++) {\\n            int curr_ch = prefix.charAt(i) - \\'a\\';\\n            if(curr.children[curr_ch] == null)\\n                return 0;\\n            curr = curr.children[curr_ch];\\n        }\\n        return curr == null ? 0 : curr.prefixVal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627936,
                "title": "c-trie-hashmap",
                "content": "**If the key already existed, the original key-value pair will be overridden to the new one.**\\nTo keep track of existing key, we use an unordered map. If the key exists then we have to subtract its value from the trie nodes before adding in the new ones.\\n\\n```\\nclass MapSum {\\nprivate:\\n    struct Node{\\n        Node* arr[26];\\n        int val = 0;\\n    };\\n    Node* root;\\npublic:\\n    unordered_map<string, int> map;\\n    MapSum() {\\n        root = new Node();\\n    }\\n    \\n    void trie_remove(string key){\\n        Node* node = root;\\n        int val = map[key];\\n        for(int i = 0; i < key.size(); i++){\\n            node = node->arr[key[i] - \\'a\\'];\\n            node->val -= val;\\n        }\\n    }\\n    \\n    void insert(string key, int val) {\\n        if(map.find(key) != map.end()){\\n            trie_remove(key);\\n            map.erase(key);\\n        }\\n        Node* node = root;\\n        for(int i = 0; i < key.length(); i++){\\n            if(node->arr[key[i] - \\'a\\'] == NULL){\\n                node->arr[key[i] - \\'a\\'] = new Node();\\n            }\\n            node = node->arr[key[i] - \\'a\\'];\\n            node->val += val;\\n        }\\n        map[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        Node *node = root;\\n        int total = 0;\\n        for(int i = 0; i < prefix.length(); i++){\\n            if(node->arr[prefix[i] - \\'a\\'] == NULL) return 0;\\n            node = node->arr[prefix[i] - \\'a\\'];\\n        }\\n        total += node->val;\\n        return total;\\n    }\\n};\\n",
                "solutionTags": [
                    "Trie"
                ],
                "code": "**If the key already existed, the original key-value pair will be overridden to the new one.**\\nTo keep track of existing key, we use an unordered map. If the key exists then we have to subtract its value from the trie nodes before adding in the new ones.\\n\\n```\\nclass MapSum {\\nprivate:\\n    struct Node{\\n        Node* arr[26];\\n        int val = 0;\\n    };\\n    Node* root;\\npublic:\\n    unordered_map<string, int> map;\\n    MapSum() {\\n        root = new Node();\\n    }\\n    \\n    void trie_remove(string key){\\n        Node* node = root;\\n        int val = map[key];\\n        for(int i = 0; i < key.size(); i++){\\n            node = node->arr[key[i] - \\'a\\'];\\n            node->val -= val;\\n        }\\n    }\\n    \\n    void insert(string key, int val) {\\n        if(map.find(key) != map.end()){\\n            trie_remove(key);\\n            map.erase(key);\\n        }\\n        Node* node = root;\\n        for(int i = 0; i < key.length(); i++){\\n            if(node->arr[key[i] - \\'a\\'] == NULL){\\n                node->arr[key[i] - \\'a\\'] = new Node();\\n            }\\n            node = node->arr[key[i] - \\'a\\'];\\n            node->val += val;\\n        }\\n        map[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        Node *node = root;\\n        int total = 0;\\n        for(int i = 0; i < prefix.length(); i++){\\n            if(node->arr[prefix[i] - \\'a\\'] == NULL) return 0;\\n            node = node->arr[prefix[i] - \\'a\\'];\\n        }\\n        total += node->val;\\n        return total;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2592420,
                "title": "c-using-trie-implementation-85-faster-than-all",
                "content": "```\\nlass MapSum {\\npublic:\\n\\tmap<string,int>mp;\\n\\tMapSum() {\\n\\n\\t}\\n\\n\\tvoid insert(string key, int val) {\\n\\t\\tmp[key]=val;\\n\\t}\\n\\n\\tint sum(string prefix) {\\n\\t\\tint count=0;\\n\\t\\tfor(auto i:mp){\\n\\t\\t\\tint j;\\n\\t\\t\\tfor(j=0;j<i.first.size() && j<prefix.size();j++){\\n\\t\\t\\t\\tif(i.first[j]!=prefix[j])break;\\n\\t\\t\\t}\\n\\t\\t\\tif(j==prefix.size())count+=i.second;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};",
                "solutionTags": [],
                "code": "```\\nlass MapSum {\\npublic:\\n\\tmap<string,int>mp;\\n\\tMapSum() {\\n\\n\\t}\\n\\n\\tvoid insert(string key, int val) {\\n\\t\\tmp[key]=val;\\n\\t}\\n\\n\\tint sum(string prefix) {\\n\\t\\tint count=0;\\n\\t\\tfor(auto i:mp){\\n\\t\\t\\tint j;\\n\\t\\t\\tfor(j=0;j<i.first.size() && j<prefix.size();j++){\\n\\t\\t\\t\\tif(i.first[j]!=prefix[j])break;\\n\\t\\t\\t}\\n\\t\\t\\tif(j==prefix.size())count+=i.second;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2566394,
                "title": "very-easy-map",
                "content": "```\\nclass MapSum {\\n    unordered_map<string,int> m;\\npublic:\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        m[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int c=0;\\n        int l = prefix.length();\\n        for(auto& itr : m){\\n            string s = itr.first;\\n            if(s.substr(0,l) == prefix){\\n                c += itr.second;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MapSum {\\n    unordered_map<string,int> m;\\npublic:\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        m[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int c=0;\\n        int l = prefix.length();\\n        for(auto& itr : m){\\n            string s = itr.first;\\n            if(s.substr(0,l) == prefix){\\n                c += itr.second;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410973,
                "title": "c-simple-solution",
                "content": "class MapSum {\\n# public:\\n    unordered_map<string,int>m;\\n    MapSum() {\\n       unordered_map<string,int>m1;\\n        m=m1;\\n    }\\n    \\n    void insert(string key, int val) {\\n        if(m.find(key)==m.end()){\\n            m.insert({key,val});\\n        }else{\\n            m[key]=val;\\n        }\\n    }\\n    \\n    int sum(string prefix) {\\n       int n=prefix.size();\\n        int ans=0;\\n        for(auto it:m){\\n            string s=it.first;\\n            if(s.substr(0,n)==prefix){\\n                ans+=it.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class MapSum {\\n# public:\\n    unordered_map<string,int>m;\\n    MapSum() {\\n       unordered_map<string,int>m1;\\n        m=m1;\\n    }\\n    \\n    void insert(string key, int val) {\\n        if(m.find(key)==m.end()){\\n            m.insert({key,val});\\n        }else{\\n            m[key]=val;\\n        }\\n    }\\n    \\n    int sum(string prefix) {\\n       int n=prefix.size();\\n        int ans=0;\\n        for(auto it:m){\\n            string s=it.first;\\n            if(s.substr(0,n)==prefix){\\n                ans+=it.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2296457,
                "title": "java-easy-understanding-beats-in-terms-of-time-memory-with-given-solution",
                "content": "```\\nclass MapSum {\\n    private TrieNode root;\\n    Map<String, Integer> map;\\n    \\n    public class TrieNode{\\n        private TrieNode[] links;\\n    \\n        private int R = 26;\\n    \\n        private boolean isEnd;\\n        int val;\\n\\n        public TrieNode() {\\n            links = new TrieNode[R];\\n        }\\n        public TrieNode(int val) {\\n            links = new TrieNode[R];\\n            this.val=val;\\n        }\\n    \\n        public boolean containsKey(char ch){\\n            return links[ch-\\'a\\'] != null;\\n        }\\n    \\n        public TrieNode get(char ch){\\n            return links[ch-\\'a\\'];\\n        }\\n    \\n        public void put(char ch, TrieNode node){\\n            links[ch - \\'a\\'] = node;\\n        }\\n    \\n        public void setEnd(){\\n            isEnd=true;\\n        }\\n    \\n        public boolean isEnd(){\\n            return isEnd;\\n        }\\n    }\\n    \\n    public MapSum() {\\n        root = new TrieNode();\\n        map=new HashMap<String, Integer>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        int delta=val-map.getOrDefault(key, 0);\\n        map.put(key,val);\\n        TrieNode node = root;\\n        node.val+=delta;\\n        for(int i=0; i<key.length();i++){\\n            char currChar = key.charAt(i);\\n            if(!node.containsKey(currChar)){\\n                node.put(currChar, new TrieNode());\\n                node=node.get(key.charAt(i));\\n                node.val+=delta;\\n            } else {\\n                node = node.get(key.charAt(i));\\n                node.val=node.val+delta;\\n            }\\n        }\\n    }\\n    \\n    public int sum(String prefix) {\\n          TrieNode node = root;\\n        for(int i=0; i<prefix.length();i++){\\n            char currChar = prefix.charAt(i);\\n            node=node.get(currChar);\\n            if(node==null) return 0;\\n        }\\n        return node.val;\\n    }\\n}\\n\\nIf you like above solution please do UpVote\\n-Thank you.",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass MapSum {\\n    private TrieNode root;\\n    Map<String, Integer> map;\\n    \\n    public class TrieNode{\\n        private TrieNode[] links;\\n    \\n        private int R = 26;\\n    \\n        private boolean isEnd;\\n        int val;\\n\\n        public TrieNode() {\\n            links = new TrieNode[R];\\n        }\\n        public TrieNode(int val) {\\n            links = new TrieNode[R];\\n            this.val=val;\\n        }\\n    \\n        public boolean containsKey(char ch){\\n            return links[ch-\\'a\\'] != null;\\n        }\\n    \\n        public TrieNode get(char ch){\\n            return links[ch-\\'a\\'];\\n        }\\n    \\n        public void put(char ch, TrieNode node){\\n            links[ch - \\'a\\'] = node;\\n        }\\n    \\n        public void setEnd(){\\n            isEnd=true;\\n        }\\n    \\n        public boolean isEnd(){\\n            return isEnd;\\n        }\\n    }\\n    \\n    public MapSum() {\\n        root = new TrieNode();\\n        map=new HashMap<String, Integer>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        int delta=val-map.getOrDefault(key, 0);\\n        map.put(key,val);\\n        TrieNode node = root;\\n        node.val+=delta;\\n        for(int i=0; i<key.length();i++){\\n            char currChar = key.charAt(i);\\n            if(!node.containsKey(currChar)){\\n                node.put(currChar, new TrieNode());\\n                node=node.get(key.charAt(i));\\n                node.val+=delta;\\n            } else {\\n                node = node.get(key.charAt(i));\\n                node.val=node.val+delta;\\n            }\\n        }\\n    }\\n    \\n    public int sum(String prefix) {\\n          TrieNode node = root;\\n        for(int i=0; i<prefix.length();i++){\\n            char currChar = prefix.charAt(i);\\n            node=node.get(currChar);\\n            if(node==null) return 0;\\n        }\\n        return node.val;\\n    }\\n}\\n\\nIf you like above solution please do UpVote\\n-Thank you.",
                "codeTag": "Java"
            },
            {
                "id": 2271837,
                "title": "88-tc-and-92-sc-easy-python-solution-using-map",
                "content": "```\\nclass MapSum:\\n    def __init__(self):\\n        self.d = defaultdict(int)\\n        self.s = dict()\\n\\n    def insert(self, key: str, val: int) -> None:\\n        if(key in self.s):\\n            val, self.s[key] = val - self.s[key], val\\n        else:\\n            self.s[key] = val\\n        for i in range(1, len(key)+1):\\n            self.d[key[:i]] += val\\n        \\n    def sum(self, prefix: str) -> int:\\n        return self.d[prefix]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass MapSum:\\n    def __init__(self):\\n        self.d = defaultdict(int)\\n        self.s = dict()\\n\\n    def insert(self, key: str, val: int) -> None:\\n        if(key in self.s):\\n            val, self.s[key] = val - self.s[key], val\\n        else:\\n            self.s[key] = val\\n        for i in range(1, len(key)+1):\\n            self.d[key[:i]] += val\\n        \\n    def sum(self, prefix: str) -> int:\\n        return self.d[prefix]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271834,
                "title": "c-trie-hashmap",
                "content": "```\\nclass MapSum {\\npublic:\\n    struct Node{\\n        Node* Links[26];\\n        int sum = 0;\\n        bool fl = false;\\n        bool containsKey(char c){\\n            return Links[c-\\'a\\'] != NULL;\\n        }\\n        Node* getKey(char c){\\n            return Links[c-\\'a\\'];\\n        }\\n        void putKey(char c, Node* node){\\n            Links[c-\\'a\\'] = node;\\n        }\\n        void updateSum(int val){\\n            sum += val;\\n        }\\n        bool isEnd(){\\n            return fl;\\n        }\\n        void putEnd(){\\n            fl = true;\\n        }\\n    };\\n    \\n    class Trie{\\n    private: Node* head;\\n    public:\\n        Trie(){\\n           head = new Node(); \\n        }\\n        \\n        void insert(string s, int val){\\n            Node* cur = head;\\n            for(int i=0; i<s.size(); i++){\\n                if(!cur->containsKey(s[i])){\\n                    cur->putKey(s[i],new Node());\\n                }\\n                cur = cur->getKey(s[i]);\\n                cur->updateSum(val);\\n            }\\n            cur->putEnd();\\n        }\\n        \\n        int sum(string s){\\n            Node* cur = head;\\n            Node* temp;\\n            for(int i=0; i<s.size(); i++){\\n                if(!cur->containsKey(s[i])) return 0;\\n                cur = cur->getKey(s[i]);\\n            }\\n            int res = cur->sum;\\n            return res;\\n        }\\n    };\\n    \\n    Trie* trie;\\n    unordered_map<string,int> mp;\\n    MapSum() {\\n        trie = new Trie;\\n    }\\n    \\n    void insert(string key, int val) {\\n        int diff = val-mp[key];\\n        mp[key] = val;\\n        trie->insert(key,diff);\\n    }\\n    \\n    int sum(string prefix) {\\n        int x = trie->sum(prefix);\\n        return x;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass MapSum {\\npublic:\\n    struct Node{\\n        Node* Links[26];\\n        int sum = 0;\\n        bool fl = false;\\n        bool containsKey(char c){\\n            return Links[c-\\'a\\'] != NULL;\\n        }\\n        Node* getKey(char c){\\n            return Links[c-\\'a\\'];\\n        }\\n        void putKey(char c, Node* node){\\n            Links[c-\\'a\\'] = node;\\n        }\\n        void updateSum(int val){\\n            sum += val;\\n        }\\n        bool isEnd(){\\n            return fl;\\n        }\\n        void putEnd(){\\n            fl = true;\\n        }\\n    };\\n    \\n    class Trie{\\n    private: Node* head;\\n    public:\\n        Trie(){\\n           head = new Node(); \\n        }\\n        \\n        void insert(string s, int val){\\n            Node* cur = head;\\n            for(int i=0; i<s.size(); i++){\\n                if(!cur->containsKey(s[i])){\\n                    cur->putKey(s[i],new Node());\\n                }\\n                cur = cur->getKey(s[i]);\\n                cur->updateSum(val);\\n            }\\n            cur->putEnd();\\n        }\\n        \\n        int sum(string s){\\n            Node* cur = head;\\n            Node* temp;\\n            for(int i=0; i<s.size(); i++){\\n                if(!cur->containsKey(s[i])) return 0;\\n                cur = cur->getKey(s[i]);\\n            }\\n            int res = cur->sum;\\n            return res;\\n        }\\n    };\\n    \\n    Trie* trie;\\n    unordered_map<string,int> mp;\\n    MapSum() {\\n        trie = new Trie;\\n    }\\n    \\n    void insert(string key, int val) {\\n        int diff = val-mp[key];\\n        mp[key] = val;\\n        trie->insert(key,diff);\\n    }\\n    \\n    int sum(string prefix) {\\n        int x = trie->sum(prefix);\\n        return x;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132074,
                "title": "cpp-easy-maps",
                "content": "```\\nclass MapSum {\\npublic:\\n    map<string,int> mp;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        mp[key]=val;\\n    }\\n    \\n    int sum(string p) {\\n        int sum=0;\\n        for(auto i:mp){\\n             int k=0;\\n             if(i.first.length()<p.length()) k=1;\\n             else{\\n                 for(int j=0;j<p.length();j++){\\n                     if(p[j]!=i.first[j]){\\n                         k=1;\\n                         break;\\n                     }\\n                 }\\n             }\\n            if(k==0) sum+=i.second;\\n        }\\n        return sum;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MapSum {\\npublic:\\n    map<string,int> mp;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        mp[key]=val;\\n    }\\n    \\n    int sum(string p) {\\n        int sum=0;\\n        for(auto i:mp){\\n             int k=0;\\n             if(i.first.length()<p.length()) k=1;\\n             else{\\n                 for(int j=0;j<p.length();j++){\\n                     if(p[j]!=i.first[j]){\\n                         k=1;\\n                         break;\\n                     }\\n                 }\\n             }\\n            if(k==0) sum+=i.second;\\n        }\\n        return sum;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963313,
                "title": "basic-hashing-c-o-n-solution",
                "content": "```\\n****\\n```class MapSum {\\npublic:\\n     map<string,int>m;\\n    MapSum() {\\n          //keep it emnpty in this case\\n    }\\n    \\n    void insert(string key, int val) {\\n      m[key]=val;\\n    }\\n    bool prefixs(string word,string ans)\\n    {\\n        int i=0;\\n        int j=0;\\n        int c=0;\\n        while(i<word.size() && j<ans.size())\\n        {\\n            if(word[i]!=ans[j])\\n            {\\n                break;\\n            }\\n            c++;\\n            i++;\\n            j++;\\n        }\\n        if(c==ans.size())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int sum(string prefix) {\\n        int ans=0;\\n        for(auto x:m)\\n        {\\n            if(prefixs(x.first,prefix))\\n            {\\n                ans+=x.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n****\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1927244,
                "title": "java-clean-trie",
                "content": "```\\n private final TrieNode trieNode;\\n\\n    public MapSum() {\\n        trieNode = new TrieNode();\\n    }\\n\\n    public void insert(String key, int val) {\\n        TrieNode current = trieNode;\\n        for (char c : key.toCharArray()) {\\n            current = current.children.computeIfAbsent(c, node -> new TrieNode());\\n        }\\n        current.val = val;\\n    }\\n\\n    public int sum(String prefix) {\\n        TrieNode current = trieNode;\\n        int sum = 0;\\n        for (char c : prefix.toCharArray()) {\\n            current = current.children.get(c);\\n            if (current == null)\\n                return sum;\\n        }\\n        return dfs(current);\\n    }\\n\\n    private int dfs(TrieNode current) {\\n        if (current == null)\\n            return 0;\\n        \\n        int sum = current.val;\\n        for (TrieNode child : current.children.values()) {\\n            sum += dfs(child);\\n        }\\n\\n        return sum;\\n    }\\n\\n    public static class TrieNode {\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        int val;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n private final TrieNode trieNode;\\n\\n    public MapSum() {\\n        trieNode = new TrieNode();\\n    }\\n\\n    public void insert(String key, int val) {\\n        TrieNode current = trieNode;\\n        for (char c : key.toCharArray()) {\\n            current = current.children.computeIfAbsent(c, node -> new TrieNode());\\n        }\\n        current.val = val;\\n    }\\n\\n    public int sum(String prefix) {\\n        TrieNode current = trieNode;\\n        int sum = 0;\\n        for (char c : prefix.toCharArray()) {\\n            current = current.children.get(c);\\n            if (current == null)\\n                return sum;\\n        }\\n        return dfs(current);\\n    }\\n\\n    private int dfs(TrieNode current) {\\n        if (current == null)\\n            return 0;\\n        \\n        int sum = current.val;\\n        for (TrieNode child : current.children.values()) {\\n            sum += dfs(child);\\n        }\\n\\n        return sum;\\n    }\\n\\n    public static class TrieNode {\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        int val;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910612,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(1) for insert and O(N * length of string) for sum***\\n* ***Space Complexity : O(N)***\\n\\n```\\n    unordered_map<string, int> mp;\\n    \\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        \\n        mp[key] = val;\\n    }\\n    \\n    int sum(string str2) {\\n        \\n        int sum = 0;\\n        \\n        for(auto x : mp)\\n        {\\n            string str1 = x.first;\\n            \\n            int i = 0;\\n            \\n            int j = 0;\\n            \\n            while(j < str2.size())\\n            {\\n                if(str1[i] == str2[j])\\n                {\\n                    i++;\\n                    \\n                    j++;\\n                }\\n                \\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            \\n            if(j == str2.size())\\n            {\\n                sum += x.second;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    unordered_map<string, int> mp;\\n    \\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        \\n        mp[key] = val;\\n    }\\n    \\n    int sum(string str2) {\\n        \\n        int sum = 0;\\n        \\n        for(auto x : mp)\\n        {\\n            string str1 = x.first;\\n            \\n            int i = 0;\\n            \\n            int j = 0;\\n            \\n            while(j < str2.size())\\n            {\\n                if(str1[i] == str2[j])\\n                {\\n                    i++;\\n                    \\n                    j++;\\n                }\\n                \\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            \\n            if(j == str2.size())\\n            {\\n                sum += x.second;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1874070,
                "title": "easy-trie-cpp-solution",
                "content": "Approach\\n1.Create a trie node which has links of size 26 and a value which holds the sum of all prefixes that were inserted in the map\\n2.While inserting the key value pair in the trie check if the map already has the key if yes then update the value to be inserted and then insert the key value pair into the map\\n3.For sum function we can just return the value stored at the ending letter of the prefix\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nstruct Node{\\n    Node* links[26];\\n    int value = 0;\\n    bool containsKey(char ch){\\n        return links[ch-\\'a\\']!=NULL;\\n    }\\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    void put(char ch,Node* node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    void assignValue(int val){\\n        value+= val;\\n    }\\n    int getVal(){\\n        return value;\\n    }\\n};\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n    void insert(string word,int val){\\n        Node* temp = root;\\n        for(int i=0;i<word.size();i++){\\n            if(!temp->containsKey(word[i])){\\n                temp->put(word[i],new Node());\\n            }\\n            temp->assignValue(val);\\n            temp = temp->get(word[i]);\\n        }\\n        temp->assignValue(val);\\n    }\\n    int storedValue(string prefix){\\n        Node* temp = root;\\n        for(int i=0;i<prefix.size();i++){\\n            if(!temp->get(prefix[i]))\\n                return 0;\\n            temp = temp->get(prefix[i]);\\n        }\\n        return temp->getVal();\\n    }\\n};\\nclass MapSum {\\nprivate:\\n    Trie* trie;\\n    map<string,int> mp;\\npublic:\\n    MapSum() {\\n        trie = new Trie();\\n    }\\n    \\n    void insert(string key, int val) {\\n        if(mp.find(key)!=mp.end()){\\n            //If the map already has value lets say {\"apple\":1} and current key value pair from the params is {\"apple\":4}\\n            //then we should update the value of \"apple\" to 4, by writing the below statement we are storing (4-1 = 3)\\n            //in the variable map hence we should add 3 to the previous existense of \"apple\" to make it 4\\n            val = val - mp[key]; \\n            //After updating the val we should make sure we insert the val(from the params) into the map\\n            //Hence we write the below statement\\n            mp[key] = val+mp[key];\\n        }\\n        else\\n            mp[key] = val;\\n        trie->insert(key,val);\\n    }\\n    \\n    int sum(string prefix) {\\n        return trie->storedValue(prefix);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nstruct Node{\\n    Node* links[26];\\n    int value = 0;\\n    bool containsKey(char ch){\\n        return links[ch-\\'a\\']!=NULL;\\n    }\\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    void put(char ch,Node* node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    void assignValue(int val){\\n        value+= val;\\n    }\\n    int getVal(){\\n        return value;\\n    }\\n};\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n    void insert(string word,int val){\\n        Node* temp = root;\\n        for(int i=0;i<word.size();i++){\\n            if(!temp->containsKey(word[i])){\\n                temp->put(word[i],new Node());\\n            }\\n            temp->assignValue(val);\\n            temp = temp->get(word[i]);\\n        }\\n        temp->assignValue(val);\\n    }\\n    int storedValue(string prefix){\\n        Node* temp = root;\\n        for(int i=0;i<prefix.size();i++){\\n            if(!temp->get(prefix[i]))\\n                return 0;\\n            temp = temp->get(prefix[i]);\\n        }\\n        return temp->getVal();\\n    }\\n};\\nclass MapSum {\\nprivate:\\n    Trie* trie;\\n    map<string,int> mp;\\npublic:\\n    MapSum() {\\n        trie = new Trie();\\n    }\\n    \\n    void insert(string key, int val) {\\n        if(mp.find(key)!=mp.end()){\\n            //If the map already has value lets say {\"apple\":1} and current key value pair from the params is {\"apple\":4}\\n            //then we should update the value of \"apple\" to 4, by writing the below statement we are storing (4-1 = 3)\\n            //in the variable map hence we should add 3 to the previous existense of \"apple\" to make it 4\\n            val = val - mp[key]; \\n            //After updating the val we should make sure we insert the val(from the params) into the map\\n            //Hence we write the below statement\\n            mp[key] = val+mp[key];\\n        }\\n        else\\n            mp[key] = val;\\n        trie->insert(key,val);\\n    }\\n    \\n    int sum(string prefix) {\\n        return trie->storedValue(prefix);\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1866021,
                "title": "simple-solution-in-java-concise-and-elegant-using-trie",
                "content": "```\\nclass MapSum {\\n    private Trie tr;\\n    \\n    public MapSum() {\\n        this.tr = new Trie();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        tr.insert(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        return tr.findSum(prefix);\\n    }\\n    \\n    private class Trie{\\n        private TrieNode parent;\\n        \\n        public Trie(){\\n            this.parent = new TrieNode();\\n        }\\n        \\n        public void insert(String s, int val){\\n            \\n            TrieNode temp = parent;\\n            for(int i=0; i<s.length(); i++){\\n                int d = s.charAt(i)-\\'a\\';\\n                \\n                if(temp.child[d] == null) temp.child[d] = new TrieNode();\\n                temp = temp.child[d];\\n            }\\n            \\n            temp.val = val;\\n            return;\\n        }\\n        \\n        public int findSum(String s){\\n            // First traverse the key in the string \\n            TrieNode temp = parent;\\n            for(int i=0; i<s.length(); i++){\\n                int d = s.charAt(i) - \\'a\\';\\n                if(temp.child[d] == null) return 0; // Key does not exist \\n                temp = temp.child[d];\\n            }\\n            \\n            return findSumWithPrefix(temp);\\n        }\\n        \\n        private int findSumWithPrefix(TrieNode tr){\\n            if(tr == null) return 0;\\n            int ans = tr.val;\\n            for(int i=0; i<26; i++){\\n                ans +=  findSumWithPrefix(tr.child[i]);\\n            }\\n            \\n            return ans;\\n        }\\n        \\n        \\n        private class TrieNode{\\n            public TrieNode[] child;\\n            public int val;\\n                \\n            public TrieNode(){\\n                this.child = new TrieNode[26];\\n                this.val = 0;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n    private Trie tr;\\n    \\n    public MapSum() {\\n        this.tr = new Trie();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        tr.insert(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        return tr.findSum(prefix);\\n    }\\n    \\n    private class Trie{\\n        private TrieNode parent;\\n        \\n        public Trie(){\\n            this.parent = new TrieNode();\\n        }\\n        \\n        public void insert(String s, int val){\\n            \\n            TrieNode temp = parent;\\n            for(int i=0; i<s.length(); i++){\\n                int d = s.charAt(i)-\\'a\\';\\n                \\n                if(temp.child[d] == null) temp.child[d] = new TrieNode();\\n                temp = temp.child[d];\\n            }\\n            \\n            temp.val = val;\\n            return;\\n        }\\n        \\n        public int findSum(String s){\\n            // First traverse the key in the string \\n            TrieNode temp = parent;\\n            for(int i=0; i<s.length(); i++){\\n                int d = s.charAt(i) - \\'a\\';\\n                if(temp.child[d] == null) return 0; // Key does not exist \\n                temp = temp.child[d];\\n            }\\n            \\n            return findSumWithPrefix(temp);\\n        }\\n        \\n        private int findSumWithPrefix(TrieNode tr){\\n            if(tr == null) return 0;\\n            int ans = tr.val;\\n            for(int i=0; i<26; i++){\\n                ans +=  findSumWithPrefix(tr.child[i]);\\n            }\\n            \\n            return ans;\\n        }\\n        \\n        \\n        private class TrieNode{\\n            public TrieNode[] child;\\n            public int val;\\n                \\n            public TrieNode(){\\n                this.child = new TrieNode[26];\\n                this.val = 0;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861982,
                "title": "python-simple-trie-solution",
                "content": "```\\nclass Node(object):\\n    def __init__(self, key, data=None, val = None):\\n        self.key = key\\n        self.data = data\\n        self.children = {}\\n        self.val = val\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.head = Node(None)\\n        \\n    def insert(self, string: str, val: int) -> None:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char not in current_node.children:\\n                current_node.children[char] = Node(char)\\n            current_node = current_node.children[char]\\n        current_node.data = string\\n        current_node.val = val\\n        \\n    def search(self, string: str) -> bool:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char in current_node.children:\\n                current_node = current_node.children[char]\\n            else:\\n                return False\\n\\n        if current_node.data:\\n            return True\\n        else:\\n            return False\\n\\n    def startsWith(self, prefix: str) -> bool:\\n        current_node = self.head\\n        words = []\\n        res = 0 \\n        for p in prefix:\\n            if p in current_node.children:\\n                current_node = current_node.children[p]\\n            else:\\n                return 0\\n\\n        current_node = [current_node]\\n        next_node = []\\n        while True:\\n            for node in current_node:\\n                if node.data:\\n                  \\n                    res += node.val\\n                next_node.extend(list(node.children.values()))\\n            if len(next_node) != 0:\\n                current_node = next_node\\n                next_node = []\\n            else:\\n                break\\n\\n        return res\\n\\n\\nclass MapSum:\\n\\n    def __init__(self):\\n        self.trie = Trie()\\n\\n    def insert(self, key: str, val: int) -> None:\\n        self.trie.insert(key, val)\\n\\n    def sum(self, prefix: str) -> int:\\n        return self.trie.startsWith(prefix)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass Node(object):\\n    def __init__(self, key, data=None, val = None):\\n        self.key = key\\n        self.data = data\\n        self.children = {}\\n        self.val = val\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.head = Node(None)\\n        \\n    def insert(self, string: str, val: int) -> None:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char not in current_node.children:\\n                current_node.children[char] = Node(char)\\n            current_node = current_node.children[char]\\n        current_node.data = string\\n        current_node.val = val\\n        \\n    def search(self, string: str) -> bool:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char in current_node.children:\\n                current_node = current_node.children[char]\\n            else:\\n                return False\\n\\n        if current_node.data:\\n            return True\\n        else:\\n            return False\\n\\n    def startsWith(self, prefix: str) -> bool:\\n        current_node = self.head\\n        words = []\\n        res = 0 \\n        for p in prefix:\\n            if p in current_node.children:\\n                current_node = current_node.children[p]\\n            else:\\n                return 0\\n\\n        current_node = [current_node]\\n        next_node = []\\n        while True:\\n            for node in current_node:\\n                if node.data:\\n                  \\n                    res += node.val\\n                next_node.extend(list(node.children.values()))\\n            if len(next_node) != 0:\\n                current_node = next_node\\n                next_node = []\\n            else:\\n                break\\n\\n        return res\\n\\n\\nclass MapSum:\\n\\n    def __init__(self):\\n        self.trie = Trie()\\n\\n    def insert(self, key: str, val: int) -> None:\\n        self.trie.insert(key, val)\\n\\n    def sum(self, prefix: str) -> int:\\n        return self.trie.startsWith(prefix)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799553,
                "title": "python-super-clean-solution-without-hashmap",
                "content": "```\\nfrom collections import defaultdict\\nclass MapSum:\\n\\n    def __init__(self):\\n        self.trie = Trie()\\n\\n    def insert(self, key: str, val: int) -> None:\\n        self.trie.insert(key,val)\\n\\n    def sum(self, prefix: str) -> int:\\n        return self.trie.sum(prefix)\\n\\n\\n# Your MapSum object will be instantiated and called as such:\\n# obj = MapSum()\\n# obj.insert(key,val)\\n# param_2 = obj.sum(prefix)\\n\\nclass TrieNode:\\n    # Initialize your data structure here.\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.is_word = False\\n        self.sum = 0\\n        self.val = 0\\n\\nclass Trie:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word, val):\\n        current = self.root\\n        for letter in word:\\n            current = current.children[letter]\\n            current.sum+=val\\n            \\n        if current.is_word:\\n            val_to_minus = current.val\\n        \\n            current = self.root\\n            for letter in word:\\n                current = current.children[letter]\\n                current.sum-=val_to_minus\\n        current.is_word = True\\n        current.val = val\\n\\n    def sum(self, prefix):\\n        node = self.root\\n        for letter in prefix:\\n            node = node.children.get(letter)\\n            if not node:\\n                return 0\\n        return node.sum\\n",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass MapSum:\\n\\n    def __init__(self):\\n        self.trie = Trie()\\n\\n    def insert(self, key: str, val: int) -> None:\\n        self.trie.insert(key,val)\\n\\n    def sum(self, prefix: str) -> int:\\n        return self.trie.sum(prefix)\\n\\n\\n# Your MapSum object will be instantiated and called as such:\\n# obj = MapSum()\\n# obj.insert(key,val)\\n# param_2 = obj.sum(prefix)\\n\\nclass TrieNode:\\n    # Initialize your data structure here.\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.is_word = False\\n        self.sum = 0\\n        self.val = 0\\n\\nclass Trie:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word, val):\\n        current = self.root\\n        for letter in word:\\n            current = current.children[letter]\\n            current.sum+=val\\n            \\n        if current.is_word:\\n            val_to_minus = current.val\\n        \\n            current = self.root\\n            for letter in word:\\n                current = current.children[letter]\\n                current.sum-=val_to_minus\\n        current.is_word = True\\n        current.val = val\\n\\n    def sum(self, prefix):\\n        node = self.root\\n        for letter in prefix:\\n            node = node.children.get(letter)\\n            if not node:\\n                return 0\\n        return node.sum\\n",
                "codeTag": "Java"
            },
            {
                "id": 1730554,
                "title": "python-clean-code-with-trie-hashmap",
                "content": "```\\nfrom collections import defaultdict\\nfrom dataclasses import dataclass, field\\nfrom typing import Dict\\n\\n\\n@dataclass\\nclass Node:\\n    c: str\\n    cnt: int = 0\\n    child: Dict[str, \\'Node\\'] = field(init=False, default_factory=dict)\\n\\n\\nclass MapSum:\\n    def __init__(self):\\n        self.root = Node(\\'ROOT\\')\\n        self.present_words = defaultdict(int)\\n\\n    def insert(self, key: str, val: int) -> None:\\n        val, self.present_words[key] = val - self.present_words[key], val\\n\\n        rt = self.root\\n\\n        for e in key:\\n            if e not in rt.child:\\n                rt.child[e] = Node(e)\\n\\n            node = rt.child[e]\\n            node.cnt += val\\n\\n            rt = node\\n\\n    def sum(self, prefix: str) -> int:\\n        rt = self.root\\n\\n        for e in prefix:\\n            if e not in rt.child:\\n                return 0\\n\\n            rt = rt.child[e]\\n\\n        return rt.cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom dataclasses import dataclass, field\\nfrom typing import Dict\\n\\n\\n@dataclass\\nclass Node:\\n    c: str\\n    cnt: int = 0\\n    child: Dict[str, \\'Node\\'] = field(init=False, default_factory=dict)\\n\\n\\nclass MapSum:\\n    def __init__(self):\\n        self.root = Node(\\'ROOT\\')\\n        self.present_words = defaultdict(int)\\n\\n    def insert(self, key: str, val: int) -> None:\\n        val, self.present_words[key] = val - self.present_words[key], val\\n\\n        rt = self.root\\n\\n        for e in key:\\n            if e not in rt.child:\\n                rt.child[e] = Node(e)\\n\\n            node = rt.child[e]\\n            node.cnt += val\\n\\n            rt = node\\n\\n    def sum(self, prefix: str) -> int:\\n        rt = self.root\\n\\n        for e in prefix:\\n            if e not in rt.child:\\n                return 0\\n\\n            rt = rt.child[e]\\n\\n        return rt.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711993,
                "title": "javascript-solution-trie-solution",
                "content": "```\\nvar MapSum = function() {\\n    this.trie = {};\\n    this.map = new Map();\\n};\\n\\nMapSum.prototype.insert = function(key, val) {\\n    let curr = this.trie;\\n    let overRide = false;\\n    let prevVal = 0;\\n   \\n    if (this.map.has(key)) {\\n        overRide = true;\\n        prevVal = this.map.get(key);\\n    }    \\n    \\n    for (const char of key) {\\n        if (curr[char] == null) curr[char] = { sum: 0 };\\n\\n        if (overRide) {\\n            curr[char].sum -= prevVal;\\n            curr[char].sum += val;\\n        } \\n        else {\\n            curr[char].sum += val;\\n        }\\n\\n        curr = curr[char];\\n    } \\n    \\n    curr.isEnd = true;\\n    this.map.set(key, val);\\n};\\n\\nMapSum.prototype.sum = function(prefix) {\\n    let sum = 0;\\n    let curr = this.trie;\\n    let isPrefix = true;\\n    \\n    for (const char of prefix) {\\n        if (curr[char] == null) {\\n            isPrefix = false;\\n            break;\\n        };\\n        ({ sum } = curr[char]);\\n        curr = curr[char];\\n    }\\n    \\n    return isPrefix ? sum : 0;\\n};\\n ```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\nvar MapSum = function() {\\n    this.trie = {};\\n    this.map = new Map();\\n};\\n\\nMapSum.prototype.insert = function(key, val) {\\n    let curr = this.trie;\\n    let overRide = false;\\n    let prevVal = 0;\\n   \\n    if (this.map.has(key)) {\\n        overRide = true;\\n        prevVal = this.map.get(key);\\n    }    \\n    \\n    for (const char of key) {\\n        if (curr[char] == null) curr[char] = { sum: 0 };\\n\\n        if (overRide) {\\n            curr[char].sum -= prevVal;\\n            curr[char].sum += val;\\n        } \\n        else {\\n            curr[char].sum += val;\\n        }\\n\\n        curr = curr[char];\\n    } \\n    \\n    curr.isEnd = true;\\n    this.map.set(key, val);\\n};\\n\\nMapSum.prototype.sum = function(prefix) {\\n    let sum = 0;\\n    let curr = this.trie;\\n    let isPrefix = true;\\n    \\n    for (const char of prefix) {\\n        if (curr[char] == null) {\\n            isPrefix = false;\\n            break;\\n        };\\n        ({ sum } = curr[char]);\\n        curr = curr[char];\\n    }\\n    \\n    return isPrefix ? sum : 0;\\n};\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681362,
                "title": "java-trie-simple-98",
                "content": "```\\nclass MapSum {\\n    class Node {\\n        Node[] childs = new Node[26];\\n        boolean isEnd;\\n        int sum = 0;\\n    }\\n    \\n    Node root;\\n\\tHashMap<String, Integer> fmap;\\n    public MapSum() {\\n        root = new Node();\\n\\t\\tfmap = new HashMap<>();\\n    }\\n\\t\\n    public void insert(String key, int val) {\\n        if (fmap.containsKey(key)) {\\n            int old_frq = fmap.get(key);\\n            addInTrie(key, val - old_frq);\\n            fmap.remove(key);\\n        } else { //  does not exists\\n            addInTrie(key, val);\\n        }\\n        fmap.put(key, val);\\n    }\\n    \\n    public void addInTrie(String key, int val) {\\n        Node curr = root;\\n        for (char c : key.toCharArray()) {\\n            if (curr.childs[c - \\'a\\'] == null) {\\n                curr.childs[c - \\'a\\'] = new Node();\\n            }\\n            curr = curr.childs[c - \\'a\\'];\\n            curr.sum += val;\\n        }\\n        curr.isEnd = true;\\n    }\\n    \\n    public int sum(String prefix) {\\n        Node curr = root;\\n        for (char c : prefix.toCharArray()) {\\n            if (curr.childs[c - \\'a\\'] == null) {\\n                return 0;\\n            }\\n            curr = curr.childs[c - \\'a\\'];\\n        }\\n        return curr.sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n    class Node {\\n        Node[] childs = new Node[26];\\n        boolean isEnd;\\n        int sum = 0;\\n    }\\n    \\n    Node root;\\n\\tHashMap<String, Integer> fmap;\\n    public MapSum() {\\n        root = new Node();\\n\\t\\tfmap = new HashMap<>();\\n    }\\n\\t\\n    public void insert(String key, int val) {\\n        if (fmap.containsKey(key)) {\\n            int old_frq = fmap.get(key);\\n            addInTrie(key, val - old_frq);\\n            fmap.remove(key);\\n        } else { //  does not exists\\n            addInTrie(key, val);\\n        }\\n        fmap.put(key, val);\\n    }\\n    \\n    public void addInTrie(String key, int val) {\\n        Node curr = root;\\n        for (char c : key.toCharArray()) {\\n            if (curr.childs[c - \\'a\\'] == null) {\\n                curr.childs[c - \\'a\\'] = new Node();\\n            }\\n            curr = curr.childs[c - \\'a\\'];\\n            curr.sum += val;\\n        }\\n        curr.isEnd = true;\\n    }\\n    \\n    public int sum(String prefix) {\\n        Node curr = root;\\n        for (char c : prefix.toCharArray()) {\\n            if (curr.childs[c - \\'a\\'] == null) {\\n                return 0;\\n            }\\n            curr = curr.childs[c - \\'a\\'];\\n        }\\n        return curr.sum;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1670391,
                "title": "java-easy-solution-trie-and-hashmap",
                "content": "```\\nclass Node {\\n    Node data[]=new Node[26];\\n    int sum=0;\\n    \\n}\\n\\nclass MapSum {\\n    \\n    Node root=new Node();\\n    \\n    void buildTrie(Node node,String s,int value,int index){\\n        if(index>=s.length()) return;\\n        char c=s.charAt(index);\\n        if(node.data[c-97]==null)\\n            node.data[c-97]=new Node();\\n            node.data[c-97].sum+=value;\\n            buildTrie(node.data[c-97],s,value,index+1);\\n    }\\n    \\n    int result(Node n,String s,int index){\\n       char c=s.charAt(index);\\n        if(n.data[c-97]==null) return 0;\\n         if(index==s.length()-1 )\\n            return n.data[c-97].sum;\\n        return result(n.data[c-97],s,index+1);\\n        \\n    }\\n\\n    HashMap<String,Integer> map;\\n    public MapSum() {\\n        map=new HashMap<String,Integer>();\\n        \\n    }\\n    \\n    public void insert(String key, int val) {\\n        \\n        int diff=val-map.getOrDefault(key,0);\\n        map.put(key,val);\\n        buildTrie(root,key,diff,0);\\n    }\\n    \\n    public int sum(String prefix) {\\n        return result(root,prefix,0);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n    Node data[]=new Node[26];\\n    int sum=0;\\n    \\n}\\n\\nclass MapSum {\\n    \\n    Node root=new Node();\\n    \\n    void buildTrie(Node node,String s,int value,int index){\\n        if(index>=s.length()) return;\\n        char c=s.charAt(index);\\n        if(node.data[c-97]==null)\\n            node.data[c-97]=new Node();\\n            node.data[c-97].sum+=value;\\n            buildTrie(node.data[c-97],s,value,index+1);\\n    }\\n    \\n    int result(Node n,String s,int index){\\n       char c=s.charAt(index);\\n        if(n.data[c-97]==null) return 0;\\n         if(index==s.length()-1 )\\n            return n.data[c-97].sum;\\n        return result(n.data[c-97],s,index+1);\\n        \\n    }\\n\\n    HashMap<String,Integer> map;\\n    public MapSum() {\\n        map=new HashMap<String,Integer>();\\n        \\n    }\\n    \\n    public void insert(String key, int val) {\\n        \\n        int diff=val-map.getOrDefault(key,0);\\n        map.put(key,val);\\n        buildTrie(root,key,diff,0);\\n    }\\n    \\n    public int sum(String prefix) {\\n        return result(root,prefix,0);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644121,
                "title": "c-using-map-0ms-100-faster",
                "content": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    map<string,int>m;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        m[key]=val;\\n    }\\n    \\n    int GetSum(string str,int val,string prefix)\\n    {\\n        for(int i=0;i<prefix.size();i++)\\n        {\\n            if(str[i]!=prefix[i])\\n                return 0;\\n        }\\n        return val;\\n    }\\n    \\n    int sum(string prefix) {\\n     int sum=0;\\n        for(auto it:m)\\n        {\\n            string str=it.first;\\n            sum+=GetSum(str,it.second,prefix);\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    map<string,int>m;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        m[key]=val;\\n    }\\n    \\n    int GetSum(string str,int val,string prefix)\\n    {\\n        for(int i=0;i<prefix.size();i++)\\n        {\\n            if(str[i]!=prefix[i])\\n                return 0;\\n        }\\n        return val;\\n    }\\n    \\n    int sum(string prefix) {\\n     int sum=0;\\n        for(auto it:m)\\n        {\\n            string str=it.first;\\n            sum+=GetSum(str,it.second,prefix);\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631688,
                "title": "trie-and-map-0ms-easy-way",
                "content": "```\\nclass MapSum {\\n    class Node{\\n    public:\\n        int val;\\n        Node* child[26];\\n    };\\n    \\n    class Trie{\\n        Node* root;\\n        public:\\n        Trie(){\\n            root=createNode();\\n        }  \\n        \\n        Node* createNode(){\\n            Node* nNode=new Node();\\n            nNode->val=0;\\n            for(int i=0; i<26; i++) nNode->child[i]=NULL;\\n            \\n            return nNode;\\n        }\\n        \\n        void insert(string &word, int val){\\n            Node* cur=root;\\n            for(int i=0; word[i]; i++){\\n                int idx=word[i]-\\'a\\';\\n                if(cur->child[idx]==NULL)             \\n                    cur->child[idx]=createNode();\\n        \\n                cur=cur->child[idx];\\n                cur->val+=val;\\n            }\\n        }\\n        \\n        int search(string &word){\\n            Node* cur=root;\\n            for(int i=0; word[i]; i++){\\n                int idx=word[i]-\\'a\\';\\n                if(cur->child[idx]!=NULL) \\n                    cur=cur->child[idx];\\n                else return 0;\\n            }\\n            return cur->val;\\n        }\\n    };\\n    \\nTrie *trie;\\nunordered_map<string,int> umap;\\npublic:\\n    MapSum() {\\n       trie = new Trie();\\n        umap.clear();\\n    }\\n    \\n    void insert(string key, int val) {\\n        int changeVal=val;\\n        if(umap.count(key)>0)\\n            changeVal=val - umap[key];\\n\\n        trie->insert(key, changeVal);\\n        umap[key]=val;\\n    }\\n    \\n    int sum(string prefix) {\\n        return trie->search(prefix);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass MapSum {\\n    class Node{\\n    public:\\n        int val;\\n        Node* child[26];\\n    };\\n    \\n    class Trie{\\n        Node* root;\\n        public:\\n        Trie(){\\n            root=createNode();\\n        }  \\n        \\n        Node* createNode(){\\n            Node* nNode=new Node();\\n            nNode->val=0;\\n            for(int i=0; i<26; i++) nNode->child[i]=NULL;\\n            \\n            return nNode;\\n        }\\n        \\n        void insert(string &word, int val){\\n            Node* cur=root;\\n            for(int i=0; word[i]; i++){\\n                int idx=word[i]-\\'a\\';\\n                if(cur->child[idx]==NULL)             \\n                    cur->child[idx]=createNode();\\n        \\n                cur=cur->child[idx];\\n                cur->val+=val;\\n            }\\n        }\\n        \\n        int search(string &word){\\n            Node* cur=root;\\n            for(int i=0; word[i]; i++){\\n                int idx=word[i]-\\'a\\';\\n                if(cur->child[idx]!=NULL) \\n                    cur=cur->child[idx];\\n                else return 0;\\n            }\\n            return cur->val;\\n        }\\n    };\\n    \\nTrie *trie;\\nunordered_map<string,int> umap;\\npublic:\\n    MapSum() {\\n       trie = new Trie();\\n        umap.clear();\\n    }\\n    \\n    void insert(string key, int val) {\\n        int changeVal=val;\\n        if(umap.count(key)>0)\\n            changeVal=val - umap[key];\\n\\n        trie->insert(key, changeVal);\\n        umap[key]=val;\\n    }\\n    \\n    int sum(string prefix) {\\n        return trie->search(prefix);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431488,
                "title": "javascript-solution-using-trie",
                "content": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MapSum = function() {\\n    this.root = {val: 0};\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} val\\n * @return {void}\\n */\\nMapSum.prototype.insert = function(key, val) {\\n    let current = this.root;\\n    for (let char of key) {\\n        if (!current[char]) {\\n            current[char] = {\\n                parent: current,\\n                val: 0\\n            }\\n        }\\n        current = current[char];\\n        current.val = current.val + val;\\n    }\\n    const isReplaced = current.endVal > 0;\\n    const oldVal = current.endVal;\\n    current.endVal = val;\\n    \\n    if (isReplaced) {\\n        while (current.parent) {\\n            current.val = current.val - oldVal;\\n            current = current.parent;\\n        }\\n    }\\n\\n};\\n\\n/** \\n * @param {string} prefix\\n * @return {number}\\n */\\nMapSum.prototype.sum = function(prefix) {\\n    let current = this.root;\\n    \\n    for (let char of prefix) {\\n        if (!current[char]) {\\n            return null;\\n        }\\n        current = current[char];\\n    }\\n    return current.val;\\n};\\n\\n/** \\n * Your MapSum object will be instantiated and called as such:\\n * var obj = new MapSum()\\n * obj.insert(key,val)\\n * var param_2 = obj.sum(prefix)\\n */\\n```\\n\\nEach node will keep track of the sum of all prefix\\'s val.\\n\"endVal\" is added to keep track of the to keep track of the end of the word and the val.\\n\\nFor example, for following input: \\n```\\n[\"MapSum\", \"insert\", \"sum\", \"insert\", \"insert\", \"sum\"]\\n[[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"apple\", 2], [\"ap\"]]\\n```\\n\\n```\\nStep1: insert [\"apple\", 3]\\n\\t|\"a\"        |-> |\"p\"        |-> |\"p\"        |-> |\"l\"        |-> |\"e\"        | \\n    |val: 3     |   |val: 3     |   |val: 3     |   |val: 3     |   |val: 3     |\\n\\t|           |   |           |   |           |   |           |   |endVal: 3  |    \\n```\\n\\n```\\t\\nStep2: sum [\"ap\"]\\n\\t|\"a\"        |-> |\"p\"        |-> |\"p\"        |-> |\"l\"        |-> |\"e\"        | \\n    |val: 3     |   |val: 3     |   |val: 3     |   |val: 3     |   |val: 3     | \\n\\t|           |   |           |   |           |   |           |   |endVal: 3  |    \\n\\t\\t\\t\\t       ^^^^^^\\n\\treturn 3\\n```\\n\\n```\\nStep3: insert [\"app\", 2]\\n\\t|\"a\"        |-> |\"p\"        |-> |\"p\"        |-> |\"l\"        |-> |\"e\"        | \\n    |val: 3+2   |   |val: 3+2   |   |val: 3+2   |   |val: 3     |   |val: 3     | \\n\\t|           |   |           |   |endVal: 2  |   |           |   |endVal: 3  |    \\n```\\n\\n```\\nStep4: insert [\"apple\", 2]\\n\\n\\t|\"a\"        |-> |\"p\"        |-> |\"p\"        |-> |\"l\"        |-> |\"e\"        | \\n    |val: 5+2   |   |val: 5+2   |   |val: 5+2   |   |val: 3+2   |   |val: 3+2   | \\n\\t|           |   |           |   |endVal: 2  |   |           |   |endVal: 3  |    \\n\\t\\n\\tisReplaced = true\\n\\toldVal = 3\\n\\t\\n\\t/*\\n\\tNow we can subtract all the parents by the old value to complete the replacing process.\\n\\tAlso remember to update the new endVal. \\n\\t*/\\n\\t|\"a\"        |-> |\"p\"        |-> |\"p\"        |-> |\"l\"        |-> |\"e\"        | \\n    |val: 7-3   |   |val: 7-3   |   |val: 7-3   |   |val: 5-3   |   |val: 5-3   | \\n\\t|           |   |           |   |endVal: 2  |   |           |   |endVal:2   |    \\n\\t\\n\\t|\"a\"        |-> |\"p\"        |-> |\"p\"        |-> |\"l\"        |-> |\"e\"        | \\n    |val: 4     |   |val: 4     |   |val: 4     |   |val: 2     |   |val: 2     | \\n\\t|           |   |           |   |endVal: 2  |   |           |   |endVal:2   |    \\n```\\n\\n```\\nStep5: sum [\"ap\"]\\n\\t|\"a\"        |-> |\"p\"        |-> |\"p\"        |-> |\"l\"        |-> |\"e\"        | \\n    |val: 4     |   |val: 4     |   |val: 4     |   |val: 2     |   |val: 2     | \\n\\t|           |   |           |   |endVal: 2  |   |           |   |endVal:2   | \\n\\t\\t\\t\\t       ^^^^^^\\n\\treturn 4\\n```\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MapSum = function() {\\n    this.root = {val: 0};\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} val\\n * @return {void}\\n */\\nMapSum.prototype.insert = function(key, val) {\\n    let current = this.root;\\n    for (let char of key) {\\n        if (!current[char]) {\\n            current[char] = {\\n                parent: current,\\n                val: 0\\n            }\\n        }\\n        current = current[char];\\n        current.val = current.val + val;\\n    }\\n    const isReplaced = current.endVal > 0;\\n    const oldVal = current.endVal;\\n    current.endVal = val;\\n    \\n    if (isReplaced) {\\n        while (current.parent) {\\n            current.val = current.val - oldVal;\\n            current = current.parent;\\n        }\\n    }\\n\\n};\\n\\n/** \\n * @param {string} prefix\\n * @return {number}\\n */\\nMapSum.prototype.sum = function(prefix) {\\n    let current = this.root;\\n    \\n    for (let char of prefix) {\\n        if (!current[char]) {\\n            return null;\\n        }\\n        current = current[char];\\n    }\\n    return current.val;\\n};\\n\\n/** \\n * Your MapSum object will be instantiated and called as such:\\n * var obj = new MapSum()\\n * obj.insert(key,val)\\n * var param_2 = obj.sum(prefix)\\n */\\n```\n```\\n[\"MapSum\", \"insert\", \"sum\", \"insert\", \"insert\", \"sum\"]\\n[[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"apple\", 2], [\"ap\"]]\\n```\n```\\nStep1: insert [\"apple\", 3]\\n\\t|\"a\"        |-> |\"p\"        |-> |\"p\"        |-> |\"l\"        |-> |\"e\"        | \\n    |val: 3     |   |val: 3     |   |val: 3     |   |val: 3     |   |val: 3     |\\n\\t|           |   |           |   |           |   |           |   |endVal: 3  |    \\n```\n```\\t\\nStep2: sum [\"ap\"]\\n\\t|\"a\"        |-> |\"p\"        |-> |\"p\"        |-> |\"l\"        |-> |\"e\"        | \\n    |val: 3     |   |val: 3     |   |val: 3     |   |val: 3     |   |val: 3     | \\n\\t|           |   |           |   |           |   |           |   |endVal: 3  |    \\n\\t\\t\\t\\t       ^^^^^^\\n\\treturn 3\\n```\n```\\nStep3: insert [\"app\", 2]\\n\\t|\"a\"        |-> |\"p\"        |-> |\"p\"        |-> |\"l\"        |-> |\"e\"        | \\n    |val: 3+2   |   |val: 3+2   |   |val: 3+2   |   |val: 3     |   |val: 3     | \\n\\t|           |   |           |   |endVal: 2  |   |           |   |endVal: 3  |    \\n```\n```\\nStep4: insert [\"apple\", 2]\\n\\n\\t|\"a\"        |-> |\"p\"        |-> |\"p\"        |-> |\"l\"        |-> |\"e\"        | \\n    |val: 5+2   |   |val: 5+2   |   |val: 5+2   |   |val: 3+2   |   |val: 3+2   | \\n\\t|           |   |           |   |endVal: 2  |   |           |   |endVal: 3  |    \\n\\t\\n\\tisReplaced = true\\n\\toldVal = 3\\n\\t\\n\\t/*\\n\\tNow we can subtract all the parents by the old value to complete the replacing process.\\n\\tAlso remember to update the new endVal. \\n\\t*/\\n\\t|\"a\"        |-> |\"p\"        |-> |\"p\"        |-> |\"l\"        |-> |\"e\"        | \\n    |val: 7-3   |   |val: 7-3   |   |val: 7-3   |   |val: 5-3   |   |val: 5-3   | \\n\\t|           |   |           |   |endVal: 2  |   |           |   |endVal:2   |    \\n\\t\\n\\t|\"a\"        |-> |\"p\"        |-> |\"p\"        |-> |\"l\"        |-> |\"e\"        | \\n    |val: 4     |   |val: 4     |   |val: 4     |   |val: 2     |   |val: 2     | \\n\\t|           |   |           |   |endVal: 2  |   |           |   |endVal:2   |    \\n```\n```\\nStep5: sum [\"ap\"]\\n\\t|\"a\"        |-> |\"p\"        |-> |\"p\"        |-> |\"l\"        |-> |\"e\"        | \\n    |val: 4     |   |val: 4     |   |val: 4     |   |val: 2     |   |val: 2     | \\n\\t|           |   |           |   |endVal: 2  |   |           |   |endVal:2   | \\n\\t\\t\\t\\t       ^^^^^^\\n\\treturn 4\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1373355,
                "title": "python-use-trie-to-precalculate-sum",
                "content": "Use a trie to precalculate sum for each node. Having this, for each prefix we already have summed up all values of its children.\\n\\nUse sign `=` for sum key.\\n\\nWhen we get sum for the prefix we move along the trie until we reach end of this prefix, once it happened we can return a value in the key `=` for the last node.\\n\\nTo keep code cleaner use 3 helpers: `_insert_trie`, `_delete_trie`, `_update_trie`.\\n\\n```\\nclass MapSum:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.trie = {}  # store our trie\\n        self.keys = {}  # store values inserted for a key\\n        \\n        \\n    def _insert_trie(self, key, val):\\n\\t    \"\"\"Insert key in the trie and for each character update sum considering the new value\"\\n        d = self.trie\\n        while key:\\n            d[key[0]] = d.get(key[0], {})\\n            d = d[key[0]]\\n            d[\\'=\\'] = d.get(\\'=\\', 0) + val\\n            key = key[1:]\\n\\n    def _delete_trie(self, key, val):\\n\\t    \"\"\"Subtract old value from all nodes for the key\"\"\"\\n        d = self.trie\\n        while key:\\n            d = d.get(key[0])\\n            d[\\'=\\'] -= val\\n            key = key[1:]\\n            \\n    \\n    def _update_trie(self, key, new_val):\\n\\t    \"\"\"If the key was already inserted - first subtract the old value and then insert the new one\"\"\"\\n        self._delete_trie(key, self.keys[key])\\n        self._insert_trie(key, new_val)\\n        \\n\\n    def insert(self, key: str, val: int) -> None:\\n\\t    \"\"\"Check if the key was already inserted in the trie - update sums, otherwise add the new value\"\"\"\\n        if key in self.keys:\\n            self._update_trie(key, val)\\n        else:\\n            self._insert_trie(key, val)\\n        self.keys[key] = val\\n        \\n\\n    def sum(self, prefix: str) -> int:\\n        d = self.trie\\n        while prefix:\\n            if prefix[0] not in d:\\n                return 0\\n            d = d[prefix[0]]\\n            prefix = prefix[1:]\\n        return d.get(\\'=\\', 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.trie = {}  # store our trie\\n        self.keys = {}  # store values inserted for a key\\n        \\n        \\n    def _insert_trie(self, key, val):\\n\\t    \"\"\"Insert key in the trie and for each character update sum considering the new value\"\\n        d = self.trie\\n        while key:\\n            d[key[0]] = d.get(key[0], {})\\n            d = d[key[0]]\\n            d[\\'=\\'] = d.get(\\'=\\', 0) + val\\n            key = key[1:]\\n\\n    def _delete_trie(self, key, val):\\n\\t    \"\"\"Subtract old value from all nodes for the key\"\"\"\\n        d = self.trie\\n        while key:\\n            d = d.get(key[0])\\n            d[\\'=\\'] -= val\\n            key = key[1:]\\n            \\n    \\n    def _update_trie(self, key, new_val):\\n\\t    \"\"\"If the key was already inserted - first subtract the old value and then insert the new one\"\"\"\\n        self._delete_trie(key, self.keys[key])\\n        self._insert_trie(key, new_val)\\n        \\n\\n    def insert(self, key: str, val: int) -> None:\\n\\t    \"\"\"Check if the key was already inserted in the trie - update sums, otherwise add the new value\"\"\"\\n        if key in self.keys:\\n            self._update_trie(key, val)\\n        else:\\n            self._insert_trie(key, val)\\n        self.keys[key] = val\\n        \\n\\n    def sum(self, prefix: str) -> int:\\n        d = self.trie\\n        while prefix:\\n            if prefix[0] not in d:\\n                return 0\\n            d = d[prefix[0]]\\n            prefix = prefix[1:]\\n        return d.get(\\'=\\', 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373116,
                "title": "java-trie-solution",
                "content": "```\\nclass MapSum {\\n\\n    private Trie root;\\n    \\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        root = new Trie();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        root.insert(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        return root.sum(prefix);\\n    }\\n    \\n    private class Trie{\\n        Map<Character,Trie> map;\\n        boolean isEnd = false;\\n        int value = 0;\\n        \\n        public Trie(){\\n            this.map = new HashMap<>();\\n        }\\n        \\n        public void insert(String word, int value){\\n            Trie current = this;\\n            for(char c : word.toCharArray()){\\n                if(!current.map.containsKey(c))\\n                    current.map.put(c, new Trie());\\n                current = current.map.get(c);    \\n            }\\n            current.value=value;\\n            current.isEnd = true;\\n        }\\n        \\n        public List<Integer> prefixSearch(String pref){\\n              Trie current = this;\\n            for(char c : pref.toCharArray()){\\n                if(!current.map.containsKey(c))\\n                    return Arrays.asList();\\n                current = current.map.get(c);    \\n            }\\n            List<Integer> nums = new ArrayList<>();\\n            prefixSearch(current,nums);\\n            return nums;\\n        }\\n        \\n        private void prefixSearch(Trie node,List<Integer> list){\\n            if(node.isEnd){\\n                list.add(node.value);\\n            }\\n            for(char c : node.map.keySet()){\\n                 Trie currNode = node.map.get(c);\\n                 prefixSearch(currNode,list);   \\n            }\\n        }\\n        \\n        public int sum(String pref){\\n            List<Integer> list = prefixSearch(pref);\\n            //System.out.println(list);\\n            int sum = 0;\\n            for(int i:list)\\n                sum+=i;\\n            return sum;\\n        }\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n\\n    private Trie root;\\n    \\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        root = new Trie();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        root.insert(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        return root.sum(prefix);\\n    }\\n    \\n    private class Trie{\\n        Map<Character,Trie> map;\\n        boolean isEnd = false;\\n        int value = 0;\\n        \\n        public Trie(){\\n            this.map = new HashMap<>();\\n        }\\n        \\n        public void insert(String word, int value){\\n            Trie current = this;\\n            for(char c : word.toCharArray()){\\n                if(!current.map.containsKey(c))\\n                    current.map.put(c, new Trie());\\n                current = current.map.get(c);    \\n            }\\n            current.value=value;\\n            current.isEnd = true;\\n        }\\n        \\n        public List<Integer> prefixSearch(String pref){\\n              Trie current = this;\\n            for(char c : pref.toCharArray()){\\n                if(!current.map.containsKey(c))\\n                    return Arrays.asList();\\n                current = current.map.get(c);    \\n            }\\n            List<Integer> nums = new ArrayList<>();\\n            prefixSearch(current,nums);\\n            return nums;\\n        }\\n        \\n        private void prefixSearch(Trie node,List<Integer> list){\\n            if(node.isEnd){\\n                list.add(node.value);\\n            }\\n            for(char c : node.map.keySet()){\\n                 Trie currNode = node.map.get(c);\\n                 prefixSearch(currNode,list);   \\n            }\\n        }\\n        \\n        public int sum(String pref){\\n            List<Integer> list = prefixSearch(pref);\\n            //System.out.println(list);\\n            int sum = 0;\\n            for(int i:list)\\n                sum+=i;\\n            return sum;\\n        }\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372971,
                "title": "my-simple-java-solution",
                "content": "\\tclass MapSum {\\n\\n\\t\\tHashMap<String,Integer> map;\\n\\n\\t\\tpublic MapSum() {\\n\\t\\t\\tmap = new HashMap();\\n\\t\\t}\\n\\n\\t\\tpublic void insert(String key, int val) {\\n\\t\\t\\tmap.put(key,val);\\n\\t\\t}\\n\\n\\t\\tpublic int sum(String prefix) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(Map.Entry<String,Integer> entry:map.entrySet()){\\n\\t\\t\\t\\tif(entry.getKey().startsWith(prefix)){\\n\\t\\t\\t\\t\\tcount+=entry.getValue();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "\\tclass MapSum {\\n\\n\\t\\tHashMap<String,Integer> map;\\n\\n\\t\\tpublic MapSum() {\\n\\t\\t\\tmap = new HashMap();\\n\\t\\t}\\n\\n\\t\\tpublic void insert(String key, int val) {\\n\\t\\t\\tmap.put(key,val);\\n\\t\\t}\\n\\n\\t\\tpublic int sum(String prefix) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(Map.Entry<String,Integer> entry:map.entrySet()){\\n\\t\\t\\t\\tif(entry.getKey().startsWith(prefix)){\\n\\t\\t\\t\\t\\tcount+=entry.getValue();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1372762,
                "title": "simple-javascript-solution-easy-to-understand",
                "content": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MapSum = function() {\\n    this.data = new Map()\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} val\\n * @return {void}\\n */\\nMapSum.prototype.insert = function(key, val) {\\n    this.data.set(key, val)\\n};\\n\\n/** \\n * @param {string} prefix\\n * @return {number}\\n */\\nMapSum.prototype.sum = function(prefix) {\\n    let sum = 0\\n    for (const [k, v] of this.data) {\\n        if (k.startsWith(prefix)) sum += v\\n    }\\n    return sum\\n};\\n\\n/** \\n * Your MapSum object will be instantiated and called as such:\\n * var obj = new MapSum()\\n * obj.insert(key,val)\\n * var param_2 = obj.sum(prefix)\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MapSum = function() {\\n    this.data = new Map()\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} val\\n * @return {void}\\n */\\nMapSum.prototype.insert = function(key, val) {\\n    this.data.set(key, val)\\n};\\n\\n/** \\n * @param {string} prefix\\n * @return {number}\\n */\\nMapSum.prototype.sum = function(prefix) {\\n    let sum = 0\\n    for (const [k, v] of this.data) {\\n        if (k.startsWith(prefix)) sum += v\\n    }\\n    return sum\\n};\\n\\n/** \\n * Your MapSum object will be instantiated and called as such:\\n * var obj = new MapSum()\\n * obj.insert(key,val)\\n * var param_2 = obj.sum(prefix)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1372620,
                "title": "c-trie-beats-100",
                "content": "```\\nclass Trie {\\n    int val ;\\n    vector<Trie*> children;\\n    public:\\n        Trie() {\\n            val = 0;\\n            children = vector<Trie*>(26, nullptr);\\n        }\\n    void insert(string word, int val) {\\n        Trie* r = this;\\n        for (char ch : word) {\\n            if (!r->children[ch - \\'a\\'])\\n                r->children[ch - \\'a\\'] = new Trie();\\n            r = r->children[ch - \\'a\\'];\\n            \\n        }\\n        r->val = val;\\n    }\\n    \\n    Trie* findPrefixNode(string word) {\\n        Trie* r = this;\\n        for (char ch : word) {\\n            if (!r->children[ch - \\'a\\'])\\n                return nullptr;\\n            r = r->children[ch - \\'a\\'];\\n            \\n        }\\n        return r;\\n    }\\n    \\n    int findSum(Trie *r) {\\n        if (!r)\\n            return 0;\\n        int sum = r->val;\\n        for (int i = 0; i < 26; ++i) {\\n            sum += findSum(r->children[i]);\\n        }\\n        return sum;\\n    }\\n    \\n};\\n\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    Trie  *r;\\n    MapSum() {\\n        r = new Trie();\\n    }\\n    \\n    void insert(string key, int val) {\\n        r->insert(key, val);\\n    }\\n    \\n    int sum(string prefix) {\\n        return r->findSum(r->findPrefixNode(prefix));\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n ```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Trie {\\n    int val ;\\n    vector<Trie*> children;\\n    public:\\n        Trie() {\\n            val = 0;\\n            children = vector<Trie*>(26, nullptr);\\n        }\\n    void insert(string word, int val) {\\n        Trie* r = this;\\n        for (char ch : word) {\\n            if (!r->children[ch - \\'a\\'])\\n                r->children[ch - \\'a\\'] = new Trie();\\n            r = r->children[ch - \\'a\\'];\\n            \\n        }\\n        r->val = val;\\n    }\\n    \\n    Trie* findPrefixNode(string word) {\\n        Trie* r = this;\\n        for (char ch : word) {\\n            if (!r->children[ch - \\'a\\'])\\n                return nullptr;\\n            r = r->children[ch - \\'a\\'];\\n            \\n        }\\n        return r;\\n    }\\n    \\n    int findSum(Trie *r) {\\n        if (!r)\\n            return 0;\\n        int sum = r->val;\\n        for (int i = 0; i < 26; ++i) {\\n            sum += findSum(r->children[i]);\\n        }\\n        return sum;\\n    }\\n    \\n};\\n\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    Trie  *r;\\n    MapSum() {\\n        r = new Trie();\\n    }\\n    \\n    void insert(string key, int val) {\\n        r->insert(key, val);\\n    }\\n    \\n    int sum(string prefix) {\\n        return r->findSum(r->findPrefixNode(prefix));\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1372529,
                "title": "map-sum-pairs-python",
                "content": "```\\nclass MapSum:\\n    def __init__(self):\\n        self.map = {}\\n        \\n    def insert(self, key: str, val: int) -> None:\\n        self.map[key] = val\\n\\n    def sum(self, prefix: str) -> int:\\n        s, l = 0, len(prefix)\\n        for k in self.map.keys():\\n            if l> len(k): continue\\n            elif prefix == k[0:l]: s += self.map[k]\\n        return s \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass MapSum:\\n    def __init__(self):\\n        self.map = {}\\n        \\n    def insert(self, key: str, val: int) -> None:\\n        self.map[key] = val\\n\\n    def sum(self, prefix: str) -> int:\\n        s, l = 0, len(prefix)\\n        for k in self.map.keys():\\n            if l> len(k): continue\\n            elif prefix == k[0:l]: s += self.map[k]\\n        return s \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372408,
                "title": "using-trie-makes-your-code-100-faster",
                "content": "```\\nclass MapSum {\\n    class Trie{\\n        Trie child[]=new Trie[26];\\n        boolean isEnd;\\n        int value;\\n    }\\n    Trie root;\\n\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        root=new Trie();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        Trie curr=root;\\n        for(int i=0;i<key.length();i++){\\n            int index=key.charAt(i)-\\'a\\';\\n            if(curr.child[index]==null){\\n                curr.child[index]=new Trie();\\n            }\\n            curr=curr.child[index];\\n        }\\n        curr.isEnd=true;\\n        curr.value=val;\\n    }\\n    \\n    public int sum(String prefix) {\\n        Trie curr=root;\\n        for(int i=0;i<prefix.length();i++){\\n            int index=prefix.charAt(i)-\\'a\\';\\n            if(curr.child[index]==null){\\n                return 0;\\n            }\\n            curr=curr.child[index];\\n        }\\n        int res[]=new int[1];\\n        callrec(curr,res);\\n        return res[0];\\n    }\\n    public void callrec(Trie curr,int res[]){\\n        if(curr.isEnd==true){\\n            res[0]+=curr.value;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(curr.child[i]!=null){\\n                callrec(curr.child[i],res);\\n            }\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n    class Trie{\\n        Trie child[]=new Trie[26];\\n        boolean isEnd;\\n        int value;\\n    }\\n    Trie root;\\n\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        root=new Trie();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        Trie curr=root;\\n        for(int i=0;i<key.length();i++){\\n            int index=key.charAt(i)-\\'a\\';\\n            if(curr.child[index]==null){\\n                curr.child[index]=new Trie();\\n            }\\n            curr=curr.child[index];\\n        }\\n        curr.isEnd=true;\\n        curr.value=val;\\n    }\\n    \\n    public int sum(String prefix) {\\n        Trie curr=root;\\n        for(int i=0;i<prefix.length();i++){\\n            int index=prefix.charAt(i)-\\'a\\';\\n            if(curr.child[index]==null){\\n                return 0;\\n            }\\n            curr=curr.child[index];\\n        }\\n        int res[]=new int[1];\\n        callrec(curr,res);\\n        return res[0];\\n    }\\n    public void callrec(Trie curr,int res[]){\\n        if(curr.isEnd==true){\\n            res[0]+=curr.value;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(curr.child[i]!=null){\\n                callrec(curr.child[i],res);\\n            }\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372277,
                "title": "c-trie-with-swiss-knife",
                "content": "It might be natural to assume that `Sum` is NOT modifying the object, but strictly speaking there is no such requirement. Deliberately omitting this simple optimization we can use one `NodeByPrefix` combo-function for both `Insert` and `Sum`.\\n\\nClass `MapSum` becomes very straightforward:\\n\\n```c#\\npublic class MapSum {\\n    private TrieNode root = new TrieNode();\\n    public void Insert(string key, int val) => root.NodeByPrefix(key).Value = val;\\n    public int Sum(string prefix) => root.NodeByPrefix(prefix).Flatten().Sum(n => n.Value);\\n}\\n```\\n\\nThe `TrieNode` class isn\\'t much more complex yet already quite generic and reusable:\\n\\n```c#\\npublic class TrieNode {\\n    private Dictionary<char, TrieNode> children = new Dictionary<char, TrieNode>();\\n    public int Value { get; set; }\\n    \\n    // Recursively return nodes of subtree (including self)\\n    public IEnumerable<TrieNode> Flatten()\\n        => children.Values.SelectMany(n => n.Flatten()).Prepend(this);\\n    \\n    // Return node by prefix (create missing ones on-the-fly)\\n    public TrieNode NodeByPrefix(string s, int i = 0) {\\n        if (i == s.Length) return this;\\n        children.TryAdd(s[i], new TrieNode());\\n        return children[s[i]].NodeByPrefix(s, i + 1);\\n    }\\n}\\n```\\n\\nP.S: adding a boolean flag `create` to `NodeByPrefix` is not a big deal if you need it\\n```c#\\npublic TrieNode NodeByPrefix(string s, bool create, int i = 0) {\\n\\tif (i == s.Length) return this;\\n\\tif (create) children.TryAdd(s[i], new TrieNode());\\n\\treturn children.GetValueOrDefault(s[i])?.NodeByPrefix(s, create, i + 1);\\n}\\n```",
                "solutionTags": [],
                "code": "```c#\\npublic class MapSum {\\n    private TrieNode root = new TrieNode();\\n    public void Insert(string key, int val) => root.NodeByPrefix(key).Value = val;\\n    public int Sum(string prefix) => root.NodeByPrefix(prefix).Flatten().Sum(n => n.Value);\\n}\\n```\n```c#\\npublic class TrieNode {\\n    private Dictionary<char, TrieNode> children = new Dictionary<char, TrieNode>();\\n    public int Value { get; set; }\\n    \\n    // Recursively return nodes of subtree (including self)\\n    public IEnumerable<TrieNode> Flatten()\\n        => children.Values.SelectMany(n => n.Flatten()).Prepend(this);\\n    \\n    // Return node by prefix (create missing ones on-the-fly)\\n    public TrieNode NodeByPrefix(string s, int i = 0) {\\n        if (i == s.Length) return this;\\n        children.TryAdd(s[i], new TrieNode());\\n        return children[s[i]].NodeByPrefix(s, i + 1);\\n    }\\n}\\n```\n```c#\\npublic TrieNode NodeByPrefix(string s, bool create, int i = 0) {\\n\\tif (i == s.Length) return this;\\n\\tif (create) children.TryAdd(s[i], new TrieNode());\\n\\treturn children.GetValueOrDefault(s[i])?.NodeByPrefix(s, create, i + 1);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372234,
                "title": "cpp-and-java-easy-solution-fast-100",
                "content": "**cpp**\\n```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    map<string,int>m;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        m[key]=val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int count=0;\\n       for(auto it:m)\\n       {\\n          if(prefix==it.first.substr(0,prefix.size()))\\n              count+=it.second;\\n       }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```\\n**java**\\n```\\nclass MapSum {\\n\\n    /** Initialize your data structure here. */\\n    Map<String,Integer>m=new HashMap<String,Integer>();\\n    public MapSum() {\\n        \\n    }\\n    \\n    public void insert(String key, int val) {\\n        m.put(key,val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        int count=0;\\n        for(Map.Entry m1:m.entrySet()){     \\n       if(prefix.length()<=((String)m1.getKey()).length()) {\\n           if(prefix.equals(((String)m1.getKey()).substring(0,prefix.length())))\\n                count+=(int)m1.getValue();\\n       }\\n           \\n            \\n      }   \\n        return count;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    map<string,int>m;\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        m[key]=val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int count=0;\\n       for(auto it:m)\\n       {\\n          if(prefix==it.first.substr(0,prefix.size()))\\n              count+=it.second;\\n       }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```\n```\\nclass MapSum {\\n\\n    /** Initialize your data structure here. */\\n    Map<String,Integer>m=new HashMap<String,Integer>();\\n    public MapSum() {\\n        \\n    }\\n    \\n    public void insert(String key, int val) {\\n        m.put(key,val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        int count=0;\\n        for(Map.Entry m1:m.entrySet()){     \\n       if(prefix.length()<=((String)m1.getKey()).length()) {\\n           if(prefix.equals(((String)m1.getKey()).substring(0,prefix.length())))\\n                count+=(int)m1.getValue();\\n       }\\n           \\n            \\n      }   \\n        return count;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372142,
                "title": "c-trie-based-solution-100-time-65-space",
                "content": "If this problem does not scream \"tries\", I don\\'t know which one would do!\\n\\nIn order to solve it, we will first of all declare an extra `struct` `Trie`, which internally will only have an array of`Trie` pointers, `children`, and a value, `val`.\\n\\nIn our main class, we can define three support variables:\\n* `root` and `curr` will be `Trie` pointers, with the former initialised to an empty `Trie`;\\n* `seen` will help keep track of the previously seen words and their own associated value.\\n\\nWe do not really need a custom constructor (since we initialised `root` above) and we can skip this.\\n\\nIn our `insert` method, we will:\\n* set `curr` to be `root`;\\n* check if we already saw `key` and, in case:\\n\\t* swap `val` and `seen[key]` (ie: we update `seen[key]` to the new value and store the previous in `val`);\\n\\t* adjust `val` to be `seen[key] - val`, so that we will later run in our trie updating the matching nodes accordingly;\\n* otherwise just assign `val` to `seen[key]`;\\n* we will then loop through each character `c` in `key` and:\\n\\t* check if `curr->children[c]` already exists, otherwise we will create it as a new `Trie` node pointer;\\n\\t* advance `curr` to `curr->children[c]`;\\n\\t* update `curr->val` adding `val` (which can also be a negative value, if we are updating a previously seen word with a lower value) - in this way each node `val` property will be the sum of all the values of all the words that share that very same node.\\n\\nIn our `sum` function, we will proceed specularly and:\\n* set `curr` to be `root`;\\n* we will then loop through each character `c` in `prefix` and:\\n\\t* if `curr->children[c]` exists, advance `curr` to it;\\n\\t* `return` `0` otherwise, since it means we are parsing a `prefix` we never encountered;\\n* once done, we can `return` `curr->val` :)\\n\\nThe code:\\n\\n```cpp\\nstruct Trie {\\n    Trie *children[123];\\n    int val = 0;\\n};\\n\\nclass MapSum {\\n    Trie *root = new Trie(), *curr;\\n    unordered_map<string, int> seen;\\npublic:\\n    MapSum() {}\\n    \\n    void insert(string key, int val) {\\n        curr = root;\\n        // updating seen and val for already seen values\\n        if (seen.find(key) != end(seen)) {\\n            swap(val, seen[key]);\\n            val = seen[key] - val;\\n        }\\n        // updating seen for new values\\n        else seen[key] = val;\\n        // populating the trie\\n        for (char c: key) {\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n            curr->val += val;\\n        }\\n    }\\n    \\n    int sum(string prefix) {\\n        curr = root;\\n        // reaching the expected position in the trie\\n        for (char c: prefix) {\\n            if (curr->children[c]) curr = curr->children[c];\\n            else return 0;\\n        }\\n        return curr->val;\\n    }\\n};\\n```\\n\\nVariant with only `26` children for each node and it goes unsurprisingly saving A LOT of memory and, a bit more surprisingly, basically as fast as the previous run:\\n\\n```cpp\\nstruct Trie {\\n    Trie *children[26];\\n    int val = 0;\\n};\\n\\nclass MapSum {\\n    Trie *root = new Trie(), *curr;\\n    unordered_map<string, int> seen;\\npublic:\\n    MapSum() {}\\n    \\n    void insert(string key, int val) {\\n        curr = root;\\n        // updating seen and val for already seen values\\n        if (seen.find(key) != end(seen)) {\\n            swap(val, seen[key]);\\n            val = seen[key] - val;\\n        }\\n        // updating seen for new values\\n        else seen[key] = val;\\n        // populating the trie\\n        for (char c: key) {\\n            c -= \\'a\\';\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n            curr->val += val;\\n        }\\n    }\\n    \\n    int sum(string prefix) {\\n        curr = root;\\n        // reaching the expected position in the trie\\n        for (char c: prefix) {\\n            c -= \\'a\\';\\n            if (curr->children[c]) curr = curr->children[c];\\n            else return 0;\\n        }\\n        return curr->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```cpp\\nstruct Trie {\\n    Trie *children[123];\\n    int val = 0;\\n};\\n\\nclass MapSum {\\n    Trie *root = new Trie(), *curr;\\n    unordered_map<string, int> seen;\\npublic:\\n    MapSum() {}\\n    \\n    void insert(string key, int val) {\\n        curr = root;\\n        // updating seen and val for already seen values\\n        if (seen.find(key) != end(seen)) {\\n            swap(val, seen[key]);\\n            val = seen[key] - val;\\n        }\\n        // updating seen for new values\\n        else seen[key] = val;\\n        // populating the trie\\n        for (char c: key) {\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n            curr->val += val;\\n        }\\n    }\\n    \\n    int sum(string prefix) {\\n        curr = root;\\n        // reaching the expected position in the trie\\n        for (char c: prefix) {\\n            if (curr->children[c]) curr = curr->children[c];\\n            else return 0;\\n        }\\n        return curr->val;\\n    }\\n};\\n```\n```cpp\\nstruct Trie {\\n    Trie *children[26];\\n    int val = 0;\\n};\\n\\nclass MapSum {\\n    Trie *root = new Trie(), *curr;\\n    unordered_map<string, int> seen;\\npublic:\\n    MapSum() {}\\n    \\n    void insert(string key, int val) {\\n        curr = root;\\n        // updating seen and val for already seen values\\n        if (seen.find(key) != end(seen)) {\\n            swap(val, seen[key]);\\n            val = seen[key] - val;\\n        }\\n        // updating seen for new values\\n        else seen[key] = val;\\n        // populating the trie\\n        for (char c: key) {\\n            c -= \\'a\\';\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n            curr->val += val;\\n        }\\n    }\\n    \\n    int sum(string prefix) {\\n        curr = root;\\n        // reaching the expected position in the trie\\n        for (char c: prefix) {\\n            c -= \\'a\\';\\n            if (curr->children[c]) curr = curr->children[c];\\n            else return 0;\\n        }\\n        return curr->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371979,
                "title": "c-easy-solution-vectors-beats-100-time-75-space",
                "content": "**insert** \\ncheck for the key , if present overwrite it. \\n**sum**\\ncheck if 1st  character of prefix  matches any key\\'s 1st character \\nif present check substring of size =  prefix size , if they match add the value\\n```\\n vector<pair<string,int>> v;\\n    MapSum() { }\\n\\t\\n    void insert(string key, int val) {\\n        bool f=1;\\n        for(int i=0;i<v.size();i++)if(v[i].first==key){f=0;v[i].second=val;break;}\\n        if(f)v.push_back({key,val});\\n    }\\n    \\n    int sum(string prefix) {\\n        int sum=0;\\n        for(auto a:v)if(a.first[0]==prefix[0])\\n            if(a.first.substr(0,prefix.length())==prefix)sum+=a.second;\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<pair<string,int>> v;\\n    MapSum() { }\\n\\t\\n    void insert(string key, int val) {\\n        bool f=1;\\n        for(int i=0;i<v.size();i++)if(v[i].first==key){f=0;v[i].second=val;break;}\\n        if(f)v.push_back({key,val});\\n    }\\n    \\n    int sum(string prefix) {\\n        int sum=0;\\n        for(auto a:v)if(a.first[0]==prefix[0])\\n            if(a.first.substr(0,prefix.length())==prefix)sum+=a.second;\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1371950,
                "title": "java-solution-using-trie-o-n-time-no-extra-space",
                "content": "class Trie {\\n\\t\\n\\tTrie trie[];\\n\\tInteger val = null;\\n\\tTrie() {\\n\\t\\ttrie = new Trie[26];\\n\\t}\\n}\\nclass MapSum {\\n\\n\\tpublic MapSum() {\\n\\t\\twordSum = new Trie();\\n\\t}\\n\\t\\n\\tpublic void insert(String key, int val) {\\n\\t\\tTrie temp = wordSum;\\n\\t\\tfor(int i = 0; i < key.length(); i++) {\\n\\t\\t\\tint x = (int)key.charAt(i) - 97;\\n\\t\\t\\tif(temp.trie[x] == null) temp.trie[x] = new Trie();\\n\\t\\t\\ttemp = temp.trie[x];\\n\\t\\t}\\n\\t\\ttemp.val = new Integer(val);\\n\\t}\\n\\t\\n\\tpublic int sum(String prefix) {\\n\\t\\tTrie temp = wordSum;\\n\\t\\tfor(int i = 0; i < prefix.length(); i++) {\\n\\t\\t\\tint x = (int)prefix.charAt(i) - 97;\\n\\t\\t\\ttemp = temp.trie[x];\\n\\t\\t\\tif(temp == null) break;\\n\\t\\t}\\n\\t\\tif(temp == null) return 0;\\n\\t\\treturn sumHelper(temp);\\n\\t} \\n\\t\\n\\tpublic int sumHelper(Trie temp) {\\n\\t\\tint sum = 0;\\n\\t\\tif(temp.val != null) sum += temp.val;\\n\\t\\tfor(int i = 0; i < 26; i++) {\\n\\t\\t\\tif(temp.trie[i] != null)\\n\\t\\t\\t\\tsum += sumHelper(temp.trie[i]);\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t} \\n\\t\\n}",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "class Trie {\\n\\t\\n\\tTrie trie[];\\n\\tInteger val = null;\\n\\tTrie() {\\n\\t\\ttrie = new Trie[26];\\n\\t}\\n}\\nclass MapSum {\\n\\n\\tpublic MapSum() {\\n\\t\\twordSum = new Trie();\\n\\t}\\n\\t\\n\\tpublic void insert(String key, int val) {\\n\\t\\tTrie temp = wordSum;\\n\\t\\tfor(int i = 0; i < key.length(); i++) {\\n\\t\\t\\tint x = (int)key.charAt(i) - 97;\\n\\t\\t\\tif(temp.trie[x] == null) temp.trie[x] = new Trie();\\n\\t\\t\\ttemp = temp.trie[x];\\n\\t\\t}\\n\\t\\ttemp.val = new Integer(val);\\n\\t}\\n\\t\\n\\tpublic int sum(String prefix) {\\n\\t\\tTrie temp = wordSum;\\n\\t\\tfor(int i = 0; i < prefix.length(); i++) {\\n\\t\\t\\tint x = (int)prefix.charAt(i) - 97;\\n\\t\\t\\ttemp = temp.trie[x];\\n\\t\\t\\tif(temp == null) break;\\n\\t\\t}\\n\\t\\tif(temp == null) return 0;\\n\\t\\treturn sumHelper(temp);\\n\\t} \\n\\t\\n\\tpublic int sumHelper(Trie temp) {\\n\\t\\tint sum = 0;\\n\\t\\tif(temp.val != null) sum += temp.val;\\n\\t\\tfor(int i = 0; i < 26; i++) {\\n\\t\\t\\tif(temp.trie[i] != null)\\n\\t\\t\\t\\tsum += sumHelper(temp.trie[i]);\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t} \\n\\t\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1371946,
                "title": "java-trie",
                "content": "```\\nclass MapSum {\\n    Node root;\\n\\t\\n    public MapSum() {\\n        root = new Node();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        char[] chars = key.toCharArray();\\n        Node parent = root;\\n        for (int i=0; i<chars.length; i++) {\\n            Node child = parent.getChild(chars[i]);\\n            if (child == null) {\\n                child = new Node(chars[i]);\\n                parent.setChild(child);\\n            }\\n            parent = child;\\n        }\\n        parent.value = val;\\n        \\n    }\\n    \\n    public int sum(String prefix) {\\n        char[] chars = prefix.toCharArray();\\n        Node parent = root;\\n        \\n        for (int i=0; i<chars.length; i++) {\\n            Node child = parent.getChild(chars[i]);\\n\\t\\t\\t//prefix not exist\\n            if (child == null) {\\n                return 0;\\n            }\\n            parent = child;\\n        }\\n        \\n       //prepare result\\n        Queue<Node> q = new ArrayDeque<Node>();\\n        q.offer(parent);\\n        int sum = 0;\\n        while (!q.isEmpty()) {\\n            Node node = q.poll();\\n            sum += node.value;\\n            for (Node child : node.children) {\\n                if (child != null) q.offer(child);\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n\\n\\nclass Node {\\n    Node[] children = new Node[26];\\n    int value;\\n    char ch;\\n    \\n    public Node (char ch, int value) {\\n        this.ch = ch;\\n        this.value = value;\\n        \\n    }\\n     public Node (char ch) {\\n        this.ch = ch;\\n    }\\n    \\n     public Node () {\\n    }\\n    \\n    public Node getChild(char ch){\\n        return children[ch-97];\\n    }\\n    \\n    public void setChild(Node child) {\\n        children[child.ch-97] = child;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n    Node root;\\n\\t\\n    public MapSum() {\\n        root = new Node();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        char[] chars = key.toCharArray();\\n        Node parent = root;\\n        for (int i=0; i<chars.length; i++) {\\n            Node child = parent.getChild(chars[i]);\\n            if (child == null) {\\n                child = new Node(chars[i]);\\n                parent.setChild(child);\\n            }\\n            parent = child;\\n        }\\n        parent.value = val;\\n        \\n    }\\n    \\n    public int sum(String prefix) {\\n        char[] chars = prefix.toCharArray();\\n        Node parent = root;\\n        \\n        for (int i=0; i<chars.length; i++) {\\n            Node child = parent.getChild(chars[i]);\\n\\t\\t\\t//prefix not exist\\n            if (child == null) {\\n                return 0;\\n            }\\n            parent = child;\\n        }\\n        \\n       //prepare result\\n        Queue<Node> q = new ArrayDeque<Node>();\\n        q.offer(parent);\\n        int sum = 0;\\n        while (!q.isEmpty()) {\\n            Node node = q.poll();\\n            sum += node.value;\\n            for (Node child : node.children) {\\n                if (child != null) q.offer(child);\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n\\n\\nclass Node {\\n    Node[] children = new Node[26];\\n    int value;\\n    char ch;\\n    \\n    public Node (char ch, int value) {\\n        this.ch = ch;\\n        this.value = value;\\n        \\n    }\\n     public Node (char ch) {\\n        this.ch = ch;\\n    }\\n    \\n     public Node () {\\n    }\\n    \\n    public Node getChild(char ch){\\n        return children[ch-97];\\n    }\\n    \\n    public void setChild(Node child) {\\n        children[child.ch-97] = child;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371941,
                "title": "python3-dictionary",
                "content": "```\\ndef __init__(self):\\n        self.map={}\\n    def insert(self, key: str, val: int) -> None:\\n        self.map[key]=val\\n\\n    def sum(self, prefix: str) -> int:\\n        ans=0\\n        n=len(prefix)\\n        for key in self.map.keys():\\n            if key[:n]==prefix:\\n                ans+=self.map[key]\\n        return ans",
                "solutionTags": [],
                "code": "```\\ndef __init__(self):\\n        self.map={}\\n    def insert(self, key: str, val: int) -> None:\\n        self.map[key]=val\\n\\n    def sum(self, prefix: str) -> int:\\n        ans=0\\n        n=len(prefix)\\n        for key in self.map.keys():\\n            if key[:n]==prefix:\\n                ans+=self.map[key]\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 1371787,
                "title": "map-sum-pairs-c-runtime-beats-100-map-and-lower-bound",
                "content": "1. In the `insert` function: I am using **ordered map** to store the strings in sorted order always.\\n2. In the `sum` function: Using `lower_bound`, we can quickly reach a point where the prefix matches\\n3. From that point I traverse in linear fashion until the prefix matches and keep adding to `sum`\\n4. Always make sure we have not reached  `mp.end()`\\n\\n```\\nclass MapSum {\\nprivate:\\n    map<string, int> mp;\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        mp[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int sum = 0;\\n        for (auto itr = mp.lower_bound(prefix); itr != mp.end() && itr->first.compare(0, prefix.size(), prefix) == 0; ++itr)\\n        {\\n            sum += itr->second;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n**Hit upvote if you like this solution :)**",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\nprivate:\\n    map<string, int> mp;\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        mp[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int sum = 0;\\n        for (auto itr = mp.lower_bound(prefix); itr != mp.end() && itr->first.compare(0, prefix.size(), prefix) == 0; ++itr)\\n        {\\n            sum += itr->second;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371782,
                "title": "scala-trie-solution",
                "content": "```scala\\nclass MapSum() {\\n\\n    /** Initialize your data structure here. */\\n    case class Trie(value: Option[Int], children: Map[Char, Trie])\\n    \\n    private def emptyTrie: Trie = Trie(None, Map.empty)\\n    \\n    private def insert(trie: Trie, string: List[Char], value: Int): Trie = {\\n        string match {\\n            case Nil => Trie(Some(value), trie.children)\\n            case c :: cs => Trie(trie.value, \\n                                 trie.children + (c -> insert(trie.children.getOrElse(c, emptyTrie), cs, value)))\\n        }\\n    }\\n    \\n    private def query(trie: Trie, prefix: List[Char]): List[Int] = {\\n        prefix match {\\n            case c :: cs => trie.children.get(c).map(sub => query(sub, cs)).getOrElse(List(0))\\n            case Nil => traverse(trie)\\n        }\\n    }\\n    \\n    private def traverse(trie: Trie): List[Int] = {\\n        val childrens = trie.children.values.toList.flatMap(sub => traverse(sub))\\n        if(trie.value.isDefined) {\\n            trie.value.get :: childrens\\n        } else {\\n            childrens\\n        }\\n    }\\n    \\n    var root = emptyTrie\\n    \\n\\n    def insert(key: String, `val`: Int) {\\n        root = insert(root, key.toList, `val`)\\n    }\\n\\n    def sum(prefix: String): Int = {\\n        query(root, prefix.toList).sum\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nclass MapSum() {\\n\\n    /** Initialize your data structure here. */\\n    case class Trie(value: Option[Int], children: Map[Char, Trie])\\n    \\n    private def emptyTrie: Trie = Trie(None, Map.empty)\\n    \\n    private def insert(trie: Trie, string: List[Char], value: Int): Trie = {\\n        string match {\\n            case Nil => Trie(Some(value), trie.children)\\n            case c :: cs => Trie(trie.value, \\n                                 trie.children + (c -> insert(trie.children.getOrElse(c, emptyTrie), cs, value)))\\n        }\\n    }\\n    \\n    private def query(trie: Trie, prefix: List[Char]): List[Int] = {\\n        prefix match {\\n            case c :: cs => trie.children.get(c).map(sub => query(sub, cs)).getOrElse(List(0))\\n            case Nil => traverse(trie)\\n        }\\n    }\\n    \\n    private def traverse(trie: Trie): List[Int] = {\\n        val childrens = trie.children.values.toList.flatMap(sub => traverse(sub))\\n        if(trie.value.isDefined) {\\n            trie.value.get :: childrens\\n        } else {\\n            childrens\\n        }\\n    }\\n    \\n    var root = emptyTrie\\n    \\n\\n    def insert(key: String, `val`: Int) {\\n        root = insert(root, key.toList, `val`)\\n    }\\n\\n    def sum(prefix: String): Int = {\\n        query(root, prefix.toList).sum\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371752,
                "title": "c-map-solution-very-easy-to-understand-with-brief-explanation",
                "content": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    int ans =0;//for the final anser\\n    map<string,int> mp; // the map which will store the values with key\\n    MapSum() {\\n        //no need to put anything here\\n    }\\n    \\n    void insert(string key, int val) {\\n        \\n        if(mp.find(key)==mp.end()){\\n            mp.insert({key,val});\\n        }\\n        else{\\n            mp[key] = val;//if there is already a key then update previous value to the new value\\n        }\\n        \\n        \\n        \\n    }\\n    \\n    int sum(string prefix) {\\n        ans = 0;\\n        for(auto x: mp){\\n            \\n\\t\\t\\t//check for prefix \\n            string word = x.first;\\n            int i=0,j=0;\\n            while(j<prefix.size()){\\n                if(word[i]==prefix[j]){\\n                    i++;\\n                    j++;    \\n                }\\n                else{\\n                    break;\\n                }\\n                \\n            }\\n            //after breaking the while loop if j is not the end of string then it is not the word which has the required prefix.\\n            if(j==prefix.size()){\\n                ans = ans + x.second;//if j== end of prefix string add the value to the ans\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Hit like,,if you liked my solution ... :),,happy coding ;)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    int ans =0;//for the final anser\\n    map<string,int> mp; // the map which will store the values with key\\n    MapSum() {\\n        //no need to put anything here\\n    }\\n    \\n    void insert(string key, int val) {\\n        \\n        if(mp.find(key)==mp.end()){\\n            mp.insert({key,val});\\n        }\\n        else{\\n            mp[key] = val;//if there is already a key then update previous value to the new value\\n        }\\n        \\n        \\n        \\n    }\\n    \\n    int sum(string prefix) {\\n        ans = 0;\\n        for(auto x: mp){\\n            \\n\\t\\t\\t//check for prefix \\n            string word = x.first;\\n            int i=0,j=0;\\n            while(j<prefix.size()){\\n                if(word[i]==prefix[j]){\\n                    i++;\\n                    j++;    \\n                }\\n                else{\\n                    break;\\n                }\\n                \\n            }\\n            //after breaking the while loop if j is not the end of string then it is not the word which has the required prefix.\\n            if(j==prefix.size()){\\n                ans = ans + x.second;//if j== end of prefix string add the value to the ans\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326372,
                "title": "trie-solution-0ms",
                "content": "```\\nclass Trie{\\n    public: \\n        vector<Trie*> dict;\\n        bool isEnd;\\n        int score;\\n        Trie(){\\n            dict.assign(26,NULL);\\n            isEnd = false;\\n            score = 0;\\n        }        \\n};\\n\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    Trie* root;\\n    int val;\\n    MapSum() {\\n        root = new Trie();        \\n        val = 0;\\n    }\\n    \\n    void insert(string key, int val) {\\n        TrieInsert(key,val);\\n    }\\n    \\n    void TrieInsert(string s,int val){\\n        Trie* curr = root;\\n        for(int i=0;i<s.length();i++){\\n            if(curr->dict[s[i]-\\'a\\'] == NULL)\\n                curr->dict[s[i]-\\'a\\'] = new Trie();\\n            curr = curr->dict[s[i]-\\'a\\'];\\n        }\\n        curr->isEnd = true;\\n        curr->score = val;\\n    }\\n    \\n    \\n    void helper(Trie* curr){\\n        if(curr->isEnd)\\n            val += curr->score;\\n        for(int i=0;i<26;i++){\\n            if(curr->dict[i])\\n                helper(curr->dict[i]);\\n        }\\n    }\\n    \\n    int sum(string prefix) {\\n        val = 0;\\n        Trie* curr = root;\\n        for(char c:  prefix) {\\n            if(curr->dict[c-\\'a\\']==NULL)\\n                return 0;\\n            curr = curr->dict[c-\\'a\\'];\\n        }\\n        helper(curr);\\n        return val;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Trie{\\n    public: \\n        vector<Trie*> dict;\\n        bool isEnd;\\n        int score;\\n        Trie(){\\n            dict.assign(26,NULL);\\n            isEnd = false;\\n            score = 0;\\n        }        \\n};\\n\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    Trie* root;\\n    int val;\\n    MapSum() {\\n        root = new Trie();        \\n        val = 0;\\n    }\\n    \\n    void insert(string key, int val) {\\n        TrieInsert(key,val);\\n    }\\n    \\n    void TrieInsert(string s,int val){\\n        Trie* curr = root;\\n        for(int i=0;i<s.length();i++){\\n            if(curr->dict[s[i]-\\'a\\'] == NULL)\\n                curr->dict[s[i]-\\'a\\'] = new Trie();\\n            curr = curr->dict[s[i]-\\'a\\'];\\n        }\\n        curr->isEnd = true;\\n        curr->score = val;\\n    }\\n    \\n    \\n    void helper(Trie* curr){\\n        if(curr->isEnd)\\n            val += curr->score;\\n        for(int i=0;i<26;i++){\\n            if(curr->dict[i])\\n                helper(curr->dict[i]);\\n        }\\n    }\\n    \\n    int sum(string prefix) {\\n        val = 0;\\n        Trie* curr = root;\\n        for(char c:  prefix) {\\n            if(curr->dict[c-\\'a\\']==NULL)\\n                return 0;\\n            curr = curr->dict[c-\\'a\\'];\\n        }\\n        helper(curr);\\n        return val;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323774,
                "title": "677-object-map-trie-solutions",
                "content": "---\\n\\nThis problem can be solved in multiple ways - Obect, Map & Trie\\nTrie seems to be a great option for these kind of problem, because we don\\'t need to search/sort all keys we have\\n\\n---\\n\\n**Algo**\\n- Object/ map solution\\n  - Store key value in object/map - overwrite previous value\\n  - When `sum` is queried for all keys that has a `prefix`\\n    - loop through all keys, sum all values that has `prefix`\\n      - return `sum`\\n- Trie solution\\n  - What & how does trie store?\\n  - if `key=abc`, and `value=3` is given, then\\n    -  it will store as  `{  a:{   b:{    c:{value:3}    }   }  }` - yes, `c` has value and it is child of `b`, `b` is chlid of `a`\\n  - if `key=abc`, and `value=5` is given, then\\n    -  it will store as  `{  a:{   b:{    c:{value:5}    }   }  }` - yes, `c` previous value is overwritten\\n  - if `key=abcd`, and `value=21` is given, then\\n    -  it will store as  `{  a:{   b:{    c:{value:3,  d:{value:21} }    }   }  }` - yes `c` has value and a child too\\n  - Now if someone asks:\\n    - What is the `sum` of `abcd`? sum is `21`\\n    - What is the `sum` of `abc`? sum is `3+21=24` because `abc` is prefix of both `abc` & `abcd`\\n    - What is the `sum` of `aDc`? sum is `0` because anything that starts with `aD` was not inserted\\n- Though more compute might be required on `insert`, this problem can be further optimized for `queries` by using `Map & Trie`, see Solution tab at https://leetcode.com/problems/map-sum-pairs/solution/\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Object solution**\\n\\n```\\nclass MapSum {\\n    obj = {};\\n\\n    constructor() {}\\n\\n    insert(key, val) {\\n        this.obj[key] = val;\\n        return null;\\n    }\\n\\n    sum(prefix) {\\n        return Object.entries(this.obj) //\\n            .filter((a) => a[0].startsWith(prefix))\\n            .reduce((sum, a) => sum + a[1], 0);\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/715a3185-9008-416e-80f8-9d6be648e60d_1625715429.057258.png)\\n\\n---\\n\\n**Map solution**\\n\\n```\\nclass MapSum {\\n    map = new Map();\\n\\n    constructor() {}\\n\\n    insert(key, val) {\\n        this.map.set(key, val);\\n        return null;\\n    }\\n\\n    sum(prefix) {\\n        let sum = 0;\\n        for (const [key, value] of this.map)\\n            if (key.startsWith(prefix))\\n                sum += value;\\n        return sum;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/d43266cf-fa20-4b7e-8c8f-23c2c2213b7c_1625715451.7110367.png)\\n\\n---\\n\\n**Trie solution**\\n\\n```\\nclass Trie {\\n    // https://en.wikipedia.org/wiki/Trie\\n    TrieNode(value = undefined, children = {}) {\\n        return {\\n            value: value,\\n            children: children,\\n        };\\n    }\\n\\n    constructor() {\\n        this.r = this.TrieNode(0);\\n    }\\n\\n    insert(key, value = key) {\\n        let node = this.r;\\n\\n        for (let char of key) {\\n            node.children[char] = node.children[char] || this.TrieNode(0); // create if not exist\\n            node = node.children[char]; // goto it\\'s child\\n        }\\n        node.value = value; // terminal node has value, representing complete string\\n    }\\n\\n    findPrefixSum(prefix) {\\n        let sum = 0;\\n        const bt = (node = this.r, currPrefix) => {\\n            if (\\n                !node ||\\n                !(\\n                    prefix.startsWith(currPrefix) || //\\n                    currPrefix.startsWith(prefix)\\n                )\\n            ) {\\n                return;\\n            }\\n\\n            if (node.value && currPrefix.startsWith(prefix)) {\\n                sum += node.value;\\n            }\\n\\n            for (let char in node.children) {\\n                bt(node.children[char], currPrefix + char); // go deeper into this child\\n            }\\n        };\\n\\n        bt(this.r, \"\");\\n        // console.log(count);\\n        return sum;\\n    }\\n}\\n\\nclass MapSum {\\n    t = new Trie();\\n\\n    constructor() {}\\n\\n    insert(key, val) {\\n        this.t.insert(key, val);\\n        return null;\\n    }\\n\\n    sum(prefix) {\\n        return this.t.findPrefixSum(prefix);\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6d8452ff-d252-4da8-966e-1f5b3960cae7_1625715569.682532.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass MapSum {\\n    obj = {};\\n\\n    constructor() {}\\n\\n    insert(key, val) {\\n        this.obj[key] = val;\\n        return null;\\n    }\\n\\n    sum(prefix) {\\n        return Object.entries(this.obj) //\\n            .filter((a) => a[0].startsWith(prefix))\\n            .reduce((sum, a) => sum + a[1], 0);\\n    }\\n}\\n```\n```\\nclass MapSum {\\n    map = new Map();\\n\\n    constructor() {}\\n\\n    insert(key, val) {\\n        this.map.set(key, val);\\n        return null;\\n    }\\n\\n    sum(prefix) {\\n        let sum = 0;\\n        for (const [key, value] of this.map)\\n            if (key.startsWith(prefix))\\n                sum += value;\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Trie {\\n    // https://en.wikipedia.org/wiki/Trie\\n    TrieNode(value = undefined, children = {}) {\\n        return {\\n            value: value,\\n            children: children,\\n        };\\n    }\\n\\n    constructor() {\\n        this.r = this.TrieNode(0);\\n    }\\n\\n    insert(key, value = key) {\\n        let node = this.r;\\n\\n        for (let char of key) {\\n            node.children[char] = node.children[char] || this.TrieNode(0); // create if not exist\\n            node = node.children[char]; // goto it\\'s child\\n        }\\n        node.value = value; // terminal node has value, representing complete string\\n    }\\n\\n    findPrefixSum(prefix) {\\n        let sum = 0;\\n        const bt = (node = this.r, currPrefix) => {\\n            if (\\n                !node ||\\n                !(\\n                    prefix.startsWith(currPrefix) || //\\n                    currPrefix.startsWith(prefix)\\n                )\\n            ) {\\n                return;\\n            }\\n\\n            if (node.value && currPrefix.startsWith(prefix)) {\\n                sum += node.value;\\n            }\\n\\n            for (let char in node.children) {\\n                bt(node.children[char], currPrefix + char); // go deeper into this child\\n            }\\n        };\\n\\n        bt(this.r, \"\");\\n        // console.log(count);\\n        return sum;\\n    }\\n}\\n\\nclass MapSum {\\n    t = new Trie();\\n\\n    constructor() {}\\n\\n    insert(key, val) {\\n        this.t.insert(key, val);\\n        return null;\\n    }\\n\\n    sum(prefix) {\\n        return this.t.findPrefixSum(prefix);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277713,
                "title": "efficient-java-trie-solution-with-less-conditional-logic-and-casework",
                "content": "I tried to make a more design pattern-y solution:\\n\\n```\\nclass MapSum {\\n    public MapSum() {}\\n    \\n    public void insert(String key, int val) {\\n        TrieNode lastNode = traverseWithValue(key,0);\\n        traverseWithValue(key,val-lastNode.origVal);                \\n        lastNode.origVal = val;\\n    }\\n    \\n    public int sum(String prefix) {\\n        return traverseWithValue(prefix,0).sum;\\n    }\\n    \\n    /** adds val to every node visited via w (creating new nodes along the way if necessary)\\n    and returns the TrieNode corresponding to the final letter of w */\\n    private TrieNode traverseWithValue(String w, int val) {\\n        TrieNode prevNode = root;\\n        for (char ch: w.toCharArray()) {\\n            int c = ch-\\'a\\';\\n            if (prevNode.children[c] == null) prevNode.children[c] = new TrieNode();\\n            prevNode = prevNode.children[c];\\n            prevNode.sum += val;\\n        }\\n        return prevNode;\\n    }\\n    \\n    private TrieNode root = new TrieNode();\\n}\\n\\nclass TrieNode {\\n    public TrieNode() {}\\n    public int origVal = 0; // Invariant: equals val for the most recent insert(key,val) where TrieNode corresponded to the last letter of key; or 0 if no such insert occurred\\n    public int sum = 0; // Invariant: equals sum of val for all insert(key,val) where key passed through this TrieNode\\n    public TrieNode[] children = new TrieNode[26];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass MapSum {\\n    public MapSum() {}\\n    \\n    public void insert(String key, int val) {\\n        TrieNode lastNode = traverseWithValue(key,0);\\n        traverseWithValue(key,val-lastNode.origVal);                \\n        lastNode.origVal = val;\\n    }\\n    \\n    public int sum(String prefix) {\\n        return traverseWithValue(prefix,0).sum;\\n    }\\n    \\n    /** adds val to every node visited via w (creating new nodes along the way if necessary)\\n    and returns the TrieNode corresponding to the final letter of w */\\n    private TrieNode traverseWithValue(String w, int val) {\\n        TrieNode prevNode = root;\\n        for (char ch: w.toCharArray()) {\\n            int c = ch-\\'a\\';\\n            if (prevNode.children[c] == null) prevNode.children[c] = new TrieNode();\\n            prevNode = prevNode.children[c];\\n            prevNode.sum += val;\\n        }\\n        return prevNode;\\n    }\\n    \\n    private TrieNode root = new TrieNode();\\n}\\n\\nclass TrieNode {\\n    public TrieNode() {}\\n    public int origVal = 0; // Invariant: equals val for the most recent insert(key,val) where TrieNode corresponded to the last letter of key; or 0 if no such insert occurred\\n    public int sum = 0; // Invariant: equals sum of val for all insert(key,val) where key passed through this TrieNode\\n    public TrieNode[] children = new TrieNode[26];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130164,
                "title": "trie-recursive-without-a-hashmap",
                "content": "```\\npublic class MapSum \\n{\\n    private class Node\\n    {\\n        public int Val;\\n        public int Total;\\n        public Node[] Children = new Node[26];\\n        public bool IsWord = false;\\n        \\n        public Node(int val, bool isWord)\\n        {\\n            this.Val = val;\\n            this.IsWord = isWord;\\n            this.Total = val;\\n        }\\n    }\\n    \\n    private Node root = new Node(0, false);\\n    \\n    private int Insert(Node n, string key, int i, int v)\\n    {\\n        if (i >= key.Length)\\n        {\\n            return 0;\\n        }\\n        \\n        int index = key[i] - \\'a\\';\\n        var cur = n.Children[index];\\n        \\n        if (i == key.Length - 1)\\n        {    \\n            int res = 0;\\n            if (cur == null)\\n            {\\n                n.Children[index] = new Node(v, true);\\n                res = v;\\n            }\\n            else if (cur.IsWord)\\n            {\\n                res = v - cur.Val;\\n                cur.Val = v;\\n                cur.Total += res;\\n            }\\n            else\\n            {\\n                cur.IsWord = true;\\n                cur.Val = v;\\n                cur.Total += v;\\n                res = v;\\n            }\\n            \\n            return res;\\n        }\\n        \\n        if (cur == null)\\n        {\\n            n.Children[index] = new Node(0, false);\\n            cur = n.Children[index];\\n        }\\n        \\n        int delta = this.Insert(cur, key, i + 1, v);\\n        n.Children[index].Total += delta;\\n        \\n        return delta;\\n    }\\n    \\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        \\n    }\\n    \\n    public void Insert(string key, int val) \\n    {\\n        this.Insert(this.root, key, 0, val);\\n    }\\n    \\n    public int Sum(string prefix) \\n    {\\n        var cur = this.root;\\n        foreach (var c in prefix)\\n        {\\n            if (cur == null)\\n            {\\n                break;\\n            }\\n            \\n            int index = c - \\'a\\';\\n            cur = cur.Children[index];\\n        }\\n        \\n        return cur != null ? cur.Total : 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MapSum \\n{\\n    private class Node\\n    {\\n        public int Val;\\n        public int Total;\\n        public Node[] Children = new Node[26];\\n        public bool IsWord = false;\\n        \\n        public Node(int val, bool isWord)\\n        {\\n            this.Val = val;\\n            this.IsWord = isWord;\\n            this.Total = val;\\n        }\\n    }\\n    \\n    private Node root = new Node(0, false);\\n    \\n    private int Insert(Node n, string key, int i, int v)\\n    {\\n        if (i >= key.Length)\\n        {\\n            return 0;\\n        }\\n        \\n        int index = key[i] - \\'a\\';\\n        var cur = n.Children[index];\\n        \\n        if (i == key.Length - 1)\\n        {    \\n            int res = 0;\\n            if (cur == null)\\n            {\\n                n.Children[index] = new Node(v, true);\\n                res = v;\\n            }\\n            else if (cur.IsWord)\\n            {\\n                res = v - cur.Val;\\n                cur.Val = v;\\n                cur.Total += res;\\n            }\\n            else\\n            {\\n                cur.IsWord = true;\\n                cur.Val = v;\\n                cur.Total += v;\\n                res = v;\\n            }\\n            \\n            return res;\\n        }\\n        \\n        if (cur == null)\\n        {\\n            n.Children[index] = new Node(0, false);\\n            cur = n.Children[index];\\n        }\\n        \\n        int delta = this.Insert(cur, key, i + 1, v);\\n        n.Children[index].Total += delta;\\n        \\n        return delta;\\n    }\\n    \\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        \\n    }\\n    \\n    public void Insert(string key, int val) \\n    {\\n        this.Insert(this.root, key, 0, val);\\n    }\\n    \\n    public int Sum(string prefix) \\n    {\\n        var cur = this.root;\\n        foreach (var c in prefix)\\n        {\\n            if (cur == null)\\n            {\\n                break;\\n            }\\n            \\n            int index = c - \\'a\\';\\n            cur = cur.Children[index];\\n        }\\n        \\n        return cur != null ? cur.Total : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126532,
                "title": "c-trie-0ms",
                "content": "```\\nclass MapSum {\\nprivate:\\n    struct TrieNode {\\n        TrieNode* nextNode[26];\\n        TrieNode* preNode;\\n        int count = 0, val = 0;\\n        bool end = false;\\n    };\\n\\n    TrieNode* root;\\n\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        root = new TrieNode();\\n    }\\n\\n    void insert(string key, int val) {\\n        int l = key.length();\\n        TrieNode* p = root;\\n        int nextChar;\\n        for(int i = 0; i < l; i++)\\n        {\\n            nextChar = key[i] - \\'a\\';\\n            if (!p->nextNode[nextChar])\\n            {\\n                p->nextNode[nextChar] = new TrieNode();\\n                p->nextNode[nextChar]->preNode = p;\\n            }\\n            p = p->nextNode[nextChar];\\n        }\\n        p->end = true;\\n        int dif = val - p->val;\\n        p->val = val;\\n        if (!dif)\\n            return;\\n        while (p != root)\\n        {\\n            p->count += dif;\\n            p = p->preNode;\\n        }\\n    }\\n\\n    int sum(string prefix) {\\n        int l = prefix.length();\\n        TrieNode* Pre = root;\\n        int nextChar;\\n        for (int i = 0; i < l; i++)\\n        {\\n            nextChar = prefix[i] - \\'a\\';\\n            if (Pre->nextNode[nextChar])\\n                Pre = Pre->nextNode[nextChar];\\n            else\\n                return 0;\\n        }\\n        return Pre->count;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\nprivate:\\n    struct TrieNode {\\n        TrieNode* nextNode[26];\\n        TrieNode* preNode;\\n        int count = 0, val = 0;\\n        bool end = false;\\n    };\\n\\n    TrieNode* root;\\n\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        root = new TrieNode();\\n    }\\n\\n    void insert(string key, int val) {\\n        int l = key.length();\\n        TrieNode* p = root;\\n        int nextChar;\\n        for(int i = 0; i < l; i++)\\n        {\\n            nextChar = key[i] - \\'a\\';\\n            if (!p->nextNode[nextChar])\\n            {\\n                p->nextNode[nextChar] = new TrieNode();\\n                p->nextNode[nextChar]->preNode = p;\\n            }\\n            p = p->nextNode[nextChar];\\n        }\\n        p->end = true;\\n        int dif = val - p->val;\\n        p->val = val;\\n        if (!dif)\\n            return;\\n        while (p != root)\\n        {\\n            p->count += dif;\\n            p = p->preNode;\\n        }\\n    }\\n\\n    int sum(string prefix) {\\n        int l = prefix.length();\\n        TrieNode* Pre = root;\\n        int nextChar;\\n        for (int i = 0; i < l; i++)\\n        {\\n            nextChar = prefix[i] - \\'a\\';\\n            if (Pre->nextNode[nextChar])\\n                Pre = Pre->nextNode[nextChar];\\n            else\\n                return 0;\\n        }\\n        return Pre->count;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070421,
                "title": "c-2-hash-tables",
                "content": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        int cur = keyVal[key];\\n        keyVal[key] = val;\\n        for (int i = 0; i < key.size(); ++i)\\n        {\\n            string pre = key.substr(0, i + 1);\\n            preSum[pre] += val - cur; \\n        }\\n    }\\n    \\n    int sum(string prefix) {\\n        return preSum[prefix];\\n    }\\n    \\nprivate:\\n    unordered_map<string, int> keyVal;\\n    unordered_map<string, int> preSum;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        int cur = keyVal[key];\\n        keyVal[key] = val;\\n        for (int i = 0; i < key.size(); ++i)\\n        {\\n            string pre = key.substr(0, i + 1);\\n            preSum[pre] += val - cur; \\n        }\\n    }\\n    \\n    int sum(string prefix) {\\n        return preSum[prefix];\\n    }\\n    \\nprivate:\\n    unordered_map<string, int> keyVal;\\n    unordered_map<string, int> preSum;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037903,
                "title": "javascript-trie-explanation-for-map-sum-pairs",
                "content": "We can use the Trie data structure with some modifications for MapSum class:\\n\\n1. In the node we will have additional properties sum (with weight for current prefix) and wordWeight (weight of the whole word instead of isWord flag);\\n\\n2. Instead of search method we will implement searchKey to check if the previous word is the part of the current word and recalculate the sum property while inserting;\\n\\n3. Instead of searchPrefix we will implement sum which returns the sum for current prefix;\\n\\n```\\n/**\\n * Initialize your data structure here.\\n */\\nclass TrieNode {\\n    constructor() {\\n        return {\\n            sum: 0, // sum for particular digit\\n            children: new Map(),\\n            wordWeight: 0 // weight of the whole word\\n        }\\n    }\\n}\\n\\nclass MapSum {\\n     /** \\n     * @param {string} key \\n     * @param {number} val\\n     * @return {void}\\n     */\\n    constructor() {\\n        this.mapSum = new TrieNode();\\n    }\\n    \\n    insert(key, val) {\\n\\t\\n\\t// return the weight if the key is already exists or 0\\n        const prevWeight = this.searchKey(key);\\n        let current = this.mapSum;\\n        for (let ch of key) {\\n            const node = current.children.get(ch) || new TrieNode();\\n            current.children.set(ch, node);\\n            current = node;\\n            current.sum += (val - prevWeight); // count the sum for digit\\n        }\\n        current.wordWeight = val;\\n    };\\n    \\n    searchKey(key) {\\n        let current = this.mapSum;\\n        for (let ch of key) {\\n            if (!current.children.has(ch)) return 0;\\n            current = current.children.get(ch);\\n        }\\n        return current.wordWeight;\\n    }\\n\\n    /** \\n     * @param {string} prefix\\n     * @return {number}\\n     */\\n    sum(prefix) {\\n        let current = this.mapSum;\\n        for (let ch of prefix) {\\n            if (!current.children.has(ch)) return 0;\\n            current = current.children.get(ch);\\n        }\\n        return current.sum;\\n    }; \\n};\\n\\n\\n\\n/** \\n * Your MapSum object will be instantiated and called as such:\\n * var obj = new MapSum()\\n * obj.insert(key,val)\\n * var param_2 = obj.sum(prefix)\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Initialize your data structure here.\\n */\\nclass TrieNode {\\n    constructor() {\\n        return {\\n            sum: 0, // sum for particular digit\\n            children: new Map(),\\n            wordWeight: 0 // weight of the whole word\\n        }\\n    }\\n}\\n\\nclass MapSum {\\n     /** \\n     * @param {string} key \\n     * @param {number} val\\n     * @return {void}\\n     */\\n    constructor() {\\n        this.mapSum = new TrieNode();\\n    }\\n    \\n    insert(key, val) {\\n\\t\\n\\t// return the weight if the key is already exists or 0\\n        const prevWeight = this.searchKey(key);\\n        let current = this.mapSum;\\n        for (let ch of key) {\\n            const node = current.children.get(ch) || new TrieNode();\\n            current.children.set(ch, node);\\n            current = node;\\n            current.sum += (val - prevWeight); // count the sum for digit\\n        }\\n        current.wordWeight = val;\\n    };\\n    \\n    searchKey(key) {\\n        let current = this.mapSum;\\n        for (let ch of key) {\\n            if (!current.children.has(ch)) return 0;\\n            current = current.children.get(ch);\\n        }\\n        return current.wordWeight;\\n    }\\n\\n    /** \\n     * @param {string} prefix\\n     * @return {number}\\n     */\\n    sum(prefix) {\\n        let current = this.mapSum;\\n        for (let ch of prefix) {\\n            if (!current.children.has(ch)) return 0;\\n            current = current.children.get(ch);\\n        }\\n        return current.sum;\\n    }; \\n};\\n\\n\\n\\n/** \\n * Your MapSum object will be instantiated and called as such:\\n * var obj = new MapSum()\\n * obj.insert(key,val)\\n * var param_2 = obj.sum(prefix)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027651,
                "title": "trie-cpp",
                "content": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    struct Trie\\n    {\\n        Trie *children[26];\\n        bool isEnd;\\n        int sum;\\n        Trie()\\n        {\\n            for(int i=0;i<26;i++)\\n                children[i]=NULL;\\n            isEnd=false;\\n            sum=0;\\n        }\\n    };\\n    Trie *root;\\n    MapSum() \\n    {\\n        root=new Trie();\\n    }\\n    void insert(string key, int val) \\n    {\\n        Trie *p=root;\\n        for(int i=0;i<key.size();i++)\\n        {\\n            int index=key[i]-\\'a\\';\\n            if(!p->children[index])\\n                p->children[index]=new Trie();\\n            p=p->children[index];\\n        }\\n        p->sum=val;\\n        p->isEnd=true;\\n    }\\n    int getsum(Trie *p)\\n    {\\n        int res=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(p->children[i]!=NULL)\\n            {\\n                res+=p->children[i]->sum+getsum(p->children[i]);\\n            }\\n        }\\n        return res;\\n    }\\n    int sum(string prefix) \\n    {\\n        Trie *p=root;\\n        for(int i=0;i<prefix.size();i++)\\n        {\\n            int index=prefix[i]-\\'a\\';\\n            if(!p->children[index])\\n                return 0;\\n            p=p->children[index];\\n        }\\n        return p->sum+getsum(p);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    struct Trie\\n    {\\n        Trie *children[26];\\n        bool isEnd;\\n        int sum;\\n        Trie()\\n        {\\n            for(int i=0;i<26;i++)\\n                children[i]=NULL;\\n            isEnd=false;\\n            sum=0;\\n        }\\n    };\\n    Trie *root;\\n    MapSum() \\n    {\\n        root=new Trie();\\n    }\\n    void insert(string key, int val) \\n    {\\n        Trie *p=root;\\n        for(int i=0;i<key.size();i++)\\n        {\\n            int index=key[i]-\\'a\\';\\n            if(!p->children[index])\\n                p->children[index]=new Trie();\\n            p=p->children[index];\\n        }\\n        p->sum=val;\\n        p->isEnd=true;\\n    }\\n    int getsum(Trie *p)\\n    {\\n        int res=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(p->children[i]!=NULL)\\n            {\\n                res+=p->children[i]->sum+getsum(p->children[i]);\\n            }\\n        }\\n        return res;\\n    }\\n    int sum(string prefix) \\n    {\\n        Trie *p=root;\\n        for(int i=0;i<prefix.size();i++)\\n        {\\n            int index=prefix[i]-\\'a\\';\\n            if(!p->children[index])\\n                return 0;\\n            p=p->children[index];\\n        }\\n        return p->sum+getsum(p);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012270,
                "title": "js-short-and-easy-solution",
                "content": "```\\nvar MapSum = function() {\\n    this.pairs = new Map();\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} val\\n * @return {void}\\n */\\nMapSum.prototype.insert = function(key, val) {\\n    this.pairs.set(key, val);\\n};\\n\\n/** \\n * @param {string} prefix\\n * @return {number}\\n */\\nMapSum.prototype.sum = function(prefix) {\\n    let sumOfPairs = 0;\\n    \\n    for (let [key, val] of Array.from(this.pairs)) {\\n        if(key.startsWith(prefix)) {\\n            sumOfPairs += val;\\n        }\\n    }\\n    return sumOfPairs;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar MapSum = function() {\\n    this.pairs = new Map();\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} val\\n * @return {void}\\n */\\nMapSum.prototype.insert = function(key, val) {\\n    this.pairs.set(key, val);\\n};\\n\\n/** \\n * @param {string} prefix\\n * @return {number}\\n */\\nMapSum.prototype.sum = function(prefix) {\\n    let sumOfPairs = 0;\\n    \\n    for (let [key, val] of Array.from(this.pairs)) {\\n        if(key.startsWith(prefix)) {\\n            sumOfPairs += val;\\n        }\\n    }\\n    return sumOfPairs;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1002766,
                "title": "simple-javascript-solution-runtime-faster-than-72-94-and-memory-less-than-80-00",
                "content": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MapSum = function() {\\n    this.root = {};\\n    this.keys = {};\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} val\\n * @return {void}\\n */\\nMapSum.prototype.insert = function(key, val) {\\n    let node = this.root;\\n    let sum;\\n    let oldVal = this.keys[key] === undefined ? 0 : this.keys[key];\\n    \\n    this.keys[key] = val;\\n    val -= oldVal;\\n    \\n    for (let c of key) {\\n        if (node[c] === undefined) {\\n            node[c] = { sum: 0 };\\n        }\\n        \\n        node[c].sum += val;\\n        node = node[c];\\n    }\\n};\\n\\n/** \\n * @param {string} prefix\\n * @return {number}\\n */\\nMapSum.prototype.sum = function(prefix) {\\n    let node = this.root;\\n    let found = true;\\n    \\n    for (let c of prefix) {\\n        if (node[c] === undefined) {\\n            found = false;\\n            break;\\n        }\\n        node = node[c];\\n    }\\n    \\n    return found ? node.sum : 0;\\n};\\n\\n/** \\n * Your MapSum object will be instantiated and called as such:\\n * var obj = new MapSum()\\n * obj.insert(key,val)\\n * var param_2 = obj.sum(prefix)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MapSum = function() {\\n    this.root = {};\\n    this.keys = {};\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} val\\n * @return {void}\\n */\\nMapSum.prototype.insert = function(key, val) {\\n    let node = this.root;\\n    let sum;\\n    let oldVal = this.keys[key] === undefined ? 0 : this.keys[key];\\n    \\n    this.keys[key] = val;\\n    val -= oldVal;\\n    \\n    for (let c of key) {\\n        if (node[c] === undefined) {\\n            node[c] = { sum: 0 };\\n        }\\n        \\n        node[c].sum += val;\\n        node = node[c];\\n    }\\n};\\n\\n/** \\n * @param {string} prefix\\n * @return {number}\\n */\\nMapSum.prototype.sum = function(prefix) {\\n    let node = this.root;\\n    let found = true;\\n    \\n    for (let c of prefix) {\\n        if (node[c] === undefined) {\\n            found = false;\\n            break;\\n        }\\n        node = node[c];\\n    }\\n    \\n    return found ? node.sum : 0;\\n};\\n\\n/** \\n * Your MapSum object will be instantiated and called as such:\\n * var obj = new MapSum()\\n * obj.insert(key,val)\\n * var param_2 = obj.sum(prefix)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 973330,
                "title": "ruby-solution",
                "content": "```\\nclass MapSum\\n\\n=begin\\n    Initialize your data structure here.\\n=end\\n    def initialize()\\n        @maps = Hash.new\\n    end\\n\\n\\n=begin\\n    :type key: String\\n    :type val: Integer\\n    :rtype: Void\\n=end\\n    def insert(key, val)\\n        @maps[key]=val\\n    end\\n\\n\\n=begin\\n    :type prefix: String\\n    :rtype: Integer\\n=end\\n    def sum(prefix)\\n        @maps.keys.map {|k| k.start_with?(prefix) ? @maps[k] : 0}.sum\\n    end\\n\\n\\nend\\n\\n# Your MapSum object will be instantiated and called as such:\\n# obj = MapSum.new()\\n# obj.insert(key, val)\\n# param_2 = obj.sum(prefix)\\n",
                "solutionTags": [],
                "code": "```\\nclass MapSum\\n\\n=begin\\n    Initialize your data structure here.\\n=end\\n    def initialize()\\n        @maps = Hash.new\\n    end\\n\\n\\n=begin\\n    :type key: String\\n    :type val: Integer\\n    :rtype: Void\\n=end\\n    def insert(key, val)\\n        @maps[key]=val\\n    end\\n\\n\\n=begin\\n    :type prefix: String\\n    :rtype: Integer\\n=end\\n    def sum(prefix)\\n        @maps.keys.map {|k| k.start_with?(prefix) ? @maps[k] : 0}.sum\\n    end\\n\\n\\nend\\n\\n# Your MapSum object will be instantiated and called as such:\\n# obj = MapSum.new()\\n# obj.insert(key, val)\\n# param_2 = obj.sum(prefix)\\n",
                "codeTag": "Java"
            },
            {
                "id": 908815,
                "title": "c-unordered-map-trie-100",
                "content": "This question did not have a single post with a proper explaination of the implementation in C++. So, here it is:\\n\\nThe idea is pretty simple: We want to insert the values in such a way that we can return sum just by traversing the input prefix array.\\n\\nThere are three possibilities for insert(key,val) function:\\n\\t\\t\\t1. \\tA new key is inserted: In this case, we insert just like a normal trie and initialise each node with val.\\n\\t\\t\\t2. \\tKey doesn\\'t exist but its prefix is present: Here also, we traverse normally and just add val to existing val at each node.\\n\\t\\t\\t3. \\tKey exists: In this case, we need to replace the old value with val, so we find new key-old key and add it to all the nodes\\n\\nImplemenation details:\\n1. We wrap our Trie class with a hashmap to make MapSum class. This will help to have a universal map and a universal Trie.\\n2. An important detail is that value is stored at next level so make sure to move to next level and update its value and not current value.\\n\\nRefer code comments for more details.\\n\\n```\\nclass Trie{\\npublic: \\n    Trie* character[26];\\n    int s;\\n    \\n    Trie() \\n    {\\n        this->s = 0;\\n        for( int i = 0 ; i < 26 ; i++)\\n            this->character[i]= NULL;          \\n    }\\n};\\nclass MapSum {\\npublic:\\n    \\n    Trie* myTrie;\\n    unordered_map <string, int> map;\\n    \\n    MapSum() \\n    {\\n         myTrie = new Trie(); \\n    }\\n    \\n    void insert(string key, int val) {\\n        \\n        \\n        int diff = val;\\n        \\n\\t\\t//If key is already present we add the difference of old val and new val and not just the new val\\n        if(map.find(key) != map.end())\\n        {\\n            diff -= map[key];\\n        }\\n         //updates map if val is changed or adds a new pair if absent   \\n        map[key] = val;\\n        \\n        \\n        int len = key.length();\\n        Trie* currLevel = myTrie;\\n        \\n      \\n        \\n        for( int i = 0 ; i < len ; i++)\\n        {\\n\\t\\t//If the desired character is absent, we create a new level and add it and the val is added to this new level\\n            if(currLevel->character[key[i]-\\'a\\'] == NULL ) \\n            {\\n                 Trie* newNode = new Trie();\\n                 currLevel->character[key[i]-\\'a\\'] = newNode;  \\n                 currLevel = currLevel->character[key[i]-\\'a\\']; \\n                 currLevel->s = diff;  \\n            }\\n\\t\\t\\t//If desired character is present, just move to next level and update the value\\n            else\\n            {   \\n                currLevel = currLevel->character[key[i]-\\'a\\']; \\n                currLevel->s += diff; \\n            }\\n            \\n                  \\n        }   \\n    }\\n    \\n    int sum(string prefix) {\\n        \\n        int len = prefix.length();\\n        Trie* currLevel = myTrie;\\n\\n//Simple traversal to reach the last character node and get its value\\n        for( int i = 0 ; i < len ; i++)\\n        {\\n            if(currLevel->character[prefix[i]-\\'a\\']== NULL ) \\n               return 0;     \\n            currLevel = currLevel->character[prefix[i]-\\'a\\'];       \\n        }\\n        \\n        return currLevel->s;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Trie{\\npublic: \\n    Trie* character[26];\\n    int s;\\n    \\n    Trie() \\n    {\\n        this->s = 0;\\n        for( int i = 0 ; i < 26 ; i++)\\n            this->character[i]= NULL;          \\n    }\\n};\\nclass MapSum {\\npublic:\\n    \\n    Trie* myTrie;\\n    unordered_map <string, int> map;\\n    \\n    MapSum() \\n    {\\n         myTrie = new Trie(); \\n    }\\n    \\n    void insert(string key, int val) {\\n        \\n        \\n        int diff = val;\\n        \\n\\t\\t//If key is already present we add the difference of old val and new val and not just the new val\\n        if(map.find(key) != map.end())\\n        {\\n            diff -= map[key];\\n        }\\n         //updates map if val is changed or adds a new pair if absent   \\n        map[key] = val;\\n        \\n        \\n        int len = key.length();\\n        Trie* currLevel = myTrie;\\n        \\n      \\n        \\n        for( int i = 0 ; i < len ; i++)\\n        {\\n\\t\\t//If the desired character is absent, we create a new level and add it and the val is added to this new level\\n            if(currLevel->character[key[i]-\\'a\\'] == NULL ) \\n            {\\n                 Trie* newNode = new Trie();\\n                 currLevel->character[key[i]-\\'a\\'] = newNode;  \\n                 currLevel = currLevel->character[key[i]-\\'a\\']; \\n                 currLevel->s = diff;  \\n            }\\n\\t\\t\\t//If desired character is present, just move to next level and update the value\\n            else\\n            {   \\n                currLevel = currLevel->character[key[i]-\\'a\\']; \\n                currLevel->s += diff; \\n            }\\n            \\n                  \\n        }   \\n    }\\n    \\n    int sum(string prefix) {\\n        \\n        int len = prefix.length();\\n        Trie* currLevel = myTrie;\\n\\n//Simple traversal to reach the last character node and get its value\\n        for( int i = 0 ; i < len ; i++)\\n        {\\n            if(currLevel->character[prefix[i]-\\'a\\']== NULL ) \\n               return 0;     \\n            currLevel = currLevel->character[prefix[i]-\\'a\\'];       \\n        }\\n        \\n        return currLevel->s;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782675,
                "title": "swift-trie-solution-with-complexity-100",
                "content": "**Time: O(n), Space: O(m)** where n is the length of the input string, m is the size of all the inputs.\\nfeel free to add suggestions\\n```\\nclass TrieNode {\\n\\tvar totalSum: Int = 0\\n\\tvar charToNode = [Character: TrieNode]()\\n}\\n\\nclass MapSum {\\n    let root: TrieNode\\n\\tvar dict: [String: Int]\\n    \\n    init() {\\n        root = TrieNode()\\n        dict = [String: Int]()\\n    }\\n    \\n    func insert(_ key: String, _ val: Int) {\\n        let newSum = val - dict[key, default: 0]\\n        dict[key] = val\\n        \\n        var node = root\\n        node.totalSum += newSum\\n        for char in key {\\n            if node.charToNode[char] == nil {\\n                node.charToNode[char] = TrieNode()\\n            }\\n            node = node.charToNode[char]!\\n            node.totalSum += newSum\\n        }\\n    }\\n    \\n    func sum(_ prefix: String) -> Int {\\n        var node = root\\n        for char in prefix {\\n            if node.charToNode[char] == nil { return 0 }\\n            node = node.charToNode[char]!\\n        }\\n        \\n        return node.totalSum\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\n\\tvar totalSum: Int = 0\\n\\tvar charToNode = [Character: TrieNode]()\\n}\\n\\nclass MapSum {\\n    let root: TrieNode\\n\\tvar dict: [String: Int]\\n    \\n    init() {\\n        root = TrieNode()\\n        dict = [String: Int]()\\n    }\\n    \\n    func insert(_ key: String, _ val: Int) {\\n        let newSum = val - dict[key, default: 0]\\n        dict[key] = val\\n        \\n        var node = root\\n        node.totalSum += newSum\\n        for char in key {\\n            if node.charToNode[char] == nil {\\n                node.charToNode[char] = TrieNode()\\n            }\\n            node = node.charToNode[char]!\\n            node.totalSum += newSum\\n        }\\n    }\\n    \\n    func sum(_ prefix: String) -> Int {\\n        var node = root\\n        for char in prefix {\\n            if node.charToNode[char] == nil { return 0 }\\n            node = node.charToNode[char]!\\n        }\\n        \\n        return node.totalSum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766513,
                "title": "trie-4ms-code-article-to-help-you-understand-trie",
                "content": "**Status**: Accepted (4ms Code) [Beats 91% of submissions]\\n\\nIf you find hard in understanding Trie, \\nHere is an article to help you. [Article on Trie. General Template](https://leetcode.com/discuss/general-discussion/680706/article-on-trie-general-template-and-list-of-problems)\\n```\\nclass Trie{\\npublic:\\n    Trie* children[26];\\n    bool leaf;\\n    int value;\\n    Trie(){\\n        memset(children, NULL, sizeof(children));\\n        leaf = false;\\n        value = 0;\\n    }\\n};\\nclass MapSum {\\nprivate:\\n    Trie* root = new Trie();\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        Trie* temp = root;\\n        for(char c : key){\\n            if(!temp -> children[c - \\'a\\']){\\n                temp -> children[c - \\'a\\'] = new Trie();\\n            }\\n            temp = temp -> children[c - \\'a\\'];\\n        }\\n        temp -> value = val;\\n        temp -> leaf = true;\\n        \\n    }\\n\\t\\n    int helper(Trie* temp){\\n        int res = 0;\\n        if(temp -> leaf) res += temp -> value;\\n        for(int i = 0; i < 26; i++){\\n            if(temp -> children[i]){\\n                res = res + helper(temp -> children[i]);\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n    int sum(string prefix) {\\n        int res = 0;\\n        Trie* temp = root;\\n        for(char c : prefix){\\n            if(!temp -> children[c - \\'a\\']) return 0;\\n            temp = temp -> children[c - \\'a\\'];\\n        }\\n        return helper(temp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Trie{\\npublic:\\n    Trie* children[26];\\n    bool leaf;\\n    int value;\\n    Trie(){\\n        memset(children, NULL, sizeof(children));\\n        leaf = false;\\n        value = 0;\\n    }\\n};\\nclass MapSum {\\nprivate:\\n    Trie* root = new Trie();\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        Trie* temp = root;\\n        for(char c : key){\\n            if(!temp -> children[c - \\'a\\']){\\n                temp -> children[c - \\'a\\'] = new Trie();\\n            }\\n            temp = temp -> children[c - \\'a\\'];\\n        }\\n        temp -> value = val;\\n        temp -> leaf = true;\\n        \\n    }\\n\\t\\n    int helper(Trie* temp){\\n        int res = 0;\\n        if(temp -> leaf) res += temp -> value;\\n        for(int i = 0; i < 26; i++){\\n            if(temp -> children[i]){\\n                res = res + helper(temp -> children[i]);\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n    int sum(string prefix) {\\n        int res = 0;\\n        Trie* temp = root;\\n        for(char c : prefix){\\n            if(!temp -> children[c - \\'a\\']) return 0;\\n            temp = temp -> children[c - \\'a\\'];\\n        }\\n        return helper(temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750162,
                "title": "python3-trie-dfs-solution",
                "content": "```\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode) \\n        self.amount = 0\\n        \\nclass MapSum:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n        \\n    def insert(self, key: str, val: int) -> None:\\n        node = self.root\\n        for c in key:\\n            node = node.children[c]\\n        node.amount = val\\n    \\n    def dfs(self, node, res):\\n        res[0] += node.amount\\n        for n in node.children.values():\\n            self.dfs(n, res)\\n        \\n    def sum(self, prefix: str) -> int:\\n        node = self.root\\n        res = [0]\\n        for c in prefix:\\n            if c not in node.children: \\n                return 0\\n            node = node.children[c]\\n            \\n        self.dfs(node, res)\\n        return res[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode) \\n        self.amount = 0\\n        \\nclass MapSum:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n        \\n    def insert(self, key: str, val: int) -> None:\\n        node = self.root\\n        for c in key:\\n            node = node.children[c]\\n        node.amount = val\\n    \\n    def dfs(self, node, res):\\n        res[0] += node.amount\\n        for n in node.children.values():\\n            self.dfs(n, res)\\n        \\n    def sum(self, prefix: str) -> int:\\n        node = self.root\\n        res = [0]\\n        for c in prefix:\\n            if c not in node.children: \\n                return 0\\n            node = node.children[c]\\n            \\n        self.dfs(node, res)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744495,
                "title": "python-prefix-tree-hash-map-approach",
                "content": "**Notes:**\\n1. Give each node of the prefix tree an atribute ```total``` that represents the sum of all of the words that stem from that node.\\n2. Everytime you add a new word, update each node\\'s total value.  \\n3. Store the value of each word in a hash map ```d```.  If a word is seen again, instead of updating each node\\'s value by ```val``` update the node\\'s value by the difference between the word\\'s original value and new value ```val - d[word]```.  \\n```python\\nclass Node(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.children = {}\\n        self.total = 0\\n        \\nclass Trie(object):\\n    def __init__(self):\\n        self.root = Node(\\'*\\')\\n        self.root.children[\\'*\\'] = Node(None)\\n        self.d = {}\\n        \\n    def add(self, word : str, num : int) -> None:\\n        diff = num - self.d.get(word,0)\\n        curr = self.root\\n        for char in word:\\n            if char not in curr.children:\\n                curr.children[char] = Node(char)\\n            curr = curr.children[char]\\n            curr.total += diff\\n\\n        curr.children[\\'*\\'] = None\\n\\nclass MapSum:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.tree = Trie()\\n\\n    def insert(self, key: str, val: int) -> None:\\n        self.tree.add(key, val)\\n        self.tree.d[key] = val\\n\\n    def sum(self, prefix: str) -> int:\\n        curr = self.tree.root\\n        for char in prefix:\\n            if char in curr.children:\\n                curr = curr.children[char]\\n            else:\\n                return 0\\n        return curr.total\\n```",
                "solutionTags": [],
                "code": "```total```\n```d```\n```val```\n```val - d[word]```\n```python\\nclass Node(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.children = {}\\n        self.total = 0\\n        \\nclass Trie(object):\\n    def __init__(self):\\n        self.root = Node(\\'*\\')\\n        self.root.children[\\'*\\'] = Node(None)\\n        self.d = {}\\n        \\n    def add(self, word : str, num : int) -> None:\\n        diff = num - self.d.get(word,0)\\n        curr = self.root\\n        for char in word:\\n            if char not in curr.children:\\n                curr.children[char] = Node(char)\\n            curr = curr.children[char]\\n            curr.total += diff\\n\\n        curr.children[\\'*\\'] = None\\n\\nclass MapSum:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.tree = Trie()\\n\\n    def insert(self, key: str, val: int) -> None:\\n        self.tree.add(key, val)\\n        self.tree.d[key] = val\\n\\n    def sum(self, prefix: str) -> int:\\n        curr = self.tree.root\\n        for char in prefix:\\n            if char in curr.children:\\n                curr = curr.children[char]\\n            else:\\n                return 0\\n        return curr.total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661148,
                "title": "starts-with-trie-dfs-iterator-python-go-rust",
                "content": "starts with\\npy\\n```python []\\nclass MapSum:\\n    def __init__(self):\\n        self.d = {}\\n\\n    def insert(self, key: str, val: int) -> None:\\n        self.d[key] = val\\n\\n    def sum(self, prefix: str) -> int:\\n        return sum(self.d[s] for s in self.d if s.startswith(prefix))\\n```\\ngo\\n```golang []\\ntype MapSum struct {\\n    d map[string]int\\n}\\n\\nfunc Constructor() MapSum {\\n    return MapSum{map[string]int{}}\\n}\\n\\nfunc (this *MapSum) Insert(key string, val int)  {\\n    this.d[key] = val\\n}\\n\\nfunc (this *MapSum) Sum(prefix string) int {\\n    sum := 0\\n    for s, v := range this.d {\\n        if strings.HasPrefix(s, prefix) {\\n            sum += v\\n        }\\n    }\\n    return sum\\n}\\n```\\nrs\\n```rust []\\nuse std::collections::HashMap;\\nstruct MapSum {\\n    d: HashMap<String, i32>\\n}\\n\\nimpl MapSum {\\n    fn new() -> Self {\\n        Self {d: HashMap::new()}\\n    }\\n    \\n    fn insert(&mut self, key: String, val: i32) {\\n        self.d.insert(key, val);\\n    }\\n    \\n    fn sum(&self, prefix: String) -> i32 {\\n        self.d.keys().filter(|s| s.starts_with(&prefix)).map(|s| self.d[s]).sum()\\n    }\\n}\\n```\\n\\ntrie dfs\\npy\\n```python []\\nclass MapSum(dict):\\n    def __init__(self):\\n        self.val, self.next = 0, {}\\n\\n    def insert(self, key: str, val: int) -> None:\\n        reduce(lambda t, c: t.next.setdefault(c, MapSum()), key, self).val = val\\n\\n    def sum(self, prefix: str) -> int:\\n        dfs = lambda t: t.val + sum(map(dfs, t.next.values()))\\n        try:\\n            return dfs(reduce(lambda t, c: t.next[c], prefix, self))\\n        except:\\n            return 0\\n```\\n```python []\\nclass MapSum:\\n    def __init__(self):\\n        self.d = {}\\n\\n    def insert(self, key: str, val: int) -> None:\\n        t = self.d\\n        for c in key:\\n            if c not in t:\\n                t[c] = {}\\n            t = t[c] \\n        t[\\'val\\'] = val          \\n\\n    def sum(self, prefix: str) -> int:\\n        t = self.d\\n        for c in prefix:\\n            if c not in t:\\n                return 0        \\n            t = t[c]\\n        ans = 0\\n        def dfs(t):\\n            for c in t:\\n                if c == \\'val\\':\\n                    nonlocal ans\\n                    ans += t[c] \\n                else:\\n                    dfs(t[c])   \\n        dfs(t)\\n        return ans\\n```\\ngo\\n```golang []\\ntype MapSum struct {\\n    val int\\n    next map[rune]*MapSum\\n}\\n\\nfunc Constructor() MapSum {\\n    return MapSum{next: map[rune]*MapSum{}}\\n}\\n\\nfunc (this *MapSum) Insert(key string, val int)  {\\n    for _, c := range key {\\n        if _, ok := this.next[c]; !ok {\\n            this.next[c] = &MapSum{next: map[rune]*MapSum{}}\\n        } \\n        this = this.next[c]\\n    }\\n    this.val = val\\n}\\n\\nfunc (this *MapSum) Sum(prefix string) int {\\n    for _, c := range prefix {\\n        if _, ok := this.next[c]; !ok {\\n            return 0\\n        }\\n        this = this.next[c]\\n    }\\n    var dfs func(*MapSum) int; dfs = func(t *MapSum) (res int) {\\n        res += t.val\\n        for _, v := range t.next {\\n            res += dfs(v)\\n        }\\n        return\\n    }\\n    return dfs(this)\\n}\\n```\\n```golang []\\ntype MapSum struct {\\n    val int\\n    next [26]*MapSum\\n}\\n\\nfunc Constructor() MapSum {\\n    return MapSum{next: [26]*MapSum{}}\\n}\\n\\nfunc (this *MapSum) Insert(key string, val int)  {\\n    for _, c := range key {\\n        c := int(c - \\'a\\')\\n        if this.next[c] == nil {\\n            this.next[c] = &MapSum{next: [26]*MapSum{}}\\n        } \\n        this = this.next[c]\\n    }\\n    this.val = val\\n}\\n\\nfunc (this *MapSum) Sum(prefix string) int {\\n    for _, c := range prefix {\\n        c := int(c - \\'a\\')\\n        if this.next[c] == nil {\\n            return 0\\n        }\\n        this = this.next[c]\\n    }\\n    ans := 0\\n    var dfs func(*MapSum); dfs = func(t *MapSum) {\\n        ans += t.val\\n        for _, v := range t.next {\\n            if v != nil {\\n                dfs(v)\\n            }\\n        }\\n    }\\n    dfs(this)\\n    return ans\\n}\\n```\\nrs\\n```rust []\\n#[derive(Default)]\\nstruct MapSum {\\n    val: i32,\\n    next: [Option<Box<MapSum>>; 26]\\n}\\n\\nimpl MapSum {\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n    \\n    fn insert(&mut self, key: String, val: i32) {\\n        key.bytes().fold(self, |t, c| t.next[c as usize - 97].get_or_insert(Box::new(MapSum::new()))).val = val;\\n    }\\n    \\n    fn sum(&self, prefix: String) -> i32 {\\n        fn dfs(t: &MapSum) -> i32 {t.val + t.next.iter().filter(|r| r.is_some()).map(|r| dfs(r.as_ref().unwrap())).sum::<i32>()}\\n        std::panic::catch_unwind(|| dfs(prefix.bytes().fold(self, |t, c| t.next[c as usize - 97].as_ref().unwrap()))).unwrap_or(0)\\n    }\\n}\\n```\\n```rust []\\nuse std::collections::HashMap;\\n#[derive(Default)]\\nstruct MapSum {\\n    val: i32,\\n    next: HashMap<u8, MapSum>\\n}\\n\\nimpl MapSum {\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n    \\n    fn insert(&mut self, key: String, val: i32) {\\n        let mut t = self;\\n        for c in key.bytes() {\\n            if !t.next.contains_key(&c) {\\n                t.next.insert(c, MapSum::new());\\n            }\\n            t = t.next.get_mut(&c).unwrap();\\n        }\\n        t.val = val;\\n    }\\n    \\n    fn sum(&self, prefix: String) -> i32 {\\n        let mut t = self;\\n        for c in prefix.bytes() {\\n            if !t.next.contains_key(&c) {\\n                return 0\\n            }\\n            t = &t.next[&c];\\n        }\\n        fn dfs(t: &MapSum) -> i32 {\\n            t.val + t.next.values().map(dfs).sum::<i32>()\\n        }\\n        dfs(t)\\n    }\\n}\\n```\\n```rust []\\n#[derive(Default)]\\nstruct MapSum {\\n    val: i32,\\n    next: [Option<Box<MapSum>>; 26]\\n}\\n\\nimpl MapSum {\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n    \\n    fn insert(&mut self, key: String, val: i32) {\\n        let mut t = self;\\n        for c in key.bytes() {\\n            t = t.next[c as usize - 97].get_or_insert(Box::new(MapSum::new()))\\n        }\\n        t.val = val;\\n    }\\n    \\n    fn sum(&self, prefix: String) -> i32 {\\n        let mut t = self;\\n        for c in prefix.bytes() {\\n            if let Some(next) = t.next[c as usize - 97].as_ref() {\\n                t = next;\\n            } else {\\n                return 0\\n            }\\n        }\\n        fn dfs(t: &MapSum) -> i32 {\\n            t.val + t.next.iter().filter(|r| r.is_some()).map(|r| dfs(r.as_ref().unwrap())).sum::<i32>()\\n        }\\n        dfs(t)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Rust"
                ],
                "code": "```python []\\nclass MapSum:\\n    def __init__(self):\\n        self.d = {}\\n\\n    def insert(self, key: str, val: int) -> None:\\n        self.d[key] = val\\n\\n    def sum(self, prefix: str) -> int:\\n        return sum(self.d[s] for s in self.d if s.startswith(prefix))\\n```\n```golang []\\ntype MapSum struct {\\n    d map[string]int\\n}\\n\\nfunc Constructor() MapSum {\\n    return MapSum{map[string]int{}}\\n}\\n\\nfunc (this *MapSum) Insert(key string, val int)  {\\n    this.d[key] = val\\n}\\n\\nfunc (this *MapSum) Sum(prefix string) int {\\n    sum := 0\\n    for s, v := range this.d {\\n        if strings.HasPrefix(s, prefix) {\\n            sum += v\\n        }\\n    }\\n    return sum\\n}\\n```\n```rust []\\nuse std::collections::HashMap;\\nstruct MapSum {\\n    d: HashMap<String, i32>\\n}\\n\\nimpl MapSum {\\n    fn new() -> Self {\\n        Self {d: HashMap::new()}\\n    }\\n    \\n    fn insert(&mut self, key: String, val: i32) {\\n        self.d.insert(key, val);\\n    }\\n    \\n    fn sum(&self, prefix: String) -> i32 {\\n        self.d.keys().filter(|s| s.starts_with(&prefix)).map(|s| self.d[s]).sum()\\n    }\\n}\\n```\n```python []\\nclass MapSum(dict):\\n    def __init__(self):\\n        self.val, self.next = 0, {}\\n\\n    def insert(self, key: str, val: int) -> None:\\n        reduce(lambda t, c: t.next.setdefault(c, MapSum()), key, self).val = val\\n\\n    def sum(self, prefix: str) -> int:\\n        dfs = lambda t: t.val + sum(map(dfs, t.next.values()))\\n        try:\\n            return dfs(reduce(lambda t, c: t.next[c], prefix, self))\\n        except:\\n            return 0\\n```\n```python []\\nclass MapSum:\\n    def __init__(self):\\n        self.d = {}\\n\\n    def insert(self, key: str, val: int) -> None:\\n        t = self.d\\n        for c in key:\\n            if c not in t:\\n                t[c] = {}\\n            t = t[c] \\n        t[\\'val\\'] = val          \\n\\n    def sum(self, prefix: str) -> int:\\n        t = self.d\\n        for c in prefix:\\n            if c not in t:\\n                return 0        \\n            t = t[c]\\n        ans = 0\\n        def dfs(t):\\n            for c in t:\\n                if c == \\'val\\':\\n                    nonlocal ans\\n                    ans += t[c] \\n                else:\\n                    dfs(t[c])   \\n        dfs(t)\\n        return ans\\n```\n```golang []\\ntype MapSum struct {\\n    val int\\n    next map[rune]*MapSum\\n}\\n\\nfunc Constructor() MapSum {\\n    return MapSum{next: map[rune]*MapSum{}}\\n}\\n\\nfunc (this *MapSum) Insert(key string, val int)  {\\n    for _, c := range key {\\n        if _, ok := this.next[c]; !ok {\\n            this.next[c] = &MapSum{next: map[rune]*MapSum{}}\\n        } \\n        this = this.next[c]\\n    }\\n    this.val = val\\n}\\n\\nfunc (this *MapSum) Sum(prefix string) int {\\n    for _, c := range prefix {\\n        if _, ok := this.next[c]; !ok {\\n            return 0\\n        }\\n        this = this.next[c]\\n    }\\n    var dfs func(*MapSum) int; dfs = func(t *MapSum) (res int) {\\n        res += t.val\\n        for _, v := range t.next {\\n            res += dfs(v)\\n        }\\n        return\\n    }\\n    return dfs(this)\\n}\\n```\n```golang []\\ntype MapSum struct {\\n    val int\\n    next [26]*MapSum\\n}\\n\\nfunc Constructor() MapSum {\\n    return MapSum{next: [26]*MapSum{}}\\n}\\n\\nfunc (this *MapSum) Insert(key string, val int)  {\\n    for _, c := range key {\\n        c := int(c - \\'a\\')\\n        if this.next[c] == nil {\\n            this.next[c] = &MapSum{next: [26]*MapSum{}}\\n        } \\n        this = this.next[c]\\n    }\\n    this.val = val\\n}\\n\\nfunc (this *MapSum) Sum(prefix string) int {\\n    for _, c := range prefix {\\n        c := int(c - \\'a\\')\\n        if this.next[c] == nil {\\n            return 0\\n        }\\n        this = this.next[c]\\n    }\\n    ans := 0\\n    var dfs func(*MapSum); dfs = func(t *MapSum) {\\n        ans += t.val\\n        for _, v := range t.next {\\n            if v != nil {\\n                dfs(v)\\n            }\\n        }\\n    }\\n    dfs(this)\\n    return ans\\n}\\n```\n```rust []\\n#[derive(Default)]\\nstruct MapSum {\\n    val: i32,\\n    next: [Option<Box<MapSum>>; 26]\\n}\\n\\nimpl MapSum {\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n    \\n    fn insert(&mut self, key: String, val: i32) {\\n        key.bytes().fold(self, |t, c| t.next[c as usize - 97].get_or_insert(Box::new(MapSum::new()))).val = val;\\n    }\\n    \\n    fn sum(&self, prefix: String) -> i32 {\\n        fn dfs(t: &MapSum) -> i32 {t.val + t.next.iter().filter(|r| r.is_some()).map(|r| dfs(r.as_ref().unwrap())).sum::<i32>()}\\n        std::panic::catch_unwind(|| dfs(prefix.bytes().fold(self, |t, c| t.next[c as usize - 97].as_ref().unwrap()))).unwrap_or(0)\\n    }\\n}\\n```\n```rust []\\nuse std::collections::HashMap;\\n#[derive(Default)]\\nstruct MapSum {\\n    val: i32,\\n    next: HashMap<u8, MapSum>\\n}\\n\\nimpl MapSum {\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n    \\n    fn insert(&mut self, key: String, val: i32) {\\n        let mut t = self;\\n        for c in key.bytes() {\\n            if !t.next.contains_key(&c) {\\n                t.next.insert(c, MapSum::new());\\n            }\\n            t = t.next.get_mut(&c).unwrap();\\n        }\\n        t.val = val;\\n    }\\n    \\n    fn sum(&self, prefix: String) -> i32 {\\n        let mut t = self;\\n        for c in prefix.bytes() {\\n            if !t.next.contains_key(&c) {\\n                return 0\\n            }\\n            t = &t.next[&c];\\n        }\\n        fn dfs(t: &MapSum) -> i32 {\\n            t.val + t.next.values().map(dfs).sum::<i32>()\\n        }\\n        dfs(t)\\n    }\\n}\\n```\n```rust []\\n#[derive(Default)]\\nstruct MapSum {\\n    val: i32,\\n    next: [Option<Box<MapSum>>; 26]\\n}\\n\\nimpl MapSum {\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n    \\n    fn insert(&mut self, key: String, val: i32) {\\n        let mut t = self;\\n        for c in key.bytes() {\\n            t = t.next[c as usize - 97].get_or_insert(Box::new(MapSum::new()))\\n        }\\n        t.val = val;\\n    }\\n    \\n    fn sum(&self, prefix: String) -> i32 {\\n        let mut t = self;\\n        for c in prefix.bytes() {\\n            if let Some(next) = t.next[c as usize - 97].as_ref() {\\n                t = next;\\n            } else {\\n                return 0\\n            }\\n        }\\n        fn dfs(t: &MapSum) -> i32 {\\n            t.val + t.next.iter().filter(|r| r.is_some()).map(|r| dfs(r.as_ref().unwrap())).sum::<i32>()\\n        }\\n        dfs(t)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621589,
                "title": "c-simple-solution",
                "content": "```\\npublic class MapSum {\\n    class TrieNode\\n    {\\n        public TrieNode[] children = new TrieNode[26];\\n        public bool isEnd;\\n        public int sum;\\n    }\\n    \\n    Dictionary<string,int> dict = new Dictionary<string,int>();\\n    TrieNode root = new TrieNode();\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        \\n    }\\n    \\n    public void Insert(string key, int val) \\n    {\\n        int prev = 0;\\n        \\n        if(!dict.ContainsKey(key))\\n            dict.Add(key,val);\\n        else\\n        {\\n            prev = dict[key];\\n            dict[key] = val;\\n        }\\n        \\n        TrieNode cur = root;\\n        \\n        foreach(var c in key)\\n        {\\n            if(cur.children[c-\\'a\\']==null)\\n                cur.children[c-\\'a\\'] = new TrieNode();\\n            \\n            cur.sum+=val-prev;\\n            cur = cur.children[c-\\'a\\'];\\n        }\\n        cur.sum+=val-prev;\\n        cur.isEnd=true;\\n    }\\n    \\n    public int Sum(string prefix) {\\n        TrieNode cur = root;\\n        \\n        foreach(var c in prefix)\\n        {\\n            if(cur.children[c-\\'a\\']==null)\\n                return 0;\\n            \\n            cur = cur.children[c-\\'a\\'];\\n        }\\n        return cur.sum;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.Insert(key,val);\\n * int param_2 = obj.Sum(prefix);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\npublic class MapSum {\\n    class TrieNode\\n    {\\n        public TrieNode[] children = new TrieNode[26];\\n        public bool isEnd;\\n        public int sum;\\n    }\\n    \\n    Dictionary<string,int> dict = new Dictionary<string,int>();\\n    TrieNode root = new TrieNode();\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        \\n    }\\n    \\n    public void Insert(string key, int val) \\n    {\\n        int prev = 0;\\n        \\n        if(!dict.ContainsKey(key))\\n            dict.Add(key,val);\\n        else\\n        {\\n            prev = dict[key];\\n            dict[key] = val;\\n        }\\n        \\n        TrieNode cur = root;\\n        \\n        foreach(var c in key)\\n        {\\n            if(cur.children[c-\\'a\\']==null)\\n                cur.children[c-\\'a\\'] = new TrieNode();\\n            \\n            cur.sum+=val-prev;\\n            cur = cur.children[c-\\'a\\'];\\n        }\\n        cur.sum+=val-prev;\\n        cur.isEnd=true;\\n    }\\n    \\n    public int Sum(string prefix) {\\n        TrieNode cur = root;\\n        \\n        foreach(var c in prefix)\\n        {\\n            if(cur.children[c-\\'a\\']==null)\\n                return 0;\\n            \\n            cur = cur.children[c-\\'a\\'];\\n        }\\n        return cur.sum;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.Insert(key,val);\\n * int param_2 = obj.Sum(prefix);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 569282,
                "title": "c-solution-using-trie",
                "content": "The idea is very simple, use trie to store the keys, also add an additional sum parameter in the trieNode to store the sums in the nodes itself, so  that retrieval is made easy by just traversing the trie till prefix length.\\n\\nFor the case when we need to overwrite the key, value pair, we just check after insertion if the key was inserted previously, and if it was then iterate one more time to overwrite the sum values among all nodes.\\n\\nTime complexity:\\nFor insert is  ```O(strlen(key))```\\nFor sum is  ```O(strlen(prefix))```\\n\\nSpace Complexity:  ``` O(strlen(key)) ```\\n\\nHave a look at the code below for more understanding, I\\'ve implemented a static version of  a trie, don\\'t get confused by it, you an implement it in the way you are comfortable in.\\n\\n```\\nstruct trieNode\\n{\\n    bool isEnd;\\n    int sum;\\n    trieNode *child[26];\\n};\\n\\ntrieNode *root;\\n\\ntrieNode nodePool[50005];\\nint poolCount;\\n\\ntrieNode *getNode()\\n{\\n    trieNode *newNode = &nodePool[poolCount++];\\n    newNode->isEnd = false;\\n    newNode->sum = 0;\\n    for (int i = 0; i < 26; i++)\\n        newNode->child[i] = NULL;\\n    return newNode;\\n}\\n\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() \\n    {\\n        poolCount = 0;\\n        root = getNode();\\n    }\\n    \\n    void insert(string key, int val) \\n    {\\n        trieNode *temp = root;\\n        int index;\\n        for (int i = 0; key[i] != \\'\\\\0\\'; i++)\\n        {\\n            index = key[i] - \\'a\\';\\n            if (temp->child[index] == NULL)\\n            {\\n                temp->child[index] = getNode();\\n            }\\n            temp = temp->child[index];\\n            temp->sum += val;\\n        }\\n        if (temp->isEnd)\\n        {\\n            temp = root;\\n            for (int i = 0; key[i] != \\'\\\\0\\'; i++)\\n            {\\n                index = key[i] - \\'a\\';\\n                temp = temp->child[index];\\n                temp->sum = val;\\n            }\\n        }\\n        else\\n            temp->isEnd = true;\\n    }\\n    \\n    int sum(string prefix) \\n    {\\n        trieNode *temp = root;\\n        int index;\\n        for (int i = 0; prefix[i] != \\'\\\\0\\'; i++)\\n        {\\n            index = prefix[i] - \\'a\\';\\n            if (temp->child[index] == NULL)\\n                return 0;\\n            temp = temp->child[index];\\n        }\\n        if (temp)\\n            return temp->sum;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```O(strlen(key))```\n```O(strlen(prefix))```\n``` O(strlen(key)) ```\n```\\nstruct trieNode\\n{\\n    bool isEnd;\\n    int sum;\\n    trieNode *child[26];\\n};\\n\\ntrieNode *root;\\n\\ntrieNode nodePool[50005];\\nint poolCount;\\n\\ntrieNode *getNode()\\n{\\n    trieNode *newNode = &nodePool[poolCount++];\\n    newNode->isEnd = false;\\n    newNode->sum = 0;\\n    for (int i = 0; i < 26; i++)\\n        newNode->child[i] = NULL;\\n    return newNode;\\n}\\n\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() \\n    {\\n        poolCount = 0;\\n        root = getNode();\\n    }\\n    \\n    void insert(string key, int val) \\n    {\\n        trieNode *temp = root;\\n        int index;\\n        for (int i = 0; key[i] != \\'\\\\0\\'; i++)\\n        {\\n            index = key[i] - \\'a\\';\\n            if (temp->child[index] == NULL)\\n            {\\n                temp->child[index] = getNode();\\n            }\\n            temp = temp->child[index];\\n            temp->sum += val;\\n        }\\n        if (temp->isEnd)\\n        {\\n            temp = root;\\n            for (int i = 0; key[i] != \\'\\\\0\\'; i++)\\n            {\\n                index = key[i] - \\'a\\';\\n                temp = temp->child[index];\\n                temp->sum = val;\\n            }\\n        }\\n        else\\n            temp->isEnd = true;\\n    }\\n    \\n    int sum(string prefix) \\n    {\\n        trieNode *temp = root;\\n        int index;\\n        for (int i = 0; prefix[i] != \\'\\\\0\\'; i++)\\n        {\\n            index = prefix[i] - \\'a\\';\\n            if (temp->child[index] == NULL)\\n                return 0;\\n            temp = temp->child[index];\\n        }\\n        if (temp)\\n            return temp->sum;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563935,
                "title": "javascript-accepted-solution",
                "content": "Runtime: 60 ms, faster than 39.33% of JavaScript online submissions for Map Sum Pairs.\\nMemory Usage: 36.2 MB, less than 100.00% of JavaScript online submissions for Map Sum Pairs.\\n\\n```\\nfunction TrieNode(char = \\'\\', value = 0) {\\n    this.char = char;\\n    this.value = value;\\n    this.children = new Map;\\n}\\n\\nTrieNode.prototype.sum = function() {\\n    let sum = this.value;\\n    \\n    for (let entry of this.children) {\\n        sum += entry[1].sum();\\n    }\\n    \\n    return sum;\\n};\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar MapSum = function() {\\n    this.root = new TrieNode();\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} val\\n * @return {void}\\n */\\nMapSum.prototype.insert = function(key, val) {\\n    let i = 0;\\n    let node = this.root;\\n    while (i < key.length) {\\n        const c = key.charAt(i);\\n        \\n        if (!node.children.has(c)) {\\n            node.children.set(c, new TrieNode(c));\\n        }\\n        \\n        node = node.children.get(c);\\n        i++;\\n    }\\n    \\n    node.value = val;\\n};\\n\\n/** \\n * @param {string} prefix\\n * @return {number}\\n */\\nMapSum.prototype.sum = function(prefix) {\\n    let i = 0;\\n    let node = this.root;\\n    \\n    while (i < prefix.length) {\\n        const c = prefix.charAt(i);\\n        \\n        if (!node.children.has(c)) {\\n            return 0;\\n        }\\n        \\n        node = node.children.get(c);\\n        i++;\\n    }\\n    \\n    return node.sum();\\n};\\n\\n/** \\n * Your MapSum object will be instantiated and called as such:\\n * var obj = new MapSum()\\n * obj.insert(key,val)\\n * var param_2 = obj.sum(prefix)\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nfunction TrieNode(char = \\'\\', value = 0) {\\n    this.char = char;\\n    this.value = value;\\n    this.children = new Map;\\n}\\n\\nTrieNode.prototype.sum = function() {\\n    let sum = this.value;\\n    \\n    for (let entry of this.children) {\\n        sum += entry[1].sum();\\n    }\\n    \\n    return sum;\\n};\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar MapSum = function() {\\n    this.root = new TrieNode();\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} val\\n * @return {void}\\n */\\nMapSum.prototype.insert = function(key, val) {\\n    let i = 0;\\n    let node = this.root;\\n    while (i < key.length) {\\n        const c = key.charAt(i);\\n        \\n        if (!node.children.has(c)) {\\n            node.children.set(c, new TrieNode(c));\\n        }\\n        \\n        node = node.children.get(c);\\n        i++;\\n    }\\n    \\n    node.value = val;\\n};\\n\\n/** \\n * @param {string} prefix\\n * @return {number}\\n */\\nMapSum.prototype.sum = function(prefix) {\\n    let i = 0;\\n    let node = this.root;\\n    \\n    while (i < prefix.length) {\\n        const c = prefix.charAt(i);\\n        \\n        if (!node.children.has(c)) {\\n            return 0;\\n        }\\n        \\n        node = node.children.get(c);\\n        i++;\\n    }\\n    \\n    return node.sum();\\n};\\n\\n/** \\n * Your MapSum object will be instantiated and called as such:\\n * var obj = new MapSum()\\n * obj.insert(key,val)\\n * var param_2 = obj.sum(prefix)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 558692,
                "title": "4ms-runtime-c-trie-and-map",
                "content": "class MapSum {\\n\\n    struct TrieNode {\\n        struct TrieNode* child[26];\\n        int val;\\n        TrieNode() {\\n            for (int i = 0; i < 26; i++)\\n                child[i] = NULL;\\n            val = 0;\\n        }\\n    };\\n    \\n    struct TrieNode *root;\\n    map<string, int>hm;\\n\\t\\npublic:\\n\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n      root = new TrieNode();  \\n    }\\n    \\n    void insert(string key, int val) {\\n        TrieNode* p = root;\\n        \\n        if (!p) return;\\n        \\n        int n = key.length();\\n        int sub = 0;\\n        if(hm.find(key) != hm.end())\\n            sub = hm[key];\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!p->child[key[i]-\\'a\\'])\\n                p->child[key[i]-\\'a\\'] = new TrieNode();\\n            p = p->child[key[i]-\\'a\\'];\\n            p->val += val;\\n            p->val -= sub;\\n        }\\n        \\n        hm[key] = val;\\n    }\\n    \\n    void sumUtil(TrieNode*p , string prefix, int i, int &ans) {\\n        if (!p) return;\\n        \\n        if (i == prefix.length()) {\\n            ans += p->val;\\n            return;\\n        }\\n            \\n        if (!p->child[prefix[i]-\\'a\\'])\\n            return; \\n            \\n        sumUtil(p->child[prefix[i]-\\'a\\'], prefix, i+1, ans);\\n    }\\n    \\n    int sum(string prefix) {\\n        TrieNode* p = root;\\n        int ans = 0;\\n        sumUtil(p, prefix, 0, ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class MapSum {\\n\\n    struct TrieNode {\\n        struct TrieNode* child[26];\\n        int val;\\n        TrieNode() {\\n            for (int i = 0; i < 26; i++)\\n                child[i] = NULL;\\n            val = 0;\\n        }\\n    };\\n    \\n    struct TrieNode *root;\\n    map<string, int>hm;\\n\\t\\npublic:\\n\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n      root = new TrieNode();  \\n    }\\n    \\n    void insert(string key, int val) {\\n        TrieNode* p = root;\\n        \\n        if (!p) return;\\n        \\n        int n = key.length();\\n        int sub = 0;\\n        if(hm.find(key) != hm.end())\\n            sub = hm[key];\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!p->child[key[i]-\\'a\\'])\\n                p->child[key[i]-\\'a\\'] = new TrieNode();\\n            p = p->child[key[i]-\\'a\\'];\\n            p->val += val;\\n            p->val -= sub;\\n        }\\n        \\n        hm[key] = val;\\n    }\\n    \\n    void sumUtil(TrieNode*p , string prefix, int i, int &ans) {\\n        if (!p) return;\\n        \\n        if (i == prefix.length()) {\\n            ans += p->val;\\n            return;\\n        }\\n            \\n        if (!p->child[prefix[i]-\\'a\\'])\\n            return; \\n            \\n        sumUtil(p->child[prefix[i]-\\'a\\'], prefix, i+1, ans);\\n    }\\n    \\n    int sum(string prefix) {\\n        TrieNode* p = root;\\n        int ans = 0;\\n        sumUtil(p, prefix, 0, ans);\\n        return ans;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 543449,
                "title": "python-3-solution",
                "content": "\\tclass MapSum:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tInitialize your data structure here.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tself.d = {}\\n\\n\\t\\tdef insert(self, key: str, val: int) -> None:\\n\\t\\t\\tself.d[key] = val\\n\\n\\t\\tdef sum(self, prefix: str) -> int:        \\n\\t\\t\\tself.res = 0\\n\\t\\t\\tfor k in self.d.keys():\\n\\t\\t\\t\\tif k.startswith(prefix):\\n\\t\\t\\t\\t\\tself.res += self.d[k]\\n\\t\\t\\treturn self.res\\n\\n\\n\\t# Your MapSum object will be instantiated and called as such:\\n\\t# obj = MapSum()\\n\\t# obj.insert(key,val)\\n\\t# param_2 = obj.sum(prefix)",
                "solutionTags": [],
                "code": "\\tclass MapSum:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tInitialize your data structure here.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tself.d = {}\\n\\n\\t\\tdef insert(self, key: str, val: int) -> None:\\n\\t\\t\\tself.d[key] = val\\n\\n\\t\\tdef sum(self, prefix: str) -> int:        \\n\\t\\t\\tself.res = 0\\n\\t\\t\\tfor k in self.d.keys():\\n\\t\\t\\t\\tif k.startswith(prefix):\\n\\t\\t\\t\\t\\tself.res += self.d[k]\\n\\t\\t\\treturn self.res\\n\\n\\n\\t# Your MapSum object will be instantiated and called as such:\\n\\t# obj = MapSum()\\n\\t# obj.insert(key,val)\\n\\t# param_2 = obj.sum(prefix)",
                "codeTag": "Java"
            },
            {
                "id": 495392,
                "title": "hashmap-solution-in-python-in-o-n-time-with-comments",
                "content": "```\\nclass MapSum:\\n    def __init__(self):\\n        self.data = dict()\\n    \\n\\t# a dictionary in python already works this way\\n    def insert(self, key: str, val: int) -> None:\\n        self.data[key] = val\\n\\n\\t# search each key for the prefix and add to a running total\\n    def sum(self, prefix: str) -> int:\\n        keys = self.data.keys()\\n        summation = 0\\n        \\n        for k in keys:\\n            # print(prefix)\\n            # print(k[:len(prefix)])\\n            \\n            if k[:len(prefix)] == prefix:\\n                summation += self.data[k]\\n                \\n        return summation\\n```\\n\\nThis feels like cheating, but was listen in the accepted solutions section. The insert function of a hashmap should already behave the way the problem definition dictates. The sum function simply checks all keys for the prefix and keeps a running total. \\n\\nSince the problem lacked any preference for optimization of summation over insert, I took the easy out. If I knew that sum was going to experience heavy use, I would have opted for a treelike structure that optimizes the search for the prefix. \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass MapSum:\\n    def __init__(self):\\n        self.data = dict()\\n    \\n\\t# a dictionary in python already works this way\\n    def insert(self, key: str, val: int) -> None:\\n        self.data[key] = val\\n\\n\\t# search each key for the prefix and add to a running total\\n    def sum(self, prefix: str) -> int:\\n        keys = self.data.keys()\\n        summation = 0\\n        \\n        for k in keys:\\n            # print(prefix)\\n            # print(k[:len(prefix)])\\n            \\n            if k[:len(prefix)] == prefix:\\n                summation += self.data[k]\\n                \\n        return summation\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491552,
                "title": "trie-based-easy-to-understand-solution",
                "content": "```\\nclass MapSum {\\npublic:\\n     MapSum() {\\n        root = new TrieNode();\\n         root->sum=0;\\n         m1.clear();\\n    }\\n    map<string,int> m1;\\n    void insert(string key, int val){\\n        \\n      \\n       bool exist=find(root,key);\\n        if(!exist){\\n            buildTrie(key,val);\\n        }\\n        else{\\n            buildTrie(key,val-m1[key]);\\n        }\\n        m1[key]=val;\\n    }\\n\\n\\n    \\n    int sum(string prefix) {\\n        return find1(root,prefix);  \\n    }   \\n    \\n    \\n    \\n    \\n   \\n    /** Initialize your data structure here. */\\n    struct TrieNode{\\n        bool isWord;\\n        int sum;\\n        TrieNode *next[26];\\n        TrieNode():isWord(false){\\n          \\n            memset(next,NULL,sizeof(next));\\n        }\\n    };\\n    TrieNode *root;\\n        int find1(TrieNode *p,string s){\\n        for(auto c :s){\\n            if(p->next[c-\\'a\\'])\\n                p = p->next[c-\\'a\\'];\\n            else\\n                return 0;\\n        }\\n            \\n                return p->sum;\\n        \\n    }\\n    void buildTrie(string s,int key){\\n        TrieNode *p=root;\\n        for(auto c:s){\\n            if(!(p->next[c-\\'a\\'])){\\n                p->next[c-\\'a\\']=new TrieNode();\\n                p->next[c-\\'a\\']->sum=0;\\n            }\\n             p->sum += key;\\n            p=p->next[c-\\'a\\'];\\n           \\n        }\\n        p->sum += key;\\n        p->isWord=true;\\n    }\\n    \\n    bool find(TrieNode *p,string s){\\n        for(auto c :s)\\n            if(p->next[c-\\'a\\'])\\n                p = p->next[c-\\'a\\'];\\n            else\\n                return false;\\n        return p->isWord;\\n    }\\n\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\npublic:\\n     MapSum() {\\n        root = new TrieNode();\\n         root->sum=0;\\n         m1.clear();\\n    }\\n    map<string,int> m1;\\n    void insert(string key, int val){\\n        \\n      \\n       bool exist=find(root,key);\\n        if(!exist){\\n            buildTrie(key,val);\\n        }\\n        else{\\n            buildTrie(key,val-m1[key]);\\n        }\\n        m1[key]=val;\\n    }\\n\\n\\n    \\n    int sum(string prefix) {\\n        return find1(root,prefix);  \\n    }   \\n    \\n    \\n    \\n    \\n   \\n    /** Initialize your data structure here. */\\n    struct TrieNode{\\n        bool isWord;\\n        int sum;\\n        TrieNode *next[26];\\n        TrieNode():isWord(false){\\n          \\n            memset(next,NULL,sizeof(next));\\n        }\\n    };\\n    TrieNode *root;\\n        int find1(TrieNode *p,string s){\\n        for(auto c :s){\\n            if(p->next[c-\\'a\\'])\\n                p = p->next[c-\\'a\\'];\\n            else\\n                return 0;\\n        }\\n            \\n                return p->sum;\\n        \\n    }\\n    void buildTrie(string s,int key){\\n        TrieNode *p=root;\\n        for(auto c:s){\\n            if(!(p->next[c-\\'a\\'])){\\n                p->next[c-\\'a\\']=new TrieNode();\\n                p->next[c-\\'a\\']->sum=0;\\n            }\\n             p->sum += key;\\n            p=p->next[c-\\'a\\'];\\n           \\n        }\\n        p->sum += key;\\n        p->isWord=true;\\n    }\\n    \\n    bool find(TrieNode *p,string s){\\n        for(auto c :s)\\n            if(p->next[c-\\'a\\'])\\n                p = p->next[c-\\'a\\'];\\n            else\\n                return false;\\n        return p->isWord;\\n    }\\n\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum* obj = new MapSum();\\n * obj->insert(key,val);\\n * int param_2 = obj->sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471819,
                "title": "java-trie-clear-solution-100-time",
                "content": "```\\nclass MapSum {\\n\\n    HashMap<String, Integer> map;\\n    TrieNode root;\\n    public MapSum() {\\n        map = new HashMap<>();\\n        root = new TrieNode();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        int oldValue = map.getOrDefault(key, 0);\\n        TrieNode node = root;\\n        for (char c : key.toCharArray()) {\\n            if (node.child[c - \\'a\\'] == null) {\\n                node.child[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node.child[c - \\'a\\'];\\n            node.value += val - oldValue;\\n        }        \\n        map.put(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        TrieNode node = root;\\n        for (char c : prefix.toCharArray()) {\\n            if (node.child[c - \\'a\\'] == null) return 0;\\n                node = node.child[c - \\'a\\'];\\n        }\\n        return node.value;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] child;\\n    int value;\\n    public TrieNode() {\\n        child = new TrieNode[26];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n\\n    HashMap<String, Integer> map;\\n    TrieNode root;\\n    public MapSum() {\\n        map = new HashMap<>();\\n        root = new TrieNode();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        int oldValue = map.getOrDefault(key, 0);\\n        TrieNode node = root;\\n        for (char c : key.toCharArray()) {\\n            if (node.child[c - \\'a\\'] == null) {\\n                node.child[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node.child[c - \\'a\\'];\\n            node.value += val - oldValue;\\n        }        \\n        map.put(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        TrieNode node = root;\\n        for (char c : prefix.toCharArray()) {\\n            if (node.child[c - \\'a\\'] == null) return 0;\\n                node = node.child[c - \\'a\\'];\\n        }\\n        return node.value;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] child;\\n    int value;\\n    public TrieNode() {\\n        child = new TrieNode[26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441642,
                "title": "golang-clean-and-beat-100",
                "content": "```\\n\\n//another tries data structure\\ntype MapSum struct {\\n\\tChildren [26]*MapSum\\n\\tVal      int\\n}\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() MapSum {\\n\\treturn MapSum{}\\n}\\n\\nfunc (root *MapSum) Insert(key string, val int) {\\n\\tstart := root\\n\\trunes := []rune(key)\\n\\tfor i, r := range runes {\\n\\t\\tif node := start.Children[r-\\'a\\']; node != nil {\\n\\t\\t\\tstart = node\\n\\t\\t} else {\\n\\t\\t\\tfor _, nr := range runes[i:] {\\n\\t\\t\\t\\tstart.Children[nr-\\'a\\'] = &MapSum{}\\n\\t\\t\\t\\tstart = start.Children[nr-\\'a\\']\\n\\t\\t\\t}\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\tstart.Val = val\\n}\\n\\nfunc (root *MapSum) SumOfChildren() int {\\n\\tsum := 0\\n\\tfor _, c := range root.Children {\\n\\t\\tif c != nil {\\n\\t\\t\\tsum += c.Val + c.SumOfChildren()\\n\\t\\t}\\n\\t}\\n\\treturn sum\\n}\\n\\n//downwards, and get sum of all leafs\\nfunc (root *MapSum) Sum(prefix string) int {\\n\\tstart := root\\n\\tfor _, r := range []rune(prefix) {\\n\\t\\tstart = start.Children[r-\\'a\\']\\n\\t\\tif start == nil {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t}\\n\\t//find the sum of all child nodes\\n\\treturn start.Val + start.SumOfChildren()\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n//another tries data structure\\ntype MapSum struct {\\n\\tChildren [26]*MapSum\\n\\tVal      int\\n}\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() MapSum {\\n\\treturn MapSum{}\\n}\\n\\nfunc (root *MapSum) Insert(key string, val int) {\\n\\tstart := root\\n\\trunes := []rune(key)\\n\\tfor i, r := range runes {\\n\\t\\tif node := start.Children[r-\\'a\\']; node != nil {\\n\\t\\t\\tstart = node\\n\\t\\t} else {\\n\\t\\t\\tfor _, nr := range runes[i:] {\\n\\t\\t\\t\\tstart.Children[nr-\\'a\\'] = &MapSum{}\\n\\t\\t\\t\\tstart = start.Children[nr-\\'a\\']\\n\\t\\t\\t}\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\tstart.Val = val\\n}\\n\\nfunc (root *MapSum) SumOfChildren() int {\\n\\tsum := 0\\n\\tfor _, c := range root.Children {\\n\\t\\tif c != nil {\\n\\t\\t\\tsum += c.Val + c.SumOfChildren()\\n\\t\\t}\\n\\t}\\n\\treturn sum\\n}\\n\\n//downwards, and get sum of all leafs\\nfunc (root *MapSum) Sum(prefix string) int {\\n\\tstart := root\\n\\tfor _, r := range []rune(prefix) {\\n\\t\\tstart = start.Children[r-\\'a\\']\\n\\t\\tif start == nil {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t}\\n\\t//find the sum of all child nodes\\n\\treturn start.Val + start.SumOfChildren()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 433765,
                "title": "i-feel-like-this-was-too-easy",
                "content": "```\\nclass MapSum:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.myDict = {}\\n\\n    def insert(self, key: str, val: int) -> None:\\n            self.myDict[key] = val\\n\\n    def sum(self, prefix: str) -> int:\\n        total = 0\\n        for each in self.myDict:\\n            if each.startswith(prefix):\\n                total += self.myDict[each]\\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass MapSum:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.myDict = {}\\n\\n    def insert(self, key: str, val: int) -> None:\\n            self.myDict[key] = val\\n\\n    def sum(self, prefix: str) -> int:\\n        total = 0\\n        for each in self.myDict:\\n            if each.startswith(prefix):\\n                total += self.myDict[each]\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422344,
                "title": "c-solution-98-faster-100-space",
                "content": "```\\npublic class MapSum {\\n\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        ans = new Dictionary<string, int>();\\n    }\\n    Dictionary<string, int> ans;\\n    public void Insert(string key, int val) {\\n        if(ans.ContainsKey(key))\\n            ans[key] = val;\\n        else\\n            ans.Add(key, val);\\n    }\\n    \\n    public int Sum(string prefix) {\\n        int sum = 0;\\n        foreach(var item in ans.Keys)\\n        {\\n            if(item.Length >= prefix.Length && item.Substring(0, prefix.Length) == prefix)\\n                sum += ans[item];\\n        }\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.Insert(key,val);\\n * int param_2 = obj.Sum(prefix);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MapSum {\\n\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        ans = new Dictionary<string, int>();\\n    }\\n    Dictionary<string, int> ans;\\n    public void Insert(string key, int val) {\\n        if(ans.ContainsKey(key))\\n            ans[key] = val;\\n        else\\n            ans.Add(key, val);\\n    }\\n    \\n    public int Sum(string prefix) {\\n        int sum = 0;\\n        foreach(var item in ans.Keys)\\n        {\\n            if(item.Length >= prefix.Length && item.Substring(0, prefix.Length) == prefix)\\n                sum += ans[item];\\n        }\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.Insert(key,val);\\n * int param_2 = obj.Sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402594,
                "title": "c-with-trie",
                "content": "```\\npublic class MapSum\\n{\\n\\tprivate class Node\\n\\t{\\n\\t\\tpublic int Value { get; set; }\\n\\t\\tpublic IDictionary<char, Node> Next { get; private set; }\\n\\n\\t\\tpublic Node(int value)\\n\\t\\t{\\n\\t\\t\\tValue = value;\\n\\t\\t\\tNext = new Dictionary<char, Node>();\\n\\t\\t}\\n\\n\\t\\tpublic Node() : this(0) { }\\n\\t}\\n\\n\\tprivate Node root;\\n\\n\\t/** Initialize your data structure here. */\\n\\tpublic MapSum()\\n\\t{\\n\\t\\troot = new Node();\\n\\t}\\n\\n\\tpublic void Insert(string key, int val)\\n\\t{\\n\\t\\tNode cur = root;\\n\\t\\tfor (int i = 0; i < key.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (!cur.Next.ContainsKey(key[i]))\\n\\t\\t\\t\\tcur.Next.Add(key[i], new Node());\\n\\t\\t\\tcur = cur.Next[key[i]];\\n\\t\\t}\\n\\t\\tcur.Value = val;\\n\\t}\\n\\n\\tpublic int Sum(string prefix)\\n\\t{\\n\\t\\tNode cur = root;\\n\\t\\tfor (int i = 0; i < prefix.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (!cur.Next.ContainsKey(prefix[i]))\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tcur = cur.Next[prefix[i]];\\n\\t\\t}\\n\\n\\t\\treturn Sum(cur);\\n\\t}\\n\\n\\tprivate int Sum(Node node)\\n\\t{\\n\\t\\tint res = node.Value;\\n\\n\\t\\tforeach (char key in node.Next.Keys)\\n\\t\\t\\tres += Sum(node.Next[key]);\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MapSum\\n{\\n\\tprivate class Node\\n\\t{\\n\\t\\tpublic int Value { get; set; }\\n\\t\\tpublic IDictionary<char, Node> Next { get; private set; }\\n\\n\\t\\tpublic Node(int value)\\n\\t\\t{\\n\\t\\t\\tValue = value;\\n\\t\\t\\tNext = new Dictionary<char, Node>();\\n\\t\\t}\\n\\n\\t\\tpublic Node() : this(0) { }\\n\\t}\\n\\n\\tprivate Node root;\\n\\n\\t/** Initialize your data structure here. */\\n\\tpublic MapSum()\\n\\t{\\n\\t\\troot = new Node();\\n\\t}\\n\\n\\tpublic void Insert(string key, int val)\\n\\t{\\n\\t\\tNode cur = root;\\n\\t\\tfor (int i = 0; i < key.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (!cur.Next.ContainsKey(key[i]))\\n\\t\\t\\t\\tcur.Next.Add(key[i], new Node());\\n\\t\\t\\tcur = cur.Next[key[i]];\\n\\t\\t}\\n\\t\\tcur.Value = val;\\n\\t}\\n\\n\\tpublic int Sum(string prefix)\\n\\t{\\n\\t\\tNode cur = root;\\n\\t\\tfor (int i = 0; i < prefix.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (!cur.Next.ContainsKey(prefix[i]))\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tcur = cur.Next[prefix[i]];\\n\\t\\t}\\n\\n\\t\\treturn Sum(cur);\\n\\t}\\n\\n\\tprivate int Sum(Node node)\\n\\t{\\n\\t\\tint res = node.Value;\\n\\n\\t\\tforeach (char key in node.Next.Keys)\\n\\t\\t\\tres += Sum(node.Next[key]);\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 331216,
                "title": "java-easy-iterator-map-solution-beats-97-runtime-and-100-memory",
                "content": "```\\nclass MapSum {\\n    Map<String, Integer>map;\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n         map=new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        map.put(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        Iterator<Map.Entry<String, Integer>> it = map.entrySet().iterator();\\n        int sum = 0;\\n        while (it.hasNext()){\\n            Map.Entry<String,Integer> entry = it.next();\\n            if (entry.getKey().startsWith(prefix))sum+=entry.getValue();\\n        }\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n    Map<String, Integer>map;\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n         map=new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        map.put(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        Iterator<Map.Entry<String, Integer>> it = map.entrySet().iterator();\\n        int sum = 0;\\n        while (it.hasNext()){\\n            Map.Entry<String,Integer> entry = it.next();\\n            if (entry.getKey().startsWith(prefix))sum+=entry.getValue();\\n        }\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283347,
                "title": "go-solution-with-trie-beats-100-in-time-and-memory",
                "content": "```\\ntype Trie struct {\\n    char byte\\n    end bool\\n    value int\\n    children map[byte]*Trie\\n}\\n\\nfunc (t *Trie) Insert(key string, val, del int) {\\n    if key == \"\" {\\n        return\\n    }\\n    t.value += val - del\\n    if len(key) == 1 {\\n        t.end = true\\n        return\\n    }\\n    ch, ok := t.children[key[1]]\\n    if !ok {\\n        ch = &Trie{char: key[1], children: map[byte]*Trie{}}\\n        t.children[key[1]] = ch\\n    }\\n    (*ch).Insert(key[1:], val, del)\\n}\\n\\nfunc (t *Trie) Find(key string) (int, bool) {\\n    if key == \"\" {\\n        return 0, false\\n    }\\n    if len(key) == 1 {\\n        return t.value, t.end\\n    }\\n    ch, ok := t.children[key[1]]\\n    if !ok {\\n        return 0, false\\n    }\\n    return ch.Find(key[1:])\\n}\\n\\ntype MapSum struct {\\n    tries map[byte]*Trie\\n}\\n\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() MapSum {\\n    return MapSum{map[byte]*Trie{}}\\n}\\n\\n\\nfunc (this *MapSum) Insert(key string, val int)  {\\n    if t, ok := this.tries[key[0]]; ok {\\n        prev, ok := (*t).Find(key)\\n        if !ok {\\n            prev = 0\\n        }\\n         (*t).Insert(key, val, prev)\\n    } else {\\n        t = &Trie{char: key[0], children: map[byte]*Trie{}}\\n        t.char = key[0]\\n        this.tries[key[0]] = t\\n        (*t).Insert(key, val, 0)\\n    }\\n}\\n\\n\\nfunc (this *MapSum) Sum(prefix string) int {\\n    if prefix == \"\" {\\n        return 0\\n    }\\n    t, ok := this.tries[prefix[0]]\\n    if !ok {\\n        return 0\\n    }\\n    val, _ := t.Find(prefix)\\n    return val\\n}\\n```\\n\\nAll operations are O(len(key)).",
                "solutionTags": [],
                "code": "```\\ntype Trie struct {\\n    char byte\\n    end bool\\n    value int\\n    children map[byte]*Trie\\n}\\n\\nfunc (t *Trie) Insert(key string, val, del int) {\\n    if key == \"\" {\\n        return\\n    }\\n    t.value += val - del\\n    if len(key) == 1 {\\n        t.end = true\\n        return\\n    }\\n    ch, ok := t.children[key[1]]\\n    if !ok {\\n        ch = &Trie{char: key[1], children: map[byte]*Trie{}}\\n        t.children[key[1]] = ch\\n    }\\n    (*ch).Insert(key[1:], val, del)\\n}\\n\\nfunc (t *Trie) Find(key string) (int, bool) {\\n    if key == \"\" {\\n        return 0, false\\n    }\\n    if len(key) == 1 {\\n        return t.value, t.end\\n    }\\n    ch, ok := t.children[key[1]]\\n    if !ok {\\n        return 0, false\\n    }\\n    return ch.Find(key[1:])\\n}\\n\\ntype MapSum struct {\\n    tries map[byte]*Trie\\n}\\n\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() MapSum {\\n    return MapSum{map[byte]*Trie{}}\\n}\\n\\n\\nfunc (this *MapSum) Insert(key string, val int)  {\\n    if t, ok := this.tries[key[0]]; ok {\\n        prev, ok := (*t).Find(key)\\n        if !ok {\\n            prev = 0\\n        }\\n         (*t).Insert(key, val, prev)\\n    } else {\\n        t = &Trie{char: key[0], children: map[byte]*Trie{}}\\n        t.char = key[0]\\n        this.tries[key[0]] = t\\n        (*t).Insert(key, val, 0)\\n    }\\n}\\n\\n\\nfunc (this *MapSum) Sum(prefix string) int {\\n    if prefix == \"\" {\\n        return 0\\n    }\\n    t, ok := this.tries[prefix[0]]\\n    if !ok {\\n        return 0\\n    }\\n    val, _ := t.Find(prefix)\\n    return val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 272445,
                "title": "java-with-trie-bfs",
                "content": "```\\nimport java.util.*;\\n\\nclass TrieNode {\\n    char c;\\n    HashMap<Character, TrieNode> children = new HashMap<>();\\n    boolean isLeaf;\\n    int value;\\n\\n    public TrieNode() {\\n    }\\n\\n    public TrieNode(char c) {\\n      this.c = c;\\n    }\\n  }\\n\\n   public class Trie {\\n    private TrieNode root;\\n\\n    public Trie() {\\n      root = new TrieNode();\\n    }\\n\\n    public void insert(String word, int value) {\\n      HashMap<Character, TrieNode> children = root.children;\\n\\n      for (int i = 0; i < word.length(); i++) {\\n        char c = word.charAt(i);\\n        TrieNode t;\\n        if (children.containsKey(c)) {\\n          t = children.get(c);\\n        } else {\\n          t = new TrieNode(c);\\n          children.put(c, t);\\n        }\\n        children = t.children;\\n        if (i == word.length() - 1) {\\n          t.isLeaf = true;\\n          t.value = value;\\n        }\\n      }\\n    }\\n\\n    public Integer search(String word) {\\n      TrieNode t = searchNode(word);\\n      if (t != null && t.isLeaf) {\\n        return t.value;\\n      } else {\\n        return null;\\n      }\\n    }\\n\\n    public boolean startsWith(String prefix) {\\n      if (searchNode(prefix) == null)\\n        return false;\\n      else\\n        return true;\\n    }\\n\\n    public TrieNode searchNode(String str) {\\n      Map<Character, TrieNode> children = root.children;\\n      TrieNode t = null;\\n      for (int i = 0; i < str.length(); i++) {\\n        char c = str.charAt(i);\\n        if (children.containsKey(c)) {\\n          t = children.get(c);\\n          children = t.children;\\n        } else {\\n          return null;\\n        }\\n      }\\n      return t;\\n    }\\n  }\\n\\n\\n   class MapSum {\\n\\n    Trie trie;\\n\\n    public MapSum() {\\n      trie = new Trie();\\n    }\\n\\n    public void insert(String key, int val) {\\n      trie.insert(key, val);\\n    }\\n\\n    public int sum(String prefix) {\\n      int sum = 0;\\n      TrieNode node = trie.searchNode(prefix);\\n      if (node != null) {\\n       Queue<TrieNode> layers = new LinkedList<>();\\n        layers.add(node);\\n        while (!layers.isEmpty()) {\\n          Queue<TrieNode> layer = new LinkedList<>();\\n          while (!layers.isEmpty()) {\\n            TrieNode curr = layers.poll();\\n            sum += curr.value;\\n            Collection<TrieNode> values = curr.children.values();\\n            layer.addAll(values);\\n          }\\n          layers.addAll(layer);\\n        }\\n      }\\n      return sum;\\n    }\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass TrieNode {\\n    char c;\\n    HashMap<Character, TrieNode> children = new HashMap<>();\\n    boolean isLeaf;\\n    int value;\\n\\n    public TrieNode() {\\n    }\\n\\n    public TrieNode(char c) {\\n      this.c = c;\\n    }\\n  }\\n\\n   public class Trie {\\n    private TrieNode root;\\n\\n    public Trie() {\\n      root = new TrieNode();\\n    }\\n\\n    public void insert(String word, int value) {\\n      HashMap<Character, TrieNode> children = root.children;\\n\\n      for (int i = 0; i < word.length(); i++) {\\n        char c = word.charAt(i);\\n        TrieNode t;\\n        if (children.containsKey(c)) {\\n          t = children.get(c);\\n        } else {\\n          t = new TrieNode(c);\\n          children.put(c, t);\\n        }\\n        children = t.children;\\n        if (i == word.length() - 1) {\\n          t.isLeaf = true;\\n          t.value = value;\\n        }\\n      }\\n    }\\n\\n    public Integer search(String word) {\\n      TrieNode t = searchNode(word);\\n      if (t != null && t.isLeaf) {\\n        return t.value;\\n      } else {\\n        return null;\\n      }\\n    }\\n\\n    public boolean startsWith(String prefix) {\\n      if (searchNode(prefix) == null)\\n        return false;\\n      else\\n        return true;\\n    }\\n\\n    public TrieNode searchNode(String str) {\\n      Map<Character, TrieNode> children = root.children;\\n      TrieNode t = null;\\n      for (int i = 0; i < str.length(); i++) {\\n        char c = str.charAt(i);\\n        if (children.containsKey(c)) {\\n          t = children.get(c);\\n          children = t.children;\\n        } else {\\n          return null;\\n        }\\n      }\\n      return t;\\n    }\\n  }\\n\\n\\n   class MapSum {\\n\\n    Trie trie;\\n\\n    public MapSum() {\\n      trie = new Trie();\\n    }\\n\\n    public void insert(String key, int val) {\\n      trie.insert(key, val);\\n    }\\n\\n    public int sum(String prefix) {\\n      int sum = 0;\\n      TrieNode node = trie.searchNode(prefix);\\n      if (node != null) {\\n       Queue<TrieNode> layers = new LinkedList<>();\\n        layers.add(node);\\n        while (!layers.isEmpty()) {\\n          Queue<TrieNode> layer = new LinkedList<>();\\n          while (!layers.isEmpty()) {\\n            TrieNode curr = layers.poll();\\n            sum += curr.value;\\n            Collection<TrieNode> values = curr.children.values();\\n            layer.addAll(values);\\n          }\\n          layers.addAll(layer);\\n        }\\n      }\\n      return sum;\\n    }\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250535,
                "title": "c-solution-with-unordered-map-100",
                "content": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<string, int> m;\\n    MapSum() {\\n\\n    }\\n    \\n    void insert(string key, int val) {\\n        m[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        auto sum = 0;\\n        for (auto p: m) {\\n            auto str = p.first;\\n            auto i = 0;\\n\\n            if (str.length() < prefix.length())\\n                continue;\\n\\n            while (i < prefix.length()) {\\n                if (str[i] != prefix[i])\\n                    break;\\n                i++;\\n            }\\n            if (i == prefix.length())\\n                sum += p.second;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<string, int> m;\\n    MapSum() {\\n\\n    }\\n    \\n    void insert(string key, int val) {\\n        m[key] = val;\\n    }\\n    \\n    int sum(string prefix) {\\n        auto sum = 0;\\n        for (auto p: m) {\\n            auto str = p.first;\\n            auto i = 0;\\n\\n            if (str.length() < prefix.length())\\n                continue;\\n\\n            while (i < prefix.length()) {\\n                if (str[i] != prefix[i])\\n                    break;\\n                i++;\\n            }\\n            if (i == prefix.length())\\n                sum += p.second;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247121,
                "title": "py3-same-as-prefix-trie-but-do-vast-search-once-got-the-key",
                "content": "```\\nclass MapSum:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.ds = {}\\n        self.total = 0\\n\\n    def insert(self, key: str, val: int) -> None:\\n        trie = self.ds\\n        for k in key:\\n            if k not in trie:\\n                trie[k] = {}\\n            trie = trie[k]\\n        trie[\\'#\\'] = val\\n\\n        \\n    def searchall(self, t):\\n        \\n        for value in t.keys():\\n            if \\'#\\' == value: \\n                self.total += t[\\'#\\']\\n            else:\\n                self.searchall(t[value])\\n                \\n        return \\n        \\n        \\n    def sum(self, prefix: str) -> int:\\n        trie = self.ds\\n        self.total = 0\\n        \\n        for p in prefix:\\n            if p in trie:\\n                trie = trie[p]\\n            else:\\n                return self.total\\n            \\n        self.searchall(trie)\\n            \\n        return self.total\\n\\n# Your MapSum object will be instantiated and called as such:\\n# obj = MapSum()\\n# obj.insert(key,val)\\n# param_2 = obj.sum(prefix)\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.ds = {}\\n        self.total = 0\\n\\n    def insert(self, key: str, val: int) -> None:\\n        trie = self.ds\\n        for k in key:\\n            if k not in trie:\\n                trie[k] = {}\\n            trie = trie[k]\\n        trie[\\'#\\'] = val\\n\\n        \\n    def searchall(self, t):\\n        \\n        for value in t.keys():\\n            if \\'#\\' == value: \\n                self.total += t[\\'#\\']\\n            else:\\n                self.searchall(t[value])\\n                \\n        return \\n        \\n        \\n    def sum(self, prefix: str) -> int:\\n        trie = self.ds\\n        self.total = 0\\n        \\n        for p in prefix:\\n            if p in trie:\\n                trie = trie[p]\\n            else:\\n                return self.total\\n            \\n        self.searchall(trie)\\n            \\n        return self.total\\n\\n# Your MapSum object will be instantiated and called as such:\\n# obj = MapSum()\\n# obj.insert(key,val)\\n# param_2 = obj.sum(prefix)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245445,
                "title": "beating-100-simple-solution-with-unordered-map",
                "content": "class MapSum {\\n    unordered_map<string, int>m;\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        m[key]=val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int sum = 0;\\n        for (auto it = m.begin(); it != m.end(); it++) {\\n            if (it->first.find(prefix) == 0)\\n                sum += it->second;\\n        }\\n        return sum;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */",
                "solutionTags": [],
                "code": "class MapSum {\\n    unordered_map<string, int>m;\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        m[key]=val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int sum = 0;\\n        for (auto it = m.begin(); it != m.end(); it++) {\\n            if (it->first.find(prefix) == 0)\\n                sum += it->second;\\n        }\\n        return sum;\\n    }\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 220362,
                "title": "348-ms-faster-than-100-00-scala-solutions-3-lines-of-code",
                "content": "```\\nclass MapSum() {\\n\\n  val internalMap = mutable.Map[String, Int]()\\n\\n  def insert(key: String, value: Int) = internalMap += (key -> value)\\n  def sum(prefix: String): Int = internalMap.filterKeys(_.startsWith(prefix)).values.sum\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum() {\\n\\n  val internalMap = mutable.Map[String, Int]()\\n\\n  def insert(key: String, value: Int) = internalMap += (key -> value)\\n  def sum(prefix: String): Int = internalMap.filterKeys(_.startsWith(prefix)).values.sum\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214909,
                "title": "javascript",
                "content": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MapSum = function() {\\n    this.map = {}\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} val\\n * @return {void}\\n */\\nMapSum.prototype.insert = function(key, val) {\\n    this.map[key] = val \\n};\\n\\n/** \\n * @param {string} prefix\\n * @return {number}\\n */\\nMapSum.prototype.sum = function(prefix) {\\n    let sum = 0\\n    for(let key in this.map){\\n        if(prefix == key.substring(0, prefix.length)){\\n            sum += this.map[key]\\n        }\\n    }\\n    return sum\\n};\\n\\n/** \\n * Your MapSum object will be instantiated and called as such:\\n * var obj = Object.create(MapSum).createNew()\\n * obj.insert(key,val)\\n * var param_2 = obj.sum(prefix)\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MapSum = function() {\\n    this.map = {}\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} val\\n * @return {void}\\n */\\nMapSum.prototype.insert = function(key, val) {\\n    this.map[key] = val \\n};\\n\\n/** \\n * @param {string} prefix\\n * @return {number}\\n */\\nMapSum.prototype.sum = function(prefix) {\\n    let sum = 0\\n    for(let key in this.map){\\n        if(prefix == key.substring(0, prefix.length)){\\n            sum += this.map[key]\\n        }\\n    }\\n    return sum\\n};\\n\\n/** \\n * Your MapSum object will be instantiated and called as such:\\n * var obj = Object.create(MapSum).createNew()\\n * obj.insert(key,val)\\n * var param_2 = obj.sum(prefix)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 199513,
                "title": "javascript-solution-trie-dfs-beats-100-of-submissions-52ms",
                "content": "```var Trie = function() {\\n     this.children = {};\\n     this.val = 0;\\n};\\n\\n/**\\n * Inserts a word into the trie. \\n * @param {string} word\\n * @return {void}\\n */\\nTrie.prototype.insert = function(word,val) {\\n    var cur = this;\\n\\n    for (var i = 0; i < word.length;i++) {\\n        var c = word[i];\\n        if (!cur.children[c]) {\\n          cur.children[c] = new Trie();\\n        }\\n        cur = cur.children[c];\\n    }\\n    cur.val = val;\\n};\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar MapSum = function() {\\n    this.root = new Trie();\\n    this.dfs = function(root) {\\n      var sum = 0;\\n      var chars = Object.keys(root.children);\\n      for (var i = 0; i < chars.length;i++) {\\n        var c = chars[i];\\n        sum += this.dfs(root.children[c])\\n      }\\n      return sum + root.val;\\n    }\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} val\\n * @return {void}\\n */\\nMapSum.prototype.insert = function(key, val) {\\n    var cur = this.root;\\n    for (var i = 0;i < key.length;i++) {\\n      var c = key[i];\\n      if (!cur.children[c]) {\\n        cur.children[c] = new Trie()\\n      }\\n      cur = cur.children[c];\\n    }\\n    cur.val = val;\\n};\\n\\n/** \\n * @param {string} prefix\\n * @return {number}\\n */\\nMapSum.prototype.sum = function(prefix) {\\n    var cur = this.root;\\n    for (var i = 0;i < prefix.length;i++) {\\n      var c = prefix[i];\\n      if (!cur.children[c]) {\\n        return 0;\\n      }\\n      cur = cur.children[c];\\n    }\\n    return this.dfs(cur);\\n};\\n```",
                "solutionTags": [],
                "code": "```var Trie = function() {\\n     this.children = {};\\n     this.val = 0;\\n};\\n\\n/**\\n * Inserts a word into the trie. \\n * @param {string} word\\n * @return {void}\\n */\\nTrie.prototype.insert = function(word,val) {\\n    var cur = this;\\n\\n    for (var i = 0; i < word.length;i++) {\\n        var c = word[i];\\n        if (!cur.children[c]) {\\n          cur.children[c] = new Trie();\\n        }\\n        cur = cur.children[c];\\n    }\\n    cur.val = val;\\n};\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar MapSum = function() {\\n    this.root = new Trie();\\n    this.dfs = function(root) {\\n      var sum = 0;\\n      var chars = Object.keys(root.children);\\n      for (var i = 0; i < chars.length;i++) {\\n        var c = chars[i];\\n        sum += this.dfs(root.children[c])\\n      }\\n      return sum + root.val;\\n    }\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} val\\n * @return {void}\\n */\\nMapSum.prototype.insert = function(key, val) {\\n    var cur = this.root;\\n    for (var i = 0;i < key.length;i++) {\\n      var c = key[i];\\n      if (!cur.children[c]) {\\n        cur.children[c] = new Trie()\\n      }\\n      cur = cur.children[c];\\n    }\\n    cur.val = val;\\n};\\n\\n/** \\n * @param {string} prefix\\n * @return {number}\\n */\\nMapSum.prototype.sum = function(prefix) {\\n    var cur = this.root;\\n    for (var i = 0;i < prefix.length;i++) {\\n      var c = prefix[i];\\n      if (!cur.children[c]) {\\n        return 0;\\n      }\\n      cur = cur.children[c];\\n    }\\n    return this.dfs(cur);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 196164,
                "title": "simple-golang-solution-using-trie-tree-beats-100-just-0ms",
                "content": "```\\n\\ntype MapSum struct {\\n\\tRoot *Node\\n}\\n\\ntype Node struct {\\n\\tVal      int\\n\\tChildren [26]*Node\\n}\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() MapSum {\\n\\tvar node *Node\\n\\tnode = &Node{}\\n\\tmapSum := MapSum{node}\\n\\treturn mapSum\\n}\\n\\nfunc (this *MapSum) Insert(key string, val int) {\\n\\thead := this.Root\\n\\tdata := []byte(key)\\n\\tfor i := 0; i < len(data); i++ {\\n\\t\\tidx := int(data[i] - \\'a\\')\\n\\n\\t\\tif head.Children[idx] == nil {\\n\\t\\t\\ttmp := &Node{}\\n\\t\\t\\thead.Children[idx] = tmp\\n\\t\\t\\thead = tmp\\n\\t\\t} else {\\n\\t\\t\\thead = head.Children[idx]\\n\\t\\t}\\n\\n\\t}\\n\\thead.Val = val\\n}\\n\\nfunc getAllNodes(head *Node, res *int) {\\n\\t*res = *res + head.Val\\n\\tfor i := 0; i < 26; i++ {\\n\\t\\tif head.Children[i] != nil {\\n\\t\\t\\tgetAllNodes(head.Children[i], res)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (this *MapSum) Sum(prefix string) int {\\n\\tres := 0\\n\\thead := this.Root\\n\\tdata := []byte(prefix)\\n\\tfor i := 0; i < len(data); i++ {\\n\\t\\tidx := int(data[i] - \\'a\\')\\n\\t\\tif head.Children[idx] == nil {\\n\\t\\t\\treturn 0\\n\\t\\t} else {\\n\\t\\t\\thead = head.Children[idx]\\n\\t\\t}\\n\\t}\\n\\tgetAllNodes(head, &res)\\n\\treturn res\\n}\\n\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Insert(key,val);\\n * param_2 := obj.Sum(prefix);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n\\ntype MapSum struct {\\n\\tRoot *Node\\n}\\n\\ntype Node struct {\\n\\tVal      int\\n\\tChildren [26]*Node\\n}\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() MapSum {\\n\\tvar node *Node\\n\\tnode = &Node{}\\n\\tmapSum := MapSum{node}\\n\\treturn mapSum\\n}\\n\\nfunc (this *MapSum) Insert(key string, val int) {\\n\\thead := this.Root\\n\\tdata := []byte(key)\\n\\tfor i := 0; i < len(data); i++ {\\n\\t\\tidx := int(data[i] - \\'a\\')\\n\\n\\t\\tif head.Children[idx] == nil {\\n\\t\\t\\ttmp := &Node{}\\n\\t\\t\\thead.Children[idx] = tmp\\n\\t\\t\\thead = tmp\\n\\t\\t} else {\\n\\t\\t\\thead = head.Children[idx]\\n\\t\\t}\\n\\n\\t}\\n\\thead.Val = val\\n}\\n\\nfunc getAllNodes(head *Node, res *int) {\\n\\t*res = *res + head.Val\\n\\tfor i := 0; i < 26; i++ {\\n\\t\\tif head.Children[i] != nil {\\n\\t\\t\\tgetAllNodes(head.Children[i], res)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (this *MapSum) Sum(prefix string) int {\\n\\tres := 0\\n\\thead := this.Root\\n\\tdata := []byte(prefix)\\n\\tfor i := 0; i < len(data); i++ {\\n\\t\\tidx := int(data[i] - \\'a\\')\\n\\t\\tif head.Children[idx] == nil {\\n\\t\\t\\treturn 0\\n\\t\\t} else {\\n\\t\\t\\thead = head.Children[idx]\\n\\t\\t}\\n\\t}\\n\\tgetAllNodes(head, &res)\\n\\treturn res\\n}\\n\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Insert(key,val);\\n * param_2 := obj.Sum(prefix);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 190044,
                "title": "python-solution-trie",
                "content": "class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.sum = 0\\n        self.val = 0\\n        \\nclass MapSum:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n\\n    def insert(self, key, val):\\n        node = self.root\\n        for c in key:\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node.sum += val\\n            node = node.children[c]\\n        \\n        node.sum += val\\n        prev_val = node.val\\n        node.val = val\\n        \\n        node = self.root\\n        for c in key:\\n            node.sum -= prev_val\\n            node = node.children[c]\\n        node.sum -= prev_val\\n\\n\\n    def sum(self, prefix):\\n        node = self.root\\n        for c in prefix:\\n            if c not in node.children:\\n                return 0\\n            node = node.children[c]\\n            \\n        return node.sum",
                "solutionTags": [],
                "code": "class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.sum = 0\\n        self.val = 0\\n        \\nclass MapSum:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n\\n    def insert(self, key, val):\\n        node = self.root\\n        for c in key:\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node.sum += val\\n            node = node.children[c]\\n        \\n        node.sum += val\\n        prev_val = node.val\\n        node.val = val\\n        \\n        node = self.root\\n        for c in key:\\n            node.sum -= prev_val\\n            node = node.children[c]\\n        node.sum -= prev_val\\n\\n\\n    def sum(self, prefix):\\n        node = self.root\\n        for c in prefix:\\n            if c not in node.children:\\n                return 0\\n            node = node.children[c]\\n            \\n        return node.sum",
                "codeTag": "Java"
            },
            {
                "id": 159673,
                "title": "java-trie-with-one-map",
                "content": "```\\nclass MapSum {\\n    /** Initialize your data structure here. */\\n    Map<String,Integer> map;\\n    TrieNode root;\\n    public MapSum() {\\n        map = new HashMap<>();\\n        root = new TrieNode();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        TrieNode temp = root;\\n        if (map.get(key) == null) {\\n            int len = key.length();\\n            for (int i = 0; i < len; i++) {\\n                char c = key.charAt(i);\\n                if (temp.children[c-\\'a\\'] == null) temp.children[c-\\'a\\'] = new TrieNode();\\n                temp = temp.children[c-\\'a\\'];\\n                temp.num += val;\\n            }\\n        } else {\\n            int tempval = map.get(key);\\n            int len = key.length();\\n            for (int i = 0; i < len; i++) {\\n                char c = key.charAt(i);\\n                temp = temp.children[c-\\'a\\'];\\n                temp.num += val - tempval;\\n            }\\n        }\\n        map.put(key,val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        TrieNode temp = root;\\n        int len = prefix.length();\\n        for (int i = 0; i < len; i++) {\\n            char c = prefix.charAt(i);\\n            if (temp.children[c-\\'a\\'] == null) return 0;\\n            temp = temp.children[c-\\'a\\'];\\n        }\\n        return temp.num;\\n    }\\n}\\n\\nclass TrieNode{\\n    int num;\\n    TrieNode[] children;\\n    public TrieNode(){\\n        num = 0;\\n        children = new TrieNode[26];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n    /** Initialize your data structure here. */\\n    Map<String,Integer> map;\\n    TrieNode root;\\n    public MapSum() {\\n        map = new HashMap<>();\\n        root = new TrieNode();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        TrieNode temp = root;\\n        if (map.get(key) == null) {\\n            int len = key.length();\\n            for (int i = 0; i < len; i++) {\\n                char c = key.charAt(i);\\n                if (temp.children[c-\\'a\\'] == null) temp.children[c-\\'a\\'] = new TrieNode();\\n                temp = temp.children[c-\\'a\\'];\\n                temp.num += val;\\n            }\\n        } else {\\n            int tempval = map.get(key);\\n            int len = key.length();\\n            for (int i = 0; i < len; i++) {\\n                char c = key.charAt(i);\\n                temp = temp.children[c-\\'a\\'];\\n                temp.num += val - tempval;\\n            }\\n        }\\n        map.put(key,val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        TrieNode temp = root;\\n        int len = prefix.length();\\n        for (int i = 0; i < len; i++) {\\n            char c = prefix.charAt(i);\\n            if (temp.children[c-\\'a\\'] == null) return 0;\\n            temp = temp.children[c-\\'a\\'];\\n        }\\n        return temp.num;\\n    }\\n}\\n\\nclass TrieNode{\\n    int num;\\n    TrieNode[] children;\\n    public TrieNode(){\\n        num = 0;\\n        children = new TrieNode[26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140418,
                "title": "c-solution-with-an-auxiliary-function",
                "content": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        \\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        if (map.count(key))\\n            map[key] = val;\\n        else\\n            map.insert({key, val});\\n    }\\n    \\n    int sum(string prefix) {\\n        int res = 0;\\n        judge(prefix, res);\\n        return res;\\n    }\\n\\t\\t\\n    void judge(string prefix, int& res) {\\n        int size = prefix.size();\\n        for (auto it = map.begin(); it != map.end(); it++) {\\n            string sub = it->first.substr(0, size);\\n            if (prefix == sub)\\n                res += it->second;\\n        }\\n    }\\n\\t\\t\\nprivate:\\n    unordered_map<string, int> map;\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        \\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        if (map.count(key))\\n            map[key] = val;\\n        else\\n            map.insert({key, val});\\n    }\\n    \\n    int sum(string prefix) {\\n        int res = 0;\\n        judge(prefix, res);\\n        return res;\\n    }\\n\\t\\t\\n    void judge(string prefix, int& res) {\\n        int size = prefix.size();\\n        for (auto it = map.begin(); it != map.end(); it++) {\\n            string sub = it->first.substr(0, size);\\n            if (prefix == sub)\\n                res += it->second;\\n        }\\n    }\\n\\t\\t\\nprivate:\\n    unordered_map<string, int> map;\\n};\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126886,
                "title": "java-solution-using-trie",
                "content": "```\\nclass MapSum {\\n    private Node root;\\n    \\n    private class Node {\\n        int val;\\n        Node[] next;\\n        \\n        public Node() {\\n            next = new Node[26];\\n        }\\n    }\\n            \\n\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        root = new Node();   \\n    }\\n    \\n    public void insert(String key, int val) {\\n        Node node = root;\\n        for (char c : key.toCharArray()) {\\n            if (node.next[c - \\'a\\'] == null) {\\n                node.next[c - \\'a\\'] = new Node();\\n            }\\n            node = node.next[c - \\'a\\'];\\n        }\\n        node.val = val;  \\n    }\\n    \\n    public int sum(String prefix) {\\n        Node node = root;\\n        for (char c : prefix.toCharArray()) {\\n            if (node.next[c - \\'a\\'] == null) return 0;\\n            node = node.next[c - \\'a\\'];\\n        }\\n        return sum(node);   \\n    }\\n    \\n    private int sum(Node node) {\\n        if (node == null) return 0;\\n        int res = 0;\\n        res += node.val;\\n        for (int i = 0; i < 26; i++) {\\n            res += sum(node.next[i]);\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n    private Node root;\\n    \\n    private class Node {\\n        int val;\\n        Node[] next;\\n        \\n        public Node() {\\n            next = new Node[26];\\n        }\\n    }\\n            \\n\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        root = new Node();   \\n    }\\n    \\n    public void insert(String key, int val) {\\n        Node node = root;\\n        for (char c : key.toCharArray()) {\\n            if (node.next[c - \\'a\\'] == null) {\\n                node.next[c - \\'a\\'] = new Node();\\n            }\\n            node = node.next[c - \\'a\\'];\\n        }\\n        node.val = val;  \\n    }\\n    \\n    public int sum(String prefix) {\\n        Node node = root;\\n        for (char c : prefix.toCharArray()) {\\n            if (node.next[c - \\'a\\'] == null) return 0;\\n            node = node.next[c - \\'a\\'];\\n        }\\n        return sum(node);   \\n    }\\n    \\n    private int sum(Node node) {\\n        if (node == null) return 0;\\n        int res = 0;\\n        res += node.val;\\n        for (int i = 0; i < 26; i++) {\\n            res += sum(node.next[i]);\\n        }\\n        return res;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 119040,
                "title": "java-trie-solution-very-easy-to-understand",
                "content": "I have tried my best to make my code clean and simple.If you have any suggestions,please tell me,thanks!\\n```\\nclass MapSum {\\n    private Node root;\\n    private class Node{\\n        public Node[] children;\\n        public int sum = 0;\\n        \\n        public Node(){\\n            children = new Node[26];\\n        }\\n    }\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        root = new Node();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        char[] cArr = key.toCharArray();\\n        Node work = root;\\n        \\n        for(char c : cArr){\\n            if(work.children[c - \\'a\\'] == null)  work.children[c - \\'a\\'] = new Node();\\n            work = work.children[c - \\'a\\'];\\n        }\\n        work.sum = val;\\n    }\\n    \\n    public int sum(String prefix) {\\n        char[] cArr =  prefix.toCharArray();\\n        Node work = root;\\n        \\n        for(char c : cArr){\\n            work = work.children[c - \\'a\\'];\\n            if(work == null)    return 0;\\n        }\\n        \\n        return dfs(work);\\n    }\\n    \\n    public int dfs(Node root){\\n        int sum = root.sum;\\n        \\n        for(Node child : root.children){\\n            if(child != null)    sum += dfs(child);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n    private Node root;\\n    private class Node{\\n        public Node[] children;\\n        public int sum = 0;\\n        \\n        public Node(){\\n            children = new Node[26];\\n        }\\n    }\\n    /** Initialize your data structure here. */\\n    public MapSum() {\\n        root = new Node();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        char[] cArr = key.toCharArray();\\n        Node work = root;\\n        \\n        for(char c : cArr){\\n            if(work.children[c - \\'a\\'] == null)  work.children[c - \\'a\\'] = new Node();\\n            work = work.children[c - \\'a\\'];\\n        }\\n        work.sum = val;\\n    }\\n    \\n    public int sum(String prefix) {\\n        char[] cArr =  prefix.toCharArray();\\n        Node work = root;\\n        \\n        for(char c : cArr){\\n            work = work.children[c - \\'a\\'];\\n            if(work == null)    return 0;\\n        }\\n        \\n        return dfs(work);\\n    }\\n    \\n    public int dfs(Node root){\\n        int sum = root.sum;\\n        \\n        for(Node child : root.children){\\n            if(child != null)    sum += dfs(child);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107510,
                "title": "java-neat-but-slow-solution",
                "content": "```\\nclass MapSum {\\n\\n    Map<String, Integer> map =new HashMap<>();\\n    \\n    public void insert(String key, int val) {\\n        map.put(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        return map.entrySet().stream().filter(map -> map.getKey().startsWith(prefix)==true).mapToInt(map->map.getValue()).sum();\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n````",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\n\\n    Map<String, Integer> map =new HashMap<>();\\n    \\n    public void insert(String key, int val) {\\n        map.put(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        return map.entrySet().stream().filter(map -> map.getKey().startsWith(prefix)==true).mapToInt(map->map.getValue()).sum();\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107522,
                "title": "python-solution",
                "content": "```\\nclass MapSum(object):\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dict = {}\\n\\n    def insert(self, key, val):\\n        \"\"\"\\n        :type key: str\\n        :type val: int\\n        :rtype: void\\n        \"\"\"\\n        self.dict[key] = val\\n\\n    def sum(self, prefix):\\n        \"\"\"\\n        :type prefix: str\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for key in self.dict:\\n            if key.startswith(prefix):\\n                res += self.dict[key]\\n            else :\\n                continue\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass MapSum(object):\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dict = {}\\n\\n    def insert(self, key, val):\\n        \"\"\"\\n        :type key: str\\n        :type val: int\\n        :rtype: void\\n        \"\"\"\\n        self.dict[key] = val\\n\\n    def sum(self, prefix):\\n        \"\"\"\\n        :type prefix: str\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for key in self.dict:\\n            if key.startswith(prefix):\\n                res += self.dict[key]\\n            else :\\n                continue\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 107523,
                "title": "simple-javascript-solution-using-string-prototype-slice",
                "content": "```\\nvar MapSum = function() {\\n  this.map = new Map();\\n};\\n\\nMapSum.prototype.insert = function (key, val) {\\n  this.map.set(key, val);\\n};\\n\\nMapSum.prototype.sum = function (prefix) {\\n  let times = 0;\\n  let map = this.map;\\n  for (let item of map) { \\n    if (item[0].slice(0,prefix.length) == (prefix)) { \\n      times += item[1];\\n    }\\n  }\\n  return times;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar MapSum = function() {\\n  this.map = new Map();\\n};\\n\\nMapSum.prototype.insert = function (key, val) {\\n  this.map.set(key, val);\\n};\\n\\nMapSum.prototype.sum = function (prefix) {\\n  let times = 0;\\n  let map = this.map;\\n  for (let item of map) { \\n    if (item[0].slice(0,prefix.length) == (prefix)) { \\n      times += item[1];\\n    }\\n  }\\n  return times;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107529,
                "title": "c-trie-solution",
                "content": "```\\nstruct Node{\\n    std::array<Node*, 26> links{};\\n    bool isKey = false;\\n    int val = 0;\\n    int sum = 0;\\n};\\nclass MapSum {\\nprivate:\\n    Node root;\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        std::vector<Node*> nodes;\\n        auto p = &root;\\n        for (auto c: key){\\n            int index = c - 'a';\\n            if (p->links[index] == nullptr)\\n                p->links[index] = new Node;\\n            p = p->links[index];\\n            p->sum += val; // p will be a prefix of the key\\n            nodes.push_back(p);\\n        }\\n        // if already exists, the old one is replaced, i.e., subtracted\\n        if (p->isKey){ \\n            for (auto q: nodes)\\n                q->sum -= p->val;\\n        }\\n        p->val = val;\\n        p->isKey = true;\\n    }\\n    \\n    int sum(string prefix) {\\n        auto p = &root;\\n        for (auto c : prefix){\\n            if (p->links[c - 'a'] == nullptr) // no such prefix\\n                return 0;\\n            p = p->links[c - 'a'];\\n        }\\n        return p->sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nstruct Node{\\n    std::array<Node*, 26> links{};\\n    bool isKey = false;\\n    int val = 0;\\n    int sum = 0;\\n};\\nclass MapSum {\\nprivate:\\n    Node root;\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() {\\n        \\n    }\\n    \\n    void insert(string key, int val) {\\n        std::vector<Node*> nodes;\\n        auto p = &root;\\n        for (auto c: key){\\n            int index = c - 'a';\\n            if (p->links[index] == nullptr)\\n                p->links[index] = new Node;\\n            p = p->links[index];\\n            p->sum += val; // p will be a prefix of the key\\n            nodes.push_back(p);\\n        }\\n        // if already exists, the old one is replaced, i.e., subtracted\\n        if (p->isKey){ \\n            for (auto q: nodes)\\n                q->sum -= p->val;\\n        }\\n        p->val = val;\\n        p->isKey = true;\\n    }\\n    \\n    int sum(string prefix) {\\n        auto p = &root;\\n        for (auto c : prefix){\\n            if (p->links[c - 'a'] == nullptr) // no such prefix\\n                return 0;\\n            p = p->links[c - 'a'];\\n        }\\n        return p->sum;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 107534,
                "title": "c-11-trie-and-map-solutions",
                "content": "**Map solution:**\\nUsing a map, simply insert key/val pairs.  When calculating the sum, start iterating through the map at the lower_bound() of the prefix.  This lower_bound() string key is either equal to prefix, or alphabetically ordered just after the prefix.  Add up the sum by continuing to iterate through the map while the beginning of the key equals the prefix.\\n\\n```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() : _map{} {}\\n    \\n    void insert(string key, int val) {\\n        _map[key]=val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int cnt=0, sz=(int)prefix.size();\\n        map<string,int>::iterator itr;\\n        for (itr=_map.lower_bound(prefix); itr!=_map.end(); itr++){\\n            if (itr->first.substr(0,sz)==prefix){ cnt+=itr->second; } else { break; }\\n        }\\n        return cnt;\\n    }\\nprivate:\\n    map<string,int> _map;\\n};\\n```\\n**Trie solution:**\\nUsing a trie + unordered_map, for each character in the trie, store an unordered_map of keys which are included under this character.\\n\\nFor example, if \"apple\" is inserted with value 3, then the trie looks like this:\\n```\\na ==> dic[\"apple\"]=3\\np ==> dic[\"apple\"]=3\\np ==> dic[\"apple\"]=3\\nl ==> dic[\"apple\"]=3\\ne ==> dic[\"apple\"]=3\\n```\\n\\nThen if \"app\" is inserted with value 2, then the trie looks like this:\\n```\\na ==> dic[\"apple\"]=3, dic[\"app\"]=2\\np ==> dic[\"apple\"]=3, dic[\"app\"]=2\\np ==> dic[\"apple\"]=3, dic[\"app\"]=2\\nl ==> dic[\"apple\"]=3\\ne ==> dic[\"apple\"]=3\\n```\\n\\n\\n\\n```\\nclass TrieNode{\\npublic:\\n    unordered_map<string,int> dic;\\n    vector<shared_ptr<TrieNode>> next;\\n    TrieNode(string key, int val) : next{26,nullptr} {\\n        dic[key]=val;\\n    }\\n};\\n\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() : _root{make_shared<TrieNode>(\"\",0)} {}\\n    \\n    void insert(string key, int val) {\\n        int idx=0;\\n        auto curr=_root;\\n        transform(key.begin(), key.end(), key.begin(), ::tolower);\\n        for (auto& ch : key){\\n            idx=ch-'a';\\n            if (!curr->next[idx]){\\n                curr->next[idx]=make_shared<TrieNode>(key,val);\\n            } else {\\n                curr->next[idx]->dic[key]=val;\\n            }\\n            curr=curr->next[idx];\\n        }\\n    }\\n    \\n    int sum(string prefix) {\\n        int res=0;\\n        auto curr=_root;\\n        for (auto& ch : prefix){\\n            int idx=ch-'a';\\n            if (curr->next[idx]){\\n                curr=curr->next[idx];\\n            } else {\\n                return 0;\\n            }\\n        }\\n        for (auto& item : curr->dic){\\n            res+=item.second;\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    shared_ptr<TrieNode> _root;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() : _map{} {}\\n    \\n    void insert(string key, int val) {\\n        _map[key]=val;\\n    }\\n    \\n    int sum(string prefix) {\\n        int cnt=0, sz=(int)prefix.size();\\n        map<string,int>::iterator itr;\\n        for (itr=_map.lower_bound(prefix); itr!=_map.end(); itr++){\\n            if (itr->first.substr(0,sz)==prefix){ cnt+=itr->second; } else { break; }\\n        }\\n        return cnt;\\n    }\\nprivate:\\n    map<string,int> _map;\\n};\\n```\n```\\na ==> dic[\"apple\"]=3\\np ==> dic[\"apple\"]=3\\np ==> dic[\"apple\"]=3\\nl ==> dic[\"apple\"]=3\\ne ==> dic[\"apple\"]=3\\n```\n```\\na ==> dic[\"apple\"]=3, dic[\"app\"]=2\\np ==> dic[\"apple\"]=3, dic[\"app\"]=2\\np ==> dic[\"apple\"]=3, dic[\"app\"]=2\\nl ==> dic[\"apple\"]=3\\ne ==> dic[\"apple\"]=3\\n```\n```\\nclass TrieNode{\\npublic:\\n    unordered_map<string,int> dic;\\n    vector<shared_ptr<TrieNode>> next;\\n    TrieNode(string key, int val) : next{26,nullptr} {\\n        dic[key]=val;\\n    }\\n};\\n\\nclass MapSum {\\npublic:\\n    /** Initialize your data structure here. */\\n    MapSum() : _root{make_shared<TrieNode>(\"\",0)} {}\\n    \\n    void insert(string key, int val) {\\n        int idx=0;\\n        auto curr=_root;\\n        transform(key.begin(), key.end(), key.begin(), ::tolower);\\n        for (auto& ch : key){\\n            idx=ch-'a';\\n            if (!curr->next[idx]){\\n                curr->next[idx]=make_shared<TrieNode>(key,val);\\n            } else {\\n                curr->next[idx]->dic[key]=val;\\n            }\\n            curr=curr->next[idx];\\n        }\\n    }\\n    \\n    int sum(string prefix) {\\n        int res=0;\\n        auto curr=_root;\\n        for (auto& ch : prefix){\\n            int idx=ch-'a';\\n            if (curr->next[idx]){\\n                curr=curr->next[idx];\\n            } else {\\n                return 0;\\n            }\\n        }\\n        for (auto& item : curr->dic){\\n            res+=item.second;\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    shared_ptr<TrieNode> _root;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107557,
                "title": "python-trie-solution-different-from-article",
                "content": "Here is my alternate Trie solution.  For the more standard version, please check the article for this problem.\\n\\n```\\nTrie = lambda: collections.defaultdict(Trie)\\nSUM = False\\n\\nclass MapSum(object):\\n    def __init__(self):\\n        self.trie = Trie()\\n        self.map = {}\\n\\n    def insert(self, key, val):\\n        delta = val - self.map.get(key, 0)\\n        self.map[key] = val\\n        cur = self.trie\\n        for char in key:\\n            cur = cur[char]\\n            cur[SUM] = cur.get(SUM, 0) + delta\\n\\n    def sum(self, prefix):\\n        cur = self.trie\\n        for char in prefix:\\n            if char not in cur: return 0\\n            cur = cur[char]\\n        return cur[SUM]\\n```",
                "solutionTags": [],
                "code": "```\\nTrie = lambda: collections.defaultdict(Trie)\\nSUM = False\\n\\nclass MapSum(object):\\n    def __init__(self):\\n        self.trie = Trie()\\n        self.map = {}\\n\\n    def insert(self, key, val):\\n        delta = val - self.map.get(key, 0)\\n        self.map[key] = val\\n        cur = self.trie\\n        for char in key:\\n            cur = cur[char]\\n            cur[SUM] = cur.get(SUM, 0) + delta\\n\\n    def sum(self, prefix):\\n        cur = self.trie\\n        for char in prefix:\\n            if char not in cur: return 0\\n            cur = cur[char]\\n        return cur[SUM]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103227,
                "title": "easy-to-understand-java-solution-using-just-basic-iteration-on-the-map",
                "content": "# Code\\n```\\nclass MapSum {\\n    Map<String, Integer> map;\\n    public MapSum() {\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        map.put(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        int sum = 0;\\n        for(Map.Entry<String, Integer> entry: map.entrySet()) {\\n            String s = entry.getKey();\\n            if(s.startsWith(prefix)) {\\n                sum += entry.getValue();\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MapSum {\\n    Map<String, Integer> map;\\n    public MapSum() {\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        map.put(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        int sum = 0;\\n        for(Map.Entry<String, Integer> entry: map.entrySet()) {\\n            String s = entry.getKey();\\n            if(s.startsWith(prefix)) {\\n                sum += entry.getValue();\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101436,
                "title": "java-dfs-trie",
                "content": "# Code\\n```\\nclass MapSum {\\n    class Node{\\n        Node[] children;\\n        int val;\\n        boolean isEnd;\\n\\n        public Node(){\\n            this.children = new Node[26];\\n            this.isEnd = false;\\n            this.val= 0;\\n        }\\n    }\\n\\n    Node root ;\\n    public MapSum() {\\n        root = new Node();\\n    }\\n    \\n    public void insert(String s, int val) {\\n        int n = s.length();\\n\\n        Node CurrNode = this.root;\\n\\n        for(int i = 0;i<n;i++){\\n            char ch = s.charAt(i);\\n            if(CurrNode.children[ch-\\'a\\'] == null){\\n                CurrNode.children[ch-\\'a\\'] = new Node();\\n            }\\n            CurrNode = CurrNode.children[ch-\\'a\\'];\\n        }\\n        CurrNode.isEnd = true;\\n        CurrNode.val= val;\\n    }\\n    \\n    public int sum(String s) {\\n        int n = s.length();\\n        int sum = 0;\\n        Node CurrNode = this.root;\\n\\n        for(int i = 0;i<n;i++){\\n            char ch = s.charAt(i);\\n            if(CurrNode.children[ch-\\'a\\'] == null){ \\n                return 0;\\n            }\\n            else{\\n\\n            }\\n            CurrNode = CurrNode.children[ch-\\'a\\'];\\n        }\\n        sum  = helper(CurrNode);\\n        return sum;\\n    }\\n\\n    int helper(Node CurrNode){\\n        int sum = 0;\\n        if(CurrNode.isEnd){\\n            sum += CurrNode.val;\\n            // return sum;\\n        }\\n\\n        for(int j = 0;j<26;j++){\\n            if(CurrNode.children[j] != null){\\n                sum += helper(CurrNode.children[j]);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass MapSum {\\n    class Node{\\n        Node[] children;\\n        int val;\\n        boolean isEnd;\\n\\n        public Node(){\\n            this.children = new Node[26];\\n            this.isEnd = false;\\n            this.val= 0;\\n        }\\n    }\\n\\n    Node root ;\\n    public MapSum() {\\n        root = new Node();\\n    }\\n    \\n    public void insert(String s, int val) {\\n        int n = s.length();\\n\\n        Node CurrNode = this.root;\\n\\n        for(int i = 0;i<n;i++){\\n            char ch = s.charAt(i);\\n            if(CurrNode.children[ch-\\'a\\'] == null){\\n                CurrNode.children[ch-\\'a\\'] = new Node();\\n            }\\n            CurrNode = CurrNode.children[ch-\\'a\\'];\\n        }\\n        CurrNode.isEnd = true;\\n        CurrNode.val= val;\\n    }\\n    \\n    public int sum(String s) {\\n        int n = s.length();\\n        int sum = 0;\\n        Node CurrNode = this.root;\\n\\n        for(int i = 0;i<n;i++){\\n            char ch = s.charAt(i);\\n            if(CurrNode.children[ch-\\'a\\'] == null){ \\n                return 0;\\n            }\\n            else{\\n\\n            }\\n            CurrNode = CurrNode.children[ch-\\'a\\'];\\n        }\\n        sum  = helper(CurrNode);\\n        return sum;\\n    }\\n\\n    int helper(Node CurrNode){\\n        int sum = 0;\\n        if(CurrNode.isEnd){\\n            sum += CurrNode.val;\\n            // return sum;\\n        }\\n\\n        for(int j = 0;j<26;j++){\\n            if(CurrNode.children[j] != null){\\n                sum += helper(CurrNode.children[j]);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091642,
                "title": "easy-hashmap-solution-hashmap-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass MapSum {\\n    HashMap<String, Integer> map; \\n    public MapSum() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        map.put(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        int s=0;\\n        int n = prefix.length();\\n        for(String key: map.keySet()){\\n            if(key.length()>=prefix.length()){\\n                if(key.substring(0, n).equals(prefix)){\\n                    s+=map.get(key);\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MapSum {\\n    HashMap<String, Integer> map; \\n    public MapSum() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void insert(String key, int val) {\\n        map.put(key, val);\\n    }\\n    \\n    public int sum(String prefix) {\\n        int s=0;\\n        int n = prefix.length();\\n        for(String key: map.keySet()){\\n            if(key.length()>=prefix.length()){\\n                if(key.substring(0, n).equals(prefix)){\\n                    s+=map.get(key);\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n}\\n\\n/**\\n * Your MapSum object will be instantiated and called as such:\\n * MapSum obj = new MapSum();\\n * obj.insert(key,val);\\n * int param_2 = obj.sum(prefix);\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1800418,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the wording in the prob statement is poor"
                    },
                    {
                        "username": "khushisingh6661",
                        "content": "true"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "especially the key-value overriding part"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think maybe this problem should be labeled as easy... unless I solved it the unintended way"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "should be easy\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Solve [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) first"
                    }
                ]
            },
            {
                "id": 2003631,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the wording in the prob statement is poor"
                    },
                    {
                        "username": "khushisingh6661",
                        "content": "true"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "especially the key-value overriding part"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think maybe this problem should be labeled as easy... unless I solved it the unintended way"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "should be easy\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Solve [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) first"
                    }
                ]
            },
            {
                "id": 1990127,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the wording in the prob statement is poor"
                    },
                    {
                        "username": "khushisingh6661",
                        "content": "true"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "especially the key-value overriding part"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think maybe this problem should be labeled as easy... unless I solved it the unintended way"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "should be easy\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Solve [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) first"
                    }
                ]
            },
            {
                "id": 1786294,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the wording in the prob statement is poor"
                    },
                    {
                        "username": "khushisingh6661",
                        "content": "true"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "especially the key-value overriding part"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think maybe this problem should be labeled as easy... unless I solved it the unintended way"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "should be easy\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Solve [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) first"
                    }
                ]
            }
        ]
    }
]