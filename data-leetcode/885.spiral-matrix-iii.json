[
    {
        "title": "Spiral Matrix III",
        "question_content": "You start at the cell (rStart, cStart) of an rows x cols grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.\nYou will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid's boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all rows * cols spaces of the grid.\nReturn an array of coordinates representing the positions of the grid in the order you visited them.\n&nbsp;\nExample 1:\n\nInput: rows = 1, cols = 4, rStart = 0, cStart = 0\nOutput: [[0,0],[0,1],[0,2],[0,3]]\n\nExample 2:\n\nInput: rows = 5, cols = 6, rStart = 1, cStart = 4\nOutput: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]\n\n&nbsp;\nConstraints:\n\n\t1 <= rows, cols <= 100\n\t0 <= rStart < rows\n\t0 <= cStart < cols",
        "solutions": [
            {
                "id": 158970,
                "title": "c-java-python-1-1-2-2-3-3-steps",
                "content": "## **Intuition**:\\nTake steps one by one.\\nIf the location is inside of grid, add it to `res`.\\nBut how to simulate the path?\\n\\nIt seems to be annoying, but if we observer the path:\\n\\nmove right `1` step, turn right\\nmove down `1` step, turn right\\nmove left `2` steps, turn right\\nmove top `2` steps, turn right,\\nmove right `3` steps, turn right\\nmove down `3` steps, turn right\\nmove left `4` steps, turn right\\nmove top `4` steps, turn right,\\n\\nwe can find the sequence of steps: 1,1,2,2,3,3,4,4,5,5....\\n\\nSo there are two thing to figure out:\\n1. how to generate sequence 1,1,2,2,3,3,4,4,5,5\\n2. how to turn right?\\n<br>\\n\\n## **Generate sequence 1,1,2,2,3,3,4,4,5,5**\\nLet `n` be index of this sequence.\\nThen `A0 = 1`, `A1 = 1`, `A2 = 2` ......\\nWe can find that `An = n / 2 + 1`\\n<br>\\n\\n## **How to turn right?**\\nBy cross product:\\nAssume current direction is (x, y) in plane, which is (x, y, 0) in space.\\nThen the direction after turn right (x, y, 0) \\xD7 (0, 0, 1) = (y, -x, 0)\\nTranslate to code: `tmp = x; x = y; y = -tmp;`\\n\\nBy arrays of arrays:\\nThe directions order is (0,1),(1,0),(0,-1),(-1,0), then repeat.\\nJust define a variable.\\n<br>\\n\\n## **Time Complexity**:\\nTime `O(max(R,C)^2)`\\nSpace `O(R*C)` for output\\n<br>\\n\\n**Java:**\\n```java\\n    public int[][] spiralMatrixIII(int R, int C, int x, int y) {\\n        int[][] res = new int[R * C][2];\\n        int dx = 0, dy = 1, n = 0, tmp;\\n        for (int j = 0; j < R * C; ++n) {\\n            for (int i = 0; i < n / 2 + 1; ++i) {\\n                if (0 <= x && x < R && 0 <= y && y < C)\\n                    res[j++] = new int[] {x, y};\\n                x += dx;\\n                y += dy;\\n            }\\n            tmp = dx;\\n            dx = dy;\\n            dy = -tmp;\\n        }\\n        return res;\\n    }\\n```\\n**C++:**\\n```cpp\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r, int c) {\\n        vector<vector<int>> res = {{r, c}};\\n        int dx = 0, dy = 1, tmp;\\n        for (int n = 0; res.size() < R * C; n++) {\\n            for (int i = 0; i < n / 2 + 1; i++) {\\n                r += dx, c += dy;\\n                if (0 <= r && r < R && 0 <= c && c < C)\\n                    res.push_back({r, c});\\n            }\\n            tmp = dx, dx = dy, dy = -tmp;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```python\\n    def spiralMatrixIII(self, R, C, x, y):\\n        res = []\\n        dx, dy, n = 0, 1, 0\\n        while len(res) < R * C:\\n            for i in xrange(n / 2 + 1):\\n                if 0 <= x < R and 0 <= y < C:\\n                    res.append([x, y])\\n                x, y = x + dx, y + dy\\n            dx, dy, n = dy, -dx, n + 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[][] spiralMatrixIII(int R, int C, int x, int y) {\\n        int[][] res = new int[R * C][2];\\n        int dx = 0, dy = 1, n = 0, tmp;\\n        for (int j = 0; j < R * C; ++n) {\\n            for (int i = 0; i < n / 2 + 1; ++i) {\\n                if (0 <= x && x < R && 0 <= y && y < C)\\n                    res[j++] = new int[] {x, y};\\n                x += dx;\\n                y += dy;\\n            }\\n            tmp = dx;\\n            dx = dy;\\n            dy = -tmp;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r, int c) {\\n        vector<vector<int>> res = {{r, c}};\\n        int dx = 0, dy = 1, tmp;\\n        for (int n = 0; res.size() < R * C; n++) {\\n            for (int i = 0; i < n / 2 + 1; i++) {\\n                r += dx, c += dy;\\n                if (0 <= r && r < R && 0 <= c && c < C)\\n                    res.push_back({r, c});\\n            }\\n            tmp = dx, dx = dy, dy = -tmp;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def spiralMatrixIII(self, R, C, x, y):\\n        res = []\\n        dx, dy, n = 0, 1, 0\\n        while len(res) < R * C:\\n            for i in xrange(n / 2 + 1):\\n                if 0 <= x < R and 0 <= y < C:\\n                    res.append([x, y])\\n                x, y = x + dx, y + dy\\n            dx, dy, n = dy, -dx, n + 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 158977,
                "title": "java-15-lines-concise-solution-with-comments",
                "content": "```Java\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] dirt = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // east, south, west, north\\n        List<int[]> res = new ArrayList<>();\\n        int len = 0, d = 0; // move <len> steps in the <d> direction\\n        res.add(new int[]{r0, c0});\\n        while (res.size() < R * C) {\\n            if (d == 0 || d == 2) len++; // when move east or west, the length of path need plus 1 \\n            for (int i = 0; i < len; i++) {\\n                r0 += dirt[d][0];\\n                c0 += dirt[d][1];\\n                if (r0 >= 0 && r0 < R && c0 >= 0 && c0 < C) // check valid\\n                    res.add(new int[]{r0, c0});\\n            }\\n            d = (d + 1) % 4; // turn to next direction\\n        }\\n        return res.toArray(new int[R * C][2]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```Java\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] dirt = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // east, south, west, north\\n        List<int[]> res = new ArrayList<>();\\n        int len = 0, d = 0; // move <len> steps in the <d> direction\\n        res.add(new int[]{r0, c0});\\n        while (res.size() < R * C) {\\n            if (d == 0 || d == 2) len++; // when move east or west, the length of path need plus 1 \\n            for (int i = 0; i < len; i++) {\\n                r0 += dirt[d][0];\\n                c0 += dirt[d][1];\\n                if (r0 >= 0 && r0 < R && c0 >= 0 && c0 < C) // check valid\\n                    res.add(new int[]{r0, c0});\\n            }\\n            d = (d + 1) % 4; // turn to next direction\\n        }\\n        return res.toArray(new int[R * C][2]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 362319,
                "title": "super-clean-code-python",
                "content": "The idea is that you keep a \"ghost\" point which keeps moving and whenever the ghost point takes a step you check if it\\'s valid. If valid, append to the return array. \\n\\n```\\nclass Solution(object):\\n    \\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        ret = [(r0, c0)] \\n        is_valid = lambda row, col: row >= 0 and row < R and col >= 0 and col < C \\n        \\n        steps = 1 \\n        r, c = r0, c0 \\n        while len(ret) < R * C: \\n            # Go east 1\\n            for step in xrange(steps):\\n                r, c = r, c + 1 \\n                if is_valid(r, c): ret.append((r, c))\\n                    \\n            # Go down 1 \\n            for step in xrange(steps):\\n                r, c = r + 1, c \\n                if is_valid(r, c): ret.append((r, c))\\n                    \\n            steps += 1\\n                    \\n            # Go west 2 \\n            for step in xrange(steps):\\n                r, c = r, c - 1\\n                if is_valid(r, c): ret.append((r, c))           \\n            \\n            # Go north 2 \\n            for step in xrange(steps):\\n                r, c = r - 1, c \\n                if is_valid(r, c): ret.append((r, c))           \\n                    \\n            steps += 1\\n            \\n        return ret \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        ret = [(r0, c0)] \\n        is_valid = lambda row, col: row >= 0 and row < R and col >= 0 and col < C \\n        \\n        steps = 1 \\n        r, c = r0, c0 \\n        while len(ret) < R * C: \\n            # Go east 1\\n            for step in xrange(steps):\\n                r, c = r, c + 1 \\n                if is_valid(r, c): ret.append((r, c))\\n                    \\n            # Go down 1 \\n            for step in xrange(steps):\\n                r, c = r + 1, c \\n                if is_valid(r, c): ret.append((r, c))\\n                    \\n            steps += 1\\n                    \\n            # Go west 2 \\n            for step in xrange(steps):\\n                r, c = r, c - 1\\n                if is_valid(r, c): ret.append((r, c))           \\n            \\n            # Go north 2 \\n            for step in xrange(steps):\\n                r, c = r - 1, c \\n                if is_valid(r, c): ret.append((r, c))           \\n                    \\n            steps += 1\\n            \\n        return ret \\n```",
                "codeTag": "Java"
            },
            {
                "id": 158971,
                "title": "python-sort-all-coordinates",
                "content": "Put all valid coordinates to a list `res`\\n\\nSort all coordinates by the following rule:\\n\\n0. Change coordinates to a relative coordinates to center.\\n\\n1. Sort ascending by the distance to the center `max(abs(x), abs(y))`\\nIf `max(abs(x), abs(y)) == 0`, it\\'s the center.\\nIf `max(abs(x), abs(y)) == 1`, it\\'s in the first layer around the center\\n\\n2. Sort descending by the angle to the center `max(abs(x), abs(y))`\\n\\n\\n**Python:**\\n```\\n    def spiralMatrixIII(self, R, C, r, c):\\n        def key((x, y)):\\n            x, y = x - r, y - c\\n            return (max(abs(x), abs(y)), -((math.atan2(-1, 1) - math.atan2(x, y)) % (math.pi * 2)))\\n        return sorted([(i, j) for i in xrange(R) for j in xrange(C)], key=key)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def spiralMatrixIII(self, R, C, r, c):\\n        def key((x, y)):\\n            x, y = x - r, y - c\\n            return (max(abs(x), abs(y)), -((math.atan2(-1, 1) - math.atan2(x, y)) % (math.pi * 2)))\\n        return sorted([(i, j) for i in xrange(R) for j in xrange(C)], key=key)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 163370,
                "title": "simple-easy-to-understand-java-solution",
                "content": "The idea here is that once we start at (r=r0, c=c0), we walk along the east, then south, then west, and then north. \\n\\nWhen we go east, we do c++ (column increases), when we go west, we do c--, when we go south, we do r++ (row increases), and when we go north, we do r--.\\n\\nAfter starting at (r0,c0), we need to walk in spirals, where the length of the spiral increases after every two directions. For example 2, we start at (r0=1, c0=4), then we go east by one length, we go south by one length. Following that, we go west by 2 length and then, go north by 2 length. After that, we go in next directions by 3 lengths, and so on.\\n\\nThe trick here is that we continue to walk in spiral, whether the current (r,c) is valid or not. However, we add (r,c) to the result only if it is valid.\\n\\n```\\nclass Solution {\\n    int idx;\\n    int[][] ret;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ret[idx][0] = r;\\n        ret[idx++][1] = c;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ret = new int[R * C][2];\\n        while (idx < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int idx;\\n    int[][] ret;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ret[idx][0] = r;\\n        ret[idx++][1] = c;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ret = new int[R * C][2];\\n        while (idx < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511489,
                "title": "java-tc-o-max-r-c-2-sc-o-1-simulating-a-spiral-walk",
                "content": "```java\\n/**\\n * Distance covered in each direction follows 1, 1, 2, 2, 3, 3, 4, 4... pattern.\\n *\\n * Order of directions: Right, Down, Left, Up. Whenever the direction becomes\\n * right or left, the distance travelled in that direction increases by 1.\\n *\\n * So the distance travelled is sum of 1, 1, 2, 2, ... 2*max(R,C), 2*max(R,C).\\n *\\n * Time Complexity: O(max(R, C)^2)\\n *\\n * Space Complexity: O(1) -> Excluding the result.\\n *\\n * R = Input number of rows. C = Input number of columns.\\n */\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        if (rows < 0 || cols < 0 || rStart < 0 || rStart >= rows || cStart < 0 || cStart >= cols) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int totalLen = rows * cols;\\n        int[][] result = new int[totalLen][2];\\n        result[0] = new int[] { rStart, cStart };\\n        if (totalLen == 1) {\\n            return result;\\n        }\\n\\n        int dist = 0;\\n        int row = rStart;\\n        int col = cStart;\\n        int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        int dirIdx = 0;\\n        int count = 1;\\n\\n        while (count < totalLen) {\\n            if (dirIdx == 0 || dirIdx == 2) {\\n                dist++;\\n            }\\n            for (int i = 1; i <= dist; i++) {\\n                row += dirs[dirIdx][0];\\n                col += dirs[dirIdx][1];\\n                if (row >= 0 && row < rows && col >= 0 && col < cols) {\\n                    result[count++] = new int[] { row, col };\\n                    if (count == totalLen) {\\n                        return result;\\n                    }\\n                }\\n            }\\n            dirIdx = (dirIdx + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Spiral Matrix question on LeetCode:\\n- [54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/discuss/1511476/Java-or-TC:-O(M*N)-or-SC:-O(1)-or-Optimized-solution-using-Switch-Case)\\n- [59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/discuss/1511479/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Multiple-optimized-ways-to-solve-this-question)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```java\\n/**\\n * Distance covered in each direction follows 1, 1, 2, 2, 3, 3, 4, 4... pattern.\\n *\\n * Order of directions: Right, Down, Left, Up. Whenever the direction becomes\\n * right or left, the distance travelled in that direction increases by 1.\\n *\\n * So the distance travelled is sum of 1, 1, 2, 2, ... 2*max(R,C), 2*max(R,C).\\n *\\n * Time Complexity: O(max(R, C)^2)\\n *\\n * Space Complexity: O(1) -> Excluding the result.\\n *\\n * R = Input number of rows. C = Input number of columns.\\n */\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        if (rows < 0 || cols < 0 || rStart < 0 || rStart >= rows || cStart < 0 || cStart >= cols) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int totalLen = rows * cols;\\n        int[][] result = new int[totalLen][2];\\n        result[0] = new int[] { rStart, cStart };\\n        if (totalLen == 1) {\\n            return result;\\n        }\\n\\n        int dist = 0;\\n        int row = rStart;\\n        int col = cStart;\\n        int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        int dirIdx = 0;\\n        int count = 1;\\n\\n        while (count < totalLen) {\\n            if (dirIdx == 0 || dirIdx == 2) {\\n                dist++;\\n            }\\n            for (int i = 1; i <= dist; i++) {\\n                row += dirs[dirIdx][0];\\n                col += dirs[dirIdx][1];\\n                if (row >= 0 && row < rows && col >= 0 && col < cols) {\\n                    result[count++] = new int[] { row, col };\\n                    if (count == totalLen) {\\n                        return result;\\n                    }\\n                }\\n            }\\n            dirIdx = (dirIdx + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159128,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int x, int y) {\\n        \\n        vector<vector<int>>sol;\\n        int n = 0;\\n        int step=1;\\n\\twhile(n<R*C){\\n\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\ty++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\tx++;\\n\\t\\t}\\n\\t\\tstep++;\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\ty--;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\tx--;\\n\\t\\t}\\n\\t\\tstep++;\\n\\n\\n\\n\\t}\\n        \\n        return sol;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int x, int y) {\\n        \\n        vector<vector<int>>sol;\\n        int n = 0;\\n        int step=1;\\n\\twhile(n<R*C){\\n\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\ty++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\tx++;\\n\\t\\t}\\n\\t\\tstep++;\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\ty--;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\tx--;\\n\\t\\t}\\n\\t\\tstep++;\\n\\n\\n\\n\\t}\\n        \\n        return sol;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184851,
                "title": "python-beats-100",
                "content": "```\nclass Solution(object):\n    def spiralMatrixIII(self, R, C, r0, c0):\n        \"\"\"\n        :type R: int\n        :type C: int\n        :type r0: int\n        :type c0: int\n        :rtype: List[List[int]]\n        \"\"\"\n        i = r0\n        j = c0\n        coordinates = [[r0, c0]]\n        step_size = 1\n        sign = 1\n        while len(coordinates) < R*C:\n            for _ in range(step_size):\n                j += sign\n                if i < R and j < C and i >= 0 and j >= 0:\n                    coordinates.append([i, j])\n            \n            for _ in range(step_size):\n                i += sign\n                if i < R and j < C and i >= 0 and j >= 0:\n                    coordinates.append([i, j])\n            \n            step_size += 1\n            sign *= -1\n        return coordinates\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def spiralMatrixIII(self, R, C, r0, c0):\n        \"\"\"\n        :type R: int\n        :type C: int\n        :type r0: int\n        :type c0: int\n        :rtype: List[List[int]]\n        \"\"\"\n        i = r0\n        j = c0\n        coordinates = [[r0, c0]]\n        step_size = 1\n        sign = 1\n        while len(coordinates) < R*C:\n            for _ in range(step_size):\n                j += sign\n                if i < R and j < C and i >= 0 and j >= 0:\n                    coordinates.append([i, j])\n            \n            for _ in range(step_size):\n                i += sign\n                if i < R and j < C and i >= 0 and j >= 0:\n                    coordinates.append([i, j])\n            \n            step_size += 1\n            sign *= -1\n        return coordinates\n```",
                "codeTag": "Java"
            },
            {
                "id": 158954,
                "title": "java-simulation-17-lines-with-line-by-line-explanation",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] res= new int[R*C][2];\\n        res[0]=new int[]{r0, c0};\\n        int len=0, idx=1, k=0;\\n        int[] d= new int[]{0,1,0,-1,0};\\n        while (idx<R*C){\\n            len++;\\n            for (int round=0; round<2; round++){\\n                for (int sz=len; sz>0; sz--){\\n                    r0+=d[k];\\n                    c0+=d[k+1];\\n                    if (r0<0 || r0>=R || c0<0 || c0>=C) continue;\\n                    res[idx++]=new int[]{r0, c0};\\n                }\\n                k=(k+1)%4;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/caraxin/image_1534044938.png)\\n\\nHappy Coding!\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] res= new int[R*C][2];\\n        res[0]=new int[]{r0, c0};\\n        int len=0, idx=1, k=0;\\n        int[] d= new int[]{0,1,0,-1,0};\\n        while (idx<R*C){\\n            len++;\\n            for (int round=0; round<2; round++){\\n                for (int sz=len; sz>0; sz--){\\n                    r0+=d[k];\\n                    c0+=d[k+1];\\n                    if (r0<0 || r0>=R || c0<0 || c0>=C) continue;\\n                    res[idx++]=new int[]{r0, c0};\\n                }\\n                k=(k+1)%4;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483264,
                "title": "sort-coordinates-python",
                "content": "Sort by:\\n1) layer = max(&Delta;r, &Delta;c)\\n2) right-bottom half before left-top half\\n3) By r and c (increasing or decreasing depending on the half)\\n```\\ndef spiralMatrixIII(self, R, C, r0, c0):\\n    return sorted([[r, c] for r in range(R) for c in range(C)],\\n                  key=lambda (r, c): (max(abs(r - r0), abs(c - c0)),\\n                                      (0, r, -c) if r + c > r0 + c0 else (1, -r, c)))\\n```\\nWritten after seeing @lee215\\'s title \"[Sort All Coordinates](https://leetcode.com/problems/spiral-matrix-iii/discuss/158971/Python-Sort-All-Coordinates)\" but before looking at its code.",
                "solutionTags": [],
                "code": "```\\ndef spiralMatrixIII(self, R, C, r0, c0):\\n    return sorted([[r, c] for r in range(R) for c in range(C)],\\n                  key=lambda (r, c): (max(abs(r - r0), abs(c - c0)),\\n                                      (0, r, -c) if r + c > r0 + c0 else (1, -r, c)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 482757,
                "title": "c-from-approach-to-implementation-explained",
                "content": "# Observation 1- How to traverse\\nIn this approach I have traversed the path of the spiral after making a few observations. If you refer \\nExample 2, R = 5, C = 6, r0 = 1, c0 = 4, you will notice the direction of the walk does not change\\nfrom 1 to 2, \\n2 to 3, \\n3 to 5,\\n5 to 7, ....\\nHere  2-1 = 3-2\\n5-3 = 7-5\\n![image](https://assets.leetcode.com/users/debipur/image_1579243848.png)\\nThis brings us to our first observation, the length of the line along which direction does not change\\nremains equal after the odd number of changes and after even direction changes the length \\nincreases by 1.\\n# Approach\\nSo, our approach here is we keep track of our current coordinates. Also have a array which stores the\\nchange required to move right, down, left and up respectively :- {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}.\\nAccording to the no. of steps taken, position in current line and no. of direction changes we make \\nthe change to our current cordinate. At each coordinate we check whether it is a valid cell, if so we \\npush it to answer.\\n```\\ninline bool isvalid(vector<int> &cur, int R, int C){\\n\\tif(cur[0] >= 0 && cur[1] >= 0 && cur[0] < R && cur[1] < C)\\n\\t\\treturn true;\\n\\treturn false;\\n}\\n```\\n# Observation 2- How long to traverse\\nThe question is how long we need to move? If you draw(rather imagine) the spiral, for the following\\nboundary case it answers our question, R = 100, C = 1, r0 = 0, c0 = 0. You will find (2*max(R, C))^2 is\\nthe maximum number of steps you will need.\\n```\\nvector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        vector<vector<int>> ans;\\n        vector<int> cur = {r0, c0};\\n        ans.push_back(cur);\\n        vector<vector<int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int totsteps = 2*max(R, C); totsteps*=totsteps;\\n\\t\\tint stepi = 0, d = 0;                    //tracks i th step and d th direction change\\n        int linelen = 1;\\n        while(stepi <= totsteps){\\n            for(int a = 1; a <=2; ++a){          // looping twice for same length\\n                int k = 1;                       //tracks steps taken in current line\\n                while(k <= linelen){\\n                    cur[0] += dir[d][0];\\n                    cur[1] += dir[d][1];\\n                    if(isvalid(cur, R, C)) ans.push_back(cur);\\n                    k++; stepi++;\\n                }\\n                d = (d+1)%4;\\n            }\\n            linelen++;\\n        }\\n        return ans;\\n    }\\n```\\nMy first post here in leetcode :)\\nLet me know if this helped or did I leave out details.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\ninline bool isvalid(vector<int> &cur, int R, int C){\\n\\tif(cur[0] >= 0 && cur[1] >= 0 && cur[0] < R && cur[1] < C)\\n\\t\\treturn true;\\n\\treturn false;\\n}\\n```\n```\\nvector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        vector<vector<int>> ans;\\n        vector<int> cur = {r0, c0};\\n        ans.push_back(cur);\\n        vector<vector<int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int totsteps = 2*max(R, C); totsteps*=totsteps;\\n\\t\\tint stepi = 0, d = 0;                    //tracks i th step and d th direction change\\n        int linelen = 1;\\n        while(stepi <= totsteps){\\n            for(int a = 1; a <=2; ++a){          // looping twice for same length\\n                int k = 1;                       //tracks steps taken in current line\\n                while(k <= linelen){\\n                    cur[0] += dir[d][0];\\n                    cur[1] += dir[d][1];\\n                    if(isvalid(cur, R, C)) ans.push_back(cur);\\n                    k++; stepi++;\\n                }\\n                d = (d+1)%4;\\n            }\\n            linelen++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2166570,
                "title": "c-easy-explanation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> ans;\\n        ans.push_back({rStart, cStart}); //Pushing the starting point in answer\\n        int topRow = rStart-1; //Row above starting point\\n        int bottomRow = rStart+1; //Row below starting point\\n        int leftCol = cStart-1; //Col left to starting point\\n        int rightCol = cStart+1; //Col right to starting point\\n        \\n        while(topRow != -1 || bottomRow != rows || leftCol != -1 || rightCol != cols){ //Untill all rows and columns are exhausted\\n            \\n            if(rightCol != cols){ //Checking if this col is exhausted\\n                for(int i = topRow+1; i < bottomRow;i++) ans.push_back({i, rightCol}); //Running loop from one bottom of top row till bottom row in right col\\n                rightCol++; //Incrementing the col forward\\n            }\\n            //Similar things are done below with different cols and rows\\n            if(bottomRow != rows){\\n                for(int j = rightCol-1; j > leftCol; j--) ans.push_back({bottomRow, j});\\n                bottomRow++;\\n            }\\n            \\n            if(leftCol != -1){\\n                for(int i = bottomRow-1; i > topRow; i--) ans.push_back({i, leftCol});\\n                leftCol--;\\n            }\\n            \\n            if(topRow != -1){\\n                for(int j = leftCol+1; j < rightCol; j++) ans.push_back({topRow, j});\\n                topRow--;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you think this post was ***helpful***, I will be happy if you give a ***upvote***. Any questions or discussions are welcome! **Thanks a lot.** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> ans;\\n        ans.push_back({rStart, cStart}); //Pushing the starting point in answer\\n        int topRow = rStart-1; //Row above starting point\\n        int bottomRow = rStart+1; //Row below starting point\\n        int leftCol = cStart-1; //Col left to starting point\\n        int rightCol = cStart+1; //Col right to starting point\\n        \\n        while(topRow != -1 || bottomRow != rows || leftCol != -1 || rightCol != cols){ //Untill all rows and columns are exhausted\\n            \\n            if(rightCol != cols){ //Checking if this col is exhausted\\n                for(int i = topRow+1; i < bottomRow;i++) ans.push_back({i, rightCol}); //Running loop from one bottom of top row till bottom row in right col\\n                rightCol++; //Incrementing the col forward\\n            }\\n            //Similar things are done below with different cols and rows\\n            if(bottomRow != rows){\\n                for(int j = rightCol-1; j > leftCol; j--) ans.push_back({bottomRow, j});\\n                bottomRow++;\\n            }\\n            \\n            if(leftCol != -1){\\n                for(int i = bottomRow-1; i > topRow; i--) ans.push_back({i, leftCol});\\n                leftCol--;\\n            }\\n            \\n            if(topRow != -1){\\n                for(int j = leftCol+1; j < rightCol; j++) ans.push_back({topRow, j});\\n                topRow--;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351356,
                "title": "python-easy-simulation-iterative-approach-notes",
                "content": "```\\n/*\\ninitialize val to 1\\ninitialize answer set with starting index\\nAlgo\\nGo in infinite loop\\n   Go right val times, if the index is valid, add all those indexes to answer set\\n   Go Down val times, if the index is valid, add all those indexes to answer set\\n   Go Left val+1 times, if the index is valid, add all those indexes to answer set\\n   Go Up val + 1 times, if the index is valid, add all those indexes to answer set\\n   if the answer set has rows*cols entries, break out of loop and return the answer set\\n*/\\n```\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ans = [[rStart, cStart]]\\n        val = 1\\n        i, j = rStart, cStart\\n        def is_valid(i, j):\\n            if 0 <= i < rows and 0 <= j < cols:\\n                return True\\n            return False\\n        \\n        while True:\\n            if len(ans) == rows * cols:\\n                return ans\\n            \\n            # go right val times\\n            for _ in range(val):\\n                j+=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go bottom val times\\n            for _ in range(val):\\n                i+=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go left val+1 times\\n            for _ in range(val+1):\\n                j-=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go up val+1 times\\n            for _ in range(val+1):\\n                i-=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            val+=2\\n```",
                "solutionTags": [
                    "Python",
                    "Simulation"
                ],
                "code": "```\\n/*\\ninitialize val to 1\\ninitialize answer set with starting index\\nAlgo\\nGo in infinite loop\\n   Go right val times, if the index is valid, add all those indexes to answer set\\n   Go Down val times, if the index is valid, add all those indexes to answer set\\n   Go Left val+1 times, if the index is valid, add all those indexes to answer set\\n   Go Up val + 1 times, if the index is valid, add all those indexes to answer set\\n   if the answer set has rows*cols entries, break out of loop and return the answer set\\n*/\\n```\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ans = [[rStart, cStart]]\\n        val = 1\\n        i, j = rStart, cStart\\n        def is_valid(i, j):\\n            if 0 <= i < rows and 0 <= j < cols:\\n                return True\\n            return False\\n        \\n        while True:\\n            if len(ans) == rows * cols:\\n                return ans\\n            \\n            # go right val times\\n            for _ in range(val):\\n                j+=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go bottom val times\\n            for _ in range(val):\\n                i+=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go left val+1 times\\n            for _ in range(val+1):\\n                j-=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go up val+1 times\\n            for _ in range(val+1):\\n                i-=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            val+=2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633745,
                "title": "easy-c-solution",
                "content": "In the below algorithm, I have used direction parameters :\\n(0,1) for east\\n(1,0) for south\\n(0,-1) for west\\n(-1,0) for north\\n\\nEven there is a chance of getting out of the boundary, this algorithm works fine only because of this statement:\\n```\\nif(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols){\\n                    result.push_back({rStart,cStart});\\n                }\\n```\\n\\n\\nComplete Code:-\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> result = {{rStart,cStart}};\\n        \\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n        \\n        int len = 0, d = 0;\\n        \\n        while(result.size()<rows*cols){\\n            \\n            if(d==0 || d==2) len++;\\n            \\n            for(int i=0;i<len;i++){\\n                rStart+=dir[d][0];\\n                cStart+=dir[d][1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols){\\n                    result.push_back({rStart,cStart});\\n                }\\n            }\\n            d = (d+1)%4;\\n        }\\n        return result;\\n    }\\n};\\n```\\nKindly upvote if you get any help here.\\nHappy coding!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nif(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols){\\n                    result.push_back({rStart,cStart});\\n                }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> result = {{rStart,cStart}};\\n        \\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n        \\n        int len = 0, d = 0;\\n        \\n        while(result.size()<rows*cols){\\n            \\n            if(d==0 || d==2) len++;\\n            \\n            for(int i=0;i<len;i++){\\n                rStart+=dir[d][0];\\n                cStart+=dir[d][1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols){\\n                    result.push_back({rStart,cStart});\\n                }\\n            }\\n            d = (d+1)%4;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440599,
                "title": "java-solution-using-simple-walking-simulation-97",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        final int totalCellsToVisit = R * C;\\n        final int[][] cells = new int[totalCellsToVisit][2];\\n        int cellsVisited = 0;\\n        int stepLength = 1;\\n        int stepsTaken = 0;\\n        int direction = 0;\\n        int row = r0, column = c0;\\n        \\n        while (cellsVisited < totalCellsToVisit) {\\n            // If we are inside the matrix, record the position\\n            if (row >= 0 && row < R && column >= 0 && column < C) {\\n                cells[cellsVisited][0] = row;\\n                cells[cellsVisited][1] = column;\\n                cellsVisited++;\\n            }\\n            \\n            // Move a step to correct direction (0=E, 1=S, 2=W, 3=N)\\n            if (direction == 0) { column++; }\\n            else if (direction == 1) { row++; }\\n            else if (direction == 2) { column--; }\\n            else if (direction == 3) { row--; }\\n            stepsTaken++;\\n            \\n            // If we are taken the correct amount of steps to the current direction,\\n            // change direction\\n            if (stepsTaken == stepLength) {\\n                stepsTaken = 0;\\n                direction++;\\n                // When going east or west increase the steps we take for each direction\\n                if (direction == 2) {\\n                    stepLength++;\\n                    stepsTaken = 0;\\n                } else if (direction == 4) {\\n                    direction = 0;\\n                    stepLength++;\\n                    stepsTaken = 0;\\n                }\\n            }\\n        }\\n        return cells;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        final int totalCellsToVisit = R * C;\\n        final int[][] cells = new int[totalCellsToVisit][2];\\n        int cellsVisited = 0;\\n        int stepLength = 1;\\n        int stepsTaken = 0;\\n        int direction = 0;\\n        int row = r0, column = c0;\\n        \\n        while (cellsVisited < totalCellsToVisit) {\\n            // If we are inside the matrix, record the position\\n            if (row >= 0 && row < R && column >= 0 && column < C) {\\n                cells[cellsVisited][0] = row;\\n                cells[cellsVisited][1] = column;\\n                cellsVisited++;\\n            }\\n            \\n            // Move a step to correct direction (0=E, 1=S, 2=W, 3=N)\\n            if (direction == 0) { column++; }\\n            else if (direction == 1) { row++; }\\n            else if (direction == 2) { column--; }\\n            else if (direction == 3) { row--; }\\n            stepsTaken++;\\n            \\n            // If we are taken the correct amount of steps to the current direction,\\n            // change direction\\n            if (stepsTaken == stepLength) {\\n                stepsTaken = 0;\\n                direction++;\\n                // When going east or west increase the steps we take for each direction\\n                if (direction == 2) {\\n                    stepLength++;\\n                    stepsTaken = 0;\\n                } else if (direction == 4) {\\n                    direction = 0;\\n                    stepLength++;\\n                    stepsTaken = 0;\\n                }\\n            }\\n        }\\n        return cells;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945963,
                "title": "c-easy-solution-0ms-intuitive-approach",
                "content": "class Solution {\\npublic:\\n    \\n    bool Valid(int i,int j,int n,int m){\\n        if(i<0 || j<0 || j>=m || i>=n) return false;\\n        return true;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int n, int m, int x, int y) {\\n        vector<vector<int>> ans ;\\n        ans.push_back({x,y});   //initial point\\n        int len=1;\\n        while(ans.size()<n*m){              //Base Case --> once we get whole grid --> break\\n            for(int j=1;j<=len;j++){        //going right \\n                if(Valid(x,y+j,n,m)){       //Checking if this pos exists in Grid\\n                    ans.push_back({x,y+j});\\n                }\\n            }\\n            y+=len;                         //Updating the value of y coordinate \\n            for(int i=1;i<=len;i++){        //Going Down\\n                if(Valid(x+i,y,n,m)) ans.push_back({x+i,y});        //Checking if exists in Grid\\n            }\\n            x+=len;                         //Updating X coordinate \\n            len++;          //Increasing length of step in each direction \\n            for(int j=1;j<=len;j++){        //Going Left \\n                if(Valid(x,y-j,n,m)) ans.push_back({x,y-j});\\n            }\\n            y-=len;\\n            for(int i=1;i<=len;i++){        //Going Up\\n                if(Valid(x-i,y,n,m)) ans.push_back({x-i,y});\\n            }\\n            x-=len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool Valid(int i,int j,int n,int m){\\n        if(i<0 || j<0 || j>=m || i>=n) return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1426785,
                "title": "python-3-simulation-explanation",
                "content": "### Explanation\\n- Starting with a step length of `1`, move one time to right, then turn; move one time to below\\n- Increase step length, `1 + 1 = 2`, move 2 times to left, then turn; move 2 times to above\\n- So, for each step length, we will move `step` for 2 directions, then increase `step` by one; and repeat\\n- To summarize:\\n\\t- `Step == 1, move*step, turn, move*step, turn`\\n\\t- `Step += 1, move*step, turn, move*step, turn`\\n\\t- `Step += 1, move*step, turn, move*step, turn`\\n\\t- `... ... repeat`\\n### Implementation\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        total, cnt, step, i = rows * cols, 1, 1, 0\\n        ans = [[rStart, cStart]]\\n        direction = {0: (0, 1), 1: (1, 0), 2: (0, -1), 3: (-1, 0)} # setup direction movements\\n        while cnt < total:\\n            for k in range(step):\\n                rStart, cStart = rStart+direction[i][0], cStart + direction[i][1]\\n                if 0 <= rStart < rows and 0 <= cStart < cols:\\n                    ans.append([rStart, cStart])\\n                    cnt += 1       # count visited \\n            i = (i + 1) % 4        # changing direction\\n            step += not i % 2      # increase step every 2 directions\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        total, cnt, step, i = rows * cols, 1, 1, 0\\n        ans = [[rStart, cStart]]\\n        direction = {0: (0, 1), 1: (1, 0), 2: (0, -1), 3: (-1, 0)} # setup direction movements\\n        while cnt < total:\\n            for k in range(step):\\n                rStart, cStart = rStart+direction[i][0], cStart + direction[i][1]\\n                if 0 <= rStart < rows and 0 <= cStart < cols:\\n                    ans.append([rStart, cStart])\\n                    cnt += 1       # count visited \\n            i = (i + 1) % 4        # changing direction\\n            step += not i % 2      # increase step every 2 directions\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897620,
                "title": "javascript-one-pass-solution",
                "content": "The idea in each spiral both row and col movements will have the same offset. but may have different limits (or boundaries). \\nSo compute `cLimit` for column and  `rLimit`  for row and update the offset to the next spiral length whenever both `i`  add `j` are equal to their respective limits\\n\\n```\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    let offset = 1, cLimit = c0+offset, rLimit = r0+offset\\n    let i = r0, j = c0\\n    let res = []\\n    \\n    while(res.length < R*C){\\n\\t\\t//if i and j are within the boundaries of the matix and to res\\n        if(i>=0 && j>=0 && i<R && j<C){  \\n            res.push([i,j])\\n        }\\n        // if i and j are both equal to their respective limits upate offset to next spiral length and direction\\n        if(i == rLimit && cLimit == j){ \\n            offset = offset<0 ? offset-1 : offset+1\\n            offset *= -1\\n            cLimit = cLimit + offset\\n            rLimit = rLimit + offset\\n        }\\n        // each of the four possible movements through the matrix\\n        if(j<cLimit) j++\\n        else if(i<rLimit) i++\\n        else if(j>cLimit) j--\\n        else if(i>rLimit) i--\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    let offset = 1, cLimit = c0+offset, rLimit = r0+offset\\n    let i = r0, j = c0\\n    let res = []\\n    \\n    while(res.length < R*C){\\n\\t\\t//if i and j are within the boundaries of the matix and to res\\n        if(i>=0 && j>=0 && i<R && j<C){  \\n            res.push([i,j])\\n        }\\n        // if i and j are both equal to their respective limits upate offset to next spiral length and direction\\n        if(i == rLimit && cLimit == j){ \\n            offset = offset<0 ? offset-1 : offset+1\\n            offset *= -1\\n            cLimit = cLimit + offset\\n            rLimit = rLimit + offset\\n        }\\n        // each of the four possible movements through the matrix\\n        if(j<cLimit) j++\\n        else if(i<rLimit) i++\\n        else if(j>cLimit) j--\\n        else if(i>rLimit) i--\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 347424,
                "title": "java-solution-just-like-clean-robot",
                "content": "Just like robot clean problem, use```curDirection```to record the curDirection and ```(curDirection + 1) % 4```to find the next direction.\\nWhen the direction is equals 0 or 2, ```len++```\\u3002\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[] dx = new int[]{0, 1, 0, -1};\\n        int[] dy = new int[]{1, 0, -1, 0};\\n        List<int[]> list = new ArrayList<>();\\n        int curDirection = 0;\\n        list.add(new int[]{r0, c0});\\n        int len = 0;\\n        while (list.size() < R * C) {\\n            if (curDirection == 0 || curDirection == 2) len++;\\n            for (int i = 0; i < len; i++) {\\n                r0 += dx[curDirection];\\n                c0 += dy[curDirection];\\n                if (r0 < 0 || r0 >= R || c0 < 0 || c0 >= C) continue;\\n                list.add(new int[]{r0, c0});\\n            }\\n            curDirection = (curDirection + 1) % 4;\\n        }\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < res.length; i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```curDirection```\n```(curDirection + 1) % 4```\n```len++```\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[] dx = new int[]{0, 1, 0, -1};\\n        int[] dy = new int[]{1, 0, -1, 0};\\n        List<int[]> list = new ArrayList<>();\\n        int curDirection = 0;\\n        list.add(new int[]{r0, c0});\\n        int len = 0;\\n        while (list.size() < R * C) {\\n            if (curDirection == 0 || curDirection == 2) len++;\\n            for (int i = 0; i < len; i++) {\\n                r0 += dx[curDirection];\\n                c0 += dy[curDirection];\\n                if (r0 < 0 || r0 >= R || c0 < 0 || c0 >= C) continue;\\n                list.add(new int[]{r0, c0});\\n            }\\n            curDirection = (curDirection + 1) % 4;\\n        }\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < res.length; i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292721,
                "title": "c-f-cing-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> ans(rows* cols, vector<int>(2));\\n        int i=0;\\n        ans[i++]={rStart,cStart};\\n        int len=0;\\n        int d=0;\\n        int direction[]={0,1,0,-1,0};\\n        while(i<rows*cols){\\n            if(d==0 ||d==2){\\n                len++;\\n            }\\n            for(int k=0;k<len;k++){\\n                rStart+=direction[d];\\n                cStart+=direction[d+1];\\n               if(rStart<rows && rStart>=0&& cStart<cols && cStart>=0 ){\\n                    ans[i++]={rStart,cStart};\\n            \\n                } \\n            }\\n         d=++d%4;   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> ans(rows* cols, vector<int>(2));\\n        int i=0;\\n        ans[i++]={rStart,cStart};\\n        int len=0;\\n        int d=0;\\n        int direction[]={0,1,0,-1,0};\\n        while(i<rows*cols){\\n            if(d==0 ||d==2){\\n                len++;\\n            }\\n            for(int k=0;k<len;k++){\\n                rStart+=direction[d];\\n                cStart+=direction[d+1];\\n               if(rStart<rows && rStart>=0&& cStart<cols && cStart>=0 ){\\n                    ans[i++]={rStart,cStart};\\n            \\n                } \\n            }\\n         d=++d%4;   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837586,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] SpiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        List<int[]> result = new();\\n       int[,] directions = new int[,]{{0,1} ,{1,0},{0,-1},{-1,0}};\\n        int len =0;\\n        int d =0;\\n        result.Add(new int[]{rStart, cStart});\\n\\n        while(result.Count < rows * cols)\\n        {\\n            //directions right---> or left <---, increase len++\\n            if(d==0 || d==2)\\n            {\\n                len++;\\n            }\\n            for(int k=0; k<len; k++)\\n            {\\n                rStart += directions[d,0];\\n                cStart += directions[d,1];\\n                if(rStart < rows && rStart >=0 && cStart < cols && cStart >=0)\\n                {\\n                    result.Add(new int[]{rStart, cStart});\\n                }\\n            }\\n            d= (d+1) % 4;\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] SpiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        List<int[]> result = new();\\n       int[,] directions = new int[,]{{0,1} ,{1,0},{0,-1},{-1,0}};\\n        int len =0;\\n        int d =0;\\n        result.Add(new int[]{rStart, cStart});\\n\\n        while(result.Count < rows * cols)\\n        {\\n            //directions right---> or left <---, increase len++\\n            if(d==0 || d==2)\\n            {\\n                len++;\\n            }\\n            for(int k=0; k<len; k++)\\n            {\\n                rStart += directions[d,0];\\n                cStart += directions[d,1];\\n                if(rStart < rows && rStart >=0 && cStart < cols && cStart >=0)\\n                {\\n                    result.Add(new int[]{rStart, cStart});\\n                }\\n            }\\n            d= (d+1) % 4;\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718364,
                "title": "easy-python-solution-based-on-spiral-matrix-i-and-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter every iteration of a row or column we need to widen our range.\\nIf the first row we\\'re reading is length of two when we read if in reverse direction we need to add one more element to it.\\nEg. Lets read a row in to the left direction then when we eventually try to read in the reverse that is to the right direction. We include one more element. 1->2 then 5<-4<-3\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ans = []\\n        left, right = cStart, cStart+1\\n        top, bottom = rStart, rStart+1\\n        current = 1\\n        move = 0\\n        while current <= rows*cols:\\n            # fill top\\n            for i in range(left+move, right+1):\\n                if self.inbound(top, i, rows, cols):\\n                    ans.append([top, i])\\n                    current += 1\\n            left -= 1\\n            # fill right\\n            for i in range(top+1, bottom+1):\\n                if self.inbound(i, right, rows, cols):\\n                    ans.append([i, right])\\n                    current += 1\\n            top -= 1\\n            # fill bottom\\n            for i in range(right-1, left-1, -1):\\n                if self.inbound(bottom, i, rows, cols):\\n                    ans.append([bottom, i])\\n                    current += 1\\n            right += 1\\n            # fill left\\n            for i in range(bottom-1, top-1, -1):\\n                if self.inbound(i, left, rows, cols):\\n                    ans.append([i, left])\\n                    current += 1\\n            bottom += 1\\n            move = 1\\n        return ans\\n    def inbound(self, r, c, rows, cols):\\n        return 0<=r<rows and 0<=c<cols\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ans = []\\n        left, right = cStart, cStart+1\\n        top, bottom = rStart, rStart+1\\n        current = 1\\n        move = 0\\n        while current <= rows*cols:\\n            # fill top\\n            for i in range(left+move, right+1):\\n                if self.inbound(top, i, rows, cols):\\n                    ans.append([top, i])\\n                    current += 1\\n            left -= 1\\n            # fill right\\n            for i in range(top+1, bottom+1):\\n                if self.inbound(i, right, rows, cols):\\n                    ans.append([i, right])\\n                    current += 1\\n            top -= 1\\n            # fill bottom\\n            for i in range(right-1, left-1, -1):\\n                if self.inbound(bottom, i, rows, cols):\\n                    ans.append([bottom, i])\\n                    current += 1\\n            right += 1\\n            # fill left\\n            for i in range(bottom-1, top-1, -1):\\n                if self.inbound(i, left, rows, cols):\\n                    ans.append([i, left])\\n                    current += 1\\n            bottom += 1\\n            move = 1\\n        return ans\\n    def inbound(self, r, c, rows, cols):\\n        return 0<=r<rows and 0<=c<cols\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188144,
                "title": "java-spiral-matrix-iii",
                "content": "In this question first we need to observe ans understand that how the direction will change or I should say what is the condition when the iterator itr (which is traversing array(matrix)) will change its direction of iteration.\\n\\nBy observation we figured it out that iterator itr is traversing the array in a pattern or elements of array are arranged in a definite pattern \\n   itr moves 1 step in right\\n   itr then moves 1step down \\n   itr then moves 2 steps in left\\n   itr then moves 2 steps top\\n   itr then moves 3 steps in right\\n   itr then moves 3 steps down\\n   itr then moves 4 steps in left\\n   itr then moves 4 steps top\\n   itr then moves 5 step in right\\n   .\\n   .\\n   .\\n   .\\n   .\\n   .\\n   .\\n   .\\n   ans so on till the last element is reached\\n   \\n  ![image](https://assets.leetcode.com/users/images/cf928875-778b-49d7-9fc0-c5e08c1e17de_1656001345.1119683.png)\\n\\n\\n   \\n   here we can observe that itreator itr traverse the array in a pattern   1,1,2,2,3,3,4,4,5,5,6,6,.............\\n   \\n   so now we know the pattern, we have to derive the formula to get that pattern to traverse the array\\n   let  A(0)==1, A(1)==1, A(2)==2, A(3)==2, A(4)==3, A(5)==3, A(6)==4, . . . . . . . . . . . . . . and so on\\n   \\n   so, by this we can conclude\\n        A(n)= n/2 + 1;\\n\\t\\there n belong to (0, length of row of ans)\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n   Now, we have one more challenge to change the direction of array in this we have four cases\\n  Case 1:-  When iterate from left to right\\n\\t\\t\\t\\t  here we need to increment the column index only \\n\\n  Case 2:- When iterate from top to bottom\\n\\t\\t\\t\\there we need to increment the row index only\\n\\n  Case 3:- When iterate from right to left\\n\\t\\t\\t\\there we need to decrement the column index only\\n\\n  Case 4:- When iterate from bottom to top \\n\\t\\t\\t\\there we need to decrement the row index only\\n\\t\\t\\t\\t\\t\\nTo handle or perform the above for cases we can do this by using simple technique\\ntake   int dx=0, dy=1, temp=0;\\nand    rStart==x, cStart=y\\n\\nnow just perfor this simple following code when the inner loop has done traversing in one direction or  you can say after  the completion of inner loop \\n\\ntemp=dx;\\ndx=dy;\\ndy= -tmp;\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t```\\n\\t\\t\\n\\t\\tclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int x, int y) {\\n        \\n        int[][] ans=new int[rows*cols][2];\\n        int n=0;\\n        int dx=0;\\n        int dy=1;\\n        int temp=0;\\n        \\n        for(int j=0;j<rows*cols;++n){\\n            for(int i=0;i< n/2 + 1;++i){\\n                \\n                if(x>=0 && x<rows && y>=0 && y<cols){\\n                    // here we are assigning the new 1D array to row of 2D array (ans) \\n                    // it will remind you some basic concept of aray that every thing in java is an object\\n                    ans[j++]=new int[]{x,y};\\n                }\\n                \\n                x=x+dx;\\n                y=y+dy;\\n            }\\n            // by this code we will change the direction of array(ans) traversing\\n            // left to right\\n            // top to bottom\\n            // right to left\\n            // bottom to up\\n            temp=dx;\\n            dx=dy;\\n            dy= -temp;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\\n\\t\\t\\n",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\n\\t\\t\\n\\t\\tclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int x, int y) {\\n        \\n        int[][] ans=new int[rows*cols][2];\\n        int n=0;\\n        int dx=0;\\n        int dy=1;\\n        int temp=0;\\n        \\n        for(int j=0;j<rows*cols;++n){\\n            for(int i=0;i< n/2 + 1;++i){\\n                \\n                if(x>=0 && x<rows && y>=0 && y<cols){\\n                    // here we are assigning the new 1D array to row of 2D array (ans) \\n                    // it will remind you some basic concept of aray that every thing in java is an object\\n                    ans[j++]=new int[]{x,y};\\n                }\\n                \\n                x=x+dx;\\n                y=y+dy;\\n            }\\n            // by this code we will change the direction of array(ans) traversing\\n            // left to right\\n            // top to bottom\\n            // right to left\\n            // bottom to up\\n            temp=dx;\\n            dx=dy;\\n            dy= -temp;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941300,
                "title": "c-easy-understanding",
                "content": "intution :\\nin each iteration you are traversing a square \\n     ->  downwards -> leftwards ->upwards ->righwards\\nwhile traversing check if the cell is within the grid\\nif with in the grid assign the value of count and increment count value\\nafter each iteration update the value of l,r,t,b\\n\\nl = index of left most column\\nr = index of right most column\\nt = index of top  row\\nb = index of bottom row\\n```\\nclass Solution {\\npublic:\\n    int m1,n1;\\n    void solve(vector<vector<int>>&res,int r,int c,int &ct){\\n        if(r>=0 && r<m1 && c>=0 && c<n1){\\n            {res.push_back({r,c});ct++;}\\n        }\\n    }\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int rs, int cs) {\\n        \\n        vector<vector<int>>res;\\n        res.push_back({rs,cs});\\n        int l=cs-1,r=cs+1,t=rs-1,b=rs+1,ct=2;\\n        m1=m;n1=n;\\n        while(ct<=m*n){\\n            for(int i=t+1;i<b;i++) solve(res,i,r,ct);\\n            for(int i=r;i>=l;i--)  solve(res,b,i,ct);\\n            for(int i=b-1;i>t;i--) solve(res,i,l,ct);\\n            for(int i=l;i<=r;i++)  solve(res,t,i,ct);\\n            r++;l--;t--;b++;\\n        }\\n        return res;\\n    }\\n};\\n```\\nplease upvote if you like .\\nHappy coding :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m1,n1;\\n    void solve(vector<vector<int>>&res,int r,int c,int &ct){\\n        if(r>=0 && r<m1 && c>=0 && c<n1){\\n            {res.push_back({r,c});ct++;}\\n        }\\n    }\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int rs, int cs) {\\n        \\n        vector<vector<int>>res;\\n        res.push_back({rs,cs});\\n        int l=cs-1,r=cs+1,t=rs-1,b=rs+1,ct=2;\\n        m1=m;n1=n;\\n        while(ct<=m*n){\\n            for(int i=t+1;i<b;i++) solve(res,i,r,ct);\\n            for(int i=r;i>=l;i--)  solve(res,b,i,ct);\\n            for(int i=b-1;i>t;i--) solve(res,i,l,ct);\\n            for(int i=l;i<=r;i++)  solve(res,t,i,ct);\\n            r++;l--;t--;b++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637681,
                "title": "python3-simple",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        res=[]\\n        rowMin=rStart\\n        rowMax=rStart+1\\n        colMin=cStart\\n        colMax=cStart+1\\n        while len(res)!=rows*cols:\\n            \\n            for col in range(colMin,colMax):\\n                if 0<=col<cols and 0<=rowMin<rows: res.append([rowMin,col])\\n            \\n            for row in range(rowMin,rowMax):\\n                if 0<=colMax<cols and 0<=row<rows: res.append([row,colMax])\\n            \\n            colMin-=1\\n            \\n            for col in range(colMax,colMin,-1):\\n                if 0<=col<cols and 0<=rowMax<rows: res.append([rowMax,col])\\n            \\n            rowMin-=1\\n            \\n            for row in range(rowMax,rowMin,-1):\\n                if 0<=colMin<cols and 0<=row<rows: res.append([row,colMin])\\n            \\n            colMax+=1\\n            rowMax+=1\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        res=[]\\n        rowMin=rStart\\n        rowMax=rStart+1\\n        colMin=cStart\\n        colMax=cStart+1\\n        while len(res)!=rows*cols:\\n            \\n            for col in range(colMin,colMax):\\n                if 0<=col<cols and 0<=rowMin<rows: res.append([rowMin,col])\\n            \\n            for row in range(rowMin,rowMax):\\n                if 0<=colMax<cols and 0<=row<rows: res.append([row,colMax])\\n            \\n            colMin-=1\\n            \\n            for col in range(colMax,colMin,-1):\\n                if 0<=col<cols and 0<=rowMax<rows: res.append([rowMax,col])\\n            \\n            rowMin-=1\\n            \\n            for row in range(rowMax,rowMin,-1):\\n                if 0<=colMin<cols and 0<=row<rows: res.append([row,colMin])\\n            \\n            colMax+=1\\n            rowMax+=1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607741,
                "title": "cpp-solution-faster-than-99-12",
                "content": "On observing we need to take take steps in each direction two times, like we start from left, then we take one step to left than we go down(directed to) and take one step there, after that we need to take 2 steps the same way to right and to up, the  solution is the sollowing the same rule> I know its a bit lengthy but ***TIME MATTERS*** most IMO.(99.12%)\\n```\\nvector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n\\t\\t//base case\\n        if(rows==1 && cols==1){\\n            temp.push_back(0);\\n            temp.push_back(0);\\n            ans.push_back(temp);\\n            return ans;\\n        }\\n        int steps=1;\\n        int n=2;\\n        int size=0;\\n        int x=rStart,y=cStart;\\n\\t\\t\\n\\t\\t//variable for tracking the direction\\n        char dir=\\'r\\';\\n\\t\\t\\n\\t\\t//for first step\\n        temp.push_back(x);\\n        temp.push_back(y);\\n        ans.push_back(temp);\\n        size++;\\n        temp.clear();\\n        while(size<=cols*rows){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<steps;j++){\\n                    if(dir==\\'r\\')y++;\\n                    else if(dir==\\'b\\')x++;\\n                    else if(dir==\\'l\\')y--;\\n                    else if(dir==\\'u\\')x--;\\n                    if(x>=0 && x<rows && y>=0 && y<cols){\\n                        temp.push_back(x);\\n                        temp.push_back(y);\\n                        ans.push_back(temp);\\n                        temp.clear();\\n                        size++;\\n                        if(size==cols*rows)return ans;\\n                    }\\n                }\\n                if(dir==\\'r\\')dir=\\'b\\';\\n                else if(dir==\\'b\\')dir=\\'l\\';\\n                else if(dir==\\'l\\')dir=\\'u\\';\\n                else if(dir==\\'u\\')dir=\\'r\\';\\n            }\\n\\t\\t\\t//after two iterations in 2 directions we need to change the number of steps\\n            steps++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n\\t\\t//base case\\n        if(rows==1 && cols==1){\\n            temp.push_back(0);\\n            temp.push_back(0);\\n            ans.push_back(temp);\\n            return ans;\\n        }\\n        int steps=1;\\n        int n=2;\\n        int size=0;\\n        int x=rStart,y=cStart;\\n\\t\\t\\n\\t\\t//variable for tracking the direction\\n        char dir=\\'r\\';\\n\\t\\t\\n\\t\\t//for first step\\n        temp.push_back(x);\\n        temp.push_back(y);\\n        ans.push_back(temp);\\n        size++;\\n        temp.clear();\\n        while(size<=cols*rows){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<steps;j++){\\n                    if(dir==\\'r\\')y++;\\n                    else if(dir==\\'b\\')x++;\\n                    else if(dir==\\'l\\')y--;\\n                    else if(dir==\\'u\\')x--;\\n                    if(x>=0 && x<rows && y>=0 && y<cols){\\n                        temp.push_back(x);\\n                        temp.push_back(y);\\n                        ans.push_back(temp);\\n                        temp.clear();\\n                        size++;\\n                        if(size==cols*rows)return ans;\\n                    }\\n                }\\n                if(dir==\\'r\\')dir=\\'b\\';\\n                else if(dir==\\'b\\')dir=\\'l\\';\\n                else if(dir==\\'l\\')dir=\\'u\\';\\n                else if(dir==\\'u\\')dir=\\'r\\';\\n            }\\n\\t\\t\\t//after two iterations in 2 directions we need to change the number of steps\\n            steps++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 600122,
                "title": "java-straightforward-solution",
                "content": "```\\n\\tpublic int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] ret = new int[R*C][2];\\n        int step = 1;\\n        int i = 0;\\n        int r = r0;\\n        int c = c0;\\n        int offset = 1;\\n        while (i < R*C) {\\n            for (int j = 0; j < step; j++) {\\n                if (r >= 0 && c >= 0 && r < R && c < C && i < R*C) {\\n                    ret[i][0] = r;\\n                    ret[i][1] = c;\\n                    i++;\\n                }\\n                c += offset;\\n            }\\n            for (int j = 0; j < step; j++) {\\n                if (r >= 0 && c >= 0 && r < R && c < C && i < R*C) {\\n                    ret[i][0] = r;\\n                    ret[i][1] = c;\\n                    i++;\\n                }\\n                r += offset;\\n            }\\n            step++;\\n            offset = -offset;\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] ret = new int[R*C][2];\\n        int step = 1;\\n        int i = 0;\\n        int r = r0;\\n        int c = c0;\\n        int offset = 1;\\n        while (i < R*C) {\\n            for (int j = 0; j < step; j++) {\\n                if (r >= 0 && c >= 0 && r < R && c < C && i < R*C) {\\n                    ret[i][0] = r;\\n                    ret[i][1] = c;\\n                    i++;\\n                }\\n                c += offset;\\n            }\\n            for (int j = 0; j < step; j++) {\\n                if (r >= 0 && c >= 0 && r < R && c < C && i < R*C) {\\n                    ret[i][0] = r;\\n                    ret[i][1] = c;\\n                    i++;\\n                }\\n                r += offset;\\n            }\\n            step++;\\n            offset = -offset;\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 159178,
                "title": "javascript-solution-straightforward-with-graph",
                "content": "The key point is to traverse the elements in correct order.\\n### Steps:\\n* Find out how many times we should do the traversal (four lines one time, as shown in the graph);\\n* Each time, we traverse four lines, and we push every element we meet, no matter whether they belong to the matrix or not;\\n* We filter the result we got, and leave only elements that belong to the matrix.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lmiaoj/image_1534089926.png)\\n\\n```\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    let n = Math.max(r0, c0, R-1-r0, C-1-c0);\\n    let res = [[r0,c0]];\\n    for(let i=1; i<=n; i++){\\n    \\tfor(let j=1-i; j<=i; j++) res.push([r0+j,c0+i]); //line 1\\n    \\tfor(let j=i-1; j>=-i; j--) res.push([r0+i,c0+j]); //line 2\\n    \\tfor(let j=i-1; j>=-i; j--) res.push([r0+j,c0-i]); //line 3\\n    \\tfor(let j=1-i; j<=i; j++) res.push([r0-i,c0+j]); //line 4\\n    }\\n    return res.filter(x=>x[0]>=0&&x[0]<R&&x[1]>=0&&x[1]<C);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    let n = Math.max(r0, c0, R-1-r0, C-1-c0);\\n    let res = [[r0,c0]];\\n    for(let i=1; i<=n; i++){\\n    \\tfor(let j=1-i; j<=i; j++) res.push([r0+j,c0+i]); //line 1\\n    \\tfor(let j=i-1; j>=-i; j--) res.push([r0+i,c0+j]); //line 2\\n    \\tfor(let j=i-1; j>=-i; j--) res.push([r0+j,c0-i]); //line 3\\n    \\tfor(let j=1-i; j<=i; j++) res.push([r0-i,c0+j]); //line 4\\n    }\\n    return res.filter(x=>x[0]>=0&&x[0]<R&&x[1]>=0&&x[1]<C);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3709692,
                "title": "c-simple-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraversing spirally and checking whether that element belong to matrix or not\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are traversing the matrix spirally and for each element we are checking  whether it lies in matrix or not and if len of answer becomes equal to rows*cols, we return.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(rows*rows*cols*cols)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int i,int j, int row, int col)\\n    {\\n        return (i>=0 && j>=0 && i<row && j<col);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        ans.push_back({rStart,cStart});\\n\\n        int step = 1;\\n        int i = rStart,j = cStart;\\n\\n        while(ans.size() < rows*cols)\\n        {\\n            if(ans.size()==rows*cols)\\n            return ans;\\n\\n            int k=0;\\n            while(k<step)\\n            {\\n                j++;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                i++;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            step++;\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                j--;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                i--;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            step++;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int i,int j, int row, int col)\\n    {\\n        return (i>=0 && j>=0 && i<row && j<col);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        ans.push_back({rStart,cStart});\\n\\n        int step = 1;\\n        int i = rStart,j = cStart;\\n\\n        while(ans.size() < rows*cols)\\n        {\\n            if(ans.size()==rows*cols)\\n            return ans;\\n\\n            int k=0;\\n            while(k<step)\\n            {\\n                j++;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                i++;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            step++;\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                j--;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                i--;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            step++;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508037,
                "title": "easy-to-understand-approach-commented",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int nrow,int ncol,int n,int m){\\n        return nrow>=0 && nrow<n && ncol>=0 && ncol<m ;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>>spiral;\\n        spiral.push_back({rStart,cStart});\\n        //till now, 1 coordinate used \\n        int used=1,move=1; \\n        while(used<rows*cols){\\n \\n            //for right movement first [1,2,3...]\\n            int canMove=move;\\n            while(canMove--){\\n                //row remains same column changes\\n                cStart++;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n\\n            //for down movement \\n              canMove=move;\\n            while(canMove--){\\n                //column remains same row changes\\n                rStart++;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            //AFTER ONE SET OF RIGHT-DOWN MOVEMENT MOVE INCREASES BY 1 \\n            move++;\\n            \\n\\n            //for left movement \\n              canMove=move;\\n            while(canMove--){\\n                //row remains same column changes\\n                cStart--;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            \\n            //for up movement \\n              canMove=move;\\n            while(canMove--){\\n                //column remains same row changes\\n                rStart--;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            //AFTER ONE SET OF LEFT-UP MOVEMENT MOVE INCREASES BY 1 \\n            move++;\\n        }\\n        return spiral;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int nrow,int ncol,int n,int m){\\n        return nrow>=0 && nrow<n && ncol>=0 && ncol<m ;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>>spiral;\\n        spiral.push_back({rStart,cStart});\\n        //till now, 1 coordinate used \\n        int used=1,move=1; \\n        while(used<rows*cols){\\n \\n            //for right movement first [1,2,3...]\\n            int canMove=move;\\n            while(canMove--){\\n                //row remains same column changes\\n                cStart++;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n\\n            //for down movement \\n              canMove=move;\\n            while(canMove--){\\n                //column remains same row changes\\n                rStart++;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            //AFTER ONE SET OF RIGHT-DOWN MOVEMENT MOVE INCREASES BY 1 \\n            move++;\\n            \\n\\n            //for left movement \\n              canMove=move;\\n            while(canMove--){\\n                //row remains same column changes\\n                cStart--;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            \\n            //for up movement \\n              canMove=move;\\n            while(canMove--){\\n                //column remains same row changes\\n                rStart--;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            //AFTER ONE SET OF LEFT-UP MOVEMENT MOVE INCREASES BY 1 \\n            move++;\\n        }\\n        return spiral;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399551,
                "title": "java-beats-100-0ms-runtime-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(rows * cols)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] matrix = new int[rows*cols][2];\\n        int k = 0;\\n        \\n        int rEnd = rStart + 1;\\n        int cEnd = cStart + 1;\\n\\n        while(true) {\\n            // right \\n            for(int i = cStart; i <= cEnd; i++) {\\n                if(i < cols && i >= 0 && rStart >= 0) {\\n                    matrix[k][0] = rStart;\\n                    matrix[k][1] = i;\\n                    k++;\\n                }\\n            }\\n            cStart--;\\n            cEnd++;\\n\\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // down \\n            for(int i = rStart + 1; i <= rEnd; i++) {\\n                if(i < rows && i >= 0 && cEnd - 1 < cols) {\\n                    matrix[k][0] = i;\\n                    matrix[k][1] = cEnd - 1;\\n                    k++;\\n                }\\n            }\\n            rStart--;\\n            rEnd++;\\n\\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // left\\n            for(int i = cEnd - 2; i >= cStart; i--) {\\n                if(i >= 0 && i < cols && rEnd - 1 < rows) {\\n                    matrix[k][0] = rEnd - 1;\\n                    matrix[k][1] = i;\\n                    k++;\\n                }\\n            }\\n        \\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // up\\n            for(int i = rEnd - 2; i > rStart; i--) {\\n                if(i >= 0 && i < rows && cStart >= 0) {\\n                    matrix[k][0] = i;\\n                    matrix[k][1] = cStart;\\n                    k++;\\n                }\\n            }\\n        \\n            if(k == matrix.length) {\\n                break;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] matrix = new int[rows*cols][2];\\n        int k = 0;\\n        \\n        int rEnd = rStart + 1;\\n        int cEnd = cStart + 1;\\n\\n        while(true) {\\n            // right \\n            for(int i = cStart; i <= cEnd; i++) {\\n                if(i < cols && i >= 0 && rStart >= 0) {\\n                    matrix[k][0] = rStart;\\n                    matrix[k][1] = i;\\n                    k++;\\n                }\\n            }\\n            cStart--;\\n            cEnd++;\\n\\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // down \\n            for(int i = rStart + 1; i <= rEnd; i++) {\\n                if(i < rows && i >= 0 && cEnd - 1 < cols) {\\n                    matrix[k][0] = i;\\n                    matrix[k][1] = cEnd - 1;\\n                    k++;\\n                }\\n            }\\n            rStart--;\\n            rEnd++;\\n\\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // left\\n            for(int i = cEnd - 2; i >= cStart; i--) {\\n                if(i >= 0 && i < cols && rEnd - 1 < rows) {\\n                    matrix[k][0] = rEnd - 1;\\n                    matrix[k][1] = i;\\n                    k++;\\n                }\\n            }\\n        \\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // up\\n            for(int i = rEnd - 2; i > rStart; i--) {\\n                if(i >= 0 && i < rows && cStart >= 0) {\\n                    matrix[k][0] = i;\\n                    matrix[k][1] = cStart;\\n                    k++;\\n                }\\n            }\\n        \\n            if(k == matrix.length) {\\n                break;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152133,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int idx;\\n    int[][] ret;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ret[idx][0] = r;\\n        ret[idx++][1] = c;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ret = new int[R * C][2];\\n        while (idx < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int idx;\\n    int[][] ret;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ret[idx][0] = r;\\n        ret[idx++][1] = c;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ret = new int[R * C][2];\\n        while (idx < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010933,
                "title": "c-commented-solution",
                "content": "# Intuition\\nThe below code works like this:\\n\\n```\\nstartPos {Row, Col}\\nloop 1:\\nCol -> + 1, Row -> + 0\\nCol -> + 0, Row -> + 1\\n++ Counter\\nloop 2:\\nCol -> - 1, Row -> + 0\\nCol -> - 1, Row -> + 0\\nCol -> + 0, Row -> - 1\\nCol -> + 0, Row -> - 1\\n++ Counter\\n...\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result;\\n        vector<int> startPos {rStart, cStart};\\n        result.push_back(startPos);\\n\\n        // For each walk, firstly we move the column by \"\"counter\"\" steps,\\n        //                secondly we move the row by \"\"counter\"\" steps,\\n        // Note that the step direction will depend on the \"counter % 2 == 0\"\\n        int counter {1};\\n        while(result.size() != rows * cols) {\\n            for (int i = 1; i <= counter; ++ i) {\\n                startPos[1] = startPos[1] + (counter % 2 == 0 ? -1 : 1);\\n                if (startPos[1] >= 0 && startPos[0] >= 0 && startPos[1] < cols && startPos[0] < rows)\\n                    result.push_back(startPos);\\n            }\\n\\n            for (int i = 1; i <= counter; ++ i) {\\n                startPos[0] = startPos[0] + (counter % 2 == 0 ? -1 : 1);\\n                if (startPos[1] >= 0 && startPos[0] >= 0 && startPos[1] < cols && startPos[0] < rows)\\n                    result.push_back(startPos);\\n            }\\n            \\n            ++ counter;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstartPos {Row, Col}\\nloop 1:\\nCol -> + 1, Row -> + 0\\nCol -> + 0, Row -> + 1\\n++ Counter\\nloop 2:\\nCol -> - 1, Row -> + 0\\nCol -> - 1, Row -> + 0\\nCol -> + 0, Row -> - 1\\nCol -> + 0, Row -> - 1\\n++ Counter\\n...\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result;\\n        vector<int> startPos {rStart, cStart};\\n        result.push_back(startPos);\\n\\n        // For each walk, firstly we move the column by \"\"counter\"\" steps,\\n        //                secondly we move the row by \"\"counter\"\" steps,\\n        // Note that the step direction will depend on the \"counter % 2 == 0\"\\n        int counter {1};\\n        while(result.size() != rows * cols) {\\n            for (int i = 1; i <= counter; ++ i) {\\n                startPos[1] = startPos[1] + (counter % 2 == 0 ? -1 : 1);\\n                if (startPos[1] >= 0 && startPos[0] >= 0 && startPos[1] < cols && startPos[0] < rows)\\n                    result.push_back(startPos);\\n            }\\n\\n            for (int i = 1; i <= counter; ++ i) {\\n                startPos[0] = startPos[0] + (counter % 2 == 0 ? -1 : 1);\\n                if (startPos[1] >= 0 && startPos[0] >= 0 && startPos[1] < cols && startPos[0] < rows)\\n                    result.push_back(startPos);\\n            }\\n            \\n            ++ counter;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777454,
                "title": "c-solution-with-explanation-and-complexity",
                "content": "After solving a few examples by myself, I found some observations:\\n* The number of grids that we are traversing in one direction starts from 1 and after traversing two direction it increases. I have called it as **checker** in code\\n* For stoping the traversal, we have to count all rows * cols grids. So i created **counter**\\n* Before pushing the coordinates in the ans vector, we need to check if it belongs inside the matrix or not. For that \\n\\t\\t0 <= i <= rows\\n\\t\\t0 <= j <= cols\\nwhere i is the index for row and j is the index for column.\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/ea296c0e-0175-4170-816b-133d40d94c51_1667559130.6659496.jpeg)\\n\\n**Space Complexity**: O(rows * cols)\\n**Time Complexity:** O(6 + (n - 1)* 8), where n = max(rows, cols)\\n```\\nclass Solution {\\npublic:\\n\\n\\t//function to check if i and j belong to matrix or not\\n    bool valid_to_push(int i, int j, int rows, int cols){\\n        if(i>=0 && i<rows && j>=0 && j<cols)\\n            return true;\\n        return false;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int counter, direction, checker;\\n        ans.push_back({rStart, cStart});\\n        counter = 1; \\n        direction = 0;\\n        checker = 1;\\n        \\n        int i = rStart, j = cStart;\\n\\t\\t\\n        while(counter != rows * cols){\\n\\t\\t\\t// for direction 0\\n            if(direction == 0){\\n\\t\\t\\t\\t// only traverse till checker\\n                for(int k = 1; k<= checker; k++){\\n                    j++;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 1; //change direction\\n            }\\n\\t\\t\\t// for direction 1\\n            if(direction == 1){\\n                for(int k = 1; k<= checker; k++){\\n                    i++;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 2; //change direction\\n            }\\n            checker++; // increase after traversing two direction\\n\\t\\t\\t\\n\\t\\t\\t// for direction 2\\n            if(direction == 2){\\n                for(int k = 1; k<= checker; k++){\\n                    j--;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 3; //change direction\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// for direction 3\\n            if(direction == 3){\\n                for(int k = 1; k<= checker; k++){\\n                    i--;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 0; //change direction\\n            }\\n            checker++; // increase after traversing two direction\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\t//function to check if i and j belong to matrix or not\\n    bool valid_to_push(int i, int j, int rows, int cols){\\n        if(i>=0 && i<rows && j>=0 && j<cols)\\n            return true;\\n        return false;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int counter, direction, checker;\\n        ans.push_back({rStart, cStart});\\n        counter = 1; \\n        direction = 0;\\n        checker = 1;\\n        \\n        int i = rStart, j = cStart;\\n\\t\\t\\n        while(counter != rows * cols){\\n\\t\\t\\t// for direction 0\\n            if(direction == 0){\\n\\t\\t\\t\\t// only traverse till checker\\n                for(int k = 1; k<= checker; k++){\\n                    j++;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 1; //change direction\\n            }\\n\\t\\t\\t// for direction 1\\n            if(direction == 1){\\n                for(int k = 1; k<= checker; k++){\\n                    i++;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 2; //change direction\\n            }\\n            checker++; // increase after traversing two direction\\n\\t\\t\\t\\n\\t\\t\\t// for direction 2\\n            if(direction == 2){\\n                for(int k = 1; k<= checker; k++){\\n                    j--;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 3; //change direction\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// for direction 3\\n            if(direction == 3){\\n                for(int k = 1; k<= checker; k++){\\n                    i--;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 0; //change direction\\n            }\\n            checker++; // increase after traversing two direction\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692625,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][];\\n        int k = 0;\\n        res[k++] = new int[]{rStart, cStart};\\n        int[] direction = {0, 1, 0, -1, 0};\\n        int d = 0;\\n        int len = 0;\\n        while(k < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int i = 0; i < len; i++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart > -1 && rStart < rows && cStart > -1 && cStart < cols){\\n                    res[k++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][];\\n        int k = 0;\\n        res[k++] = new int[]{rStart, cStart};\\n        int[] direction = {0, 1, 0, -1, 0};\\n        int d = 0;\\n        int len = 0;\\n        while(k < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int i = 0; i < len; i++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart > -1 && rStart < rows && cStart > -1 && cStart < cols){\\n                    res[k++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131312,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/689bb355-4bde-4d86-bac1-13b88f5cb601_1654783840.3640954.png)\\n```\\nint** spiralMatrixIII(int rows, int cols, int rStart, int cStart, int* returnSize, int** returnColumnSizes) {\\n    (*returnSize) = rows * cols;\\n    *returnColumnSizes = (int*) malloc((*returnSize) * sizeof(int));\\n    int** res = (int**) malloc((*returnSize) * sizeof(int*));\\n    for (int i = 0; i < (*returnSize); i++) {\\n        res[i] = (int*) calloc(2, sizeof(int));\\n        (*returnColumnSizes)[i] = 2;\\n    }\\n    res[0][0] = rStart; res[0][1] = cStart;\\n    int up = 1, right = 1, cntRL = 0, cntUD = 0, idx = 1;\\n    while (idx < (*returnSize)) {\\n        for (int shift = 1; shift <= right; shift++) {\\n            cStart = (cntRL % 2 == 0) ? cStart + 1 : cStart - 1;\\n            if (rStart < rows && cStart < cols && rStart > -1 && cStart > -1) {\\n                res[idx][0] = rStart;\\n                res[idx][1] = cStart;\\n                idx++;\\n            }\\n        }\\n        cntRL++;\\n        right++;\\n        for (int shift = 1; shift <= up; shift++) {\\n            rStart = (cntUD % 2 == 0) ? rStart + 1 : rStart - 1;\\n            if (rStart < rows && cStart < cols && rStart > -1 && cStart > -1) {\\n                res[idx][0] = rStart;\\n                res[idx][1] = cStart;\\n                idx++;\\n            }\\n        }\\n        cntUD++;\\n        up++;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** spiralMatrixIII(int rows, int cols, int rStart, int cStart, int* returnSize, int** returnColumnSizes) {\\n    (*returnSize) = rows * cols;\\n    *returnColumnSizes = (int*) malloc((*returnSize) * sizeof(int));\\n    int** res = (int**) malloc((*returnSize) * sizeof(int*));\\n    for (int i = 0; i < (*returnSize); i++) {\\n        res[i] = (int*) calloc(2, sizeof(int));\\n        (*returnColumnSizes)[i] = 2;\\n    }\\n    res[0][0] = rStart; res[0][1] = cStart;\\n    int up = 1, right = 1, cntRL = 0, cntUD = 0, idx = 1;\\n    while (idx < (*returnSize)) {\\n        for (int shift = 1; shift <= right; shift++) {\\n            cStart = (cntRL % 2 == 0) ? cStart + 1 : cStart - 1;\\n            if (rStart < rows && cStart < cols && rStart > -1 && cStart > -1) {\\n                res[idx][0] = rStart;\\n                res[idx][1] = cStart;\\n                idx++;\\n            }\\n        }\\n        cntRL++;\\n        right++;\\n        for (int shift = 1; shift <= up; shift++) {\\n            rStart = (cntUD % 2 == 0) ? rStart + 1 : rStart - 1;\\n            if (rStart < rows && cStart < cols && rStart > -1 && cStart > -1) {\\n                res[idx][0] = rStart;\\n                res[idx][1] = cStart;\\n                idx++;\\n            }\\n        }\\n        cntUD++;\\n        up++;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1946605,
                "title": "easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // {0,1,0,-1,0}   directions  0-> col++, 1->row++, 2-> col-- 3->row--\\n        \\n        \\n        int directions[]={0,1,0,-1,0} ;\\n        \\n        int steps=0;\\n        int move=0;\\n        int count=0;\\n        int ans[][]=new int[rows*cols][2];\\n        ans[count][0]=rStart;\\n        ans[count][1]=cStart;\\n        count++;\\n        \\n        int row=rStart,col=cStart;\\n        \\n        while(count<rows*cols)\\n        {\\n            if(move==0 || move== 2)\\n                steps++;\\n            \\n            for(int i=0;i<steps;i++)\\n            {\\n                row+=directions[move];\\n                col+=directions[move+1];\\n               if(row<rows && row>=0 && col<cols && col>=0)\\n               {\\n                ans[count][0]=row;\\n                ans[count][1]=col;\\n                count++;\\n               }\\n                \\n            }\\n            if(move!=0)\\n            move=(move+1)%4;\\n            else \\n                move++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // {0,1,0,-1,0}   directions  0-> col++, 1->row++, 2-> col-- 3->row--\\n        \\n        \\n        int directions[]={0,1,0,-1,0} ;\\n        \\n        int steps=0;\\n        int move=0;\\n        int count=0;\\n        int ans[][]=new int[rows*cols][2];\\n        ans[count][0]=rStart;\\n        ans[count][1]=cStart;\\n        count++;\\n        \\n        int row=rStart,col=cStart;\\n        \\n        while(count<rows*cols)\\n        {\\n            if(move==0 || move== 2)\\n                steps++;\\n            \\n            for(int i=0;i<steps;i++)\\n            {\\n                row+=directions[move];\\n                col+=directions[move+1];\\n               if(row<rows && row>=0 && col<cols && col>=0)\\n               {\\n                ans[count][0]=row;\\n                ans[count][1]=col;\\n                count++;\\n               }\\n                \\n            }\\n            if(move!=0)\\n            move=(move+1)%4;\\n            else \\n                move++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943274,
                "title": "c-solution-intutive",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int result=rows*cols;\\n        int limit=1;\\n        int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\\n        int d=0;\\n        vector<vector<int>>ans={{rStart,cStart}};\\n        int no=1;\\n        while(ans.size()!=result)\\n        {\\n            for(int i=0;i<limit;i++)\\n            {\\n                rStart+=dir[d][0];\\n                cStart+=dir[d][1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols)\\n                {\\n                    ans.push_back({rStart,cStart});\\n                }\\n            }\\n                \\n                \\n                d=(d+1)%4;\\n            if(no==2)\\n            {\\n                limit++;no=1;\\n            }\\n            else no++;\\n                \\n                \\n                \\n        }\\n        return ans;\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int result=rows*cols;\\n        int limit=1;\\n        int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\\n        int d=0;\\n        vector<vector<int>>ans={{rStart,cStart}};\\n        int no=1;\\n        while(ans.size()!=result)\\n        {\\n            for(int i=0;i<limit;i++)\\n            {\\n                rStart+=dir[d][0];\\n                cStart+=dir[d][1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols)\\n                {\\n                    ans.push_back({rStart,cStart});\\n                }\\n            }\\n                \\n                \\n                d=(d+1)%4;\\n            if(no==2)\\n            {\\n                limit++;no=1;\\n            }\\n            else no++;\\n                \\n                \\n                \\n        }\\n        return ans;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739543,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] matrix=new int[rows*cols][2];\\n        int i=0;\\n        matrix[i++]=new int[]{rStart,cStart};  //adding the initial position\\n        int d=0;          // this will be used for direction there can be 4 direction only 0 1 2 3 \\n\\t\\tint len=0;          //this is to take the number of steps;\\n        int[] directions=new int[]{0,1,0,-1,0};   //\\n        while(i<rows*cols){\\n            if(d==0||d==2){   // 0 for east 1 for south 2 for west and 3 for south \\n                len++;              //because only when we are facing east  or facing west then we are moving 1 step more\\n            }\\n            for(int k=0;k<len;k++){    //this for loop is to give the position after each step\\n                rStart+=directions[d];     //when facing east the x coordinate will not be changing only y coordinate will be changing that\\'s why cStart is incremented\\n                cStart+=directions[d+1];\\n                if(rStart<rows&&rStart>=0&&cStart<cols&&cStart>=0){\\n                    matrix[i++]=new int[]{rStart,cStart};         //this condition is to ensure we are only adding the coordinates of position which are in the matrix \\n                }\\n            }\\n            d=++d%4;       //this is to ensure d values never exceed 3 because we only want 4 direction and d value will be changing many times \\n            \\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] matrix=new int[rows*cols][2];\\n        int i=0;\\n        matrix[i++]=new int[]{rStart,cStart};  //adding the initial position\\n        int d=0;          // this will be used for direction there can be 4 direction only 0 1 2 3 \\n\\t\\tint len=0;          //this is to take the number of steps;\\n        int[] directions=new int[]{0,1,0,-1,0};   //\\n        while(i<rows*cols){\\n            if(d==0||d==2){   // 0 for east 1 for south 2 for west and 3 for south \\n                len++;              //because only when we are facing east  or facing west then we are moving 1 step more\\n            }\\n            for(int k=0;k<len;k++){    //this for loop is to give the position after each step\\n                rStart+=directions[d];     //when facing east the x coordinate will not be changing only y coordinate will be changing that\\'s why cStart is incremented\\n                cStart+=directions[d+1];\\n                if(rStart<rows&&rStart>=0&&cStart<cols&&cStart>=0){\\n                    matrix[i++]=new int[]{rStart,cStart};         //this condition is to ensure we are only adding the coordinates of position which are in the matrix \\n                }\\n            }\\n            d=++d%4;       //this is to ensure d values never exceed 3 because we only want 4 direction and d value will be changing many times \\n            \\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735206,
                "title": "java-solution-using-recursion-faster-than-99-43",
                "content": "class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] ans = new int[rows*cols][2];\\n        int topr = rStart-1;\\n        int bottomr =rStart+1;\\n        int leftc = cStart-1;\\n        int rightc =cStart+1;\\n        ans[0][0] = rStart;\\n        ans[0][1]= cStart;\\n        \\n        \\n        return path(rows, cols, rStart, cStart, topr, bottomr, leftc, rightc, ans, 1);\\n    }\\n    int[][] path(int rows, int cols, int rStart, int cStart, int topr, int bottomr, int leftc, int rightc, int[][] mat, int x){\\n        \\n        if(topr<0 && bottomr>rows-1 && leftc<0 && rightc>cols-1){\\n            return mat;\\n        }\\n        \\n        for(int i = topr+1 ; i <= bottomr; i++){\\n            if(i<rows && i>=0 && rightc>=0 && rightc<cols){\\n                mat[x][0]=i;\\n                mat[x][1]=rightc;\\n                x +=1;\\n            }\\n        }\\n        for(int i =rightc-1; i>= leftc ; i--){\\n            if(i>=0 && i<cols && bottomr>=0 && bottomr < rows){\\n                mat[x][0]=bottomr;\\n                mat[x][1]=i;\\n                x +=1;\\n            }\\n        }\\n        for(int i =bottomr-1; i>=topr; i--){\\n            if(i<rows && i>=0 && leftc >= 0 && leftc<cols){\\n                mat[x][0]=i;\\n                mat[x][1]=leftc;\\n                x +=1;\\n            }\\n        }\\n        for(int i = leftc+1 ; i<= rightc; i++){\\n            if(i<cols && i>=0 && topr>=0 && topr<rows){\\n                mat[x][0]=topr;\\n                mat[x][1]=i;\\n                x +=1;\\n            }\\n        }\\n        return path(rows, cols, rStart+1, cStart, topr-1, bottomr+1, leftc-1, rightc+1, mat, x);\\n            \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] ans = new int[rows*cols][2];\\n        int topr = rStart-1;\\n        int bottomr =rStart+1;\\n        int leftc = cStart-1;\\n        int rightc =cStart+1;\\n        ans[0][0] = rStart;\\n        ans[0][1]= cStart;\\n        \\n        \\n        return path(rows, cols, rStart, cStart, topr, bottomr, leftc, rightc, ans, 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1688165,
                "title": "javascript-commented-solution",
                "content": "\\n```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\n var spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n    let r = rStart, c = cStart, results = [];\\n    results.push([r,c]);\\n    // Draw a picture of an infinite grid, then highlight a smaller grid inside with ${rows} of rows and ${cols} of columns.\\n    // Draw a little man at the rStart row and the cStart column.\\n    // We will tell the man to walk a number of steps in a certain direction.\\n    // if the man is on a highlighted square, he will collect it.\\n    const walk = (steps,rStep,cStep) => {\\n        for (let i =0;i<steps;i++) {\\n            r +=rStep, c+=cStep;\\n            if ( r>=0 && c >=0 && r < rows && c<cols) results.push([r,c]);\\n        }\\n    }\\n    // we need to direct the little man how to walk\\n    // first he will walk a distance of one step.\\n    let distance = 1;  \\n    // think about how he will walk the spiral.\\n     \\n    // we will tell the man to walk right 1 unit.\\n    // after that he will walk down 1 unit.\\n    let rDirection = 0, cDirection = 1;\\n     \\n    // then he walks left 2 units, then he walks up 2 units \\n    // then he walks right 3 units, then walks down 3 units\\n     \\n    // do this pattern until he collects all the squares. \\n    while (results.length < rows*cols) {\\n        walk(distance,rDirection,cDirection);\\n        [rDirection,cDirection] = [cDirection,rDirection];\\n        walk(distance,rDirection,cDirection);\\n        [rDirection,cDirection] = [-1*cDirection,-1*rDirection];\\n        distance++;\\n    }\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\n var spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n    let r = rStart, c = cStart, results = [];\\n    results.push([r,c]);\\n    // Draw a picture of an infinite grid, then highlight a smaller grid inside with ${rows} of rows and ${cols} of columns.\\n    // Draw a little man at the rStart row and the cStart column.\\n    // We will tell the man to walk a number of steps in a certain direction.\\n    // if the man is on a highlighted square, he will collect it.\\n    const walk = (steps,rStep,cStep) => {\\n        for (let i =0;i<steps;i++) {\\n            r +=rStep, c+=cStep;\\n            if ( r>=0 && c >=0 && r < rows && c<cols) results.push([r,c]);\\n        }\\n    }\\n    // we need to direct the little man how to walk\\n    // first he will walk a distance of one step.\\n    let distance = 1;  \\n    // think about how he will walk the spiral.\\n     \\n    // we will tell the man to walk right 1 unit.\\n    // after that he will walk down 1 unit.\\n    let rDirection = 0, cDirection = 1;\\n     \\n    // then he walks left 2 units, then he walks up 2 units \\n    // then he walks right 3 units, then walks down 3 units\\n     \\n    // do this pattern until he collects all the squares. \\n    while (results.length < rows*cols) {\\n        walk(distance,rDirection,cDirection);\\n        [rDirection,cDirection] = [cDirection,rDirection];\\n        walk(distance,rDirection,cDirection);\\n        [rDirection,cDirection] = [-1*cDirection,-1*rDirection];\\n        distance++;\\n    }\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283466,
                "title": "efficient-c-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int i, int j) {\\n\\t\\n\\t   // vector where we will store our elements indices { i , j }\\n       vector<vector<int>> matrix(rows*cols,vector<int>(2)); \\n\\t\\tint x=2;            // value to be used and incremented step by step\\n        int k=rows*cols,n1=0;      // max value is rows*cols\\n        int steps=1,t;      //  number of steps to go in any direction, we will increase this time to time\\n        matrix[n1++]={i,j};       // initialized first indice\\n        while(x<=k){\\n            \\n\\t\\t\\t// now first we will traverse steps number of steps in right direction\\n\\t\\t\\t// at every step, we will check if its a valid matrix indice or not\\n\\t\\t\\tt=steps;\\n            while(t--){\\n                j++;\\n                if( j<cols && i<rows && j>=0 && i>=0) {\\n\\t\\t\\t\\t// for any valid indice, we will store that indice in matrix and increment x\\n                    matrix[n1++]={ i , j };\\n                    x++;\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// now we will traverse same number of steps vertically down \\n            t=steps;\\n            while(t--){\\n                i++;\\n                if( j<cols && i<rows && j>=0 && i>=0) {\\n                    matrix[n1++]={ i , j };\\n                    x++;\\n                }\\n            }\\n\\t\\t\\t// now we will traverse steps+1 number of steps in left direction\\n            steps++;\\n            t=steps;\\n            while(t--){\\n                j--;\\n                if( j<cols && i<rows && j>=0 && i>=0) {\\n                    matrix[n1++]={ i , j };\\n                    x++;\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// now we will traverse same number of steps vertically upward \\n            t=steps;\\n            while(t--){\\n                i--;\\n                if( j<cols && i<rows && j>=0 && i>=0) {\\n                    matrix[n1++]={ i , j };\\n                    x++;\\n                }\\n            }\\n\\t\\t\\t// now we again increase steps by 1 to maintain clockwise motion\\n            l++;\\n        }\\n        return matrix;  // our matrix is ready \\n    }\\n// NOTE:- To understand the code, have a look at the given sample examples and understand the motion.\\n// If understood the concept then please press the up arrow on the left of this solution.\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int i, int j) {\\n\\t\\n\\t   // vector where we will store our elements indices { i , j }",
                "codeTag": "Java"
            },
            {
                "id": 352599,
                "title": "c-clean-code-beat-96-with-explanation",
                "content": "**take a pen and paper, try to draw the path once by yourself, you will notice that**\\n```\\n\\t\\t\\t       i    wanted steps\\ngo right  by 1     0        1 = i/2+1\\ngo down   by 1     1        1 = i/2+1\\ngo left   by 2     2        2 = i/2+1\\ngo up     by 2     3        2 = i/2+1\\ngo right  by 3     4        3 = i/2+1\\ngo down   by 3     5        3 = i/2+1\\ngo left   by 4     6        4 = i/2+1\\ngo up     by 4     7        4 = i/2+1\\n...etc\\n```\\n**once we meet out of bound, don\\'t add it to the answer and just going forward.**\\n\\n```\\nclass Solution {\\npublic:\\n    int way[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        vector<vector<int>> res;\\n        res.push_back({r0,c0}); //put the source first\\n        int direction = 0, end_cnt = 1;\\n        for(int i = 0 ; end_cnt < R*C ; i++){\\n            int cnt = i/2+1;\\n            while(cnt--){\\n                r0 += way[direction][0];\\n                c0 += way[direction][1];\\n                if(r0 >= 0 && r0 < R && c0 < C && c0 >= 0) // only when current node is a valid position, add vector to the answer. There is no duplicate node, don\\'t worry.\\n                    res.push_back({r0,c0}),end_cnt++;\\n            }\\n            direction = (direction+1)%4; //each i loop, change direction\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t       i    wanted steps\\ngo right  by 1     0        1 = i/2+1\\ngo down   by 1     1        1 = i/2+1\\ngo left   by 2     2        2 = i/2+1\\ngo up     by 2     3        2 = i/2+1\\ngo right  by 3     4        3 = i/2+1\\ngo down   by 3     5        3 = i/2+1\\ngo left   by 4     6        4 = i/2+1\\ngo up     by 4     7        4 = i/2+1\\n...etc\\n```\n```\\nclass Solution {\\npublic:\\n    int way[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        vector<vector<int>> res;\\n        res.push_back({r0,c0}); //put the source first\\n        int direction = 0, end_cnt = 1;\\n        for(int i = 0 ; end_cnt < R*C ; i++){\\n            int cnt = i/2+1;\\n            while(cnt--){\\n                r0 += way[direction][0];\\n                c0 += way[direction][1];\\n                if(r0 >= 0 && r0 < R && c0 < C && c0 >= 0) // only when current node is a valid position, add vector to the answer. There is no duplicate node, don\\'t worry.\\n                    res.push_back({r0,c0}),end_cnt++;\\n            }\\n            direction = (direction+1)%4; //each i loop, change direction\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160624,
                "title": "python-version-with-counting-turn-times",
                "content": "```\\ndef  spiralMatrixIII(R, C, r0, c0):\\n        res = [[r0,c0]]\\n        count_turn = 0\\n        di = 0\\n        x, y = r0, c0\\n        dx = [0, 1, 0, -1]\\n        dy = [1, 0, -1, 0]\\n        while len(res) < R*C:\\n            steps = count_turn//2 + 1\\n            for step in range(steps):\\n                x += dx[di]\\n                y += dy[di]\\n                if 0<= x<= R-1 and 0 <= y <=C-1:\\n                    res.append([x, y])\\n            count_turn += 1\\n            di = (di+1)%4\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef  spiralMatrixIII(R, C, r0, c0):\\n        res = [[r0,c0]]\\n        count_turn = 0\\n        di = 0\\n        x, y = r0, c0\\n        dx = [0, 1, 0, -1]\\n        dy = [1, 0, -1, 0]\\n        while len(res) < R*C:\\n            steps = count_turn//2 + 1\\n            for step in range(steps):\\n                x += dx[di]\\n                y += dy[di]\\n                if 0<= x<= R-1 and 0 <= y <=C-1:\\n                    res.append([x, y])\\n            count_turn += 1\\n            di = (di+1)%4\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 158995,
                "title": "python-infinite-generator-yield",
                "content": "* use a generator to generate the infinite sequence of spiral coordinates\\n* every time a coordinate is within bounds, add it to the solution\\n* based on the spiral pattern:\\n  * no coordinate is visited twice\\n  * every coordinate is visited\\n  * the total number of spiral coordinates generated will not exceed approximately 4 times the size of the grid (since the first RxCx4 spiral coordinates should cover all four cuadrants around the starting point)\\n* stop when RxC coordinates have been collected\\n```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        def nxt(r,c):\\n            d=1\\n            yield (r,c)\\n            while True:\\n                for i in range(d):\\n                    c+=1\\n                    yield (r,c)\\n                for i in range(d):\\n                    r+=1\\n                    yield (r,c)\\n                for i in range(d+1):\\n                    c-=1\\n                    yield (r,c)\\n                for i in range(d+1):\\n                    r-=1\\n                    yield (r,c)\\n                d+=2\\n        \\n        ret=[]\\n        r,c=r0,c0\\n        for (r,c) in nxt(r0,c0):\\n            if 0<=r<R and 0<=c<C:\\n                ret.append([r,c])\\n            if len(ret)==R*C:\\n                break\\n            \\n        return ret\\n\\t\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        def nxt(r,c):\\n            d=1\\n            yield (r,c)\\n            while True:\\n                for i in range(d):\\n                    c+=1\\n                    yield (r,c)\\n                for i in range(d):\\n                    r+=1\\n                    yield (r,c)\\n                for i in range(d+1):\\n                    c-=1\\n                    yield (r,c)\\n                for i in range(d+1):\\n                    r-=1\\n                    yield (r,c)\\n                d+=2\\n        \\n        ret=[]\\n        r,c=r0,c0\\n        for (r,c) in nxt(r0,c0):\\n            if 0<=r<R and 0<=c<C:\\n                ret.append([r,c])\\n            if len(ret)==R*C:\\n                break\\n            \\n        return ret\\n\\t\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750377,
                "title": "solution-made-easy",
                "content": "# Approach\\nSame as Spiral Matrix 1\\nJust keep in mind that we do not have to stop once we are out of the boundary. The stopping condition is that when we have visited all the cells i.e. $$ans.size() == m*n$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int x, int y) {\\n        vector<vector<int>> ans;\\n\\n        int len = 1;\\n        ans.push_back({x,y});\\n\\n        while(ans.size() < m*n) {\\n            for(int j=1 ; j<=len ; j++) {\\n                if(isValid(x,y+j,m,n)) {\\n                    ans.push_back({x,y+j});\\n                }\\n            }\\n            y += len;\\n            \\n            for(int i=1 ; i<=len ; i++) {\\n                if(isValid(x+i,y,m,n)) {\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x += len;\\n\\n            len++;\\n            for(int j=1 ; j<=len ; j++) {\\n                if(isValid(x,y-j,m,n)) {\\n                    ans.push_back({x,y-j});\\n                }\\n            }\\n            y -= len;\\n\\n            for(int i=1 ; i<=len ; i++) {\\n                if(isValid(x-i,y,m,n)) {\\n                    ans.push_back({x-i,y});\\n                }\\n            }\\n            x -= len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n\\n    bool isValid(int i, int j, int m, int n) {\\n        return (i>=0 && j>=0 && i<m && j<n);\\n    }\\n};\\n```\\n\\nCheck all the Spiral Matrix Problems (1 to 4) here -\\nSpiral Matrix 1 - https://leetcode.com/problems/spiral-matrix/solutions/3747955/easy-traversal/\\nSpiral Matrix 2 - https://leetcode.com/problems/spiral-matrix-ii/solutions/3747970/same-as-spiral-matrix-i/\\nSpiral Matrix 3 - https://leetcode.com/problems/spiral-matrix-iii/solutions/3750377/solution-made-easy/\\nSpiral Matrix 4 - https://leetcode.com/problems/spiral-matrix-iv/solutions/2230030/simple-solution/\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int x, int y) {\\n        vector<vector<int>> ans;\\n\\n        int len = 1;\\n        ans.push_back({x,y});\\n\\n        while(ans.size() < m*n) {\\n            for(int j=1 ; j<=len ; j++) {\\n                if(isValid(x,y+j,m,n)) {\\n                    ans.push_back({x,y+j});\\n                }\\n            }\\n            y += len;\\n            \\n            for(int i=1 ; i<=len ; i++) {\\n                if(isValid(x+i,y,m,n)) {\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x += len;\\n\\n            len++;\\n            for(int j=1 ; j<=len ; j++) {\\n                if(isValid(x,y-j,m,n)) {\\n                    ans.push_back({x,y-j});\\n                }\\n            }\\n            y -= len;\\n\\n            for(int i=1 ; i<=len ; i++) {\\n                if(isValid(x-i,y,m,n)) {\\n                    ans.push_back({x-i,y});\\n                }\\n            }\\n            x -= len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n\\n    bool isValid(int i, int j, int m, int n) {\\n        return (i>=0 && j>=0 && i<m && j<n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507866,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        vector<vector<int>> result;\\n        int total = 0;\\n\\n        int rowStart = rStart;\\n        int rowEnd = rStart;\\n\\n        int colStart = cStart;\\n        int colEnd = cStart;\\n\\n        while(true){\\n            for(int i=colStart; i<=colEnd; i++){\\n                if(i >= 0 && i < cols && rowStart >= 0){\\n                    result.push_back({rowStart, i});\\n                    total++;\\n                }\\n            }\\n            colEnd++;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=rowStart; i<=rowEnd; i++){\\n                if(i >= 0 && i < rows && colEnd < cols){\\n                    result.push_back({i, colEnd});\\n                    total++;\\n                }\\n            }\\n            rowEnd++;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=colEnd; i>=colStart; i--){\\n                if(i >= 0 && i < cols && rowEnd < rows){\\n                    result.push_back({rowEnd, i});\\n                    total++;\\n                }\\n            }\\n            colStart--;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=rowEnd; i>=rowStart; i--){\\n                if(i >= 0 && i < rows && colStart >= 0){\\n                    result.push_back({i, colStart});\\n                    total++;\\n                }\\n            }\\n            rowStart--;\\n            if(total == (rows * cols))\\n                break;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        visits = []\\n        top, bottom, left, right = rStart, rStart + 1, cStart, cStart + 1\\n\\n        self.incr = 1\\n        direction = 0\\n\\n        def place(row, col):\\n            visits.append([row, col])\\n            self.incr += 1\\n        \\n        while self.incr != (1 + rows * cols):\\n            if direction == 0:\\n                if top >= 0:\\n                    row = top\\n                    for col in range(max(left, 0), min(right, cols)):\\n                        place(row, col)\\n                right += 1\\n            if direction == 1:\\n                if right <= cols:\\n                    col = right - 1\\n                    for row in range(max(top, 0), min(bottom, rows)):\\n                        place(row, col)\\n                bottom += 1\\n            if direction == 2:\\n                if bottom <= rows:\\n                    row = bottom - 1\\n                    for col in range(min(right - 1, cols - 1), max(left - 1, -1), -1):\\n                        place(row, col)\\n                left -= 1\\n            if direction == 3:\\n                if left >= 0:\\n                    col = left\\n                    for row in range(min(bottom - 1, rows - 1), max(top - 1, -1), -1):\\n                        place(row, col)\\n                top -= 1\\n            direction = (direction + 1) % 4\\n        return visits\\n```\\n\\n```Java []\\nclass Solution {\\n    int index = 1;\\n    int row;\\n    int col;\\n    int rows;\\n    int cols;\\n\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] result = new int[rows * cols][2];\\n        int moves = 0;\\n        row = rStart;\\n        col = cStart;\\n        this.rows = rows;\\n        this.cols = cols;\\n        result[0] = new int[] { rStart, cStart };\\n        while (index < result.length) {\\n            ++moves;\\n            addToResult(result, moves, 1, 0);\\n            addToResult(result, moves, 0, 1);\\n            ++moves;\\n            addToResult(result, moves, -1, 0);\\n            addToResult(result, moves, 0, -1);\\n        }\\n        return result;\\n    }\\n    public void addToResult(int[][] result, int moves, int horizontal, int vertical) {\\n        for (int i = 0; i < moves; ++i) {\\n            row += vertical;\\n            col += horizontal;\\n            if (row < rows && row > -1 && col < cols && col > -1) {\\n                result[index] = new int[] { row, col };\\n                ++index;\\n            }\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        vector<vector<int>> result;\\n        int total = 0;\\n\\n        int rowStart = rStart;\\n        int rowEnd = rStart;\\n\\n        int colStart = cStart;\\n        int colEnd = cStart;\\n\\n        while(true){\\n            for(int i=colStart; i<=colEnd; i++){\\n                if(i >= 0 && i < cols && rowStart >= 0){\\n                    result.push_back({rowStart, i});\\n                    total++;\\n                }\\n            }\\n            colEnd++;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=rowStart; i<=rowEnd; i++){\\n                if(i >= 0 && i < rows && colEnd < cols){\\n                    result.push_back({i, colEnd});\\n                    total++;\\n                }\\n            }\\n            rowEnd++;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=colEnd; i>=colStart; i--){\\n                if(i >= 0 && i < cols && rowEnd < rows){\\n                    result.push_back({rowEnd, i});\\n                    total++;\\n                }\\n            }\\n            colStart--;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=rowEnd; i>=rowStart; i--){\\n                if(i >= 0 && i < rows && colStart >= 0){\\n                    result.push_back({i, colStart});\\n                    total++;\\n                }\\n            }\\n            rowStart--;\\n            if(total == (rows * cols))\\n                break;\\n        }\\n        return result;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        visits = []\\n        top, bottom, left, right = rStart, rStart + 1, cStart, cStart + 1\\n\\n        self.incr = 1\\n        direction = 0\\n\\n        def place(row, col):\\n            visits.append([row, col])\\n            self.incr += 1\\n        \\n        while self.incr != (1 + rows * cols):\\n            if direction == 0:\\n                if top >= 0:\\n                    row = top\\n                    for col in range(max(left, 0), min(right, cols)):\\n                        place(row, col)\\n                right += 1\\n            if direction == 1:\\n                if right <= cols:\\n                    col = right - 1\\n                    for row in range(max(top, 0), min(bottom, rows)):\\n                        place(row, col)\\n                bottom += 1\\n            if direction == 2:\\n                if bottom <= rows:\\n                    row = bottom - 1\\n                    for col in range(min(right - 1, cols - 1), max(left - 1, -1), -1):\\n                        place(row, col)\\n                left -= 1\\n            if direction == 3:\\n                if left >= 0:\\n                    col = left\\n                    for row in range(min(bottom - 1, rows - 1), max(top - 1, -1), -1):\\n                        place(row, col)\\n                top -= 1\\n            direction = (direction + 1) % 4\\n        return visits\\n```\n```Java []\\nclass Solution {\\n    int index = 1;\\n    int row;\\n    int col;\\n    int rows;\\n    int cols;\\n\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] result = new int[rows * cols][2];\\n        int moves = 0;\\n        row = rStart;\\n        col = cStart;\\n        this.rows = rows;\\n        this.cols = cols;\\n        result[0] = new int[] { rStart, cStart };\\n        while (index < result.length) {\\n            ++moves;\\n            addToResult(result, moves, 1, 0);\\n            addToResult(result, moves, 0, 1);\\n            ++moves;\\n            addToResult(result, moves, -1, 0);\\n            addToResult(result, moves, 0, -1);\\n        }\\n        return result;\\n    }\\n    public void addToResult(int[][] result, int moves, int horizontal, int vertical) {\\n        for (int i = 0; i < moves; ++i) {\\n            row += vertical;\\n            col += horizontal;\\n            if (row < rows && row > -1 && col < cols && col > -1) {\\n                result[index] = new int[] { row, col };\\n                ++index;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3507245,
                "title": "c-easy-solution",
                "content": "```\\nvector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int top = rStart, down = rStart, left = cStart, right = cStart;\\n        ans.push_back({rStart, cStart});\\n        int count = 1;\\n        \\n        int dir = 0;\\n        //rows* cols => no of elements in the matrix\\n        while(count < rows*cols)\\n        {\\n            if(dir == 0)\\n            {\\n                for(int i=left+1; i<=right+1; i++)\\n                {\\n                    if(i>=0 && i<cols && top>=0 && top<rows)\\n                    {\\n                        ans.push_back({top, i});\\n                        count++;\\n                    }\\n                }\\n                right++;\\n            }\\n            else if(dir == 1)\\n            {\\n                for(int i=top+1; i<=down+1; i++)\\n                {\\n                    if(i>=0 && i<rows && right>=0 && right<cols)\\n                    {\\n                        ans.push_back({i, right});\\n                        count++;\\n                    }\\n                }\\n                down++;\\n            }\\n            else if(dir == 2)\\n            {\\n                for(int i=right-1; i>=left-1; i--)\\n                {\\n                    if(i>=0 && i<cols && down>=0 && down<rows)\\n                    {\\n                        ans.push_back({down, i});\\n                        count++;\\n                    }\\n                }\\n                left--;\\n            }\\n            else if(dir == 3)\\n            {\\n                for(int i=down-1; i>=top-1; i--)\\n                {\\n                    if(i>=0 && i<rows && left>=0 && left<cols)\\n                    {\\n                        ans.push_back({i, left});\\n                        count++;\\n                    }\\n                }\\n                top--;\\n            }\\n            dir = (dir+1)%4;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int top = rStart, down = rStart, left = cStart, right = cStart;\\n        ans.push_back({rStart, cStart});\\n        int count = 1;\\n        \\n        int dir = 0;\\n        //rows* cols => no of elements in the matrix\\n        while(count < rows*cols)\\n        {\\n            if(dir == 0)\\n            {\\n                for(int i=left+1; i<=right+1; i++)\\n                {\\n                    if(i>=0 && i<cols && top>=0 && top<rows)\\n                    {\\n                        ans.push_back({top, i});\\n                        count++;\\n                    }\\n                }\\n                right++;\\n            }\\n            else if(dir == 1)\\n            {\\n                for(int i=top+1; i<=down+1; i++)\\n                {\\n                    if(i>=0 && i<rows && right>=0 && right<cols)\\n                    {\\n                        ans.push_back({i, right});\\n                        count++;\\n                    }\\n                }\\n                down++;\\n            }\\n            else if(dir == 2)\\n            {\\n                for(int i=right-1; i>=left-1; i--)\\n                {\\n                    if(i>=0 && i<cols && down>=0 && down<rows)\\n                    {\\n                        ans.push_back({down, i});\\n                        count++;\\n                    }\\n                }\\n                left--;\\n            }\\n            else if(dir == 3)\\n            {\\n                for(int i=down-1; i>=top-1; i--)\\n                {\\n                    if(i>=0 && i<rows && left>=0 && left<cols)\\n                    {\\n                        ans.push_back({i, left});\\n                        count++;\\n                    }\\n                }\\n                top--;\\n            }\\n            dir = (dir+1)%4;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3504467,
                "title": "simple-simulation-solution-python",
                "content": "# Intuition and Approach\\n* start the simulation from starting cell and insert position of cells in to ans which lie within the matrix\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n\\n- Space complexity: O(N^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, m: int, n: int, i: int, j: int) -> List[List[int]]:\\n        ans=[]\\n        lb,rb,tb,bb=j,j,i,i\\n        while(len(ans)<m*n):\\n            while(j<rb+1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                j+=1\\n            rb+=1\\n            while(i<bb+1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                i+=1\\n            bb+=1\\n            while(j>lb-1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                j-=1\\n            lb-=1\\n            while(i>tb-1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                i-=1\\n            tb-=1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Array",
                    "Matrix",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, m: int, n: int, i: int, j: int) -> List[List[int]]:\\n        ans=[]\\n        lb,rb,tb,bb=j,j,i,i\\n        while(len(ans)<m*n):\\n            while(j<rb+1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                j+=1\\n            rb+=1\\n            while(i<bb+1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                i+=1\\n            bb+=1\\n            while(j>lb-1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                j-=1\\n            lb-=1\\n            while(i>tb-1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                i-=1\\n            tb-=1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812047,
                "title": "spiral-matrix-iii-adapted-dfs-solution",
                "content": "# Approach\\nWe keep track of 5 main variables:\\n1. x: colum number\\n2. y: row number\\n3. d: current direction\\n3. visited: Set of Pairs of visited col & row\\n4. result: List of ordered visited pairs\\n\\nEach time we check the direction and possible x & y values :\\n- if next position already visited: keep moving in the same current position.\\n- if next position is not visited: update x & y\\n\\n**Grid\\'s boundary**:\\nMoving outside of the grid\\'s boundary will not cause a problem if we ignore the positions in the final result. It is not needed to include the outer positions in the visited set. \\n\\n# Complexity\\n- Time complexity: **O(n*m)**\\n\\n- Space complexity: **O(n*m)**\\n\\nNote: *n=rows, m=columns*\\n\\n# Code\\n```\\nenum class Direction {\\n    RIGHT, DOWN, LEFT, UP\\n}\\n\\nclass Solution {\\n\\n    fun spiralMatrixIII(rows: Int, cols: Int, rStart: Int, cStart: Int): Array<IntArray> {\\n        val visited: MutableSet<Pair<Int, Int>> = mutableSetOf()\\n        val result: MutableList<IntArray> = mutableListOf()\\n        var y = rStart\\n        var x = cStart\\n        var d: Direction = Direction.UP\\n        fun dfs() {\\n            if (x in 0 until cols && y in 0 until rows) {\\n                visited.add(Pair(y, x))\\n                result.add(intArrayOf(y, x))\\n            }\\n            when (d) {\\n                Direction.RIGHT -> {\\n                    if (!visited.contains(Pair(y+1, x))) {y+=1; d=Direction.DOWN}\\n                    else {x+=1; d=Direction.RIGHT}\\n                }\\n                Direction.DOWN -> {\\n                    if (!visited.contains(Pair(y, x-1))) {x-=1; d=Direction.LEFT}\\n                    else {y+=1; d=Direction.DOWN}\\n                }\\n                Direction.LEFT -> {\\n                    if (!visited.contains(Pair(y-1, x))) {y-=1; d=Direction.UP}\\n                    else {x-=1; d=Direction.LEFT}\\n                }\\n                Direction.UP -> {\\n                    if (!visited.contains(Pair(y, x+1))) {x+=1; d=Direction.RIGHT}\\n                    else {y-=1; d=Direction.UP}\\n                }\\n            }\\n            if (visited.size == rows * cols){\\n                return\\n            } else { dfs() }\\n        }\\n        dfs()\\n        return result.toTypedArray()\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nenum class Direction {\\n    RIGHT, DOWN, LEFT, UP\\n}\\n\\nclass Solution {\\n\\n    fun spiralMatrixIII(rows: Int, cols: Int, rStart: Int, cStart: Int): Array<IntArray> {\\n        val visited: MutableSet<Pair<Int, Int>> = mutableSetOf()\\n        val result: MutableList<IntArray> = mutableListOf()\\n        var y = rStart\\n        var x = cStart\\n        var d: Direction = Direction.UP\\n        fun dfs() {\\n            if (x in 0 until cols && y in 0 until rows) {\\n                visited.add(Pair(y, x))\\n                result.add(intArrayOf(y, x))\\n            }\\n            when (d) {\\n                Direction.RIGHT -> {\\n                    if (!visited.contains(Pair(y+1, x))) {y+=1; d=Direction.DOWN}\\n                    else {x+=1; d=Direction.RIGHT}\\n                }\\n                Direction.DOWN -> {\\n                    if (!visited.contains(Pair(y, x-1))) {x-=1; d=Direction.LEFT}\\n                    else {y+=1; d=Direction.DOWN}\\n                }\\n                Direction.LEFT -> {\\n                    if (!visited.contains(Pair(y-1, x))) {y-=1; d=Direction.UP}\\n                    else {x-=1; d=Direction.LEFT}\\n                }\\n                Direction.UP -> {\\n                    if (!visited.contains(Pair(y, x+1))) {x+=1; d=Direction.RIGHT}\\n                    else {y-=1; d=Direction.UP}\\n                }\\n            }\\n            if (visited.size == rows * cols){\\n                return\\n            } else { dfs() }\\n        }\\n        dfs()\\n        return result.toTypedArray()\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288908,
                "title": "c-easy-code-with-comments",
                "content": "![image](https://assets.leetcode.com/users/images/f1fe41ab-78f6-476e-9878-58beac74b5a6_1657953630.037121.jpeg)\\n\\n\\n\\n//  Key idea behind this approach is to spirally(clockwise) traverse matrix and expand traversal area( decrementing top and left, incrementing right and down) and keep checking boundary condition\\n\\n// T.C = O(rows*cols) , S.C = O(rows*cols)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        \\n        vector<vector<int>> ans ;\\n        \\n        // keep track which cell is visited to avoid duplicate insertion in ans \\n        vector<vector<bool>> isvisited( rows, vector<bool>( cols, false ) ) ;\\n        \\n        int top = rStart , down = (rStart < (rows-1)) ? rStart+1 : rStart , left = cStart, right = (cStart < (cols-1)) ? cStart+1 : cStart ;\\n        \\n        int direction = 0 ;   // 0 == forward, 1 == downward , 2 == backward, 3 == upward\\n        \\n        \\n        ans.push_back({rStart, cStart}) ;\\n        \\n        isvisited[rStart][cStart] = true ;\\n        \\n        while( (int)ans.size() < (rows*cols) ){\\n            \\n           \\n            // forward move\\n            \\n            if( direction == 0 ){\\n                \\n                for( int i = left+1 ; i <= right ; ++i ){\\n                    \\n                    if(!isvisited[top][i]){\\n                        \\n                        ans.push_back({ top , i }) ;\\n                        \\n                        isvisited[top][i] = true ;\\n                    }\\n                }\\n            }\\n            \\n            // downward move\\n            \\n            else if( direction == 1 ){\\n                \\n                for( int i = top+1 ; i <= down ; ++i ){\\n                    \\n                    if( !isvisited[i][right] ){\\n                        \\n                        ans.push_back({ i , right }) ;\\n                        \\n                        isvisited[i][right] = true ;\\n                    }\\n                }\\n                // if we can expand area, expand it(boundary condtion)\\n               if( top > 0 ){\\n                \\ttop -= 1 ;\\n                }\\n                if( left > 0 ){\\n                \\tleft -= 1 ;\\n                }\\n            }\\n            \\n            // backward move\\n            \\n            else if( direction == 2 ){\\n                \\n                for( int i = right-1 ; i >= left ; --i ){\\n                    \\n                    if( !isvisited[down][i] ){\\n                        \\n                        ans.push_back({ down , i }) ;\\n                        \\n                        isvisited[down][i] = true ;\\n                    }\\n                }\\n                // if we can expand area, expand it(boundary condtion)\\n                if( right < (cols-1)){\\n                \\tright += 1 ;\\n                }\\n            }\\n            \\n            // upward move\\n            \\n            else if( direction == 3 ){\\n                \\n                for( int i = down-1 ; i >= top ; --i ){\\n                    \\n                    if( !isvisited[i][left] ){\\n                        \\n                        ans.push_back({ i, left }) ;\\n                        \\n                        isvisited[i][left] = true ;\\n                    }\\n                }\\n                // if we can expand area, expand it(boundary condtion)\\n                if( down < (rows-1)){\\n                \\tdown += 1;\\n                }\\n            }\\n            \\n            \\n            direction =  (direction+1)%4 ;\\n           \\n        } \\n        \\n        return ans ;\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        \\n        vector<vector<int>> ans ;\\n        \\n        // keep track which cell is visited to avoid duplicate insertion in ans \\n        vector<vector<bool>> isvisited( rows, vector<bool>( cols, false ) ) ;\\n        \\n        int top = rStart , down = (rStart < (rows-1)) ? rStart+1 : rStart , left = cStart, right = (cStart < (cols-1)) ? cStart+1 : cStart ;\\n        \\n        int direction = 0 ;   // 0 == forward, 1 == downward , 2 == backward, 3 == upward\\n        \\n        \\n        ans.push_back({rStart, cStart}",
                "codeTag": "Java"
            },
            {
                "id": 2238692,
                "title": "c-simple-simulate-the-process-with-ease",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int r,int c,int n,int m)\\n    {\\n        return r>=0&&r<n&&c>=0&&c<m;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int c=0;\\n        int grids=rows*cols;\\n        int go=1;\\n        bool up,left,right,down;\\n        left=up=down=false;\\n        int z=0;\\n        right=true;\\n        while(true)\\n        {\\n            if(isvalid(rStart,cStart,rows,cols))\\n            {\\n                c++;\\n                // cout<<c<<endl;\\n                // cout<<rStart<<\" \"<<cStart<<endl;\\n                ans.push_back({rStart,cStart});\\n            }\\n            if(c==grids)\\n            {\\n                break;\\n            }\\n            if(right&&z!=go)\\n            {\\n                cStart++;\\n                z++;\\n                if(z==go)\\n                {\\n                    right=false;\\n                    down=true;\\n                    z=0;\\n                }\\n            }\\n            else if(down&&z!=go)\\n            {\\n                rStart++;\\n                z++;\\n                if(z==go)\\n                {\\n                    down=false;\\n                    left=true;\\n                    go++;\\n                    z=0;\\n                }\\n            }\\n            else if(left)\\n            {\\n                cStart--;\\n                z++;\\n                if(z==go)\\n                {\\n                    left=false;\\n                    up=true;\\n                    z=0;\\n                }\\n            }\\n            else if(up)\\n            {\\n                rStart--;\\n                z++;\\n                if(z==go)\\n                {\\n                    up=false;\\n                    right=true;\\n                    go++;\\n                    z=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int r,int c,int n,int m)\\n    {\\n        return r>=0&&r<n&&c>=0&&c<m;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int c=0;\\n        int grids=rows*cols;\\n        int go=1;\\n        bool up,left,right,down;\\n        left=up=down=false;\\n        int z=0;\\n        right=true;\\n        while(true)\\n        {\\n            if(isvalid(rStart,cStart,rows,cols))\\n            {\\n                c++;\\n                // cout<<c<<endl;\\n                // cout<<rStart<<\" \"<<cStart<<endl;\\n                ans.push_back({rStart,cStart});\\n            }\\n            if(c==grids)\\n            {\\n                break;\\n            }\\n            if(right&&z!=go)\\n            {\\n                cStart++;\\n                z++;\\n                if(z==go)\\n                {\\n                    right=false;\\n                    down=true;\\n                    z=0;\\n                }\\n            }\\n            else if(down&&z!=go)\\n            {\\n                rStart++;\\n                z++;\\n                if(z==go)\\n                {\\n                    down=false;\\n                    left=true;\\n                    go++;\\n                    z=0;\\n                }\\n            }\\n            else if(left)\\n            {\\n                cStart--;\\n                z++;\\n                if(z==go)\\n                {\\n                    left=false;\\n                    up=true;\\n                    z=0;\\n                }\\n            }\\n            else if(up)\\n            {\\n                rStart--;\\n                z++;\\n                if(z==go)\\n                {\\n                    up=false;\\n                    right=true;\\n                    go++;\\n                    z=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2091734,
                "title": "java-easy-to-understand-solution",
                "content": "```\\npublic static final int[][] dir = new int[][]{{0,1}, {1,0}, {0,-1}, {-1, 0}};\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] coords = new int[rows*cols][2];\\n        int ind = 0;\\n        int count = 0;\\n        int d = 0;\\n        int x = rStart, y = cStart;\\n        coords[ind++] = new int[]{rStart, cStart};\\n        while(ind < rows*cols) {\\n            if(d % 2 == 0)\\n                count++;\\n            for(int i = 0; i < count; i++) {\\n                x += dir[d][0];\\n                y += dir[d][1];\\n                if(isCoordValid(x, y, rows, cols))\\n                    coords[ind++] = new int[]{x, y};\\n            }\\n            d = (d+1)%4;\\n        }\\n        return coords;\\n    }\\n    \\n    private boolean isCoordValid(int x, int y, int rows, int cols) {\\n        return x >= 0 && y >= 0 && x < rows && y < cols;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static final int[][] dir = new int[][]{{0,1}, {1,0}, {0,-1}, {-1, 0}};\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] coords = new int[rows*cols][2];\\n        int ind = 0;\\n        int count = 0;\\n        int d = 0;\\n        int x = rStart, y = cStart;\\n        coords[ind++] = new int[]{rStart, cStart};\\n        while(ind < rows*cols) {\\n            if(d % 2 == 0)\\n                count++;\\n            for(int i = 0; i < count; i++) {\\n                x += dir[d][0];\\n                y += dir[d][1];\\n                if(isCoordValid(x, y, rows, cols))\\n                    coords[ind++] = new int[]{x, y};\\n            }\\n            d = (d+1)%4;\\n        }\\n        return coords;\\n    }\\n    \\n    private boolean isCoordValid(int x, int y, int rows, int cols) {\\n        return x >= 0 && y >= 0 && x < rows && y < cols;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038092,
                "title": "python-go-easy-to-understand-because-i-m-a-dummy-and-so-are-you",
                "content": "This is a dummy\\'s way to solve the problem so it might be a bit lengthy, but I figure this should be easy to understand.\\n\\nFirst look at the picture with the arrows in the question (Look at the second example, it\\'s easier to visualize).\\n\\nHere\\'s the steps we follow:\\n- First move 1 step to the right\\n- Then move 1 step down\\n- Then move 2 steps to the left\\n- Then move 2 steps up\\n- Then move 3 steps to the right\\n- This goes on...\\n\\nHow can we exploit this pattern? By making a step variable.\\n- If the step is odd, we move right then down\\n- If the step is even, we move left then up\\n\\nFor each movement, we check if the position is within the matrix boundary. If it is, we add it to the solution, if not we ignore.\\n\\nJust look at the code. It\\'s really simple.\\n\\nHere\\'s the code:\\n\\n**Python:**\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, row: int, col: int) -> List[List[int]]:\\n        step = 1\\n        res = [[row, col]] # we always start with the given position\\n        while len(res) < rows * cols: # stop when we have enough elements\\n            if step % 2 == 1: # odd step\\n                stop = col + step\\n                while col < stop: # move left\\n                    col += 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n                stop = row + step\\n                while row < stop: # move down\\n                    row += 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n            else: # even step\\n                stop = col - step\\n                while col > stop: # move right\\n                    col -= 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n                stop = row - step\\n                while row > stop: # move up\\n                    row -= 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n            step += 1\\n            \\n        return res\\n    \\n    def is_valid(self, row, col, rows, cols):\\n        return row >= 0 and row < rows and col >= 0 and col < cols\\n```\\n\\n**Go:**\\n```\\nfunc spiralMatrixIII(rows int, cols int, row int, col int) [][]int {\\n    step := 1\\n    res := [][]int{[]int{row, col}}\\n    \\n    for len(res) < rows * cols {\\n        if step % 2 == 1 { // odd step\\n            stop := col + step\\n            for col < stop { // move left\\n                col++\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n            \\n            stop = row + step\\n            for row < stop { // move down\\n                row++\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n        } else { // even step\\n            stop := col - step\\n            for col > stop { // move right\\n                col--\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n            \\n            stop = row - step\\n            for row > stop { // move up\\n                row--\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n        }\\n        \\n        step++\\n    }\\n    \\n    return res\\n}\\n\\nfunc is_valid(row, col, rows, cols int) bool {\\n    return row >= 0 && row < rows && col >= 0 && col < cols\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Go",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, row: int, col: int) -> List[List[int]]:\\n        step = 1\\n        res = [[row, col]] # we always start with the given position\\n        while len(res) < rows * cols: # stop when we have enough elements\\n            if step % 2 == 1: # odd step\\n                stop = col + step\\n                while col < stop: # move left\\n                    col += 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n                stop = row + step\\n                while row < stop: # move down\\n                    row += 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n            else: # even step\\n                stop = col - step\\n                while col > stop: # move right\\n                    col -= 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n                stop = row - step\\n                while row > stop: # move up\\n                    row -= 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n            step += 1\\n            \\n        return res\\n    \\n    def is_valid(self, row, col, rows, cols):\\n        return row >= 0 and row < rows and col >= 0 and col < cols\\n```\n```\\nfunc spiralMatrixIII(rows int, cols int, row int, col int) [][]int {\\n    step := 1\\n    res := [][]int{[]int{row, col}}\\n    \\n    for len(res) < rows * cols {\\n        if step % 2 == 1 { // odd step\\n            stop := col + step\\n            for col < stop { // move left\\n                col++\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n            \\n            stop = row + step\\n            for row < stop { // move down\\n                row++\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n        } else { // even step\\n            stop := col - step\\n            for col > stop { // move right\\n                col--\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n            \\n            stop = row - step\\n            for row > stop { // move up\\n                row--\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n        }\\n        \\n        step++\\n    }\\n    \\n    return res\\n}\\n\\nfunc is_valid(row, col, rows, cols int) bool {\\n    return row >= 0 && row < rows && col >= 0 && col < cols\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956245,
                "title": "java-solution",
                "content": "Solution - \\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] ans = new int[rows*cols][2];\\n        int i=0;\\n        ans[i++] = new int[]{rStart, cStart};\\n        \\n        int len=0;\\n        int d=0;\\n        int[] direction = new int[]{0, 1, 0, -1, 0};\\n        \\n        while(i < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int k=0; k<len; k++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart<rows && rStart>=0 && cStart<cols && cStart >= 0){\\n                    ans[i++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] ans = new int[rows*cols][2];\\n        int i=0;\\n        ans[i++] = new int[]{rStart, cStart};\\n        \\n        int len=0;\\n        int d=0;\\n        int[] direction = new int[]{0, 1, 0, -1, 0};\\n        \\n        while(i < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int k=0; k<len; k++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart<rows && rStart>=0 && cStart<cols && cStart >= 0){\\n                    ans[i++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942233,
                "title": "c-with-issafe-function",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int isSafe(int rows, int cols, int i, int j)\\n    {\\n\\n        if (i < 0 || j < 0 || j >= cols || i >= rows)\\n        {\\n            return false;\\n        }\\n        return true;\\n    } \\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart)\\n    {\\n        int num = 2;\\n        vector<vector<int>> ans;\\n        int move = 0;\\n        ans.push_back(vector<int>{rStart, cStart});\\n        while (num <= rows * cols)\\n        {\\n\\n            move++;\\n            // right\\n            int p = move;\\n            while (p--)\\n            {\\n                cStart++;\\n                if (isSafe(rows , cols, rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            // down\\n            p = move;\\n            while (p--)\\n            {\\n                rStart++;\\n                if (isSafe(rows , cols , rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            move++;\\n            // r -> l\\n            p = move;\\n            while (p--)\\n            {\\n                cStart--;\\n                if (isSafe(rows , cols , rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            // d -> u\\n            p = move;\\n            while (p--)\\n            {\\n                rStart--;\\n                if (isSafe(rows , cols, rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int isSafe(int rows, int cols, int i, int j)\\n    {\\n\\n        if (i < 0 || j < 0 || j >= cols || i >= rows)\\n        {\\n            return false;\\n        }\\n        return true;\\n    } \\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart)\\n    {\\n        int num = 2;\\n        vector<vector<int>> ans;\\n        int move = 0;\\n        ans.push_back(vector<int>{rStart, cStart});\\n        while (num <= rows * cols)\\n        {\\n\\n            move++;\\n            // right\\n            int p = move;\\n            while (p--)\\n            {\\n                cStart++;\\n                if (isSafe(rows , cols, rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            // down\\n            p = move;\\n            while (p--)\\n            {\\n                rStart++;\\n                if (isSafe(rows , cols , rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            move++;\\n            // r -> l\\n            p = move;\\n            while (p--)\\n            {\\n                cStart--;\\n                if (isSafe(rows , cols , rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            // d -> u\\n            p = move;\\n            while (p--)\\n            {\\n                rStart--;\\n                if (isSafe(rows , cols, rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942077,
                "title": "python",
                "content": "\\n    def spiralMatrixIII(self, rows, cols, rStart, cStart):\\n        i, j = rStart, cStart\\n        coordinates = [[rStart,cStart]]\\n        \\n        step, sign = 1, 1\\n        \\n        while len(coordinates) < rows*cols:\\n            for _ in range(step):\\n                j += sign\\n                if 0 <= i < rows and 0 <= j < cols:\\n                    coordinates.append([i,j])\\n                    \\n            for _ in range(step):\\n                i += sign\\n                if 0 <= i < rows and 0 <= j < cols:\\n                    coordinates.append([i,j])\\n                    \\n            step += 1\\n            sign *= -1\\n    \\n        return coordinates",
                "solutionTags": [],
                "code": "\\n    def spiralMatrixIII(self, rows, cols, rStart, cStart):\\n        i, j = rStart, cStart\\n        coordinates = [[rStart,cStart]]\\n        \\n        step, sign = 1, 1\\n        \\n        while len(coordinates) < rows*cols:\\n            for _ in range(step):\\n                j += sign\\n                if 0 <= i < rows and 0 <= j < cols:\\n                    coordinates.append([i,j])\\n                    \\n            for _ in range(step):\\n                i += sign\\n                if 0 <= i < rows and 0 <= j < cols:\\n                    coordinates.append([i,j])\\n                    \\n            step += 1\\n            sign *= -1\\n    \\n        return coordinates",
                "codeTag": "Python3"
            },
            {
                "id": 1760359,
                "title": "java-simple-code-faster-than-99-47",
                "content": "\\n\\n```\\nclass Solution {\\n      int size = 0;\\n      int[][] mat;\\n    \\n     public void add(int r, int c, int rows, int cols) {\\n            \\n            //Check out of bound condition , if it is out of bound , don\\'t do anything\\n            //just return it\\n            \\n            if(r>=rows || r<0 || c>=cols || c<0) {\\n                return;\\n            }\\n            \\n             mat[size][0] = r;\\n             mat[size++][1] = c;        //size is increaed for next trip or iteration\\n     }\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\t\\n /*     \\nThere are rows X cols elements in Matrix , and each of that element we have to\\ntraverse in clockwise spiral i.e Jalebi , and we need to print co-ordinates of each\\nelement , so we need rows = rows X cols and in each 1D Array , there are two indices\\nonly i.e (row , col) , so we need cols = 2\\n*/    \\n \\n        mat = new int[rows * cols][2];\\n        \\n        int len = 1;\\n        int r = rStart, c = cStart;\\n        \\n        while(size < rows * cols) {\\n            \\n            //Move Right or East , so cols will increase\\n            for(int i=0; i<len; i++) {\\n                add(r, c++,  rows , cols);\\n            }\\n            \\n            //Move Down or South , so rows will increase\\n            for(int i=0; i<len; i++) {\\n                add(r++, c, rows, cols);\\n            }\\n                    len++;  \\n            \\n            //Move Left or West , so cols will decrease\\n            for(int i=0; i<len; i++) {\\n                add(r, c--, rows, cols);\\n            }\\n                    \\n            //Move Up or North , so rows will decrease\\n            for(int i=0; i<len; i++) {\\n                add(r--, c, rows, cols);\\n            }\\n                    len++;\\n        }\\n                    return mat;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n      int size = 0;\\n      int[][] mat;\\n    \\n     public void add(int r, int c, int rows, int cols) {\\n            \\n            //Check out of bound condition , if it is out of bound , don\\'t do anything\\n            //just return it\\n            \\n            if(r>=rows || r<0 || c>=cols || c<0) {\\n                return;\\n            }\\n            \\n             mat[size][0] = r;\\n             mat[size++][1] = c;        //size is increaed for next trip or iteration\\n     }\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\t\\n /*     \\nThere are rows X cols elements in Matrix , and each of that element we have to\\ntraverse in clockwise spiral i.e Jalebi , and we need to print co-ordinates of each\\nelement , so we need rows = rows X cols and in each 1D Array , there are two indices\\nonly i.e (row , col) , so we need cols = 2\\n*/    \\n \\n        mat = new int[rows * cols][2];\\n        \\n        int len = 1;\\n        int r = rStart, c = cStart;\\n        \\n        while(size < rows * cols) {\\n            \\n            //Move Right or East , so cols will increase\\n            for(int i=0; i<len; i++) {\\n                add(r, c++,  rows , cols);\\n            }\\n            \\n            //Move Down or South , so rows will increase\\n            for(int i=0; i<len; i++) {\\n                add(r++, c, rows, cols);\\n            }\\n                    len++;  \\n            \\n            //Move Left or West , so cols will decrease\\n            for(int i=0; i<len; i++) {\\n                add(r, c--, rows, cols);\\n            }\\n                    \\n            //Move Up or North , so rows will decrease\\n            for(int i=0; i<len; i++) {\\n                add(r--, c, rows, cols);\\n            }\\n                    len++;\\n        }\\n                    return mat;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731664,
                "title": "java-easy-solution-with-explaintation",
                "content": "\\n      class Solution{\\n      public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        //first we need an 2D array to store all the indices\\n        //of rows = r*c and columns = 2 .\\n        int[][] res = new int[rows*cols][2];\\n        \\n        //edge case\\n        int size = rows*cols ; \\n     \\n\\t   //since initial positions index is given \\n        res[0] = new int[]{ rStart , cStart};\\n        if(size == 1) { return res ; }\\n        \\n        //we need an another array which change row and col values\\n        //so that we can move in spiral order.\\n        int[][] dir = { {0,1} , {1,0} , {0,-1} , {-1,0} };\\n        //now why I took these specific values in my dir array\\n        //bcoz if you notice the given examples , You will see a\\n        //pattern.\\n        //First we go east column increases & row remains constant so {0,1}\\n        //Second we go south row increases & column remains constant so {1,0}\\n        //Third we go west column decreases & row remains constant so {0,-1}\\n        //Fourth we go north row decreases & column remains constant so{-1,0}\\n        \\n        //now since we are moving in 4 directions so after a complete\\n        //revolution we need do reset direction to east \\n        //or we can say reset dir arr to its begining.\\n        int d = 0 ; // this variable gonna help us in his task.\\n        int len = 0; // this will decide how much length to go in a direction\\n        \\n       \\n        int count = 1 ; // this will be our counter var to break the loop\\n        // we put 1 element in res thats why count = 1.\\n        \\n        //now a loop to get all other indices in spiral manner\\n        \\n        while(count<rows*cols)\\n        {\\n            if(d==0||d==2) { len++ ; } //1,1,2,2,3,3,4,4\\n            //Above condition will helps in achieving the repeating sequence\\n            \\n            for(int i=0;i<len;i++)\\n            {\\n                rStart = rStart + dir[d][0]; //increase or decrease row\\n                cStart = cStart + dir[d][1]; //increase or decrease column\\n                \\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols)\\n                {\\n                    //Above condition will check if the row & col values\\n                    //are in the given matrix or not. If true then we will\\n                    //add them in our result array.\\n                    res[count++] = new int[]{ rStart , cStart };\\n                }\\n            }\\n            //we have to change values of d in order to change the diection\\n            \\n            d = ( d+1 ) % 4 ; // this will reset the value to 0 after a revolution.                                                           \\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution{\\n      public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        //first we need an 2D array to store all the indices\\n        //of rows = r*c and columns = 2 .\\n        int[][] res = new int[rows*cols][2];\\n        \\n        //edge case\\n        int size = rows*cols ; \\n     \\n\\t   //since initial positions index is given \\n        res[0] = new int[]{ rStart , cStart}",
                "codeTag": "Java"
            },
            {
                "id": 1696940,
                "title": "java-solution-easy",
                "content": "```class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        int[][] ans = new int[rows*cols][2];\\n        \\n        int t = rStart;\\n        int d = t+1;\\n        int l = cStart;\\n        int r = l+1;\\n        int i = 0;\\n        int j = 0;\\n        \\n        ans[i][j++] = rStart;\\n        ans[i++][j] = cStart;\\n        j = 0;\\n        \\n        while((i<(rows*cols)) && j<2){\\n            \\n            for(int a = l+1; a<=r && i<(rows*cols); a++){\\n                if(a<cols && t>=0 && a>=0){\\n                    ans[i][j++] = t;\\n                    ans[i++][j] = a;\\n                    j=0;\\n                }\\n            }\\n            l--;\\n            \\n            for(int a = t+1; a<=d && i<(rows*cols); a++){\\n                if(a<rows && r<cols && a>=0){\\n                    ans[i][j++] = a;\\n                    ans[i++][j] = r;\\n                    j=0;\\n                }\\n            }\\n            t--;\\n            \\n            for(int a = r-1; a>=l && i<(rows*cols); a--){\\n                if(a<cols && d<rows && a>=0){\\n                    ans[i][j++] = d;\\n                    ans[i++][j] = a;\\n                    j=0;\\n                }\\n            }\\n            r++;\\n            \\n            for(int a = d-1; a>=t && i<(rows*cols); a--){\\n                if(a<rows && l>=0 && a>=0){\\n                    ans[i][j++] = a;\\n                    ans[i++][j] = l;\\n                    j=0;\\n                }\\n            }\\n            d++;\\n        }\\n        return ans;\\n    }\\n}```\\n\\nThere are four for loops for 4 movements  and the if condition take care that ans contains correct numbers for rows and collumn",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        int[][] ans = new int[rows*cols][2];\\n        \\n        int t = rStart;\\n        int d = t+1;\\n        int l = cStart;\\n        int r = l+1;\\n        int i = 0;\\n        int j = 0;\\n        \\n        ans[i][j++] = rStart;\\n        ans[i++][j] = cStart;\\n        j = 0;\\n        \\n        while((i<(rows*cols)) && j<2){\\n            \\n            for(int a = l+1; a<=r && i<(rows*cols); a++){\\n                if(a<cols && t>=0 && a>=0){\\n                    ans[i][j++] = t;\\n                    ans[i++][j] = a;\\n                    j=0;\\n                }\\n            }\\n            l--;\\n            \\n            for(int a = t+1; a<=d && i<(rows*cols); a++){\\n                if(a<rows && r<cols && a>=0){\\n                    ans[i][j++] = a;\\n                    ans[i++][j] = r;\\n                    j=0;\\n                }\\n            }\\n            t--;\\n            \\n            for(int a = r-1; a>=l && i<(rows*cols); a--){\\n                if(a<cols && d<rows && a>=0){\\n                    ans[i][j++] = d;\\n                    ans[i++][j] = a;\\n                    j=0;\\n                }\\n            }\\n            r++;\\n            \\n            for(int a = d-1; a>=t && i<(rows*cols); a--){\\n                if(a<rows && l>=0 && a>=0){\\n                    ans[i][j++] = a;\\n                    ans[i++][j] = l;\\n                    j=0;\\n                }\\n            }\\n            d++;\\n        }\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1594604,
                "title": "c-98-4-solution",
                "content": "```\\n/*\\nRuntime: 8 ms, faster than 98.40% of C++ online submissions for Spiral Matrix III.\\nMemory Usage: 12.2 MB, less than 62.57% of C++ online submissions for Spiral Matrix III.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(const int rows, \\n                                        const int cols, \\n                                        const int rStart, \\n                                        const int cStart) \\n    {        \\n        const int SIZE = rows * cols;\\n        \\n        if ( 0 == SIZE ) return {};\\n        if ( 1 == SIZE ) \\n        {\\n            return { {0, 0} };\\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        int count = 1;\\n        int r = rStart;\\n        int c = cStart;\\n        int step = 2;\\n        ans.push_back( {r, c} );\\n        \\n        while (1)\\n        {\\n            for ( int i = c; i < c+step; i++ )\\n            {\\n                if (  0 <= i && i < cols \\n                   && 0 <= r && r < rows )\\n                {\\n                    if ( i==c ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {r, i} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            c += step-1;\\n            \\n            for ( int i = r; i < r+step; i++ )\\n            {\\n                if (  0 <= i && i < rows \\n                   && 0 <= c && c < cols )\\n                {\\n                    if ( i==r ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {i, c} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            r += step-1;\\n            step++;\\n            \\n            for ( int i = c; i > c-step; i-- )\\n            {\\n                if (  0 <= i && i < cols \\n                   && 0 <= r && r < rows )\\n                {\\n                    if ( i==c ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {r, i} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            c += 1-step;\\n            \\n            for ( int i = r; i > r-step; i-- )\\n            {\\n                if (  0 <= i && i < rows \\n                   && 0 <= c && c < cols )\\n                {\\n                    if ( i==r ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {i, c} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            r += 1-step;\\n            step++;\\n        }\\n                \\n        return ans;      \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nRuntime: 8 ms, faster than 98.40% of C++ online submissions for Spiral Matrix III.\\nMemory Usage: 12.2 MB, less than 62.57% of C++ online submissions for Spiral Matrix III.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(const int rows, \\n                                        const int cols, \\n                                        const int rStart, \\n                                        const int cStart) \\n    {        \\n        const int SIZE = rows * cols;\\n        \\n        if ( 0 == SIZE ) return {};\\n        if ( 1 == SIZE ) \\n        {\\n            return { {0, 0} };\\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        int count = 1;\\n        int r = rStart;\\n        int c = cStart;\\n        int step = 2;\\n        ans.push_back( {r, c} );\\n        \\n        while (1)\\n        {\\n            for ( int i = c; i < c+step; i++ )\\n            {\\n                if (  0 <= i && i < cols \\n                   && 0 <= r && r < rows )\\n                {\\n                    if ( i==c ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {r, i} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            c += step-1;\\n            \\n            for ( int i = r; i < r+step; i++ )\\n            {\\n                if (  0 <= i && i < rows \\n                   && 0 <= c && c < cols )\\n                {\\n                    if ( i==r ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {i, c} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            r += step-1;\\n            step++;\\n            \\n            for ( int i = c; i > c-step; i-- )\\n            {\\n                if (  0 <= i && i < cols \\n                   && 0 <= r && r < rows )\\n                {\\n                    if ( i==c ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {r, i} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            c += 1-step;\\n            \\n            for ( int i = r; i > r-step; i-- )\\n            {\\n                if (  0 <= i && i < rows \\n                   && 0 <= c && c < cols )\\n                {\\n                    if ( i==r ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {i, c} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            r += 1-step;\\n            step++;\\n        }\\n                \\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365212,
                "title": "to-practice-the-recursion",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\t\\t\\t// int[][] arr = new int[rows][cols];\\n\\t\\t\\t// arr[rStart][cStart] = 1;\\n\\t\\t\\tint[][] ans = new int[rows * cols][2];\\n\\t\\t\\tif (rows == 1 && cols == 1) return ans;\\n        \\n\\t\\t\\tint[] writer = new int[1];\\n\\t\\t\\tans[0][0] = rStart;\\n\\t\\t\\tans[0][1] = cStart;        \\n\\t\\t\\twriter[0] = 2;\\n\\t\\t\\tspiralMatrixIII(ans, 3, 0, rows, cols, rStart, cStart, writer);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n    \\n\\t\\tprivate void spiralMatrixIII(int[][] ans, int size, int offset, int rows, int cols, int rStart, int cStart, int[] writer) {\\n\\t\\t\\tif ((rStart + offset >= rows) && (rStart - offset < 0) && (cStart + offset >= cols) && (cStart - offset < 0)) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t// right\\n\\t\\t\\tfor (int i = 0; i < size - 1; i++) {\\n\\t\\t\\t\\tif ((rStart - offset + i <= rows - 1) && (cStart + 1 + offset <= cols - 1) && (rStart - offset + i >= 0) && (cStart + 1 + offset >=0)){\\n\\t\\t\\t\\t\\t// arr[rStart - offset + i][cStart + 1 + offset] = writer[0];\\n\\t\\t\\t\\t\\twriter[0]++;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][0] = rStart - offset + i;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][1] = cStart + 1 + offset;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n        \\n\\t\\t\\t// bottom\\n\\t\\t\\tfor (int i = 0; i < size - 1; i++) {\\n\\t\\t\\t\\tif ((rStart + 1 + offset <= rows - 1) && (cStart - i + offset <= cols - 1) && (rStart + 1 + offset >= 0) && (cStart - i + offset >= 0)){\\n\\t\\t\\t\\t\\t// arr[rStart + 1 + offset][cStart - i + offset] = writer[0];\\n\\t\\t\\t\\t\\twriter[0]++;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][0] = rStart + 1 + offset;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][1] = cStart - i + offset;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        \\n\\t\\t\\t// left\\n\\t\\t\\tfor (int i = 0; i < size - 1; i ++) {\\n\\t\\t\\t\\tif ((rStart - i + offset <= rows - 1) && (cStart - 1 - offset <= cols - 1) && (rStart - i + offset >= 0) && (cStart - 1 - offset >= 0)){\\n\\t\\t\\t\\t\\t// arr[rStart - i + offset][cStart - 1 - offset] = writer[0];\\n\\t\\t\\t\\t\\twriter[0]++; \\n\\t\\t\\t\\t\\tans[writer[0] - 2][0] = rStart - i + offset;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][1] = cStart - 1 - offset;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        \\n\\t\\t\\t// top\\n\\t\\t\\tfor (int i = 0; i < size - 1; i++) {\\n\\t\\t\\t\\tif ((rStart - 1 - offset <= rows - 1) && (cStart + i - offset <= cols - 1) && (rStart - 1 - offset >= 0) && (cStart + i - offset >= 0)){\\n\\t\\t\\t\\t\\t// arr[rStart - 1 - offset][cStart + i - offset] = writer[0];\\n\\t\\t\\t\\t\\twriter[0]++;  \\n\\t\\t\\t\\t\\tans[writer[0] - 2][0] = rStart - 1 - offset;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][1] = cStart + i - offset;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tspiralMatrixIII(ans, size + 2, offset + 1, rows, cols, rStart, cStart, writer);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\t\\t\\t// int[][] arr = new int[rows][cols];\\n\\t\\t\\t// arr[rStart][cStart] = 1;\\n\\t\\t\\tint[][] ans = new int[rows * cols][2];\\n\\t\\t\\tif (rows == 1 && cols == 1) return ans;\\n        \\n\\t\\t\\tint[] writer = new int[1];\\n\\t\\t\\tans[0][0] = rStart;\\n\\t\\t\\tans[0][1] = cStart;        \\n\\t\\t\\twriter[0] = 2;\\n\\t\\t\\tspiralMatrixIII(ans, 3, 0, rows, cols, rStart, cStart, writer);\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1285754,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        i ,j = rStart, cStart\\n        inc = 1\\n        ans = [[rStart, cStart]]\\n        while len(ans) < rows*cols:\\n            if inc % 2 == 0:\\n                c = inc * -1\\n            else:\\n                c = inc\\n            z = abs(c)\\n            while z > 0:\\n                if c < 0:\\n                    j -= 1\\n                else:\\n                    j += 1\\n                if i in range(0, rows) and j in range(0, cols):\\n                    ans.append([i, j])\\n                z -= 1\\n            z = abs(c)\\n            while z > 0:\\n                if c < 0:\\n                    i -= 1\\n                else:\\n                    i += 1\\n                if i in range(0, rows) and j in range(0, cols):\\n                    ans.append([i, j])\\n                z -= 1\\n            inc += 1\\n        return ans\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        i ,j = rStart, cStart\\n        inc = 1\\n        ans = [[rStart, cStart]]\\n        while len(ans) < rows*cols:\\n            if inc % 2 == 0:\\n                c = inc * -1\\n            else:\\n                c = inc\\n            z = abs(c)\\n            while z > 0:\\n                if c < 0:\\n                    j -= 1\\n                else:\\n                    j += 1\\n                if i in range(0, rows) and j in range(0, cols):\\n                    ans.append([i, j])\\n                z -= 1\\n            z = abs(c)\\n            while z > 0:\\n                if c < 0:\\n                    i -= 1\\n                else:\\n                    i += 1\\n                if i in range(0, rows) and j in range(0, cols):\\n                    ans.append([i, j])\\n                z -= 1\\n            inc += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218501,
                "title": "java-iterative-approach-clear-code",
                "content": "Here\\'s a clear iterative code in Java, keep expanding to higher square as done with up, down, then expand col then expand row.\\n\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int n = rows*cols;\\n        List<int[]> l = new ArrayList<>();\\n        int rowStart = rStart, rowEnd = rStart+1;\\n        int colStart = cStart, colEnd = cStart+1;\\n        while (l.size() != n) {\\n            for (int j = colStart; j <= colEnd; j++) {\\n                if (isValid(rowStart, j, rows, cols)) {\\n                    l.add(new int[]{rowStart, j});\\n                }\\n            }\\n            for (int i = rowStart+1; i <= rowEnd; i++) {\\n                if (isValid(i, colEnd, rows, cols)) {\\n                    l.add(new int[]{i, colEnd});\\n                }\\n            }\\n            for (int j = colEnd-1; j >= colStart-1; j--) {\\n                if (isValid(rowEnd, j, rows, cols)) {\\n                    l.add(new int[]{rowEnd, j});\\n                }\\n            }\\n            for (int i = rowEnd-1; i >= rowStart; i--) {\\n                if (isValid(i, colStart-1, rows, cols)) {\\n                    l.add(new int[]{i, colStart-1});\\n                }\\n            }\\n            rowStart--;\\n            colStart--;\\n            rowEnd++;\\n            colEnd++;\\n        }\\n        int[][] res = new int[l.size()][];\\n        for (int i = 0; i < l.size(); i++) {\\n            res[i] = l.get(i);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int i, int j, int rows, int cols) {\\n        return (i >= 0 && i < rows && j >= 0 && j < cols);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int n = rows*cols;\\n        List<int[]> l = new ArrayList<>();\\n        int rowStart = rStart, rowEnd = rStart+1;\\n        int colStart = cStart, colEnd = cStart+1;\\n        while (l.size() != n) {\\n            for (int j = colStart; j <= colEnd; j++) {\\n                if (isValid(rowStart, j, rows, cols)) {\\n                    l.add(new int[]{rowStart, j});\\n                }\\n            }\\n            for (int i = rowStart+1; i <= rowEnd; i++) {\\n                if (isValid(i, colEnd, rows, cols)) {\\n                    l.add(new int[]{i, colEnd});\\n                }\\n            }\\n            for (int j = colEnd-1; j >= colStart-1; j--) {\\n                if (isValid(rowEnd, j, rows, cols)) {\\n                    l.add(new int[]{rowEnd, j});\\n                }\\n            }\\n            for (int i = rowEnd-1; i >= rowStart; i--) {\\n                if (isValid(i, colStart-1, rows, cols)) {\\n                    l.add(new int[]{i, colStart-1});\\n                }\\n            }\\n            rowStart--;\\n            colStart--;\\n            rowEnd++;\\n            colEnd++;\\n        }\\n        int[][] res = new int[l.size()][];\\n        for (int i = 0; i < l.size(); i++) {\\n            res[i] = l.get(i);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int i, int j, int rows, int cols) {\\n        return (i >= 0 && i < rows && j >= 0 && j < cols);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979712,
                "title": "python-solution-faster-than-96",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        res = [[r0, c0]]\\n        c_r, c_c = r0, c0  # current row, current column\\n        s, d = 1, 1  # step, direction\\n\\n        while len(res) < R * C:\\n            for _ in range(s):\\n                c_c = c_c + 1 * d\\n                if 0 <= c_r < R and 0 <= c_c < C:\\n                    res.append([c_r, c_c])\\n\\n            for _ in range(s):\\n                c_r = c_r + 1 * d\\n                if 0 <= c_r < R and 0 <= c_c < C:\\n                    res.append([c_r, c_c])\\n\\n            s += 1\\n            d *= -1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        res = [[r0, c0]]\\n        c_r, c_c = r0, c0  # current row, current column\\n        s, d = 1, 1  # step, direction\\n\\n        while len(res) < R * C:\\n            for _ in range(s):\\n                c_c = c_c + 1 * d\\n                if 0 <= c_r < R and 0 <= c_c < C:\\n                    res.append([c_r, c_c])\\n\\n            for _ in range(s):\\n                c_r = c_r + 1 * d\\n                if 0 <= c_r < R and 0 <= c_c < C:\\n                    res.append([c_r, c_c])\\n\\n            s += 1\\n            d *= -1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866874,
                "title": "java-very-simple-concise-and-fast",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R*C][2];\\n        \\n        int direction=0;//{0,1,2,3};\\n        int index=0;\\n        int r=r0, c=c0;\\n        int step=0, size=1;\\n        \\n        while(index < R*C){\\n            if(r>=0 && r<=R-1 && c>=0 && c<=C-1){\\n                result[index][0]=r;\\n                result[index][1]=c;\\n                index++;\\n            }\\n\\n            if(direction==0){\\n                c++;\\n            }else if(direction==1)\\n                r++;\\n            else if(direction==2){\\n                c--;\\n            }else if(direction==3)\\n                r--;\\n            \\n            step++; //steps taken on a same direction\\n            if(step == size){\\n                direction= (direction+1) %4;\\n                //only on east and west we increase size.\\n                if(direction==0 || direction ==2)\\n                    size++;\\n                step=0;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R*C][2];\\n        \\n        int direction=0;//{0,1,2,3};\\n        int index=0;\\n        int r=r0, c=c0;\\n        int step=0, size=1;\\n        \\n        while(index < R*C){\\n            if(r>=0 && r<=R-1 && c>=0 && c<=C-1){\\n                result[index][0]=r;\\n                result[index][1]=c;\\n                index++;\\n            }\\n\\n            if(direction==0){\\n                c++;\\n            }else if(direction==1)\\n                r++;\\n            else if(direction==2){\\n                c--;\\n            }else if(direction==3)\\n                r--;\\n            \\n            step++; //steps taken on a same direction\\n            if(step == size){\\n                direction= (direction+1) %4;\\n                //only on east and west we increase size.\\n                if(direction==0 || direction ==2)\\n                    size++;\\n                step=0;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848527,
                "title": "95-runtime-50-space-c",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        \\n        int cnt = 2;\\n        int inc = 1;\\n        vector<vector<int>> fi;\\n        fi.push_back({r0, c0});\\n        while(cnt <= R*C){\\n            for(int i = c0+1; i <= c0 + inc && i < C && (r0 >= 0 && r0 < R); i++){\\n                if(i >= 0){\\n                    cnt++;\\n                    fi.push_back({r0, i});\\n                } \\n\\n            }\\n            c0 = c0+inc;\\n            if(cnt>R*C){\\n                break;\\n            }\\n            \\n            for(int i = r0+1; i <= r0+ inc && i < R && (c0 >= 0 && c0 < C); i++){\\n                if(i >= 0){\\n                    cnt++;\\n                    fi.push_back({i, c0});\\n                }\\n            }\\n            r0 = r0 + inc;\\n            if(cnt>R*C){\\n                break;\\n            }\\n            inc++;\\n            for(int i = c0-1; i >= c0 - inc && i>= 0 && (r0 >= 0 && r0 < R); i--){\\n                if(i < C){\\n                    cnt++;\\n                    fi.push_back({r0, i});\\n                }\\n            }\\n            c0 = c0-inc;\\n            if(cnt>R*C){\\n                break;\\n            }\\n            for(int i = r0-1; i >= r0 - inc && i >= 0 && (c0 >= 0 && c0 < C); i--){\\n                if(i < R) {\\n                    cnt++;\\n                    fi.push_back({i, c0});\\n                }     \\n            }\\n            r0 = r0-inc;\\n            if(cnt > R*C){\\n                break;\\n            }\\n            inc++;\\n        }\\n        return fi;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        \\n        int cnt = 2;\\n        int inc = 1;\\n        vector<vector<int>> fi;\\n        fi.push_back({r0, c0}",
                "codeTag": "Java"
            },
            {
                "id": 834247,
                "title": "a-python-concise-solution-for-generic-these-problem",
                "content": "`direction` is a generator for right, down, left, up loop. If the direction is horizontal, step + 1.\\n```python\\ndef spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n    direction = itertools.cycle([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n    ans = [(r0, c0)]\\n    step = 0\\n    while len(ans) < R*C:\\n        di, dj = next(direction)        \\n        if di==0:\\n            step += 1\\n        for _ in range(step):\\n            r0 += di\\n            c0 += dj\\n            if 0<=r0<R and 0<=c0<C:\\n                ans.append((r0, c0))\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```python\\ndef spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n    direction = itertools.cycle([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n    ans = [(r0, c0)]\\n    step = 0\\n    while len(ans) < R*C:\\n        di, dj = next(direction)        \\n        if di==0:\\n            step += 1\\n        for _ in range(step):\\n            r0 += di\\n            c0 += dj\\n            if 0<=r0<R and 0<=c0<C:\\n                ans.append((r0, c0))\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 812777,
                "title": "python-easy-simple-solution-91-faster",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        ans = []\\n        len_row, len_col = 0, 2\\n        start_row, start_col= r0, c0\\n        direction = 1\\n        cnt = 0\\n\\n        while cnt < R * C:\\n            curr_row, curr_col = start_row, start_col\\n            for c in range(len_col):\\n                curr_col = start_col + c * direction\\n                if 0 <= start_row < R and 0 <= curr_col < C:\\n                    ans.append([start_row, curr_col])\\n                    cnt += 1\\n\\t\\t\\t\\t\\t\\n            start_col = curr_col\\n            start_row += direction\\n\\n            for r in range(len_row):\\n                curr_row = start_row + r * direction\\n                if 0 <= curr_row < R and 0 <= start_col < C:\\n                    ans.append([curr_row, start_col])\\n                    cnt += 1\\n\\n            len_row += 1\\n            len_col += 1\\n            start_row = curr_row\\n            start_row += direction\\n            direction *= -1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        ans = []\\n        len_row, len_col = 0, 2\\n        start_row, start_col= r0, c0\\n        direction = 1\\n        cnt = 0\\n\\n        while cnt < R * C:\\n            curr_row, curr_col = start_row, start_col\\n            for c in range(len_col):\\n                curr_col = start_col + c * direction\\n                if 0 <= start_row < R and 0 <= curr_col < C:\\n                    ans.append([start_row, curr_col])\\n                    cnt += 1\\n\\t\\t\\t\\t\\t\\n            start_col = curr_col\\n            start_row += direction\\n\\n            for r in range(len_row):\\n                curr_row = start_row + r * direction\\n                if 0 <= curr_row < R and 0 <= start_col < C:\\n                    ans.append([curr_row, start_col])\\n                    cnt += 1\\n\\n            len_row += 1\\n            len_col += 1\\n            start_row = curr_row\\n            start_row += direction\\n            direction *= -1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812019,
                "title": "python-beats-100-simple-solution-with-explanation",
                "content": "**Explanation**\\nThe basic idea behind this question is to increment the number of cells traversed after every column and row operation. So if we can perform these two operations and increment the number of cells it needs to traverse next, we simply reach the solution. \\nIn this solution, I have checked if the number of steps required is odd or even. In case of odd, we need to increase the indices by 1 and decrease by 1 in case of even, i.e., go right or south in case of odd steps and west or north in case of even steps. \\n\\n**Hope this helps!**\\n```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        out = [[r0,c0]]\\n        steps = 1\\n        \\n        while len(out) == R*C:\\n            rowS = colS = steps\\n            if rowS % 2 == 0:\\n                x = True\\n            else:\\n                x = False\\n                \\n            while colS != 0:\\n                if not x:\\n                    c0 += 1\\n                else:\\n                    c0 -= 1\\n                if 0 <= c0 < C and 0 <= r0 < R:\\n                    out.append([r0,c0])\\n                colS -= 1\\n                \\n            while rowS != 0:\\n                if not x:\\n                    r0 += 1\\n                else:\\n                    r0 -= 1\\n                if 0 <= c0 < C and 0 <= r0 < R:\\n                    out.append([r0,c0])\\n                rowS -= 1\\n            \\n            steps += 1\\n            \\n        return out\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        out = [[r0,c0]]\\n        steps = 1\\n        \\n        while len(out) == R*C:\\n            rowS = colS = steps\\n            if rowS % 2 == 0:\\n                x = True\\n            else:\\n                x = False\\n                \\n            while colS != 0:\\n                if not x:\\n                    c0 += 1\\n                else:\\n                    c0 -= 1\\n                if 0 <= c0 < C and 0 <= r0 < R:\\n                    out.append([r0,c0])\\n                colS -= 1\\n                \\n            while rowS != 0:\\n                if not x:\\n                    r0 += 1\\n                else:\\n                    r0 -= 1\\n                if 0 <= c0 < C and 0 <= r0 < R:\\n                    out.append([r0,c0])\\n                rowS -= 1\\n            \\n            steps += 1\\n            \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710300,
                "title": "simple-and-concise-c-solution",
                "content": "<iframe src=\"https://leetcode.com/playground/3psR9eMH/shared\" frameBorder=\"0\" width=\"600\" height=\"650\"></iframe>",
                "solutionTags": [],
                "code": "<iframe src=\"https://leetcode.com/playground/3psR9eMH/shared\" frameBorder=\"0\" width=\"600\" height=\"650\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 633901,
                "title": "simpleish-js",
                "content": "```\\n\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    var totalTile = R * C\\n    var amount    = 1\\n    var output    = [[ r0, c0 ]]\\n    var place     = [ r0, c0 ]\\n    var direction = directions[0]\\n    \\n    while ( output.length < totalTile ) {\\n        walk( place, amount | 0, direction, output, R, C )\\n        amount += .5\\n        direction = directions[ ( directions.indexOf( direction ) + 1 ) % 4 ]\\n    }\\n    \\n    return output\\n}\\n\\nconst directions = [\\n    [ 0, 1 ], // east\\n    [ 1, 0 ], // south\\n    [ 0, -1 ], // west\\n    [ -1, 0 ], // north\\n]\\n    \\nconst walk = ( place, amount, direction, output, R, C ) => {\\n    while ( amount ) {\\n        place[0] += direction[0]\\n        place[1] += direction[1]\\n\\n        if ( isInGrid( place[0], place[1], R, C ) )\\n            output.push([ place[0], place[1] ])\\n        \\n        amount--\\n    }\\n}\\n\\nconst isInGrid = ( r, c, R, C ) => 0 <= r && 0 <= c && r < R && c < C\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    var totalTile = R * C\\n    var amount    = 1\\n    var output    = [[ r0, c0 ]]\\n    var place     = [ r0, c0 ]\\n    var direction = directions[0]\\n    \\n    while ( output.length < totalTile ) {\\n        walk( place, amount | 0, direction, output, R, C )\\n        amount += .5\\n        direction = directions[ ( directions.indexOf( direction ) + 1 ) % 4 ]\\n    }\\n    \\n    return output\\n}\\n\\nconst directions = [\\n    [ 0, 1 ], // east\\n    [ 1, 0 ], // south\\n    [ 0, -1 ], // west\\n    [ -1, 0 ], // north\\n]\\n    \\nconst walk = ( place, amount, direction, output, R, C ) => {\\n    while ( amount ) {\\n        place[0] += direction[0]\\n        place[1] += direction[1]\\n\\n        if ( isInGrid( place[0], place[1], R, C ) )\\n            output.push([ place[0], place[1] ])\\n        \\n        amount--\\n    }\\n}\\n\\nconst isInGrid = ( r, c, R, C ) => 0 <= r && 0 <= c && r < R && c < C\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 584440,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        target = R * C\\n        \\n        def in_matrix():\\n            if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n                return True \\n            return False\\n        while len(res) < target:\\n            i += 1\\n            #move right\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                c0 += 1\\n            \\n            #move down\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                r0 += 1\\n            \\n            i += 1\\n            \\n            #move Left\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                c0 -= 1\\n                \\n            #move up\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                r0 -= 1\\n        return res\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        target = R * C\\n        \\n        def in_matrix():\\n            if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n                return True \\n            return False\\n        while len(res) < target:\\n            i += 1\\n            #move right\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                c0 += 1\\n            \\n            #move down\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                r0 += 1\\n            \\n            i += 1\\n            \\n            #move Left\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                c0 -= 1\\n                \\n            #move up\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                r0 -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513543,
                "title": "simple-java-solution",
                "content": "```java\\nclass Solution {\\n    \\n    int[] dr = new int[] { 0, 1, 0, -1 };\\n    int[] dc = new int[] { 1, 0, -1, 0 };\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        \\n        int x = r0, y = c0;\\n        \\n        int[][] res = new int[R*C][2];\\n        res[0][0] = r0;\\n        res[0][1] = c0;\\n\\n        int count = 1;\\n        int size = 1;\\n        \\n        int dir = 0;\\n        \\n        while (count < R * C) {\\n            \\n            for (int i = 0; i < size; i++) {\\n                x = x + dr[dir];\\n                y = y + dc[dir];\\n\\n                if (0 <= x && x < R && 0 <= y && y < C) {\\n                    res[count][0] = x;\\n                    res[count][1] = y;\\n                    count++;\\n                }\\n            }\\n            \\n            dir = (dir + 1) % 4;;\\n            \\n            for (int i = 0; i < size; i++) {\\n                x = x + dr[dir];\\n                y = y + dc[dir];\\n\\n                if (0 <= x && x < R && 0 <= y && y < C) {\\n                    res[count][0] = x;\\n                    res[count][1] = y;\\n                    count++;\\n                }\\n            }\\n            \\n            dir = (dir + 1) % 4;\\n            size++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    int[] dr = new int[] { 0, 1, 0, -1 };\\n    int[] dc = new int[] { 1, 0, -1, 0 };\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        \\n        int x = r0, y = c0;\\n        \\n        int[][] res = new int[R*C][2];\\n        res[0][0] = r0;\\n        res[0][1] = c0;\\n\\n        int count = 1;\\n        int size = 1;\\n        \\n        int dir = 0;\\n        \\n        while (count < R * C) {\\n            \\n            for (int i = 0; i < size; i++) {\\n                x = x + dr[dir];\\n                y = y + dc[dir];\\n\\n                if (0 <= x && x < R && 0 <= y && y < C) {\\n                    res[count][0] = x;\\n                    res[count][1] = y;\\n                    count++;\\n                }\\n            }\\n            \\n            dir = (dir + 1) % 4;;\\n            \\n            for (int i = 0; i < size; i++) {\\n                x = x + dr[dir];\\n                y = y + dc[dir];\\n\\n                if (0 <= x && x < R && 0 <= y && y < C) {\\n                    res[count][0] = x;\\n                    res[count][1] = y;\\n                    count++;\\n                }\\n            }\\n            \\n            dir = (dir + 1) % 4;\\n            size++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501338,
                "title": "python-detailed-explanation-easy-to-understand",
                "content": "Let\\'s assume the board is infinite (then we don\\'t need to care about the case of moving out of boundary, we can add restrictions back later), if the current position is ```(i,j)```, the moves are:\\n```\\ni,j\\ni,j-1\\ni+1,j+1\\ni+1,j\\ni+1,j-1\\ni,j-1\\ni-1,j-1\\n------ (first round ends)\\ni-1,j\\ni-1,j+1\\ni-1,j+2\\ni,j+2\\ni-1,j+2\\n...\\n```\\nLet\\'s make a cut each time when we move to ```(i-k, j-k), k=1,2,3...``` and call it a round, then we\\'ll find the following pattern in each round(```R``` means ```move right```, ```L``` means ```move left```, ```U``` means ```move up```, ```D``` means ```move down```):\\n```\\nfirst round: RDLLUUR\\nsecond round: RRDDDLLLLUUUURR\\nthird round: RRRDDDDDLLLLLLUUUUUURRR\\n```\\nAs you can see:\\nthe number of R: 1 2 3......\\nthe number of D: 1 3 5......\\nthe number of L:  2 4 6......\\nthe number of U: 2 4 6......\\nthe number of R: 1 2 3......\\nThe pattern is quite clear now, from the above observation, we can use 5 counters to count RDLUR, and update positions in five for-loops, update rules:\\n```\\ncnt1+=1\\ncnt2+=2\\ncnt3+=2\\ncnt4+=2\\ncnt5+=1\\n```\\nbecause so far our board is infinite, now we also need to consider the restriction for a legal step, it\\'s simple:\\n```\\n0 <= cur_x < R and 0 <= cur_y < C\\n```\\nBased on the code above, we have the code below:\\n```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        def isGood(x, y):\\n            return 0 <= x < R and 0 <= y < C\\n        \\n        ans = [[r0, c0]]\\n        cnt1 = 1  # R\\n        cnt2 = 1  # D\\n        cnt3 = 2  # L\\n        cnt4 = 2  # U\\n        cnt5 = 1  # R\\n        nx, ny = r0, c0\\n        while len(ans) != R*C:\\n            for i in range(cnt1):\\n                nx, ny = nx, ny+1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt2):\\n                nx, ny = nx+1, ny\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt3):\\n                nx, ny = nx, ny-1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt4):\\n                nx, ny = nx-1, ny\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt5):\\n                nx, ny = nx, ny+1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            cnt1+=1\\n            cnt2+=2\\n            cnt3+=2\\n            cnt4+=2\\n            cnt5+=1\\n            \\n        return ans\\n```\\nNot elegant, but easy enough to understand.",
                "solutionTags": [],
                "code": "```(i,j)```\n```\\ni,j\\ni,j-1\\ni+1,j+1\\ni+1,j\\ni+1,j-1\\ni,j-1\\ni-1,j-1\\n------ (first round ends)\\ni-1,j\\ni-1,j+1\\ni-1,j+2\\ni,j+2\\ni-1,j+2\\n...\\n```\n```(i-k, j-k), k=1,2,3...```\n```R```\n```move right```\n```L```\n```move left```\n```U```\n```move up```\n```D```\n```move down```\n```\\nfirst round: RDLLUUR\\nsecond round: RRDDDLLLLUUUURR\\nthird round: RRRDDDDDLLLLLLUUUUUURRR\\n```\n```\\ncnt1+=1\\ncnt2+=2\\ncnt3+=2\\ncnt4+=2\\ncnt5+=1\\n```\n```\\n0 <= cur_x < R and 0 <= cur_y < C\\n```\n```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        def isGood(x, y):\\n            return 0 <= x < R and 0 <= y < C\\n        \\n        ans = [[r0, c0]]\\n        cnt1 = 1  # R\\n        cnt2 = 1  # D\\n        cnt3 = 2  # L\\n        cnt4 = 2  # U\\n        cnt5 = 1  # R\\n        nx, ny = r0, c0\\n        while len(ans) != R*C:\\n            for i in range(cnt1):\\n                nx, ny = nx, ny+1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt2):\\n                nx, ny = nx+1, ny\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt3):\\n                nx, ny = nx, ny-1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt4):\\n                nx, ny = nx-1, ny\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt5):\\n                nx, ny = nx, ny+1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            cnt1+=1\\n            cnt2+=2\\n            cnt3+=2\\n            cnt4+=2\\n            cnt5+=1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479084,
                "title": "python-concise-solution-beats-100-run-time-and-memory",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        out=[[r0,c0]]\\n        rn,cn=r0,c0\\n        step=1\\n        while len(out)!=R*C:                \\n            direction = ((-1)**(step-1))\\n            if rn<R and rn>-1:             \\n                for c in range(step): \\n                    cn += direction \\n                    if cn<C and cn>-1:\\n                        out.append([rn,cn])\\n            else:                          \\n                cn+= direction*step\\n            if cn<C and cn>-1:              \\n                for c in range(step):\\n                    rn += direction\\n                    if rn<R and rn>-1:\\n                        out.append([rn,cn])\\n            else:                          \\n                rn += direction*step\\n            step+=1\\n        return out \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        out=[[r0,c0]]\\n        rn,cn=r0,c0\\n        step=1\\n        while len(out)!=R*C:                \\n            direction = ((-1)**(step-1))\\n            if rn<R and rn>-1:             \\n                for c in range(step): \\n                    cn += direction \\n                    if cn<C and cn>-1:\\n                        out.append([rn,cn])\\n            else:                          \\n                cn+= direction*step\\n            if cn<C and cn>-1:              \\n                for c in range(step):\\n                    rn += direction\\n                    if rn<R and rn>-1:\\n                        out.append([rn,cn])\\n            else:                          \\n                rn += direction*step\\n            step+=1\\n        return out \\n```",
                "codeTag": "Java"
            },
            {
                "id": 384657,
                "title": "java-clean-solution-step-by-step-with-explanation",
                "content": "```\\nclass Solution {\\n    /*  Time Complexity: the worse condition is when the starting point\\n        is in the south-east corner of the grid, which requires the function\\n        to traveal through (2max(R,C)) ^ 2 points thus the TM would be \\n        O((max(R, C)^2)). Space complexity would be O(R*C)*/\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        // direction: right, down, left, up\\n        int[] dirRow = new int[]{0, 1, 0, -1};\\n        int[] dirCol = new int[]{1, 0, -1, 0};\\n        \\n        int[][] result = new int[R*C][2];\\n        result[0] = new int[]{r0, c0};\\n        // use count to keep track of number of nodes that have been found\\n        // use k to keep track of direction and steps\\n        int count = 1, k = 1;\\n        \\n        while (count != R*C) {\\n            // get direction\\n            int dir = (k - 1) % 4;\\n            // get number of steps\\n            int step = k % 2 == 0 ? k / 2 : (k + 1) / 2;\\n            \\n            // move in this direction\\n            for (int i = 0; i < step; i++) {\\n                r0 += dirRow[dir];\\n                c0 += dirCol[dir];\\n                // check for the bound, if within the bound\\n                // then add them into the result array\\n                if (r0 < R && c0 < C && r0 >= 0 && c0 >= 0) {\\n                    result[count] = new int[]{r0, c0};\\n                    count++;\\n                }\\n            }\\n            k++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /*  Time Complexity: the worse condition is when the starting point\\n        is in the south-east corner of the grid, which requires the function\\n        to traveal through (2max(R,C)) ^ 2 points thus the TM would be \\n        O((max(R, C)^2)). Space complexity would be O(R*C)*/\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        // direction: right, down, left, up\\n        int[] dirRow = new int[]{0, 1, 0, -1};\\n        int[] dirCol = new int[]{1, 0, -1, 0};\\n        \\n        int[][] result = new int[R*C][2];\\n        result[0] = new int[]{r0, c0};\\n        // use count to keep track of number of nodes that have been found\\n        // use k to keep track of direction and steps\\n        int count = 1, k = 1;\\n        \\n        while (count != R*C) {\\n            // get direction\\n            int dir = (k - 1) % 4;\\n            // get number of steps\\n            int step = k % 2 == 0 ? k / 2 : (k + 1) / 2;\\n            \\n            // move in this direction\\n            for (int i = 0; i < step; i++) {\\n                r0 += dirRow[dir];\\n                c0 += dirCol[dir];\\n                // check for the bound, if within the bound\\n                // then add them into the result array\\n                if (r0 < R && c0 < C && r0 >= 0 && c0 >= 0) {\\n                    result[count] = new int[]{r0, c0};\\n                    count++;\\n                }\\n            }\\n            k++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383209,
                "title": "simple-java-solution",
                "content": "```\\n    //Steps : 1,1,2,2,3,3,4,4...(increase step by 1 when turn east or west)\\n    public int[][] spiralMatrixIII(int R, int C, int x, int y) {\\n        int[][] res = new int[R * C][2];\\n        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; //east, south, west, north\\n        int steps = 0, dir = 0, count = 0;\\n        res[0] = new int[]{x, y};\\n        count++;\\n        while (count < R * C) {\\n            if (dir == 0 || dir == 2)\\n                steps++;\\n            for (int i = 0; i < steps; i++) {\\n                x += dirs[dir][0];\\n                y += dirs[dir][1];\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    res[count++] = new int[]{x, y};\\n                }\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    //Steps : 1,1,2,2,3,3,4,4...(increase step by 1 when turn east or west)\\n    public int[][] spiralMatrixIII(int R, int C, int x, int y) {\\n        int[][] res = new int[R * C][2];\\n        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; //east, south, west, north\\n        int steps = 0, dir = 0, count = 0;\\n        res[0] = new int[]{x, y};\\n        count++;\\n        while (count < R * C) {\\n            if (dir == 0 || dir == 2)\\n                steps++;\\n            for (int i = 0; i < steps; i++) {\\n                x += dirs[dir][0];\\n                y += dirs[dir][1];\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    res[count++] = new int[]{x, y};\\n                }\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 267308,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int[][] SpiralMatrixIII(int R, int C, int r0, int c0) {\\n        var res = new int[R * C][];\\n\\n        int cur = 0, len = 1;\\n\\n        while (cur < R * C)\\n        {\\n            for (var i = c0; i < c0 + len; i++) if (i >= 0 && i < C && r0 >= 0 && r0 < R) res[cur++] = new[] { r0, i };\\n\\n            c0 += len;\\n\\n            for (var i = r0; i < r0 + len; i++) if (c0 < C && c0 >= 0 && i >= 0 && i < R) res[cur++] = new[] { i, c0 };\\n\\n            r0 += len++;\\n\\n            for (var i = c0; i > c0 - len; i--) if (r0 < R && r0 >= 0 && i >= 0 && i < C) res[cur++] = new[] { r0, i };\\n\\n            c0 -= len;\\n\\n            for (var i = r0; i > r0 - len; i--) if (i >= 0 && i < R && c0 >= 0 && c0 < C) res[cur++] = new[] { i, c0 };\\n\\n            r0 -= len++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] SpiralMatrixIII(int R, int C, int r0, int c0) {\\n        var res = new int[R * C][];\\n\\n        int cur = 0, len = 1;\\n\\n        while (cur < R * C)\\n        {\\n            for (var i = c0; i < c0 + len; i++) if (i >= 0 && i < C && r0 >= 0 && r0 < R) res[cur++] = new[] { r0, i };\\n\\n            c0 += len;\\n\\n            for (var i = r0; i < r0 + len; i++) if (c0 < C && c0 >= 0 && i >= 0 && i < R) res[cur++] = new[] { i, c0 };\\n\\n            r0 += len++;\\n\\n            for (var i = c0; i > c0 - len; i--) if (r0 < R && r0 >= 0 && i >= 0 && i < C) res[cur++] = new[] { r0, i };\\n\\n            c0 -= len;\\n\\n            for (var i = r0; i > r0 - len; i--) if (i >= 0 && i < R && c0 >= 0 && c0 < C) res[cur++] = new[] { i, c0 };\\n\\n            r0 -= len++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260748,
                "title": "javascript-solution-with-comments-beats-100",
                "content": "```\\n/**\\n * @param {number} R\\n * @param {number} C\\n * @param {number} r0\\n * @param {number} c0\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    // Set start space.\\n    let r = r0;\\n    let c = c0;\\n    let startSpace = [r, c];\\n    \\n    // Define possible diredctions, start from index = 0.\\n    const directions = [\\'+c\\', \\'+r\\', \\'-c\\', \\'-r\\'];\\n    let directionIndex = 0;\\n    \\n    // Add startSpace to the result array.\\n    const result = [startSpace];\\n    \\n    // Mark the start space as parsed and start from spiral shape with length = 2.\\n    let parsedSpaces = 1;\\n    let spiralLength = 2;\\n    \\n    // Define helper method for setting the next direction.\\n    const changeDirection = () => {\\n        directionIndex = directionIndex + 1 > 3 ? 0 : directionIndex + 1;\\n    }\\n    \\n    // Iterate until all R * C spaces of the grid are parsed.\\n    while (result.length < R * C) {\\n        // Calculate the amount of spaces in the next spiral shape.\\n        const areaOfSpiralShape = spiralLength ** 2;\\n        \\n        // Iterate until all spaces of the current spiral shape are parsed.\\n        while (parsedSpaces <= areaOfSpiralShape) {\\n            const isLastSpace = parsedSpaces === areaOfSpiralShape - 1;\\n            \\n            // 1. Go to the next space by incrementing/decrementing c/r according to direction.\\n            // 2. Check if a wall of the current spiral shape is reached.\\n            // 3. Change direction if the wall is reached.\\n            // 4. Exception: leave the current direction if the last space of spiral is reached.\\n            switch (directions[directionIndex]) {\\n                case \\'+c\\':\\n                    c++;\\n                    if (!isLastSpace && c + 1 >= startSpace[1] + spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'-c\\':\\n                    c--;\\n                    if (!isLastSpace && c - 1 <= startSpace[1] - spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'+r\\':\\n                    r++;\\n                    if (!isLastSpace && r + 1 >= startSpace[0] + spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'-r\\': \\n                    r--;\\n                    if (!isLastSpace && r - 1 <= startSpace[0] - spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n            }\\n            \\n            // Add to result in case [r, c] is within R*C grid.\\n            if (c >= 0 && c < C && r >= 0 && r < R) {\\n                result.push([r, c]);\\n            }\\n            parsedSpaces++;\\n        }\\n        \\n        // Set the start space of the next spiral.\\n        startSpace = [r, c];\\n        spiralLength++;\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} R\\n * @param {number} C\\n * @param {number} r0\\n * @param {number} c0\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    // Set start space.\\n    let r = r0;\\n    let c = c0;\\n    let startSpace = [r, c];\\n    \\n    // Define possible diredctions, start from index = 0.\\n    const directions = [\\'+c\\', \\'+r\\', \\'-c\\', \\'-r\\'];\\n    let directionIndex = 0;\\n    \\n    // Add startSpace to the result array.\\n    const result = [startSpace];\\n    \\n    // Mark the start space as parsed and start from spiral shape with length = 2.\\n    let parsedSpaces = 1;\\n    let spiralLength = 2;\\n    \\n    // Define helper method for setting the next direction.\\n    const changeDirection = () => {\\n        directionIndex = directionIndex + 1 > 3 ? 0 : directionIndex + 1;\\n    }\\n    \\n    // Iterate until all R * C spaces of the grid are parsed.\\n    while (result.length < R * C) {\\n        // Calculate the amount of spaces in the next spiral shape.\\n        const areaOfSpiralShape = spiralLength ** 2;\\n        \\n        // Iterate until all spaces of the current spiral shape are parsed.\\n        while (parsedSpaces <= areaOfSpiralShape) {\\n            const isLastSpace = parsedSpaces === areaOfSpiralShape - 1;\\n            \\n            // 1. Go to the next space by incrementing/decrementing c/r according to direction.\\n            // 2. Check if a wall of the current spiral shape is reached.\\n            // 3. Change direction if the wall is reached.\\n            // 4. Exception: leave the current direction if the last space of spiral is reached.\\n            switch (directions[directionIndex]) {\\n                case \\'+c\\':\\n                    c++;\\n                    if (!isLastSpace && c + 1 >= startSpace[1] + spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'-c\\':\\n                    c--;\\n                    if (!isLastSpace && c - 1 <= startSpace[1] - spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'+r\\':\\n                    r++;\\n                    if (!isLastSpace && r + 1 >= startSpace[0] + spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'-r\\': \\n                    r--;\\n                    if (!isLastSpace && r - 1 <= startSpace[0] - spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n            }\\n            \\n            // Add to result in case [r, c] is within R*C grid.\\n            if (c >= 0 && c < C && r >= 0 && r < R) {\\n                result.push([r, c]);\\n            }\\n            parsedSpaces++;\\n        }\\n        \\n        // Set the start space of the next spiral.\\n        startSpace = [r, c];\\n        spiralLength++;\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 220530,
                "title": "python-real-o-r-c-solution-skipping-paths-outside-the-grid-beats-100",
                "content": "Here is the solution that skips rows and columns outside of the grid in O(1) instead of traversing them and checking if every cell is valid like most other solutions do (which yields them O(max(R,C)^2) time complexity which is apparent if you try a case like `1000 1 0 0`\\n\\nWhen I use `timeit` on my function with arguments `30000, 1, 0, 0` my algorithm takes less than 0.05 seconds on my machine, compared to admin provided solution which given exactly the same input takes around 238 seconds to complete (~4 minutes). And it grows really really fast after that, whereas my solution can process input `1000000, 1, 0, 0` in 1.5 seconds.\\n\\n```python \\nclass Solution:\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n        d = 0\\n        steps = 0\\n        ans = [[r0, c0]]\\n        \\n        total = R*C\\n        while len(ans) < total:\\n            d = d % 4\\n            if d % 2 == 0:\\n                steps += 1\\n            steps_left = steps\\n            while steps_left:\\n                r0 = r0 + dirs[d][0]\\n                c0 = c0 + dirs[d][1]\\n                steps_left -= 1\\n                if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n                    ans.append([r0, c0])\\n                elif steps_left:\\n                    if d == 0:\\n                        if c0 < 0 and r0 >= 0:\\n                            steps_left += c0 + 1\\n                            c0 = -1\\n                        else:\\n                            c0 += steps_left\\n                            steps_left = 0\\n                    elif d == 1:\\n                        if r0 < 0 and c0 < C:\\n                            steps_left += r0 + 1\\n                            r0 = -1\\n                        else:\\n                            r0 += steps_left\\n                            steps_left = 0\\n                    elif d == 2:\\n                        if c0 >= C and r0 < R:\\n                            steps_left -= c0 - C\\n                            c0 = C\\n                        else:\\n                            c0 -= steps_left\\n                            steps_left = 0\\n                    else:\\n                        if r0 >= R and c0 >= 0:\\n                            steps_left -= r0 - R\\n                            r0 = R\\n                        else:\\n                            r0 -= steps_left\\n                            steps_left = 0\\n            d += 1\\n        return ans",
                "solutionTags": [],
                "code": "Here is the solution that skips rows and columns outside of the grid in O(1) instead of traversing them and checking if every cell is valid like most other solutions do (which yields them O(max(R,C)^2) time complexity which is apparent if you try a case like `1000 1 0 0`\\n\\nWhen I use `timeit` on my function with arguments `30000, 1, 0, 0` my algorithm takes less than 0.05 seconds on my machine, compared to admin provided solution which given exactly the same input takes around 238 seconds to complete (~4 minutes). And it grows really really fast after that, whereas my solution can process input `1000000, 1, 0, 0` in 1.5 seconds.\\n\\n```python \\nclass Solution:\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n        d = 0\\n        steps = 0\\n        ans = [[r0, c0]]\\n        \\n        total = R*C\\n        while len(ans) < total:\\n            d = d % 4\\n            if d % 2 == 0:\\n                steps += 1\\n            steps_left = steps\\n            while steps_left:\\n                r0 = r0 + dirs[d][0]\\n                c0 = c0 + dirs[d][1]\\n                steps_left -= 1\\n                if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n                    ans.append([r0, c0])\\n                elif steps_left:\\n                    if d == 0:\\n                        if c0 < 0 and r0 >= 0:\\n                            steps_left += c0 + 1\\n                            c0 = -1\\n                        else:\\n                            c0 += steps_left\\n                            steps_left = 0\\n                    elif d == 1:\\n                        if r0 < 0 and c0 < C:\\n                            steps_left += r0 + 1\\n                            r0 = -1\\n                        else:\\n                            r0 += steps_left\\n                            steps_left = 0\\n                    elif d == 2:\\n                        if c0 >= C and r0 < R:\\n                            steps_left -= c0 - C\\n                            c0 = C\\n                        else:\\n                            c0 -= steps_left\\n                            steps_left = 0\\n                    else:\\n                        if r0 >= R and c0 >= 0:\\n                            steps_left -= r0 - R\\n                            r0 = R\\n                        else:\\n                            r0 -= steps_left\\n                            steps_left = 0\\n            d += 1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 219801,
                "title": "c-straightforward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int limit=R*C,size=1,direction=0,counter=1,num=2;\\n        vector<vector<int>> res={{r0,c0}};\\n        while(size<limit)\\n        {\\n            switch(direction)\\n            {   case 0:c0++;break;\\n                case 1:r0++;break;\\n                case 2:c0--;break;\\n                case 3:r0--;break;  }  \\n            if(r0>-1&&c0>-1&&r0<R&&c0<C) res.push_back({r0,c0}),size++;\\n            if((--counter)==0) counter=(++num)/2,direction=(direction+1)%4;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int limit=R*C,size=1,direction=0,counter=1,num=2;\\n        vector<vector<int>> res={{r0,c0}};\\n        while(size<limit)\\n        {\\n            switch(direction)\\n            {   case 0:c0++;break;\\n                case 1:r0++;break;\\n                case 2:c0--;break;\\n                case 3:r0--;break;  }  \\n            if(r0>-1&&c0>-1&&r0<R&&c0<C) res.push_back({r0,c0}),size++;\\n            if((--counter)==0) counter=(++num)/2,direction=(direction+1)%4;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159580,
                "title": "simple-python3-solution-with-video-explanation",
                "content": "Video Link: https://www.youtube.com/watch?v=zG05E85u1s0\\n\\n```\\nclass Solution:\\n  def spiralMatrixIII(self, R, C, r0, c0):\\n    \"\"\"\\n    :type R: int\\n    :type C: int\\n    :type r0: int\\n    :type c0: int\\n    :rtype: List[List[int]]\\n    \"\"\"\\n\\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n    dir_idx = 0\\n    total = R*C\\n    steps = 1\\n    increment = 1\\n    result = [[r0, c0]]\\n\\n    while len(result) < total:\\n      for i in range(increment):\\n        r0, c0 = r0 + dirs[dir_idx][0], c0 + dirs[dir_idx][1]\\n        if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n          result.append([r0, c0])\\n      \\n      dir_idx = (dir_idx + 1) % 4\\n      if steps % 2 == 0:\\n        increment += 1\\n      steps += 1\\n    \\n    return result\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def spiralMatrixIII(self, R, C, r0, c0):\\n    \"\"\"\\n    :type R: int\\n    :type C: int\\n    :type r0: int\\n    :type c0: int\\n    :rtype: List[List[int]]\\n    \"\"\"\\n\\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n    dir_idx = 0\\n    total = R*C\\n    steps = 1\\n    increment = 1\\n    result = [[r0, c0]]\\n\\n    while len(result) < total:\\n      for i in range(increment):\\n        r0, c0 = r0 + dirs[dir_idx][0], c0 + dirs[dir_idx][1]\\n        if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n          result.append([r0, c0])\\n      \\n      dir_idx = (dir_idx + 1) % 4\\n      if steps % 2 == 0:\\n        increment += 1\\n      steps += 1\\n    \\n    return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159112,
                "title": "short-java-solution",
                "content": "```\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] res = new int[R * C][2], dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        boolean[][] v = new boolean[R][C];\\n        int x = r0, y = c0, count = 0, dir = 0;\\n        \\n        while (count < R * C) {\\n            if(x >= 0 && x < R && y >=0 && y < C) {\\n                res[count][0] = x;\\n                res[count][1] = y;\\n                v[x][y] = true;\\n                count++;\\n            }\\n            x += dirs[dir][0];\\n            y += dirs[dir][1];\\n            \\n            dir = (dir + 1)%4;\\n            \\n            //one more step to check if we should change dir\\n            int xx = x + dirs[dir][0];\\n            int yy = y + dirs[dir][1];\\n            if(xx >= 0 && xx < R && yy >=0 && yy < C && v[xx][yy]) dir = (dir + 4 - 1)%4;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] res = new int[R * C][2], dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        boolean[][] v = new boolean[R][C];\\n        int x = r0, y = c0, count = 0, dir = 0;\\n        \\n        while (count < R * C) {\\n            if(x >= 0 && x < R && y >=0 && y < C) {\\n                res[count][0] = x;\\n                res[count][1] = y;\\n                v[x][y] = true;\\n                count++;\\n            }\\n            x += dirs[dir][0];\\n            y += dirs[dir][1];\\n            \\n            dir = (dir + 1)%4;\\n            \\n            //one more step to check if we should change dir\\n            int xx = x + dirs[dir][0];\\n            int yy = y + dirs[dir][1];\\n            if(xx >= 0 && xx < R && yy >=0 && yy < C && v[xx][yy]) dir = (dir + 4 - 1)%4;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158983,
                "title": "python-iterative-solution",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        direct, res, n, l, ind = [(-1, 0), (0, 1), (1, 0), (0, -1)], [[r0, c0]], R * C, 1, 1\\n        while len(res) < n:\\n            for __ in range(2):\\n                for _ in range(l):\\n                    r0 += direct[ind][0]\\n                    c0 += direct[ind][1]\\n                    if 0 <= r0 < R and 0 <= c0 < C:\\n                        res.append([r0, c0])\\n                ind = (ind + 1) % 4\\n            l += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        direct, res, n, l, ind = [(-1, 0), (0, 1), (1, 0), (0, -1)], [[r0, c0]], R * C, 1, 1\\n        while len(res) < n:\\n            for __ in range(2):\\n                for _ in range(l):\\n                    r0 += direct[ind][0]\\n                    c0 += direct[ind][1]\\n                    if 0 <= r0 < R and 0 <= c0 < C:\\n                        res.append([r0, c0])\\n                ind = (ind + 1) % 4\\n            l += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158975,
                "title": "brute-force",
                "content": "high level idea is quite simple: we simulate the circle. If we change direction twice, we add 1 to our step.\\n\\n\\tclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int direction = 0; //0\\n        int step = 1;\\n        int index = 1;\\n        int flag = 0;\\n        \\n        result[0][0] = r0;\\n        result[0][1] = c0;\\n        int x = r0;\\n        int y = c0;\\n        \\n        while(index < R * C) {\\n            for(int i = 0; i < step; i++) {\\n                switch(direction) {\\n                    case 0 :\\n                        y = y+ 1;\\n                        break;\\n                    case 1:\\n                        x = x + 1;\\n                        break;\\n                    case 2:\\n                        y = y- 1;\\n                        break;\\n                    case 3:\\n                        x = x - 1;\\n                        break;\\n                }\\n                \\n                if(isValid(R, C, x, y)) {\\n                    if(index >= R * C) {\\n                        return result;\\n                    }\\n                    \\n                    result[index][0] = x;\\n                    result[index++][1] = y;\\n                }\\n                \\n            }\\n            direction++;\\n            direction = direction % 4;\\n            \\n            if(flag == 1) {\\n                step++;\\n                \\n            }\\n            flag = (flag + 1) % 2;\\n            \\n        }\\n        return result;     \\n    }\\n    \\n    private boolean isValid(int R, int C, int x, int y) {\\n        return x >= 0 && x < R && y >= 0 && y < C;\\n    }}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int direction = 0; //0\\n        int step = 1;\\n        int index = 1;\\n        int flag = 0;\\n        \\n        result[0][0] = r0;\\n        result[0][1] = c0;\\n        int x = r0;\\n        int y = c0;\\n        \\n        while(index < R * C) {\\n            for(int i = 0; i < step; i++) {\\n                switch(direction) {\\n                    case 0 :\\n                        y = y+ 1;\\n                        break;\\n                    case 1:\\n                        x = x + 1;\\n                        break;\\n                    case 2:\\n                        y = y- 1;\\n                        break;\\n                    case 3:\\n                        x = x - 1;\\n                        break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 158968,
                "title": "concise-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        if (R == 0 || C == 0) return new int[0][0];\\n        int[][] res = new int[R * C][2];\\n        int[][] dirs = {{ 0, 1 }, {1, 0 }, {0, -1}, {-1, 0}};\\n        int p = 0; //current pointing direction: 0, 1, 2, 3\\n        int[] steps = {1, 1}; //steps to move along c and r direction\\n        int r = r0, c = c0;\\n        res[0] = new int[] {r0, c0};\\n        int i = 1;\\n        while (i < R * C) {\\n            for (int j = 0; j < steps[p % 2]; j++) {\\n                int[] dir = dirs[p];\\n                r += dir[0];\\n                c += dir[1];\\n                if (r >= 0 && r < R && c >= 0 && c < C) {\\n                    res[i++] = new int[] {r, c};\\n                }\\n            }\\n            steps[p % 2]++;\\n            p = (p + 1) % 4;\\n        }\\n        return res; \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        if (R == 0 || C == 0) return new int[0][0];\\n        int[][] res = new int[R * C][2];\\n        int[][] dirs = {{ 0, 1 }",
                "codeTag": "Java"
            },
            {
                "id": 158962,
                "title": "concise-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int total = R*C;\\n        int dx[4] = { 0 , 1, 0, -1};\\n        int dy[4] = { 1 , 0, -1, 0};\\n        int cnt = 0;\\n        vector<vector<int> > ans;\\n        ans.push_back({r0, c0});\\n        while(total > ans.size() ){\\n            int step = cnt/2+1;\\n            for( int i = 1; i<=step;i++){\\n                r0 += dx[cnt%4];\\n                c0 += dy[cnt%4];\\n                if( r0 >= 0 && c0 >= 0 && r0 < R && c0 <C )\\n                    ans.push_back({r0,c0});\\n            }\\n            cnt++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int total = R*C;\\n        int dx[4] = { 0 , 1, 0, -1};\\n        int dy[4] = { 1 , 0, -1, 0};\\n        int cnt = 0;\\n        vector<vector<int> > ans;\\n        ans.push_back({r0, c0});\\n        while(total > ans.size() ){\\n            int step = cnt/2+1;\\n            for( int i = 1; i<=step;i++){\\n                r0 += dx[cnt%4];\\n                c0 += dy[cnt%4];\\n                if( r0 >= 0 && c0 >= 0 && r0 < R && c0 <C )\\n                    ans.push_back({r0,c0});\\n            }\\n            cnt++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069939,
                "title": "java-solution",
                "content": "\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n            int[][] ans = new int[rows*cols][2];\\n            int i=0;\\n            ans[i++]= new int[]{rStart,cStart};\\n\\n            int len = 0;\\n            int d = 0;\\n\\n            int[] directions = new int[]{0,1,0,-1,0};\\n\\n            while(i< rows*cols){\\n                if(d==0 || d==2){\\n                    len++;\\n                }\\n                for(int k=0;k<len;k++){\\n                    rStart += directions[d];\\n                    cStart += directions[d+1];\\n                    if(rStart<rows && rStart>=0 && cStart<cols && cStart>=0){\\n                        ans[i++]=new int[]{rStart,cStart};\\n                    }\\n                }\\n                d = ++d % 4;\\n            }\\n\\n            return ans;\\n   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n            int[][] ans = new int[rows*cols][2];\\n            int i=0;\\n            ans[i++]= new int[]{rStart,cStart}",
                "codeTag": "Java"
            },
            {
                "id": 4066962,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // Right, Down, Left, Up\\n        int direction = 0; // Start with the right direction\\n        int steps = 1; // Number of steps to take in the current direction\\n        int count = 0; // Number of cells visited\\n        \\n        int x = r0;\\n        int y = c0;\\n        \\n        while (count < R * C) {\\n            for (int i = 0; i < steps; i++) {\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    result[count][0] = x;\\n                    result[count][1] = y;\\n                    count++;\\n                }\\n                \\n                // Move in the current direction\\n                x += directions[direction][0];\\n                y += directions[direction][1];\\n            }\\n            \\n            // Change direction after every two steps\\n            direction = (direction + 1) % 4;\\n            \\n            // Increase steps after every two directions\\n            if (direction == 0 || direction == 2) {\\n                steps++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\nbool validcoordinate(int r,int m,int rows,int cols){\\n           return r>=0&&m>=0&&r<rows&&m<cols;\\n        }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len=1;\\n        vector<vector<int>>ans;\\n        ans.push_back({rStart,cStart});\\n        int x=rStart,y=cStart;\\n    //jbtk ans ka size matrix ke size se kam ho tbtk loop chle kuki sare cell visit krne hai\\n        while(ans.size()<rows*cols){\\n            //toward right\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y+i,rows,cols))\\n                ans.push_back({x,y+i});\\n            }\\n            //goes out of boundary\\n            y+=len;\\n            //toward down\\n            for(int i=1;i<=len;i++){\\n                //check currently in valid cell or not\\n                if(validcoordinate(x+i,y,rows,cols)){\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x+=len;\\n            len++;\\n            //toward left\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y-i,rows,cols))\\n                ans.push_back({x,y-i});\\n            }\\n            y-=len;\\n            //toward up\\n            for(int i=1;i<=len;i++){\\n              if(validcoordinate(x-i,y,rows,cols))\\n              ans.push_back({x-i,y});\\n            }\\n            x-=len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def doMove(self, rows, cols, current_pos, direction_index, distance):\\n        directions = [\\'e\\', \\'s\\', \\'w\\', \\'n\\']\\n        new_direction = directions[direction_index]\\n        spaces_moved = 1\\n        moves = []\\n        while(spaces_moved <= distance):\\n            if new_direction == \\'e\\':\\n                if current_pos[1] + 1 < cols and current_pos[0] >= 0 and current_pos[0] < rows and current_pos[1]+1 >=0:\\n                    moves.append([current_pos[0], current_pos[1]+1])\\n                current_pos = [current_pos[0], current_pos[1]+1]\\n                \\n            \\n            elif new_direction == \\'s\\':\\n                if current_pos[0]+1 < rows and current_pos[1] < cols and current_pos[1] >= 0 and current_pos[0]+1 >=0:\\n                    moves.append([current_pos[0]+1, current_pos[1]])\\n                current_pos = [current_pos[0]+1, current_pos[1]]\\n\\n            elif new_direction == \\'w\\':\\n                if current_pos[1] - 1 >= 0 and current_pos[0] >=0 and current_pos[0] < rows and current_pos[1]-1 < cols:\\n                    moves.append([current_pos[0], current_pos[1] - 1])\\n                current_pos = [current_pos[0], current_pos[1] - 1]\\n\\n            else:\\n                if current_pos[0] - 1 >= 0 and current_pos[1] < cols and current_pos[1] >= 0 and current_pos[0] - 1 < rows:\\n                    moves.append([current_pos[0]-1, current_pos[1]])\\n                current_pos = [current_pos[0]-1, current_pos[1]]\\n\\n            spaces_moved += 1\\n\\n        return moves, current_pos\\n\\n\\n\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        skip_add = True\\n        visited = []\\n        direction_index = 0\\n        distance = 1\\n        current_pos = [rStart, cStart]\\n        visited.append(current_pos)\\n\\n        while(len(visited) < (rows * cols)):\\n            latest_moves, current_pos = self.doMove(rows, cols, current_pos, direction_index, distance)\\n            visited.extend(latest_moves)\\n            direction_index += 1\\n            if direction_index > 3:\\n                direction_index = 0\\n            if not skip_add:\\n                skip_add = True\\n                distance += 1\\n            else:\\n                skip_add = False\\n\\n            \\n\\n        return visited\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // Right, Down, Left, Up\\n        int direction = 0; // Start with the right direction\\n        int steps = 1; // Number of steps to take in the current direction\\n        int count = 0; // Number of cells visited\\n        \\n        int x = r0;\\n        int y = c0;\\n        \\n        while (count < R * C) {\\n            for (int i = 0; i < steps; i++) {\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    result[count][0] = x;\\n                    result[count][1] = y;\\n                    count++;\\n                }\\n                \\n                // Move in the current direction\\n                x += directions[direction][0];\\n                y += directions[direction][1];\\n            }\\n            \\n            // Change direction after every two steps\\n            direction = (direction + 1) % 4;\\n            \\n            // Increase steps after every two directions\\n            if (direction == 0 || direction == 2) {\\n                steps++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\nbool validcoordinate(int r,int m,int rows,int cols){\\n           return r>=0&&m>=0&&r<rows&&m<cols;\\n        }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len=1;\\n        vector<vector<int>>ans;\\n        ans.push_back({rStart,cStart});\\n        int x=rStart,y=cStart;\\n    //jbtk ans ka size matrix ke size se kam ho tbtk loop chle kuki sare cell visit krne hai\\n        while(ans.size()<rows*cols){\\n            //toward right\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y+i,rows,cols))\\n                ans.push_back({x,y+i});\\n            }\\n            //goes out of boundary\\n            y+=len;\\n            //toward down\\n            for(int i=1;i<=len;i++){\\n                //check currently in valid cell or not\\n                if(validcoordinate(x+i,y,rows,cols)){\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x+=len;\\n            len++;\\n            //toward left\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y-i,rows,cols))\\n                ans.push_back({x,y-i});\\n            }\\n            y-=len;\\n            //toward up\\n            for(int i=1;i<=len;i++){\\n              if(validcoordinate(x-i,y,rows,cols))\\n              ans.push_back({x-i,y});\\n            }\\n            x-=len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def doMove(self, rows, cols, current_pos, direction_index, distance):\\n        directions = [\\'e\\', \\'s\\', \\'w\\', \\'n\\']\\n        new_direction = directions[direction_index]\\n        spaces_moved = 1\\n        moves = []\\n        while(spaces_moved <= distance):\\n            if new_direction == \\'e\\':\\n                if current_pos[1] + 1 < cols and current_pos[0] >= 0 and current_pos[0] < rows and current_pos[1]+1 >=0:\\n                    moves.append([current_pos[0], current_pos[1]+1])\\n                current_pos = [current_pos[0], current_pos[1]+1]\\n                \\n            \\n            elif new_direction == \\'s\\':\\n                if current_pos[0]+1 < rows and current_pos[1] < cols and current_pos[1] >= 0 and current_pos[0]+1 >=0:\\n                    moves.append([current_pos[0]+1, current_pos[1]])\\n                current_pos = [current_pos[0]+1, current_pos[1]]\\n\\n            elif new_direction == \\'w\\':\\n                if current_pos[1] - 1 >= 0 and current_pos[0] >=0 and current_pos[0] < rows and current_pos[1]-1 < cols:\\n                    moves.append([current_pos[0], current_pos[1] - 1])\\n                current_pos = [current_pos[0], current_pos[1] - 1]\\n\\n            else:\\n                if current_pos[0] - 1 >= 0 and current_pos[1] < cols and current_pos[1] >= 0 and current_pos[0] - 1 < rows:\\n                    moves.append([current_pos[0]-1, current_pos[1]])\\n                current_pos = [current_pos[0]-1, current_pos[1]]\\n\\n            spaces_moved += 1\\n\\n        return moves, current_pos\\n\\n\\n\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        skip_add = True\\n        visited = []\\n        direction_index = 0\\n        distance = 1\\n        current_pos = [rStart, cStart]\\n        visited.append(current_pos)\\n\\n        while(len(visited) < (rows * cols)):\\n            latest_moves, current_pos = self.doMove(rows, cols, current_pos, direction_index, distance)\\n            visited.extend(latest_moves)\\n            direction_index += 1\\n            if direction_index > 3:\\n                direction_index = 0\\n            if not skip_add:\\n                skip_add = True\\n                distance += 1\\n            else:\\n                skip_add = False\\n\\n            \\n\\n        return visited\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066023,
                "title": "spiral-matrix-iii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAS we have done in spiral-I,spiral-II their was not given from where to start so we assume 4 pointers top,bottom,left,right but in this it is mentioned from where to start so in this traverse matrix till size of resultant array is less than size of matix (rows*cols);\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize len to 1 to represent the length of the current spiral.\\nCreate an empty 2D vector ans to store the coordinates in the spiral.\\nAdd the starting coordinate (rStart, cStart) to ans.\\nEnter a loop that continues until ans contains coordinates for all cells in the grid.\\nInside the loop:\\na. Move right by iterating i from 1 to len, adding valid coordinates to ans.\\nb. Update the y coordinate to the right boundary.\\nc. Move down by iterating i from 1 to len, adding valid coordinates to ans.\\nd. Update the x coordinate to the bottom boundary.\\ne. Increment len to increase the length of the spiral.\\nf. Move left by iterating i from 1 to len, adding valid coordinates to ans.\\ng. Update the y coordinate to the left boundary.\\nh. Move up by iterating i from 1 to len, adding valid coordinates to ans.\\ni. Update the x coordinate to the top boundary.\\nRepeat the above steps until ans contains coordinates for all cells in the grid.\\nReturn the ans vector containing the spiral coordinates.\\n# This code essentially follows a clockwise spiral pattern, extending the spiral by increasing len and updating the boundary coordinates in each direction (right, down, left, up) until all cells are covered.\\n\\n\\n# Complexity\\n- Time complexity:O(n*m)  ; n=rows,m=cols\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m) ; n=rows,m=cols\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool validcoordinate(int r,int m,int rows,int cols){\\n           return r>=0&&m>=0&&r<rows&&m<cols;\\n        }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len=1;\\n        vector<vector<int>>ans;\\n        ans.push_back({rStart,cStart});\\n        int x=rStart,y=cStart;\\n    //jbtk ans ka size matrix ke size se kam ho tbtk loop chle kuki sare cell visit krne hai\\n        while(ans.size()<rows*cols){\\n            //toward right\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y+i,rows,cols))\\n                ans.push_back({x,y+i});\\n            }\\n            //goes out of boundary\\n            y+=len;\\n            //toward down\\n            for(int i=1;i<=len;i++){\\n                //check currently in valid cell or not\\n                if(validcoordinate(x+i,y,rows,cols)){\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x+=len;\\n            len++;\\n            //toward left\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y-i,rows,cols))\\n                ans.push_back({x,y-i});\\n            }\\n            y-=len;\\n            //toward up\\n            for(int i=1;i<=len;i++){\\n              if(validcoordinate(x-i,y,rows,cols))\\n              ans.push_back({x-i,y});\\n            }\\n            x-=len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool validcoordinate(int r,int m,int rows,int cols){\\n           return r>=0&&m>=0&&r<rows&&m<cols;\\n        }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len=1;\\n        vector<vector<int>>ans;\\n        ans.push_back({rStart,cStart});\\n        int x=rStart,y=cStart;\\n    //jbtk ans ka size matrix ke size se kam ho tbtk loop chle kuki sare cell visit krne hai\\n        while(ans.size()<rows*cols){\\n            //toward right\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y+i,rows,cols))\\n                ans.push_back({x,y+i});\\n            }\\n            //goes out of boundary\\n            y+=len;\\n            //toward down\\n            for(int i=1;i<=len;i++){\\n                //check currently in valid cell or not\\n                if(validcoordinate(x+i,y,rows,cols)){\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x+=len;\\n            len++;\\n            //toward left\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y-i,rows,cols))\\n                ans.push_back({x,y-i});\\n            }\\n            y-=len;\\n            //toward up\\n            for(int i=1;i<=len;i++){\\n              if(validcoordinate(x-i,y,rows,cols))\\n              ans.push_back({x-i,y});\\n            }\\n            x-=len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064400,
                "title": "r-50-m-70",
                "content": "# Complexity\\n- Time complexity: **O(max(m, n) ** 2)**\\nm - rows input value.\\nn - cols input value.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(m * n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        # maximum size of row|column, inside the matrix.\\n        row_limit: int = rows\\n        col_limit: int = cols\\n        y: int = rStart\\n        x: int = cStart\\n        dx: int = 0\\n        dy: int = 0\\n        # All coordinates inside given matrix limits.\\n        insides: list[list[int]] = [[y, x]]\\n        # Maximum cells in given matrix.\\n        all_insides: int = rows * cols\\n        turn: int = 0\\n        # Standard steps we need to cover first ROW|COLUMN.\\n        y_steps: int = 1\\n        x_steps: int = 1\\n        # Essentially we\\'re just traversing matrix, and storing correct coordinates.\\n        # From some given point, we just travel ROW|COLUMN and expand it on turns.\\n        # Starting from sizes: ROW == 1, COLUMN == 1 and ending only when all coordinates added.\\n        while len(insides) != all_insides:\\n            if turn == 4:\\n                turn = 0\\n            if turn == 0:\\n                dx = 1\\n                dy = 0\\n            elif turn == 1:\\n                dx = 0\\n                dy = 1\\n            elif turn == 2:\\n                dx = -1\\n                dy = 0\\n            elif turn == 3:\\n                dx = 0\\n                dy = -1\\n            cur_steps: int = 0\\n            if turn == 0 or turn == 2:\\n                while cur_steps != x_steps:\\n                    y += dy\\n                    x += dx\\n                    cur_steps += 1\\n                    # Inside matrix.\\n                    if 0 <= y < row_limit and 0 <= x < col_limit:\\n                        insides.append([y, x])\\n                    # Out of bounds, no reasons to make steps.\\n                    # Just change coordinate to the last position we could have reach.\\n                    elif dx == 1 and x >= col_limit:\\n                        x += dx * (x_steps - cur_steps)\\n                        break\\n                    elif dx == -1 and x < 0:\\n                        x += dx * (x_steps - cur_steps)\\n                        break\\n                x_steps += 1\\n                turn += 1\\n            elif turn == 1 or turn == 3:\\n                while cur_steps != y_steps:\\n                    y += dy\\n                    x += dx\\n                    cur_steps += 1\\n                    if 0 <= y < row_limit and 0 <= x < col_limit:\\n                        insides.append([y, x])\\n                    elif dy == 1 and y >= row_limit:\\n                        y += dy * (y_steps - cur_steps)\\n                        break\\n                    elif dy == -1 and y < 0:\\n                        y += dy * (y_steps - cur_steps)\\n                        break\\n                y_steps += 1\\n                turn += 1\\n        return insides\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        # maximum size of row|column, inside the matrix.\\n        row_limit: int = rows\\n        col_limit: int = cols\\n        y: int = rStart\\n        x: int = cStart\\n        dx: int = 0\\n        dy: int = 0\\n        # All coordinates inside given matrix limits.\\n        insides: list[list[int]] = [[y, x]]\\n        # Maximum cells in given matrix.\\n        all_insides: int = rows * cols\\n        turn: int = 0\\n        # Standard steps we need to cover first ROW|COLUMN.\\n        y_steps: int = 1\\n        x_steps: int = 1\\n        # Essentially we\\'re just traversing matrix, and storing correct coordinates.\\n        # From some given point, we just travel ROW|COLUMN and expand it on turns.\\n        # Starting from sizes: ROW == 1, COLUMN == 1 and ending only when all coordinates added.\\n        while len(insides) != all_insides:\\n            if turn == 4:\\n                turn = 0\\n            if turn == 0:\\n                dx = 1\\n                dy = 0\\n            elif turn == 1:\\n                dx = 0\\n                dy = 1\\n            elif turn == 2:\\n                dx = -1\\n                dy = 0\\n            elif turn == 3:\\n                dx = 0\\n                dy = -1\\n            cur_steps: int = 0\\n            if turn == 0 or turn == 2:\\n                while cur_steps != x_steps:\\n                    y += dy\\n                    x += dx\\n                    cur_steps += 1\\n                    # Inside matrix.\\n                    if 0 <= y < row_limit and 0 <= x < col_limit:\\n                        insides.append([y, x])\\n                    # Out of bounds, no reasons to make steps.\\n                    # Just change coordinate to the last position we could have reach.\\n                    elif dx == 1 and x >= col_limit:\\n                        x += dx * (x_steps - cur_steps)\\n                        break\\n                    elif dx == -1 and x < 0:\\n                        x += dx * (x_steps - cur_steps)\\n                        break\\n                x_steps += 1\\n                turn += 1\\n            elif turn == 1 or turn == 3:\\n                while cur_steps != y_steps:\\n                    y += dy\\n                    x += dx\\n                    cur_steps += 1\\n                    if 0 <= y < row_limit and 0 <= x < col_limit:\\n                        insides.append([y, x])\\n                    elif dy == 1 and y >= row_limit:\\n                        y += dy * (y_steps - cur_steps)\\n                        break\\n                    elif dy == -1 and y < 0:\\n                        y += dy * (y_steps - cur_steps)\\n                        break\\n                y_steps += 1\\n                turn += 1\\n        return insides\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031124,
                "title": "super-easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(R^2 * C^2) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // Right, Down, Left, Up\\n        int direction = 0; // Start with the right direction\\n        int steps = 1; // Number of steps to take in the current direction\\n        int count = 0; // Number of cells visited\\n        \\n        int x = r0;\\n        int y = c0;\\n        \\n        while (count < R * C) {\\n            for (int i = 0; i < steps; i++) {\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    result[count][0] = x;\\n                    result[count][1] = y;\\n                    count++;\\n                }\\n                \\n                // Move in the current direction\\n                x += directions[direction][0];\\n                y += directions[direction][1];\\n            }\\n            \\n            // Change direction after every two steps\\n            direction = (direction + 1) % 4;\\n            \\n            // Increase steps after every two directions\\n            if (direction == 0 || direction == 2) {\\n                steps++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // Right, Down, Left, Up\\n        int direction = 0; // Start with the right direction\\n        int steps = 1; // Number of steps to take in the current direction\\n        int count = 0; // Number of cells visited\\n        \\n        int x = r0;\\n        int y = c0;\\n        \\n        while (count < R * C) {\\n            for (int i = 0; i < steps; i++) {\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    result[count][0] = x;\\n                    result[count][1] = y;\\n                    count++;\\n                }\\n                \\n                // Move in the current direction\\n                x += directions[direction][0];\\n                y += directions[direction][1];\\n            }\\n            \\n            // Change direction after every two steps\\n            direction = (direction + 1) % 4;\\n            \\n            // Increase steps after every two directions\\n            if (direction == 0 || direction == 2) {\\n                steps++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012986,
                "title": "java-esy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][];\\n        int k = 0;\\n        res[k++] = new int[]{rStart, cStart};\\n        int[] direction = {0, 1, 0, -1, 0};\\n        int d = 0;\\n        int len = 0;\\n        while(k < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int i = 0; i < len; i++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart > -1 && rStart < rows && cStart > -1 && cStart < cols){\\n                    res[k++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][];\\n        int k = 0;\\n        res[k++] = new int[]{rStart, cStart};\\n        int[] direction = {0, 1, 0, -1, 0};\\n        int d = 0;\\n        int len = 0;\\n        while(k < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int i = 0; i < len; i++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart > -1 && rStart < rows && cStart > -1 && cStart < cols){\\n                    res[k++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012467,
                "title": "c-simple-brute-force-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        static const struct { int dRow, dCol, dSteps; } dirs[] = {\\n            // right,   down,      left,        up\\n            {0, 1, 0}, {1, 0, 0}, {0, -1, 1}, {-1, 0, 1},\\n        };\\n\\n        vector<vector<int>> res;\\n        res.reserve(rows * cols);\\n\\n        int row = rStart, col = cStart;\\n        for (int nSteps = 1; res.size() < rows * cols; nSteps += 2) {\\n            for (const auto& dir : dirs) {\\n                for (int i = 0; i < nSteps + dir.dSteps; ++i) {\\n                    if (row >= 0 && row < rows && col >= 0 && col < cols)\\n                        res.emplace_back(vector<int>{row, col});\\n                    row += dir.dRow;\\n                    col += dir.dCol;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        static const struct { int dRow, dCol, dSteps; } dirs[] = {\\n            // right,   down,      left,        up\\n            {0, 1, 0}, {1, 0, 0}, {0, -1, 1}, {-1, 0, 1},\\n        };\\n\\n        vector<vector<int>> res;\\n        res.reserve(rows * cols);\\n\\n        int row = rStart, col = cStart;\\n        for (int nSteps = 1; res.size() < rows * cols; nSteps += 2) {\\n            for (const auto& dir : dirs) {\\n                for (int i = 0; i < nSteps + dir.dSteps; ++i) {\\n                    if (row >= 0 && row < rows && col >= 0 && col < cols)\\n                        res.emplace_back(vector<int>{row, col});\\n                    row += dir.dRow;\\n                    col += dir.dCol;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003147,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int totalCells = rows * cols;\\n        int[][] result = new int[totalCells][2];\\n\\n        result[0][0] = rStart;\\n        result[0][1] = cStart;\\n        if (totalCells == 1) return result;\\n\\n        // every left and every right up the steps;\\n        int totalSteps = 1;\\n        int steps = 0;\\n        String dir = \"right\";\\n        int[] currentCell = new int[]{rStart, cStart, 0};\\n        while (totalSteps < totalCells) {\\n            if (dir.equals(\"right\")) {\\n                steps++;\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"down\";\\n            }\\n            if (dir.equals(\"down\")) {\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"left\";\\n            }\\n            if (dir.equals(\"left\")) {\\n                steps++;\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"up\";\\n            }\\n            if (dir.equals(\"up\")) {\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"right\";\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private int addSteps(String dir, int steps, int[] currentCell, int[][] result, int rows, int cols) {\\n        int addedSteps = 0;\\n        for (int i = 0; i < steps; i++) {\\n            if (dir.equals(\"right\")) {\\n                currentCell[1]++;\\n            } else if (dir.equals(\"down\")) {\\n                currentCell[0]++;\\n            } else if (dir.equals(\"left\")) {\\n                currentCell[1]--;\\n            } else  if (dir.equals(\"up\")) {\\n                currentCell[0]--;\\n            }\\n            if (currentCell[0] < 0 || currentCell[0] >= rows || currentCell[1] < 0 || currentCell[1] >= cols) continue;\\n            currentCell[2]++;\\n            result[currentCell[2]][0] = currentCell[0];\\n            result[currentCell[2]][1] = currentCell[1];\\n            addedSteps++;\\n        }\\n        return addedSteps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int totalCells = rows * cols;\\n        int[][] result = new int[totalCells][2];\\n\\n        result[0][0] = rStart;\\n        result[0][1] = cStart;\\n        if (totalCells == 1) return result;\\n\\n        // every left and every right up the steps;\\n        int totalSteps = 1;\\n        int steps = 0;\\n        String dir = \"right\";\\n        int[] currentCell = new int[]{rStart, cStart, 0};\\n        while (totalSteps < totalCells) {\\n            if (dir.equals(\"right\")) {\\n                steps++;\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"down\";\\n            }\\n            if (dir.equals(\"down\")) {\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"left\";\\n            }\\n            if (dir.equals(\"left\")) {\\n                steps++;\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"up\";\\n            }\\n            if (dir.equals(\"up\")) {\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"right\";\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private int addSteps(String dir, int steps, int[] currentCell, int[][] result, int rows, int cols) {\\n        int addedSteps = 0;\\n        for (int i = 0; i < steps; i++) {\\n            if (dir.equals(\"right\")) {\\n                currentCell[1]++;\\n            } else if (dir.equals(\"down\")) {\\n                currentCell[0]++;\\n            } else if (dir.equals(\"left\")) {\\n                currentCell[1]--;\\n            } else  if (dir.equals(\"up\")) {\\n                currentCell[0]--;\\n            }\\n            if (currentCell[0] < 0 || currentCell[0] >= rows || currentCell[1] < 0 || currentCell[1] >= cols) continue;\\n            currentCell[2]++;\\n            result[currentCell[2]][0] = currentCell[0];\\n            result[currentCell[2]][1] = currentCell[1];\\n            addedSteps++;\\n        }\\n        return addedSteps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995487,
                "title": "beats-96-python-straightforward-solution",
                "content": "# Intuition\\nGenerates a spiral matrix of integers within a grid (rows x cols), starting at a specified point (rStart, cStart). It moves in four directions (right, down, left, up) while incrementing numbers until the entire grid is covered.\\n\\n# Complexity\\n- Time complexity: **O(rows * cols)**\\n- Space complexity: **O(rows * cols)**\\n![image.png](https://assets.leetcode.com/users/images/05db3c52-f603-4ca3-8d9a-808e088a982d_1693720178.937379.png)\\n\\n# Code\\n```py\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int):\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        curRow, curCol = rStart, cStart\\n        curNum = 1\\n        dirIdx = 0\\n        iterLen = 1\\n        res = [[rStart, cStart]]\\n        while curNum < rows * cols:\\n            dr, dc = directions[dirIdx]\\n            for c in range(iterLen):\\n                newR = curRow + dr\\n                newC = curCol + dc\\n\\n                if 0 <= newR < rows and 0 <= newC < cols:\\n                    curNum += 1\\n                    res.append([newR, newC])\\n                curRow = newR\\n                curCol = newC\\n\\n            dirIdx = (dirIdx + 1) % 4\\n            if dirIdx % 2 == 0:  # Increase iterLen every two directions\\n                iterLen += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int):\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        curRow, curCol = rStart, cStart\\n        curNum = 1\\n        dirIdx = 0\\n        iterLen = 1\\n        res = [[rStart, cStart]]\\n        while curNum < rows * cols:\\n            dr, dc = directions[dirIdx]\\n            for c in range(iterLen):\\n                newR = curRow + dr\\n                newC = curCol + dc\\n\\n                if 0 <= newR < rows and 0 <= newC < cols:\\n                    curNum += 1\\n                    res.append([newR, newC])\\n                curRow = newR\\n                curCol = newC\\n\\n            dirIdx = (dirIdx + 1) % 4\\n            if dirIdx % 2 == 0:  # Increase iterLen every two directions\\n                iterLen += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988426,
                "title": "optimal-solution-and-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is(int i , int j , int r , int c){\\n        return i>=0 && j>=0 && i<r && j<c;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int r , int c , int x , int y){\\n        vector<vector<int>>v{{x,y}};\\n        int size = r*c , l=1;\\n        while(v.size()<size){\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y+j , r , c)){\\n                    v.push_back({x,y+j});\\n                }\\n            }\\n            y+=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x+j , y , r , c)){\\n                    v.push_back({x+j,y});\\n                }\\n            }\\n            x+=l;\\n            l++;\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y-j , r , c)){\\n                    v.push_back({x,y-j});\\n                }\\n            }\\n            y-=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x-j , y , r , c)){\\n                    v.push_back({x-j,y});\\n                }\\n            }\\n            x-=l;\\n            l++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is(int i , int j , int r , int c){\\n        return i>=0 && j>=0 && i<r && j<c;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int r , int c , int x , int y){\\n        vector<vector<int>>v{{x,y}};\\n        int size = r*c , l=1;\\n        while(v.size()<size){\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y+j , r , c)){\\n                    v.push_back({x,y+j});\\n                }\\n            }\\n            y+=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x+j , y , r , c)){\\n                    v.push_back({x+j,y});\\n                }\\n            }\\n            x+=l;\\n            l++;\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y-j , r , c)){\\n                    v.push_back({x,y-j});\\n                }\\n            }\\n            y-=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x-j , y , r , c)){\\n                    v.push_back({x-j,y});\\n                }\\n            }\\n            x-=l;\\n            l++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988412,
                "title": "simplest-and-easiest-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is(int i , int j , int r , int c){\\n        return i>=0 && j>=0 && i<r && j<c;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int r , int c , int rS , int cS){\\n        vector<vector<int>>v{{rS,cS}};\\n        int size = r*c , l=1 , x=rS , y=cS;\\n        while(v.size()<size){\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y+j , r , c)){\\n                    v.push_back({x,y+j});\\n                }\\n            }\\n            y+=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x+j , y , r , c)){\\n                    v.push_back({x+j,y});\\n                }\\n            }\\n            x+=l;\\n            l++;\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y-j , r , c)){\\n                    v.push_back({x,y-j});\\n                }\\n            }\\n            y-=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x-j , y , r , c)){\\n                    v.push_back({x-j,y});\\n                }\\n            }\\n            x-=l;\\n            l++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is(int i , int j , int r , int c){\\n        return i>=0 && j>=0 && i<r && j<c;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int r , int c , int rS , int cS){\\n        vector<vector<int>>v{{rS,cS}};\\n        int size = r*c , l=1 , x=rS , y=cS;\\n        while(v.size()<size){\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y+j , r , c)){\\n                    v.push_back({x,y+j});\\n                }\\n            }\\n            y+=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x+j , y , r , c)){\\n                    v.push_back({x+j,y});\\n                }\\n            }\\n            x+=l;\\n            l++;\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y-j , r , c)){\\n                    v.push_back({x,y-j});\\n                }\\n            }\\n            y-=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x-j , y , r , c)){\\n                    v.push_back({x-j,y});\\n                }\\n            }\\n            x-=l;\\n            l++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983475,
                "title": "java-straightforward",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // lets make some boundaries and stick with it !\\n        int left = cStart -1 , right = cStart+1 , top = rStart-1 , btm = rStart+1 , cnt= 0;\\n        int [][] res = new int[rows*cols][2];\\n        while(cnt < rows * cols ){\\n            // move left to right\\n            for( ; cStart <= right ; cStart++){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            cStart = right ;\\n            rStart++;\\n\\n            // top to btm \\n            for( ; rStart <= btm ; rStart++){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            rStart = btm  ;\\n            cStart--;\\n\\n            //right to left\\n            for( ; cStart >= left ; cStart--){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            cStart = left;\\n            rStart--;\\n\\n            // btm to top\\n            for( ; rStart >= top ; rStart--){\\n                if( check(rStart , cStart , rows , cols))   res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            rStart = top ;\\n            cStart++;\\n\\n            top--;btm++;left--;right++;\\n            \\n        }\\n        return res;\\n    }\\n    public boolean check( int rStart , int cStart , int rows , int cols){\\n        if( rStart >= 0 && rStart <rows && cStart >= 0 && cStart < cols)  return true ;\\n        return false ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // lets make some boundaries and stick with it !\\n        int left = cStart -1 , right = cStart+1 , top = rStart-1 , btm = rStart+1 , cnt= 0;\\n        int [][] res = new int[rows*cols][2];\\n        while(cnt < rows * cols ){\\n            // move left to right\\n            for( ; cStart <= right ; cStart++){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            cStart = right ;\\n            rStart++;\\n\\n            // top to btm \\n            for( ; rStart <= btm ; rStart++){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            rStart = btm  ;\\n            cStart--;\\n\\n            //right to left\\n            for( ; cStart >= left ; cStart--){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            cStart = left;\\n            rStart--;\\n\\n            // btm to top\\n            for( ; rStart >= top ; rStart--){\\n                if( check(rStart , cStart , rows , cols))   res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            rStart = top ;\\n            cStart++;\\n\\n            top--;btm++;left--;right++;\\n            \\n        }\\n        return res;\\n    }\\n    public boolean check( int rStart , int cStart , int rows , int cols){\\n        if( rStart >= 0 && rStart <rows && cStart >= 0 && cStart < cols)  return true ;\\n        return false ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981258,
                "title": "c-matrix-traversal",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(rows*cols)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    inline bool isValid(int cr,int cc,int rows, int cols){\\n        return cr>=0 && cc>=0 && cr<rows && cc <cols;\\n    }\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> dirs {{0,1,0},{1,0,0},{0,-1,1},{-1,0,1}};\\n        int cellsToVisit = rows*cols-1,cl=1,cr=rStart,cc=cStart;\\n        vector<vector<int>> ans;\\n        ans.push_back({rStart,cStart});\\n        while (cellsToVisit>0){\\n            for (int i=0;i<4 && cellsToVisit>0;i++){\\n                for (int j=0;j<cl+dirs[i][2]&& cellsToVisit>0;j++){\\n                    cr += dirs[i][0];\\n                    cc += dirs[i][1];\\n                    //cout << cr << \"-\" << cc << endl;\\n                    if (isValid(cr,cc,rows,cols)) ans.push_back({cr,cc}),cellsToVisit--;\\n                }\\n            }\\n            cl+=2;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    inline bool isValid(int cr,int cc,int rows, int cols){\\n        return cr>=0 && cc>=0 && cr<rows && cc <cols;\\n    }\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> dirs {{0,1,0},{1,0,0},{0,-1,1},{-1,0,1}};\\n        int cellsToVisit = rows*cols-1,cl=1,cr=rStart,cc=cStart;\\n        vector<vector<int>> ans;\\n        ans.push_back({rStart,cStart});\\n        while (cellsToVisit>0){\\n            for (int i=0;i<4 && cellsToVisit>0;i++){\\n                for (int j=0;j<cl+dirs[i][2]&& cellsToVisit>0;j++){\\n                    cr += dirs[i][0];\\n                    cc += dirs[i][1];\\n                    //cout << cr << \"-\" << cc << endl;\\n                    if (isValid(cr,cc,rows,cols)) ans.push_back({cr,cc}),cellsToVisit--;\\n                }\\n            }\\n            cl+=2;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3971173,
                "title": "easy-solution-cpp-fastest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rstart, int cstart) {\\n        vector<vector<int>> ans;\\n        int total = rows * cols;\\n        int ec = cstart, sc = cstart;\\n        int sr = rstart , er = rstart;\\n            \\n        while(ans.size() < total){\\n            ec++;\\n            if(sr >= 0) \\n                for(int i = max(0,sc); i < min(cols,ec) ; i++) \\n                    ans.push_back({sr,i});\\n                  \\n            er++;\\n            if(ec < cols) \\n                for(int i = max(sr,0) ; i < min(er,rows); i++) \\n                    ans.push_back({i,ec});\\n\\n            sc--;\\n            if(er < rows) \\n                for(int i = min (ec, cols-1); i >max(-1, sc) ;i--) \\n                    ans.push_back({er,i});\\n                   \\n            sr--;\\n            if(sc >=0 )\\n                for(int i = min(er,rows-1) ;i > max(-1,sr) ; i--) \\n                    ans.push_back({i,sc}); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rstart, int cstart) {\\n        vector<vector<int>> ans;\\n        int total = rows * cols;\\n        int ec = cstart, sc = cstart;\\n        int sr = rstart , er = rstart;\\n            \\n        while(ans.size() < total){\\n            ec++;\\n            if(sr >= 0) \\n                for(int i = max(0,sc); i < min(cols,ec) ; i++) \\n                    ans.push_back({sr,i});\\n                  \\n            er++;\\n            if(ec < cols) \\n                for(int i = max(sr,0) ; i < min(er,rows); i++) \\n                    ans.push_back({i,ec});\\n\\n            sc--;\\n            if(er < rows) \\n                for(int i = min (ec, cols-1); i >max(-1, sc) ;i--) \\n                    ans.push_back({er,i});\\n                   \\n            sr--;\\n            if(sc >=0 )\\n                for(int i = min(er,rows-1) ;i > max(-1,sr) ; i--) \\n                    ans.push_back({i,sc}); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956137,
                "title": "solution-same-with-spiral-matrix-i-and-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> sprial(rows, vector<int>(cols));\\n        int i = 0;\\n        int a = rStart;\\n        int b = cStart;\\n        int layer1 = max({a, rows-a, cols-b, b});\\n        sprial.erase(sprial.begin(), sprial.end());\\n        sprial.push_back({rStart, cStart});\\n        for (int layer = 0; layer <= layer1;){\\n            for(i = 0; i < (2 * layer + 1); i++){\\n                if((b - layer + i + 1) >= 0 && (b - layer + i + 1) < cols && (a - layer) >= 0) {\\n                    sprial.push_back({a - layer, b - layer + i + 1});\\n                    }\\n            }\\n            layer++;\\n            for(i = 0; i < 2 * layer - 1; i++){\\n                if((a - layer + i + 2) < rows && (a - layer + i + 2)>=0 && (b + layer) < cols) {\\n                    sprial.push_back({a - layer + 2 + i, b + layer});\\n                    }\\n            }\\n            for(i = 0; i < 2 * layer; i++){\\n                if((b + layer - i -1) < cols && (b + layer - i -1) >= 0 && (a + layer) < rows) {\\n                    sprial.push_back({a + layer, b + layer -i - 1});}\\n            }\\n            for(i = 0; i < 2 * layer; i++){\\n                if((a + layer - i -1) < rows && (a + layer - i -1) >= 0 && (b - layer) >= 0) {\\n                    sprial.push_back({a + layer - i -1, b - layer});}\\n            }\\n        }\\n        return sprial;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> sprial(rows, vector<int>(cols));\\n        int i = 0;\\n        int a = rStart;\\n        int b = cStart;\\n        int layer1 = max({a, rows-a, cols-b, b});\\n        sprial.erase(sprial.begin(), sprial.end());\\n        sprial.push_back({rStart, cStart});\\n        for (int layer = 0; layer <= layer1;){\\n            for(i = 0; i < (2 * layer + 1); i++){\\n                if((b - layer + i + 1) >= 0 && (b - layer + i + 1) < cols && (a - layer) >= 0) {\\n                    sprial.push_back({a - layer, b - layer + i + 1});\\n                    }\\n            }\\n            layer++;\\n            for(i = 0; i < 2 * layer - 1; i++){\\n                if((a - layer + i + 2) < rows && (a - layer + i + 2)>=0 && (b + layer) < cols) {\\n                    sprial.push_back({a - layer + 2 + i, b + layer});\\n                    }\\n            }\\n            for(i = 0; i < 2 * layer; i++){\\n                if((b + layer - i -1) < cols && (b + layer - i -1) >= 0 && (a + layer) < rows) {\\n                    sprial.push_back({a + layer, b + layer -i - 1});}\\n            }\\n            for(i = 0; i < 2 * layer; i++){\\n                if((a + layer - i -1) < rows && (a + layer - i -1) >= 0 && (b - layer) >= 0) {\\n                    sprial.push_back({a + layer - i -1, b - layer});}\\n            }\\n        }\\n        return sprial;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908272,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] mat = new int[rows * cols][2];\\n        int in = 0;\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int rs = rStart;\\n        int cs = cStart;\\n        int directionIndex = 0;\\n        int steps = 1;\\n        while (in < rows * cols) {\\n            for (int i = 0; i < steps; i++) {\\n                if (rs >= 0 && rs < rows && cs >= 0 && cs < cols) {\\n                    mat[in][0] = rs;\\n                    mat[in][1] = cs;\\n                    in++;\\n                }\\n                rs += directions[directionIndex][0];\\n                cs += directions[directionIndex][1];\\n            }\\n            if (directionIndex % 2 == 1) {\\n                steps++;\\n            }\\n            directionIndex = (directionIndex + 1) % 4;\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] mat = new int[rows * cols][2];\\n        int in = 0;\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int rs = rStart;\\n        int cs = cStart;\\n        int directionIndex = 0;\\n        int steps = 1;\\n        while (in < rows * cols) {\\n            for (int i = 0; i < steps; i++) {\\n                if (rs >= 0 && rs < rows && cs >= 0 && cs < cols) {\\n                    mat[in][0] = rs;\\n                    mat[in][1] = cs;\\n                    in++;\\n                }\\n                rs += directions[directionIndex][0];\\n                cs += directions[directionIndex][1];\\n            }\\n            if (directionIndex % 2 == 1) {\\n                steps++;\\n            }\\n            directionIndex = (directionIndex + 1) % 4;\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861073,
                "title": "elegant-c-solution",
                "content": "\\n# Solution\\n\\nAdd start cell to the solution list. \\n\\nStart from given starting position and walk until result list contains all `R * C` cells.\\n\\n# Complexity\\n\\nWorst case scenario when $$R = 1$$, $$C > 1$$, and starting position $$(0, C-1)$$ corner. To reach $$(0, C-2)$$ we need to do spiral around, and trace $$3 *3$$ square before we reach starting position. To reach $$(0, C-3)$$ cell we must do $$5 * 5$$ moves. It is easy to see that the algorithm will require $$O(max(R, C)^2)$$ steps to walk all $$R*C$$ cells.\\n\\n# Code\\n\\n```\\n// define how to add pairs\\ntemplate<typename T, typename K>\\nvoid operator +=(pair<T,K> &lhs, const pair<T,K> &rhs) {\\n    lhs.first += rhs.first;\\n    lhs.second += rhs.second;\\n}\\n\\nclass Solution {\\n\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\n        pair<int, int> pos = { rStart, cStart};\\n    \\n        const vector<pair<int,int>> dirs = {\\n            {  0,  1 }, // E\\n            {  1,  0 }, // S\\n            {  0, -1 }, // W\\n            { -1,  0 }  // N\\n        };\\n\\n        vector<vector<int>> ans;\\n        ans.reserve(rows*cols); // from problem statement\\n        ans.push_back({pos.first, pos.second});\\n\\n        const int cnt = rows * cols;\\n\\n        int r = 1; // radius\\n        int s = 0; // steps\\n\\n        while (ans.size() < cnt) {\\n            const auto &move = dirs[s++ % dirs.size()];\\n\\n            for (int k = 0; k < r && ans.size() < cnt; ++k) {\\n                pos += move;\\n                \\n                if (pos.first == clamp(pos.first, 0, rows - 1) && \\n                    pos.second == clamp(pos.second, 0, cols - 1)) {\\n                    ans.push_back({pos.first, pos.second});\\n                }\\n            }\\n\\n            // every two steps increase radius\\n            if (s % 2 == 0) {\\n                r++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// define how to add pairs\\ntemplate<typename T, typename K>\\nvoid operator +=(pair<T,K> &lhs, const pair<T,K> &rhs) {\\n    lhs.first += rhs.first;\\n    lhs.second += rhs.second;\\n}\\n\\nclass Solution {\\n\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\n        pair<int, int> pos = { rStart, cStart};\\n    \\n        const vector<pair<int,int>> dirs = {\\n            {  0,  1 }, // E\\n            {  1,  0 }, // S\\n            {  0, -1 }, // W\\n            { -1,  0 }  // N\\n        };\\n\\n        vector<vector<int>> ans;\\n        ans.reserve(rows*cols); // from problem statement\\n        ans.push_back({pos.first, pos.second});\\n\\n        const int cnt = rows * cols;\\n\\n        int r = 1; // radius\\n        int s = 0; // steps\\n\\n        while (ans.size() < cnt) {\\n            const auto &move = dirs[s++ % dirs.size()];\\n\\n            for (int k = 0; k < r && ans.size() < cnt; ++k) {\\n                pos += move;\\n                \\n                if (pos.first == clamp(pos.first, 0, rows - 1) && \\n                    pos.second == clamp(pos.second, 0, cols - 1)) {\\n                    ans.push_back({pos.first, pos.second});\\n                }\\n            }\\n\\n            // every two steps increase radius\\n            if (s % 2 == 0) {\\n                r++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849650,
                "title": "clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe algorithm generates a spiral path by simulating movement starting from a given position. It traverses right, down, left, and up in a spiral pattern, increasing the step length to cover all cells.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing sets, the algorithm tracks already traversed and all possible coordinates. It ensures cell validity and avoids revisiting cells. By incrementally updating the step length, it efficiently covers all cells in the grid. The output grid is constructed with the visited cells in the order of traversal, forming a spiral pattern that represents the desired path. This approach ensures a complete and optimized traversal of the grid to solve the spiral matrix III problem.\\n# Complexity\\n- Time complexity: O(row^2 + column^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(row * column)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // Create an unordered_set to store the coordinates of all cells in the grid\\n        unordered_set<string> coordinates;\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                // Convert the row and column indices to a string and insert into the set\\n                coordinates.insert(to_string(r) + \"-\" + to_string(c));\\n            }\\n        }\\n\\n        // Create an unordered_set to store the already traversed coordinates\\n        unordered_set<string> AlreadyTraversed;\\n\\n        // Create a vector to store the final output grid\\n        vector<vector<int>> OutputGrid;\\n\\n        // Initialize the current row and column with the starting positions\\n        int curr_row = rStart;\\n        int curr_column = cStart;\\n\\n        // Push the starting cell into the output grid\\n        OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n        // Mark the starting cell as already traversed\\n        AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n\\n        // Initialize the current step length to 1\\n        int curr = 1;\\n\\n        // Continue traversing until all cells have been visited\\n        while (AlreadyTraversed.size() != coordinates.size()) {\\n            // Traverse to the right\\n            for (int i = 0; i < curr; i++) {\\n                // Move to the next right cell\\n                curr_column++;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Traverse down\\n            for (int i = 0; i < curr; i++) {\\n                // Move down by 1\\n                curr_row++;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Increment the current step length\\n            curr++;\\n\\n            // Traverse to the left\\n            for (int i = 0; i < curr; i++) {\\n                // Move left by one\\n                curr_column--;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Traverse up\\n            for (int i = 0; i < curr; i++) {\\n                // Move up by 1\\n                curr_row--;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Increment the current step length\\n            curr++;\\n        }\\n\\n        // Return the final output grid containing the spiral path\\n        return OutputGrid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // Create an unordered_set to store the coordinates of all cells in the grid\\n        unordered_set<string> coordinates;\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                // Convert the row and column indices to a string and insert into the set\\n                coordinates.insert(to_string(r) + \"-\" + to_string(c));\\n            }\\n        }\\n\\n        // Create an unordered_set to store the already traversed coordinates\\n        unordered_set<string> AlreadyTraversed;\\n\\n        // Create a vector to store the final output grid\\n        vector<vector<int>> OutputGrid;\\n\\n        // Initialize the current row and column with the starting positions\\n        int curr_row = rStart;\\n        int curr_column = cStart;\\n\\n        // Push the starting cell into the output grid\\n        OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n        // Mark the starting cell as already traversed\\n        AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n\\n        // Initialize the current step length to 1\\n        int curr = 1;\\n\\n        // Continue traversing until all cells have been visited\\n        while (AlreadyTraversed.size() != coordinates.size()) {\\n            // Traverse to the right\\n            for (int i = 0; i < curr; i++) {\\n                // Move to the next right cell\\n                curr_column++;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Traverse down\\n            for (int i = 0; i < curr; i++) {\\n                // Move down by 1\\n                curr_row++;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Increment the current step length\\n            curr++;\\n\\n            // Traverse to the left\\n            for (int i = 0; i < curr; i++) {\\n                // Move left by one\\n                curr_column--;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Traverse up\\n            for (int i = 0; i < curr; i++) {\\n                // Move up by 1\\n                curr_row--;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Increment the current step length\\n            curr++;\\n        }\\n\\n        // Return the final output grid containing the spiral path\\n        return OutputGrid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828031,
                "title": "java-straightforward-simulation",
                "content": "The square we walk in grows its sides by **2** each iteration; i.e., **1 x 1**-> **3 x 3**-> **5 x 5**. The walk down needs to be one shorter than the others, and the walk right needs to be one longer.\\n\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][2];\\n        \\n        int x = rStart, y = cStart, idx = 0, spiralSize = 1;\\n        while (idx < res.length) {\\n            //walk down\\n            for (int i = 0; i < spiralSize - 2; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                x++;\\n            }\\n            //walk left\\n            for (int i = 0; i < spiralSize - 1; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                y--;\\n            }\\n            //walk up\\n            for (int i = 0; i < spiralSize - 1; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                x--;\\n            }\\n            //walk right\\n            for (int i = 0; i < spiralSize; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                y++;\\n            }\\n            spiralSize += 2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][2];\\n        \\n        int x = rStart, y = cStart, idx = 0, spiralSize = 1;\\n        while (idx < res.length) {\\n            //walk down\\n            for (int i = 0; i < spiralSize - 2; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                x++;\\n            }\\n            //walk left\\n            for (int i = 0; i < spiralSize - 1; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                y--;\\n            }\\n            //walk up\\n            for (int i = 0; i < spiralSize - 1; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                x--;\\n            }\\n            //walk right\\n            for (int i = 0; i < spiralSize; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                y++;\\n            }\\n            spiralSize += 2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815975,
                "title": "innovative-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int max=rows*cols;\\n        int res[][]=new int[max][2];\\n        int i=1,minus=1,count=0;\\n        res[count++]=new int[]{rStart,cStart};\\n        while(count<max){\\n            for(int j=i;j>0;j--){\\n                cStart+=minus;\\n                if(rStart<rows && cStart<cols && rStart>=0 && cStart>=0){\\n                    res[count++]=new int[]{rStart,cStart};\\n                    if(count>=max) return res;\\n                }\\n            }\\n            for(int j=i;j>0;j--){\\n                rStart+=minus;\\n                if(rStart<rows && cStart<cols && rStart>=0 && cStart>=0){\\n                    res[count++]=new int[]{rStart,cStart};\\n                    if(count>=max) return res;\\n                }\\n            }\\n            minus*=-1;\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int max=rows*cols;\\n        int res[][]=new int[max][2];\\n        int i=1,minus=1,count=0;\\n        res[count++]=new int[]{rStart,cStart};\\n        while(count<max){\\n            for(int j=i;j>0;j--){\\n                cStart+=minus;\\n                if(rStart<rows && cStart<cols && rStart>=0 && cStart>=0){\\n                    res[count++]=new int[]{rStart,cStart};\\n                    if(count>=max) return res;\\n                }\\n            }\\n            for(int j=i;j>0;j--){\\n                rStart+=minus;\\n                if(rStart<rows && cStart<cols && rStart>=0 && cStart>=0){\\n                    res[count++]=new int[]{rStart,cStart};\\n                    if(count>=max) return res;\\n                }\\n            }\\n            minus*=-1;\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785773,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        directions = [(0 ,1), (1, 0), (0, -1), (-1, 0)]\\n        step = 0\\n        w = 2\\n        ret = [[rStart, cStart]]\\n        r, c = rStart, cStart\\n        while len(ret) < rows * cols:\\n            direction = directions[step % 4]\\n\\n            for i in range(1, w):\\n                r += direction[0]\\n                c += direction[1]\\n                if r >= 0 and r < rows and c >= 0 and c < cols:\\n                    ret.append([r, c])\\n\\n            step += 1\\n            if step % 2 == 0:\\n                w += 1\\n        return ret\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        directions = [(0 ,1), (1, 0), (0, -1), (-1, 0)]\\n        step = 0\\n        w = 2\\n        ret = [[rStart, cStart]]\\n        r, c = rStart, cStart\\n        while len(ret) < rows * cols:\\n            direction = directions[step % 4]\\n\\n            for i in range(1, w):\\n                r += direction[0]\\n                c += direction[1]\\n                if r >= 0 and r < rows and c >= 0 and c < cols:\\n                    ret.append([r, c])\\n\\n            step += 1\\n            if step % 2 == 0:\\n                w += 1\\n        return ret\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773371,
                "title": "java-easy-understable-problem",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int size = 1;\\n        int dir = 1;\\n        int result[][] = new int[rows * cols][2];\\n        result[0] = new int[]{rStart, cStart};\\n        \\n        while (size < rows * cols) {\\n            // for east\\n            int east = 1;\\n            while (east <= dir) {\\n                cStart++;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                east++;\\n            }\\n            \\n            // for south\\n            int south = 1;\\n            while (south <= dir) {\\n                rStart++;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                south++;\\n            }\\n            \\n            dir++;\\n            \\n            // for west\\n            int west = 1;\\n            while (west <= dir) {\\n                cStart--;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                west++;\\n            }\\n            \\n            // for north\\n            int north = 1;\\n            while (north <= dir) {\\n                rStart--;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                north++;\\n            }\\n            \\n            dir++;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public static boolean check(int row, int col, int rows, int cols) {\\n        return row >= 0 && row < rows && col >= 0 && col < cols;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int size = 1;\\n        int dir = 1;\\n        int result[][] = new int[rows * cols][2];\\n        result[0] = new int[]{rStart, cStart};\\n        \\n        while (size < rows * cols) {\\n            // for east\\n            int east = 1;\\n            while (east <= dir) {\\n                cStart++;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                east++;\\n            }\\n            \\n            // for south\\n            int south = 1;\\n            while (south <= dir) {\\n                rStart++;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                south++;\\n            }\\n            \\n            dir++;\\n            \\n            // for west\\n            int west = 1;\\n            while (west <= dir) {\\n                cStart--;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                west++;\\n            }\\n            \\n            // for north\\n            int north = 1;\\n            while (north <= dir) {\\n                rStart--;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                north++;\\n            }\\n            \\n            dir++;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public static boolean check(int row, int col, int rows, int cols) {\\n        return row >= 0 && row < rows && col >= 0 && col < cols;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741426,
                "title": "slow-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        matrix = []\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix.append([i,j])\\n        mypath = [[rStart, cStart]]\\n        mypoint = [rStart, cStart]\\n        offset = 1\\n        while len(mypath) < len(matrix):\\n            # right\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0],mypoint[1]+1]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            # down\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0]+1,mypoint[1]]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            offset += 1\\n            #left\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0],mypoint[1]-1]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            # up\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0]-1,mypoint[1]]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            offset += 1\\n            steps += 1\\n\\n\\n        return mypath\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        matrix = []\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix.append([i,j])\\n        mypath = [[rStart, cStart]]\\n        mypoint = [rStart, cStart]\\n        offset = 1\\n        while len(mypath) < len(matrix):\\n            # right\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0],mypoint[1]+1]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            # down\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0]+1,mypoint[1]]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            offset += 1\\n            #left\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0],mypoint[1]-1]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            # up\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0]-1,mypoint[1]]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            offset += 1\\n            steps += 1\\n\\n\\n        return mypath\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734825,
                "title": "easiest-code-you-will-ever-find-beats-everyone",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, r: int, c: int, i: int, j: int) -> List[List[int]]:\\n\\n\\n        ans = []                                    \\n        rb, lb, ub, db = j, j, i, i                 \\n        while (len(ans) < r*c):                     \\n            while j < rb + 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                j += 1                              \\n            rb += 1                                 \\n                                            \\n            while i < db + 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                i += 1                              \\n            db += 1                                 \\n                                            \\n            while j > lb - 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                j -= 1                              \\n            lb -= 1                                 \\n                                            \\n            while i > ub - 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                i -= 1                              \\n            ub -= 1                                 \\n        return ans                                                      \\n                  \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, r: int, c: int, i: int, j: int) -> List[List[int]]:\\n\\n\\n        ans = []                                    \\n        rb, lb, ub, db = j, j, i, i                 \\n        while (len(ans) < r*c):                     \\n            while j < rb + 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                j += 1                              \\n            rb += 1                                 \\n                                            \\n            while i < db + 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                i += 1                              \\n            db += 1                                 \\n                                            \\n            while j > lb - 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                j -= 1                              \\n            lb -= 1                                 \\n                                            \\n            while i > ub - 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                i -= 1                              \\n            ub -= 1                                 \\n        return ans                                                      \\n                  \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734049,
                "title": "c-termination-condition-one-loop-design-hard-problem-2023-july",
                "content": "July 7, 2023\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo be a good thinker, it takes a lot of practice. \\n\\nThe challenge part is to define termination condition for spiral matrix movement. With uncertain Spiral visit\\'s length, all nodes inside matrix should be able to be visited once. \\n\\nI also learn to write C# in short form, using int[,] instead of declaring two arrays. \\n\\n```\\n// clockwise, right, down, left, up\\nvar directions = new int[,] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n```\\n\\nBetter than the following\\n```\\n var directionRow = new int[] { 0, 1, 0, -1 };\\n var directionCol = new int[] { 1, 0, -1, 0 };\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter 6+ month break, I came back to warmup my C# coding skills to prepare Meta phone screen in 2 months. \\n\\nThe following are needed:\\n1. Work on basics of algorithm - start one algorithm a day, code one algorithm a day\\n2. Also challenge myself to solve more algorithms, really go through painful feelings to fail on some algorithms. \\n3. Get back on working on C# coding skills, one tip a time. \\n4. Trust myself to learn better, fail better.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _885_spiral_matrix_III\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var test = new Program();\\n\\n            var result = test.SpiralMatrixIII(1, 4, 0, 0);\\n            var sb = new StringBuilder();\\n            for (var i = 0; i < result.Length; i++)\\n            {\\n                sb.Append(string.Join(\"-\", result[i]));                \\n                sb.Append(\",\");\\n            }\\n            \\n            Debug.Assert(sb.ToString().CompareTo(\"0-0,0-1,0-2,0-3,\") == 0);\\n\\n            result = test.SpiralMatrixIII(5, 6, 1, 4);\\n        }\\n\\n        /// <summary>\\n        /// Spiral matrix \\n        /// study code\\n        /// https://leetcode.com/problems/spiral-matrix-iii/solutions/2837586/c/\\n        /// </summary>\\n        /// <param name=\"rows\"></param>\\n        /// <param name=\"cols\"></param>\\n        /// <param name=\"rStart\"></param>\\n        /// <param name=\"cStart\"></param>\\n        /// <returns></returns>\\n        public int[][] SpiralMatrixIII(int rows, int cols, int rStart, int cStart)\\n        {\\n            var result = new List<int[]>();\\n\\n            // clockwise, right, down, left, up\\n            var directions = new int[,] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\n            var steps = 0;\\n            var direction = 0;\\n\\n            result.Add(new int[] { rStart, cStart });\\n\\n            // based on two facts: All nodes will be visited in the matrix\\n            // step - 1, 1, 2, 2, 3, 3, ...\\n            // We do not care about nodes outside of matrix - just go through those nodes if needed\\n            // Think about more carefully - one loop - termination condition - ?\\n            while (result.Count < rows * cols)\\n            {\\n                //directions right---> or left <---, increase steps++\\n                if (direction == 0 || direction == 2)\\n                {\\n                    steps++;\\n                }\\n\\n                for (int index = 0; index < steps; index++)\\n                {\\n                    rStart += directions[direction, 0];\\n                    cStart += directions[direction, 1];\\n\\n                    // if it is in matrix range - out-of-range - just ignore\\n                    if (rStart < rows && rStart >= 0 && cStart < cols && cStart >= 0)\\n                    {\\n                        result.Add(new int[] { rStart, cStart });\\n                    }\\n                }\\n\\n                direction = (direction + 1) % 4;\\n            }\\n\\n            return result.ToArray();\\n        }\\n    }    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n// clockwise, right, down, left, up\\nvar directions = new int[,] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n```\n```\\n var directionRow = new int[] { 0, 1, 0, -1 };\\n var directionCol = new int[] { 1, 0, -1, 0 };\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _885_spiral_matrix_III\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var test = new Program();\\n\\n            var result = test.SpiralMatrixIII(1, 4, 0, 0);\\n            var sb = new StringBuilder();\\n            for (var i = 0; i < result.Length; i++)\\n            {\\n                sb.Append(string.Join(\"-\", result[i]));                \\n                sb.Append(\",\");\\n            }\\n            \\n            Debug.Assert(sb.ToString().CompareTo(\"0-0,0-1,0-2,0-3,\") == 0);\\n\\n            result = test.SpiralMatrixIII(5, 6, 1, 4);\\n        }\\n\\n        /// <summary>\\n        /// Spiral matrix \\n        /// study code\\n        /// https://leetcode.com/problems/spiral-matrix-iii/solutions/2837586/c/\\n        /// </summary>\\n        /// <param name=\"rows\"></param>\\n        /// <param name=\"cols\"></param>\\n        /// <param name=\"rStart\"></param>\\n        /// <param name=\"cStart\"></param>\\n        /// <returns></returns>\\n        public int[][] SpiralMatrixIII(int rows, int cols, int rStart, int cStart)\\n        {\\n            var result = new List<int[]>();\\n\\n            // clockwise, right, down, left, up\\n            var directions = new int[,] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\n            var steps = 0;\\n            var direction = 0;\\n\\n            result.Add(new int[] { rStart, cStart });\\n\\n            // based on two facts: All nodes will be visited in the matrix\\n            // step - 1, 1, 2, 2, 3, 3, ...\\n            // We do not care about nodes outside of matrix - just go through those nodes if needed\\n            // Think about more carefully - one loop - termination condition - ?\\n            while (result.Count < rows * cols)\\n            {\\n                //directions right---> or left <---, increase steps++\\n                if (direction == 0 || direction == 2)\\n                {\\n                    steps++;\\n                }\\n\\n                for (int index = 0; index < steps; index++)\\n                {\\n                    rStart += directions[direction, 0];\\n                    cStart += directions[direction, 1];\\n\\n                    // if it is in matrix range - out-of-range - just ignore\\n                    if (rStart < rows && rStart >= 0 && cStart < cols && cStart >= 0)\\n                    {\\n                        result.Add(new int[] { rStart, cStart });\\n                    }\\n                }\\n\\n                direction = (direction + 1) % 4;\\n            }\\n\\n            return result.ToArray();\\n        }\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723058,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result;\\n        \\n        // Initialize the boundary variables\\n        int left = cStart - 1;\\n        int right = cStart + 1;\\n        int top = rStart - 1;\\n        int bottom = rStart + 1;\\n        \\n        // Add the initial position to the result\\n        result.push_back({rStart, cStart});\\n\\n        // Continue until all positions are covered\\n        while (left > -1 || right < cols || top > -1 || bottom < rows) {\\n            // Traverse right from top to bottom\\n            if (right < cols) {\\n                for (int i = top + 1; i < bottom; i++) {\\n                    result.push_back({i, right});\\n                }\\n                right++;\\n            }\\n            \\n            // Traverse down from right to left\\n            if (bottom < rows) {\\n                for (int i = right - 1; i > left; i--) {\\n                    result.push_back({bottom, i});\\n                }\\n                bottom++;\\n            }\\n            \\n            // Traverse left from bottom to top\\n            if (left > -1) {\\n                for (int i = bottom - 1; i > top; i--) {\\n                    result.push_back({i, left});\\n                }\\n                left--;\\n            }\\n            \\n            // Traverse up from left to right\\n            if (top > -1) {\\n                for (int i = left + 1; i < right; i++) {\\n                    result.push_back({top, i});\\n                }\\n                top--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result;\\n        \\n        // Initialize the boundary variables\\n        int left = cStart - 1;\\n        int right = cStart + 1;\\n        int top = rStart - 1;\\n        int bottom = rStart + 1;\\n        \\n        // Add the initial position to the result\\n        result.push_back({rStart, cStart});\\n\\n        // Continue until all positions are covered\\n        while (left > -1 || right < cols || top > -1 || bottom < rows) {\\n            // Traverse right from top to bottom\\n            if (right < cols) {\\n                for (int i = top + 1; i < bottom; i++) {\\n                    result.push_back({i, right});\\n                }\\n                right++;\\n            }\\n            \\n            // Traverse down from right to left\\n            if (bottom < rows) {\\n                for (int i = right - 1; i > left; i--) {\\n                    result.push_back({bottom, i});\\n                }\\n                bottom++;\\n            }\\n            \\n            // Traverse left from bottom to top\\n            if (left > -1) {\\n                for (int i = bottom - 1; i > top; i--) {\\n                    result.push_back({i, left});\\n                }\\n                left--;\\n            }\\n            \\n            // Traverse up from left to right\\n            if (top > -1) {\\n                for (int i = left + 1; i < right; i++) {\\n                    result.push_back({top, i});\\n                }\\n                top--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705690,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        int[][] matrix = new int[rows*cols][2];\\n        int i=0;\\n        // 0th row is filled and i is incremented afterwards\\n        matrix[i++]=new int[]{rStart,cStart};\\n\\n        int d=0; // for direction moving\\n        //to move in all directions as per the need\\n        int[] directions = new int[]{0,1,0,-1,0}; \\n        int length =0;\\n\\n        while(i < rows*cols)\\n        {\\n            if(d==0 || d==2) // length need not to be incremnted in case of 3 or 4\\n            {\\n                length++;\\n            }\\n          //loop will run the length times\\n            for(int j=0; j<length; j++)\\n            {\\n                rStart += directions[d];\\n                cStart += directions[d+1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols)\\n                {\\n                    matrix[i++] = new int[]{rStart,cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return matrix;\\n    }\\n}\\n```\\n\\nUpvote please\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        int[][] matrix = new int[rows*cols][2];\\n        int i=0;\\n        // 0th row is filled and i is incremented afterwards\\n        matrix[i++]=new int[]{rStart,cStart};\\n\\n        int d=0; // for direction moving\\n        //to move in all directions as per the need\\n        int[] directions = new int[]{0,1,0,-1,0}; \\n        int length =0;\\n\\n        while(i < rows*cols)\\n        {\\n            if(d==0 || d==2) // length need not to be incremnted in case of 3 or 4\\n            {\\n                length++;\\n            }\\n          //loop will run the length times\\n            for(int j=0; j<length; j++)\\n            {\\n                rStart += directions[d];\\n                cStart += directions[d+1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols)\\n                {\\n                    matrix[i++] = new int[]{rStart,cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684268,
                "title": "c-very-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        ans.reserve(rows*cols);\\n\\n        enum directions {RIGHT, DOWN, LEFT, UP};\\n        int dir = RIGHT;\\n        int step = 1;\\n        int countAll = rows*cols;\\n\\n        int i = rStart;\\n        int j = cStart;\\n\\n        while(countAll > 0) {\\n            if (dir == RIGHT) {\\n                if (i >=0 && i < rows)\\n                for(int k = max(j, 0), maxK = min(j+step-1, cols-1); k <= maxK; k++) {\\n                    ans.push_back({i, k});\\n                    countAll--;\\n                }\\n                j += step;\\n                dir = DOWN;\\n            } else if (dir == DOWN) {\\n                if (j >=0 && j < cols)\\n                for(int k = max(i, 0), maxK = min(i+step-1, rows-1); k <= maxK; k++) {\\n                    ans.push_back({k, j});\\n                    countAll--;\\n                }\\n                i += step;\\n                step++;\\n                dir = LEFT;\\n            }if (dir == LEFT) {\\n                if (i >=0 && i < rows)\\n                for(int k = min(j, cols-1), minK = max(j-step+1, 0); k >= minK; k--) {\\n                    ans.push_back({i, k});\\n                    countAll--;\\n                }\\n                j -= step;\\n                dir = UP;\\n            } else if (dir == UP) {\\n                if (j >=0 && j < cols)\\n                for(int k = min(i, rows-1), minK = max(i-step+1, 0); k >= minK; k--) {\\n                    ans.push_back({k, j});\\n                    countAll--;\\n                }\\n                i -= step;\\n                step++;\\n                dir = RIGHT;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        ans.reserve(rows*cols);\\n\\n        enum directions {RIGHT, DOWN, LEFT, UP};\\n        int dir = RIGHT;\\n        int step = 1;\\n        int countAll = rows*cols;\\n\\n        int i = rStart;\\n        int j = cStart;\\n\\n        while(countAll > 0) {\\n            if (dir == RIGHT) {\\n                if (i >=0 && i < rows)\\n                for(int k = max(j, 0), maxK = min(j+step-1, cols-1); k <= maxK; k++) {\\n                    ans.push_back({i, k});\\n                    countAll--;\\n                }\\n                j += step;\\n                dir = DOWN;\\n            } else if (dir == DOWN) {\\n                if (j >=0 && j < cols)\\n                for(int k = max(i, 0), maxK = min(i+step-1, rows-1); k <= maxK; k++) {\\n                    ans.push_back({k, j});\\n                    countAll--;\\n                }\\n                i += step;\\n                step++;\\n                dir = LEFT;\\n            }if (dir == LEFT) {\\n                if (i >=0 && i < rows)\\n                for(int k = min(j, cols-1), minK = max(j-step+1, 0); k >= minK; k--) {\\n                    ans.push_back({i, k});\\n                    countAll--;\\n                }\\n                j -= step;\\n                dir = UP;\\n            } else if (dir == UP) {\\n                if (j >=0 && j < cols)\\n                for(int k = min(i, rows-1), minK = max(i-step+1, 0); k >= minK; k--) {\\n                    ans.push_back({k, j});\\n                    countAll--;\\n                }\\n                i -= step;\\n                step++;\\n                dir = RIGHT;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657077,
                "title": "solution-with-comments-3",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] result = new int[rows * cols][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int directionIndex = 0;\\n        int currentRow = rStart;\\n        int currentCol = cStart;\\n        int count = 0;\\n        int stepsInCurrentDirection = 1;\\n\\n        while (count < rows * cols) {\\n            for (int i = 0; i < 2; i++) {  // \\u041E\\u0431\\u0440\\u043E\\u0431\\u043A\\u0430 \\u0434\\u0432\\u043E\\u0445 \\u043A\\u0440\\u043E\\u043A\\u0456\\u0432 \\u0443 \\u043F\\u043E\\u0442\\u043E\\u0447\\u043D\\u043E\\u043C\\u0443 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n                for (int j = 0; j < stepsInCurrentDirection; j++) {\\n                    if (currentRow >= 0 && currentRow < rows && currentCol >= 0 && currentCol < cols) {\\n                        result[count++] = new int[]{currentRow, currentCol};\\n                    }\\n                    currentRow += directions[directionIndex][0];\\n                    currentCol += directions[directionIndex][1];\\n                    if (count == rows * cols) {\\n                        return result;  // \\u0412\\u0441\\u0456 \\u043F\\u043E\\u0437\\u0438\\u0446\\u0456\\u0457 \\u0432\\u0456\\u0434\\u0432\\u0456\\u0434\\u0430\\u043D\\u0456, \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454\\u043C\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\n                    }\\n                }\\n                directionIndex = (directionIndex + 1) % 4;  // \\u0417\\u043C\\u0456\\u043D\\u0430 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n            }\\n            stepsInCurrentDirection++;  // \\u0417\\u0431\\u0456\\u043B\\u044C\\u0448\\u0435\\u043D\\u043D\\u044F \\u043A\\u0456\\u043B\\u044C\\u043A\\u043E\\u0441\\u0442\\u0456 \\u043A\\u0440\\u043E\\u043A\\u0456\\u0432 \\u0443 \\u043D\\u0430\\u0441\\u0442\\u0443\\u043F\\u043D\\u043E\\u043C\\u0443 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] result = new int[rows * cols][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int directionIndex = 0;\\n        int currentRow = rStart;\\n        int currentCol = cStart;\\n        int count = 0;\\n        int stepsInCurrentDirection = 1;\\n\\n        while (count < rows * cols) {\\n            for (int i = 0; i < 2; i++) {  // \\u041E\\u0431\\u0440\\u043E\\u0431\\u043A\\u0430 \\u0434\\u0432\\u043E\\u0445 \\u043A\\u0440\\u043E\\u043A\\u0456\\u0432 \\u0443 \\u043F\\u043E\\u0442\\u043E\\u0447\\u043D\\u043E\\u043C\\u0443 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n                for (int j = 0; j < stepsInCurrentDirection; j++) {\\n                    if (currentRow >= 0 && currentRow < rows && currentCol >= 0 && currentCol < cols) {\\n                        result[count++] = new int[]{currentRow, currentCol};\\n                    }\\n                    currentRow += directions[directionIndex][0];\\n                    currentCol += directions[directionIndex][1];\\n                    if (count == rows * cols) {\\n                        return result;  // \\u0412\\u0441\\u0456 \\u043F\\u043E\\u0437\\u0438\\u0446\\u0456\\u0457 \\u0432\\u0456\\u0434\\u0432\\u0456\\u0434\\u0430\\u043D\\u0456, \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454\\u043C\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\n                    }\\n                }\\n                directionIndex = (directionIndex + 1) % 4;  // \\u0417\\u043C\\u0456\\u043D\\u0430 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n            }\\n            stepsInCurrentDirection++;  // \\u0417\\u0431\\u0456\\u043B\\u044C\\u0448\\u0435\\u043D\\u043D\\u044F \\u043A\\u0456\\u043B\\u044C\\u043A\\u043E\\u0441\\u0442\\u0456 \\u043A\\u0440\\u043E\\u043A\\u0456\\u0432 \\u0443 \\u043D\\u0430\\u0441\\u0442\\u0443\\u043F\\u043D\\u043E\\u043C\\u0443 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649528,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        total = rows * cols\\n        if total == 1:\\n            return [[rStart, cStart]]\\n        c = 1\\n        step = 0\\n        jump = 1\\n        dirs = [(0,1), (1,0), (0,-1), (-1,0)]\\n        idx = 0\\n        d = dirs[idx]\\n\\n        i = rStart\\n        j = cStart\\n        matrix = [[0 for _ in range(cols)] for _ in range(rows)]\\n        matrix[rStart][cStart] = 1\\n        res = [[rStart, cStart]]\\n\\n        while c <= total:\\n\\n            inext = i + d[0] * jump\\n            jnext = j + d[1] * jump\\n            if idx < 2:\\n                ds = 1\\n                istart = i\\n                iend = inext+1\\n                jstart = j\\n                jend = jnext+1\\n            else:\\n                ds = -1\\n                istart = i\\n                iend = inext-1\\n                jstart = j\\n                jend = jnext-1\\n\\n            for ic in range(istart, iend, ds):\\n                for jc in range(jstart, jend, ds):\\n                    if 0 <= ic < rows and 0 <= jc < cols and matrix[ic][jc] == 0:\\n                        c += 1\\n                        res.append([ic, jc])\\n                        matrix[ic][jc] = 1\\n                        if c == total:\\n\\n                            return res\\n\\n            step += 1\\n            \\n            if idx == 3:\\n                idx = 0\\n            else:\\n                idx += 1\\n            d = dirs[idx]\\n            \\n            if step == 2:\\n                step = 0\\n                jump += 1\\n            \\n            i = inext\\n            j = jnext\\n\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        total = rows * cols\\n        if total == 1:\\n            return [[rStart, cStart]]\\n        c = 1\\n        step = 0\\n        jump = 1\\n        dirs = [(0,1), (1,0), (0,-1), (-1,0)]\\n        idx = 0\\n        d = dirs[idx]\\n\\n        i = rStart\\n        j = cStart\\n        matrix = [[0 for _ in range(cols)] for _ in range(rows)]\\n        matrix[rStart][cStart] = 1\\n        res = [[rStart, cStart]]\\n\\n        while c <= total:\\n\\n            inext = i + d[0] * jump\\n            jnext = j + d[1] * jump\\n            if idx < 2:\\n                ds = 1\\n                istart = i\\n                iend = inext+1\\n                jstart = j\\n                jend = jnext+1\\n            else:\\n                ds = -1\\n                istart = i\\n                iend = inext-1\\n                jstart = j\\n                jend = jnext-1\\n\\n            for ic in range(istart, iend, ds):\\n                for jc in range(jstart, jend, ds):\\n                    if 0 <= ic < rows and 0 <= jc < cols and matrix[ic][jc] == 0:\\n                        c += 1\\n                        res.append([ic, jc])\\n                        matrix[ic][jc] = 1\\n                        if c == total:\\n\\n                            return res\\n\\n            step += 1\\n            \\n            if idx == 3:\\n                idx = 0\\n            else:\\n                idx += 1\\n            d = dirs[idx]\\n            \\n            if step == 2:\\n                step = 0\\n                jump += 1\\n            \\n            i = inext\\n            j = jnext\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620449,
                "title": "brute-force",
                "content": "# Approach\\nSimilar to I and II, store direction in a deque, and use a counter to determine floor((n+1)/2) steps to take, for all natural number n.\\n\\nIf the coordinate is in grid, at coordinate to grid (or increment a counter). Continue this process until all coordinate in grid is collected. \\n\\n# Complexity\\n- Time complexity: O((max(rows, cols))^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(rows * cols)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ret = [[rStart, cStart]]\\n        direction = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n        count = 2\\n\\n        while True:\\n            dx, dy = direction[0]\\n\\n            for i in range(count//2):\\n                rStart += dx\\n                cStart += dy\\n                \\n                if 0 <= rStart < rows and 0 <= cStart < cols:\\n                    ret.append([rStart, cStart]) \\n            \\n            if len(ret) == rows * cols:\\n                return ret\\n            \\n            direction.rotate(-1)\\n            count += 1\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ret = [[rStart, cStart]]\\n        direction = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n        count = 2\\n\\n        while True:\\n            dx, dy = direction[0]\\n\\n            for i in range(count//2):\\n                rStart += dx\\n                cStart += dy\\n                \\n                if 0 <= rStart < rows and 0 <= cStart < cols:\\n                    ret.append([rStart, cStart]) \\n            \\n            if len(ret) == rows * cols:\\n                return ret\\n            \\n            direction.rotate(-1)\\n            count += 1\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613845,
                "title": "simple-simulation",
                "content": "# Approach\\nWe simulate spiral traversal. When we are inside given boundaries we append to the result.\\n\\n# Complexity\\n- Time complexity: $$O(4*rows*cols)$$ ~ $$O(rows*cols)$$.\\n\\n- Space complexity: $$O(rows*cols)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        curDir = 0\\n        result = []\\n        r, c = rStart, cStart\\n        steps = 1\\n        n = 0\\n        while n < rows*cols:\\n            for _ in range(2):\\n                for _ in range(steps):\\n                    if 0 <= r < rows and 0 <= c < cols:\\n                        result.append([r,c])\\n                        n += 1\\n\\n                    r += directions[curDir][0]\\n                    c += directions[curDir][1]\\n            \\n                curDir = (curDir + 1)%len(directions)\\n\\n            steps += 1\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        curDir = 0\\n        result = []\\n        r, c = rStart, cStart\\n        steps = 1\\n        n = 0\\n        while n < rows*cols:\\n            for _ in range(2):\\n                for _ in range(steps):\\n                    if 0 <= r < rows and 0 <= c < cols:\\n                        result.append([r,c])\\n                        n += 1\\n\\n                    r += directions[curDir][0]\\n                    c += directions[curDir][1]\\n            \\n                curDir = (curDir + 1)%len(directions)\\n\\n            steps += 1\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605129,
                "title": "c-solution-with-explanation",
                "content": "# EXPLANATION\\nWe created 2-D vector **v** for our traversal.\\nStored the given coordinates in **i** and **j** respectively.\\nCreated a 2-D vector **ans** for our answer.\\n\\nLet\\'s see the idea:-\\nWe took bool\\na = for traversal left to right (if possible)\\nb = for traversal top to bottom (if possible)\\nc = for traversal right to left (if possible)\\nd = for traversal bottom to top (if possible)\\nThe idea is to keep track of 4 index to check if traversal is possible or not. The coordinates of 4-index are stored in vector **p**.\\nIn the first set of the conditions we we checked if the 4 point are going to lie in **v** or not.\\nInside big while loop\\nWe traversed in spiral form and on every inner loop, we checked if we are not out of vector and simultaneously added the coordinates in **ans**.\\nFinally returned the answer.\\nIT WILL BE BETTER IF THE CODE IS DRY RUN FOR JUST ONE SPIRAL MOVEMENT, FOR BETTER UNDERSTANDING.\\nIn this we need to check for condition of corner cases too.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> v(rows,vector<int>(cols,0));\\n        int i=rStart,j=cStart;\\n        vector<vector<int>> ans;\\n        bool a=true,b=true,c=true,d=true;\\n        vector<vector<int>> p={{i,j},{i,j+1},{i+1,j},{i,j-1}};\\n        if(p[1][1]>=cols)\\n            b=false;\\n        if(p[2][0]>=rows)\\n            c=false;\\n        else if(p[2][1]+1<cols)\\n            p[2][1]++;\\n        if(p[3][1]<0)\\n            d=false;\\n        else if(p[3][0]+1<rows)\\n            p[3][0]++;\\n        while(a || b || c || d){\\n            if(a){\\n                int x=p[0][0],y=p[0][1];\\n                while(y<cols && y!=p[1][1])\\n                    ans.push_back({x,y++});\\n                p[0][0]--;\\n                if(p[0][0]<0)\\n                    a=false;\\n                (p[0][1]-1<0)?:p[0][1]--;\\n            }\\n            if(b){\\n                int x=p[1][0],y=p[1][1];\\n                while(x<rows && x!=p[2][0])\\n                    ans.push_back({x++,y});\\n                p[1][1]++;\\n                if(p[1][1]>=cols)\\n                    b=false;\\n                (p[1][0]-1<0)?:p[1][0]--;\\n            }\\n            if(c){\\n                int x=p[2][0],y=p[2][1];\\n                while(y>=0 && y!=p[3][1])\\n                    ans.push_back({x,y--});\\n                p[2][0]++;\\n                if(p[2][0]>=rows)\\n                    c=false;\\n                (p[2][1]+1>=cols)?:p[2][1]++;\\n            }\\n            if(d){\\n                int x=p[3][0],y=p[3][1];\\n                while(x>=0 && x!=p[0][0])\\n                    ans.push_back({x--,y});\\n                p[3][1]--;\\n                if(p[3][1]<0)\\n                    d=false;\\n                (p[3][0]+1>=rows)?:p[3][0]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> v(rows,vector<int>(cols,0));\\n        int i=rStart,j=cStart;\\n        vector<vector<int>> ans;\\n        bool a=true,b=true,c=true,d=true;\\n        vector<vector<int>> p={{i,j},{i,j+1},{i+1,j},{i,j-1}};\\n        if(p[1][1]>=cols)\\n            b=false;\\n        if(p[2][0]>=rows)\\n            c=false;\\n        else if(p[2][1]+1<cols)\\n            p[2][1]++;\\n        if(p[3][1]<0)\\n            d=false;\\n        else if(p[3][0]+1<rows)\\n            p[3][0]++;\\n        while(a || b || c || d){\\n            if(a){\\n                int x=p[0][0],y=p[0][1];\\n                while(y<cols && y!=p[1][1])\\n                    ans.push_back({x,y++});\\n                p[0][0]--;\\n                if(p[0][0]<0)\\n                    a=false;\\n                (p[0][1]-1<0)?:p[0][1]--;\\n            }\\n            if(b){\\n                int x=p[1][0],y=p[1][1];\\n                while(x<rows && x!=p[2][0])\\n                    ans.push_back({x++,y});\\n                p[1][1]++;\\n                if(p[1][1]>=cols)\\n                    b=false;\\n                (p[1][0]-1<0)?:p[1][0]--;\\n            }\\n            if(c){\\n                int x=p[2][0],y=p[2][1];\\n                while(y>=0 && y!=p[3][1])\\n                    ans.push_back({x,y--});\\n                p[2][0]++;\\n                if(p[2][0]>=rows)\\n                    c=false;\\n                (p[2][1]+1>=cols)?:p[2][1]++;\\n            }\\n            if(d){\\n                int x=p[3][0],y=p[3][1];\\n                while(x>=0 && x!=p[0][0])\\n                    ans.push_back({x--,y});\\n                p[3][1]--;\\n                if(p[3][1]<0)\\n                    d=false;\\n                (p[3][0]+1>=rows)?:p[3][0]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602266,
                "title": "python-straightforward-and-logical",
                "content": "# Intuition\\n1. Notice that we must traverse the spiral walk regardless if we are inside or outside the grid boundaries.\\n2. We will need to continue spiral walking until visiting all cells.\\n3. The spiral walk follows a pattern:\\n4. Move forward `k` steps, turn right, move forward `k` steps, turn right, then increment `k += 1`. \\n5. Each time we move, we visit the cell by checking if we are within the boundaries, if so, then we append to output.\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        d = 0\\n        k = 1\\n        x, y = rStart, cStart\\n        output = []\\n        output.append([x, y])\\n        while len(output) < rows * cols:\\n            # move forward k steps\\n            dx, dy = moves[d]\\n            for _ in range(k):\\n                x += dx\\n                y += dy\\n                if 0 <= x < rows and 0 <= y < cols:\\n                    output.append([x, y])\\n            # turn right\\n            d = (d + 1) % 4\\n            # move forward k steps\\n            dx, dy = moves[d]\\n            for _ in range(k):\\n                x += dx\\n                y += dy\\n                if 0 <= x < rows and 0 <= y < cols:\\n                    output.append([x, y])\\n            # turn right\\n            d = (d + 1) % 4\\n            # increment k\\n            k += 1\\n        \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        d = 0\\n        k = 1\\n        x, y = rStart, cStart\\n        output = []\\n        output.append([x, y])\\n        while len(output) < rows * cols:\\n            # move forward k steps\\n            dx, dy = moves[d]\\n            for _ in range(k):\\n                x += dx\\n                y += dy\\n                if 0 <= x < rows and 0 <= y < cols:\\n                    output.append([x, y])\\n            # turn right\\n            d = (d + 1) % 4\\n            # move forward k steps\\n            dx, dy = moves[d]\\n            for _ in range(k):\\n                x += dx\\n                y += dy\\n                if 0 <= x < rows and 0 <= y < cols:\\n                    output.append([x, y])\\n            # turn right\\n            d = (d + 1) % 4\\n            # increment k\\n            k += 1\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590449,
                "title": "go-simple-solution",
                "content": "```\\nfunc spiralMatrixIII(rows int, cols int, rStart int, cStart int) [][]int {\\n\\n\\tres := make([][]int, 0, rows*cols)\\n\\tres = append(res, []int{rStart, cStart})\\n\\n\\tcount := 1\\n\\tlimit := 1\\n\\tdirections := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n\\tcol, row := cStart, rStart\\n\\tfor count != rows*cols {\\n\\t\\tfor k, d := range directions {\\n\\t\\t\\tfor c := 0; c < limit; c++ {\\n\\t\\t\\t\\trow += d[0]\\n\\t\\t\\t\\tcol += d[1]\\n\\t\\t\\t\\tif col < cols && row < rows && row >= 0 && col >= 0 {\\n\\t\\t\\t\\t\\tres = append(res, []int{row, col})\\n\\t\\t\\t\\t\\tcount++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif k == 1 || k == 3 {\\n\\t\\t\\t\\tlimit += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc spiralMatrixIII(rows int, cols int, rStart int, cStart int) [][]int {\\n\\n\\tres := make([][]int, 0, rows*cols)\\n\\tres = append(res, []int{rStart, cStart})\\n\\n\\tcount := 1\\n\\tlimit := 1\\n\\tdirections := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n\\tcol, row := cStart, rStart\\n\\tfor count != rows*cols {\\n\\t\\tfor k, d := range directions {\\n\\t\\t\\tfor c := 0; c < limit; c++ {\\n\\t\\t\\t\\trow += d[0]\\n\\t\\t\\t\\tcol += d[1]\\n\\t\\t\\t\\tif col < cols && row < rows && row >= 0 && col >= 0 {\\n\\t\\t\\t\\t\\tres = append(res, []int{row, col})\\n\\t\\t\\t\\t\\tcount++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif k == 1 || k == 3 {\\n\\t\\t\\t\\tlimit += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3562668,
                "title": "simple-rotating-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. create bound for start/end of row and column\\n2. rotate increasing our bounds by 1 each time\\n3. if an index is within our grid bounds add it to the result set\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nfunc spiralMatrixIII(rows int, cols int, rStart int, cStart int) [][]int {\\n    res := [][]int{}\\n\\n    rstart, rend := rStart, rStart + 1\\n    cstart, cend := cStart, cStart + 1\\n\\n    for len(res) < rows * cols {\\n        for i := cstart; i <= cend; i++ {\\n            res = add(res, rstart, i, rows, cols)\\n        }\\n\\n        cstart--\\n\\n        for i := rstart + 1; i <= rend; i++ {\\n            res = add(res, i, cend, rows, cols)\\n        }\\n\\n        rstart--\\n\\n        for i := cend - 1; i >= cstart; i-- {\\n            res = add(res, rend, i, rows, cols)\\n        }\\n\\n        cend++\\n\\n        for i := rend - 1; i > rstart; i-- {\\n            res = add(res, i, cstart, rows, cols)\\n        }\\n\\n        rend++\\n    }\\n\\n    return res\\n}\\n\\nfunc add(res [][]int, i int, j int, rows int, cols int) [][]int {\\n    if i < 0 || i > rows - 1 || j < 0 || j > cols - 1 {\\n        return res\\n    }\\n\\n    return append(res, []int{i, j})\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc spiralMatrixIII(rows int, cols int, rStart int, cStart int) [][]int {\\n    res := [][]int{}\\n\\n    rstart, rend := rStart, rStart + 1\\n    cstart, cend := cStart, cStart + 1\\n\\n    for len(res) < rows * cols {\\n        for i := cstart; i <= cend; i++ {\\n            res = add(res, rstart, i, rows, cols)\\n        }\\n\\n        cstart--\\n\\n        for i := rstart + 1; i <= rend; i++ {\\n            res = add(res, i, cend, rows, cols)\\n        }\\n\\n        rstart--\\n\\n        for i := cend - 1; i >= cstart; i-- {\\n            res = add(res, rend, i, rows, cols)\\n        }\\n\\n        cend++\\n\\n        for i := rend - 1; i > rstart; i-- {\\n            res = add(res, i, cstart, rows, cols)\\n        }\\n\\n        rend++\\n    }\\n\\n    return res\\n}\\n\\nfunc add(res [][]int, i int, j int, rows int, cols int) [][]int {\\n    if i < 0 || i > rows - 1 || j < 0 || j > cols - 1 {\\n        return res\\n    }\\n\\n    return append(res, []int{i, j})\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539627,
                "title": "swift-clean-solution-explained",
                "content": "# Approach\\n###### Simulate the walk, ignoring whether we stay in the grid or not, and record positions of the grid in the order we encounter them.\\n###### Keep track of the count of steps needed in current direction. When it becomes zero, turn clockwise and reset the counter, incrementing it every second time.\\n###### Take the unit vector $$(0, 1)$$ pointing to the right as the start move direction. When it\\'s time to turn, use the force of science to get a new heading. As the math says, the orthogonals to vector $$(A, B)$$ are vectors $$(-B, A)$$ and $$(B, -A)$$, the former is original turned $$90^0$$ counter-clockwise and the latter is $$(A, B)$$ turned $$90^0$$ clockwise, which is what we need.\\n\\n# Complexity\\n- Time complexity: $$O(max(R, C)^2)$$. Potentially, our walk needs to spiral until we move $$R$$ in one direction, and $$C$$ in another direction, so as to reach every cell of the grid.\\n- Space complexity: $$O(R*C)$$, the space used by the answer.\\n\\n# Code\\n```\\nclass Solution\\n{\\n    struct Coord\\n    {\\n        var i, j: Int\\n        init(_ i: Int, _ j: Int) { self.i = i; self.j = j }\\n        static func += (lhs: inout Coord, rhs: Coord) { lhs.i += rhs.i; lhs.j += rhs.j }\\n    }\\n    \\n    func spiralMatrixIII(_ rows: Int, _ cols: Int, _ rStart: Int, _ cStart: Int) -> [[Int]]\\n    {\\n        var coord = Coord(rStart, cStart), direction = Coord(0, 1)\\n        func isInGrid() -> Bool {\\n            coord.i >= 0 && coord.i < rows && coord.j >= 0 && coord.j < cols\\n        }\\n\\n        let cellCount = rows * cols\\n        var visited: [[Int]] = [], steps = 1, maxSteps = 2\\n        while true\\n        {\\n            if isInGrid() {\\n                visited.append([coord.i, coord.j])\\n                if visited.count == cellCount { break }\\n            }\\n\\n            if steps == 0\\n            {   // turn clockwise\\n                (direction.i, direction.j) = (direction.j, -direction.i)\\n                // calculate amount of steps in new direction\\n                maxSteps += 1\\n                steps = maxSteps / 2\\n            }\\n            // advance in the current direction\\n            coord += direction\\n            steps -= 1\\n        }\\n        return visited\\n    }\\n}\\n\\n```\\n### The same, using SIMD2 vector type just for kicks\\n```\\n    func spiralMatrixIII(_ rows: Int, _ cols: Int, _ rStart: Int, _ cStart: Int) -> [[Int]]\\n    {\\n        // coord.x is rows from top to down, coord.y is columns from left to right\\n        var coord = SIMD2(rStart, cStart), direction = SIMD2(0, 1)\\n\\n        let origin = SIMD2(0, 0), corner = SIMD2(rows - 1, cols - 1)\\n        let SIMD2True = SIMDMask<SIMD2<Int>>(repeating: true)\\n        func isInGrid() -> Bool { \\n            ((coord .>= origin) == SIMD2True) && ((coord .<= corner) == SIMD2True)\\n        }\\n\\n        let cellCount = rows * cols\\n        var visited: [[Int]] = [], steps = 1, maxSteps = 2\\n        while true\\n        {\\n            if isInGrid() {\\n                visited.append([coord.x, coord.y])\\n                if visited.count == cellCount { break }\\n            }\\n\\n            if steps == 0\\n            {   // turn clockwise\\n                (direction.x, direction.y) = (direction.y, -direction.x)\\n                // calculate amount of steps in new direction\\n                maxSteps += 1\\n                steps = maxSteps / 2\\n            }\\n            // advance in the current direction\\n            coord &+= direction\\n            steps -= 1            \\n        }\\n        return visited\\n    }\\n```",
                "solutionTags": [
                    "Swift",
                    "Math",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution\\n{\\n    struct Coord\\n    {\\n        var i, j: Int\\n        init(_ i: Int, _ j: Int) { self.i = i; self.j = j }\\n        static func += (lhs: inout Coord, rhs: Coord) { lhs.i += rhs.i; lhs.j += rhs.j }\\n    }\\n    \\n    func spiralMatrixIII(_ rows: Int, _ cols: Int, _ rStart: Int, _ cStart: Int) -> [[Int]]\\n    {\\n        var coord = Coord(rStart, cStart), direction = Coord(0, 1)\\n        func isInGrid() -> Bool {\\n            coord.i >= 0 && coord.i < rows && coord.j >= 0 && coord.j < cols\\n        }\\n\\n        let cellCount = rows * cols\\n        var visited: [[Int]] = [], steps = 1, maxSteps = 2\\n        while true\\n        {\\n            if isInGrid() {\\n                visited.append([coord.i, coord.j])\\n                if visited.count == cellCount { break }\\n            }\\n\\n            if steps == 0\\n            {   // turn clockwise\\n                (direction.i, direction.j) = (direction.j, -direction.i)\\n                // calculate amount of steps in new direction\\n                maxSteps += 1\\n                steps = maxSteps / 2\\n            }\\n            // advance in the current direction\\n            coord += direction\\n            steps -= 1\\n        }\\n        return visited\\n    }\\n}\\n\\n```\n```\\n    func spiralMatrixIII(_ rows: Int, _ cols: Int, _ rStart: Int, _ cStart: Int) -> [[Int]]\\n    {\\n        // coord.x is rows from top to down, coord.y is columns from left to right\\n        var coord = SIMD2(rStart, cStart), direction = SIMD2(0, 1)\\n\\n        let origin = SIMD2(0, 0), corner = SIMD2(rows - 1, cols - 1)\\n        let SIMD2True = SIMDMask<SIMD2<Int>>(repeating: true)\\n        func isInGrid() -> Bool { \\n            ((coord .>= origin) == SIMD2True) && ((coord .<= corner) == SIMD2True)\\n        }\\n\\n        let cellCount = rows * cols\\n        var visited: [[Int]] = [], steps = 1, maxSteps = 2\\n        while true\\n        {\\n            if isInGrid() {\\n                visited.append([coord.x, coord.y])\\n                if visited.count == cellCount { break }\\n            }\\n\\n            if steps == 0\\n            {   // turn clockwise\\n                (direction.x, direction.y) = (direction.y, -direction.x)\\n                // calculate amount of steps in new direction\\n                maxSteps += 1\\n                steps = maxSteps / 2\\n            }\\n            // advance in the current direction\\n            coord &+= direction\\n            steps -= 1            \\n        }\\n        return visited\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519800,
                "title": "simple-c-code-with-o-n-4",
                "content": "# Complexity\\n- Time complexity:\\nO(ror*row*col*col)\\n\\n- Space complexity:\\nWe have not used any extra space bu to return the answer we have used a space of O(row*col)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int n = rows*cols;\\n        int left=cStart, right=cStart+1, bottom=rStart+1,top=rStart;\\n        vector<vector<int>> ans;\\n        while(n){\\n            //right\\n            for(int i=left; i<=right; i++){\\n                if(i<=cols-1 && i>=0 && top>=0 && top<=rows-1){\\n                    ans.push_back({top, i});\\n                    n--;\\n                }\\n            }\\n            left--;\\n\\n            //bottom\\n            for(int i=top+1; i<=bottom; i++){\\n                if(right<=cols-1 && right>=0 && i>=0 && i<=rows-1){\\n                    ans.push_back({i, right});\\n                    n--;\\n                }\\n            }\\n            top--;\\n\\n            //left\\n            for(int i=right-1; i>=left; i--){\\n                if(i<=cols-1 && i>=0 && bottom>=0 && bottom<=rows-1){\\n                    ans.push_back({bottom, i});\\n                    n--;\\n                }\\n            }\\n            right++;\\n\\n            //top\\n            for(int i=bottom-1; i>top; i--){\\n                if(left<=cols-1 && left>=0 && i>=0 && i<=rows-1){\\n                    ans.push_back({i, left});\\n                    n--;\\n                }\\n            }\\n            bottom++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int n = rows*cols;\\n        int left=cStart, right=cStart+1, bottom=rStart+1,top=rStart;\\n        vector<vector<int>> ans;\\n        while(n){\\n            //right\\n            for(int i=left; i<=right; i++){\\n                if(i<=cols-1 && i>=0 && top>=0 && top<=rows-1){\\n                    ans.push_back({top, i});\\n                    n--;\\n                }\\n            }\\n            left--;\\n\\n            //bottom\\n            for(int i=top+1; i<=bottom; i++){\\n                if(right<=cols-1 && right>=0 && i>=0 && i<=rows-1){\\n                    ans.push_back({i, right});\\n                    n--;\\n                }\\n            }\\n            top--;\\n\\n            //left\\n            for(int i=right-1; i>=left; i--){\\n                if(i<=cols-1 && i>=0 && bottom>=0 && bottom<=rows-1){\\n                    ans.push_back({bottom, i});\\n                    n--;\\n                }\\n            }\\n            right++;\\n\\n            //top\\n            for(int i=bottom-1; i>top; i--){\\n                if(left<=cols-1 && left>=0 && i>=0 && i<=rows-1){\\n                    ans.push_back({i, left});\\n                    n--;\\n                }\\n            }\\n            bottom++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519783,
                "title": "simple-c-solution-with-o-n-4",
                "content": "# Complexity\\n- Time complexity: O(r * r * c * c)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(r*c)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int r, int c, int sr, int sc) {\\n        int n=r*c;\\n        vector<vector<int>>ans;\\n        int top=sr,right=sc+1;\\n        int bottom=sr+1,left=sc;\\n        while(n>0){\\n            for(int i=left;i<=right;++i){\\n                if(top>=0 && top<r && i>=0 && i<c){\\n                    ans.push_back({top,i});\\n                    n--;\\n                }\\n            }\\n            left--;\\n            for(int i=top+1;i<=bottom;++i){\\n                if(i>=0 && i<r && right>=0 && right<c){\\n                    ans.push_back({i,right});\\n                    n--;\\n                }\\n            }\\n            top--;\\n            for(int i=right-1;i>left;--i){\\n                if(bottom>=0 && bottom<r && i>=0 && i<c){\\n                    ans.push_back({bottom,i});\\n                    n--;\\n                }\\n            }\\n            right++;\\n            for(int i=bottom;i>top;--i){\\n                if(i>=0 && i<r && left>=0 && left<c){\\n                    ans.push_back({i,left});\\n                    n--;\\n                }\\n            }\\n            bottom++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int r, int c, int sr, int sc) {\\n        int n=r*c;\\n        vector<vector<int>>ans;\\n        int top=sr,right=sc+1;\\n        int bottom=sr+1,left=sc;\\n        while(n>0){\\n            for(int i=left;i<=right;++i){\\n                if(top>=0 && top<r && i>=0 && i<c){\\n                    ans.push_back({top,i});\\n                    n--;\\n                }\\n            }\\n            left--;\\n            for(int i=top+1;i<=bottom;++i){\\n                if(i>=0 && i<r && right>=0 && right<c){\\n                    ans.push_back({i,right});\\n                    n--;\\n                }\\n            }\\n            top--;\\n            for(int i=right-1;i>left;--i){\\n                if(bottom>=0 && bottom<r && i>=0 && i<c){\\n                    ans.push_back({bottom,i});\\n                    n--;\\n                }\\n            }\\n            right++;\\n            for(int i=bottom;i>top;--i){\\n                if(i>=0 && i<r && left>=0 && left<c){\\n                    ans.push_back({i,left});\\n                    n--;\\n                }\\n            }\\n            bottom++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516395,
                "title": "spiral-matrix-iii-very-easy-solution-in-c-intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int required_movements = rows * cols;\\n        int i = rStart, j = cStart;\\n        int steps = 0, steps_cpy = 0;\\n        ans.push_back({i, j});\\n        while(ans.size() < required_movements)\\n        {\\n            steps++;\\n            steps_cpy = steps;\\n            while(steps_cpy > 0)\\n            {\\n                if(steps % 2 != 0)\\n                {\\n                    j++;\\n                    if(i>=0 && i<rows && j>=0 && j<cols)\\n                    {\\n                        ans.push_back({i, j});\\n                    }\\n                    steps_cpy--;\\n                }\\n                else\\n                {\\n                    j--;\\n                    if(i>=0 && i<rows && j>=0 && j<cols)\\n                    {\\n                        ans.push_back({i, j});\\n                    }\\n                    steps_cpy--; \\n                }\\n            }\\n            if(ans.size() < required_movements)\\n            {\\n                steps_cpy = steps;\\n                while(steps_cpy > 0)\\n                {\\n                    if(steps % 2 != 0)\\n                    {\\n                        i++;\\n                        if(i>=0 && i<rows && j>=0 && j<cols)\\n                        {\\n                            ans.push_back({i, j});\\n                        }\\n                        steps_cpy--;\\n                    }\\n                    else\\n                    {\\n                        i--;\\n                        if(i>=0 && i<rows && j>=0 && j<cols)\\n                        {\\n                            ans.push_back({i, j});\\n                        }\\n                        steps_cpy--; \\n                    }\\n                }\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int required_movements = rows * cols;\\n        int i = rStart, j = cStart;\\n        int steps = 0, steps_cpy = 0;\\n        ans.push_back({i, j});\\n        while(ans.size() < required_movements)\\n        {\\n            steps++;\\n            steps_cpy = steps;\\n            while(steps_cpy > 0)\\n            {\\n                if(steps % 2 != 0)\\n                {\\n                    j++;\\n                    if(i>=0 && i<rows && j>=0 && j<cols)\\n                    {\\n                        ans.push_back({i, j});\\n                    }\\n                    steps_cpy--;\\n                }\\n                else\\n                {\\n                    j--;\\n                    if(i>=0 && i<rows && j>=0 && j<cols)\\n                    {\\n                        ans.push_back({i, j});\\n                    }\\n                    steps_cpy--; \\n                }\\n            }\\n            if(ans.size() < required_movements)\\n            {\\n                steps_cpy = steps;\\n                while(steps_cpy > 0)\\n                {\\n                    if(steps % 2 != 0)\\n                    {\\n                        i++;\\n                        if(i>=0 && i<rows && j>=0 && j<cols)\\n                        {\\n                            ans.push_back({i, j});\\n                        }\\n                        steps_cpy--;\\n                    }\\n                    else\\n                    {\\n                        i--;\\n                        if(i>=0 && i<rows && j>=0 && j<cols)\\n                        {\\n                            ans.push_back({i, j});\\n                        }\\n                        steps_cpy--; \\n                    }\\n                }\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512926,
                "title": "java-solution",
                "content": "# Time complexity:\\nO ( max ( rows, cols ) ^2 )\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len = rows*cols;\\n        int[][] ans = new int[len][2];\\n        int ai = 0;\\n        ans[ai][0] = rStart;\\n        ans[ai][1] = cStart++;\\n        ai++;\\n        int rEnd = rStart-1;\\n        int cEnd = cStart;\\n        while(ai<len){\\n            //go right\\n            for(int i=cStart; i<=cEnd && ai<len; i++){\\n                if(rStart<0 || i<0  || i>=cols) continue;\\n                ans[ai][0] = rStart;\\n                ans[ai][1] = i;\\n                ai++;\\n            }\\n            rStart++; //cuz starting row is covered now\\n            rEnd+=2;\\n\\n            //go down -> travel rows\\n            for(int i=rStart; i<=rEnd && ai<len; i++){\\n                if(i<0 || i>=rows || cEnd>=cols) continue;\\n                ans[ai][0] = i;\\n                ans[ai][1] = cEnd;\\n                ai++;\\n            }\\n            cEnd--; //cuz last column is finished now\\n            cStart-=2;\\n            \\n            //go left -> travel columns\\n            for(int i=cEnd; i>=cStart && ai<len; i--){\\n                if(rEnd>=rows || i<0 || i>=cols) continue;\\n                ans[ai][0] = rEnd;\\n                ans[ai][1] = i;\\n                ai++;\\n            }\\n            rEnd--; //cuz last row is now done\\n            rStart-=2;\\n            \\n            //go up -> travel rows\\n            for(int i=rEnd; i>=rStart && ai<len; i--){\\n                if(cStart<0 || i<0 || i>=rows) continue;\\n                ans[ai][0] = i;\\n                ans[ai][1] = cStart;\\n                ai++;\\n            }\\n            cStart++; //cuz starting col is now done\\n            cEnd+=2;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len = rows*cols;\\n        int[][] ans = new int[len][2];\\n        int ai = 0;\\n        ans[ai][0] = rStart;\\n        ans[ai][1] = cStart++;\\n        ai++;\\n        int rEnd = rStart-1;\\n        int cEnd = cStart;\\n        while(ai<len){\\n            //go right\\n            for(int i=cStart; i<=cEnd && ai<len; i++){\\n                if(rStart<0 || i<0  || i>=cols) continue;\\n                ans[ai][0] = rStart;\\n                ans[ai][1] = i;\\n                ai++;\\n            }\\n            rStart++; //cuz starting row is covered now\\n            rEnd+=2;\\n\\n            //go down -> travel rows\\n            for(int i=rStart; i<=rEnd && ai<len; i++){\\n                if(i<0 || i>=rows || cEnd>=cols) continue;\\n                ans[ai][0] = i;\\n                ans[ai][1] = cEnd;\\n                ai++;\\n            }\\n            cEnd--; //cuz last column is finished now\\n            cStart-=2;\\n            \\n            //go left -> travel columns\\n            for(int i=cEnd; i>=cStart && ai<len; i--){\\n                if(rEnd>=rows || i<0 || i>=cols) continue;\\n                ans[ai][0] = rEnd;\\n                ans[ai][1] = i;\\n                ai++;\\n            }\\n            rEnd--; //cuz last row is now done\\n            rStart-=2;\\n            \\n            //go up -> travel rows\\n            for(int i=rEnd; i>=rStart && ai<len; i--){\\n                if(cStart<0 || i<0 || i>=rows) continue;\\n                ans[ai][0] = i;\\n                ans[ai][1] = cStart;\\n                ai++;\\n            }\\n            cStart++; //cuz starting col is now done\\n            cEnd+=2;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509778,
                "title": "python-solution-based-spiral-matrix-1-2-and-4-easy-understanding",
                "content": "\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        matrix = [[-1 for i in range(cols)] for j in range(rows)]\\n        if rows==0:\\n            return []\\n        t=rStart\\n        ans=[]\\n        b=t+1\\n        l=cStart\\n        r=l+1\\n        d=0\\n        ct=1\\n        while ct<=rows*cols:\\n            if l<=0:\\n                l=0\\n            if t<=0:\\n                t=0\\n            if r>=cols-1:\\n                r=cols-1\\n            if b>=rows-1:\\n                b=rows-1\\n            if(d==0):\\n                for i in range(l,r+1):\\n                    if matrix[t][i]==-1:\\n                        ans.append([t,i])\\n                        matrix[t][i]=0\\n                        ct+=1\\n                d=1\\n                l-=1\\n            elif(d==1):\\n                for i in range(t,b+1):\\n                    if matrix[i][r]==-1:\\n                        matrix[i][r]=0\\n                        ans.append([i,r])\\n                        ct+=1\\n                d=2\\n                t-=1\\n            elif(d==2):\\n                for i in reversed(range(l,r+1)):\\n                    if matrix[b][i]==-1:\\n                        ans.append([b,i])\\n                        matrix[b][i]=0\\n                        ct+=1\\n                r+=1\\n                d=3\\n            elif(d==3):\\n                for i in reversed(range(t,b+1)):\\n                    if matrix[i][l]==-1:\\n                        ans.append([i,l])\\n                        matrix[i][l]=0\\n                        ct+=1\\n                b+=1\\n                d=0\\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        matrix = [[-1 for i in range(cols)] for j in range(rows)]\\n        if rows==0:\\n            return []\\n        t=rStart\\n        ans=[]\\n        b=t+1\\n        l=cStart\\n        r=l+1\\n        d=0\\n        ct=1\\n        while ct<=rows*cols:\\n            if l<=0:\\n                l=0\\n            if t<=0:\\n                t=0\\n            if r>=cols-1:\\n                r=cols-1\\n            if b>=rows-1:\\n                b=rows-1\\n            if(d==0):\\n                for i in range(l,r+1):\\n                    if matrix[t][i]==-1:\\n                        ans.append([t,i])\\n                        matrix[t][i]=0\\n                        ct+=1\\n                d=1\\n                l-=1\\n            elif(d==1):\\n                for i in range(t,b+1):\\n                    if matrix[i][r]==-1:\\n                        matrix[i][r]=0\\n                        ans.append([i,r])\\n                        ct+=1\\n                d=2\\n                t-=1\\n            elif(d==2):\\n                for i in reversed(range(l,r+1)):\\n                    if matrix[b][i]==-1:\\n                        ans.append([b,i])\\n                        matrix[b][i]=0\\n                        ct+=1\\n                r+=1\\n                d=3\\n            elif(d==3):\\n                for i in reversed(range(t,b+1)):\\n                    if matrix[i][l]==-1:\\n                        ans.append([i,l])\\n                        matrix[i][l]=0\\n                        ct+=1\\n                b+=1\\n                d=0\\n        return ans\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3509589,
                "title": "java-solution-with-approach",
                "content": "# Intuition\\nfor solving spiral matrix III you should be able to solve spiral matrix I and II \\ncheckout my solution link for spiral matrix I and II with the same approach I have solved spiral matrix III with little changes.\\n\\nspiral matrix I :-https://leetcode.com/problems/spiral-matrix/solutions/3506074/easy-beats-100-java-while-loop/?orderBy=most_votes\\n\\nspiral matrix II :-https://leetcode.com/problems/spiral-matrix-ii/solutions/3509420/easy-java-solution-with-explanation/?orderBy=most_votes\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n     int[] a1 = new int[rows*cols];\\n     int[] a2 = new int[rows*cols];\\n     int[][] arr = new int[rows*cols][2];\\n     int add=0;\\n     int i1=0;\\n     int index=0;\\n\\n\\n     while(add!=rows*cols){\\n     int c1=cStart+1; // in spiral matrix III loop conditions and \\n     int c2=cStart-1; //dependent on both i1 and these 4 variables\\n     int r1=rStart+1;\\n     int r2=rStart-1;\\n\\n\\n         int i=rStart-i1;\\n         int j=cStart-i1;\\n            if(i<rows&&i>=0&&j<cols&&j>=0){\\n                a1[index]=i;// add first element \\n                a2[index]=j;\\n                index++;\\n                add++;\\n            }    \\n         if(add==rows*cols){\\n             add(arr,a1,a2); // when this condition becomes true we \\n             return arr;     //got our answer \\n         }\\n         j++;\\n         c1=c1+i1;\\n\\n\\n         while(j<=c1){//first while loop going right\\n             if(i<rows&&i>=0&&j<cols&&j>=0){\\n            a1[index]=i;\\n            a2[index]=j;\\n            index++;\\n            add++;\\n             }\\n             if(add==rows*cols){ // check each time\\n             add(arr,a1,a2);     // you can write function for that\\n             return arr;\\n         }\\n             j++;\\n         }\\n         j--;\\n         i++;\\n         r1=r1+i1;\\n\\n\\n         while(i<=r1){//second while loop going down\\n             if(i<rows && i>=0 && j<cols && j>=0){\\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         i++;             \\n         }\\n         i--;\\n         j--;\\n         c2=c2-i1;\\n\\n\\n         while(j>=c2){//third while loop going left\\n             if(i<rows&&i>=0&&j<cols&&j>=0){ \\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         j--;            \\n         }  \\n         j++;\\n         i--;\\n         r2=r2-i1;\\n\\n\\n         while(i>r2){//fourth while  loop going up\\n             if(i<rows&&i>=0&&j<cols&&j>=0){\\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         i--;        \\n         }\\n\\n\\n         i1++;     // i1 variable which is deciding all conditions\\n            // of the loop and increasing by one in each iteration\\n\\n     }\\n     return arr;\\n    }\\n    public static void add(int[][] arr ,int[] a1,int[] a2){\\n        for(int i=0;i<a1.length;i++){\\n            arr[i][0]=a1[i];\\n            arr[i][1]=a2[i];\\n        }\\n    }\\n\\n    public static boolean \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n     int[] a1 = new int[rows*cols];\\n     int[] a2 = new int[rows*cols];\\n     int[][] arr = new int[rows*cols][2];\\n     int add=0;\\n     int i1=0;\\n     int index=0;\\n\\n\\n     while(add!=rows*cols){\\n     int c1=cStart+1; // in spiral matrix III loop conditions and \\n     int c2=cStart-1; //dependent on both i1 and these 4 variables\\n     int r1=rStart+1;\\n     int r2=rStart-1;\\n\\n\\n         int i=rStart-i1;\\n         int j=cStart-i1;\\n            if(i<rows&&i>=0&&j<cols&&j>=0){\\n                a1[index]=i;// add first element \\n                a2[index]=j;\\n                index++;\\n                add++;\\n            }    \\n         if(add==rows*cols){\\n             add(arr,a1,a2); // when this condition becomes true we \\n             return arr;     //got our answer \\n         }\\n         j++;\\n         c1=c1+i1;\\n\\n\\n         while(j<=c1){//first while loop going right\\n             if(i<rows&&i>=0&&j<cols&&j>=0){\\n            a1[index]=i;\\n            a2[index]=j;\\n            index++;\\n            add++;\\n             }\\n             if(add==rows*cols){ // check each time\\n             add(arr,a1,a2);     // you can write function for that\\n             return arr;\\n         }\\n             j++;\\n         }\\n         j--;\\n         i++;\\n         r1=r1+i1;\\n\\n\\n         while(i<=r1){//second while loop going down\\n             if(i<rows && i>=0 && j<cols && j>=0){\\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         i++;             \\n         }\\n         i--;\\n         j--;\\n         c2=c2-i1;\\n\\n\\n         while(j>=c2){//third while loop going left\\n             if(i<rows&&i>=0&&j<cols&&j>=0){ \\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         j--;            \\n         }  \\n         j++;\\n         i--;\\n         r2=r2-i1;\\n\\n\\n         while(i>r2){//fourth while  loop going up\\n             if(i<rows&&i>=0&&j<cols&&j>=0){\\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         i--;        \\n         }\\n\\n\\n         i1++;     // i1 variable which is deciding all conditions\\n            // of the loop and increasing by one in each iteration\\n\\n     }\\n     return arr;\\n    }\\n    public static void add(int[][] arr ,int[] a1,int[] a2){\\n        for(int i=0;i<a1.length;i++){\\n            arr[i][0]=a1[i];\\n            arr[i][1]=a2[i];\\n        }\\n    }\\n\\n    public static boolean \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509429,
                "title": "clean-and-explanined-one-past-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n) as it would just visit each of the item in the matrix for once.(I did vertify my thinking with Chat GPT)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) as constant of the space was used\\n\\n# Code\\n```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n  //as mention in the editorial, we walk in 1,1,2,2,3,3 ... \\n  //and so on pattern, so the step is used to count \\n  //the step before turning\\n  let step = 1;\\n\\n  let curStep = 0;\\n  let turnCount = 0;\\n  //turnCount is used to indicate which direction is moving, \\n  //if it is 0, it means moving right as direction[turnCount] = [0,1]\\n  let ans = [[rStart, cStart]];\\n\\n  let sr = rStart, sc = cStart;\\n\\n  const direction = [[0,1],[1,0],[0,-1],[-1,0]];\\n\\n  while(ans.length < rows * cols){\\n    curStep = step;\\n    while(curStep){\\n      const [dx, dy] = direction[turnCount];\\n      sr += dx;\\n      sc += dy;\\n      if(sr >=0 && sr < rows && sc >= 0 && sc < cols){\\n        ans.push([sr, sc]);\\n      }\\n      curStep--;\\n    }\\n    turnCount = (turnCount + 1) % direction.length;\\n\\n    //the number of step is increased when the direction is moving left or right,\\n    //which means direction[2] || direction[0] on the direction array    \\n    if(turnCount === 2 || turnCount === 0){\\n      step++;\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n  //as mention in the editorial, we walk in 1,1,2,2,3,3 ... \\n  //and so on pattern, so the step is used to count \\n  //the step before turning\\n  let step = 1;\\n\\n  let curStep = 0;\\n  let turnCount = 0;\\n  //turnCount is used to indicate which direction is moving, \\n  //if it is 0, it means moving right as direction[turnCount] = [0,1]\\n  let ans = [[rStart, cStart]];\\n\\n  let sr = rStart, sc = cStart;\\n\\n  const direction = [[0,1],[1,0],[0,-1],[-1,0]];\\n\\n  while(ans.length < rows * cols){\\n    curStep = step;\\n    while(curStep){\\n      const [dx, dy] = direction[turnCount];\\n      sr += dx;\\n      sc += dy;\\n      if(sr >=0 && sr < rows && sc >= 0 && sc < cols){\\n        ans.push([sr, sc]);\\n      }\\n      curStep--;\\n    }\\n    turnCount = (turnCount + 1) % direction.length;\\n\\n    //the number of step is increased when the direction is moving left or right,\\n    //which means direction[2] || direction[0] on the direction array    \\n    if(turnCount === 2 || turnCount === 0){\\n      step++;\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3509096,
                "title": "java-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe simple approach that comes to mind is traverse in spiral direction from the current position, if we are within matrix are we will add that to our ans otherwise ignore, this way we will cover all indexes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstart from current index and start traversing in spiral way,\\nComments are added in code for more clarity.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nif size of matrix is X then max we will iterate 4*X indexes.\\nO(4*X)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(X)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        //set the size of matrix -1 because we already visited one position\\n        int size = rows*cols-1;\\n        //shift is the number of steps in one direction, we can also say one side of rectangle\\n        int shift = 1;\\n        //when to increase shift, we will increase shift after completing two sides\\n        boolean increaseShift = false;\\n        //op stands for operation, operations means the direction of traversal\\n        int op = 1;\\n        //start and end point\\n        int x=rStart;\\n        int y=cStart;\\n        //array to store ans\\n        int[][] ans = new int[size+1][2];\\n        //index of ans array\\n        int idx=0;\\n        //count of steps in one particular direction\\n        int currentCount=0;\\n        //we add the current position\\n        ans[idx][0]=rStart;\\n        ans[idx][1]=cStart;\\n        idx++;\\n        while(size>0){\\n            if(op==1){\\n                y++;\\n            }else if(op==2){\\n                x++;\\n            }else if(op==3){\\n                y--;\\n            }else if(op==4){\\n                x--;\\n            }\\n            //increase the count in this direction\\n            currentCount++;\\n            //if position is within our range then add to ans\\n            if(inRange(rows,cols,x,y)){\\n                    ans[idx][0]=x;\\n                    ans[idx][1]=y;\\n                    idx++;\\n                    size--;\\n            }\\n            //if current count is equal to max steps then...\\n            if(currentCount==shift){\\n                currentCount=0; //reset\\n                op++;   //change direction\\n                op=op%4;\\n                if(op==0){\\n                    op=4;\\n                }\\n                if(!increaseShift){ //logic to increase shift\\n                    increaseShift=true;\\n                }else{\\n                    increaseShift=false;\\n                    shift++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean inRange(int rows, int cols, int x, int y){\\n        if(x<0 || x>=rows){\\n            return false;\\n        }\\n        if(y<0 || y>=cols){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        //set the size of matrix -1 because we already visited one position\\n        int size = rows*cols-1;\\n        //shift is the number of steps in one direction, we can also say one side of rectangle\\n        int shift = 1;\\n        //when to increase shift, we will increase shift after completing two sides\\n        boolean increaseShift = false;\\n        //op stands for operation, operations means the direction of traversal\\n        int op = 1;\\n        //start and end point\\n        int x=rStart;\\n        int y=cStart;\\n        //array to store ans\\n        int[][] ans = new int[size+1][2];\\n        //index of ans array\\n        int idx=0;\\n        //count of steps in one particular direction\\n        int currentCount=0;\\n        //we add the current position\\n        ans[idx][0]=rStart;\\n        ans[idx][1]=cStart;\\n        idx++;\\n        while(size>0){\\n            if(op==1){\\n                y++;\\n            }else if(op==2){\\n                x++;\\n            }else if(op==3){\\n                y--;\\n            }else if(op==4){\\n                x--;\\n            }\\n            //increase the count in this direction\\n            currentCount++;\\n            //if position is within our range then add to ans\\n            if(inRange(rows,cols,x,y)){\\n                    ans[idx][0]=x;\\n                    ans[idx][1]=y;\\n                    idx++;\\n                    size--;\\n            }\\n            //if current count is equal to max steps then...\\n            if(currentCount==shift){\\n                currentCount=0; //reset\\n                op++;   //change direction\\n                op=op%4;\\n                if(op==0){\\n                    op=4;\\n                }\\n                if(!increaseShift){ //logic to increase shift\\n                    increaseShift=true;\\n                }else{\\n                    increaseShift=false;\\n                    shift++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean inRange(int rows, int cols, int x, int y){\\n        if(x<0 || x>=rows){\\n            return false;\\n        }\\n        if(y<0 || y>=cols){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508974,
                "title": "50-long-typescript-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlet go = ([r, c]: number[], direction: \"u\" | \"d\" | \"l\" | \"r\") => {\\n    switch (direction) {\\n        case \"u\":\\n            return [r-1, c]\\n        case \"d\":\\n            return [r+1, c]\\n        case \"l\":\\n            return [r, c-1]\\n        case \"r\":\\n            return [r, c+1]\\n        default:\\n            return [r, c]\\n    }\\n}\\n\\nlet convertToOrgCoords = ([r,c]: number[], [expandedXLength, expandedYLength]: number[]) => {\\n    return [r-expandedYLength, c-expandedXLength]\\n}\\n\\nlet isOutOfBound = ([r,c]: number[], rows: number, cols: number):boolean => {\\n    if(r < 0 || r >= rows) return true;\\n    if(c < 0 || c >= cols) return true;\\n    return false;\\n}\\n\\n\\nlet getExpandedCoords = (rows: number, cols: number, rStart: number, cStart: number): number[][] => {\\n    let leftLength = cStart;\\n    let rightLength = cols-cStart-1;\\n    let maxXAxis = Math.max(leftLength, rightLength);\\n    let topLength = rStart;\\n    let bottomLength = rows-rStart-1;\\n    let maxYAxis = Math.max(topLength, bottomLength);\\n    let maxLength = Math.max(maxXAxis, maxYAxis);\\n    let expandedXLength = maxLength-cStart;\\n    let expandedYLength = maxLength-rStart;\\n    // console.log(maxLength, maxXAxis, maxYAxis)\\n    return [[maxLength, maxLength], [expandedXLength, expandedYLength]];\\n}\\n\\nfunction spiralMatrixIII(rows: number, cols: number, rStart: number, cStart: number): number[][] {\\n    let res: number[][] = []\\n    let l = Math.max(cStart, rStart)*2+1;\\n    let [startCoords, expandedLength] = getExpandedCoords(rows, cols, rStart, cStart);\\n    // console.log(expandedLength)\\n    res.push(convertToOrgCoords(startCoords, expandedLength));\\n    let step = 1;\\n    let direction: (\"u\" | \"d\" | \"l\" | \"r\")[] = [\"r\", \"d\", \"l\", \"u\"];\\n    let t = rows*cols;\\n    if(res.length === t) return res;\\n    // let z = 0\\n    let coords = startCoords;\\n    while(true) {\\n    // while(z<2) {\\n        // z++;\\n        for(let i=0; i<4; i++) {\\n            for(let j=0; j<step; j++) {\\n                coords = go(coords, direction[i])\\n                let orgCoords = convertToOrgCoords(coords, expandedLength)\\n                if(isOutOfBound(orgCoords, rows, cols)) continue;\\n                res.push(orgCoords);\\n                if(res.length === t) return res;\\n                // console.log(orgCoords, coords)\\n            }\\n            if(i === 1) step++;\\n        }\\n        step++;\\n        // console.log(res)\\n        // break;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nlet go = ([r, c]: number[], direction: \"u\" | \"d\" | \"l\" | \"r\") => {\\n    switch (direction) {\\n        case \"u\":\\n            return [r-1, c]\\n        case \"d\":\\n            return [r+1, c]\\n        case \"l\":\\n            return [r, c-1]\\n        case \"r\":\\n            return [r, c+1]\\n        default:\\n            return [r, c]\\n    }\\n}\\n\\nlet convertToOrgCoords = ([r,c]: number[], [expandedXLength, expandedYLength]: number[]) => {\\n    return [r-expandedYLength, c-expandedXLength]\\n}\\n\\nlet isOutOfBound = ([r,c]: number[], rows: number, cols: number):boolean => {\\n    if(r < 0 || r >= rows) return true;\\n    if(c < 0 || c >= cols) return true;\\n    return false;\\n}\\n\\n\\nlet getExpandedCoords = (rows: number, cols: number, rStart: number, cStart: number): number[][] => {\\n    let leftLength = cStart;\\n    let rightLength = cols-cStart-1;\\n    let maxXAxis = Math.max(leftLength, rightLength);\\n    let topLength = rStart;\\n    let bottomLength = rows-rStart-1;\\n    let maxYAxis = Math.max(topLength, bottomLength);\\n    let maxLength = Math.max(maxXAxis, maxYAxis);\\n    let expandedXLength = maxLength-cStart;\\n    let expandedYLength = maxLength-rStart;\\n    // console.log(maxLength, maxXAxis, maxYAxis)\\n    return [[maxLength, maxLength], [expandedXLength, expandedYLength]];\\n}\\n\\nfunction spiralMatrixIII(rows: number, cols: number, rStart: number, cStart: number): number[][] {\\n    let res: number[][] = []\\n    let l = Math.max(cStart, rStart)*2+1;\\n    let [startCoords, expandedLength] = getExpandedCoords(rows, cols, rStart, cStart);\\n    // console.log(expandedLength)\\n    res.push(convertToOrgCoords(startCoords, expandedLength));\\n    let step = 1;\\n    let direction: (\"u\" | \"d\" | \"l\" | \"r\")[] = [\"r\", \"d\", \"l\", \"u\"];\\n    let t = rows*cols;\\n    if(res.length === t) return res;\\n    // let z = 0\\n    let coords = startCoords;\\n    while(true) {\\n    // while(z<2) {\\n        // z++;\\n        for(let i=0; i<4; i++) {\\n            for(let j=0; j<step; j++) {\\n                coords = go(coords, direction[i])\\n                let orgCoords = convertToOrgCoords(coords, expandedLength)\\n                if(isOutOfBound(orgCoords, rows, cols)) continue;\\n                res.push(orgCoords);\\n                if(res.length === t) return res;\\n                // console.log(orgCoords, coords)\\n            }\\n            if(i === 1) step++;\\n        }\\n        step++;\\n        // console.log(res)\\n        // break;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3508609,
                "title": "spiral-walking-using-point-direction-datatypes",
                "content": "# Approach\\nUses Direction and Point datatypes. Walk in a spiral by keeping track of `step_count` and `step_length`. When changing direction from Up or Down, the `step_length` increases by `1`. \\n\\nOnly push to the `output` array if the input is within the bounds.\\n\\nTerminate when the number of steps walked in a single direction is larger than `n`.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn spiral_matrix_iii(rows: i32, cols: i32, r_start: i32, c_start: i32) -> Vec<Vec<i32>> {\\n        let n = i32::max(r_start + rows, c_start + cols) * 2;\\n\\n        let mut output: Vec<Vec<i32>> = vec![];\\n        let mut position = Point {\\n            x: c_start,\\n            y: r_start,\\n        };\\n        let mut direction = Direction::Right;\\n        let (mut step_length, mut step_count) = (1, 0);\\n\\n        loop {\\n            if position.x >= 0 && position.x < cols && position.y >= 0 && position.y < rows {\\n                output.push(vec![position.y, position.x]);\\n            }\\n            position = position.next_point(&direction);\\n            step_count += 1;\\n\\n            if step_count >= step_length {\\n                step_count = 0;\\n                if direction == Direction::Down || direction == Direction::Up {\\n                    step_length += 1;\\n                }\\n                direction = direction.next();\\n            }\\n            if step_count > n {\\n                break;\\n            }\\n        }\\n\\n        output\\n    }\\n}\\n\\n#[derive(PartialEq, Eq)]\\nenum Direction {\\n    Right,\\n    Down,\\n    Left,\\n    Up,\\n}\\n\\nimpl Direction {\\n    pub fn next(&self) -> Direction {\\n        match self {\\n            Direction::Right => Direction::Down,\\n            Direction::Down => Direction::Left,\\n            Direction::Left => Direction::Up,\\n            Direction::Up => Direction::Right,\\n        }\\n    }\\n}\\n\\nstruct Point {\\n    x: i32,\\n    y: i32,\\n}\\n\\nimpl Point {\\n    pub fn next_point(&self, direction: &Direction) -> Point {\\n        match direction {\\n            Direction::Right => Point {\\n                x: self.x + 1,\\n                y: self.y,\\n            },\\n            Direction::Down => Point {\\n                x: self.x,\\n                y: self.y + 1,\\n            },\\n            Direction::Left => Point {\\n                x: self.x - 1,\\n                y: self.y,\\n            },\\n            Direction::Up => Point {\\n                x: self.x,\\n                y: self.y - 1,\\n            },\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn spiral_matrix_iii(rows: i32, cols: i32, r_start: i32, c_start: i32) -> Vec<Vec<i32>> {\\n        let n = i32::max(r_start + rows, c_start + cols) * 2;\\n\\n        let mut output: Vec<Vec<i32>> = vec![];\\n        let mut position = Point {\\n            x: c_start,\\n            y: r_start,\\n        };\\n        let mut direction = Direction::Right;\\n        let (mut step_length, mut step_count) = (1, 0);\\n\\n        loop {\\n            if position.x >= 0 && position.x < cols && position.y >= 0 && position.y < rows {\\n                output.push(vec![position.y, position.x]);\\n            }\\n            position = position.next_point(&direction);\\n            step_count += 1;\\n\\n            if step_count >= step_length {\\n                step_count = 0;\\n                if direction == Direction::Down || direction == Direction::Up {\\n                    step_length += 1;\\n                }\\n                direction = direction.next();\\n            }\\n            if step_count > n {\\n                break;\\n            }\\n        }\\n\\n        output\\n    }\\n}\\n\\n#[derive(PartialEq, Eq)]\\nenum Direction {\\n    Right,\\n    Down,\\n    Left,\\n    Up,\\n}\\n\\nimpl Direction {\\n    pub fn next(&self) -> Direction {\\n        match self {\\n            Direction::Right => Direction::Down,\\n            Direction::Down => Direction::Left,\\n            Direction::Left => Direction::Up,\\n            Direction::Up => Direction::Right,\\n        }\\n    }\\n}\\n\\nstruct Point {\\n    x: i32,\\n    y: i32,\\n}\\n\\nimpl Point {\\n    pub fn next_point(&self, direction: &Direction) -> Point {\\n        match direction {\\n            Direction::Right => Point {\\n                x: self.x + 1,\\n                y: self.y,\\n            },\\n            Direction::Down => Point {\\n                x: self.x,\\n                y: self.y + 1,\\n            },\\n            Direction::Left => Point {\\n                x: self.x - 1,\\n                y: self.y,\\n            },\\n            Direction::Up => Point {\\n                x: self.x,\\n                y: self.y - 1,\\n            },\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3506810,
                "title": "easy-brute-force-with-explaination",
                "content": "# Intuition\\nIf we observer the path:\\n\\nmove right 1 step, turn right\\nmove down 1 step, turn right\\nmove left 2 steps, turn right\\nmove top 2 steps, turn right,\\nmove right 3 steps, turn right\\nmove down 3 steps, turn right\\nmove left 4 steps, turn right\\nmove top 4 steps, turn right,\\n\\nwe can find the sequence of steps: 1,1,2,2,3,3,4,4,5,5....\\n\\nThus, the length variable keeps changing after 2 steps, i.e, 1,1 then 2,2 then 3,3 and so on.\\n\\n# Code\\n```\\nclass Solution {\\n    int index;\\n    int[][] ans;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ans[index][0] = r;\\n        ans[index][1] = c;\\n        index++;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ans= new int[R * C][2];\\n        while (index < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int index;\\n    int[][] ans;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ans[index][0] = r;\\n        ans[index][1] = c;\\n        index++;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ans= new int[R * C][2];\\n        while (index < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504838,
                "title": "javascript-easy-understanding-solution",
                "content": "# Intuition\\nUse 4 while loop to move from top left to top right, top right to bottom right, bottom right to bottom left and bottom left to top left. We will travel each edge in 1 while loop and then extend the bound until it reach the border.\\n\\n# Code\\n```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n    let res = [];\\n    let leftCol = cStart, rightCol = cStart;\\n    let topRow = rStart, bottomRow = rStart;\\n    let i = rStart, j = cStart;\\n    let visit = {};\\n    while (1) {\\n        rightCol = rightCol + 1 === cols ? rightCol : rightCol + 1;\\n        while (j <= rightCol){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            j++;\\n        }\\n        j--;\\n        if (res.length === rows * cols) break;\\n        bottomRow = bottomRow + 1 === rows ? bottomRow : bottomRow + 1;\\n        while (i <= bottomRow){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            i++;\\n        }\\n        i--;\\n        if (res.length === rows * cols) break;\\n        leftCol = leftCol === 0 ? 0 : leftCol - 1;\\n        while (j >= leftCol){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            j--;\\n        }\\n        j++;\\n        if (res.length === rows * cols) break;\\n        topRow = topRow === 0 ? 0 : topRow - 1;\\n        while (i >= topRow){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            i--;\\n        }\\n        i++;\\n        if (res.length === rows * cols) break;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n    let res = [];\\n    let leftCol = cStart, rightCol = cStart;\\n    let topRow = rStart, bottomRow = rStart;\\n    let i = rStart, j = cStart;\\n    let visit = {};\\n    while (1) {\\n        rightCol = rightCol + 1 === cols ? rightCol : rightCol + 1;\\n        while (j <= rightCol){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            j++;\\n        }\\n        j--;\\n        if (res.length === rows * cols) break;\\n        bottomRow = bottomRow + 1 === rows ? bottomRow : bottomRow + 1;\\n        while (i <= bottomRow){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            i++;\\n        }\\n        i--;\\n        if (res.length === rows * cols) break;\\n        leftCol = leftCol === 0 ? 0 : leftCol - 1;\\n        while (j >= leftCol){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            j--;\\n        }\\n        j++;\\n        if (res.length === rows * cols) break;\\n        topRow = topRow === 0 ? 0 : topRow - 1;\\n        while (i >= topRow){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            i--;\\n        }\\n        i++;\\n        if (res.length === rows * cols) break;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3503916,
                "title": "c-112233-sequence-observation-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObservation of Sequence 11223344......\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Variables: i -> Row, j -> col, k -> sequence number**\\n1) put (r, c) in ans.\\n2) then observe that every time we take \"k\" number of row\\'s OR col\\'s elements either in right or left side(For Row) OR top or down side(For Col). \\n3) Upper codition manages to generate the spiral.\\n4) We take those indices only which are in the grid, For that we applied codition(ok(i, j)).\\n7) If size of \"ans\" becomes (n*m) means we took elements of grid then we break(Here, \"done\" Do that which is nothing but #define....).\\n8) Try to do Dry Run by yourself for \"k\" values upto 4 it will be more clear.\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N * M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define done {if(ans.size() == n * m) break;}\\n    \\n    int N, M;\\n    bool ok(int i, int j)\\n    {\\n        return (i >= 0 && j >= 0 && i < N && j < M);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int n, int m, int r, int c) {\\n        N = n, M = m;\\n        vector<vector<int>> ans;\\n        int i = r, j = c + 1, k = 1;\\n        ans.push_back({r, c});\\n        while(1)\\n        {\\n            done;\\n\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                j++;\\n            }\\n            j--;\\n\\n            done;\\n\\n            i++;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                i++;\\n            }\\n            i--;\\n            \\n            done;\\n            k++;\\n\\n            j--;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                j--;\\n            }\\n            j++;\\n            \\n            done;\\n\\n            i--;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                i--;\\n            }\\n            i++;\\n\\n            done;\\n            k++;\\n\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define done {if(ans.size() == n * m) break;}\\n    \\n    int N, M;\\n    bool ok(int i, int j)\\n    {\\n        return (i >= 0 && j >= 0 && i < N && j < M);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int n, int m, int r, int c) {\\n        N = n, M = m;\\n        vector<vector<int>> ans;\\n        int i = r, j = c + 1, k = 1;\\n        ans.push_back({r, c});\\n        while(1)\\n        {\\n            done;\\n\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                j++;\\n            }\\n            j--;\\n\\n            done;\\n\\n            i++;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                i++;\\n            }\\n            i--;\\n            \\n            done;\\n            k++;\\n\\n            j--;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                j--;\\n            }\\n            j++;\\n            \\n            done;\\n\\n            i--;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                i--;\\n            }\\n            i++;\\n\\n            done;\\n            k++;\\n\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503860,
                "title": "c-simple-and-understandable-solution-two-pointers",
                "content": "# Intuition\\nFirst of all, set the left and right pointer as cStart and up and down pointer as rStart.And initialize num as 0 to keep track of element we have visited.\\nThen do the following in the different blocks:\\n//Upper Block (dir=0)\\n    Traverse it from left to right keeping **\"up\"** pointer as constant and after it increment the **\"right\"** pointer by 1. \\n//Right Block (dir=1)\\n    Traverse it from up to down keeping **\"right\"** pointer as constant and after it increment the **\"down\"** pointer by 1. \\n//Lower Block (dir=2)\\n    Traverse it from right to left keeping **\"down\"** pointer as constant and after it decrement the **\"left\"** pointer by 1. \\n//Left Block (dir=3)\\n    Traverse it from down to up keeping **\"left\"** pointer as constant and after it decrement the **\"up\"** pointer by 1.\\n**Note :-** Before traversing any block, check whether it(left,right,up,down) lies in the matrix or not. \\n# Approach\\nTwo pointers.\\n\\n# Complexity\\n- Time complexity:\\n    O(rows*cols)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result(rows*cols,vector<int>(2,0));\\n        int left=cStart,right=cStart,up=rStart,down=rStart;\\n        int dir=0,num=0;\\n        while (num < rows*cols){\\n            //upper block\\n            if (dir==0){\\n                if (up>=0){\\n                    for (int i=max(left,0);i<=min(right,cols-1);i++){\\n                        result[num][0]=up;\\n                        result[num][1]=i;\\n                        num++;\\n                    }\\n                }\\n                right++;\\n            }\\n            //right block\\n            if (dir==1){\\n                if (right<cols){\\n                    for (int i=max(up,0);i<=min(down,rows-1);i++){\\n                        result[num][0]=i;\\n                        result[num][1]=right;\\n                        num++;\\n                    }\\n                }\\n                down++;\\n            }\\n            //lower block\\n            if (dir==2){\\n                if (down < rows){\\n                    for (int i=min(right,cols-1);i>=max(left,0);i--){\\n                        result[num][0]=down;\\n                        result[num][1]=i;\\n                        num++;\\n                    }\\n                }\\n                left--;\\n            }\\n            //left block\\n            if (dir==3){\\n                if (left>=0){\\n                    for (int i=min(down,rows-1);i>=max(up,0);i--){\\n                        result[num][0]=i;\\n                        result[num][1]=left;\\n                        num++;\\n                    }\\n                }\\n                up--;\\n            }\\n            dir++;\\n            if (dir==4)\\n                dir=0;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result(rows*cols,vector<int>(2,0));\\n        int left=cStart,right=cStart,up=rStart,down=rStart;\\n        int dir=0,num=0;\\n        while (num < rows*cols){\\n            //upper block\\n            if (dir==0){\\n                if (up>=0){\\n                    for (int i=max(left,0);i<=min(right,cols-1);i++){\\n                        result[num][0]=up;\\n                        result[num][1]=i;\\n                        num++;\\n                    }\\n                }\\n                right++;\\n            }\\n            //right block\\n            if (dir==1){\\n                if (right<cols){\\n                    for (int i=max(up,0);i<=min(down,rows-1);i++){\\n                        result[num][0]=i;\\n                        result[num][1]=right;\\n                        num++;\\n                    }\\n                }\\n                down++;\\n            }\\n            //lower block\\n            if (dir==2){\\n                if (down < rows){\\n                    for (int i=min(right,cols-1);i>=max(left,0);i--){\\n                        result[num][0]=down;\\n                        result[num][1]=i;\\n                        num++;\\n                    }\\n                }\\n                left--;\\n            }\\n            //left block\\n            if (dir==3){\\n                if (left>=0){\\n                    for (int i=min(down,rows-1);i>=max(up,0);i--){\\n                        result[num][0]=i;\\n                        result[num][1]=left;\\n                        num++;\\n                    }\\n                }\\n                up--;\\n            }\\n            dir++;\\n            if (dir==4)\\n                dir=0;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476884,
                "title": "c-simply-traverse-as-directed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFollow path as directed.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhile following spiral path, if row and col falls on matrix, add to answer vector.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int r = rStart, c = cStart;\\n        int step = 1, dir = 1;\\n        ans.push_back({r,c});\\n        while (ans.size() < rows*cols) {\\n            for (int i = 0; i < step; i++) {\\n                c += dir;\\n                if (r >= 0 and r < rows and c >= 0 and c < cols)\\n                    ans.push_back({r,c});\\n            }\\n            for (int i = 0; i < step; i++) {\\n                r += dir;\\n                if (r >= 0 and r < rows and c >= 0 and c < cols)\\n                    ans.push_back({r,c});\\n            }\\n            dir *= -1;\\n            step++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int r = rStart, c = cStart;\\n        int step = 1, dir = 1;\\n        ans.push_back({r,c});\\n        while (ans.size() < rows*cols) {\\n            for (int i = 0; i < step; i++) {\\n                c += dir;\\n                if (r >= 0 and r < rows and c >= 0 and c < cols)\\n                    ans.push_back({r,c});\\n            }\\n            for (int i = 0; i < step; i++) {\\n                r += dir;\\n                if (r >= 0 and r < rows and c >= 0 and c < cols)\\n                    ans.push_back({r,c});\\n            }\\n            dir *= -1;\\n            step++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456668,
                "title": "java-easy-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n       int[][] ans= new int[rows*cols][2];\\n       int rmax=rStart+1, cmax=cStart+1, j=0;\\n        while(j<ans.length){\\n            for(int i=cStart; i<cmax; i++){\\n                if(j>=ans.length || i>=cols || rStart<0){rStart=0; break;}\\n                ans[j][0]=rStart;\\n                ans[j][1]=i;\\n                j++;\\n            }\\n            cStart--;\\n            for(int i=rStart; i<rmax; i++){\\n                if(j>=ans.length || i>=rows || cmax>=cols){cmax=cols-1; break;}\\n                ans[j][0]=i;\\n                ans[j][1]=cmax;\\n                j++;\\n            }\\n            rStart--;\\n            for(int i=cmax; i>cStart; i--){\\n                if(j>=ans.length || i<0  || rmax>=rows){rmax=rows-1; break;}\\n                ans[j][0]=rmax;\\n                ans[j][1]=i;\\n                j++;\\n            }\\n            cmax++;\\n            for(int i=rmax; i>rStart; i--){\\n                if(j>=ans.length || i<0 || cStart<0){cStart=0; break;}\\n                ans[j][0]=i;\\n                ans[j][1]=cStart;\\n                j++;\\n            }\\n            rmax++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n       int[][] ans= new int[rows*cols][2];\\n       int rmax=rStart+1, cmax=cStart+1, j=0;\\n        while(j<ans.length){\\n            for(int i=cStart; i<cmax; i++){\\n                if(j>=ans.length || i>=cols || rStart<0){rStart=0; break;}\\n                ans[j][0]=rStart;\\n                ans[j][1]=i;\\n                j++;\\n            }\\n            cStart--;\\n            for(int i=rStart; i<rmax; i++){\\n                if(j>=ans.length || i>=rows || cmax>=cols){cmax=cols-1; break;}\\n                ans[j][0]=i;\\n                ans[j][1]=cmax;\\n                j++;\\n            }\\n            rStart--;\\n            for(int i=cmax; i>cStart; i--){\\n                if(j>=ans.length || i<0  || rmax>=rows){rmax=rows-1; break;}\\n                ans[j][0]=rmax;\\n                ans[j][1]=i;\\n                j++;\\n            }\\n            cmax++;\\n            for(int i=rmax; i>rStart; i--){\\n                if(j>=ans.length || i<0 || cStart<0){cStart=0; break;}\\n                ans[j][0]=i;\\n                ans[j][1]=cStart;\\n                j++;\\n            }\\n            rmax++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454323,
                "title": "1-1-2-2-3-3-steps-firstly-right-down-n-then-left-up-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(int m, int n, int i, int j)\\n    {\\n        if(i>=0 and i<m and j>=0 and j<n) return true;\\n        return false;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int rStart, int cStart) {\\n        vector<vector<int>>mat;\\n        int cnt = 1;\\n        int movement = 1;\\n        int i = rStart, j = cStart;\\n        bool rd = true;\\n        while(cnt <= m*n)\\n        {\\n            int curr = 0;\\n            if(rd)\\n            {\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    j++;\\n                    curr++;\\n                }\\n                curr = 0;\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    i++;\\n                    curr++;\\n                }\\n                rd = false;\\n                movement++;\\n            }\\n            else\\n            {\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    j--;\\n                    curr++;\\n                }\\n                curr = 0;\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    i--;\\n                    curr++;\\n                }\\n                rd = true;\\n                movement++;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int m, int n, int i, int j)\\n    {\\n        if(i>=0 and i<m and j>=0 and j<n) return true;\\n        return false;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int rStart, int cStart) {\\n        vector<vector<int>>mat;\\n        int cnt = 1;\\n        int movement = 1;\\n        int i = rStart, j = cStart;\\n        bool rd = true;\\n        while(cnt <= m*n)\\n        {\\n            int curr = 0;\\n            if(rd)\\n            {\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    j++;\\n                    curr++;\\n                }\\n                curr = 0;\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    i++;\\n                    curr++;\\n                }\\n                rd = false;\\n                movement++;\\n            }\\n            else\\n            {\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    j--;\\n                    curr++;\\n                }\\n                curr = 0;\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    i--;\\n                    curr++;\\n                }\\n                rd = true;\\n                movement++;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447270,
                "title": "easy-clean-java-solution-directions",
                "content": "If we look at the spiral, the noOfElements written in different direction looks like 1, 1, 2, 2, 3, 3 ...\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\n        int totalElement = rows * cols;\\n\\n        // Result Matrix having rows equal to the totalElements\\n        int[][] resMatrix = new int[totalElement][2];\\n\\n        int i = rStart, j = cStart;\\n        int count = 1;\\n\\n        // trackes the noOfElements to be written in a particular direction\\n        int length = 1;\\n\\n        // this loop will run until all the elements are written\\n        while(count <= totalElement) {\\n\\n            // Looping through each direction and writing the length noOfElements in that direction\\n            for(Direction dir : Direction.values()) {\\n                for(int rep = 0; rep < length; rep++) {\\n                    if(i < rows && j < cols && i >=0 && j >= 0) {\\n                        resMatrix[count - 1][0] = i;\\n                        resMatrix[count - 1][1] = j;\\n                        count++;\\n                    }\\n                    i = i + dir.rMove;\\n                    j = j + dir.cMove;\\n                }\\n\\n                // the length will change after every two direction\\n                if(dir.ordinal() % 2 != 0) {\\n                    length++;\\n                }\\n            }\\n        }\\n        return resMatrix;\\n    }\\n\\n    enum Direction {\\n        RIGHT(0,1), DOWN(1,0), LEFT(0,-1), UP(-1,0);\\n\\n        // rMove, cMove: value to be added to the indexes to move to the next positon in a given direction\\n        final int rMove;\\n        final int cMove;\\n\\n        Direction(int rMove, int cMove) {\\n            this.rMove = rMove;\\n            this.cMove = cMove;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\n        int totalElement = rows * cols;\\n\\n        // Result Matrix having rows equal to the totalElements\\n        int[][] resMatrix = new int[totalElement][2];\\n\\n        int i = rStart, j = cStart;\\n        int count = 1;\\n\\n        // trackes the noOfElements to be written in a particular direction\\n        int length = 1;\\n\\n        // this loop will run until all the elements are written\\n        while(count <= totalElement) {\\n\\n            // Looping through each direction and writing the length noOfElements in that direction\\n            for(Direction dir : Direction.values()) {\\n                for(int rep = 0; rep < length; rep++) {\\n                    if(i < rows && j < cols && i >=0 && j >= 0) {\\n                        resMatrix[count - 1][0] = i;\\n                        resMatrix[count - 1][1] = j;\\n                        count++;\\n                    }\\n                    i = i + dir.rMove;\\n                    j = j + dir.cMove;\\n                }\\n\\n                // the length will change after every two direction\\n                if(dir.ordinal() % 2 != 0) {\\n                    length++;\\n                }\\n            }\\n        }\\n        return resMatrix;\\n    }\\n\\n    enum Direction {\\n        RIGHT(0,1), DOWN(1,0), LEFT(0,-1), UP(-1,0);\\n\\n        // rMove, cMove: value to be added to the indexes to move to the next positon in a given direction\\n        final int rMove;\\n        final int cMove;\\n\\n        Direction(int rMove, int cMove) {\\n            this.rMove = rMove;\\n            this.cMove = cMove;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438808,
                "title": "simpe-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int arr[][] = new int[rows*cols][2];\\n        int row=rStart, col=cStart;\\n        int rowLast = row, collast = col;\\n        int c=0;\\n        while(c<rows*cols)\\n        {\\n            collast++;\\n            if(row>=0)\\n            {\\n                for(int i=col; i<collast; i++)\\n                    if(i>=0 && i<cols)\\n                    {\\n                        arr[c][0]=row;\\n                        arr[c++][1]=i;\\n                    }\\n            }\\n            rowLast++;\\n            if(collast<cols)\\n            {\\n                for(int i=row; i<rowLast; i++)\\n                    if(i>=0 && i<rows)\\n                    {\\n                        arr[c][0]=i;\\n                        arr[c++][1]=collast;\\n                    }\\n            }\\n            col--;\\n            if(rowLast<rows)\\n            {\\n                for(int i=collast; i>col; i--)\\n                    if(i>=0 && i<cols)\\n                    {\\n                        arr[c][0]=rowLast;\\n                        arr[c++][1]=i;\\n                    }\\n            }\\n            row--;\\n            if(col>=0)\\n            {\\n                for(int i=rowLast; i>row; i--)\\n                {\\n                    if(i>=0 && i<rows && c<rows*cols)\\n                    {\\n                        arr[c][0]=i;\\n                        arr[c++][1]=col;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int arr[][] = new int[rows*cols][2];\\n        int row=rStart, col=cStart;\\n        int rowLast = row, collast = col;\\n        int c=0;\\n        while(c<rows*cols)\\n        {\\n            collast++;\\n            if(row>=0)\\n            {\\n                for(int i=col; i<collast; i++)\\n                    if(i>=0 && i<cols)\\n                    {\\n                        arr[c][0]=row;\\n                        arr[c++][1]=i;\\n                    }\\n            }\\n            rowLast++;\\n            if(collast<cols)\\n            {\\n                for(int i=row; i<rowLast; i++)\\n                    if(i>=0 && i<rows)\\n                    {\\n                        arr[c][0]=i;\\n                        arr[c++][1]=collast;\\n                    }\\n            }\\n            col--;\\n            if(rowLast<rows)\\n            {\\n                for(int i=collast; i>col; i--)\\n                    if(i>=0 && i<cols)\\n                    {\\n                        arr[c][0]=rowLast;\\n                        arr[c++][1]=i;\\n                    }\\n            }\\n            row--;\\n            if(col>=0)\\n            {\\n                for(int i=rowLast; i>row; i--)\\n                {\\n                    if(i>=0 && i<rows && c<rows*cols)\\n                    {\\n                        arr[c][0]=i;\\n                        arr[c++][1]=col;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421247,
                "title": "java-soln-simulation",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] spiralMatrix = new int[rows * cols][2];\\n        \\n        int count = 1;\\n        int x = rStart;\\n        int y = cStart;\\n        int offset = Math.max(cStart, cols - cStart);\\n        int rightLimit = cStart + 2, downLimit = rStart + 2, leftLimit = cStart - 1, upLimit = rStart - 1;\\n        while(count <= rows * cols) {\\n            // right\\n            while(y < rightLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(y <= rightLimit - 1) y++;\\n            }\\n            y--;\\n            \\n            // down\\n            x++;\\n            while(x < downLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(x <= downLimit - 1) x++;\\n            }\\n            x--;\\n            \\n            // left\\n            y--;\\n            while(y >= leftLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(y >= leftLimit) y--;\\n            }\\n            y++;\\n            \\n            // up\\n            x--;\\n            while(x >= upLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(x >= upLimit) x--;\\n            }\\n            x++;\\n            \\n            y++;\\n            upLimit--;\\n            rightLimit++;\\n            downLimit++;\\n            leftLimit--;\\n        }\\n        \\n        return spiralMatrix;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] spiralMatrix = new int[rows * cols][2];\\n        \\n        int count = 1;\\n        int x = rStart;\\n        int y = cStart;\\n        int offset = Math.max(cStart, cols - cStart);\\n        int rightLimit = cStart + 2, downLimit = rStart + 2, leftLimit = cStart - 1, upLimit = rStart - 1;\\n        while(count <= rows * cols) {\\n            // right\\n            while(y < rightLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(y <= rightLimit - 1) y++;\\n            }\\n            y--;\\n            \\n            // down\\n            x++;\\n            while(x < downLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(x <= downLimit - 1) x++;\\n            }\\n            x--;\\n            \\n            // left\\n            y--;\\n            while(y >= leftLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(y >= leftLimit) y--;\\n            }\\n            y++;\\n            \\n            // up\\n            x--;\\n            while(x >= upLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(x >= upLimit) x--;\\n            }\\n            x++;\\n            \\n            y++;\\n            upLimit--;\\n            rightLimit++;\\n            downLimit++;\\n            leftLimit--;\\n        }\\n        \\n        return spiralMatrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391541,
                "title": "imperative-approach-python3",
                "content": "# Code\\n```\\n\\n        UP, RIGHT, DOWN, LEFT = 0, 1, 2, 3\\n        \\n        def switch(d):\\n            return {\\n                UP:    RIGHT,\\n                RIGHT:  DOWN,\\n                DOWN:   LEFT,\\n                LEFT:     UP\\n            }[d]\\n            \\n        def move(i, j, d):\\n            return {\\n                UP:     (i - 1,     j),\\n                RIGHT:  (    i, j + 1),\\n                DOWN:   (i + 1,     j),\\n                LEFT:   (    i, j - 1)\\n            }[d]\\n\\n        def valid(i, j, m, n):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        res       = [(i, j)]\\n        d         = RIGHT\\n        num_movs  = 1\\n        it        = 0\\n\\n        while len(res) < rows * cols:\\n            for _ in range(num_movs):\\n                i, j = move(i, j, d)\\n                if valid(i, j, rows, cols):\\n                    res.append((i, j))\\n\\n            num_movs  += it & 1          # Increment every two iterations\\n            d          = switch(d)\\n            it        += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\n        UP, RIGHT, DOWN, LEFT = 0, 1, 2, 3\\n        \\n        def switch(d):\\n            return {\\n                UP:    RIGHT,\\n                RIGHT:  DOWN,\\n                DOWN:   LEFT,\\n                LEFT:     UP\\n            }[d]\\n            \\n        def move(i, j, d):\\n            return {\\n                UP:     (i - 1,     j),\\n                RIGHT:  (    i, j + 1),\\n                DOWN:   (i + 1,     j),\\n                LEFT:   (    i, j - 1)\\n            }[d]\\n\\n        def valid(i, j, m, n):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        res       = [(i, j)]\\n        d         = RIGHT\\n        num_movs  = 1\\n        it        = 0\\n\\n        while len(res) < rows * cols:\\n            for _ in range(num_movs):\\n                i, j = move(i, j, d)\\n                if valid(i, j, rows, cols):\\n                    res.append((i, j))\\n\\n            num_movs  += it & 1          # Increment every two iterations\\n            d          = switch(d)\\n            it        += 1\\n\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3356529,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) \\n    {\\n        vector<vector<int>>ans;\\n        int r=rStart;\\n        int c=cStart;\\n        int cnt=0;\\n        int steps=2;\\n        bool even=1;\\n        cnt++;\\n        ans.push_back({rStart,cStart});\\n        while(cnt<rows*cols)\\n        {\\n             if (even)\\n             {\\n                for (int i=0;i<steps-1;i++)\\n                {\\n                    c++;\\n                    if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        \\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                }\\n                for (int i=0;i<steps-1;i++)\\n                {\\n                    r++;\\n                     if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                }\\n             }\\n             else{\\n                 for (int i=0;i<steps-1;i++)\\n                 {\\n                     c--;\\n                      if ( r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                 }\\n                 for (int i=0;i<steps-1;i++)\\n                 {\\n                    r--;\\n                     if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                 }\\n             }\\n             steps++;\\n             even=1-even;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) \\n    {\\n        vector<vector<int>>ans;\\n        int r=rStart;\\n        int c=cStart;\\n        int cnt=0;\\n        int steps=2;\\n        bool even=1;\\n        cnt++;\\n        ans.push_back({rStart,cStart});\\n        while(cnt<rows*cols)\\n        {\\n             if (even)\\n             {\\n                for (int i=0;i<steps-1;i++)\\n                {\\n                    c++;\\n                    if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        \\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                }\\n                for (int i=0;i<steps-1;i++)\\n                {\\n                    r++;\\n                     if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                }\\n             }\\n             else{\\n                 for (int i=0;i<steps-1;i++)\\n                 {\\n                     c--;\\n                      if ( r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                 }\\n                 for (int i=0;i<steps-1;i++)\\n                 {\\n                    r--;\\n                     if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                 }\\n             }\\n             steps++;\\n             even=1-even;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356397,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool liesInside(int r, int c, int rows, int cols)\\n    {\\n        return (r>=0 && r<rows && c>=0 && c<cols);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) \\n    {\\n        int cnt=1;\\n        vector<vector<int>> ans;\\n        vector<int> v={rStart,cStart};\\n        ans.push_back(v);\\n        int count=0, d=0, steps=1;\\n        int r=rStart, c=cStart;\\n        while(cnt!=(rows*cols))\\n        {\\n            for(int x=1; x<=steps; x++)\\n            {\\n                if(d==0)\\n                {\\n                    c++;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    }\\n                }\\n                else if(d==1)\\n                {\\n                    r++;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    }\\n                }\\n                else if(d==2)\\n                {\\n                    c--;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    } \\n                }\\n                else\\n                {\\n                    r--;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    } \\n                }\\n            }\\n            count++;\\n            d=(d+1)%4;\\n            if(count%2==0) steps++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool liesInside(int r, int c, int rows, int cols)\\n    {\\n        return (r>=0 && r<rows && c>=0 && c<cols);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) \\n    {\\n        int cnt=1;\\n        vector<vector<int>> ans;\\n        vector<int> v={rStart,cStart};\\n        ans.push_back(v);\\n        int count=0, d=0, steps=1;\\n        int r=rStart, c=cStart;\\n        while(cnt!=(rows*cols))\\n        {\\n            for(int x=1; x<=steps; x++)\\n            {\\n                if(d==0)\\n                {\\n                    c++;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    }\\n                }\\n                else if(d==1)\\n                {\\n                    r++;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    }\\n                }\\n                else if(d==2)\\n                {\\n                    c--;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    } \\n                }\\n                else\\n                {\\n                    r--;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    } \\n                }\\n            }\\n            count++;\\n            d=(d+1)%4;\\n            if(count%2==0) steps++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351492,
                "title": "simple-java-solution-using-while-loop-and-if-conditions",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        char ch=\\'s\\';\\n        int r=0;\\n        int[][] ans=new int[rows*cols][2];\\n        ans[r][0]=rStart;\\n        ans[r][1]=cStart;r++;\\n        cStart++;\\n        int times=0;\\n        int i=1;\\n        while(i<(rows*cols)){\\n           if(ch==\\'s\\'){\\n               times=times+1;\\n               ch=\\'r\\';\\n           }\\n            else if(ch==\\'r\\'){\\n                int temp=times;\\n                while(temp>0){\\n                    if(rStart>=0 && rStart<rows&&cStart>=0&&cStart<cols){\\n                        ans[r][0]=rStart;\\n                        ans[r][1]=cStart;\\n                    \\n                    r++;i++;\\n                    }\\n                    cStart++;\\n                    temp--;\\n                }\\n                ch=\\'d\\';\\n                rStart++;\\n                cStart--;\\n            }\\n            else if(ch==\\'d\\'){\\n                int temp=times;\\n                while(temp>0){\\n                    if(rStart>=0 && rStart<rows&&cStart>=0&&cStart<cols){\\n                    ans[r][0]=rStart;\\n                    ans[r][1]=cStart;\\n                    \\n                   r++;i++;}\\n                    rStart++;\\n                     temp--;\\n                }\\n                ch=\\'l\\';\\n                times=times+1;\\n                rStart--;\\n                cStart--;\\n            }\\n            else if(ch==\\'l\\'){\\n                int temp=times;\\n                while(temp>0){\\n                    if(rStart>=0 && rStart<rows&&cStart>=0&&cStart<cols){\\n                    ans[r][0]=rStart;\\n                    ans[r][1]=cStart;\\n                    \\n                    r++;i++;\\n                }\\n                    cStart--;\\n                    temp--;\\n                }\\n                ch=\\'u\\';\\n                cStart++;\\n                rStart--;\\n            }\\n            else{\\n                int temp=times;\\n                while(temp>0){\\n                    if(rStart>=0 && rStart<rows&&cStart>=0&&cStart<cols){\\n                    ans[r][0]=rStart;\\n                    ans[r][1]=cStart;\\n                    r++;i++;\\n                }\\n                    rStart--;\\n                temp--;\\n                }\\n                ch=\\'r\\';\\n                times=times+1;\\n                rStart++;\\n                cStart++;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        char ch=\\'s\\';\\n        int r=0;\\n        int[][] ans=new int[rows*cols][2];\\n        ans[r][0]=rStart;\\n        ans[r][1]=cStart;r++;\\n        cStart++;\\n        int times=0;\\n        int i=1;\\n        while(i<(rows*cols)){\\n           if(ch==\\'s\\'){\\n               times=times+1;\\n               ch=\\'r\\';\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3344671,
                "title": "crazy-code-will-blow-off-you-mind-c",
                "content": "# Intuition\\n<Moving in spiral and filling the value in v[t++] if ro and co lie in boundary>\\n\\n# Approach\\n<moving in a spiral ,.. with the help .of direction(d) and displacement(a)>\\n\\n# Complexity\\n- Time complexity:\\n<$$O(n^m)$$>\\n\\n- Space complexity:\\n<$$O(n*m)$$>\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> spiralMatrixIII(int row, int col, int ro, int co) {\\n    int n=row*col;\\n    vector<vector<int>>v(n);\\n    int a=1;\\n    int t=0;\\n    int d=1;\\n    int c;\\n    while(t<n){\\n        c=a;\\n        while(c--){ // moving right \\n            if(-1<ro && ro<row && -1<co && co<col){v[t++]={ro,co};}\\n            co+=d;\\n        }\\n        c=a;\\n        while(c--){  /// moving downward\\n            if(-1<ro && ro<row && -1<co && co<col){v[t++]={ro,co};}\\n            ro+=d;\\n        }\\n        d*=(-1); /// and we will change the direction \\n        a++; /// we will increase the distane we will now cover ..\\n    }\\n    return v;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>> spiralMatrixIII(int row, int col, int ro, int co) {\\n    int n=row*col;\\n    vector<vector<int>>v(n);\\n    int a=1;\\n    int t=0;\\n    int d=1;\\n    int c;\\n    while(t<n){\\n        c=a;\\n        while(c--){ // moving right \\n            if(-1<ro && ro<row && -1<co && co<col){v[t++]={ro,co};}\\n            co+=d;\\n        }\\n        c=a;\\n        while(c--){  /// moving downward\\n            if(-1<ro && ro<row && -1<co && co<col){v[t++]={ro,co};}\\n            ro+=d;\\n        }\\n        d*=(-1); /// and we will change the direction \\n        a++; /// we will increase the distane we will now cover ..\\n    }\\n    return v;\\n}\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565679,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1899832,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1804177,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1782042,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1965068,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2037855,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1970393,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1888980,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2052023,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2020544,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1565679,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1899832,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1804177,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1782042,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1965068,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2037855,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1970393,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1888980,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2052023,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2020544,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            }
        ]
    }
]