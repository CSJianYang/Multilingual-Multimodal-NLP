[
    {
        "title": "Count the Number of Fair Pairs",
        "question_content": "Given a 0-indexed integer array nums of size n and two integers lower and upper, return the number of fair pairs.\nA pair (i, j) is fair if:\n\n\t0 <= i < j < n, and\n\tlower <= nums[i] + nums[j] <= upper\n\n&nbsp;\nExample 1:\n\nInput: nums = [0,1,7,4,4,5], lower = 3, upper = 6\nOutput: 6\nExplanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5).\n\nExample 2:\n\nInput: nums = [1,7,9,2,5], lower = 11, upper = 11\nOutput: 1\nExplanation: There is a single fair pair: (2,3).\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\tnums.length == n\n\t-109&nbsp;<= nums[i] <= 109\n\t-109&nbsp;<= lower <= upper <= 109",
        "solutions": [
            {
                "id": 3174181,
                "title": "two-pointers-2",
                "content": "Because `nums[i] + nums[j] == nums[j] + nums[i]` the `i < j` condition degrades to `i != j`.\\n\\nSo, we can sort the array, and use the two-pointer approach to count pairs less than a certain value.\\n\\nWe do it twice for `uppper` and `lower`, and return the difference.\\n\\nTime complexity: O(sort)\\n\\n**C++**\\n```cpp\\nlong long countLess(vector<int>& nums, int val) {\\n    long long res = 0;\\n    for (int i = 0, j = nums.size() - 1; i < j; ++i) {\\n        while(i < j && nums[i] + nums[j] > val)\\n            --j;\\n        res += j - i;\\n    }        \\n    return res;\\n}\\nlong long countFairPairs(vector<int>& nums, int lower, int upper) {\\n    sort(begin(nums), end(nums));\\n    return countLess(nums, upper) - countLess(nums, lower - 1);\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        def countLess(val: int) -> int:\\n            res, j = 0, len(nums) - 1\\n            for i in range(len(nums)):\\n                while i < j and nums[i] + nums[j] > val:\\n                    j -= 1\\n                res += max(0, j - i)\\n            return res\\n        nums.sort()\\n        return countLess(upper) - countLess(lower - 1)\\n```\\n**Java**\\n```java\\nlong countLess(int[] nums, int val) {\\n    long res = 0;\\n    for (int i = 0, j = nums.length - 1; i < j; ++i) {\\n        while(i < j && nums[i] + nums[j] > val)\\n            --j;\\n        res += j - i;\\n    }        \\n    return res;        \\n}\\npublic long countFairPairs(int[] nums, int lower, int upper) {\\n    Arrays.sort(nums);\\n    return countLess(nums, upper) - countLess(nums, lower - 1);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\nlong long countLess(vector<int>& nums, int val) {\\n    long long res = 0;\\n    for (int i = 0, j = nums.size() - 1; i < j; ++i) {\\n        while(i < j && nums[i] + nums[j] > val)\\n            --j;\\n        res += j - i;\\n    }        \\n    return res;\\n}\\nlong long countFairPairs(vector<int>& nums, int lower, int upper) {\\n    sort(begin(nums), end(nums));\\n    return countLess(nums, upper) - countLess(nums, lower - 1);\\n}\\n```\n```python\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        def countLess(val: int) -> int:\\n            res, j = 0, len(nums) - 1\\n            for i in range(len(nums)):\\n                while i < j and nums[i] + nums[j] > val:\\n                    j -= 1\\n                res += max(0, j - i)\\n            return res\\n        nums.sort()\\n        return countLess(upper) - countLess(lower - 1)\\n```\n```java\\nlong countLess(int[] nums, int val) {\\n    long res = 0;\\n    for (int i = 0, j = nums.length - 1; i < j; ++i) {\\n        while(i < j && nums[i] + nums[j] > val)\\n            --j;\\n        res += j - i;\\n    }        \\n    return res;        \\n}\\npublic long countFairPairs(int[] nums, int lower, int upper) {\\n    Arrays.sort(nums);\\n    return countLess(nums, upper) - countLess(nums, lower - 1);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174030,
                "title": "c-python3-sorting-lower-and-upper",
                "content": "# Please Upvote \\uD83D\\uDE07\\n# C++\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& v, int first_val, int last_val) {\\n        deque<int>vc;\\n        sort(v.begin(),v.end());\\n        for(auto i:v) vc.push_back(i);\\n        long long int ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            vc.pop_front();\\n            int lower=first_val-v[i],upper=last_val-v[i];\\n            auto left=lower_bound(vc.begin(),vc.end(),lower);\\n            auto right=upper_bound(vc.begin(),vc.end(),upper);\\n            ans+=(right-left);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Python3\\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        ans=0\\n        for i in range(len(nums)-1, -1, -1):\\n            v = nums[i]\\n            a = bisect_left(nums, lower - v, lo=0, hi=i)\\n            b = bisect_right(nums, upper - v, lo=0, hi=i)\\n            ans += b - a\\n        return ans \\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& v, int first_val, int last_val) {\\n        deque<int>vc;\\n        sort(v.begin(),v.end());\\n        for(auto i:v) vc.push_back(i);\\n        long long int ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            vc.pop_front();\\n            int lower=first_val-v[i],upper=last_val-v[i];\\n            auto left=lower_bound(vc.begin(),vc.end(),lower);\\n            auto right=upper_bound(vc.begin(),vc.end(),upper);\\n            ans+=(right-left);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        ans=0\\n        for i in range(len(nums)-1, -1, -1):\\n            v = nums[i]\\n            a = bisect_left(nums, lower - v, lo=0, hi=i)\\n            b = bisect_right(nums, upper - v, lo=0, hi=i)\\n            ans += b - a\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174301,
                "title": "java-detailed-intiution-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFeels like binary search because we need to figure out lower bound upper bound something, So for every nums[i], find out range as if, we can add nums[i] into the range and the sum will be between [lower, upper]. So simply for every nums[i], find (lower - nums[i]) and (upper - nums[i]). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1\\n- Sort the Array\\n\\n- why? ignore i < j, the reason is we care of x + y should lies between the rangem here index does not plays any role\\n\\nStep 2 :  \\n- For every element repeat Step 3, 4 and 5.\\n\\nStep 3 : \\n - Find the point uptil we can add nums[i] and get sum >= lower, say j\\n\\nStep 4 : \\n - Find the point uptil we can add nums[i] and get sum <= upper, say k\\n\\nStep 5 \\n- We can get answer from the k - j;\\n\\n\\n---\\n\\n\\n**Example**\\n \\narr = [1,2,3,4,6,5] \\nfor, nums[i] = 1;\\n\\n - lower - 4,     upper - 10\\n\\n- lowerTarget -> 4 - 1 = 3,    upperTarget -> 10 - 1 = 9\\n\\n- Sorted array -> 1 2 3 4 5 6\\n\\n- values of j and k => 1 2 3 4 5 6 \\n-------------------------j---------k\\n\\n**in this case -> k (5) - j (1) = 4**\\n\\nwhich means there will be 4 elements who can pair up with 1 satisfying the conditions i.e., 3 4 5 6 \\n\\nSo for every element in nums find the range and add to the answer.\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO (N * log(N))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO (1)\\n# Code\\n\\n**PLEASE UPVOTE IF IT HELPED : - ))**\\n\\n```\\npublic long countFairPairs(int[] nums, int lower, int upper) {\\n        long count = 0;\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i ++) {\\n            int num = nums[i];\\n            int lT = lower - num; // lower Target\\n            int uT = upper - num; // upper Target\\n            // k - j thing explained above\\n            count += (lowerUpperBound(nums, uT, i + 1, nums.length - 1, true) - \\n            lowerUpperBound(nums, lT, i + 1, nums.length - 1, false));\\n        }   \\n        return count;\\n    }\\n    public long lowerUpperBound(int [] arr, int target, int l, int r, boolean isUpper) {\\n        while(l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if(!isUpper) {  // BS lower bound\\n                if (arr[mid] < target) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid - 1;\\n                }\\n            } \\n\\n            else { // BS upper bound\\n                if (arr[mid] <= target) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid - 1;\\n                }\\n            }\\n        }\\n\\n        long ans = isUpper ? r : l - 1;\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long countFairPairs(int[] nums, int lower, int upper) {\\n        long count = 0;\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i ++) {\\n            int num = nums[i];\\n            int lT = lower - num; // lower Target\\n            int uT = upper - num; // upper Target\\n            // k - j thing explained above\\n            count += (lowerUpperBound(nums, uT, i + 1, nums.length - 1, true) - \\n            lowerUpperBound(nums, lT, i + 1, nums.length - 1, false));\\n        }   \\n        return count;\\n    }\\n    public long lowerUpperBound(int [] arr, int target, int l, int r, boolean isUpper) {\\n        while(l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if(!isUpper) {  // BS lower bound\\n                if (arr[mid] < target) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid - 1;\\n                }\\n            } \\n\\n            else { // BS upper bound\\n                if (arr[mid] <= target) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid - 1;\\n                }\\n            }\\n        }\\n\\n        long ans = isUpper ? r : l - 1;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3174615,
                "title": "very-simple-easy-to-understand-solution",
                "content": "# Approach\\nWe can fix the first number ( say x) then the second number must be in between [lower - x , upper - x].\\nTo get above result, we need to sort the array and then find the upper bound of (upper - nums[i]) and lower bound of (lower - nums[i]).\\nDifference of the upper bound index and lower bound index will give us the number elements that can be added to nums[i] whose sum will be in between lower & upper.\\n\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans = 0;\\n        auto beg = nums.begin(), end = nums.end();\\n        sort(beg, end);\\n        for(int i = 0; i < nums.size()-1; ++i){\\n            ans += upper_bound(beg + i+1, end, upper - nums[i]) - lower_bound(beg + i+1, end, lower - nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans = 0;\\n        auto beg = nums.begin(), end = nums.end();\\n        sort(beg, end);\\n        for(int i = 0; i < nums.size()-1; ++i){\\n            ans += upper_bound(beg + i+1, end, upper - nums[i]) - lower_bound(beg + i+1, end, lower - nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174134,
                "title": "sorting-binary-search-bound-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nclassic lower bound and upper bound problem \\n\\nequation can be written as\\n$$lower-nums[i]<=nums[j]<=upper-nums[i]$$\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n1) sort the array , the condition `0 <= i < j < n` is redundant.(observe carefully)\\n2) now if i am at `nums[i]`\\nto find how many elements that we can add to nums[i] such that they are in range $$[lower-nums[i],upper-nums[i]]$$\\n->since the array is sorted and we have to find these numbers from index (i+1,n) we can find the range of the number for particualr element `nums[i]`.\\n-> to find the **low index** range simply use upper_bound `(low)`\\n-> to find the **high index** range simply use upper_bound `(high)`\\n3) add  `high-low` in your answer\\n\\n# Complexity\\n- Time complexity: `O(nlogn)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) \\n    {\\n        sort(begin(nums),end(nums));\\n        long long ans = 0,n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int low=lower_bound(begin(nums) + i + 1,end(nums),lower - nums[i]) - begin(nums);\\n            int high=upper_bound(begin(nums) + i + 1,end(nums),upper - nums[i]) - begin(nums);\\n            ans += 1LL*(high - low);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) \\n    {\\n        sort(begin(nums),end(nums));\\n        long long ans = 0,n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int low=lower_bound(begin(nums) + i + 1,end(nums),lower - nums[i]) - begin(nums);\\n            int high=upper_bound(begin(nums) + i + 1,end(nums),upper - nums[i]) - begin(nums);\\n            ans += 1LL*(high - low);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174164,
                "title": "best-solution-in-c-binarysearch",
                "content": "# Complexity\\n```\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n```\\n\\n##### Connect with me  on LinkedIn : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195\\n# Code\\n## **Please Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        int n=nums.size();\\n        long ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-1;i++){\\n            int x=lower-nums[i],y=upper-nums[i];\\n            auto it=lower_bound(nums.begin()+i+1,nums.end(),x);\\n            auto gt=upper_bound(nums.begin()+i+1,nums.end(),y);\\n            ans+=gt-it;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n## **For Any Doubts u can freely ask me in the comments section**\\uD83D\\uDE0A\\n![98b7adbc-5abf-45f7-9b5b-538574194654_1676344687.6513524.png](https://assets.leetcode.com/users/images/bbf35347-7587-4211-99ee-01c89f0b758c_1689164666.789704.png)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n```\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        int n=nums.size();\\n        long ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-1;i++){\\n            int x=lower-nums[i],y=upper-nums[i];\\n            auto it=lower_bound(nums.begin()+i+1,nums.end(),x);\\n            auto gt=upper_bound(nums.begin()+i+1,nums.end(),y);\\n            ans+=gt-it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174022,
                "title": "java-binary-search-solution",
                "content": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long result = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            result = result + binarySearch1(nums, nums[i], i, lower, upper) - binarySearch2(nums, nums[i], i, lower, upper);\\n        }\\n        return result;\\n    }\\n    public long binarySearch1(int[] nums, int currentValue, int index, int lower, int upper) {\\n        int start = index + 1;\\n        int end = nums.length;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] > (upper - currentValue)) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n     public long binarySearch2(int[] nums, int currentValue, int index, int lower, int upper) {\\n        int start = index + 1;\\n        int end = nums.length;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < (lower - currentValue)) {\\n                start = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long result = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            result = result + binarySearch1(nums, nums[i], i, lower, upper) - binarySearch2(nums, nums[i], i, lower, upper);\\n        }\\n        return result;\\n    }\\n    public long binarySearch1(int[] nums, int currentValue, int index, int lower, int upper) {\\n        int start = index + 1;\\n        int end = nums.length;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] > (upper - currentValue)) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n     public long binarySearch2(int[] nums, int currentValue, int index, int lower, int upper) {\\n        int start = index + 1;\\n        int end = nums.length;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < (lower - currentValue)) {\\n                start = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174463,
                "title": "sorting-binarysearch-super-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& v, int lower, int upper) {\\n        long long ans =0;\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n           auto a = lower_bound(v.begin()+i+1, v.end(), lower-v[i]) - v.begin();\\n           auto b = upper_bound(v.begin()+i+1, v.end(), upper-v[i]) - v.begin();\\n           ans += (b-a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& v, int lower, int upper) {\\n        long long ans =0;\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n           auto a = lower_bound(v.begin()+i+1, v.end(), lower-v[i]) - v.begin();\\n           auto b = upper_bound(v.begin()+i+1, v.end(), upper-v[i]) - v.begin();\\n           ans += (b-a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174418,
                "title": "why-sorting-does-not-affect-order-intuition-and-thoughtprocess-explained-sorting-binary-search",
                "content": "# Idea of Why this way?\\n- Why to go with sorting and binsearch? we will see next\\n- **Does sorting Affect ordering? Yah, but here its NOT.** \\n- See they said 0<= i < j <= N\\n- Say after SORTING, u affected the order and now j < i.\\n- No issues at all, just assume j as i and i as j, so that j<i => i<j.\\n- So basically the **breakdown of the Condition is i!=j**.\\n- ***Why SORT?***\\n- By sorting we group all the ans to one side and making further process easy. TOWARDS RIGHT here.\\n- Now we need to find HOW MANY VALUES are there in right to satisfy the range [lower, upper]\\n- **So, WHY SORTING is sorted in brain.**\\n- As we fixed Nums[i], So lowval to be searched is lower - nums[i].\\n- Also upval to be searched is upper - nums[i]. \\n- Why we do so? [1..i i+1......N-1]\\n- We **should not search 1...i-1, because its just DUPLICATION of Pairs, useless. As already one i selected and searched and counted**\\n- In [i+1. .... N-1] find j and k such that [i+1...j....k....N-1]\\n- nums[j] >= lowval and nums[k] <= upval so that we are always in RANGE [lower, upper]\\n- **DONE**.\\n\\n# Algo :\\n- sort it so that we group the ans to right side\\n- now pick one value for i idx, then search for 2 Values to the right side.\\n- Lower - nums[i] = Lower bound value\\n- Upper - nums[i] = Upper bound value\\n- Now Do 2 Binary search, as the part of array is sorted. [i+1...N-1]\\n- Find value in nums that is >= Lower bound value. Minimize it.\\n- Find value in nums that is <= Upper bound value. Maximize it.\\n- So that we have bigger range.[j....k]. j and k should be as far as possible to get maximum number of pairs\\n- k-j+1 will give you total nos of nums that satisfy the condition with inclusive of the nums in j and k indx too.\\n- Add on to final ans.\\n- Do the same for every i in nums.\\n- We got the ans.\\n\\n# Complexity\\n- Time complexity: $$O(NLogN + N*2*LogN) = O(NLogN)$$\\n- Sorting\\n- For every value in list, doing bin search from i+1 to N\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        \\n        int N = nums.size();\\n        long long ans = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i =0; i<N; i++){\\n            int l = lower - nums[i];\\n            int u = upper - nums[i];\\n            \\n            int j = N;\\n            int k = -1;\\n            \\n            int s = i+1;\\n            int e = N-1;\\n            \\n            while(s<=e){\\n                int mid = s + (e-s)/2;\\n                \\n                if(nums[mid] < l){\\n                    s = mid +1;\\n                }\\n                else{\\n                    j = min(j, mid);\\n                    e = mid -1;\\n                }\\n            }\\n            \\n            \\n            if(j == N) continue;\\n            \\n            s= i+1;\\n            e = N-1;\\n            while(s<=e){\\n                int mid = s + (e-s)/2;\\n                \\n                if(nums[mid] > u){\\n                    e = mid - 1;\\n                }\\n                else{\\n                    k = max(k, mid);\\n                    s = mid + 1;\\n                }\\n            }\\n            \\n            \\n            if(k == -1) continue;\\n            \\n            int occ = k-j+1;\\n            \\n            ans+=occ;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n## Thank you, kindly share it, UPVOTE it, so that it helps others a lot to reach out the article. (As It goes on front page, top voted post) Also motivates me to post more.",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        \\n        int N = nums.size();\\n        long long ans = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i =0; i<N; i++){\\n            int l = lower - nums[i];\\n            int u = upper - nums[i];\\n            \\n            int j = N;\\n            int k = -1;\\n            \\n            int s = i+1;\\n            int e = N-1;\\n            \\n            while(s<=e){\\n                int mid = s + (e-s)/2;\\n                \\n                if(nums[mid] < l){\\n                    s = mid +1;\\n                }\\n                else{\\n                    j = min(j, mid);\\n                    e = mid -1;\\n                }\\n            }\\n            \\n            \\n            if(j == N) continue;\\n            \\n            s= i+1;\\n            e = N-1;\\n            while(s<=e){\\n                int mid = s + (e-s)/2;\\n                \\n                if(nums[mid] > u){\\n                    e = mid - 1;\\n                }\\n                else{\\n                    k = max(k, mid);\\n                    s = mid + 1;\\n                }\\n            }\\n            \\n            \\n            if(k == -1) continue;\\n            \\n            int occ = k-j+1;\\n            \\n            ans+=occ;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200145,
                "title": "java-binary-search-o-nlogn-easy-with-explanation",
                "content": "**Explanation**\\n![image](https://assets.leetcode.com/users/images/5dfbb0be-a87c-4838-80f1-11028be008f3_1676702816.5909715.jpeg)\\n![image](https://assets.leetcode.com/users/images/0b5e875c-078c-44b7-a98b-2d907dec9c05_1676702816.0027335.jpeg)\\n![image](https://assets.leetcode.com/users/images/6b375c04-6a95-487d-8370-0653e97268e2_1676702814.2047656.jpeg)\\n\\n**Code**\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums); /*Sort  the array*/\\n        long cnt=0;\\n        for(int i=0;i<nums.length;i++){\\n            int currlower=lower-nums[i]; /*The other number of the pair should lie within the range \\n\\t\\t\\tof currlower and currupper */\\n            int currupper=upper-nums[i];\\n            long x=bs1(nums,i+1,nums.length-1,currlower);  /*So we found the index of the element\\n\\t\\t\\t                                                 that is >= currlower */\\n            long y=bs2(nums,i+1,nums.length-1,currupper); /*So we found the index of the element \\n\\t\\t\\t                                                that is <= currupper */\\n            cnt+=y-x+1;\\n        }\\n        return cnt;\\n    }\\n    public long bs1(int[] nums,int low,int high,int ele){\\n        long n=0;\\n        while(low<=high){\\n            int mid=low+((high-low)/2);\\n            if(nums[mid]>=ele){\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public long bs2(int[] nums,int low,int high,int ele){\\n        long n=0;\\n        while(low<=high){\\n            int mid=low+((high-low)/2);\\n            if(nums[mid]<=ele){\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return high;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/76d96bd0-5386-4b65-be9c-ca652c3566e5_1676698964.6270268.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums); /*Sort  the array*/\\n        long cnt=0;\\n        for(int i=0;i<nums.length;i++){\\n            int currlower=lower-nums[i]; /*The other number of the pair should lie within the range \\n\\t\\t\\tof currlower and currupper */\\n            int currupper=upper-nums[i];\\n            long x=bs1(nums,i+1,nums.length-1,currlower);  /*So we found the index of the element\\n\\t\\t\\t                                                 that is >= currlower */\\n            long y=bs2(nums,i+1,nums.length-1,currupper); /*So we found the index of the element \\n\\t\\t\\t                                                that is <= currupper */\\n            cnt+=y-x+1;\\n        }\\n        return cnt;\\n    }\\n    public long bs1(int[] nums,int low,int high,int ele){\\n        long n=0;\\n        while(low<=high){\\n            int mid=low+((high-low)/2);\\n            if(nums[mid]>=ele){\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public long bs2(int[] nums,int low,int high,int ele){\\n        long n=0;\\n        while(low<=high){\\n            int mid=low+((high-low)/2);\\n            if(nums[mid]<=ele){\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return high;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174096,
                "title": "binary-search-left-and-right-index-easy",
                "content": "# Intuition\\nIt\\'s just a simple binary search problem, we need to find out leftmost index and rightmost index within range from `lower` to `higher` inclusive.\\nThis Problem is Similar to [Leetcode 34](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/).\\n# Approach\\n1. Sort the array.\\n2. Calculate the second valid value which will make fair pair. for each number in `nums`. Like,\\n    - `LeftMostValue = lower - nums[i]`\\n    - `RightMostValue = Upper - nums[i]`\\n\\n3. Use binary search on problem to get leftMost and rightmost index to get number of fair pairs.\\n\\n# Complexity\\n- Time `O(NlogN)`\\n\\n- Space `O(N) #For Sorting the array.`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Please **UpVote**, if you like it **:)**\\n\\n# Code\\nWith and Without Build-in function.\\n```python []\\n### Using Build-in Function\\nclass Solution(object):\\n    def countFairPairs(self, nums, lower, upper):\\n        res = 0\\n        nums.sort()\\n        for val in nums:\\n            left = bisect.bisect_left(nums, lower - val)\\n            right = bisect.bisect_right(nums, upper - val)\\n            pairs = right - left\\n            if lower - val <= val <= upper - val:\\n                pairs -= 1\\n            res += pairs\\n        return res // 2\\n```\\n```Python []\\nclass Solution(object):\\n    def getLeftIndex(self, l, r, nums, leftVal, rightVal):\\n        index = -1\\n        while r >= l:\\n            mid = (r + l) // 2\\n            if nums[mid] < leftVal:\\n                l = mid + 1\\n            elif rightVal < nums[mid]:\\n                r = mid - 1\\n            else:\\n                index = mid\\n                r = mid - 1\\n        return index\\n    \\n    def getRightIndex(self, l, r, nums, leftVal, rightVal):\\n        index = -1\\n        while r >= l:\\n            mid = (l + r) // 2\\n            if nums[mid] > rightVal:\\n                r = mid - 1\\n            elif nums[mid] < leftVal:\\n                l = mid + 1\\n            else:\\n                index = mid\\n                l = mid + 1\\n        return index\\n        \\n    def countFairPairs(self, nums, lower, upper):\\n        nums.sort()\\n        res = 0;\\n        n = len(nums)\\n        for i, val in enumerate(nums):\\n            leftVal, rightVal = lower - val , upper - val\\n            l, r = i + 1, n - 1\\n            left = self.getLeftIndex(l, r, nums, leftVal, rightVal)\\n            right = self.getRightIndex(l, r, nums, leftVal, rightVal)\\n            if left != -1 and right != -1:\\n                res += (right - left) + 1\\n        return res\\n```\\n\\n**UpVote.**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```python []\\n### Using Build-in Function\\nclass Solution(object):\\n    def countFairPairs(self, nums, lower, upper):\\n        res = 0\\n        nums.sort()\\n        for val in nums:\\n            left = bisect.bisect_left(nums, lower - val)\\n            right = bisect.bisect_right(nums, upper - val)\\n            pairs = right - left\\n            if lower - val <= val <= upper - val:\\n                pairs -= 1\\n            res += pairs\\n        return res // 2\\n```\n```Python []\\nclass Solution(object):\\n    def getLeftIndex(self, l, r, nums, leftVal, rightVal):\\n        index = -1\\n        while r >= l:\\n            mid = (r + l) // 2\\n            if nums[mid] < leftVal:\\n                l = mid + 1\\n            elif rightVal < nums[mid]:\\n                r = mid - 1\\n            else:\\n                index = mid\\n                r = mid - 1\\n        return index\\n    \\n    def getRightIndex(self, l, r, nums, leftVal, rightVal):\\n        index = -1\\n        while r >= l:\\n            mid = (l + r) // 2\\n            if nums[mid] > rightVal:\\n                r = mid - 1\\n            elif nums[mid] < leftVal:\\n                l = mid + 1\\n            else:\\n                index = mid\\n                l = mid + 1\\n        return index\\n        \\n    def countFairPairs(self, nums, lower, upper):\\n        nums.sort()\\n        res = 0;\\n        n = len(nums)\\n        for i, val in enumerate(nums):\\n            leftVal, rightVal = lower - val , upper - val\\n            l, r = i + 1, n - 1\\n            left = self.getLeftIndex(l, r, nums, leftVal, rightVal)\\n            right = self.getRightIndex(l, r, nums, leftVal, rightVal)\\n            if left != -1 and right != -1:\\n                res += (right - left) + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174427,
                "title": "python3-two-pointers",
                "content": "\\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        ans = 0 \\n        lo = hi = len(nums)-1\\n        for i, x in enumerate(nums): \\n            while 0 <= hi and x + nums[hi] > upper: hi -= 1\\n            while 0 <= lo and x + nums[lo] >= lower: lo -= 1\\n            ans += hi - lo \\n            if lo < i <= hi: ans -= 1\\n        return ans//2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        ans = 0 \\n        lo = hi = len(nums)-1\\n        for i, x in enumerate(nums): \\n            while 0 <= hi and x + nums[hi] > upper: hi -= 1\\n            while 0 <= lo and x + nums[lo] >= lower: lo -= 1\\n            ans += hi - lo \\n            if lo < i <= hi: ans -= 1\\n        return ans//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174170,
                "title": "super-easy-upper-and-lower-bound-code-with-comments",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //app 1: \\n    long long countFairPairs(vector<int>& nums, int lower, int upper){ \\n          int n = nums.size();\\n          long long ans = 0;\\n        \\n          //sort array\\n           sort(nums.begin(), nums.end());\\n\\n            for(long long i=0; i<n; i++){\\n            //find lower and upper bound\\n            long long itr1 = lower_bound(nums.begin() + i + 1, nums.end(), lower - nums[i]) - nums.begin();\\n                \\n            long long itr2 = upper_bound(nums.begin() + i + 1, nums.end(), upper - nums[i]) - nums.begin() - 1;\\n\\n            //if they lie in range,update ans\\n            if (itr2 >= itr1){\\n              ans += itr2 - itr1 + 1;\\n            }\\n\\n          }\\n          return ans;\\n    }\\n};\\n```\\n# Don\\'t forget to upvote!\\nHappy coding!\\n![Upvote 2.png](https://assets.leetcode.com/users/images/b3d6fe4b-a58d-418c-a842-cf3598ab6fc7_1676177145.8694694.png)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //app 1: \\n    long long countFairPairs(vector<int>& nums, int lower, int upper){ \\n          int n = nums.size();\\n          long long ans = 0;\\n        \\n          //sort array\\n           sort(nums.begin(), nums.end());\\n\\n            for(long long i=0; i<n; i++){\\n            //find lower and upper bound\\n            long long itr1 = lower_bound(nums.begin() + i + 1, nums.end(), lower - nums[i]) - nums.begin();\\n                \\n            long long itr2 = upper_bound(nums.begin() + i + 1, nums.end(), upper - nums[i]) - nums.begin() - 1;\\n\\n            //if they lie in range,update ans\\n            if (itr2 >= itr1){\\n              ans += itr2 - itr1 + 1;\\n            }\\n\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175016,
                "title": "java-solution",
                "content": "# JAVA Code\\n``` JAVA []\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long result = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            result = result + binarySearch1(nums, nums[i], i, lower, upper) - binarySearch2(nums, nums[i], i, lower, upper);\\n        }\\n        return result;\\n    }\\n    public long binarySearch1(int[] nums, int currentValue, int index, int lower, int upper) {\\n        int start = index + 1;\\n        int end = nums.length;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] > (upper - currentValue)) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n     public long binarySearch2(int[] nums, int currentValue, int index, int lower, int upper) {\\n        int start = index + 1;\\n        int end = nums.length;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < (lower - currentValue)) {\\n                start = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/d0b09f1e-5bd8-4b0a-8fe1-eb5ba64e56a6_1676186450.7231095.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long result = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            result = result + binarySearch1(nums, nums[i], i, lower, upper) - binarySearch2(nums, nums[i], i, lower, upper);\\n        }\\n        return result;\\n    }\\n    public long binarySearch1(int[] nums, int currentValue, int index, int lower, int upper) {\\n        int start = index + 1;\\n        int end = nums.length;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] > (upper - currentValue)) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n     public long binarySearch2(int[] nums, int currentValue, int index, int lower, int upper) {\\n        int start = index + 1;\\n        int end = nums.length;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < (lower - currentValue)) {\\n                start = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200207,
                "title": "c-explanation-time-space-complexity-analysis",
                "content": "# Problem Statement Explanation\\n-   The problem asks us to find the number of fair pairs in the given array of integers nums. A pair of indices **(i,j)** is said to be a fair pair if **0 <= i < j < n** and **lower <= nums[i]+nums[j] <= upper** where **n** is the size of the array.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach :\\n<!-- Describe your approach to solving the problem. -->\\n- The idea is to fix one index **i** at a time and search for all indices **j** such that **lower-nums[i] <= nums[j] <= upper-nums[i]**. If we can find out all such indices **j** then it would be the answer to count fair pairs for the index **i**. We do this for all the indices and finally return the total count.\\n\\n# Step :\\n 1. Sort the given array **nums**.\\n 2. Initialize a variable **res** to 0 which will store the count of fair pairs.\\n 3. Traverse the array from **i=0** to **n-2** where **n** is the size of the array.\\n 4. For each **i**, compute **l** and **u** as **l=lower-nums[i]** and **u=upper-nums[i].**\\n 5. Find the number of elements in the subarray starting from **i+1** to **n-1** which lie in the range **[l,u]**. We can do this by applying **upper_bound** and **lower_bound** algorithms.\\n 6. Add the count to **res** for each **i**.\\n 7. Finally, return the **res**.\\n \\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n    - The time complexity of the above solution is $$O(nlogn)$$. Sorting the array takes $$O(nlogn)$$ time and the for loop takes $$O(n)$$ time complexity. Therefore, the total time complexity of the solution is $$O(n*logn)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->   \\n\\n- Space complexity: $$O(1)$$\\n    - The space complexity of the above solution is $$O(1)$$ since we are not using any extra data structure.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote \\uD83D\\uDE07\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long res=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            auto l=lower-nums[i],u=upper-nums[i];\\n            res+=upper_bound(nums.begin()+(i+1),nums.end(),u)-lower_bound(nums.begin()+(i+1),nums.end(),l);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long res=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            auto l=lower-nums[i],u=upper-nums[i];\\n            res+=upper_bound(nums.begin()+(i+1),nums.end(),u)-lower_bound(nums.begin()+(i+1),nums.end(),l);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175464,
                "title": "o-n-log-n-binary-search-approach",
                "content": "As `i` and `j` can be anywhere in the array, we can note the following intuitions:\\n1. Pair of any 2 non same indexes may form i,j\\n2. Thus, The array can be **Sorted**.\\n3. As we can have the array sorted, we can apply **Binary Search**\\n\\nApproach to solve the problem:\\n1. For each element we can Binary search the indexes of an element equal to or higher than `lower-v[i]` and `upper-v[i]` \\n2.  hence , find out the range of indexes for which the element `v[i]` can form up the pairs so that the sum is in range.\\n3.  This will take O(n*Log(n)) time as is required according to the constraints\\n```\\nlong long countFairPairs(vector<int>& v, int lower, int upper) {\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            int a=lower_bound(v.begin()+i+1,v.end(),lower-v[i])-v.begin();\\n            int b=upper_bound(v.begin()+i+1,v.end(),upper-v[i])-v.begin();\\n            if(a==n||v[i]+v[a]>upper) continue;\\n            if(a==b&&a!=i) {\\n                ans++;\\n                continue;\\n            }\\n            ans+=(b-a);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nlong long countFairPairs(vector<int>& v, int lower, int upper) {\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            int a=lower_bound(v.begin()+i+1,v.end(),lower-v[i])-v.begin();\\n            int b=upper_bound(v.begin()+i+1,v.end(),upper-v[i])-v.begin();\\n            if(a==n||v[i]+v[a]>upper) continue;\\n            if(a==b&&a!=i) {\\n                ans++;\\n                continue;\\n            }\\n            ans+=(b-a);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3174320,
                "title": "easy-python-solution-with-comments-with-2-binary-searches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n ln(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        # First, note that the answer does not change if we sort the array\\n        nums.sort()\\n        fairCtr = 0\\n        for i in range(len(nums)):\\n            # For each index find the left and right elements for which the sums lie between lower and upper\\n            l = bisect_left(nums, lower - nums[i])\\n            r = bisect_right(nums, upper - nums[i])\\n            fairCtr += (r - l)\\n            # check if index i lies in the interval, subtract one (we don\\'t want to double count index i)\\n            if l <= i < r:\\n                fairCtr -= 1\\n        return fairCtr // 2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        # First, note that the answer does not change if we sort the array\\n        nums.sort()\\n        fairCtr = 0\\n        for i in range(len(nums)):\\n            # For each index find the left and right elements for which the sums lie between lower and upper\\n            l = bisect_left(nums, lower - nums[i])\\n            r = bisect_right(nums, upper - nums[i])\\n            fairCtr += (r - l)\\n            # check if index i lies in the interval, subtract one (we don\\'t want to double count index i)\\n            if l <= i < r:\\n                fairCtr -= 1\\n        return fairCtr // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177505,
                "title": "python-3-3-lines-sort-and-bisect-t-m-706-ms-24-mb",
                "content": "```\\nclass Solution:\\n    def countFairPairs(self, nums: list[int], lower: int, upper: int) -> int:\\n\\n        f = lambda x: sum(bisect_right(nums, x - num, hi=i)\\n                       for i, num in enumerate(nums))\\n        nums.sort()\\n\\n        return f(upper) - f(lower - 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countFairPairs(self, nums: list[int], lower: int, upper: int) -> int:\\n\\n        f = lambda x: sum(bisect_right(nums, x - num, hi=i)\\n                       for i, num in enumerate(nums))\\n        nums.sort()\\n\\n        return f(upper) - f(lower - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174608,
                "title": "c-best-solution-with-intuition-and-approach-well-commented",
                "content": "# Intuition\\n**BRUTE FORCE**:\\n\\nRun two loops, check for every pair that whether it is valid or not. Have a count variable and keep updating it everytime you find valid pairs.\\nTime complexity: O(N*N)\\n\\n**OPTIMIZED APPROACH**:\\n\\nThe idea is to use Binary Search.\\n\\n-> if you closely look at the explanation of the examples, you will see that we have taken elements of nums and then looked for another number in the array that forms the valid pair.\\n\\n-> Example 1: nums = [0,1,7,4,4,5], lower = 3, upper = 6\\nExplanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5).\\n\\nIn this example, starting from 0, we looked for all the numbers in the array that forms a valid pair with 0 that are {4,4,5}.\\n\\nSo what we can do is, for every number in the nums, we can find:\\n1. the smallest element that forms the valid pair\\n2. and the largest element that forms the valid pair.\\n\\nFinding these can become easy for us if the array is sorted.\\n\\nAfter sorting, the array becomes: [0,1,4,4,5,7]\\n\\nSo for 0, the smallest element that forms the valid pair is (lower-0) i.e 3\\nand the largest element that forms the valid pair is(upper - 0) i.e 6\\n\\nNow if we can find out the indices of these numbers, then we can simply get the number of valid pair for 0, by subtracting the indices.\\n\\nFor that we will use the concept of lower bound and upper bound.\\n\\nAnd finally we can return our ans.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i<nums.size(); i++){\\n           int x = lower-nums[i]; // for nums[i], (lower-nums[i]) will be smallest valid number of the pair\\n           int y = upper-nums[i]; // for nums[i], this will be the largest valid number of the pair\\n           // now we will find its index in the array\\n           auto itx = lower_bound(nums.begin()+i+1, nums.end(), x);\\n           auto ity = upper_bound(nums.begin()+i+1, nums.end(), y);\\n           ans += ity-itx; \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i<nums.size(); i++){\\n           int x = lower-nums[i]; // for nums[i], (lower-nums[i]) will be smallest valid number of the pair\\n           int y = upper-nums[i]; // for nums[i], this will be the largest valid number of the pair\\n           // now we will find its index in the array\\n           auto itx = lower_bound(nums.begin()+i+1, nums.end(), x);\\n           auto ity = upper_bound(nums.begin()+i+1, nums.end(), y);\\n           ans += ity-itx; \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196718,
                "title": "python-simple-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countFairPairs(self, nums, lower, upper):\\n        nums.sort()\\n\\n        total, i, j = 0, 0, len(nums)-1\\n\\n        while i < j:\\n            if nums[i] + nums[j] > upper:\\n                j -= 1\\n            else:\\n                total += j-i\\n                i += 1\\n\\n        i, j = 0, len(nums)-1\\n\\n        while i < j:\\n            if nums[i] + nums[j] > lower-1:\\n                j -= 1\\n            else:\\n                total -= j-i\\n                i += 1\\n\\n        return total\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countFairPairs(self, nums, lower, upper):\\n        nums.sort()\\n\\n        total, i, j = 0, 0, len(nums)-1\\n\\n        while i < j:\\n            if nums[i] + nums[j] > upper:\\n                j -= 1\\n            else:\\n                total += j-i\\n                i += 1\\n\\n        i, j = 0, len(nums)-1\\n\\n        while i < j:\\n            if nums[i] + nums[j] > lower-1:\\n                j -= 1\\n            else:\\n                total -= j-i\\n                i += 1\\n\\n        return total\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174469,
                "title": "using-lower-and-upper-bound-c-basic-solution-easy-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each current Number find the acceptable Range of smallest and largest number\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n         sort(nums.begin(),nums.end());\\n       \\n         ll ans = 0;         \\n         ll n = size(nums);\\n         for(ll i = 0;i<n;i++){\\n\\n             ll currentNumber = nums[i];\\n             ll leftRange = lower-nums[i];\\n             ll rightRange = upper-nums[i];\\n             \\n             int smallest = lower_bound(nums.begin()+i+1,nums.end(),leftRange)-nums.begin();\\n             int largest = upper_bound(nums.begin()+i+1,nums.end(),rightRange)-nums.begin();\\n              \\nans += largest-smallest;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n         sort(nums.begin(),nums.end());\\n       \\n         ll ans = 0;         \\n         ll n = size(nums);\\n         for(ll i = 0;i<n;i++){\\n\\n             ll currentNumber = nums[i];\\n             ll leftRange = lower-nums[i];\\n             ll rightRange = upper-nums[i];\\n             \\n             int smallest = lower_bound(nums.begin()+i+1,nums.end(),leftRange)-nums.begin();\\n             int largest = upper_bound(nums.begin()+i+1,nums.end(),rightRange)-nums.begin();\\n              \\nans += largest-smallest;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301898,
                "title": "java-count-pairs-whose-sum-is-target-explained",
                "content": "\\n# Previous post got removed :(\\n---\\n![image.png](https://assets.leetcode.com/users/images/07c14613-340c-4941-9b9b-7614e9319274_1678914475.1148329.png)\\n\\n---\\n### Intuition:\\n\\nWe need the number of pairs whose sum lie in the range `[lower, upper]`.\\nSo I just made this simple formula:\\n```\\nNumber of pairs with sum >= lower and <= upper\\n= (Number of pairs with sum <= upper) - (Number of pairs with sum < lower)\\n```\\n---\\n### Here is the implementation of the logic:\\n\\n``` java []\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        // sort the array to make your life easier\\n        Arrays.sort(nums);\\n        return smaller(nums, upper) - smaller(nums, lower - 1);\\n        //              |                        |\\n        //         pairs with               pairs with\\n        //        sum <= upper              sum < lower\\n\\n        // Why lower - 1? because we want to include lower\\n    }\\n\\n    private long smaller(int[] nums, int value) {\\n        // initialise pointers at index 0 and last\\n        int l = 0, r = nums.length - 1;\\n        long result = 0;\\n        while (l < r) {\\n            int sum = nums[l] + nums[r];\\n            // If left and right have sum smaller than target,\\n            // means all elements from l+1 to r form a pair with l\\n            // say we have found the subarray [2,3,4,5] and target is 7           \\n            // (2,3), (2,4), (2,5) are pairs with sum <= 7\\n            if (sum <= value) {\\n                // number of such pairs: 3 (2 with 3, 4, 5) \\n                // which will be given by l - r\\n                result += (r - l);\\n                l++;    // move up to look for more pairs\\n            } else {    // if sum is greater, decrement right pointer\\n                r--;\\n            }\\n        }\\n            \\n        return result;\\n    }\\n}\\n```\\n---\\n### Clean solution:\\n``` java []\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        return smaller(nums, upper) - smaller(nums, --lower);\\n    }\\n\\n    private long smaller(int[] nums, int value) {\\n        int l = 0, r = nums.length - 1;\\n        long result = 0;\\n        while (l < r) {\\n            int sum = nums[l] + nums[r];\\n            if (sum <= value) {\\n                result += (r - l);\\n                l++;    \\n            } else {   \\n                r--;\\n            }\\n        }\\n            \\n        return result;\\n    }\\n}\\n```\\n---\\n##### Time complexity: $$O(n * logn) + O(2n) => O(n * logn)$$\\n##### Space complexity: $$O(1)$$",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nNumber of pairs with sum >= lower and <= upper\\n= (Number of pairs with sum <= upper) - (Number of pairs with sum < lower)\\n```\n``` java []\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        // sort the array to make your life easier\\n        Arrays.sort(nums);\\n        return smaller(nums, upper) - smaller(nums, lower - 1);\\n        //              |                        |\\n        //         pairs with               pairs with\\n        //        sum <= upper              sum < lower\\n\\n        // Why lower - 1? because we want to include lower\\n    }\\n\\n    private long smaller(int[] nums, int value) {\\n        // initialise pointers at index 0 and last\\n        int l = 0, r = nums.length - 1;\\n        long result = 0;\\n        while (l < r) {\\n            int sum = nums[l] + nums[r];\\n            // If left and right have sum smaller than target,\\n            // means all elements from l+1 to r form a pair with l\\n            // say we have found the subarray [2,3,4,5] and target is 7           \\n            // (2,3), (2,4), (2,5) are pairs with sum <= 7\\n            if (sum <= value) {\\n                // number of such pairs: 3 (2 with 3, 4, 5) \\n                // which will be given by l - r\\n                result += (r - l);\\n                l++;    // move up to look for more pairs\\n            } else {    // if sum is greater, decrement right pointer\\n                r--;\\n            }\\n        }\\n            \\n        return result;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        return smaller(nums, upper) - smaller(nums, --lower);\\n    }\\n\\n    private long smaller(int[] nums, int value) {\\n        int l = 0, r = nums.length - 1;\\n        long result = 0;\\n        while (l < r) {\\n            int sum = nums[l] + nums[r];\\n            if (sum <= value) {\\n                result += (r - l);\\n                l++;    \\n            } else {   \\n                r--;\\n            }\\n        }\\n            \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180727,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long i=0,j=nums.size()-1,ans=0;\\n        while(i<j)\\n        {\\n            if(nums[i]+nums[j]<=upper&&nums[i]+nums[j]>=lower)\\n            {\\n                int k=i+1;\\n                while(k<j)\\n                {\\n                    if(nums[k]+nums[i]>=lower)break;\\n                    k++;\\n                }\\n                ans+=j-k+1;\\n                cout<<i<<\" \"<<j<<endl;\\n                i++;\\n            }\\n            else if(nums[i]+nums[j]>upper)\\n            {\\n                j--;\\n            }\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long i=0,j=nums.size()-1,ans=0;\\n        while(i<j)\\n        {\\n            if(nums[i]+nums[j]<=upper&&nums[i]+nums[j]>=lower)\\n            {\\n                int k=i+1;\\n                while(k<j)\\n                {\\n                    if(nums[k]+nums[i]>=lower)break;\\n                    k++;\\n                }\\n                ans+=j-k+1;\\n                cout<<i<<\" \"<<j<<endl;\\n                i++;\\n            }\\n            else if(nums[i]+nums[j]>upper)\\n            {\\n                j--;\\n            }\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3178075,
                "title": "java-approach-tracing-simple-tc-o-n-log-n-sc-o-1",
                "content": "# Approach\\n- Sort the elements.\\n- Let\\'s say p1 as  number of pairs <= upper.\\n- Let\\'s say p2 as number of pairs <= lower - 1.\\n- Result is p1 - p2.\\n\\n**Approach for Number of Pairs <= val in Sorted Array**\\n- Take2 pointers i at 0 and j at len - 1\\n- if nums[i] + nums[j] > val we decrement j since the sum of values at pair(i, j) > val.\\n- else nums[i] + nums[j] <= val we increment the output by j - i.\\nreason: lets say i is at 0 and j is at 5 in sorted array.\\nsince nums[i] + nums[j] <= 6 then nums[i] + nums[x] <= 6 where\\n i < x <= j\\n\\n**Let\\'s trace Number of Pairs <= val in Sorted Array with an example**\\n```\\nnums = {0,1,7,4,4,5}, val = 6\\n\\nAfter sorting\\nnums = {0,1,4,4,5,7}\\n \\n i         j \\n 0,1,2,3,4,5        \\n{0,1,4,4,5,7} nums[0] + nums[5] = 0 + 7 > 6, so decrease j by 1.\\n\\n i       j \\n 0,1,2,3,4,5        \\n{0,1,4,4,5,7} nums[0] + nums[4] = 0 + 5 <= 6, so increament ouput by j - i = 4 - 0 = 4 and increase by 1.[output = 4]\\n\\n   i     j \\n 0,1,2,3,4,5        \\n{0,1,4,4,5,7} nums[1] + nums[4] = 1 + 5 <= 6, so increament ouput by j - i = 4 - 1 = 3 and increase by 1.[output = 7]\\ni.e., pair (1,4), (1,3), (1,2) satisfies the condition.\\n\\n     i   j \\n 0,1,2,3,4,5        \\n{0,1,4,4,5,7} nums[2] + nums[4] = 4 + 5 > 6, so decrease j by 1.\\n\\n     i j \\n 0,1,2,3,4,5        \\n{0,1,4,4,5,7} nums[2] + nums[3] = 4 + 4 > 6, so decrease j by 1.\\n\\n\\n     i\\n     j \\n 0,1,2,3,4,5        \\n{0,1,4,4,5,7} i == j **STOP**\\n\\n```\\n# Complexity\\n- Time complexity: O(N log N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        return countPairsLessThanVal(nums, upper) - countPairsLessThanVal(nums, lower - 1);\\n    }\\n    \\n    private long countPairsLessThanVal(int[] nums, int val) {\\n        long output = 0;\\n        int i = 0, j = nums.length - 1;\\n        \\n        while (i < j) {\\n            if (nums[i] + nums[j] > val) {\\n                -- j;\\n            } else {\\n                output += j - i;\\n                ++ i;\\n            }\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nnums = {0,1,7,4,4,5}, val = 6\\n\\nAfter sorting\\nnums = {0,1,4,4,5,7}\\n \\n i         j \\n 0,1,2,3,4,5        \\n{0,1,4,4,5,7} nums[0] + nums[5] = 0 + 7 > 6, so decrease j by 1.\\n\\n i       j \\n 0,1,2,3,4,5        \\n{0,1,4,4,5,7} nums[0] + nums[4] = 0 + 5 <= 6, so increament ouput by j - i = 4 - 0 = 4 and increase by 1.[output = 4]\\n\\n   i     j \\n 0,1,2,3,4,5        \\n{0,1,4,4,5,7} nums[1] + nums[4] = 1 + 5 <= 6, so increament ouput by j - i = 4 - 1 = 3 and increase by 1.[output = 7]\\ni.e., pair (1,4), (1,3), (1,2) satisfies the condition.\\n\\n     i   j \\n 0,1,2,3,4,5        \\n{0,1,4,4,5,7} nums[2] + nums[4] = 4 + 5 > 6, so decrease j by 1.\\n\\n     i j \\n 0,1,2,3,4,5        \\n{0,1,4,4,5,7} nums[2] + nums[3] = 4 + 4 > 6, so decrease j by 1.\\n\\n\\n     i\\n     j \\n 0,1,2,3,4,5        \\n{0,1,4,4,5,7} i == j **STOP**\\n\\n```\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        return countPairsLessThanVal(nums, upper) - countPairsLessThanVal(nums, lower - 1);\\n    }\\n    \\n    private long countPairsLessThanVal(int[] nums, int val) {\\n        long output = 0;\\n        int i = 0, j = nums.length - 1;\\n        \\n        while (i < j) {\\n            if (nums[i] + nums[j] > val) {\\n                -- j;\\n            } else {\\n                output += j - i;\\n                ++ i;\\n            }\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177009,
                "title": "c-lower-and-upper-bound",
                "content": "Please **upvote** \\u2B06\\uFE0F if you like the **solution**.\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans = 0;\\n        sort(nums.begin(), nums.end());\\n        int mn, mx;\\n        for(int i = 0; i < nums.size(); i++){\\n\\t\\t    // to get the lowest indice to make the valid pair\\n            mn = lower_bound(nums.begin()+i+1, nums.end(), lower - nums[i]) - nums.begin();\\n\\t\\t\\t// to get the largest indice to make the valid pair\\n            mx = upper_bound(nums.begin()+i+1, nums.end(), upper - nums[i]) - nums.begin();\\n\\t\\t\\t// just count all the numbers between these indices\\n            ans += (mx - mn);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans = 0;\\n        sort(nums.begin(), nums.end());\\n        int mn, mx;\\n        for(int i = 0; i < nums.size(); i++){\\n\\t\\t    // to get the lowest indice to make the valid pair\\n            mn = lower_bound(nums.begin()+i+1, nums.end(), lower - nums[i]) - nums.begin();\\n\\t\\t\\t// to get the largest indice to make the valid pair\\n            mx = upper_bound(nums.begin()+i+1, nums.end(), upper - nums[i]) - nums.begin();\\n\\t\\t\\t// just count all the numbers between these indices\\n            ans += (mx - mn);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176296,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity:  $$O(n log n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        return task(nums,upper) - task(nums,lower-1);\\n    }\\n    public long task(int nums[], int val)\\n    {\\n        long p=0;\\n        for(int i=0,j=nums.length-1;i<j;i++)\\n        {\\n            int k=nums[i]+nums[j];\\n            while(i<j && k>val)\\n            {\\n                j--;\\n                k=nums[i]+nums[j];\\n            }\\n            p+=(long)(j-i);\\n        }\\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        return task(nums,upper) - task(nums,lower-1);\\n    }\\n    public long task(int nums[], int val)\\n    {\\n        long p=0;\\n        for(int i=0,j=nums.length-1;i<j;i++)\\n        {\\n            int k=nums[i]+nums[j];\\n            while(i<j && k>val)\\n            {\\n                j--;\\n                k=nums[i]+nums[j];\\n            }\\n            p+=(long)(j-i);\\n        }\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175432,
                "title": "c-simple-sort-find-bound",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long int ans = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            int x = lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i])-nums.begin()+i;\\n            int y = upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i])-nums.begin()+i;\\n            ans += (y-x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long int ans = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            int x = lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i])-nums.begin()+i;\\n            int y = upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i])-nums.begin()+i;\\n            ans += (y-x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174676,
                "title": "simple-and-easy-approach-with-explanation",
                "content": "# Approach:-\\n```\\nCase 1:- if nums[left] + nums[right] > upper:\\nChecking all the cases where sum is greater than upper then simply decrement right by one. If less or equal to the upper value then it satisfy for all case between right to left so add count += right - left and increment in left.\\n```\\n```\\nCase 2:- if nums[left] + nums[right] > lower -1:\\nChecking all the cases where sum is greater than lower - 1 then simply decrement right by one. If less or equal to the upper value then it satisfy for all case between right to left so add count += right - left and increment in left.\\n\\n```\\n#  Time Complexity And Space Complexity:-\\n\\nThe time complexity of the code using the two pointer approach is O(n log n), where n is the size of the input array nums. This is because the sorting of the array takes O(n log n) time and the two while loops take O(n) time each, so the total time complexity is O(n log n) + 2 * O(n) = O(n log n).\\n\\nThe space complexity of this algorithm is O(1), because it does not use any additional data structures other than the input array nums. The sorting is done in-place, so no additional space is used for sorting. The only extra space used is a few variables for storing intermediate values, such as left, right, and count, which have a constant space complexity of O(1).\\n\\n\\n# Code:-\\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        left , right = 0 , len(nums)-1\\n        count = 0\\n        while left < right:\\n            if nums[left] + nums[right] > upper:\\n                right -= 1\\n            else:\\n                count += right - left\\n                left += 1\\n        left , right = 0 , len(nums)-1\\n        while left < right:\\n            if nums[left] + nums[right] > lower - 1:\\n                right -= 1\\n            else:\\n                count -= right - left\\n                left += 1\\n        return count\\n        \\n```\\n#  ___________PLEASE UPVOTE___________\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nCase 1:- if nums[left] + nums[right] > upper:\\nChecking all the cases where sum is greater than upper then simply decrement right by one. If less or equal to the upper value then it satisfy for all case between right to left so add count += right - left and increment in left.\\n```\n```\\nCase 2:- if nums[left] + nums[right] > lower -1:\\nChecking all the cases where sum is greater than lower - 1 then simply decrement right by one. If less or equal to the upper value then it satisfy for all case between right to left so add count += right - left and increment in left.\\n\\n```\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        left , right = 0 , len(nums)-1\\n        count = 0\\n        while left < right:\\n            if nums[left] + nums[right] > upper:\\n                right -= 1\\n            else:\\n                count += right - left\\n                left += 1\\n        left , right = 0 , len(nums)-1\\n        while left < right:\\n            if nums[left] + nums[right] > lower - 1:\\n                right -= 1\\n            else:\\n                count -= right - left\\n                left += 1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174543,
                "title": "java-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int low=lower-nums[i];\\n            int high=upper-nums[i];\\n            long l=help1(nums,i+1,low);\\n            long h=help2(nums,i+1,high);\\n            ans+=h-l;\\n        }\\n        return ans;\\n    }\\n    public long help2(int[] nums,int s,int high) {\\n        int end = nums.length;\\n        while (s < end) {\\n            int mid = (s+end) / 2;\\n            if (nums[mid] >high) {\\n                end = mid;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n        return s;\\n    }\\n     public long help1(int[] nums,int s,int low) {\\n        int end = nums.length;\\n        while (s < end) {\\n            int mid = (s+end)/ 2;\\n            if (nums[mid] < (low)) {\\n                s = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return s;\\n    }\\n    \\n    \\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int low=lower-nums[i];\\n            int high=upper-nums[i];\\n            long l=help1(nums,i+1,low);\\n            long h=help2(nums,i+1,high);\\n            ans+=h-l;\\n        }\\n        return ans;\\n    }\\n    public long help2(int[] nums,int s,int high) {\\n        int end = nums.length;\\n        while (s < end) {\\n            int mid = (s+end) / 2;\\n            if (nums[mid] >high) {\\n                end = mid;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n        return s;\\n    }\\n     public long help1(int[] nums,int s,int low) {\\n        int end = nums.length;\\n        while (s < end) {\\n            int mid = (s+end)/ 2;\\n            if (nums[mid] < (low)) {\\n                s = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return s;\\n    }\\n    \\n    \\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174533,
                "title": "java-simple-solution-two-pointer-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long count = 0;\\n        int u = nums.length-1;\\n        int l = 1;\\n        for(int i = 0; i<nums.length; i++){\\n            while(u>0 && nums[i]+nums[u] > upper){\\n                u--;\\n            }\\n            l = i+1;\\n            while(l<nums.length && nums[i]+nums[l] < lower){\\n                l++;\\n            }\\n            if(l<=u){\\n                count += u-l+1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long count = 0;\\n        int u = nums.length-1;\\n        int l = 1;\\n        for(int i = 0; i<nums.length; i++){\\n            while(u>0 && nums[i]+nums[u] > upper){\\n                u--;\\n            }\\n            l = i+1;\\n            while(l<nums.length && nums[i]+nums[l] < lower){\\n                l++;\\n            }\\n            if(l<=u){\\n                count += u-l+1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174422,
                "title": "c-sorting-binary-search",
                "content": "# Intuition\\nInitially I thought of using a multiset but subtracting iterators is very costly in non linear data structures like set, multiset.\\nThe next thing which struck my mind was whether I can sort the array or not and as it turns out, I can.\\n\\n# Approach>\\nFirst, sort the array. It can be seen that it won\\'t change the answer as the indices of elements are not important at all.\\n\\nFor every element, we just need to find the number of elements which are in a specific range.(Just write down the equations on paper and it\\'s easy to see the constraints on the lowerbound and upperbound).\\n\\nLower bound function gives the first number which is in this \"specific\" range and upper bound gives the first number which is not.\\n\\nSubtract them and one more question solved successfully.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)    thanks to sorting and lower_bound upper_bound functions\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long countFairPairs(vector<int>& a, int lower, int upper) {\\n        ll ans = 0;\\n        sort(a.begin(), a.end());\\n        int n = a.size();\\n        \\n        for(int i=0; i<n; i++){\\n            auto it1 = lower_bound(a.begin(), a.begin()+i, lower - a[i]);\\n            auto it2 = upper_bound(a.begin(), a.begin()+i, upper - a[i]);\\n            if(it2 > it1)   ans += (it2 - it1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long countFairPairs(vector<int>& a, int lower, int upper) {\\n        ll ans = 0;\\n        sort(a.begin(), a.end());\\n        int n = a.size();\\n        \\n        for(int i=0; i<n; i++){\\n            auto it1 = lower_bound(a.begin(), a.begin()+i, lower - a[i]);\\n            auto it2 = upper_bound(a.begin(), a.begin()+i, upper - a[i]);\\n            if(it2 > it1)   ans += (it2 - it1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174281,
                "title": "simple-approaches-two-pointer-binary-search-c",
                "content": "\\n\\n# Approach : Two pointer  (gives tle)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        int s=0,n=nums.size();\\n        int e=n-1;\\n        long long cnt=0;\\n        sort(nums.begin(),nums.end());\\n        while(s<e){\\n            long long yk=nums[s]+nums[e];\\n            if(yk<=upper&& yk>=lower){\\n                int k=e-1;  cnt++;\\n                while(k>s &&nums[k]+nums[s]>=lower&&nums[k]+nums[s]<=upper){\\n                    cnt++;\\n                    k--;\\n                }\\n              \\n                s++;\\n            }\\n            else if(yk>upper){\\n                e--;\\n            }\\n            else if(yk<lower){\\n                s++;\\n            }\\n            \\n                \\n            }       \\n        return cnt;\\n        \\n   \\n    \\n    \\n    \\n    \\n    \\n    \\n    }\\n};\\n```\\n\\n\\n\\n# Approach : Binary search \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        int s=0,n=nums.size();\\n        int e=n-1;\\n        long long cnt=0;\\n        vector<int>vec1(n,0),vec2(n,0);\\n        sort(nums.begin(),nums.end());\\n       for(int i=0;i<n;i++){\\n           int a=lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i])-nums.begin();\\n           int b=upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i])-nums.begin()-1;\\n           if(a<=b){\\n               cnt+=(b-a+1);\\n           }\\n       }\\n        return cnt;\\n        \\n  \\n    \\n    \\n    \\n    \\n    \\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        int s=0,n=nums.size();\\n        int e=n-1;\\n        long long cnt=0;\\n        sort(nums.begin(),nums.end());\\n        while(s<e){\\n            long long yk=nums[s]+nums[e];\\n            if(yk<=upper&& yk>=lower){\\n                int k=e-1;  cnt++;\\n                while(k>s &&nums[k]+nums[s]>=lower&&nums[k]+nums[s]<=upper){\\n                    cnt++;\\n                    k--;\\n                }\\n              \\n                s++;\\n            }\\n            else if(yk>upper){\\n                e--;\\n            }\\n            else if(yk<lower){\\n                s++;\\n            }\\n            \\n                \\n            }       \\n        return cnt;\\n        \\n   \\n    \\n    \\n    \\n    \\n    \\n    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        int s=0,n=nums.size();\\n        int e=n-1;\\n        long long cnt=0;\\n        vector<int>vec1(n,0),vec2(n,0);\\n        sort(nums.begin(),nums.end());\\n       for(int i=0;i<n;i++){\\n           int a=lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i])-nums.begin();\\n           int b=upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i])-nums.begin()-1;\\n           if(a<=b){\\n               cnt+=(b-a+1);\\n           }\\n       }\\n        return cnt;\\n        \\n  \\n    \\n    \\n    \\n    \\n    \\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174158,
                "title": "javascript-binary-search-sorting",
                "content": "**Solution: Binary Search & Sorting**\\n\\nFirst, sort nums in asc order (order doesn\\'t matter)\\nThen for each index `i`, binary search for the lower and upper bound indices:\\n  1. Binary search for the smallest index `j` where `nums[i] + nums[j] >= lower` (and `j > i`)\\n  2. Binary search for the largest index `j` where `nums[i] + nums[j] <= upper` (and `j > i`)\\nThe number of pairs with the index `i` = `upperBound - lowerBound + 1`\\n\\nTime Complexity: `O(n log(n))`\\nSpace Complexity: `O(log(n))` (space for sorting)\\n```\\nvar countFairPairs = function(nums, lower, upper) {\\n  let n = nums.length, pairs = 0;\\n  nums.sort((a, b) => a - b);\\n  for (let i = 0; i < n - 1; i++) {\\n    let lowerBound = lower_bound(i); \\n    let upperBound = upper_bound(i);\\n    pairs += Math.max(0, upperBound - lowerBound + 1);\\n  }\\n  return pairs;\\n  \\n  function lower_bound(i) {\\n    // Find smallest index j where nums[i] + nums[j] >= lower\\n    let low = i + 1, high = n - 1;\\n    while (low < high) {\\n      let mid = Math.floor((low + high) / 2);\\n      if (nums[mid] + nums[i] >= lower) high = mid;\\n      else low = mid + 1;\\n    }\\n    return nums[low] + nums[i] >= lower ? low : n;\\n  }\\n  \\n  function upper_bound(i) {\\n    // Find largest index j where nums[i] + nums[j] <= upper\\n    let low = i + 1, high = n - 1;\\n    while (low < high) {\\n      let mid = Math.ceil((low + high) / 2);\\n      if (nums[mid] + nums[i] <= upper) low = mid;\\n      else high = mid - 1;\\n    }\\n    return nums[low] + nums[i] <= upper ? low : i;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countFairPairs = function(nums, lower, upper) {\\n  let n = nums.length, pairs = 0;\\n  nums.sort((a, b) => a - b);\\n  for (let i = 0; i < n - 1; i++) {\\n    let lowerBound = lower_bound(i); \\n    let upperBound = upper_bound(i);\\n    pairs += Math.max(0, upperBound - lowerBound + 1);\\n  }\\n  return pairs;\\n  \\n  function lower_bound(i) {\\n    // Find smallest index j where nums[i] + nums[j] >= lower\\n    let low = i + 1, high = n - 1;\\n    while (low < high) {\\n      let mid = Math.floor((low + high) / 2);\\n      if (nums[mid] + nums[i] >= lower) high = mid;\\n      else low = mid + 1;\\n    }\\n    return nums[low] + nums[i] >= lower ? low : n;\\n  }\\n  \\n  function upper_bound(i) {\\n    // Find largest index j where nums[i] + nums[j] <= upper\\n    let low = i + 1, high = n - 1;\\n    while (low < high) {\\n      let mid = Math.ceil((low + high) / 2);\\n      if (nums[mid] + nums[i] <= upper) low = mid;\\n      else high = mid - 1;\\n    }\\n    return nums[low] + nums[i] <= upper ? low : i;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3174066,
                "title": "python-a-clean-and-short-method-using-binary-search",
                "content": "\\n# Code\\n```\\nimport bisect\\nclass Solution:     \\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        sortingData=[nums[-1]]\\n        n=len(nums)\\n        answer=0\\n        for i in range(n-2, -1, -1):\\n            l=bisect.bisect_left(sortingData, lower-nums[i])\\n            u=bisect.bisect_right(sortingData, upper-nums[i])            \\n            answer+=(u-l)\\n            bisect.insort_left(sortingData, nums[i])\\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport bisect\\nclass Solution:     \\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        sortingData=[nums[-1]]\\n        n=len(nums)\\n        answer=0\\n        for i in range(n-2, -1, -1):\\n            l=bisect.bisect_left(sortingData, lower-nums[i])\\n            u=bisect.bisect_right(sortingData, upper-nums[i])            \\n            answer+=(u-l)\\n            bisect.insort_left(sortingData, nums[i])\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174053,
                "title": "simple-short-binary-search-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust for every number find the another number using binary search in the right side. and add the range into your answer.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& arr, int lower, int upper) \\n    {\\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        long long ans = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int val = upper - arr[i];\\n            int cal = lower - arr[i];\\n            \\n            auto ind = upper_bound(arr.begin(), arr.end(), val);\\n            auto ind1 = lower_bound(arr.begin(), arr.end(), cal);\\n            \\n            int index = ind-arr.begin()-1;\\n            int index1 = ind1-arr.begin();\\n            \\n         \\n            if(index1 < 0 || index < 0) continue;\\n            \\n            if(index >= i) \\n            {\\n                if(index1 > i) ans += index-index1+1;\\n                else ans += index-max(index1, i);\\n            }\\n        }\\n        \\n        return ans;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& arr, int lower, int upper) \\n    {\\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        long long ans = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int val = upper - arr[i];\\n            int cal = lower - arr[i];\\n            \\n            auto ind = upper_bound(arr.begin(), arr.end(), val);\\n            auto ind1 = lower_bound(arr.begin(), arr.end(), cal);\\n            \\n            int index = ind-arr.begin()-1;\\n            int index1 = ind1-arr.begin();\\n            \\n         \\n            if(index1 < 0 || index < 0) continue;\\n            \\n            if(index >= i) \\n            {\\n                if(index1 > i) ans += index-index1+1;\\n                else ans += index-max(index1, i);\\n            }\\n        }\\n        \\n        return ans;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174024,
                "title": "sorting-binary-search-explanation-python-solution",
                "content": "This problem doesn\\'t ask you to recover the pairs, so you can sort the array and try to get the range of the numbers that you can use to get the answer. So the problem reduces to:\\n\\n* Sorting the array\\n* Iterate over each of the elements and, considering the number you\\'re checking at that point as the `i`th number, you need to see how many indices `j` can be paired with this one. For this:\\n    1. Find a lower index `lowerLimit` where the sum of the current number you\\'re holding and the number of the lower index are the smallest pair such that adds bigger than the `lower`\\n    2. Find an upper index `upperLimit` where the sum of the current number you\\'re holding and the number of the upper index are the biggest pair such that adds smaller than the `upper`\\n    3. If any of your two indices goes under the index of the current number you are, stop. There is no pair that you can make where that number is the `i` component of your pair.\\n    4. Add to your final answer `upperLimit - lowerLimit + 1` only if both indices are bigger than your current index.\\n\\nThat\\'s all. \\n# Complexity\\n- Time complexity: $O(n\\\\log(n) + \\\\log(n)) = O(n\\\\log(n))$ because of the sorting. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$ if we consider the sorted array as an extra. Else is $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        size = len(nums)\\n        answer = 0\\n        for idx in range(size):\\n            current = nums[idx]\\n            left = idx+1\\n            right = size - 1\\n            lowerLimit = None\\n            while left <= right:\\n                middle = (left+right) // 2\\n                if middle < idx: break\\n                if current + nums[middle] < lower:\\n                    left = middle + 1\\n                else:\\n                    lowerLimit = middle\\n                    right = middle - 1\\n            left = idx+1\\n            right = size - 1\\n            upperLimit = None\\n            while left <= right:\\n                middle = (left+right) // 2\\n                if middle < idx: break\\n                if nums[middle] + current > upper:\\n                    right = middle - 1\\n                else:\\n                    upperLimit = middle\\n                    left = middle + 1\\n            if upperLimit and lowerLimit:\\n                answer += upperLimit - lowerLimit + 1\\n        return answer\\n            \\n```\\n\\nFeel free to ask any question.",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        size = len(nums)\\n        answer = 0\\n        for idx in range(size):\\n            current = nums[idx]\\n            left = idx+1\\n            right = size - 1\\n            lowerLimit = None\\n            while left <= right:\\n                middle = (left+right) // 2\\n                if middle < idx: break\\n                if current + nums[middle] < lower:\\n                    left = middle + 1\\n                else:\\n                    lowerLimit = middle\\n                    right = middle - 1\\n            left = idx+1\\n            right = size - 1\\n            upperLimit = None\\n            while left <= right:\\n                middle = (left+right) // 2\\n                if middle < idx: break\\n                if nums[middle] + current > upper:\\n                    right = middle - 1\\n                else:\\n                    upperLimit = middle\\n                    left = middle + 1\\n            if upperLimit and lowerLimit:\\n                answer += upperLimit - lowerLimit + 1\\n        return answer\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247004,
                "title": "simple-binary-search-solution",
                "content": "**I used my custom binary search but you can use the builtin one but it will require some conditions to be written so that you get correct answer and to avoid any runtime errors.\\nI prefer mine one.**\\n\\n```\\nclass Solution\\n{\\n    public:\\n        int bsh(vector<int> &nums, int x, int num, int l, int h)//binary search for finding higher bound\\n        {\\n            int best = nums.size();\\n            while (l <= h)\\n            {\\n                int mid = l + (h - l) / 2;\\n                if (nums[mid] + num <= x)\\n                {\\n                    best = mid;\\n                    l = mid + 1;\\n                }\\n                else\\n                    h = mid - 1;\\n            }\\n            return best;\\n        }\\n    int bsl(vector<int> &nums, int x, int num, int l, int h)//binary search for finding lower bound\\n    {\\n        int best = nums.size();\\n        while (l <= h)\\n        {\\n            int mid = l + (h - l) / 2;\\n            if (nums[mid] + num >= x)\\n            {\\n                best = mid;\\n                h = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return best;\\n    }\\n    long long countFairPairs(vector<int> &nums, int lower, int upper)\\n    {\\n        sort(nums.begin(), nums.end());\\n        long long ans = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            int l = bsl(nums, lower, nums[i], i + 1, nums.size() - 1);\\n            int h = bsh(nums, upper, nums[i], i + 1, nums.size() - 1);\\n            if (l != nums.size() and h != nums.size())//if found valid index then calculate their intermediate distance and add to answer.\\n                ans += (h - l + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int bsh(vector<int> &nums, int x, int num, int l, int h)//binary search for finding higher bound\\n        {\\n            int best = nums.size();\\n            while (l <= h)\\n            {\\n                int mid = l + (h - l) / 2;\\n                if (nums[mid] + num <= x)\\n                {\\n                    best = mid;\\n                    l = mid + 1;\\n                }\\n                else\\n                    h = mid - 1;\\n            }\\n            return best;\\n        }\\n    int bsl(vector<int> &nums, int x, int num, int l, int h)//binary search for finding lower bound\\n    {\\n        int best = nums.size();\\n        while (l <= h)\\n        {\\n            int mid = l + (h - l) / 2;\\n            if (nums[mid] + num >= x)\\n            {\\n                best = mid;\\n                h = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return best;\\n    }\\n    long long countFairPairs(vector<int> &nums, int lower, int upper)\\n    {\\n        sort(nums.begin(), nums.end());\\n        long long ans = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            int l = bsl(nums, lower, nums[i], i + 1, nums.size() - 1);\\n            int h = bsh(nums, upper, nums[i], i + 1, nums.size() - 1);\\n            if (l != nums.size() and h != nums.size())//if found valid index then calculate their intermediate distance and add to answer.\\n                ans += (h - l + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176352,
                "title": "swift-solution-using-two-pointers-approach-o-nlogn",
                "content": "# Code\\n```\\nclass Solution {\\n    func countFairPairs(_ nums: [Int], _ lower: Int, _ upper: Int) -> Int {\\n\\n        var res = 0\\n        let nums = nums.sorted()\\n\\n        var l = 0\\n        var r = nums.count - 1\\n\\n        while l < r {\\n            if nums[l] + nums[r] <= upper {\\n                res += r - l\\n                l += 1\\n            } else {\\n                r -= 1\\n            }\\n        }\\n\\n        l = 0\\n        r = nums.count - 1\\n\\n        while l < r {\\n            if nums[l] + nums[r] <= lower - 1 {\\n                res -= r - l\\n                l += 1\\n            } else {\\n                r -= 1\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countFairPairs(_ nums: [Int], _ lower: Int, _ upper: Int) -> Int {\\n\\n        var res = 0\\n        let nums = nums.sorted()\\n\\n        var l = 0\\n        var r = nums.count - 1\\n\\n        while l < r {\\n            if nums[l] + nums[r] <= upper {\\n                res += r - l\\n                l += 1\\n            } else {\\n                r -= 1\\n            }\\n        }\\n\\n        l = 0\\n        r = nums.count - 1\\n\\n        while l < r {\\n            if nums[l] + nums[r] <= lower - 1 {\\n                res -= r - l\\n                l += 1\\n            } else {\\n                r -= 1\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174509,
                "title": "sliding-window-with-explaination-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we don\\'t sort the array, it will end up in TLE with brute force solution.\\nFor i-th element in nums, we can find a fair window `(left, right]` where from `(i, left+1)` to `(i, right)` are fair pairs.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key point is to find the `left` boundary and the `right` boundary.\\n`left`: the smallest index that doesn\\'t satisfy nums[i] + nums[left] >= lower.\\n`right`: the largest index that satisfy nums[i] + nums[right] <= upper.\\nTherefore, we can say there are (right - (left+1) + 1) = (right - left) pairs for i-th element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public long CountFairPairs(int[] nums, int lower, int upper) {\\n        long count = 0;\\n        Array.Sort(nums);\\n        int left=nums.Length - 1, right=nums.Length - 1;\\n        for(int i = 0; i < nums.Length-1; i++) {\\n            left = Math.Max(left, i+1);\\n            while(left > i && nums[i] + nums[left] >= lower){\\n                left--;\\n            }\\n            while(right>i && nums[i] + nums[right] > upper){\\n                right--;\\n            }\\n            if (right < left)\\n                break;\\n            count += right-left;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long CountFairPairs(int[] nums, int lower, int upper) {\\n        long count = 0;\\n        Array.Sort(nums);\\n        int left=nums.Length - 1, right=nums.Length - 1;\\n        for(int i = 0; i < nums.Length-1; i++) {\\n            left = Math.Max(left, i+1);\\n            while(left > i && nums[i] + nums[left] >= lower){\\n                left--;\\n            }\\n            while(right>i && nums[i] + nums[right] > upper){\\n                right--;\\n            }\\n            if (right < left)\\n                break;\\n            count += right-left;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174283,
                "title": "c-binary-search-easy-to-understand",
                "content": "\\n# Approach : Binary Search\\n\\n# Complexity\\n- Time complexity: O(NxLog(N))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans=0;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            long long s = lower_bound(nums.begin(),nums.begin()+i,(lower-nums[i])) - nums.begin();\\n            long long e = upper_bound(nums.begin(),nums.begin()+i,(upper-nums[i])) - nums.begin()-1;\\n            if(s>=i){\\n                continue;\\n            }\\n            ans+=e-s+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans=0;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            long long s = lower_bound(nums.begin(),nums.begin()+i,(lower-nums[i])) - nums.begin();\\n            long long e = upper_bound(nums.begin(),nums.begin()+i,(upper-nums[i])) - nums.begin()-1;\\n            if(s>=i){\\n                continue;\\n            }\\n            ans+=e-s+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174208,
                "title": "python-2-liner",
                "content": "Though not very pretty\\n\\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        return sum([bisect_right(nums, upper - v, i + 1) - bisect_left(nums, lower - v, i + 1) for i,v in enumerate(nums)])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        return sum([bisect_right(nums, upper - v, i + 1) - bisect_left(nums, lower - v, i + 1) for i,v in enumerate(nums)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174200,
                "title": "c-binary-search-easy-approach-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere, I use binary search approch to find the correct index range of ans for every element of the given array using binary search.\\nThe length of the range will add up to our final answer.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn) where n is the number of elements in the array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countPairSum(vector<int>& arr,int l,int r){\\n        sort(arr.begin(),arr.end());    \\n        int n=arr.size();\\n        long long right = n-1, ans = 0;\\n \\n        while (right > 0) {\\n            // finding starting point of range\\n            long long strt = lower_bound(arr.begin(), arr .end(),l - arr[right])-arr.begin();\\n\\n            // finding ending point of range\\n            auto it2 = upper_bound(arr.begin(), arr .end(), r - arr[right]);\\n            --it2;\\n            long long end = it2 - arr.begin();\\n\\n            end = min(end, right - 1);\\n\\n            // adding length of the range to our final answer.\\n            if (end - strt >= 0)\\n                ans += (end - strt + 1);\\n            \\n            right--;\\n        }\\n        return ans;\\n    }\\n    \\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans = countPairSum(nums,lower,upper);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairSum(vector<int>& arr,int l,int r){\\n        sort(arr.begin(),arr.end());    \\n        int n=arr.size();\\n        long long right = n-1, ans = 0;\\n \\n        while (right > 0) {\\n            // finding starting point of range\\n            long long strt = lower_bound(arr.begin(), arr .end(),l - arr[right])-arr.begin();\\n\\n            // finding ending point of range\\n            auto it2 = upper_bound(arr.begin(), arr .end(), r - arr[right]);\\n            --it2;\\n            long long end = it2 - arr.begin();\\n\\n            end = min(end, right - 1);\\n\\n            // adding length of the range to our final answer.\\n            if (end - strt >= 0)\\n                ans += (end - strt + 1);\\n            \\n            right--;\\n        }\\n        return ans;\\n    }\\n    \\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans = countPairSum(nums,lower,upper);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174098,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\nll bsLow(const vi(int)&v, ll it, ll l, ll r){\\n    ll ans=-1;\\n    while(l<=r){\\n        ll m=l+((r-l)>>1);\\n        if(v[m]<it){\\n            l=m+1;\\n        }\\n        else{\\n            ans=m, r=m-1;\\n        }\\n    }\\n    return ans;\\n}\\n\\nll bsHigh(const vi(int)&v, ll it, ll l, ll r){\\n    ll ans=-1;\\n    while(l<=r){\\n        ll m=l+((r-l)>>1);\\n        if(v[m]>it){\\n            r=m-1;\\n        }\\n        else{\\n            ans=m, l=m+1;\\n        }\\n    }\\n    return ans;\\n}\\n\\nlong long countFairPairs(vector<int>&v, int low, int high) {\\n    sort(begin(v), end(v));\\n    ll ans=0, n=v.size();\\n    for(ll i=0;i<n;++i){\\n        ll l=low-v[i], r=high-v[i];\\n        ll lIn=bsLow(v, l, 0, i-1), rIn=bsHigh(v, r, 0, i-1);\\n        if(!(lIn==-1  || rIn==-1 || lIn>rIn)){\\n            ans+=rIn-lIn+1;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\nll bsLow(const vi(int)&v, ll it, ll l, ll r){\\n    ll ans=-1;\\n    while(l<=r){\\n        ll m=l+((r-l)>>1);\\n        if(v[m]<it){\\n            l=m+1;\\n        }\\n        else{\\n            ans=m, r=m-1;\\n        }\\n    }\\n    return ans;\\n}\\n\\nll bsHigh(const vi(int)&v, ll it, ll l, ll r){\\n    ll ans=-1;\\n    while(l<=r){\\n        ll m=l+((r-l)>>1);\\n        if(v[m]>it){\\n            r=m-1;\\n        }\\n        else{\\n            ans=m, l=m+1;\\n        }\\n    }\\n    return ans;\\n}\\n\\nlong long countFairPairs(vector<int>&v, int low, int high) {\\n    sort(begin(v), end(v));\\n    ll ans=0, n=v.size();\\n    for(ll i=0;i<n;++i){\\n        ll l=low-v[i], r=high-v[i];\\n        ll lIn=bsLow(v, l, 0, i-1), rIn=bsHigh(v, r, 0, i-1);\\n        if(!(lIn==-1  || rIn==-1 || lIn>rIn)){\\n            ans+=rIn-lIn+1;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797141,
                "title": "binary-search-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) \\n    {\\n        sort(nums.begin(), nums.end());\\n        long long ans=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            int x=lower_bound(nums.begin()+i+1, nums.end(), lower-nums[i])-nums.begin()+i;\\n            int y=upper_bound(nums.begin()+i+1, nums.end(), upper-nums[i])-nums.begin()+i;\\n            ans+=(y-x);\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) \\n    {\\n        sort(nums.begin(), nums.end());\\n        long long ans=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            int x=lower_bound(nums.begin()+i+1, nums.end(), lower-nums[i])-nums.begin()+i;\\n            int y=upper_bound(nums.begin()+i+1, nums.end(), upper-nums[i])-nums.begin()+i;\\n            ans+=(y-x);\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748278,
                "title": "clean-and-easy-implementation-using-upper-bound-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& nums, int x){\\n        int n = nums.size();\\n        long long ans = 0;\\n        for(int i=0; i<n; i++){\\n            int id = upper_bound(nums.begin()+i+1, nums.end(),x-nums[i]) - nums.begin();\\n            ans += (id - i);\\n        }\\n        return ans;\\n    }\\n\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        return solve(nums,upper) - solve(nums,lower-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& nums, int x){\\n        int n = nums.size();\\n        long long ans = 0;\\n        for(int i=0; i<n; i++){\\n            int id = upper_bound(nums.begin()+i+1, nums.end(),x-nums[i]) - nums.begin();\\n            ans += (id - i);\\n        }\\n        return ans;\\n    }\\n\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        return solve(nums,upper) - solve(nums,lower-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393969,
                "title": "sort-and-binary-search-beginner-friendly",
                "content": "# Intuition\\nsort the array \\n**for each element find the first element  such that  sum of both >=lower**\\n**for each element find the last element  such that  sum of both \\n<=upper**\\nBy this way we will be able to cover all the possible  indices\\n# Approach\\nPls upvote if you find it helpful!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) \\n    {\\n       long long  int res = 0 ; \\n        sort(nums.begin(),nums.end());\\n\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n           long long  int l = i+1 ,  h = nums.size()-1 , mid ,firstlower =-1 , lastupper =-1;\\n            // finding first element  nums[mid] + nums[i]>=lower\\n            while(l<=h)\\n            {\\n                mid = (l+h)/2;\\n                if(nums[mid] + nums[i]>=lower)\\n                {\\n                    firstlower = mid; \\n                    h = mid -1;\\n                }\\n                else l = mid + 1;\\n            }\\n\\n            l= i+1;\\n            h = nums.size()-1 ;\\n            // finding last element  nums[mid] + nums[i]<=upper\\n            while(l<=h)\\n            {\\n                mid = (l+h)/2;\\n                if(nums[mid] + nums[i]<=upper)\\n                {\\n                  lastupper = mid; \\n                    l = mid  +1;\\n                }\\n                else h = mid -  1;\\n            }\\n            if(firstlower != -1 && lastupper !=-1)\\n            res += lastupper - firstlower + 1; \\n        }\\n        \\n  \\n\\n        return res ; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) \\n    {\\n       long long  int res = 0 ; \\n        sort(nums.begin(),nums.end());\\n\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n           long long  int l = i+1 ,  h = nums.size()-1 , mid ,firstlower =-1 , lastupper =-1;\\n            // finding first element  nums[mid] + nums[i]>=lower\\n            while(l<=h)\\n            {\\n                mid = (l+h)/2;\\n                if(nums[mid] + nums[i]>=lower)\\n                {\\n                    firstlower = mid; \\n                    h = mid -1;\\n                }\\n                else l = mid + 1;\\n            }\\n\\n            l= i+1;\\n            h = nums.size()-1 ;\\n            // finding last element  nums[mid] + nums[i]<=upper\\n            while(l<=h)\\n            {\\n                mid = (l+h)/2;\\n                if(nums[mid] + nums[i]<=upper)\\n                {\\n                  lastupper = mid; \\n                    l = mid  +1;\\n                }\\n                else h = mid -  1;\\n            }\\n            if(firstlower != -1 && lastupper !=-1)\\n            res += lastupper - firstlower + 1; \\n        }\\n        \\n  \\n\\n        return res ; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359061,
                "title": "sorting-binary-search-python-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        cnt = 0\\n        for i in range(len(nums)-1, -1, -1):\\n            x = nums[i]\\n            lo = bisect_left(nums, lower - x, 0, i)\\n            hi = bisect_right(nums, upper - x, 0, i)\\n            cnt += hi - lo\\n        return cnt \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        cnt = 0\\n        for i in range(len(nums)-1, -1, -1):\\n            x = nums[i]\\n            lo = bisect_left(nums, lower - x, 0, i)\\n            hi = bisect_right(nums, upper - x, 0, i)\\n            cnt += hi - lo\\n        return cnt \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189582,
                "title": "python-elegant-short-two-lines-bisect-in-place",
                "content": "```\\nfrom bisect import bisect, bisect_left\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \"\"\"\\n    Time:   O(sort)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        return sum(\\n            bisect(nums, upper - num, hi=i) - bisect_left(nums, lower - num, hi=i)\\n            for i, num in enumerate(nums)\\n        )\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nfrom bisect import bisect, bisect_left\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \"\"\"\\n    Time:   O(sort)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        return sum(\\n            bisect(nums, upper - num, hi=i) - bisect_left(nums, lower - num, hi=i)\\n            for i, num in enumerate(nums)\\n        )\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178103,
                "title": "swift-two-pointers-9-sloc",
                "content": "**Two Pointers (accepted answer)**\\n```\\nclass Solution {\\n    func countFairPairs(_ nums: [Int], _ lower: Int, _ upper: Int) -> Int {\\n        let nums = nums.sorted()\\n        var result = 0, left = 0, rightL = nums.count-1, rightU = rightL\\n        while left < max(rightL, rightU) {\\n            while left < rightU && upper < nums[left] + nums[rightU] { rightU -= 1 }\\n            while left < rightL && lower <= nums[left] + nums[rightL] { rightL -= 1 }\\n            result += max(rightU-left, 0) - max(rightL-left, 0)\\n            left += 1\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countFairPairs(_ nums: [Int], _ lower: Int, _ upper: Int) -> Int {\\n        let nums = nums.sorted()\\n        var result = 0, left = 0, rightL = nums.count-1, rightU = rightL\\n        while left < max(rightL, rightU) {\\n            while left < rightU && upper < nums[left] + nums[rightU] { rightU -= 1 }\\n            while left < rightL && lower <= nums[left] + nums[rightL] { rightL -= 1 }\\n            result += max(rightU-left, 0) - max(rightL-left, 0)\\n            left += 1\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177402,
                "title": "two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Calculate the no. of pairs which have sum of pairs less then or equal to upper\\n- Calculate the no. of pairs which have sum of pairs less then or equal to lower-1\\n- result= calculation of upper - calculation of lower-1\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointer \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long helper(vector<int>& nums,int val){\\n        long long res=0;\\n        for (int i = 0, j = nums.size() - 1; i < j; ++i) {\\n            while(i < j && nums[i] + nums[j] > val){\\n                --j;\\n            }\\n            res += j - i;\\n        }     \\n        return res;\\n    }\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long cnt=0;\\n        sort(nums.begin(),nums.end());\\n        return helper(nums,upper)-helper(nums,lower-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(vector<int>& nums,int val){\\n        long long res=0;\\n        for (int i = 0, j = nums.size() - 1; i < j; ++i) {\\n            while(i < j && nums[i] + nums[j] > val){\\n                --j;\\n            }\\n            res += j - i;\\n        }     \\n        return res;\\n    }\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long cnt=0;\\n        sort(nums.begin(),nums.end());\\n        return helper(nums,upper)-helper(nums,lower-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177025,
                "title": "the-simplest-solution-binary-search-with-intervals-python",
                "content": "****Bold****# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport bisect\\n\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n\\n        ans = 0\\n        for i in range(n):\\n            l = bisect.bisect_left(nums, lower-nums[i], i+1, n)\\n            r = bisect.bisect_right(nums, upper-nums[i], i+1, n)\\n\\n            ans += r-l\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport bisect\\n\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n\\n        ans = 0\\n        for i in range(n):\\n            l = bisect.bisect_left(nums, lower-nums[i], i+1, n)\\n            r = bisect.bisect_right(nums, upper-nums[i], i+1, n)\\n\\n            ans += r-l\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176071,
                "title": "lower-bound-and-upper-bound",
                "content": "**No need of check whether i<j because nums[i]+nums[j] == nums[j]+nums[i]\\nReduces the condition to i!=j**\\n\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int l=lower-nums[i];\\n            int h=upper-nums[i];\\n            auto a = lower_bound(nums.begin()+i+1,nums.end(),l);\\n            auto b = upper_bound(nums.begin()+i+1,nums.end(),h);\\n            ans+=b-a;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "**No need of check whether i<j because nums[i]+nums[j] == nums[j]+nums[i]\\nReduces the condition to i!=j**\\n\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int l=lower-nums[i];\\n            int h=upper-nums[i];\\n            auto a = lower_bound(nums.begin()+i+1,nums.end(),l);\\n            auto b = upper_bound(nums.begin()+i+1,nums.end(),h);\\n            ans+=b-a;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3175813,
                "title": "javascript-easy-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: O(n(logn))\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} lower\\n * @param {number} upper\\n * @return {number}\\n */\\nvar countFairPairs = function(nums, lower, upper) {\\n    nums.sort((a, b) => a - b);\\n    const countless = (val) => {\\n        let res = 0;\\n        for (let i = 0, j = nums.length - 1; i < j; ++i) {\\n            while (i < j && nums[i] + nums[j] > val) --j;\\n            res += j - i;\\n        }\\n        return res;\\n    };\\n    return countless(upper) - countless(lower - 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} lower\\n * @param {number} upper\\n * @return {number}\\n */\\nvar countFairPairs = function(nums, lower, upper) {\\n    nums.sort((a, b) => a - b);\\n    const countless = (val) => {\\n        let res = 0;\\n        for (let i = 0, j = nums.length - 1; i < j; ++i) {\\n            while (i < j && nums[i] + nums[j] > val) --j;\\n            res += j - i;\\n        }\\n        return res;\\n    };\\n    return countless(upper) - countless(lower - 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3175393,
                "title": "easy-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we are only required to find the number of pairs and not the pairs, therefore we can sort the vector without thinking of any index related issue. Now you have to find pairs whose sum lies in between of upper and lower. And to find the sum of pairs first thing that comes to mind is 2 pointer approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we\\'ll find the number of pairs whose sum is less than or equal to \\'upper\\'. And then find the number if pairs whose sum is less than or equal to \\'lower-1\\'. The difference of the two will be the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN) for the sort, O(N) for first(upper) loop, O(N) for second(lower) loop.\\n\\n- Space complexity:\\nO(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        \\n        sort(nums.begin(), nums.end());\\n        int i=0, j=nums.size()-1;\\n        //upper\\n        long long up=0;\\n        while(i<j){\\n            if (nums[i]+nums[j] <= upper){\\n                up += (j-i); \\n                i++;\\n            }\\n            else if (nums[i]+nums[j] > upper){\\n                j--;\\n            }\\n        }\\n\\n        //lower\\n        long long lo=0;\\n        i=0; \\n        j=nums.size()-1;\\n        while(i<=j){\\n            if (nums[i]+nums[j] <= lower-1){\\n                lo += (j-i);\\n                i++;\\n            }\\n            else if (nums[i]+nums[j] > lower-1){\\n                j--;\\n            }\\n        }\\n        return up-lo;\\n    }\\n\\n};\\n```\\n\\nIf you understood the question please upvote it.\\n\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        \\n        sort(nums.begin(), nums.end());\\n        int i=0, j=nums.size()-1;\\n        //upper\\n        long long up=0;\\n        while(i<j){\\n            if (nums[i]+nums[j] <= upper){\\n                up += (j-i); \\n                i++;\\n            }\\n            else if (nums[i]+nums[j] > upper){\\n                j--;\\n            }\\n        }\\n\\n        //lower\\n        long long lo=0;\\n        i=0; \\n        j=nums.size()-1;\\n        while(i<=j){\\n            if (nums[i]+nums[j] <= lower-1){\\n                lo += (j-i);\\n                i++;\\n            }\\n            else if (nums[i]+nums[j] > lower-1){\\n                j--;\\n            }\\n        }\\n        return up-lo;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175254,
                "title": "easy-c-solution-upper-bound-and-lower-bound",
                "content": "## Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans=0;\\n        sort(nums.begin(),nums.end());\\n        for (int i=0; i<nums.size(); i++){\\n            int v1= lower-nums[i];\\n            int v2= upper-nums[i];\\n            int x= lower_bound(nums.begin()+i+1,nums.end(),v1)-nums.begin()-i-1-1;\\n            int y= upper_bound(nums.begin()+i+1,nums.end(),v2)-nums.begin()-i-1-1;\\n            ans+= (y-x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans=0;\\n        sort(nums.begin(),nums.end());\\n        for (int i=0; i<nums.size(); i++){\\n            int v1= lower-nums[i];\\n            int v2= upper-nums[i];\\n            int x= lower_bound(nums.begin()+i+1,nums.end(),v1)-nums.begin()-i-1-1;\\n            int y= upper_bound(nums.begin()+i+1,nums.end(),v2)-nums.begin()-i-1-1;\\n            ans+= (y-x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175136,
                "title": "java-sorting-treemap-ordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOnce you sort the array, for every number in the array, you just have to know the minimum number that you have to add to make it atleast the lower value, and maximum number you have to add to make it atmost the upper value.\\n\\nTreeMap can be useful here if you are fine with $$O(n)$$ space.\\nIf you store key as the number and value as it\\'s index, then you can ask treemap to find indices for min and max numbers that can be added to a number.\\n\\nOnce you find indices you just add the difference between them to the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the Array. \\nAdd `-Infinity` as index `-1` to the treeMap.\\nGo through each number, calculate `min and max additions` you can do to the current number.\\n\\nFind the `leftmost index of minAdd`, but notice that because of duplicates you might ovveride a number\\'s index. So better to find the index of the previous number. So search for `minAdd-1` it will give you the rightmost index of immediate previous number.\\n\\nFind the `rightmost index of maxAdd`.\\nAdd `right-left` to the answer. This is the number of integers that exist between these indices.\\n\\nStore index of current number.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n*logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        long ans = 0;\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>();\\n        treeMap.put(Integer.MIN_VALUE, -1);\\n\\n        Arrays.sort(nums);\\n\\n        for(int i=0;i<nums.length;i++){\\n            int x = nums[i];\\n            int minAdd = lower - x;\\n            int maxAdd = upper - x;\\n            \\n            int left = treeMap.floorEntry(minAdd-1).getValue();\\n            int right = treeMap.floorEntry(maxAdd).getValue();\\n            ans += right-left;\\n\\n            treeMap.put(x, i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sort",
                    "Tree",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        long ans = 0;\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>();\\n        treeMap.put(Integer.MIN_VALUE, -1);\\n\\n        Arrays.sort(nums);\\n\\n        for(int i=0;i<nums.length;i++){\\n            int x = nums[i];\\n            int minAdd = lower - x;\\n            int maxAdd = upper - x;\\n            \\n            int left = treeMap.floorEntry(minAdd-1).getValue();\\n            int right = treeMap.floorEntry(maxAdd).getValue();\\n            ans += right-left;\\n\\n            treeMap.put(x, i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175093,
                "title": "python-java-simple-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countFairPairs(self, nums, lower, upper):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type lower: int\\n        :type upper: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        nums.sort()\\n        result=0\\n        start,end=len(nums)-1,len(nums)-1\\n        for i in range(len(nums)):\\n            while end >=0 and nums[i]+nums[end]>upper:\\n                end-=1\\n            while start>=0 and nums[i]+nums[start]>=lower:\\n                start-=1\\n            if(start < i and end >= i):\\n                result+=end-start-1\\n            else:\\n                result+=end-start\\n        return result/2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countFairPairs(self, nums, lower, upper):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type lower: int\\n        :type upper: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        nums.sort()\\n        result=0\\n        start,end=len(nums)-1,len(nums)-1\\n        for i in range(len(nums)):\\n            while end >=0 and nums[i]+nums[end]>upper:\\n                end-=1\\n            while start>=0 and nums[i]+nums[start]>=lower:\\n                start-=1\\n            if(start < i and end >= i):\\n                result+=end-start-1\\n            else:\\n                result+=end-start\\n        return result/2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174783,
                "title": "yes-you-will-get-tle-but-47-51",
                "content": "Yes! You will get tle in this. :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long n=nums.size(), count=0;\\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                if((nums[i]+nums[j]>=lower) && (nums[i]+nums[j]<=upper)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long n=nums.size(), count=0;\\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                if((nums[i]+nums[j]>=lower) && (nums[i]+nums[j]<=upper)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174534,
                "title": "simple-c-solution",
                "content": "# Code \\n\\n### 1.Binary Search\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());     \\n        long long sum = 0;\\n        int j=1,k=nums.size()-1;\\n        for(int i=0;i<nums.size();i++){\\n            j = lower_bound(nums.begin() + i + 1, nums.end(), lower - nums[i]) - nums.begin(); \\n            k = upper_bound(nums.begin() + i + 1, nums.end(), upper - nums[i]) - nums.begin();\\n            if(j <= k)\\n                sum += k-j;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n\\n### 2.TLE\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1,k=nums.size()-1;\\n        long long sum = 0;\\n        while(i<nums.size()){\\n            while(k>=0 && nums[i]+nums[k] > upper)\\n                k--;\\n            while(j<nums.size() && nums[i]+nums[j] < lower)\\n                j++;\\n            if(j <= k){\\n                sum += k-j+1;\\n            }\\n            i++,j=i+1;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());     \\n        long long sum = 0;\\n        int j=1,k=nums.size()-1;\\n        for(int i=0;i<nums.size();i++){\\n            j = lower_bound(nums.begin() + i + 1, nums.end(), lower - nums[i]) - nums.begin(); \\n            k = upper_bound(nums.begin() + i + 1, nums.end(), upper - nums[i]) - nums.begin();\\n            if(j <= k)\\n                sum += k-j;\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1,k=nums.size()-1;\\n        long long sum = 0;\\n        while(i<nums.size()){\\n            while(k>=0 && nums[i]+nums[k] > upper)\\n                k--;\\n            while(j<nums.size() && nums[i]+nums[j] < lower)\\n                j++;\\n            if(j <= k){\\n                sum += k-j+1;\\n            }\\n            i++,j=i+1;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174528,
                "title": "c-sorting-2-pointer-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long left=0;\\n        int right=0;\\n        int s=0,e=nums.size()-1;\\n        sort(nums.begin(),nums.end());\\n        while(s<e)\\n        {\\n            if(nums[s]+nums[e]<=upper)\\n            {\\n                left=left+(e-s);\\n                s++;\\n            }\\n            else\\n            {\\n                e--;\\n            }\\n        }\\n        s=0,e=nums.size()-1;\\n         while(s<e)\\n        {\\n            if(nums[s]+nums[e]<lower)\\n            {\\n                left-=e-s;\\n                s++;\\n            }\\n            else\\n            {\\n                e--;\\n            }\\n        }\\n        return left;;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long left=0;\\n        int right=0;\\n        int s=0,e=nums.size()-1;\\n        sort(nums.begin(),nums.end());\\n        while(s<e)\\n        {\\n            if(nums[s]+nums[e]<=upper)\\n            {\\n                left=left+(e-s);\\n                s++;\\n            }\\n            else\\n            {\\n                e--;\\n            }\\n        }\\n        s=0,e=nums.size()-1;\\n         while(s<e)\\n        {\\n            if(nums[s]+nums[e]<lower)\\n            {\\n                left-=e-s;\\n                s++;\\n            }\\n            else\\n            {\\n                e--;\\n            }\\n        }\\n        return left;;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174515,
                "title": "sorting-binary-search-self-explanatory-solution-in-rust",
                "content": "# Intuition\\nReordering elements in the input array doesn\\'t change number of pairs giving us a sum in the specified $$[lower, upper]$$ interval. So we can sort array first without affecting result.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n\\\\cdot \\\\log (n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_fair_pairs(mut nums: Vec<i32>, lower: i32, upper: i32) -> i64 {\\n        nums.sort_unstable();\\n        let mut ans = 0i64;\\n        for (idx, num) in nums.iter().copied().enumerate() {\\n            let l_bound = nums[idx+1..].partition_point(|&n| n+num < lower);\\n            let u_bound = nums[idx+1..].partition_point(|&n| n+num <= upper);\\n            ans += (u_bound - l_bound) as i64;\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_fair_pairs(mut nums: Vec<i32>, lower: i32, upper: i32) -> i64 {\\n        nums.sort_unstable();\\n        let mut ans = 0i64;\\n        for (idx, num) in nums.iter().copied().enumerate() {\\n            let l_bound = nums[idx+1..].partition_point(|&n| n+num < lower);\\n            let u_bound = nums[idx+1..].partition_point(|&n| n+num <= upper);\\n            ans += (u_bound - l_bound) as i64;\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3174502,
                "title": "c-binary-search-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long countFairPairs(vector<int>& nums, int lower, int upper) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            \\n            int idx1=lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i])-nums.begin();\\n            int idx2=upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i])-nums.begin();\\n            \\n            ans+=idx2-idx1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nvotrubac solution\\n```\\nclass Solution {\\npublic:\\n        long long countLess(vector<int>& nums, int val) {\\n            long long res = 0;\\n            for (int i = 0, j = nums.size() - 1; i < j; ++i) {\\n                while(i < j && nums[i] + nums[j] >= lower)\\n                    --j;\\n                res += j - i;\\n            }        \\n            return res;\\n        }\\n        long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n            sort(begin(nums), end(nums));\\n            return countLess(nums, upper) - countLess(nums, lower + 1);\\n        }\\n};\\n```\\nIf you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long countFairPairs(vector<int>& nums, int lower, int upper) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            \\n            int idx1=lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i])-nums.begin();\\n            int idx2=upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i])-nums.begin();\\n            \\n            ans+=idx2-idx1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n        long long countLess(vector<int>& nums, int val) {\\n            long long res = 0;\\n            for (int i = 0, j = nums.size() - 1; i < j; ++i) {\\n                while(i < j && nums[i] + nums[j] >= lower)\\n                    --j;\\n                res += j - i;\\n            }        \\n            return res;\\n        }\\n        long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n            sort(begin(nums), end(nums));\\n            return countLess(nums, upper) - countLess(nums, lower + 1);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174387,
                "title": "pop-tail-before-each-binary-search-o-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search lower, and upper\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPop tail, so it will not count itself.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        A = nums\\n        A.sort()\\n        n = len(A)\\n        ans = 0\\n\\n        for i in range(n-1, -1, -1):\\n            v = A.pop()\\n            a = bisect_left(A, lower - v)\\n            b = bisect_right(A, upper - v)\\n\\n            ans += b - a\\n        \\n        return ans\\n```\\n\\nThe version without pop(), or virtual pop.  :)\\n\\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        A = nums\\n        A.sort()\\n        print(A)\\n        n = len(A)\\n        ans = 0\\n        for i in range(n-1, -1, -1):\\n            v = A[i]\\n            a = bisect_left(A, lower - v, lo=0, hi=i)\\n            b = bisect_right(A, upper - v, lo=0, hi=i)\\n\\n            ans += b - a\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        A = nums\\n        A.sort()\\n        n = len(A)\\n        ans = 0\\n\\n        for i in range(n-1, -1, -1):\\n            v = A.pop()\\n            a = bisect_left(A, lower - v)\\n            b = bisect_right(A, upper - v)\\n\\n            ans += b - a\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        A = nums\\n        A.sort()\\n        print(A)\\n        n = len(A)\\n        ans = 0\\n        for i in range(n-1, -1, -1):\\n            v = A[i]\\n            a = bisect_left(A, lower - v, lo=0, hi=i)\\n            b = bisect_right(A, upper - v, lo=0, hi=i)\\n\\n            ans += b - a\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174380,
                "title": "simple-sorting-and-searching-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsorting and searching\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.sort the array\\n2.use lower bound and upper bound to find range of nums between lower and upper number\\n3.return ans\\n\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int l, int u) {\\n        long long ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n                int lb=lower_bound(nums.begin(),nums.end(),l-nums[i])-nums.begin();\\n                int ub=upper_bound(nums.begin(),nums.end(),u-nums[i])-nums.begin()-1;\\n                if(lb<=i)lb=i+1;\\n                if(ub<i)ub=i;\\n                if(ub>=lb)ans+=ub-lb+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int l, int u) {\\n        long long ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n                int lb=lower_bound(nums.begin(),nums.end(),l-nums[i])-nums.begin();\\n                int ub=upper_bound(nums.begin(),nums.end(),u-nums[i])-nums.begin()-1;\\n                if(lb<=i)lb=i+1;\\n                if(ub<i)ub=i;\\n                if(ub>=lb)ans+=ub-lb+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174277,
                "title": "c-sorting-three-pointer-tc-o-nlogn-sc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int l, int u) {\\n        sort(nums.begin(), nums.end());\\n        long long ans=0;\\n        int i=nums.size()-1, j= nums.size()-1;\\n        for(int k=0; k<nums.size(); k++){\\n            while(j>=0 && nums[k]+nums[j]>u) j--;\\n            if(i>=k)\\n            while(i>=0 && nums[k]+nums[i]>=l) i--;\\n            i= max(i,k);\\n            if(i>=0 && j>=0){\\n                ans+= (j-i>0)?j-i:0;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int l, int u) {\\n        sort(nums.begin(), nums.end());\\n        long long ans=0;\\n        int i=nums.size()-1, j= nums.size()-1;\\n        for(int k=0; k<nums.size(); k++){\\n            while(j>=0 && nums[k]+nums[j]>u) j--;\\n            if(i>=k)\\n            while(i>=0 && nums[k]+nums[i]>=l) i--;\\n            i= max(i,k);\\n            if(i>=0 && j>=0){\\n                ans+= (j-i>0)?j-i:0;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174215,
                "title": "c-binary-search-supermacy-easy-full-explanation",
                "content": "Brute Force : O(n^2) solution \\n```\\nfor(i->n)\\nfor(j:i+1 ->n){\\nif(i+j <= upper && i+j >= lower) cnt++\\n}\\nreturn cnt\\n```\\n \\uD83D\\uDE23 This gives this TLE. \\uD83E\\uDD7A\\uD83E\\uDD7A\\n\\nNow for 10^5 constraint n log n works !!!\\n\\nn log n ->>>>>> sorting and binary search\\n\\nNow intuition : \\n1. Sort the array.\\n2. For every value we have to find the range , for which the selected num and each num in range follows the given condition :\\n ```\\n lower <= num[i] + for each n in range <=upper\\n ```\\n 3. Now how to find the range !!\\n 4. Simple Lower bound and upper Bound. For every value in nums find lower bound and upper bound for nums[i] - lower value as val parameter ( *lowerbound(first iterator, last iterator , val*)\\n 5. Add the value lowerbound - upperbound + 1 in the ans if(lower bound < =upperbound)\\n \\n **Code**\\n ```\\n class Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        int n = nums.size();\\n        long long cnt = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<n;++i){\\n            int l = lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i])-nums.begin();\\n            int r = upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i])-nums.begin()-1;\\n            if(l<=r){\\n                cnt+=r-l+1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nfor(i->n)\\nfor(j:i+1 ->n){\\nif(i+j <= upper && i+j >= lower) cnt++\\n}\\nreturn cnt\\n```\n```\\n lower <= num[i] + for each n in range <=upper\\n ```\n```\\n class Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        int n = nums.size();\\n        long long cnt = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<n;++i){\\n            int l = lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i])-nums.begin();\\n            int r = upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i])-nums.begin()-1;\\n            if(l<=r){\\n                cnt+=r-l+1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174093,
                "title": "java-sorting-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long result = 0;\\n        for(int i = 0; i < n-1; i++){\\n            long lowSum = lower - nums[i];\\n            long highSum = upper - nums[i];\\n            int count1 = lowerBound(i+1, n, nums, lowSum);\\n            int count2 = upperBound(i+1, n, nums, highSum);\\n            result += (count2 - count1);\\n        }\\n        return result;\\n    }\\n    \\n    private int lowerBound(int start, int end, int[] nums, long key){\\n        while(start < end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] < key){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n    \\n    private int upperBound(int start, int end, int[] nums, long key){\\n        while(start < end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] <= key){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long result = 0;\\n        for(int i = 0; i < n-1; i++){\\n            long lowSum = lower - nums[i];\\n            long highSum = upper - nums[i];\\n            int count1 = lowerBound(i+1, n, nums, lowSum);\\n            int count2 = upperBound(i+1, n, nums, highSum);\\n            result += (count2 - count1);\\n        }\\n        return result;\\n    }\\n    \\n    private int lowerBound(int start, int end, int[] nums, long key){\\n        while(start < end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] < key){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n    \\n    private int upperBound(int start, int end, int[] nums, long key){\\n        while(start < end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] <= key){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174084,
                "title": "easy-approach-using-lower-and-upper-bound-concept-o-nlogn",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n        long long low = lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i])-nums.begin();\\n            \\n        long long up = upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i])-nums.begin();\\n            \\n        cnt += up-low;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n        long long low = lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i])-nums.begin();\\n            \\n        long long up = upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i])-nums.begin();\\n            \\n        cnt += up-low;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174045,
                "title": "c-bs-on-lower-and-upper",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            int l = i+1,r=nums.size()-1;\\n            int x=0,xx=0;\\n            while(l<=r){\\n                int mid = l + (r-l)/2;\\n                if(nums[mid]+nums[i]<lower){\\n                    l = mid+1;\\n                }else{\\n                    r = mid-1;\\n                }\\n            }\\n            x=l;\\n            l=i+1,r=nums.size()-1;\\n            while(l<r){\\n                int mid = l + (r-l)/2;\\n                if(nums[i]+nums[mid]>upper){\\n                    r = mid-1;\\n                }else{\\n                    l = mid+1;\\n                }\\n            }\\n            xx=l;\\n            int n = nums.size();\\n            if(xx>=0 && x>=0 && xx<n && x<n){\\n                if(nums[i]+nums[x]>=lower && nums[xx]+nums[i]<=upper){\\n                    ans += (xx-x+1);\\n                }else if(nums[i]+nums[x]>=lower && nums[xx-1]+nums[i]<=upper){\\n                    ans += (xx-x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            int l = i+1,r=nums.size()-1;\\n            int x=0,xx=0;\\n            while(l<=r){\\n                int mid = l + (r-l)/2;\\n                if(nums[mid]+nums[i]<lower){\\n                    l = mid+1;\\n                }else{\\n                    r = mid-1;\\n                }\\n            }\\n            x=l;\\n            l=i+1,r=nums.size()-1;\\n            while(l<r){\\n                int mid = l + (r-l)/2;\\n                if(nums[i]+nums[mid]>upper){\\n                    r = mid-1;\\n                }else{\\n                    l = mid+1;\\n                }\\n            }\\n            xx=l;\\n            int n = nums.size();\\n            if(xx>=0 && x>=0 && xx<n && x<n){\\n                if(nums[i]+nums[x]>=lower && nums[xx]+nums[i]<=upper){\\n                    ans += (xx-x+1);\\n                }else if(nums[i]+nums[x]>=lower && nums[xx-1]+nums[i]<=upper){\\n                    ans += (xx-x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988538,
                "title": "easiest-solution-using-sorting-lower-and-upper-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& v, int lower, int upper) {\\n        long long ans=0;\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++){\\n            int l=lower-v[i];\\n            int r=upper-v[i];\\n\\n            int l1=lower_bound(v.begin()+i+1, v.end(), l)-v.begin();\\n            int u1=upper_bound(v.begin()+i+1, v.end(), r)-v.begin();\\n            //return u1;\\n            ans+=u1-l1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& v, int lower, int upper) {\\n        long long ans=0;\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++){\\n            int l=lower-v[i];\\n            int r=upper-v[i];\\n\\n            int l1=lower_bound(v.begin()+i+1, v.end(), l)-v.begin();\\n            int u1=upper_bound(v.begin()+i+1, v.end(), r)-v.begin();\\n            //return u1;\\n            ans+=u1-l1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988214,
                "title": "c-solution-tc-o-nlogn-simple-lower-bound-and-upper-bound",
                "content": "# Intuition\\n->lower <= nums[i]+nums[j] <= upper\\n->lower - nums[i] <= nums[j] <= upper - nums[i]\\n->To find the upper and lower bound we should sort the array\\n->As of the condition i < j, the lower bound should not point to the previous elements of the current element\\n->Example : nums = [0,1,7,4,4,5]\\nsorted nums = [0,1,4,4,5,7]\\nlower = 3 and upper = 6\\nfor element 4, 3-4 <= nums[j] <= 6-4\\n-1 <= nums[j] <= 2 so, for element 4 the lower_bound is 0 and upper_bound is 4 and they are pointing before the current element i.e, 4 where i < j condition violates.\\nSo, to avoid this we remove the first elemnt before performing lowe and upper bound\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        // lower - nums[i] <= nums[j] <= upper - nums[i]\\n        //To find the upper and lowe bound we should sort the array\\n        //As of the condition i < j, the lower and upper bound should not point to the previous elements of the current element \\n\\n        long long ans = 0;\\n        sort(nums.begin(), nums.end());\\n        deque<long long> dq;\\n        for(auto i:nums) dq.push_back(i);\\n        \\n        for(int i=0;i<nums.size();i++) {\\n            dq.pop_front(); // To satisfy i < j condition as i said earlier\\n\\n            auto low = lower_bound(dq.begin(), dq.end(), lower - nums[i]);  // lower - nums[i] <= nums[j] <= upper - nums[i]\\n            auto high =  upper_bound(dq.begin(), dq.end(), upper - nums[i]);\\n\\n            ans += (high - low); //Difference between high to low gives us the numbers in range\\n\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![leetupvote.png](https://assets.leetcode.com/users/images/6bcdddf6-00ec-4ffd-bb53-413c813e8d9e_1695018353.158166.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        // lower - nums[i] <= nums[j] <= upper - nums[i]\\n        //To find the upper and lowe bound we should sort the array\\n        //As of the condition i < j, the lower and upper bound should not point to the previous elements of the current element \\n\\n        long long ans = 0;\\n        sort(nums.begin(), nums.end());\\n        deque<long long> dq;\\n        for(auto i:nums) dq.push_back(i);\\n        \\n        for(int i=0;i<nums.size();i++) {\\n            dq.pop_front(); // To satisfy i < j condition as i said earlier\\n\\n            auto low = lower_bound(dq.begin(), dq.end(), lower - nums[i]);  // lower - nums[i] <= nums[j] <= upper - nums[i]\\n            auto high =  upper_bound(dq.begin(), dq.end(), upper - nums[i]);\\n\\n            ans += (high - low); //Difference between high to low gives us the numbers in range\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957996,
                "title": "count-the-number-of-fair-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        return countLess(nums, upper) - countLess(nums, lower - 1);\\n  }\\n\\n  private long countLess(int[] nums, int sum) {\\n    long res = 0;\\n    for (int i = 0, j = nums.length - 1; i < j; ++i) {\\n      while (i < j && nums[i] + nums[j] > sum)\\n        --j;\\n      res += j - i;\\n    }\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        return countLess(nums, upper) - countLess(nums, lower - 1);\\n  }\\n\\n  private long countLess(int[] nums, int sum) {\\n    long res = 0;\\n    for (int i = 0, j = nums.length - 1; i < j; ++i) {\\n      while (i < j && nums[i] + nums[j] > sum)\\n        --j;\\n      res += j - i;\\n    }\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955206,
                "title": "o-n-log-n-time-o-n-space-clear-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/b0e80d89-bf41-436f-9bf6-e23974d646e9_1692895574.4367921.png)\\n\\n    def countFairPairs(self, nums: list[int], lower: int, upper: int) -> int:\\n        fn = lambda x: sum(bisect.bisect_right(nums, x - n, hi=i) for i, n in enumerate(nums))\\n        nums.sort()\\n        return fn(upper) - fn(lower - 1)",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/b0e80d89-bf41-436f-9bf6-e23974d646e9_1692895574.4367921.png)\\n\\n    def countFairPairs(self, nums: list[int], lower: int, upper: int) -> int:\\n        fn = lambda x: sum(bisect.bisect_right(nums, x - n, hi=i) for i, n in enumerate(nums))\\n        nums.sort()\\n        return fn(upper) - fn(lower - 1)",
                "codeTag": "Python3"
            },
            {
                "id": 3955061,
                "title": "golang-binary-search-solution",
                "content": "# Code\\n```go\\nfunc countFairPairs(nums []int, lower int, upper int) int64 {\\n\\tsorted := make([]int, 0, 16)\\n\\tcount := 0\\n\\tfor _, v := range nums {\\n\\t\\tlBound := findFirstGreaterOrEqual(sorted, lower-v)\\n\\t\\trBound := findFirstGreaterOrEqual(sorted, upper-v+1)\\n\\t\\tcount += rBound - lBound\\n\\t\\tinsertIndex := findFirstGreaterOrEqual(sorted, v)\\n\\t\\tsorted = append(sorted, 0)\\n\\t\\tcopy(sorted[insertIndex+1:], sorted[insertIndex:])\\n\\t\\tsorted[insertIndex] = v\\n\\t}\\n\\treturn int64(count)\\n}\\n\\nfunc findFirstGreaterOrEqual(nums []int, val int) int {\\n\\tl, r := 0, len(nums)-1\\n\\tfor l <= r {\\n\\t\\tm := (l+r)>>1\\n\\t\\tif nums[m] < val {\\n\\t\\t\\tl = m+1\\n\\t\\t} else {\\n\\t\\t\\tr = m-1\\n\\t\\t}\\n\\t}\\n\\treturn r+1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```go\\nfunc countFairPairs(nums []int, lower int, upper int) int64 {\\n\\tsorted := make([]int, 0, 16)\\n\\tcount := 0\\n\\tfor _, v := range nums {\\n\\t\\tlBound := findFirstGreaterOrEqual(sorted, lower-v)\\n\\t\\trBound := findFirstGreaterOrEqual(sorted, upper-v+1)\\n\\t\\tcount += rBound - lBound\\n\\t\\tinsertIndex := findFirstGreaterOrEqual(sorted, v)\\n\\t\\tsorted = append(sorted, 0)\\n\\t\\tcopy(sorted[insertIndex+1:], sorted[insertIndex:])\\n\\t\\tsorted[insertIndex] = v\\n\\t}\\n\\treturn int64(count)\\n}\\n\\nfunc findFirstGreaterOrEqual(nums []int, val int) int {\\n\\tl, r := 0, len(nums)-1\\n\\tfor l <= r {\\n\\t\\tm := (l+r)>>1\\n\\t\\tif nums[m] < val {\\n\\t\\t\\tl = m+1\\n\\t\\t} else {\\n\\t\\t\\tr = m-1\\n\\t\\t}\\n\\t}\\n\\treturn r+1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3935671,
                "title": "sort-3-pointers",
                "content": "```\\nlong long countFairPairs(vector<int>& n, int l, int u) \\n{\\n\\tsort(begin(n), end(n));\\n\\tlong long out{};\\n\\tfor(int i{}, j(size(n)-1), k(size(n)-1); i<k; )\\n\\t\\tj>=0 and n[i]+n[j]>=l ? --j : n[i]+n[k]>u ? --k : out+=max(0, k-max(i++,j)); \\n\\treturn out;\\n}\\n```\\n**Similar problems:**\\n[2824. Count Pairs Whose Sum is Less than Target](https://leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/discuss/3933815/sort-2p)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long countFairPairs(vector<int>& n, int l, int u) \\n{\\n\\tsort(begin(n), end(n));\\n\\tlong long out{};\\n\\tfor(int i{}, j(size(n)-1), k(size(n)-1); i<k; )\\n\\t\\tj>=0 and n[i]+n[j]>=l ? --j : n[i]+n[k]>u ? --k : out+=max(0, k-max(i++,j)); \\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3933216,
                "title": "no-binary-search-nlogn-simple-beats-94-53",
                "content": "# Intuition\\nMake a function to calculate all pairs having sum less than equal to K. Call this function for upper and for lower - 1 (because we have to include lower)\\n\\nhence,\\nfinal ans = all pairs having sum less than equal to upper - all pairs having sum less than equal  to lower -1\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        length = len(nums)\\n\\n        def lessthanequalto(nums,k):\\n            count,left,right = 0,0,length-1\\n            \\n            while(left<right):\\n                Sum = nums[left] + nums[right]\\n                if Sum<=k:\\n                    count += right - left\\n                    left += 1\\n                else:\\n                    right -= 1\\n            return count\\n        \\n        return lessthanequalto(nums,upper) - lessthanequalto(nums,lower-1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        length = len(nums)\\n\\n        def lessthanequalto(nums,k):\\n            count,left,right = 0,0,length-1\\n            \\n            while(left<right):\\n                Sum = nums[left] + nums[right]\\n                if Sum<=k:\\n                    count += right - left\\n                    left += 1\\n                else:\\n                    right -= 1\\n            return count\\n        \\n        return lessthanequalto(nums,upper) - lessthanequalto(nums,lower-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929528,
                "title": "c-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper)\\n    {\\n        sort(nums.begin(), nums.end());\\n        long long ans = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(2*nums[i]<=upper && nums[i]+nums[n-1]>=lower)\\n            {\\n                int l1 = i+1;\\n                int r1 = n-1;\\n                while(l1<r1)\\n                {\\n                    int m1 = l1+(r1-l1)/2;\\n                    if(nums[i]+nums[m1]>=lower){r1=m1;}\\n                    else{l1=m1+1;}\\n                }\\n                int l2 = l1;\\n                int r2 = n;\\n                while(l2<r2)\\n                {\\n                    int m2 = l2+(r2-l2)/2;\\n                    if(nums[i]+nums[m2]>upper){r2=m2;}\\n                    else{l2=m2+1;}\\n                }\\n                l2--;\\n                ans=ans+l2-l1+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper)\\n    {\\n        sort(nums.begin(), nums.end());\\n        long long ans = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(2*nums[i]<=upper && nums[i]+nums[n-1]>=lower)\\n            {\\n                int l1 = i+1;\\n                int r1 = n-1;\\n                while(l1<r1)\\n                {\\n                    int m1 = l1+(r1-l1)/2;\\n                    if(nums[i]+nums[m1]>=lower){r1=m1;}\\n                    else{l1=m1+1;}\\n                }\\n                int l2 = l1;\\n                int r2 = n;\\n                while(l2<r2)\\n                {\\n                    int m2 = l2+(r2-l2)/2;\\n                    if(nums[i]+nums[m2]>upper){r2=m2;}\\n                    else{l2=m2+1;}\\n                }\\n                l2--;\\n                ans=ans+l2-l1+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911205,
                "title": "javascript-sorting-two-pointers",
                "content": "# Approach\\nhttps://leetcode.com/problems/count-the-number-of-fair-pairs/solutions/3174181/two-pointers-2/\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nvar countFairPairs = function(nums, lower, upper) {\\n    nums.sort((b, a) => b - a);\\n\\n    let fairPairs = 0, n = nums.length;\\n\\n    for (let i = 0, l = n, u = n - 1; i < u; l = Math.max(l, ++i + 1)) {\\n        while (i < l - 1 && nums[i] + nums[l - 1] >= lower) l--;\\n        while (i < u && nums[i] + nums[u] > upper) u--;\\n        fairPairs += u - l + 1;\\n    }\\n\\n    return fairPairs;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nvar countFairPairs = function(nums, lower, upper) {\\n    nums.sort((b, a) => b - a);\\n\\n    let fairPairs = 0, n = nums.length;\\n\\n    for (let i = 0, l = n, u = n - 1; i < u; l = Math.max(l, ++i + 1)) {\\n        while (i < l - 1 && nums[i] + nums[l - 1] >= lower) l--;\\n        while (i < u && nums[i] + nums[u] > upper) u--;\\n        fairPairs += u - l + 1;\\n    }\\n\\n    return fairPairs;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3908924,
                "title": "both-two-pointer-and-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n    /*    Arrays.sort(nums);\\n        long result = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            result = result + binarySearch1(nums, nums[i], i, lower, upper) - binarySearch2(nums, nums[i], i, lower, upper);\\n        }\\n        return result;\\n    }\\n    public long binarySearch1(int[] nums, int currentValue, int index, int lower, int upper) {\\n        int start = index + 1;\\n        int end = nums.length-1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] > (upper - currentValue)) {\\n                end = mid-1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n     public long binarySearch2(int[] nums, int currentValue, int index, int lower, int upper) {\\n        int start = index + 1;\\n        int end = nums.length-1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < (lower - currentValue)) {\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return start;*/\\n            Arrays.sort(nums);\\n        long c1=0;\\n        long c2=0;\\n\\n        int i=0;\\n        int j=nums.length -1;\\n        \\n        while(i<j)\\n        {\\n            if(nums[i]+nums[j]<=upper)\\n            {\\n                c1=c1+(j-i);\\n                i++;\\n            }\\n            else\\n            j--;\\n        }\\n\\n        i=0;\\n        j=nums.length -1;\\n        while(i<j)\\n        {\\n            if(nums[i]+nums[j]<lower)\\n            {\\n                c2=c2+(j-i);\\n                i++;\\n            }\\n            else\\n            j--;\\n        }\\n        return c1-c2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n    /*    Arrays.sort(nums);\\n        long result = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            result = result + binarySearch1(nums, nums[i], i, lower, upper) - binarySearch2(nums, nums[i], i, lower, upper);\\n        }\\n        return result;\\n    }\\n    public long binarySearch1(int[] nums, int currentValue, int index, int lower, int upper) {\\n        int start = index + 1;\\n        int end = nums.length-1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] > (upper - currentValue)) {\\n                end = mid-1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n     public long binarySearch2(int[] nums, int currentValue, int index, int lower, int upper) {\\n        int start = index + 1;\\n        int end = nums.length-1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < (lower - currentValue)) {\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return start;*/\\n            Arrays.sort(nums);\\n        long c1=0;\\n        long c2=0;\\n\\n        int i=0;\\n        int j=nums.length -1;\\n        \\n        while(i<j)\\n        {\\n            if(nums[i]+nums[j]<=upper)\\n            {\\n                c1=c1+(j-i);\\n                i++;\\n            }\\n            else\\n            j--;\\n        }\\n\\n        i=0;\\n        j=nums.length -1;\\n        while(i<j)\\n        {\\n            if(nums[i]+nums[j]<lower)\\n            {\\n                c2=c2+(j-i);\\n                i++;\\n            }\\n            else\\n            j--;\\n        }\\n        return c1-c2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892848,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long result=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int x=lower-nums[i];\\n            int y=upper-nums[i];\\n            int min=0,max=0;\\n            int low=0,high=nums.length-1;\\n            while(low<=high)\\n            {\\n                int mid=(low+high)/2;\\n                if(nums[mid]>=x)\\n                {\\n                    min=mid;\\n                    high=mid-1;\\n                }\\n                else\\n                {\\n                    min=mid+1;\\n                    low=mid+1;\\n                }\\n            }\\n            low=0;\\n            high=nums.length-1;\\n            while(low<=high)\\n            {\\n                int mid=(low+high)/2;\\n                if(nums[mid]>y)\\n                {\\n                    max=mid;\\n                    high=mid-1;\\n                }\\n                else\\n                {\\n                    max=mid+1;\\n                    low=mid+1;\\n                }\\n            }\\n            if(min>i && max>i)\\n            {\\n                result+=max-min;\\n            }\\n            else\\n            {\\n                if(max<=i)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    min=i+1;\\n                    result+=max-min;\\n                }\\n            }\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long result=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int x=lower-nums[i];\\n            int y=upper-nums[i];\\n            int min=0,max=0;\\n            int low=0,high=nums.length-1;\\n            while(low<=high)\\n            {\\n                int mid=(low+high)/2;\\n                if(nums[mid]>=x)\\n                {\\n                    min=mid;\\n                    high=mid-1;\\n                }\\n                else\\n                {\\n                    min=mid+1;\\n                    low=mid+1;\\n                }\\n            }\\n            low=0;\\n            high=nums.length-1;\\n            while(low<=high)\\n            {\\n                int mid=(low+high)/2;\\n                if(nums[mid]>y)\\n                {\\n                    max=mid;\\n                    high=mid-1;\\n                }\\n                else\\n                {\\n                    max=mid+1;\\n                    low=mid+1;\\n                }\\n            }\\n            if(min>i && max>i)\\n            {\\n                result+=max-min;\\n            }\\n            else\\n            {\\n                if(max<=i)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    min=i+1;\\n                    result+=max-min;\\n                }\\n            }\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782714,
                "title": "sort-binary-search-keep-it-simple",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long ans = 0;\\n\\n        for(int i=0; i<nums.size(); i++)\\n        {   //start searching from i+1th index till the index\\n            int low = lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i]) - nums.begin();\\n            int high = upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i]) - nums.begin();\\n        //nums[i] can pair up with all nums[j] such that low <= j <= high\\n            ans += (high-low); //No. of pairs = high - low\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long ans = 0;\\n\\n        for(int i=0; i<nums.size(); i++)\\n        {   //start searching from i+1th index till the index\\n            int low = lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i]) - nums.begin();\\n            int high = upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i]) - nums.begin();\\n        //nums[i] can pair up with all nums[j] such that low <= j <= high\\n            ans += (high-low); //No. of pairs = high - low\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775139,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        deque<int> dq;\\n        for(auto x:nums) {\\n            dq.push_back(x);\\n        }\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++) {\\n            dq.pop_front();\\n            auto l=lower_bound(dq.begin(),dq.end(),lower-nums[i]);\\n            auto h=upper_bound(dq.begin(),dq.end(),upper-nums[i]); \\n            ans+=(h-l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        deque<int> dq;\\n        for(auto x:nums) {\\n            dq.push_back(x);\\n        }\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++) {\\n            dq.pop_front();\\n            auto l=lower_bound(dq.begin(),dq.end(),lower-nums[i]);\\n            auto h=upper_bound(dq.begin(),dq.end(),upper-nums[i]); \\n            ans+=(h-l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741614,
                "title": "2563-count-the-number-of-fair-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(i)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        return smaller(nums, upper) - smaller(nums, --lower);\\n    }\\n\\n    private long smaller(int[] nums, int value) {\\n        int l = 0, r = nums.length - 1;\\n        long result = 0;\\n        while (l < r) {\\n            int sum = nums[l] + nums[r];\\n            if (sum <= value) {\\n                result += (r - l);\\n                l++;    \\n            } else {   \\n                r--;\\n            }\\n        }\\n            \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        return smaller(nums, upper) - smaller(nums, --lower);\\n    }\\n\\n    private long smaller(int[] nums, int value) {\\n        int l = 0, r = nums.length - 1;\\n        long result = 0;\\n        while (l < r) {\\n            int sum = nums[l] + nums[r];\\n            if (sum <= value) {\\n                result += (r - l);\\n                l++;    \\n            } else {   \\n                r--;\\n            }\\n        }\\n            \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733958,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        return countPairsLessThanVal(nums, upper) - countPairsLessThanVal(nums, lower - 1);\\n    }\\n    \\n    private long countPairsLessThanVal(int[] nums, int val) {\\n        long output = 0;\\n        int i = 0, j = nums.length - 1;\\n        \\n        while (i < j) {\\n            if (nums[i] + nums[j] > val) {\\n                -- j;\\n            } else {\\n                output += j - i;\\n                ++ i;\\n            }\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        return countPairsLessThanVal(nums, upper) - countPairsLessThanVal(nums, lower - 1);\\n    }\\n    \\n    private long countPairsLessThanVal(int[] nums, int val) {\\n        long output = 0;\\n        int i = 0, j = nums.length - 1;\\n        \\n        while (i < j) {\\n            if (nums[i] + nums[j] > val) {\\n                -- j;\\n            } else {\\n                output += j - i;\\n                ++ i;\\n            }\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667900,
                "title": "c-upper-lower-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long int ans = 0;\\n        for(int i = 0;i<nums.size();i++){\\n        int x = lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i])-nums.begin();\\n        int y = upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i])-nums.begin();\\n            ans += (y-x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long int ans = 0;\\n        for(int i = 0;i<nums.size();i++){\\n        int x = lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i])-nums.begin();\\n        int y = upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i])-nums.begin();\\n            ans += (y-x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627220,
                "title": "binary-search-tree",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        n = len(nums)\\n        bst = SortedList()\\n        res = 0\\n        for i in range(n):\\n            res += bst.bisect_right(upper - nums[i]) - bst.bisect_left(lower - nums[i])\\n            bst.add(nums[i])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        n = len(nums)\\n        bst = SortedList()\\n        res = 0\\n        for i in range(n):\\n            res += bst.bisect_right(upper - nums[i]) - bst.bisect_left(lower - nums[i])\\n            bst.add(nums[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478335,
                "title": "count-the-number-of-fair-pairs",
                "content": "--------------- Easy C++ Solution -------------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        const auto& count = [&](int64_t x) {\\n            int64_t cnt = 0;\\n            int left = 0, right = size(nums) - 1;\\n            while (left < right) {\\n                if (nums[left] + nums[right] <= x) {\\n                    cnt += right - left;\\n                    cout<<cnt<<endl;\\n                    left++;\\n                } else {\\n                    --right;\\n                }\\n            }\\n            return cnt;\\n        };\\n\\n        sort(begin(nums), end(nums));\\n        return count(upper) - count(lower - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        const auto& count = [&](int64_t x) {\\n            int64_t cnt = 0;\\n            int left = 0, right = size(nums) - 1;\\n            while (left < right) {\\n                if (nums[left] + nums[right] <= x) {\\n                    cnt += right - left;\\n                    cout<<cnt<<endl;\\n                    left++;\\n                } else {\\n                    --right;\\n                }\\n            }\\n            return cnt;\\n        };\\n\\n        sort(begin(nums), end(nums));\\n        return count(upper) - count(lower - 1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3407255,
                "title": "c-solution-simple-and-easy-without-binary-search-sorting-and-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long count=0,i=0,j=nums.size()-1;\\n        while(i<j){\\n            if((nums[i]+nums[j])<lower){\\n                // cout<<i<<\" \"<<j<<endl;\\n                count+=(j-i);\\n                i++;\\n            }\\n            else if((nums[i]+nums[j])>=lower){\\n                j--;\\n            }\\n            \\n        }\\n        i=0,j=nums.size()-1;\\n        while(i<j){\\n            if(nums[i]+nums[j]>upper){\\n                // cout<<i<<\" \"<<j<<endl;\\n                count+=(j-i);\\n                j--;\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        long long res=(nums.size()*(nums.size()-1))/2;\\n        // cout<<res<<\" \"<<count<<endl;\\n        return res-count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long count=0,i=0,j=nums.size()-1;\\n        while(i<j){\\n            if((nums[i]+nums[j])<lower){\\n                // cout<<i<<\" \"<<j<<endl;\\n                count+=(j-i);\\n                i++;\\n            }\\n            else if((nums[i]+nums[j])>=lower){\\n                j--;\\n            }\\n            \\n        }\\n        i=0,j=nums.size()-1;\\n        while(i<j){\\n            if(nums[i]+nums[j]>upper){\\n                // cout<<i<<\" \"<<j<<endl;\\n                count+=(j-i);\\n                j--;\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        long long res=(nums.size()*(nums.size()-1))/2;\\n        // cout<<res<<\" \"<<count<<endl;\\n        return res-count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3376153,
                "title": "c-binary-search-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        \\n        sort(nums.begin(),nums.end());\\n        long long count=0;\\n        int n=nums.size();\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<j){\\n            \\n            if(nums[i]+nums[j]>=lower && nums[i]+nums[j]<=upper){\\n                \\n                int start=i+1;\\n                int end=j;\\n                int target=lower-nums[i];\\n                int index=-1;\\n                while(start<=end){\\n                    int mid=(start+end)/2;\\n                    if(nums[mid]>=target){\\n                        index=mid;\\n                        end=mid-1;\\n                    }\\n                    else{\\n                        start=mid+1;\\n                    }\\n                }\\n                if(index!=-1){\\n                    count=count+(j-index+1);\\n                }\\n                else{\\n                    count++;\\n                }\\n                i++;\\n            }\\n            else if(nums[i]+nums[j]>upper){\\n                j--;\\n            }\\n            else if(nums[i]+nums[j]<lower){\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        \\n        sort(nums.begin(),nums.end());\\n        long long count=0;\\n        int n=nums.size();\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<j){\\n            \\n            if(nums[i]+nums[j]>=lower && nums[i]+nums[j]<=upper){\\n                \\n                int start=i+1;\\n                int end=j;\\n                int target=lower-nums[i];\\n                int index=-1;\\n                while(start<=end){\\n                    int mid=(start+end)/2;\\n                    if(nums[mid]>=target){\\n                        index=mid;\\n                        end=mid-1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3364733,
                "title": "must-see-binary-search-easy-to-understand",
                "content": "# Code\\n```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\n\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    long long int count;\\n    int lower;\\n    int upper;\\n    long long countFairPairs(vector<int>& nums, int l, int u) \\n    {\\n          //initilizing the range\\n          lower = l;\\n          upper = u;\\n\\n          //to keep the track of the no of pairs in  the aray\\n          count = 0;\\n\\n          //first we will sort the given array nums\\n          sort(nums.begin(),nums.end());\\n\\n          //we are going to keep the track for the two extremen elements\\n          for(int i=0;i<(nums.size());i++)\\n          {\\n               int start = fun1(nums,0,i-1,nums[i]);\\n               //if no element exist after the first call\\n               if(start == -1) continue;\\n\\n               int end   = fun2(nums,0,i-1,nums[i]);\\n               //if no element is found after the call then we will return -1\\n               if(end == -1) continue;\\n\\n               count = count + (end - start + 1);      \\n\\n            //    cout<<\"i=\"<<i<<\" \"<<(end - start + 1)<<endl;\\n            //    cout<<\"start =\"<<start<<\" \"<<\"end = \"<<end<<endl;\\n          }\\n          return count;\\n    }\\n    int fun2(vector<int>&nums,int start,int end,int &ele)\\n    {\\n        int temp = end;\\n        //this function will give the index of the last element of the array satisfying the sum \\n        //constraint\\n        int pos = -1;\\n\\n        if(start > end) \\n        return -1;\\n\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end - start)/2));\\n            long long int sum = ele + nums[mid];\\n\\n            if((sum>=lower) and (sum<=upper))\\n            {\\n                pos = mid;\\n                start = mid+1;\\n            }\\n            else if(sum < lower)\\n            {\\n                start = mid+1;\\n            }\\n            else if(sum > upper)\\n            {\\n                end = mid-1;\\n            }\\n        }\\n        if(start!=(temp+1) and start>=0 and start<nums.size() and ((nums[start]+ele)>=lower and (nums[start]+ele)<=upper))\\n        {\\n               pos = max(pos,start);\\n        }\\n        return pos;\\n    }\\n    int fun1(vector<int>&nums,int start,int end,int &ele)\\n    {\\n          //if there is no one to find to pair up with the ele\\n          if(start > end) \\n          return -1;\\n\\n          //this function will find the first element that will keep the \\n          //sum in the range \\n          int pos = -1;     \\n\\n          while(start <= end)\\n          {\\n              long long int mid = (start + ((end - start)/2));\\n              long long int sum = ele + nums[mid];\\n\\n              if((sum>=lower) and (sum<=upper))\\n              {\\n                  pos = mid;\\n                  end = mid-1;\\n              }\\n              else if(sum < lower)\\n              {\\n                   start = mid+1;  \\n              }\\n              else if(sum > upper)\\n              {\\n                  end = mid-1;\\n              }\\n          }\\n          //we are going to check the end at last for safer side\\n          if(end>=0 and end<nums.size() and ((nums[end]+ele)>=lower and (nums[end]+ele)<=upper))\\n          {\\n               pos = min(pos,end);\\n          }\\n          return pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\n\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    long long int count;\\n    int lower;\\n    int upper;\\n    long long countFairPairs(vector<int>& nums, int l, int u) \\n    {\\n          //initilizing the range\\n          lower = l;\\n          upper = u;\\n\\n          //to keep the track of the no of pairs in  the aray\\n          count = 0;\\n\\n          //first we will sort the given array nums\\n          sort(nums.begin(),nums.end());\\n\\n          //we are going to keep the track for the two extremen elements\\n          for(int i=0;i<(nums.size());i++)\\n          {\\n               int start = fun1(nums,0,i-1,nums[i]);\\n               //if no element exist after the first call\\n               if(start == -1) continue;\\n\\n               int end   = fun2(nums,0,i-1,nums[i]);\\n               //if no element is found after the call then we will return -1\\n               if(end == -1) continue;\\n\\n               count = count + (end - start + 1);      \\n\\n            //    cout<<\"i=\"<<i<<\" \"<<(end - start + 1)<<endl;\\n            //    cout<<\"start =\"<<start<<\" \"<<\"end = \"<<end<<endl;\\n          }\\n          return count;\\n    }\\n    int fun2(vector<int>&nums,int start,int end,int &ele)\\n    {\\n        int temp = end;\\n        //this function will give the index of the last element of the array satisfying the sum \\n        //constraint\\n        int pos = -1;\\n\\n        if(start > end) \\n        return -1;\\n\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end - start)/2));\\n            long long int sum = ele + nums[mid];\\n\\n            if((sum>=lower) and (sum<=upper))\\n            {\\n                pos = mid;\\n                start = mid+1;\\n            }\\n            else if(sum < lower)\\n            {\\n                start = mid+1;\\n            }\\n            else if(sum > upper)\\n            {\\n                end = mid-1;\\n            }\\n        }\\n        if(start!=(temp+1) and start>=0 and start<nums.size() and ((nums[start]+ele)>=lower and (nums[start]+ele)<=upper))\\n        {\\n               pos = max(pos,start);\\n        }\\n        return pos;\\n    }\\n    int fun1(vector<int>&nums,int start,int end,int &ele)\\n    {\\n          //if there is no one to find to pair up with the ele\\n          if(start > end) \\n          return -1;\\n\\n          //this function will find the first element that will keep the \\n          //sum in the range \\n          int pos = -1;     \\n\\n          while(start <= end)\\n          {\\n              long long int mid = (start + ((end - start)/2));\\n              long long int sum = ele + nums[mid];\\n\\n              if((sum>=lower) and (sum<=upper))\\n              {\\n                  pos = mid;\\n                  end = mid-1;\\n              }\\n              else if(sum < lower)\\n              {\\n                   start = mid+1;  \\n              }\\n              else if(sum > upper)\\n              {\\n                  end = mid-1;\\n              }\\n          }\\n          //we are going to check the end at last for safer side\\n          if(end>=0 and end<nums.size() and ((nums[end]+ele)>=lower and (nums[end]+ele)<=upper))\\n          {\\n               pos = min(pos,end);\\n          }\\n          return pos;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3364694,
                "title": "2-approaches-combo-fast-cpp-soluton",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  o(nlogn)\\n\\n- Space complexity:\\no(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        // this is a bruteforce approach-->\\n\\n        // int n = nums.size();\\n        // long long cnt =0;\\n        \\n        // for(int i=0;i<nums.size();i++){\\n        //     if(nums[i]<lower && nums[i]>upper)continue;\\n        //     for(int j= nums.size()-1;j>i;j--){\\n        //          if((lower <= nums[i] + nums[j]) && (nums[i] + nums[j] <= upper))cnt++;\\n        //     }\\n        // }\\n        // return cnt;\\n\\n        // using binary search approach....\\n\\n        long long ans =0;\\n        int n = nums.size();\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++){\\n            int lwr = lower-nums[i],upr = upper - nums[i];\\n\\n            ans+= upper_bound(nums.begin()+i+1,nums.end(),upr)-lower_bound(nums.begin()+i+1,nums.end(),lwr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        // this is a bruteforce approach-->\\n\\n        // int n = nums.size();\\n        // long long cnt =0;\\n        \\n        // for(int i=0;i<nums.size();i++){\\n        //     if(nums[i]<lower && nums[i]>upper)continue;\\n        //     for(int j= nums.size()-1;j>i;j--){\\n        //          if((lower <= nums[i] + nums[j]) && (nums[i] + nums[j] <= upper))cnt++;\\n        //     }\\n        // }\\n        // return cnt;\\n\\n        // using binary search approach....\\n\\n        long long ans =0;\\n        int n = nums.size();\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++){\\n            int lwr = lower-nums[i],upr = upper - nums[i];\\n\\n            ans+= upper_bound(nums.begin()+i+1,nums.end(),upr)-lower_bound(nums.begin()+i+1,nums.end(),lwr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364634,
                "title": "must-see-binary-search-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        // sort the array \\n        // we will find the lower and higher number that\\n        // are making fair pair with choosen element\\n        sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=ans+fun(nums,lower,upper,nums[i],i);\\n        }\\n        return ans;\\n    }\\n    long long fun(vector<int>&nums,int &l,int &u,int &a,int &idx)\\n    {\\n        int start=idx+1;\\n        int end=nums.size()-1;\\n        int mid;\\n        int b;\\n        long long i=-1;\\n        while(start<=end)\\n        {\\n            mid=(start+end)/2;\\n            b=nums[mid];\\n            if((a+b)>=l)\\n            {\\n                i=mid;\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        start=idx+1;\\n        end=nums.size()-1;\\n        long long j=-1;\\n        while(start<=end)\\n        {\\n            mid=(start+end)/2;\\n            b=nums[mid];\\n            if((a+b)<=u)\\n            {\\n                j=mid;\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n        if(i!=-1 and j!=-1)\\n        {\\n            return j-i+1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        // sort the array \\n        // we will find the lower and higher number that\\n        // are making fair pair with choosen element\\n        sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=ans+fun(nums,lower,upper,nums[i],i);\\n        }\\n        return ans;\\n    }\\n    long long fun(vector<int>&nums,int &l,int &u,int &a,int &idx)\\n    {\\n        int start=idx+1;\\n        int end=nums.size()-1;\\n        int mid;\\n        int b;\\n        long long i=-1;\\n        while(start<=end)\\n        {\\n            mid=(start+end)/2;\\n            b=nums[mid];\\n            if((a+b)>=l)\\n            {\\n                i=mid;\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        start=idx+1;\\n        end=nums.size()-1;\\n        long long j=-1;\\n        while(start<=end)\\n        {\\n            mid=(start+end)/2;\\n            b=nums[mid];\\n            if((a+b)<=u)\\n            {\\n                j=mid;\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n        if(i!=-1 and j!=-1)\\n        {\\n            return j-i+1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346850,
                "title": "python-binary-search-solution-with-explanation",
                "content": "### simulation\\n```python\\n\\'\\'\\'\\nA brute force method is to walk through poistion i where is [0, n-2] and enumerate poistion j where is in [i+1, n-1] such that lower <= nums[i] + nums[j] <= upper, tc is O(n^2), sc is O(1).\\nwe can sort nums first.\\nIn the sorted nums, we can walk through poistion i where is [0, n-2] and enumerate poistion j where is in [i+1, n-1].\\nbecause of sorted, we can use binary search to locate left and right bound of valid position j, and each valid position j > i (avoid to count duplicate pairs)\\n\\ne.g., nums = [0,1,7,4,4,5,1,1,1], lower = 2, upper = 6\\nindex   0 1 2 3 4 5 6 7 8\\nsorted [0,1,1,1,1,4,4,5,7]\\nnums[i] = 0, 2-0 = 2, 6-0 = 6, left bound of 2 is index 5, right bound of 6 is index 7, ans += 7-5+1\\nnums[i] = 1, 2-1 = 1, 6-1 = 5, left bound of 1 is index 1 which is less than or equl to i, left bound becomes i+1, right bound of 5 is index 7, ans += 5-2+1\\nnums[i] = 1, 2-1 = 1, 6-1 = 5, left bound of 1 is index 1 which is less than or equl to i, left bound becomes i+1, right bound of 5 is index 7, ans += 5-3+1\\n...\\nnums[i] = 4, 2-4 = -2, 6-4 = 2, right bound of 2 is before i, there is no valid j, return ans\\ntc is O(nlogn), sc is O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        ans = 0\\n        for idx, n in enumerate(nums):\\n\\t\\t\\t# the j we find is before the i, there is no vaild j, and nums is sorted, the rest i are in the same situation, just return ans\\n            if upper - n < n: return ans\\n            l = self.findLeftBound(nums, lower-n)\\n            r = self.findRightBound(nums, upper-n)\\n            if idx >= l: l = idx + 1 \\n            if r >= l: ans += r - l + 1\\n        return ans\\n\\n    def findLeftBound(self, arr, target):\\n        l, r = 0, len(arr)\\n        while l < r:\\n            m = (l + r) // 2\\n            if arr[m] >= target:\\n                r = m\\n            else: l = m + 1\\n        return l\\n        \\n    def findRightBound(self, arr, target):\\n        l, r = 0, len(arr)\\n        while l < r:\\n            m = (l + r) // 2\\n            if arr[m] <= target:\\n                l = m + 1\\n            else: r = m\\n        return r-1\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```python\\n\\'\\'\\'\\nA brute force method is to walk through poistion i where is [0, n-2] and enumerate poistion j where is in [i+1, n-1] such that lower <= nums[i] + nums[j] <= upper, tc is O(n^2), sc is O(1).\\nwe can sort nums first.\\nIn the sorted nums, we can walk through poistion i where is [0, n-2] and enumerate poistion j where is in [i+1, n-1].\\nbecause of sorted, we can use binary search to locate left and right bound of valid position j, and each valid position j > i (avoid to count duplicate pairs)\\n\\ne.g., nums = [0,1,7,4,4,5,1,1,1], lower = 2, upper = 6\\nindex   0 1 2 3 4 5 6 7 8\\nsorted [0,1,1,1,1,4,4,5,7]\\nnums[i] = 0, 2-0 = 2, 6-0 = 6, left bound of 2 is index 5, right bound of 6 is index 7, ans += 7-5+1\\nnums[i] = 1, 2-1 = 1, 6-1 = 5, left bound of 1 is index 1 which is less than or equl to i, left bound becomes i+1, right bound of 5 is index 7, ans += 5-2+1\\nnums[i] = 1, 2-1 = 1, 6-1 = 5, left bound of 1 is index 1 which is less than or equl to i, left bound becomes i+1, right bound of 5 is index 7, ans += 5-3+1\\n...\\nnums[i] = 4, 2-4 = -2, 6-4 = 2, right bound of 2 is before i, there is no valid j, return ans\\ntc is O(nlogn), sc is O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        ans = 0\\n        for idx, n in enumerate(nums):\\n\\t\\t\\t# the j we find is before the i, there is no vaild j, and nums is sorted, the rest i are in the same situation, just return ans\\n            if upper - n < n: return ans\\n            l = self.findLeftBound(nums, lower-n)\\n            r = self.findRightBound(nums, upper-n)\\n            if idx >= l: l = idx + 1 \\n            if r >= l: ans += r - l + 1\\n        return ans\\n\\n    def findLeftBound(self, arr, target):\\n        l, r = 0, len(arr)\\n        while l < r:\\n            m = (l + r) // 2\\n            if arr[m] >= target:\\n                r = m\\n            else: l = m + 1\\n        return l\\n        \\n    def findRightBound(self, arr, target):\\n        l, r = 0, len(arr)\\n        while l < r:\\n            m = (l + r) // 2\\n            if arr[m] <= target:\\n                l = m + 1\\n            else: r = m\\n        return r-1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342075,
                "title": "python-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort array and then using binary search\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        def bs(t, r, left):\\n            l = 0\\n            while l < r:\\n                mid = (l + r) // 2\\n                if left and t <= nums[mid]:\\n                    r = mid\\n                elif not left and t < nums[mid]:\\n                    r = mid\\n                else:\\n                    l = mid + 1\\n            return l\\n            \\n        ret = 0\\n        for i in range(len(nums)):\\n            lo = bs(lower - nums[i], i, True)\\n            hi = bs(upper - nums[i], i, False)\\n            ret += (hi - lo)\\n        return ret\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        def bs(t, r, left):\\n            l = 0\\n            while l < r:\\n                mid = (l + r) // 2\\n                if left and t <= nums[mid]:\\n                    r = mid\\n                elif not left and t < nums[mid]:\\n                    r = mid\\n                else:\\n                    l = mid + 1\\n            return l\\n            \\n        ret = 0\\n        for i in range(len(nums)):\\n            lo = bs(lower - nums[i], i, True)\\n            hi = bs(upper - nums[i], i, False)\\n            ret += (hi - lo)\\n        return ret\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311839,
                "title": "sorting-bs",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        long long cnt = 0;\\n        for(int i = 0; i < n; i++) {\\n            int l = lower - nums[i];\\n            int r = upper - nums[i];\\n            int u = upper_bound(nums.begin(), nums.end(), r) - nums.begin();\\n            int b = max((int)(lower_bound(nums.begin(), nums.end(), l) - nums.begin()), i + 1);\\n            cnt +=  (u < b)? 0: u - b;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        long long cnt = 0;\\n        for(int i = 0; i < n; i++) {\\n            int l = lower - nums[i];\\n            int r = upper - nums[i];\\n            int u = upper_bound(nums.begin(), nums.end(), r) - nums.begin();\\n            int b = max((int)(lower_bound(nums.begin(), nums.end(), l) - nums.begin()), i + 1);\\n            cnt +=  (u < b)? 0: u - b;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311258,
                "title": "c-binary-search-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findindexlower(vector<int>&nums,int x,int s,int e)\\n    {\\n        int ans=-1;\\n        while(s<=e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]>=x)\\n            {\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else s=mid+1;\\n        }\\n        return ans;\\n    }\\n    int findindexupper(vector<int>&nums,int x,int s,int e)\\n    {\\n        int ans=-1;\\n        while(s<=e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]<=x)\\n            {\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            else e=mid-1;\\n        }\\n        return ans;\\n    }\\n\\n\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        long long ans=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int l=lower-nums[i];\\n            int r=upper-nums[i];\\n            int x=findindexlower(nums,l,i+1,n-1);\\n            int y=findindexupper(nums,r,i+1,n-1);\\n            if(x!=-1 and y!=-1)\\n                ans+=y-x+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findindexlower(vector<int>&nums,int x,int s,int e)\\n    {\\n        int ans=-1;\\n        while(s<=e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]>=x)\\n            {\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else s=mid+1;\\n        }\\n        return ans;\\n    }\\n    int findindexupper(vector<int>&nums,int x,int s,int e)\\n    {\\n        int ans=-1;\\n        while(s<=e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]<=x)\\n            {\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            else e=mid-1;\\n        }\\n        return ans;\\n    }\\n\\n\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        long long ans=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int l=lower-nums[i];\\n            int r=upper-nums[i];\\n            int x=findindexlower(nums,l,i+1,n-1);\\n            int y=findindexupper(nums,r,i+1,n-1);\\n            if(x!=-1 and y!=-1)\\n                ans+=y-x+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307814,
                "title": "sort-and-use-lower-bound-uper-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsort and use lower_bound, uper_bound\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsort and use lower_bound, uper_bound\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(), nums.end());\\n        long long res = 0;\\n        for (int i=1; i<nums.size(); i++)\\n            res += upper_bound(nums.begin(), nums.begin()+i, upper-nums[i]) -\\n                lower_bound(nums.begin(), nums.begin()+i, lower - nums[i]);\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(), nums.end());\\n        long long res = 0;\\n        for (int i=1; i<nums.size(); i++)\\n            res += upper_bound(nums.begin(), nums.begin()+i, upper-nums[i]) -\\n                lower_bound(nums.begin(), nums.begin()+i, lower - nums[i]);\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278973,
                "title": "c-sorting-lower-and-upper-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int lwr=lower-nums[i];\\n            int upr=upper-nums[i];\\n            ans+=upper_bound(nums.begin()+(i+1),nums.end(),upr)-lower_bound(nums.begin()+(i+1),nums.end(),lwr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int lwr=lower-nums[i];\\n            int upr=upper-nums[i];\\n            ans+=upper_bound(nums.begin()+(i+1),nums.end(),upr)-lower_bound(nums.begin()+(i+1),nums.end(),lwr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262349,
                "title": "three-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(begin(nums), end(nums));\\n        long long res = 0;\\n        for (int i = 0, k = INT_MAX, j = nums.size() - 1; i < j; ++i) {\\n            while (i < j && nums[i] + nums[j] > upper)\\n                --j;\\n            k = max(min(k, j), i + 1);\\n            while (i < k && nums[i] + nums[k] >= lower)\\n                --k;\\n            res += j - k;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(begin(nums), end(nums));\\n        long long res = 0;\\n        for (int i = 0, k = INT_MAX, j = nums.size() - 1; i < j; ++i) {\\n            while (i < j && nums[i] + nums[j] > upper)\\n                --j;\\n            k = max(min(k, j), i + 1);\\n            while (i < k && nums[i] + nums[k] >= lower)\\n                --k;\\n            res += j - k;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261960,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long res = 0;\\n        sort(begin(nums), end(nums));\\n        for(int i=0;i<nums.size();i++) {\\n            int lower_p = lower - nums[i];\\n            int upper_p = upper - nums[i];\\n            int first_index = lower_bound(nums.begin(), nums.begin() + i, lower_p) - nums.begin();\\n            int last_index = lower_bound(nums.begin(), nums.begin() + i, upper_p+1) - nums.begin();\\n            last_index--;\\n            if(last_index >= first_index) {\\n                res += last_index - first_index + 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long res = 0;\\n        sort(begin(nums), end(nums));\\n        for(int i=0;i<nums.size();i++) {\\n            int lower_p = lower - nums[i];\\n            int upper_p = upper - nums[i];\\n            int first_index = lower_bound(nums.begin(), nums.begin() + i, lower_p) - nums.begin();\\n            int last_index = lower_bound(nums.begin(), nums.begin() + i, upper_p+1) - nums.begin();\\n            last_index--;\\n            if(last_index >= first_index) {\\n                res += last_index - first_index + 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255641,
                "title": "well-explained-solution",
                "content": "# Intuition\\nThe given problem asks us to find the number of fair pairs in the given array. A pair is called fair if it satisfies the following conditions:\\n\\ni < j\\nlower <= nums[i]+nums[j] <= upper\\nOne approach to solve this problem is to iterate through all pairs of i and j, check whether it is a fair pair or not, and count the number of fair pairs. However, this approach will take O(n^2) time complexity, which is not efficient for large arrays.\\n\\nAnother approach is to sort the given array and use two pointers technique. We can use two pointers i and j where i starts from 0 and j starts from n-1. Then, we can check whether nums[i]+nums[j] satisfies the given conditions or not. If nums[i]+nums[j] is greater than upper, we can decrement j as we need to decrease the sum. If nums[i]+nums[j] is less than lower, we can increment i as we need to increase the sum. If nums[i]+nums[j] is between lower and upper, we can count the number of valid pairs (i,k) where i<k<=j that satisfies lower<=nums[i]+nums[k]<=upper.\\n\\n# Approach\\nThe following approach is used to solve the given problem:\\n\\nSort the given array.\\nInitialize two pointers i=0 and j=n-1.\\nInitialize a variable cnt=0 to count the number of fair pairs.\\nWhile i<j, check the following:\\na. If nums[i]+nums[j] is greater than upper, decrement j.\\nb. If nums[i]+nums[j] is less than lower, increment i.\\nc. If nums[i]+nums[j] is between lower and upper, find the minimum k such that nums[i]+nums[k] is greater than or equal to lower.\\nd. Add the number of valid pairs (i,k) to cnt where i<k<=j.\\ne. Increment i and repeat the above steps until i<j.\\nReturn cnt.\\n# Complexity\\nTime complexity: The time complexity of the given approach is O(nlogn) due to sorting the array, where n is the length of the input array. The while loop in the approach runs in O(n) time, and the inner while loop for finding k runs in O(n) in the worst case, which gives a total time complexity of O(nlogn).\\nSpace complexity: The space complexity of the given approach is O(1) as we are not using any extra space, and the sorting algorithm used in the implementation is an in-place sorting algorithm.\\n\\nif you liked the solution please upvote!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& v, int lower, int upper) {\\n       int n = v.size();\\n    \\n        sort(v.begin(),v.end());\\n        \\n        long long  i = 0 , j = n-1,cnt = 0;\\n        \\n        while(i<j)\\n        {\\n            if(v[i]+v[j] > upper)\\n            {\\n                j--;\\n            }\\n            else if(v[i]+v[j] < lower)\\n            {\\n                i++;\\n            }\\n            \\n            else if(v[i]+v[j] >= lower and v[i]+v[j] <= upper)\\n            {\\n                // now finding the min val that is also satisfy the given condn\\n                int k = i+1;\\n                while(k<=j)\\n                {\\n                    if(v[k]+v[i] >= lower)\\n                    {\\n                        break;\\n                    }\\n                    else \\n                    {\\n                        k++;\\n                    }\\n                }\\n\\n                cnt += (j-k+1); // including val pair with i that satisfy this condn\\n                i++;\\n            }\\n            \\n        }\\n        \\n        \\n        return cnt;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& v, int lower, int upper) {\\n       int n = v.size();\\n    \\n        sort(v.begin(),v.end());\\n        \\n        long long  i = 0 , j = n-1,cnt = 0;\\n        \\n        while(i<j)\\n        {\\n            if(v[i]+v[j] > upper)\\n            {\\n                j--;\\n            }\\n            else if(v[i]+v[j] < lower)\\n            {\\n                i++;\\n            }\\n            \\n            else if(v[i]+v[j] >= lower and v[i]+v[j] <= upper)\\n            {\\n                // now finding the min val that is also satisfy the given condn\\n                int k = i+1;\\n                while(k<=j)\\n                {\\n                    if(v[k]+v[i] >= lower)\\n                    {\\n                        break;\\n                    }\\n                    else \\n                    {\\n                        k++;\\n                    }\\n                }\\n\\n                cnt += (j-k+1); // including val pair with i that satisfy this condn\\n                i++;\\n            }\\n            \\n        }\\n        \\n        \\n        return cnt;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255585,
                "title": "well-explained-solution",
                "content": "Intuition\\nThe given problem asks us to find the number of fair pairs in the given array. A pair is called fair if it satisfies the following conditions:\\n\\ni < j\\nlower <= nums[i]+nums[j] <= upper\\nOne approach to solve this problem is to iterate through all pairs of i and j, check whether it is a fair pair or not, and count the number of fair pairs. However, this approach will take O(n^2) time complexity, which is not efficient for large arrays.\\n\\nAnother approach is to sort the given array and use two pointers technique. We can use two pointers i and j where i starts from 0 and j starts from n-1. Then, we can check whether nums[i]+nums[j] satisfies the given conditions or not. If nums[i]+nums[j] is greater than upper, we can decrement j as we need to decrease the sum. If nums[i]+nums[j] is less than lower, we can increment i as we need to increase the sum. If nums[i]+nums[j] is between lower and upper, we can count the number of valid pairs (i,k) where i<k<=j that satisfies lower<=nums[i]+nums[k]<=upper.\\n\\nApproach\\nThe following approach is used to solve the given problem:\\n\\nSort the given array.\\nInitialize two pointers i=0 and j=n-1.\\nInitialize a variable cnt=0 to count the number of fair pairs.\\nWhile i<j, check the following:\\na. If nums[i]+nums[j] is greater than upper, decrement j.\\nb. If nums[i]+nums[j] is less than lower, increment i.\\nc. If nums[i]+nums[j] is between lower and upper, find the minimum k such that nums[i]+nums[k] is greater than or equal to lower.\\nd. Add the number of valid pairs (i,k) to cnt where i<k<=j.\\ne. Increment i and repeat the above steps until i<j.\\nReturn cnt.\\nComplexity\\nTime complexity: The time complexity of the given approach is O(nlogn) due to sorting the array, where n is the length of the input array. The while loop in the approach runs in O(n) time, and the inner while loop for finding k runs in O(n) in the worst case, which gives a total time complexity of O(nlogn).\\nSpace complexity: The space complexity of the given approach is O(1) as we are not using any extra space, and the sorting algorithm used in the implementation is an in-place sorting algorithm.\\n\\nif you liked the solution please upvote!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& v, int lower, int upper) {\\n       int n = v.size();\\n    \\n        sort(v.begin(),v.end());\\n        \\n        long long  i = 0 , j = n-1,cnt = 0;\\n        \\n        while(i<j)\\n        {\\n            if(v[i]+v[j] > upper)\\n            {\\n                j--;\\n            }\\n            else if(v[i]+v[j] < lower)\\n            {\\n                i++;\\n            }\\n            \\n            else if(v[i]+v[j] >= lower and v[i]+v[j] <= upper)\\n            {\\n                // now finding the min val that is also satisfy the given condn\\n                int k = i+1;\\n                while(k<=j)\\n                {\\n                    if(v[k]+v[i] >= lower)\\n                    {\\n                        break;\\n                    }\\n                    else \\n                    {\\n                        k++;\\n                    }\\n                }\\n\\n                cnt += (j-k+1); // including val pair with i that satisfy this condn\\n                i++;\\n            }\\n            \\n        }\\n        \\n        \\n        return cnt;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& v, int lower, int upper) {\\n       int n = v.size();\\n    \\n        sort(v.begin(),v.end());\\n        \\n        long long  i = 0 , j = n-1,cnt = 0;\\n        \\n        while(i<j)\\n        {\\n            if(v[i]+v[j] > upper)\\n            {\\n                j--;\\n            }\\n            else if(v[i]+v[j] < lower)\\n            {\\n                i++;\\n            }\\n            \\n            else if(v[i]+v[j] >= lower and v[i]+v[j] <= upper)\\n            {\\n                // now finding the min val that is also satisfy the given condn\\n                int k = i+1;\\n                while(k<=j)\\n                {\\n                    if(v[k]+v[i] >= lower)\\n                    {\\n                        break;\\n                    }\\n                    else \\n                    {\\n                        k++;\\n                    }\\n                }\\n\\n                cnt += (j-k+1); // including val pair with i that satisfy this condn\\n                i++;\\n            }\\n            \\n        }\\n        \\n        \\n        return cnt;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246739,
                "title": "java-two-pointers",
                "content": "```\\n// for each value int the array, find the target interval\\n        public long countFairPairs(int[] nums, int lower, int upper) {\\n            Arrays.sort(nums);\\n            long res = 0;\\n            int n = nums.length;\\n            int l = n - 1, r = n - 1;\\n            for (int i = 0; i < nums.length; i++) {\\n                while (l >= 0 && nums[i] + nums[l] >= lower) --l;\\n                while (r >= 0 && nums[i] + nums[r] > upper) --r;\\n                res += Math.max(0, r - Math.max(i, l));\\n            }\\n            return res;\\n        }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n// for each value int the array, find the target interval\\n        public long countFairPairs(int[] nums, int lower, int upper) {\\n            Arrays.sort(nums);\\n            long res = 0;\\n            int n = nums.length;\\n            int l = n - 1, r = n - 1;\\n            for (int i = 0; i < nums.length; i++) {\\n                while (l >= 0 && nums[i] + nums[l] >= lower) --l;\\n                while (r >= 0 && nums[i] + nums[r] > upper) --r;\\n                res += Math.max(0, r - Math.max(i, l));\\n            }\\n            return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3241205,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long cnt(vector<int>v,int val){\\n        long ans=0;\\n        for(int i=0,j=v.size()-1;i<j;i++){\\n            while(i<j&&v[i]+v[j]>val)j--;\\n            ans+=j-i;\\n        }\\n        return ans;\\n    }\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        return cnt(nums,upper)-cnt(nums,lower-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long cnt(vector<int>v,int val){\\n        long ans=0;\\n        for(int i=0,j=v.size()-1;i<j;i++){\\n            while(i<j&&v[i]+v[j]>val)j--;\\n            ans+=j-i;\\n        }\\n        return ans;\\n    }\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        return cnt(nums,upper)-cnt(nums,lower-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236472,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def countFairPairs(nums: Array[Int], lower: Int, upper: Int): Long = {\\n        val n = nums.sorted\\n        @scala.annotation.tailrec\\n        def help(left: Int, right: Int, u: Int, res: Long):Long = {\\n            if (left >= right) res\\n            else if (n(left) + n(right) <= u) help(left + 1, right, u, res + right - left)\\n            else help(left, right - 1, u, res)\\n        }\\n        help(0, nums.length - 1, upper, 0L) - help( 0, nums.length - 1, lower - 1, 0L)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def countFairPairs(nums: Array[Int], lower: Int, upper: Int): Long = {\\n        val n = nums.sorted\\n        @scala.annotation.tailrec\\n        def help(left: Int, right: Int, u: Int, res: Long):Long = {\\n            if (left >= right) res\\n            else if (n(left) + n(right) <= u) help(left + 1, right, u, res + right - left)\\n            else help(left, right - 1, u, res)\\n        }\\n        help(0, nums.length - 1, upper, 0L) - help( 0, nums.length - 1, lower - 1, 0L)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3234934,
                "title": "two-pointer-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long toN(vector<int>& v, int limit){\\n        long long cnt = 0;\\n        for(int i = 0, j = v.size() - 1 ; i < j; i++){\\n            while(i < j && v[i] + v[j] > limit)\\n                --j;\\n            cnt += j - i;\\n        }\\n        return cnt;\\n    }\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(), nums.end());\\n        return toN(nums, upper) - toN(nums, lower  - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long toN(vector<int>& v, int limit){\\n        long long cnt = 0;\\n        for(int i = 0, j = v.size() - 1 ; i < j; i++){\\n            while(i < j && v[i] + v[j] > limit)\\n                --j;\\n            cnt += j - i;\\n        }\\n        return cnt;\\n    }\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(), nums.end());\\n        return toN(nums, upper) - toN(nums, lower  - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231503,
                "title": "using-binary-search-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int searchUpper(int x, int start, int end, int upper, vector<int>& arr){\\n        int ans = -1;\\n        while(start<=end){\\n            int mid = (start+end)/2;\\n            if(x + arr[mid] <= upper){\\n                start = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int searchLower(int x, int start, int end, int lower, vector<int>& arr){\\n        int ans = -1;\\n        while(start<=end){\\n            int mid = (start+end)/2;\\n            if(x + arr[mid] >= lower){\\n                end = mid-1;\\n                ans = mid;\\n            }\\n            else{\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    long long countFairPairs(vector<int>& arr, int lower, int upper) {\\n        int n = arr.size();\\n        long long ans=0;\\n        sort(arr.begin(), arr.end());\\n        for(int i=0; i<n; i++){\\n            int l = searchLower(arr[i], i+1, n-1, lower, arr);\\n            int u = searchUpper(arr[i], i+1, n-1, upper, arr);\\n            cout<<l<<\" \"<<u<<endl;\\n            if(l!=-1 && u!=-1){\\n                ans += (u-l+1);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int searchUpper(int x, int start, int end, int upper, vector<int>& arr){\\n        int ans = -1;\\n        while(start<=end){\\n            int mid = (start+end)/2;\\n            if(x + arr[mid] <= upper){\\n                start = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int searchLower(int x, int start, int end, int lower, vector<int>& arr){\\n        int ans = -1;\\n        while(start<=end){\\n            int mid = (start+end)/2;\\n            if(x + arr[mid] >= lower){\\n                end = mid-1;\\n                ans = mid;\\n            }\\n            else{\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    long long countFairPairs(vector<int>& arr, int lower, int upper) {\\n        int n = arr.size();\\n        long long ans=0;\\n        sort(arr.begin(), arr.end());\\n        for(int i=0; i<n; i++){\\n            int l = searchLower(arr[i], i+1, n-1, lower, arr);\\n            int u = searchUpper(arr[i], i+1, n-1, upper, arr);\\n            cout<<l<<\" \"<<u<<endl;\\n            if(l!=-1 && u!=-1){\\n                ans += (u-l+1);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3230607,
                "title": "java-one-pass-2-pointer-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n\\n        long result = 0;\\n        int start = nums.length - 1, end = nums.length - 1;\\n        for(int i = 0; i < nums.length; i++) {\\n            int l = lower - nums[i];\\n            int u = upper - nums[i];\\n            while (end >= 0 && nums[end] > u) {\\n                end--;\\n            }\\n            while (start >= 0 && nums[start] >= l) {\\n                start--;\\n            }\\n            if (end <= i) {\\n                break;\\n            }\\n            result += end - Math.max(start, i);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n\\n        long result = 0;\\n        int start = nums.length - 1, end = nums.length - 1;\\n        for(int i = 0; i < nums.length; i++) {\\n            int l = lower - nums[i];\\n            int u = upper - nums[i];\\n            while (end >= 0 && nums[end] > u) {\\n                end--;\\n            }\\n            while (start >= 0 && nums[start] >= l) {\\n                start--;\\n            }\\n            if (end <= i) {\\n                break;\\n            }\\n            result += end - Math.max(start, i);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230473,
                "title": "python3-binary-search-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        sorted_nums = sorted(nums)\\n        res = 0\\n        for element in nums:\\n            del sorted_nums[bisect.bisect_left(sorted_nums, element)]\\n            temp_lower = lower - element\\n            temp_upper = upper - element\\n            index1 = bisect.bisect_left(sorted_nums, temp_lower)\\n            index2 = bisect.bisect_right(sorted_nums, temp_upper)\\n            res += (index2 - index1)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        sorted_nums = sorted(nums)\\n        res = 0\\n        for element in nums:\\n            del sorted_nums[bisect.bisect_left(sorted_nums, element)]\\n            temp_lower = lower - element\\n            temp_upper = upper - element\\n            index1 = bisect.bisect_left(sorted_nums, temp_lower)\\n            index2 = bisect.bisect_right(sorted_nums, temp_upper)\\n            res += (index2 - index1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229708,
                "title": "java-solution-using-binary-search",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->we can find lower and upper bound by sorting the array and find the length of that subarray and add it to the answer\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public static int findlowerbound(int arr[],int low,int high,int target)\\n    {\\n        int ans=-1;\\n       int ans1=-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(arr[mid]>=target)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            if(arr[mid]<target)\\n            {\\n                low=mid+1;          }\\n            \\n        }\\n        return ans;\\n    }\\n    public static int findupperbound(int arr[],int low,int high,int target)\\n    {\\n        int ans=-1;\\n       int ans1=-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(arr[mid]<=target)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            if(arr[mid]>target)\\n            {\\n                high=mid-1;        }\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        long ans=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            int one=findlowerbound(nums,i+1,nums.length-1,lower-nums[i]);\\n            int two=findupperbound(nums,i+1,nums.length-1,upper-nums[i]);\\n            if(one==-1||two==-1)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                ans+=(long)(two-one)+1;\\n                System.out.println(ans);\\n            }\\n        }\\n        return ans;\\n        \\n       \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n   public static int findlowerbound(int arr[],int low,int high,int target)\\n    {\\n        int ans=-1;\\n       int ans1=-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(arr[mid]>=target)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            if(arr[mid]<target)\\n            {\\n                low=mid+1;          }\\n            \\n        }\\n        return ans;\\n    }\\n    public static int findupperbound(int arr[],int low,int high,int target)\\n    {\\n        int ans=-1;\\n       int ans1=-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(arr[mid]<=target)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            if(arr[mid]>target)\\n            {\\n                high=mid-1;        }\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        long ans=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            int one=findlowerbound(nums,i+1,nums.length-1,lower-nums[i]);\\n            int two=findupperbound(nums,i+1,nums.length-1,upper-nums[i]);\\n            if(one==-1||two==-1)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                ans+=(long)(two-one)+1;\\n                System.out.println(ans);\\n            }\\n        }\\n        return ans;\\n        \\n       \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229494,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size();++i){\\n            int low = lower-nums[i];\\n            int upp = upper-nums[i];\\n            ans+=upper_bound(nums.begin()+i+1,nums.end(),upp)-lower_bound(nums.begin()+i+1,nums.end(),low);\\n        }\\n        return ans;\\n    }\\n  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size();++i){\\n            int low = lower-nums[i];\\n            int upp = upper-nums[i];\\n            ans+=upper_bound(nums.begin()+i+1,nums.end(),upp)-lower_bound(nums.begin()+i+1,nums.end(),low);\\n        }\\n        return ans;\\n    }\\n  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227777,
                "title": "c-binary-search-o-n-logn",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long ans = 0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int low = max((long)i+1,lower_bound(nums.begin(),nums.end(),lower-nums[i]) - nums.begin());\\n            int upp = max((long)i+1,upper_bound(nums.begin(),nums.end(),upper-nums[i]) - nums.begin());\\n\\n            ans+=max(0,(upp-low));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long ans = 0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int low = max((long)i+1,lower_bound(nums.begin(),nums.end(),lower-nums[i]) - nums.begin());\\n            int upp = max((long)i+1,upper_bound(nums.begin(),nums.end(),upper-nums[i]) - nums.begin());\\n\\n            ans+=max(0,(upp-low));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219474,
                "title": "detailed-java-solution-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve problem with 2 pointer method but i go with binary search because we need to figure out lower bound upper bound something, So for every nums[i], find out range as if, we can add nums[i] into the range and the sum will be between [lower, upper]. So simply for every nums[i], find (lower - nums[i]) and (upper - nums[i]).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1\\n\\nSort the Array\\n\\nwhy? ignore i < j, the reason is we care of x + y should lies between the rangem here index does not plays any role\\n\\nStep 2 :\\n\\nFor every element repeat Step 3, 4 and 5.\\nStep 3 :\\n\\nFind the point uptil we can add nums[i] and get sum >= lower, say j\\nStep 4 :\\n\\nFind the point uptil we can add nums[i] and get sum <= upper, say k\\nStep 5\\n\\nWe can get answer from the k - j;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO (N * log(N))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n   public long countFairPairs(int[] nums, int lower, int upper) {\\n        long count = 0;\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i ++) {\\n            int num = nums[i];\\n            int lT = lower - num; // lower Target\\n            int uT = upper - num; // upper Target\\n            // k - j thing explained above\\n            count += (lowerUpperBound(nums, uT, i + 1, nums.length - 1, true) - \\n            lowerUpperBound(nums, lT, i + 1, nums.length - 1, false));\\n        }   \\n        return count;\\n    }\\n    public long lowerUpperBound(int [] arr, int target, int l, int r, boolean isUpper) {\\n        while(l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if(!isUpper) {  // BS lower bound\\n                if (arr[mid] < target) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid - 1;\\n                }\\n            } \\n\\n            else { // BS upper bound\\n                if (arr[mid] <= target) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid - 1;\\n                }\\n            }\\n        }\\n\\n        long ans = isUpper ? r : l - 1;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public long countFairPairs(int[] nums, int lower, int upper) {\\n        long count = 0;\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i ++) {\\n            int num = nums[i];\\n            int lT = lower - num; // lower Target\\n            int uT = upper - num; // upper Target\\n            // k - j thing explained above\\n            count += (lowerUpperBound(nums, uT, i + 1, nums.length - 1, true) - \\n            lowerUpperBound(nums, lT, i + 1, nums.length - 1, false));\\n        }   \\n        return count;\\n    }\\n    public long lowerUpperBound(int [] arr, int target, int l, int r, boolean isUpper) {\\n        while(l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if(!isUpper) {  // BS lower bound\\n                if (arr[mid] < target) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid - 1;\\n                }\\n            } \\n\\n            else { // BS upper bound\\n                if (arr[mid] <= target) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid - 1;\\n                }\\n            }\\n        }\\n\\n        long ans = isUpper ? r : l - 1;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206923,
                "title": "partition-point-approach-using-rust",
                "content": "# Intuition\\nPartition Point : Returns the index of the partition point according to the given predicate (the index of the first element of the second partition). If this slice is not partitioned, the returned result is unspecified and meaningless, as this method performs a kind of binary search.\\n\\nJust utilize this fact. Here\\'s the implementation of partition point :\\n\\n```rust\\npub fn partition_point<P>(&self, mut pred: P) -> usize\\nwhere\\n    P: FnMut(&T) -> bool,\\n{\\n    self.binary_search_by(|x| if pred(x) { Less } else { Greater }).unwrap_or_else(|i| i)\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    fn count_valid(nums: &[i32], lower: i32, upper: i32) -> usize {\\n        nums.partition_point(|&x| x <= upper) - nums.partition_point(|&x| x < lower)\\n    }\\n\\n    pub fn count_fair_pairs(nums: Vec<i32>, lower: i32, upper: i32) -> i64 {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n        let mut result = 0;\\n        for i in (0..nums.len()).rev() {\\n            result += Self::count_valid(&nums[i + 1..], lower - nums[i], upper - nums[i]);\\n        }\\n        result as i64\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\npub fn partition_point<P>(&self, mut pred: P) -> usize\\nwhere\\n    P: FnMut(&T) -> bool,\\n{\\n    self.binary_search_by(|x| if pred(x) { Less } else { Greater }).unwrap_or_else(|i| i)\\n}\\n```\n```\\nimpl Solution {\\n    fn count_valid(nums: &[i32], lower: i32, upper: i32) -> usize {\\n        nums.partition_point(|&x| x <= upper) - nums.partition_point(|&x| x < lower)\\n    }\\n\\n    pub fn count_fair_pairs(nums: Vec<i32>, lower: i32, upper: i32) -> i64 {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n        let mut result = 0;\\n        for i in (0..nums.len()).rev() {\\n            result += Self::count_valid(&nums[i + 1..], lower - nums[i], upper - nums[i]);\\n        }\\n        result as i64\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3205434,
                "title": "easy-c-solution-using-lower-bound-and-upper-bound",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(), nums.end());\\n        long long ans = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            int l = lower_bound(nums.begin() + i + 1, nums.end(), lower - nums[i]) - nums.begin();\\n            int r = upper_bound(nums.begin() + i + 1, nums.end(), upper - nums[i]) - nums.begin();\\n            ans += r - l;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(), nums.end());\\n        long long ans = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            int l = lower_bound(nums.begin() + i + 1, nums.end(), lower - nums[i]) - nums.begin();\\n            int r = upper_bound(nums.begin() + i + 1, nums.end(), upper - nums[i]) - nums.begin();\\n            ans += r - l;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203613,
                "title": "c-solution-using-lower-bound-and-upper-bound-methods",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing a given `nums[j]`, consider intergers `nums[i]` satisfying `lower <= nums[i] + nums[j] <= upper`.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort an array with respect to intergers. Here let us consider the index `j` and then we could consider the range where an index `i` satisfies the condition `lower <= nums[i] + nums[j] <= upper`.\\n\\nFirst, the minimum index (iterator) satifying `lower <= nums[i] + nums[j]` is written as `auto left = lower_bound(nums.begin(), &nums[i], lower - nums[j])` and the maximum index satifying `nums[i] + nums[j] <= upper` is written as `upper_bound(nums.begin(), iter, upper - v)--`. Then the number of indecies satisfying the condition is given as the difference of these two indecies. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn), where n is the size of a given array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(), nums.end());\\n        long long int ans = 0;\\n        auto iter = nums.begin();\\n        iter++;\\n        while(iter != nums.end()){\\n            int v = *iter;\\n            auto left = lower_bound(nums.begin(), iter, lower - v);\\n            auto right = upper_bound(nums.begin(), iter, upper - v);\\n            right--;\\n            ans += (right - left) + 1;\\n            iter++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(), nums.end());\\n        long long int ans = 0;\\n        auto iter = nums.begin();\\n        iter++;\\n        while(iter != nums.end()){\\n            int v = *iter;\\n            auto left = lower_bound(nums.begin(), iter, lower - v);\\n            auto right = upper_bound(nums.begin(), iter, upper - v);\\n            right--;\\n            ans += (right - left) + 1;\\n            iter++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201223,
                "title": "c-policy-based-ds-ordered-multiset-fun-approach",
                "content": "**Code**\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        ordered_set s;\\n        for(int i = 0; i < n; i++) {\\n            int d1 = s.order_of_key(upper - nums[i] + 1);\\n            int d2 = s.order_of_key(lower - nums[i]);\\n            ans += (d1 - d2);\\n            s.insert(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        ordered_set s;\\n        for(int i = 0; i < n; i++) {\\n            int d1 = s.order_of_key(upper - nums[i] + 1);\\n            int d2 = s.order_of_key(lower - nums[i]);\\n            ans += (d1 - d2);\\n            s.insert(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3200590,
                "title": "easy-similar-to-2-sum",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    long long countFairPairs(vector<int>& arr, int lower, int upper) {\\n        sort(arr.begin(),arr.end());\\n        long long cnt=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int lb=lower-arr[i], ub=upper-arr[i];\\n            cnt+= (upper_bound(arr.begin()+(i+1), arr.end(), ub)-lower_bound(arr.begin()+(i+1), arr.end(), lb));\\n        }\\n        return cnt;\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    long long countFairPairs(vector<int>& arr, int lower, int upper) {\\n        sort(arr.begin(),arr.end());\\n        long long cnt=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int lb=lower-arr[i], ub=upper-arr[i];\\n            cnt+= (upper_bound(arr.begin()+(i+1), arr.end(), ub)-lower_bound(arr.begin()+(i+1), arr.end(), lb));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3198980,
                "title": "golang-two-pointers",
                "content": "# Code\\n```\\nfunc solve(nums []int, target int) int64 {\\n    var i, j = 0, len(nums) - 1\\n    var ans int64 = 0\\n    for i < j {\\n        for i < j && nums[i] + nums[j] > target {\\n            j--\\n        }\\n        ans += int64(j - i)\\n        i++\\n    }\\n    return ans\\n}\\n\\nfunc countFairPairs(nums []int, lower int, upper int) int64 {\\n    sort.Ints(nums)\\n    return solve(nums, upper) - solve(nums, lower - 1)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nfunc solve(nums []int, target int) int64 {\\n    var i, j = 0, len(nums) - 1\\n    var ans int64 = 0\\n    for i < j {\\n        for i < j && nums[i] + nums[j] > target {\\n            j--\\n        }\\n        ans += int64(j - i)\\n        i++\\n    }\\n    return ans\\n}\\n\\nfunc countFairPairs(nums []int, lower int, upper int) int64 {\\n    sort.Ints(nums)\\n    return solve(nums, upper) - solve(nums, lower - 1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3198945,
                "title": "sorting-binary-search-bounds-with-comments",
                "content": "```\\n//Make sure you are have clarification of what is upper and lower bounds are before attempting this problem !\\n//Watch here - [https://youtu.be/Cg7SI0WtmXY]\\n\\n\\t\\tsort(begin(nums),end(nums));\\n        long long ans = 0,n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int lwr=lower - nums[i],upr=upper - nums[i];  \\n            ans+=upper_bound(nums.begin()+i+1,nums.end(),upr)-lower_bound(nums.begin()+i+1,nums.end(),lwr);\\n        }\\n        return ans;",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n//Make sure you are have clarification of what is upper and lower bounds are before attempting this problem !\\n//Watch here - [https://youtu.be/Cg7SI0WtmXY]\\n\\n\\t\\tsort(begin(nums),end(nums));\\n        long long ans = 0,n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int lwr=lower - nums[i],upr=upper - nums[i];  \\n            ans+=upper_bound(nums.begin()+i+1,nums.end(),upr)-lower_bound(nums.begin()+i+1,nums.end(),lwr);\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 3198813,
                "title": "python-one-liner-with-binary-search-the-best",
                "content": "# Approach\\nSort the input and use binary search to bound the indices range for second value in the pair for each possible first value.\\n\\nThe Best!\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```py\\ndef countFairPairs(self, nums: list[int], lower: int, upper: int) -> int:\\n    return sum(bisect.bisect(nums, upper-x, i+1) - bisect.bisect_left(nums, lower-x, i+1)\\n               for nums in [sorted(nums)] for i, x in enumerate(nums))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\ndef countFairPairs(self, nums: list[int], lower: int, upper: int) -> int:\\n    return sum(bisect.bisect(nums, upper-x, i+1) - bisect.bisect_left(nums, lower-x, i+1)\\n               for nums in [sorted(nums)] for i, x in enumerate(nums))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3198485,
                "title": "c-easy-linear-search-o-n-solution",
                "content": "# Intuition\\nset theory concept-let says range you want value from range 3 to 6 :\\nfirst find values less than 6 and values less than 3 then  take diffrence you will get ans.\\n# Approach\\nLinear search  C++ solution  Easy Simple \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n  sort(nums.begin(), nums.end());\\n  int n = nums.size(),s=0,e=n-1;\\n  long long ct = 0,cnt1=0,cnt2=0;\\n//         number less than uppper.\\n    while(s<=e){\\n      if((nums[s]+nums[e])<=upper){\\n          cnt2+=e-s;\\n          s++;\\n      }else e--;\\n    }\\n//         no less than lower.\\n        s=0,e=n-1;\\n    while(s<=e){\\n        if((nums[s]+nums[e])<lower){\\n          cnt1+=e-s;\\n          s++;\\n      }else e--;\\n    }    \\n    ct=cnt2-cnt1;\\n  return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n  sort(nums.begin(), nums.end());\\n  int n = nums.size(),s=0,e=n-1;\\n  long long ct = 0,cnt1=0,cnt2=0;\\n//         number less than uppper.\\n    while(s<=e){\\n      if((nums[s]+nums[e])<=upper){\\n          cnt2+=e-s;\\n          s++;\\n      }else e--;\\n    }\\n//         no less than lower.\\n        s=0,e=n-1;\\n    while(s<=e){\\n        if((nums[s]+nums[e])<lower){\\n          cnt1+=e-s;\\n          s++;\\n      }else e--;\\n    }    \\n    ct=cnt2-cnt1;\\n  return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198419,
                "title": "intuitive-solution-with-array-binary-search-explained",
                "content": "# Intuition\\nSimilar to 3 sum problem. We have fix one number and find other possible number in logn, building base for sorting. \\n\\n# Approach\\nI fixed all element once, in remaining array obtain the lower value and upper value which we need to find in the array. We need sorting array for this.\\neg. fixed number is 3, lower=1, upper=4\\nwe need to find number of element between -2(lower-fixed number) and  4(upper-fixed number)\\n\\nFor this i created two helper function , using binary search \\nupppervalue: telling the index just greater than required by upper element finded by us. \\nlowervalue:telling the index just smaller than required by lower element finded by us. \\n\\nWe can take all element between index founded by helper function.\\n\\nspecial case: if i also forms a part of of index range , then we have to exclude it , as we cannot take same number twice.\\n\\n\\n At last we half our ans because of contraint i<j as we have included cases where j>i;\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int findupperindex(vector<int>& arr,int target){\\n        int s=0,e=arr.size()-1;\\n        int mid;\\n         while(s<=e){\\n            // cout<<s<<\" \"<<e<<endl;\\n            mid=s+(e-s)/2;\\n            \\n          if(target>=arr[mid]){\\n                s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n                }            \\n        } \\n\\n        return s; \\n    }\\n\\n    int findlowerindex(vector<int> &arr,int target){\\n\\n        int s=0,e=arr.size()-1;\\n        int mid;\\n        while(s<=e){\\n            // cout<<s<<\" \"<<e<<endl;\\n            mid=s+(e-s)/2;\\n            \\n          if(target>arr[mid]){\\n                s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n                }            \\n        }\\nreturn e;\\n    }\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        \\n        sort(nums.begin(),nums.end());\\n       long long ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int lowerval=lower-nums[i];\\n            int upperval=upper-nums[i];\\n            int lowerindex=findlowerindex(nums,lowerval);\\n            int upperindex=findupperindex(nums,upperval);\\n            ans+=upperindex-lowerindex-1;\\n            if(i>lowerindex&& i<upperindex)\\n            ans-=1;\\n            // cout<<upperindex<<\" \"<<lowerindex<<endl; \\n        }\\n\\nreturn ans/2;\\n\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    int findupperindex(vector<int>& arr,int target){\\n        int s=0,e=arr.size()-1;\\n        int mid;\\n         while(s<=e){\\n            // cout<<s<<\" \"<<e<<endl;\\n            mid=s+(e-s)/2;\\n            \\n          if(target>=arr[mid]){\\n                s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n                }            \\n        } \\n\\n        return s; \\n    }\\n\\n    int findlowerindex(vector<int> &arr,int target){\\n\\n        int s=0,e=arr.size()-1;\\n        int mid;\\n        while(s<=e){\\n            // cout<<s<<\" \"<<e<<endl;\\n            mid=s+(e-s)/2;\\n            \\n          if(target>arr[mid]){\\n                s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n                }            \\n        }\\nreturn e;\\n    }\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        \\n        sort(nums.begin(),nums.end());\\n       long long ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int lowerval=lower-nums[i];\\n            int upperval=upper-nums[i];\\n            int lowerindex=findlowerindex(nums,lowerval);\\n            int upperindex=findupperindex(nums,upperval);\\n            ans+=upperindex-lowerindex-1;\\n            if(i>lowerindex&& i<upperindex)\\n            ans-=1;\\n            // cout<<upperindex<<\" \"<<lowerindex<<endl; \\n        }\\n\\nreturn ans/2;\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3198183,
                "title": "c-two-solution-binary-search-two-pointers",
                "content": "# Code\\n```\\n// Binary Search\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(), nums.end());\\n        long long ans = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            ans += upper_bound(nums.begin() + i + 1, nums.end(), upper - nums[i]) - lower_bound(nums.begin() + i + 1, nums.end(), lower - nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Two Pointers\\nclass Solution {\\n    long long solve(vector<int> &nums, int target) {\\n        int i = 0, j = nums.size() - 1;\\n        long long ans = 0;\\n        while(i < j) {\\n            while(i < j && nums[i] + nums[j] > target) {\\n                j--;\\n            }\\n            ans += j - i;\\n            i++;\\n        }\\n        return ans;\\n    }\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(), nums.end());\\n        return solve(nums, upper) - solve(nums, lower - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n// Binary Search\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(), nums.end());\\n        long long ans = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            ans += upper_bound(nums.begin() + i + 1, nums.end(), upper - nums[i]) - lower_bound(nums.begin() + i + 1, nums.end(), lower - nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Two Pointers\\nclass Solution {\\n    long long solve(vector<int> &nums, int target) {\\n        int i = 0, j = nums.size() - 1;\\n        long long ans = 0;\\n        while(i < j) {\\n            while(i < j && nums[i] + nums[j] > target) {\\n                j--;\\n            }\\n            ans += j - i;\\n            i++;\\n        }\\n        return ans;\\n    }\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(), nums.end());\\n        return solve(nums, upper) - solve(nums, lower - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197198,
                "title": "java-sorting-similar-to-two-sum-binary-search-solution-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int getMax(int[] nums, int target, int start) {\\n        int low = start, high = nums.length - 1;\\n        while(low <= high) {\\n            int mid = (low + high) / 2;\\n            \\n            if(target < nums[mid]) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n    private int getMin(int[] nums, int target, int start) {\\n        int low = start, high = nums.length - 1;\\n        while(low <= high) {\\n            int mid = (low + high) / 2;\\n            \\n            if(target <= nums[mid]) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long ans = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            int minIdx = getMin(nums, lower - nums[i], i+1);\\n            int maxIdx = getMax(nums, upper - nums[i], i+1);\\n\\n            //Finding a valid pairs\\n            if(minIdx > i && maxIdx > i) {\\n                if(minIdx <= maxIdx) {\\n                    ans += (long)((maxIdx - minIdx) + 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    private int getMax(int[] nums, int target, int start) {\\n        int low = start, high = nums.length - 1;\\n        while(low <= high) {\\n            int mid = (low + high) / 2;\\n            \\n            if(target < nums[mid]) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n    private int getMin(int[] nums, int target, int start) {\\n        int low = start, high = nums.length - 1;\\n        while(low <= high) {\\n            int mid = (low + high) / 2;\\n            \\n            if(target <= nums[mid]) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long ans = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            int minIdx = getMin(nums, lower - nums[i], i+1);\\n            int maxIdx = getMax(nums, upper - nums[i], i+1);\\n\\n            //Finding a valid pairs\\n            if(minIdx > i && maxIdx > i) {\\n                if(minIdx <= maxIdx) {\\n                    ans += (long)((maxIdx - minIdx) + 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197093,
                "title": "java-treemap",
                "content": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n       // for every element we have to find the elements which is >= lower and <= upper\\n       // we will sort the array,once sorted we can see for eche element which is the starting\\n       // and ending points\\n        if(nums.length==1) return 0;\\n        Arrays.sort(nums);\\n        \\n        Map<Integer,Integer> startIndexMap = new HashMap<>();\\n        Map<Integer,Integer> endIndexMap = new HashMap<>();\\n        TreeMap<Integer,Integer> orderedMap = new TreeMap<>();\\n        \\n        long ans = 0;\\n        \\n        int startIndex=0,endIndex = 0;\\n        int ind = 0;\\n        for(int i : nums){\\n            //let\\'s create the range if we thake i then we have find value(j) which is >= lower - i and <= upper - i\\n            //how?..think if we have to make one pair(i,j) ---> where lower >= i+j <= upper\\n            //so if we think every i creates pair then lower - i >= j <= upper - i\\n            //once the map prepared we just have to find the boundary indexes\\n            if(!startIndexMap.containsKey(i)){\\n        \\n                startIndexMap.put(i,ind);\\n            \\n            }\\n            \\n            endIndexMap.put(i,ind);\\n            \\n            //get the boudaries as the number previously\\n            \\n            Integer lowerBoundary = orderedMap.ceilingKey(lower - i);//start\\n            Integer upperBoundary = orderedMap.floorKey( upper - i);//end\\n            \\n            if(lowerBoundary != null && upperBoundary != null ){\\n                //get the indexes from index maps for getting how many mubers are there inside that boundary\\n                ans += endIndexMap.get(upperBoundary) - startIndexMap.get(lowerBoundary) ;\\n                if(upperBoundary != i){\\n                    ans+=1;\\n                }\\n            }\\n            orderedMap.put(i,0);\\n            \\n            ind++;\\n            \\n            \\n        }\\n        \\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n       // for every element we have to find the elements which is >= lower and <= upper\\n       // we will sort the array,once sorted we can see for eche element which is the starting\\n       // and ending points\\n        if(nums.length==1) return 0;\\n        Arrays.sort(nums);\\n        \\n        Map<Integer,Integer> startIndexMap = new HashMap<>();\\n        Map<Integer,Integer> endIndexMap = new HashMap<>();\\n        TreeMap<Integer,Integer> orderedMap = new TreeMap<>();\\n        \\n        long ans = 0;\\n        \\n        int startIndex=0,endIndex = 0;\\n        int ind = 0;\\n        for(int i : nums){\\n            //let\\'s create the range if we thake i then we have find value(j) which is >= lower - i and <= upper - i\\n            //how?..think if we have to make one pair(i,j) ---> where lower >= i+j <= upper\\n            //so if we think every i creates pair then lower - i >= j <= upper - i\\n            //once the map prepared we just have to find the boundary indexes\\n            if(!startIndexMap.containsKey(i)){\\n        \\n                startIndexMap.put(i,ind);\\n            \\n            }\\n            \\n            endIndexMap.put(i,ind);\\n            \\n            //get the boudaries as the number previously\\n            \\n            Integer lowerBoundary = orderedMap.ceilingKey(lower - i);//start\\n            Integer upperBoundary = orderedMap.floorKey( upper - i);//end\\n            \\n            if(lowerBoundary != null && upperBoundary != null ){\\n                //get the indexes from index maps for getting how many mubers are there inside that boundary\\n                ans += endIndexMap.get(upperBoundary) - startIndexMap.get(lowerBoundary) ;\\n                if(upperBoundary != i){\\n                    ans+=1;\\n                }\\n            }\\n            orderedMap.put(i,0);\\n            \\n            ind++;\\n            \\n            \\n        }\\n        \\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195815,
                "title": "two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a two pointer question.\\nWe need to get all sum>=lower & sum<=upper.\\nWe need to select two numbers from array to get the sum(nums[i]+nums[j]). \\n \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach 1\\n1) Select a number in the array nums[i].\\n2)  find another numbers in array that satisfy\\n (nums[i]+nums[j]>=lower && nums[i] +nums[j]<=upper)\\nThe second can be done using\\na) brute force using for loop\\nb)the numbers can be sorted from the beginning to use binary search.\\n            auto itr1=lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i]);\\n            auto itr2=upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i]);\\n            count+=(itr2-itr1);\\nApproach 2\\n1)Find all sums less than upper limit\\n2)Find all sums less than lower limit -1\\n3) Get their difference.\\nThis can be also done using two pointer but twice, i.e step1 & step2.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLog(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long count=0;\\n        \\n       \\n        for(int i=0;i<nums.size();++i){\\n            auto itr1=lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i]);\\n            auto itr2=upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i]);\\n            count+=(itr2-itr1);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long count=0;\\n        \\n       \\n        for(int i=0;i<nums.size();++i){\\n            auto itr1=lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i]);\\n            auto itr2=upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i]);\\n            count+=(itr2-itr1);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194592,
                "title": "java-basic-approach-o-n-log-n-time-o-1-space",
                "content": "\\n    class Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        long ans=0;\\n       Arrays.sort(nums);\\n        \\n        \\n        for(int i=0;i<nums.length;i++){\\n\\n            int first=binaryLower(nums,i+1,nums.length-1,lower-nums[i]);\\n            int second=binaryUpper(nums,i+1,nums.length-1,upper-nums[i]);\\n            \\n            // after find the lower and uper bound index now it just simple\\n            if(first!=-1 && second!=-1) ans+=(second-first)+1;\\n        }\\n        return ans;\\n    }\\n\\n    // for finding possible smalest index for lower bound\\n    public int binaryLower(int a[],int i,int n,int tar){\\n        \\n        int index=-1;\\n        \\n        while(i<=n){\\n            \\n        int mid=i+(n-i)/2;\\n            \\n        if(a[mid]<tar){\\n            \\n            i=mid+1;\\n            \\n        }else if(a[mid]>tar){ // here we found our possible lower bound but we have to Check if any better index we can get\\n\\n            index=mid;\\n            n=mid-1;\\n           \\n            \\n        }else if(a[mid]==tar){ //here we found our possible lower bound but we have to Check if any better index we can get(if value is repeated)\\n            \\n            index=mid;\\n            \\n            n=mid-1;\\n        }\\n            \\n        }\\n        return index;\\n    }\\n\\n    // for finding the possible largest  index for upper bound\\n    public int binaryUpper(int a[],int i,int n,int tar){\\n        int index=-1;\\n        \\n        while(i<=n){\\n            \\n        int mid=i+(n-i)/2;\\n            \\n        if(a[mid]<tar){ //here we found our possible upper bound but we have to  Check if any better index we can get\\n\\n            index=mid;\\n            i=mid+1;\\n            \\n        }else if(a[mid]>tar){\\n            \\n            \\n            n=mid-1;\\n            \\n        }else if(a[mid]==tar){ //here we found our possible upper bound but we have to Check  if any better index we can get(if value is repeated)\\n\\n            index=mid;\\n            i=mid+1;\\n        }\\n            \\n        }\\n        return index;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        long ans=0;\\n       Arrays.sort(nums);\\n        \\n        \\n        for(int i=0;i<nums.length;i++){\\n\\n            int first=binaryLower(nums,i+1,nums.length-1,lower-nums[i]);\\n            int second=binaryUpper(nums,i+1,nums.length-1,upper-nums[i]);\\n            \\n            // after find the lower and uper bound index now it just simple\\n            if(first!=-1 && second!=-1) ans+=(second-first)+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3190337,
                "title": "c-sorting-binary-search-faster-easy-to-understand",
                "content": "* ***Using Sorting && Binary Search***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        \\n        int n = nums.size();\\n        \\n        // sort the array\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        long long ans = 0;\\n        \\n        // traverse over the array\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // find the left index\\n            \\n            int left_idx = lower_bound(nums.begin(), nums.begin() + i, lower - nums[i]) - nums.begin();\\n            \\n            // find the right index\\n            \\n            int right_idx = upper_bound(nums.begin(), nums.begin() + i, upper - nums[i]) - nums.begin();\\n            \\n            // update ans\\n            \\n            ans += right_idx - left_idx;\\n        }\\n        \\n        // return ans\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        \\n        int n = nums.size();\\n        \\n        // sort the array\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        long long ans = 0;\\n        \\n        // traverse over the array\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // find the left index\\n            \\n            int left_idx = lower_bound(nums.begin(), nums.begin() + i, lower - nums[i]) - nums.begin();\\n            \\n            // find the right index\\n            \\n            int right_idx = upper_bound(nums.begin(), nums.begin() + i, upper - nums[i]) - nums.begin();\\n            \\n            // update ans\\n            \\n            ans += right_idx - left_idx;\\n        }\\n        \\n        // return ans\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190291,
                "title": "binary-search-sorting-o-nlogn-solution",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int lowerb=lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i])-nums.begin();\\n            int upperb=upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i])-nums.begin();\\n            ans+=upperb-lowerb;\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int lowerb=lower_bound(nums.begin()+i+1,nums.end(),lower-nums[i])-nums.begin();\\n            int upperb=upper_bound(nums.begin()+i+1,nums.end(),upper-nums[i])-nums.begin();\\n            ans+=upperb-lowerb;\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190061,
                "title": "o-n-easy-java-solution-treemap",
                "content": "# Intuition\\nMake two treemaps which contain the first index and last index of a value in array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        long count=0;\\n        if(nums.length==1) return count;\\n        Arrays.sort(nums);\\n        TreeMap<Integer,Integer> map1 = new TreeMap<>();\\n        TreeMap<Integer,Integer> map2 = new TreeMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(!map1.containsKey(nums[i])) map1.put(nums[i],i);\\n            map2.put(nums[i],i);\\n            Integer l = map2.ceilingKey(lower-nums[i]);\\n            Integer r = map2.floorKey(upper-nums[i]);\\n            if(l==null || r==null || l>r) continue;\\n            count+=map2.get(r)-map1.get(l);\\n            if(map2.get(r)!=i) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        long count=0;\\n        if(nums.length==1) return count;\\n        Arrays.sort(nums);\\n        TreeMap<Integer,Integer> map1 = new TreeMap<>();\\n        TreeMap<Integer,Integer> map2 = new TreeMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(!map1.containsKey(nums[i])) map1.put(nums[i],i);\\n            map2.put(nums[i],i);\\n            Integer l = map2.ceilingKey(lower-nums[i]);\\n            Integer r = map2.floorKey(upper-nums[i]);\\n            if(l==null || r==null || l>r) continue;\\n            count+=map2.get(r)-map1.get(l);\\n            if(map2.get(r)!=i) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188117,
                "title": "2-approach-to-solve-the-problem-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int val) {\\n        long long res = 0;\\n        int n = nums.size();\\n        for (int l = 0, r = n-1; l < r; l++) {\\n            while(l < r && (nums[l] + nums[r]) > val)\\n                r--;\\n            res += (r-l);\\n        }\\n        return res;\\n    }\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(begin(nums),end(nums));\\n        long long lessThanEqualUpper = countPairs(nums,upper);\\n        long long lessThanLower = countPairs(nums,lower-1);\\n        return (lessThanEqualUpper - lessThanLower);\\n    }\\n};\\n\\nclass Solution1 {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(begin(nums),end(nums));\\n        long long result = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int n = nums[i];\\n            int min = lower-n;\\n            int max = upper-n;\\n            auto it1 = lower_bound(begin(nums)+i+1,end(nums),min);\\n            auto it2 = upper_bound(begin(nums)+i+1,end(nums),max);\\n            result += (it2-it1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int val) {\\n        long long res = 0;\\n        int n = nums.size();\\n        for (int l = 0, r = n-1; l < r; l++) {\\n            while(l < r && (nums[l] + nums[r]) > val)\\n                r--;\\n            res += (r-l);\\n        }\\n        return res;\\n    }\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(begin(nums),end(nums));\\n        long long lessThanEqualUpper = countPairs(nums,upper);\\n        long long lessThanLower = countPairs(nums,lower-1);\\n        return (lessThanEqualUpper - lessThanLower);\\n    }\\n};\\n\\nclass Solution1 {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(begin(nums),end(nums));\\n        long long result = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int n = nums[i];\\n            int min = lower-n;\\n            int max = upper-n;\\n            auto it1 = lower_bound(begin(nums)+i+1,end(nums),min);\\n            auto it2 = upper_bound(begin(nums)+i+1,end(nums),max);\\n            result += (it2-it1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186243,
                "title": "simple-c-solution",
                "content": "\\n# Approach\\nBrute Force Solution\\n\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& v, int lower, int upper) {\\n        \\n        long long ans =0;\\n        sort(v.begin(),v.end());\\n        for(int i =0;i<v.size();i++){\\n            int l = lower-v[i];\\n            int u = upper-v[i];\\n            \\n            ans+=upper_bound(v.begin()+(i+1),v.end(),u) - lower_bound(v.begin()+(i+1),v.end(),l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& v, int lower, int upper) {\\n        \\n        long long ans =0;\\n        sort(v.begin(),v.end());\\n        for(int i =0;i<v.size();i++){\\n            int l = lower-v[i];\\n            int u = upper-v[i];\\n            \\n            ans+=upper_bound(v.begin()+(i+1),v.end(),u) - lower_bound(v.begin()+(i+1),v.end(),l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185635,
                "title": "binary-search-yes-worse-than-o-n",
                "content": "```ruby\\ndef count_fair_pairs(a, l, u) =\\n    (0..(z = (a.sort! << 9e9).size) - 2).reduce(0) do | r, i |\\n        r + (x = u - a[i]; i + 1...z).bsearch { a[_1] >  x } -\\n            (x = l - a[i]; i + 1...z).bsearch { a[_1] >= x }\\n    end\\n```",
                "solutionTags": [
                    "Ruby",
                    "Binary Search"
                ],
                "code": "```ruby\\ndef count_fair_pairs(a, l, u) =\\n    (0..(z = (a.sort! << 9e9).size) - 2).reduce(0) do | r, i |\\n        r + (x = u - a[i]; i + 1...z).bsearch { a[_1] >  x } -\\n            (x = l - a[i]; i + 1...z).bsearch { a[_1] >= x }\\n    end\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3185569,
                "title": "binary-search-with-easy-to-understand-explanation-sort-bin-search",
                "content": "# Intuition\\'\\nUse the length of window which is falling under the [lower, upper] range for every pair of elements. To make things quicker we will be using binary search technique\\n\\narr[i] + arr[j] == arr[j] + arr[i]\\ntherefore, position of i and j does not matter as long as they are not equal\\n\\n# Approach\\nAs you may have observed that the lower and upper from each index can be found in O(log n) speed if we use binary search technique at each index to find the value of \\ni. index of first element which is greater or equal to LOWER limit when added along with the number at current index\\nii. index of last element which is less than or equal to UPPER limit when added with number at current index.\\n\\nfor example:-\\nLet a = element at current index\\n    b = element at any other index.\\n    to find the value of b in case we already know the value of a, we can find the number which is >= to (Lower - a)\\nbecause  a + b >= lower (as given in problem)\\n    =>  b >= lower - a\\n\\nsimilarly for upper,\\n     a + b <= upper\\n    => b <= upper - a\\n\\n# Complexity\\n- Time complexity:\\nO(n log(n))\\n\\n- Space complexity:\\nO(1);\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // get the index of FIRST element which is Greater Or Equal to \"lower\" value\\n    int getLower(vector<int>& nums, int l, int r, int& lower){\\n        int i = l-1;\\n        int mid, ans=l;\\n        while( l<=r ){\\n            mid = l + (r-l)/2;\\n            if(nums[i] + nums[mid] >= lower){\\n                ans = mid;\\n                r = mid - 1;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    // get the index of LAST element which is Less than or Equals to \"upper\" value.\\n    int getUpper(vector<int>& nums, int l, int r, int& upper){\\n        int i = l-1;\\n        int mid, ans=l;\\n        while( l<=r ){\\n            mid = l + (r-l)/2;\\n            if(nums[i] + nums[mid] <= upper){\\n                ans = mid;\\n                l = mid + 1;\\n            }else{\\n                r = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans = 0;\\n        int n = nums.size();\\n\\n        // it is only requried that i != j. Constraints are to divert your thinking abilities.\\n        sort(nums.begin(), nums.end());\\n\\n        for(int i = 0 ; i<n-1 ; i++){\\n            int l = getLower(nums, i+1, n-1, lower);\\n            int r = getUpper(nums, i+1, n-1, upper);\\n            if((nums[i] + nums[l]) >= lower && (nums[i] + nums[r]) <= upper)\\n                ans += (r - l + 1);\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n\\n    // get the index of FIRST element which is Greater Or Equal to \"lower\" value\\n    int getLower(vector<int>& nums, int l, int r, int& lower){\\n        int i = l-1;\\n        int mid, ans=l;\\n        while( l<=r ){\\n            mid = l + (r-l)/2;\\n            if(nums[i] + nums[mid] >= lower){\\n                ans = mid;\\n                r = mid - 1;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    // get the index of LAST element which is Less than or Equals to \"upper\" value.\\n    int getUpper(vector<int>& nums, int l, int r, int& upper){\\n        int i = l-1;\\n        int mid, ans=l;\\n        while( l<=r ){\\n            mid = l + (r-l)/2;\\n            if(nums[i] + nums[mid] <= upper){\\n                ans = mid;\\n                l = mid + 1;\\n            }else{\\n                r = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans = 0;\\n        int n = nums.size();\\n\\n        // it is only requried that i != j. Constraints are to divert your thinking abilities.\\n        sort(nums.begin(), nums.end());\\n\\n        for(int i = 0 ; i<n-1 ; i++){\\n            int l = getLower(nums, i+1, n-1, lower);\\n            int r = getUpper(nums, i+1, n-1, upper);\\n            if((nums[i] + nums[l]) >= lower && (nums[i] + nums[r]) <= upper)\\n                ans += (r - l + 1);\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185110,
                "title": "c-solution-using-merge-sort-divide-and-conquer-and-binary-search-technique",
                "content": "Problems reletaed to Merge Sort\\n1. https://leetcode.com/problems/reverse-pairs/\\n2. https://leetcode.com/problems/count-of-smaller-numbers-after-self/\\n3. https://leetcode.com/problems/reverse-pairs/submissions/\\n\\n```\\nclass Solution {\\npublic:\\n    long long merge(int lo, int mid, int hi, vector<int>& nums, int lower, int upper) {\\n        long long ans = 0;\\n        \\n        // Geeting the start Index and the end Index of the elements which satify the given conditions.\\n        for(int i = lo; i <= mid; i++) {\\n            \\n            // Using Binary Search to get the start and end Index.\\n            int startIdx = lower_bound(nums.begin() + mid + 1, nums.begin() + hi + 1, lower - nums[i]) - nums.begin(); \\n            int endIdx = upper_bound(nums.begin() + mid + 1, nums.begin() + hi + 1, upper - nums[i]) - nums.begin();\\n            ans += 1LL * (endIdx - startIdx);\\n        }\\n        \\n        // Merging two sorted array.\\n        vector<int>curr;\\n        int s = lo, e = mid + 1;\\n        while(s <= mid and e <= hi) {\\n            if(nums[s] < nums[e]) {\\n                curr.push_back(nums[s]);\\n                s++;\\n            }\\n            else {\\n                curr.push_back(nums[e]);\\n                e++;\\n            }\\n        }\\n        while(s <= mid) {\\n            curr.push_back(nums[s]);\\n            s++;\\n        }\\n        while(e <= hi) {\\n            curr.push_back(nums[e]);\\n            e++;\\n        }\\n        int idx = 0;\\n        for (int i = lo; i <= hi; i++) {\\n            nums[i] = curr[idx];\\n            idx++;\\n        }\\n        return ans;\\n    }\\n    long long mergeSort(int lo, int hi, vector<int>& nums, int lower, int upper) {\\n        if(lo >= hi) {\\n            return 0;\\n        }\\n        int mid = (hi + lo)/2;\\n        \\n        // Calling MergeSort from lo to mid\\n        long long ans = mergeSort(lo, mid, nums, lower, upper);\\n        \\n        // Calling MergeSort from mid + 1 to hi\\n        ans += mergeSort(mid + 1, hi, nums, lower, upper);\\n        \\n        // Merging the two sorted array.\\n        ans += merge(lo, mid, hi, nums, lower, upper);\\n        return ans;\\n    }\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        return mergeSort(0, nums.size() - 1, nums, lower, upper);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Divide and Conquer",
                    "Sorting",
                    "Merge Sort",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long merge(int lo, int mid, int hi, vector<int>& nums, int lower, int upper) {\\n        long long ans = 0;\\n        \\n        // Geeting the start Index and the end Index of the elements which satify the given conditions.\\n        for(int i = lo; i <= mid; i++) {\\n            \\n            // Using Binary Search to get the start and end Index.\\n            int startIdx = lower_bound(nums.begin() + mid + 1, nums.begin() + hi + 1, lower - nums[i]) - nums.begin(); \\n            int endIdx = upper_bound(nums.begin() + mid + 1, nums.begin() + hi + 1, upper - nums[i]) - nums.begin();\\n            ans += 1LL * (endIdx - startIdx);\\n        }\\n        \\n        // Merging two sorted array.\\n        vector<int>curr;\\n        int s = lo, e = mid + 1;\\n        while(s <= mid and e <= hi) {\\n            if(nums[s] < nums[e]) {\\n                curr.push_back(nums[s]);\\n                s++;\\n            }\\n            else {\\n                curr.push_back(nums[e]);\\n                e++;\\n            }\\n        }\\n        while(s <= mid) {\\n            curr.push_back(nums[s]);\\n            s++;\\n        }\\n        while(e <= hi) {\\n            curr.push_back(nums[e]);\\n            e++;\\n        }\\n        int idx = 0;\\n        for (int i = lo; i <= hi; i++) {\\n            nums[i] = curr[idx];\\n            idx++;\\n        }\\n        return ans;\\n    }\\n    long long mergeSort(int lo, int hi, vector<int>& nums, int lower, int upper) {\\n        if(lo >= hi) {\\n            return 0;\\n        }\\n        int mid = (hi + lo)/2;\\n        \\n        // Calling MergeSort from lo to mid\\n        long long ans = mergeSort(lo, mid, nums, lower, upper);\\n        \\n        // Calling MergeSort from mid + 1 to hi\\n        ans += mergeSort(mid + 1, hi, nums, lower, upper);\\n        \\n        // Merging the two sorted array.\\n        ans += merge(lo, mid, hi, nums, lower, upper);\\n        return ans;\\n    }\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        return mergeSort(0, nums.size() - 1, nums, lower, upper);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184233,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func countFairPairs(_ nums: [Int], _ lower: Int, _ upper: Int) -> Int {\\n        let n = nums.count\\n        guard n > 1 else { return 0 }\\n        let sorted = nums.sorted(by: <)\\n        var ans = 0\\n        \\n        func countPairSumLess(_ target: Int) -> Int {\\n            var count = 0\\n            for i in 0..<n-1 {\\n                if sorted[i] + sorted[i+1] > target { continue }\\n                var left = i+1\\n                var right = n-1\\n                var j = left\\n                while left <= right {\\n                    let mid = left + (right - left) / 2 \\n                    if sorted[i] + sorted[mid] > target {\\n                        right = mid-1\\n                    } else {\\n                        j = mid\\n                        left = mid+1\\n                    }\\n                }\\n                count += j-i\\n            }\\n            \\n            return count\\n        }\\n        \\n        return countPairSumLess(upper) - countPairSumLess(lower-1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countFairPairs(_ nums: [Int], _ lower: Int, _ upper: Int) -> Int {\\n        let n = nums.count\\n        guard n > 1 else { return 0 }\\n        let sorted = nums.sorted(by: <)\\n        var ans = 0\\n        \\n        func countPairSumLess(_ target: Int) -> Int {\\n            var count = 0\\n            for i in 0..<n-1 {\\n                if sorted[i] + sorted[i+1] > target { continue }\\n                var left = i+1\\n                var right = n-1\\n                var j = left\\n                while left <= right {\\n                    let mid = left + (right - left) / 2 \\n                    if sorted[i] + sorted[mid] > target {\\n                        right = mid-1\\n                    } else {\\n                        j = mid\\n                        left = mid+1\\n                    }\\n                }\\n                count += j-i\\n            }\\n            \\n            return count\\n        }\\n        \\n        return countPairSumLess(upper) - countPairSumLess(lower-1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183380,
                "title": "too-easy-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long countFairPairs(vector<int>& v, int l, int u) {\\n        sort(v.begin(),v.end());\\n        ll ans=0;\\n        for(int i=0; i<v.size()-1; i++) {\\n            ll x=l-v[i],y=u-v[i];\\n            auto p=lower_bound(v.begin()+i+1,v.end(),x);\\n            auto q=upper_bound(v.begin()+i+1,v.end(),y);\\n            ans+=q-p;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long countFairPairs(vector<int>& v, int l, int u) {\\n        sort(v.begin(),v.end());\\n        ll ans=0;\\n        for(int i=0; i<v.size()-1; i++) {\\n            ll x=l-v[i],y=u-v[i];\\n            auto p=lower_bound(v.begin()+i+1,v.end(),x);\\n            auto q=upper_bound(v.begin()+i+1,v.end(),y);\\n            ans+=q-p;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182412,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long call(vector<int >nums,int x){\\n    long long res=0;\\n    for(int i=0,j=nums.size()-1;i<j;i++){\\n        while(i<j and nums[i]+nums[j]>x ){\\n            j--;\\n        }\\n        res+=j-i;\\n    }\\n    return res;\\n}\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n       sort(nums.begin(),nums.end());\\n        return call(nums,upper)-call(nums,lower-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long call(vector<int >nums,int x){\\n    long long res=0;\\n    for(int i=0,j=nums.size()-1;i<j;i++){\\n        while(i<j and nums[i]+nums[j]>x ){\\n            j--;\\n        }\\n        res+=j-i;\\n    }\\n    return res;\\n}\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n       sort(nums.begin(),nums.end());\\n        return call(nums,upper)-call(nums,lower-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182327,
                "title": "simple-binary-search-faster-than-60",
                "content": "# Intuition\\nSort the array in non - decreasing order . Then for each arr[i] find the lower bound and upper bound of L - arr[i] and R - arr[i] respectively. If the lower bound <= upperbound , add (upperBound - lowerBound + 1) in the count , i.e , the number of elemnts which we can add so that the result lies in the range.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n .log n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] arr, int L, int R) {\\n        Arrays.sort(arr);\\n        int N = arr.length;\\n        int right = N - 1;\\n        long count = 0;\\n        for(int i = 0 ; i < arr.length-1 ; i++){    \\n            if((L - arr[i]) <= arr[arr.length - 1]){        \\n                int lowerBound = lowerBound(arr , i+1 , arr.length-1 , L - arr[i]);\\n                int upperBound = upperBound(arr , i+1 , arr.length-1 , R - arr[i]);\\n                if((arr[i] + arr[upperBound]) > R){\\n                    upperBound--;\\n                }\\n                if(upperBound >= lowerBound )\\n                    count += (upperBound - lowerBound + 1);\\n            }            \\n        }\\n        return count;\\n\\n    }  \\n    static int lowerBound(int[] a, int low, int high, int element)\\n    {\\n        while(low < high){\\n            int middle = low + (high - low)/2;\\n            if(element > a[middle]){\\n                low = middle+1;\\n            }\\n            else\\n                high = middle;\\n        }\\n        return low;\\n    }\\n    static int upperBound(int[] a, int low, int high, int element)\\n    {\\n        while(low < high){\\n            int middle = low + (high - low)/2;\\n            if(element >= a[middle]){\\n                low = middle+1;\\n            }\\n            else\\n                high = middle;\\n        }\\n        return low;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] arr, int L, int R) {\\n        Arrays.sort(arr);\\n        int N = arr.length;\\n        int right = N - 1;\\n        long count = 0;\\n        for(int i = 0 ; i < arr.length-1 ; i++){    \\n            if((L - arr[i]) <= arr[arr.length - 1]){        \\n                int lowerBound = lowerBound(arr , i+1 , arr.length-1 , L - arr[i]);\\n                int upperBound = upperBound(arr , i+1 , arr.length-1 , R - arr[i]);\\n                if((arr[i] + arr[upperBound]) > R){\\n                    upperBound--;\\n                }\\n                if(upperBound >= lowerBound )\\n                    count += (upperBound - lowerBound + 1);\\n            }            \\n        }\\n        return count;\\n\\n    }  \\n    static int lowerBound(int[] a, int low, int high, int element)\\n    {\\n        while(low < high){\\n            int middle = low + (high - low)/2;\\n            if(element > a[middle]){\\n                low = middle+1;\\n            }\\n            else\\n                high = middle;\\n        }\\n        return low;\\n    }\\n    static int upperBound(int[] a, int low, int high, int element)\\n    {\\n        while(low < high){\\n            int middle = low + (high - low)/2;\\n            if(element >= a[middle]){\\n                low = middle+1;\\n            }\\n            else\\n                high = middle;\\n        }\\n        return low;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182312,
                "title": "count-number-of-fair-pairs-java-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long pairs=helper(nums,upper)-helper(nums,lower-1);\\n        return pairs;\\n    }\\n\\n    public long helper(int []nums, int target){\\n        int l=0;\\n        int r=nums.length-1;\\n        long sum=0;\\n        while(l<r){\\n            if(nums[l]+nums[r]<=target){\\n                sum+=(r-l);\\n                l++;\\n            }else{\\n                r--;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long pairs=helper(nums,upper)-helper(nums,lower-1);\\n        return pairs;\\n    }\\n\\n    public long helper(int []nums, int target){\\n        int l=0;\\n        int r=nums.length-1;\\n        long sum=0;\\n        while(l<r){\\n            if(nums[l]+nums[r]<=target){\\n                sum+=(r-l);\\n                l++;\\n            }else{\\n                r--;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182308,
                "title": "python-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n\\n        nums.sort()\\n        \\n        ans = 0\\n        for i in range(len(nums)):\\n            target = upper - nums[i]\\n            left = i+1\\n            right = len(nums)-1\\n            while left <= right :\\n                mid = (left + right) // 2 \\n                if nums[mid] <= target :\\n                    left = mid + 1 \\n                else :\\n                    right = mid -1 \\n            U = right \\n            \\n            target = lower - nums[i]\\n            left = i+1\\n            right = len(nums)-1\\n            while left <= right :\\n                mid = (left + right) // 2 \\n                if nums[mid] >= target :\\n                    right = mid -1                         \\n                else :\\n                    left = mid + 1 \\n            if left <= U :\\n                ans += U - left + 1\\n\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n\\n        nums.sort()\\n        \\n        ans = 0\\n        for i in range(len(nums)):\\n            target = upper - nums[i]\\n            left = i+1\\n            right = len(nums)-1\\n            while left <= right :\\n                mid = (left + right) // 2 \\n                if nums[mid] <= target :\\n                    left = mid + 1 \\n                else :\\n                    right = mid -1 \\n            U = right \\n            \\n            target = lower - nums[i]\\n            left = i+1\\n            right = len(nums)-1\\n            while left <= right :\\n                mid = (left + right) // 2 \\n                if nums[mid] >= target :\\n                    right = mid -1                         \\n                else :\\n                    left = mid + 1 \\n            if left <= U :\\n                ans += U - left + 1\\n\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182256,
                "title": "c-binary-search-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int low, int u) {\\n        sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int n1=low-nums[i];\\n            int n2=u-nums[i];\\n            int l=0,r=nums.size()-1;\\n            int x1=-1,x2=-1;\\n            while(l<=r)\\n            {\\n                int mid=l+(r-l)/2;\\n                if(nums[mid]>=n1)\\n                {\\n                    x1=mid;\\n                    r=mid-1;\\n                }\\n                else\\n                    l=mid+1;\\n            }\\n            if(x1==-1)\\n                continue;\\n            l=0,r=nums.size()-1;\\n            while(l<=r)\\n            {\\n                int mid=l+(r-l)/2;\\n                if(nums[mid]<=n2)\\n                {\\n                    x2=mid;\\n                    l=mid+1;\\n                }\\n                else\\n                    r=mid-1;\\n            }\\n            if(x1==-1 || x2==-1 || x1>x2)\\n                continue;\\n            if(i>=x1 && i<=x2)\\n            ans+=(x2-x1);\\n            else\\n            ans+=x2-x1+1;\\n        }\\n        return ans/2;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int low, int u) {\\n        sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int n1=low-nums[i];\\n            int n2=u-nums[i];\\n            int l=0,r=nums.size()-1;\\n            int x1=-1,x2=-1;\\n            while(l<=r)\\n            {\\n                int mid=l+(r-l)/2;\\n                if(nums[mid]>=n1)\\n                {\\n                    x1=mid;\\n                    r=mid-1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3182241,
                "title": "c-using-binary-search-o-nlogn",
                "content": "### <a href=\"https://github.com/Arnab-Patra006/Code_With_Pie/blob/main/LeetCode/2563.%20Count%20the%20Number%20of%20Fair%20Pairs.md\">Explaination in GitHub</a>\\n```\\nclass Solution {\\npublic:\\n    int find_right_idx(int idx,int r,int lo,int up,vector<int>& nums)\\n    {\\n        int ans=idx;\\n        int l=idx+1;\\n        while(l<=r)\\n        {\\n            long long mid=l+(r-l)/2;\\n            int sum=nums[idx]+nums[mid];\\n            if(sum>=lo && sum<=up)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else if(sum<lo)\\n            {\\n                l=mid+1;\\n            }\\n            else if(sum>up)\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int find_left_idx(int idx,int r,int lo,int up,vector<int>& nums)\\n    {\\n        int ans=idx;\\n        int l=idx+1;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            long long sum=nums[idx]+nums[mid];\\n            if(sum>=lo && sum<=up)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else if(sum<lo)\\n            {\\n                l=mid+1;\\n            }\\n            else if(sum>up)\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left_idx=find_left_idx(i,n-1,lower,upper,nums);\\n            int right_idx=find_right_idx(i,n-1,lower,upper,nums);\\n            if(left_idx==i || left_idx==i)\\n            {\\n                continue;\\n            }\\n            long long t=right_idx-left_idx+1;\\n            ans+=t;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_right_idx(int idx,int r,int lo,int up,vector<int>& nums)\\n    {\\n        int ans=idx;\\n        int l=idx+1;\\n        while(l<=r)\\n        {\\n            long long mid=l+(r-l)/2;\\n            int sum=nums[idx]+nums[mid];\\n            if(sum>=lo && sum<=up)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else if(sum<lo)\\n            {\\n                l=mid+1;\\n            }\\n            else if(sum>up)\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int find_left_idx(int idx,int r,int lo,int up,vector<int>& nums)\\n    {\\n        int ans=idx;\\n        int l=idx+1;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            long long sum=nums[idx]+nums[mid];\\n            if(sum>=lo && sum<=up)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else if(sum<lo)\\n            {\\n                l=mid+1;\\n            }\\n            else if(sum>up)\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left_idx=find_left_idx(i,n-1,lower,upper,nums);\\n            int right_idx=find_right_idx(i,n-1,lower,upper,nums);\\n            if(left_idx==i || left_idx==i)\\n            {\\n                continue;\\n            }\\n            long long t=right_idx-left_idx+1;\\n            ans+=t;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181725,
                "title": "concise-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n\\n        sort(nums.begin(), nums.end());\\n        int size = nums.size();\\n        long long answer = 0;\\n        \\n        for(int i = 0; i < size; i++){\\n            if((nums[i]*2) >=lower && (nums[i]*2) <=upper)answer--;\\n            int u = prev(upper_bound(nums.begin()+i, nums.end(), upper-nums[i]))-lower_bound(nums.begin()+i,nums.end(), lower-nums[i])+1;\\n            answer+=u;\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n\\n        sort(nums.begin(), nums.end());\\n        int size = nums.size();\\n        long long answer = 0;\\n        \\n        for(int i = 0; i < size; i++){\\n            if((nums[i]*2) >=lower && (nums[i]*2) <=upper)answer--;\\n            int u = prev(upper_bound(nums.begin()+i, nums.end(), upper-nums[i]))-lower_bound(nums.begin()+i,nums.end(), lower-nums[i])+1;\\n            answer+=u;\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181622,
                "title": "scala-recursive-two-pointer",
                "content": "# Complexity\\n- Time complexity:\\nO(n * log(n))\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nobject Solution {\\n  def countFairPairs(nums: Array[Int], lower: Int, upper: Int): Long = {\\n    val n = nums.sorted\\n    def goCount(l: Int, r: Int, acc: Long): Long =\\n      if (l >= r) acc\\n      else if (n(l) + n(r) < lower) goCount(l + 1, r, acc)\\n      else if (n(l) + n(r) > upper) goCount(l, r - 1, acc)\\n      else {\\n        val inBound = (l + 1 to r).dropWhile(i => n(l) + n(i) < lower)\\n        goCount(l + 1, r, acc + r - inBound.head + 1)\\n      }\\n      \\n\\n    goCount(0, n.length - 1, 0)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def countFairPairs(nums: Array[Int], lower: Int, upper: Int): Long = {\\n    val n = nums.sorted\\n    def goCount(l: Int, r: Int, acc: Long): Long =\\n      if (l >= r) acc\\n      else if (n(l) + n(r) < lower) goCount(l + 1, r, acc)\\n      else if (n(l) + n(r) > upper) goCount(l, r - 1, acc)\\n      else {\\n        val inBound = (l + 1 to r).dropWhile(i => n(l) + n(i) < lower)\\n        goCount(l + 1, r, acc + r - inBound.head + 1)\\n      }\\n      \\n\\n    goCount(0, n.length - 1, 0)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3181598,
                "title": "easy-c-solution-with-lower-bound-upper-bound-clean-code",
                "content": "# Code\\n```cpp\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans = 0;\\n        int n = (int)nums.size();\\n\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = 0; i < n - 1; ++i) {\\n            int newLower = lower - nums[i];\\n            int newUpper = upper - nums[i];\\n            int lb = lower_bound(nums.begin() + i + 1, nums.end(), newLower) - nums.begin();\\n            int ub = upper_bound(nums.begin() + i + 1, nums.end(), newUpper) - nums.begin();\\n            ans += ub - lb;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        long long ans = 0;\\n        int n = (int)nums.size();\\n\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = 0; i < n - 1; ++i) {\\n            int newLower = lower - nums[i];\\n            int newUpper = upper - nums[i];\\n            int lb = lower_bound(nums.begin() + i + 1, nums.end(), newLower) - nums.begin();\\n            int ub = upper_bound(nums.begin() + i + 1, nums.end(), newUpper) - nums.begin();\\n            ans += ub - lb;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181241,
                "title": "2-pointers-o-n-logn-cpp",
                "content": "**Idea taken from @raincoat911**\\nWe can basicallt breakdown the problem into **two sub-problems** of counting the pairs having sum less than equal to ***upper*** and count of pairs having sum less than equal to ***lower - 1***\\n\\nResult = CountPairs(Upper) - CountPairs(Lower - 1)\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    // Counting Pairs with sum <= k\\n    ll getPairs(vector<int>& nums, int k) {\\n        ll res = 0;\\n        \\n        for (int i = 0, l = nums.size() - 1; i < l; i++) {\\n            while (i < l && nums[i] + nums[l] > k) {\\n                l--;\\n            }\\n            res += l - i;\\n        }\\n        \\n        return res;\\n    }\\n    long long countFairPairs(vector<int>& nums, int low, int up) {\\n        sort(begin(nums), end(nums));\\n        ll res = 0;\\n        res += getPairs(nums, up);\\n        res -= getPairs(nums, low - 1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    // Counting Pairs with sum <= k\\n    ll getPairs(vector<int>& nums, int k) {\\n        ll res = 0;\\n        \\n        for (int i = 0, l = nums.size() - 1; i < l; i++) {\\n            while (i < l && nums[i] + nums[l] > k) {\\n                l--;\\n            }\\n            res += l - i;\\n        }\\n        \\n        return res;\\n    }\\n    long long countFairPairs(vector<int>& nums, int low, int up) {\\n        sort(begin(nums), end(nums));\\n        ll res = 0;\\n        res += getPairs(nums, up);\\n        res -= getPairs(nums, low - 1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180976,
                "title": "best-solution-in-c-binarysearch-2-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=nums.size()-1;\\n        long long ans=0;\\n        while(i<j){\\n            if(nums[i]+nums[j]>=lower&&nums[i]+nums[j]<=upper){\\n                int u=upper_bound(nums.begin()+i+1,nums.end(),lower-nums[i]-1)-nums.begin();\\n               long long c=j-u+1;\\n               // cout<<u;\\n                ans+=c;\\n                i++;\\n            }\\n             else if(nums[i]+nums[j]>upper){\\n                j--;\\n            }\\n            else if(nums[i]+nums[j]<lower){\\n                i++;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=nums.size()-1;\\n        long long ans=0;\\n        while(i<j){\\n            if(nums[i]+nums[j]>=lower&&nums[i]+nums[j]<=upper){\\n                int u=upper_bound(nums.begin()+i+1,nums.end(),lower-nums[i]-1)-nums.begin();\\n               long long c=j-u+1;\\n               // cout<<u;\\n                ans+=c;\\n                i++;\\n            }\\n             else if(nums[i]+nums[j]>upper){\\n                j--;\\n            }\\n            else if(nums[i]+nums[j]<lower){\\n                i++;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3180584,
                "title": "binary-search-lower-and-upper-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        // 0 1 4 4 5 7\\n        long ans = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            int index = binarySearchUpper(i,nums,upper);\\n            // System.out.println(\"index: \"+ index);\\n            int index2 = binarySearchLower(i,nums,lower);\\n            index2++;\\n            int pairs = index - index2 + 1;\\n            // System.out.println(\"nums[i] \" + nums[i] + \" pairs: \" + pairs);\\n            if(i>=index2 && i<=index)pairs--;\\n            ans+=pairs;\\n            // System.out.println(\"index2: \"+ index2);\\n        }\\n        return ans/2;\\n    }\\n\\n    public int binarySearchUpper(int i,int [] nums,int upper){\\n        int toFind = upper - nums[i];\\n        // System.out.println(\"To find:\" + toFind);\\n        int k = 0,j = nums.length - 1;\\n        int ans = -1;\\n        while(k<=j){\\n            int mid = (k+j)/2;\\n            if(nums[mid]<=toFind){\\n                ans = mid;\\n                k = mid + 1;\\n            }else j = mid - 1;\\n        }\\n        return ans;\\n    }\\n\\n    public int binarySearchLower(int i,int [] nums,int lower){\\n        int toFind = lower - nums[i];\\n        // System.out.println(\"To find:\" + toFind);\\n        int k = 0,j = nums.length - 1;\\n        int ans = -1;\\n        while(k<=j){\\n            int mid = (k+j)/2;\\n            // System.out.println(\"mid \" + mid + \" k: \" + k + \" j: \" + j);\\n            if(nums[mid]<toFind){\\n                // System.out.println(\"lower:\" + mid);\\n                ans = mid;\\n                k = mid + 1;\\n            }else j = mid - 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        // 0 1 4 4 5 7\\n        long ans = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            int index = binarySearchUpper(i,nums,upper);\\n            // System.out.println(\"index: \"+ index);\\n            int index2 = binarySearchLower(i,nums,lower);\\n            index2++;\\n            int pairs = index - index2 + 1;\\n            // System.out.println(\"nums[i] \" + nums[i] + \" pairs: \" + pairs);\\n            if(i>=index2 && i<=index)pairs--;\\n            ans+=pairs;\\n            // System.out.println(\"index2: \"+ index2);\\n        }\\n        return ans/2;\\n    }\\n\\n    public int binarySearchUpper(int i,int [] nums,int upper){\\n        int toFind = upper - nums[i];\\n        // System.out.println(\"To find:\" + toFind);\\n        int k = 0,j = nums.length - 1;\\n        int ans = -1;\\n        while(k<=j){\\n            int mid = (k+j)/2;\\n            if(nums[mid]<=toFind){\\n                ans = mid;\\n                k = mid + 1;\\n            }else j = mid - 1;\\n        }\\n        return ans;\\n    }\\n\\n    public int binarySearchLower(int i,int [] nums,int lower){\\n        int toFind = lower - nums[i];\\n        // System.out.println(\"To find:\" + toFind);\\n        int k = 0,j = nums.length - 1;\\n        int ans = -1;\\n        while(k<=j){\\n            int mid = (k+j)/2;\\n            // System.out.println(\"mid \" + mid + \" k: \" + k + \" j: \" + j);\\n            if(nums[mid]<toFind){\\n                // System.out.println(\"lower:\" + mid);\\n                ans = mid;\\n                k = mid + 1;\\n            }else j = mid - 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1798872,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1797623,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1797537,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1880296,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1797484,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1797657,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1797804,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1797554,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1814347,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1802131,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1798872,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1797623,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1797537,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1880296,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1797484,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1797657,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1797804,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1797554,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1814347,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1802131,
                "content": [
                    {
                        "username": "imankitg",
                        "content": "How many of you restricted yourself from sorting the array after seeing this\\n`0 <= i < j < n`"
                    },
                    {
                        "username": "halfengineer",
                        "content": "47/51 test case ruined the day 😓😓"
                    },
                    {
                        "username": "wtfbroeveryusernameistaken",
                        "content": "[@shivam2612002](/shivam2612002)  TLE is due to complexity ig, and not due the return type of function. OP probably did this problem in O(n^2) "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@animeshsaini](/animeshsaini) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "lol ! long long int use krna tha na bro. jab function hi LL return krra h to :))"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "i got 49/51 \\uD83E\\uDD23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@al_ghaib](/al_ghaib) \\uD83D\\uDE05"
                    },
                    {
                        "username": "halfengineer",
                        "content": "no bro its tle using two ptr"
                    },
                    {
                        "username": "n761z",
                        "content": "Atleast they should give points according to number of accepted test cases.\\uD83D\\uDE02"
                    },
                    {
                        "username": "n761z",
                        "content": "[@shekharaditya](/shekharaditya) Yes.\\n"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think that was [0,0,0......0] right ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A good problem if you want to practice two pointer approach"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "```> sort an array```\n```> 0 <= i < j < n```\n\nI'm really hate this question"
                    },
                    {
                        "username": "Weildcard",
                        "content": "But there\\'s actually no distinction between i and j so you can sort it anyway."
                    },
                    {
                        "username": "ChandBasha",
                        "content": "[@Vaibhav_69](/Vaibhav_69) Yes, only when u don\\'t use binary Search."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Isnt it giving TLE for the last few testcases?\\n\\n"
                    },
                    {
                        "username": "native_element",
                        "content": "sorting the array does not change order of i and j .please explain."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Like if you have an array and you find a good pair in unsorted array, let that be at (i, j). Now either i<j or i>j. When you sort irrespective of the order they are placed in you will get that one pair. Now, whether if jth comes before ith then we\\'ll still get the pair but in reverse order. We are not bothered about their relative order but the fact that we get the pair, and it will counted only once. This condition was in place just to make sure pairs are not counted twice."
                    },
                    {
                        "username": "native_element",
                        "content": "[@_aka5h](/_aka5h) \\nThanks Akash for the Tip."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "you just need to know the number of pairs, but finding the all pairs (i, j)\\nAnd number of pairs will not change after sorting. You can proof this by finding the original pairs first, and to swap (i, j)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "for any 2 arbitrary elements at indices x and y. It is quite obvious that either x > y or x < y. In either case, assume j to be the largest index and respectively i to be the smallest. Moreover, a tip from my side : order doesn\\'t matter if the property of commutative holds."
                    },
                    {
                        "username": "yashsrivastava0211",
                        "content": "both i and j belong to the array and you just have to return the count so does not matter which order they are "
                    },
                    {
                        "username": "n761z",
                        "content": "What\\'s the use of this constraint ( i < j ), can someone please explain?\\nIf sorting doesn\\'t affect the solution. "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "i<j  implies that don\\'t use the  element of same index twice in pair !!"
                    },
                    {
                        "username": "n761z",
                        "content": "[@csmth](/csmth) Thanks !"
                    },
                    {
                        "username": "maktinho",
                        "content": "The answer is doubled without this constraint (note that index i and j can never be equal). But that is not big a difference."
                    },
                    {
                        "username": "weimiao1993",
                        "content": "I\\'m so trapped by 0 <= i < j < n during the contest that I think so hard how to get the pairs ordered..."
                    },
                    {
                        "username": "Ankit_Singh25",
                        "content": "I solve using brute force - >TLE\\nthen solve using map->TLE\\nFINALLY using sorting+upper/lower bound->accept:\\nGOOD QUESTION FOR UNDERSTANDING THE POINTER AND LOWER AND UPPER BOUND:"
                    },
                    {
                        "username": "j-simian",
                        "content": "Sorting is okay as `i < j` really means `i != j` as if `i > j` we have `j < i` and  by renaming variables we get `i < j` (the variable names `i` and `j` are not the same as the pair results :)"
                    }
                ]
            },
            {
                "id": 1800596,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "it should be like this :  \\n`i != j`"
                    },
                    {
                        "username": "olazznog_88",
                        "content": "It\\'s not as simple as that. Consider this. If the pair (0,3) is a solution, the pair (3,0) must not be counted. By reducing the constraint to i != j you would count those two pairs, where only one (0,3) needs to be counted."
                    },
                    {
                        "username": "user8738ZV",
                        "content": "just sort the array and then apply binary search"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "is it be able to solve using binary search?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "noman598",
                        "content": "Every time I get stuck on this type of problem :)"
                    },
                    {
                        "username": "y-not",
                        "content": "Why is below code failing 2 test cases - \\n\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        int pairs = 0;\\n\\n        for (int i=0; i<nums.length; i++)\\n        {\\n            /*\\n                lower  <= (nums[i] + x)  <=   upper\\n                lower - nums[i]  <=  x <=  upper - nums[i]\\n            */\\n\\n            int l = lowerBound(nums, i+1, nums.length-1, lower - nums[i]);\\n            int u = upperBound(nums, i+1, nums.length-1, upper - nums[i]);\\n\\n            pairs += (u - l);\\n        }\\n        \\n        return pairs;\\n    }\\n\\n    /*\\n        Return value:\\n            - If key is present, return the first idx whose value is k\\n            - If key is not present, return the first idx whose value is greater than k. If no such element is present return r+1\\n    */\\n    int lowerBound(int[] nums, int l, int r, int key)\\n    {\\n        int ret = -1;\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] >= key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n\\n    /*\\n        Returns the first idx whose value is greater than k\\n        If no such element is present return r+1\\n    */\\n    int upperBound(int[] nums, int l, int r, int key)\\n    {\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] > key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }    \\n}"
                    },
                    {
                        "username": "prateek26",
                        "content": "51th test case failed where expected output is 4999950000. lower = -1000000000.  upper =1000000000. Anybody can help. \\n\\n    public int countFairPairs(final int[] a, final int lo, final int hi) {\\n        Arrays.sort(a);\\n        return countGreaterThanTarget(a, lo-1) - countGreaterThanTarget(a, hi);\\n    }\\n\\n    private int countGreaterThanTarget(final int[] a, final int target) {\\n        final int n = a.length;\\n        int i = 0, j = n-1;\\n        int ans = 0;\\n        while (i < j) {\\n            if (a[i] + a[j] > target) {\\n                ans = ans + (j-i);\\n                j--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "i didnt expect the second question in contest is like that"
                    },
                    {
                        "username": "Adonis21",
                        "content": "why it is giving error with 2 pointers ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "`can anyone help me to correct this code passing 49/51 test cases.`\\npublic int countFairPairs(int[] nums, int lower, int upper) {\\nArrays.sort(nums);\\nreturn count(nums,upper+1)-count(nums,lower);\\n}\\npublic int count(int[]nums,int target){\\n    int ans=0,i=0,j=nums.length-1;\\n    while(i<j){\\n        if(nums[i]+nums[j]>=target){\\n            j--;\\n        }\\n        else{\\n            ans+=j-i;\\n            i++;\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "it\\'s my life 46/51...whole moral down...\\uD83D\\uDE2A\\uD83D\\uDE2A\\nbut after context solved using Two Pointer"
                    }
                ]
            },
            {
                "id": 1799151,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "it should be like this :  \\n`i != j`"
                    },
                    {
                        "username": "olazznog_88",
                        "content": "It\\'s not as simple as that. Consider this. If the pair (0,3) is a solution, the pair (3,0) must not be counted. By reducing the constraint to i != j you would count those two pairs, where only one (0,3) needs to be counted."
                    },
                    {
                        "username": "user8738ZV",
                        "content": "just sort the array and then apply binary search"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "is it be able to solve using binary search?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "noman598",
                        "content": "Every time I get stuck on this type of problem :)"
                    },
                    {
                        "username": "y-not",
                        "content": "Why is below code failing 2 test cases - \\n\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        int pairs = 0;\\n\\n        for (int i=0; i<nums.length; i++)\\n        {\\n            /*\\n                lower  <= (nums[i] + x)  <=   upper\\n                lower - nums[i]  <=  x <=  upper - nums[i]\\n            */\\n\\n            int l = lowerBound(nums, i+1, nums.length-1, lower - nums[i]);\\n            int u = upperBound(nums, i+1, nums.length-1, upper - nums[i]);\\n\\n            pairs += (u - l);\\n        }\\n        \\n        return pairs;\\n    }\\n\\n    /*\\n        Return value:\\n            - If key is present, return the first idx whose value is k\\n            - If key is not present, return the first idx whose value is greater than k. If no such element is present return r+1\\n    */\\n    int lowerBound(int[] nums, int l, int r, int key)\\n    {\\n        int ret = -1;\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] >= key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n\\n    /*\\n        Returns the first idx whose value is greater than k\\n        If no such element is present return r+1\\n    */\\n    int upperBound(int[] nums, int l, int r, int key)\\n    {\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] > key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }    \\n}"
                    },
                    {
                        "username": "prateek26",
                        "content": "51th test case failed where expected output is 4999950000. lower = -1000000000.  upper =1000000000. Anybody can help. \\n\\n    public int countFairPairs(final int[] a, final int lo, final int hi) {\\n        Arrays.sort(a);\\n        return countGreaterThanTarget(a, lo-1) - countGreaterThanTarget(a, hi);\\n    }\\n\\n    private int countGreaterThanTarget(final int[] a, final int target) {\\n        final int n = a.length;\\n        int i = 0, j = n-1;\\n        int ans = 0;\\n        while (i < j) {\\n            if (a[i] + a[j] > target) {\\n                ans = ans + (j-i);\\n                j--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "i didnt expect the second question in contest is like that"
                    },
                    {
                        "username": "Adonis21",
                        "content": "why it is giving error with 2 pointers ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "`can anyone help me to correct this code passing 49/51 test cases.`\\npublic int countFairPairs(int[] nums, int lower, int upper) {\\nArrays.sort(nums);\\nreturn count(nums,upper+1)-count(nums,lower);\\n}\\npublic int count(int[]nums,int target){\\n    int ans=0,i=0,j=nums.length-1;\\n    while(i<j){\\n        if(nums[i]+nums[j]>=target){\\n            j--;\\n        }\\n        else{\\n            ans+=j-i;\\n            i++;\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "it\\'s my life 46/51...whole moral down...\\uD83D\\uDE2A\\uD83D\\uDE2A\\nbut after context solved using Two Pointer"
                    }
                ]
            },
            {
                "id": 1798144,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "it should be like this :  \\n`i != j`"
                    },
                    {
                        "username": "olazznog_88",
                        "content": "It\\'s not as simple as that. Consider this. If the pair (0,3) is a solution, the pair (3,0) must not be counted. By reducing the constraint to i != j you would count those two pairs, where only one (0,3) needs to be counted."
                    },
                    {
                        "username": "user8738ZV",
                        "content": "just sort the array and then apply binary search"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "is it be able to solve using binary search?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "noman598",
                        "content": "Every time I get stuck on this type of problem :)"
                    },
                    {
                        "username": "y-not",
                        "content": "Why is below code failing 2 test cases - \\n\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        int pairs = 0;\\n\\n        for (int i=0; i<nums.length; i++)\\n        {\\n            /*\\n                lower  <= (nums[i] + x)  <=   upper\\n                lower - nums[i]  <=  x <=  upper - nums[i]\\n            */\\n\\n            int l = lowerBound(nums, i+1, nums.length-1, lower - nums[i]);\\n            int u = upperBound(nums, i+1, nums.length-1, upper - nums[i]);\\n\\n            pairs += (u - l);\\n        }\\n        \\n        return pairs;\\n    }\\n\\n    /*\\n        Return value:\\n            - If key is present, return the first idx whose value is k\\n            - If key is not present, return the first idx whose value is greater than k. If no such element is present return r+1\\n    */\\n    int lowerBound(int[] nums, int l, int r, int key)\\n    {\\n        int ret = -1;\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] >= key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n\\n    /*\\n        Returns the first idx whose value is greater than k\\n        If no such element is present return r+1\\n    */\\n    int upperBound(int[] nums, int l, int r, int key)\\n    {\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] > key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }    \\n}"
                    },
                    {
                        "username": "prateek26",
                        "content": "51th test case failed where expected output is 4999950000. lower = -1000000000.  upper =1000000000. Anybody can help. \\n\\n    public int countFairPairs(final int[] a, final int lo, final int hi) {\\n        Arrays.sort(a);\\n        return countGreaterThanTarget(a, lo-1) - countGreaterThanTarget(a, hi);\\n    }\\n\\n    private int countGreaterThanTarget(final int[] a, final int target) {\\n        final int n = a.length;\\n        int i = 0, j = n-1;\\n        int ans = 0;\\n        while (i < j) {\\n            if (a[i] + a[j] > target) {\\n                ans = ans + (j-i);\\n                j--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "i didnt expect the second question in contest is like that"
                    },
                    {
                        "username": "Adonis21",
                        "content": "why it is giving error with 2 pointers ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "`can anyone help me to correct this code passing 49/51 test cases.`\\npublic int countFairPairs(int[] nums, int lower, int upper) {\\nArrays.sort(nums);\\nreturn count(nums,upper+1)-count(nums,lower);\\n}\\npublic int count(int[]nums,int target){\\n    int ans=0,i=0,j=nums.length-1;\\n    while(i<j){\\n        if(nums[i]+nums[j]>=target){\\n            j--;\\n        }\\n        else{\\n            ans+=j-i;\\n            i++;\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "it\\'s my life 46/51...whole moral down...\\uD83D\\uDE2A\\uD83D\\uDE2A\\nbut after context solved using Two Pointer"
                    }
                ]
            },
            {
                "id": 1797751,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "it should be like this :  \\n`i != j`"
                    },
                    {
                        "username": "olazznog_88",
                        "content": "It\\'s not as simple as that. Consider this. If the pair (0,3) is a solution, the pair (3,0) must not be counted. By reducing the constraint to i != j you would count those two pairs, where only one (0,3) needs to be counted."
                    },
                    {
                        "username": "user8738ZV",
                        "content": "just sort the array and then apply binary search"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "is it be able to solve using binary search?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "noman598",
                        "content": "Every time I get stuck on this type of problem :)"
                    },
                    {
                        "username": "y-not",
                        "content": "Why is below code failing 2 test cases - \\n\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        int pairs = 0;\\n\\n        for (int i=0; i<nums.length; i++)\\n        {\\n            /*\\n                lower  <= (nums[i] + x)  <=   upper\\n                lower - nums[i]  <=  x <=  upper - nums[i]\\n            */\\n\\n            int l = lowerBound(nums, i+1, nums.length-1, lower - nums[i]);\\n            int u = upperBound(nums, i+1, nums.length-1, upper - nums[i]);\\n\\n            pairs += (u - l);\\n        }\\n        \\n        return pairs;\\n    }\\n\\n    /*\\n        Return value:\\n            - If key is present, return the first idx whose value is k\\n            - If key is not present, return the first idx whose value is greater than k. If no such element is present return r+1\\n    */\\n    int lowerBound(int[] nums, int l, int r, int key)\\n    {\\n        int ret = -1;\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] >= key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n\\n    /*\\n        Returns the first idx whose value is greater than k\\n        If no such element is present return r+1\\n    */\\n    int upperBound(int[] nums, int l, int r, int key)\\n    {\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] > key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }    \\n}"
                    },
                    {
                        "username": "prateek26",
                        "content": "51th test case failed where expected output is 4999950000. lower = -1000000000.  upper =1000000000. Anybody can help. \\n\\n    public int countFairPairs(final int[] a, final int lo, final int hi) {\\n        Arrays.sort(a);\\n        return countGreaterThanTarget(a, lo-1) - countGreaterThanTarget(a, hi);\\n    }\\n\\n    private int countGreaterThanTarget(final int[] a, final int target) {\\n        final int n = a.length;\\n        int i = 0, j = n-1;\\n        int ans = 0;\\n        while (i < j) {\\n            if (a[i] + a[j] > target) {\\n                ans = ans + (j-i);\\n                j--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "i didnt expect the second question in contest is like that"
                    },
                    {
                        "username": "Adonis21",
                        "content": "why it is giving error with 2 pointers ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "`can anyone help me to correct this code passing 49/51 test cases.`\\npublic int countFairPairs(int[] nums, int lower, int upper) {\\nArrays.sort(nums);\\nreturn count(nums,upper+1)-count(nums,lower);\\n}\\npublic int count(int[]nums,int target){\\n    int ans=0,i=0,j=nums.length-1;\\n    while(i<j){\\n        if(nums[i]+nums[j]>=target){\\n            j--;\\n        }\\n        else{\\n            ans+=j-i;\\n            i++;\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "it\\'s my life 46/51...whole moral down...\\uD83D\\uDE2A\\uD83D\\uDE2A\\nbut after context solved using Two Pointer"
                    }
                ]
            },
            {
                "id": 1951829,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "it should be like this :  \\n`i != j`"
                    },
                    {
                        "username": "olazznog_88",
                        "content": "It\\'s not as simple as that. Consider this. If the pair (0,3) is a solution, the pair (3,0) must not be counted. By reducing the constraint to i != j you would count those two pairs, where only one (0,3) needs to be counted."
                    },
                    {
                        "username": "user8738ZV",
                        "content": "just sort the array and then apply binary search"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "is it be able to solve using binary search?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "noman598",
                        "content": "Every time I get stuck on this type of problem :)"
                    },
                    {
                        "username": "y-not",
                        "content": "Why is below code failing 2 test cases - \\n\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        int pairs = 0;\\n\\n        for (int i=0; i<nums.length; i++)\\n        {\\n            /*\\n                lower  <= (nums[i] + x)  <=   upper\\n                lower - nums[i]  <=  x <=  upper - nums[i]\\n            */\\n\\n            int l = lowerBound(nums, i+1, nums.length-1, lower - nums[i]);\\n            int u = upperBound(nums, i+1, nums.length-1, upper - nums[i]);\\n\\n            pairs += (u - l);\\n        }\\n        \\n        return pairs;\\n    }\\n\\n    /*\\n        Return value:\\n            - If key is present, return the first idx whose value is k\\n            - If key is not present, return the first idx whose value is greater than k. If no such element is present return r+1\\n    */\\n    int lowerBound(int[] nums, int l, int r, int key)\\n    {\\n        int ret = -1;\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] >= key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n\\n    /*\\n        Returns the first idx whose value is greater than k\\n        If no such element is present return r+1\\n    */\\n    int upperBound(int[] nums, int l, int r, int key)\\n    {\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] > key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }    \\n}"
                    },
                    {
                        "username": "prateek26",
                        "content": "51th test case failed where expected output is 4999950000. lower = -1000000000.  upper =1000000000. Anybody can help. \\n\\n    public int countFairPairs(final int[] a, final int lo, final int hi) {\\n        Arrays.sort(a);\\n        return countGreaterThanTarget(a, lo-1) - countGreaterThanTarget(a, hi);\\n    }\\n\\n    private int countGreaterThanTarget(final int[] a, final int target) {\\n        final int n = a.length;\\n        int i = 0, j = n-1;\\n        int ans = 0;\\n        while (i < j) {\\n            if (a[i] + a[j] > target) {\\n                ans = ans + (j-i);\\n                j--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "i didnt expect the second question in contest is like that"
                    },
                    {
                        "username": "Adonis21",
                        "content": "why it is giving error with 2 pointers ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "`can anyone help me to correct this code passing 49/51 test cases.`\\npublic int countFairPairs(int[] nums, int lower, int upper) {\\nArrays.sort(nums);\\nreturn count(nums,upper+1)-count(nums,lower);\\n}\\npublic int count(int[]nums,int target){\\n    int ans=0,i=0,j=nums.length-1;\\n    while(i<j){\\n        if(nums[i]+nums[j]>=target){\\n            j--;\\n        }\\n        else{\\n            ans+=j-i;\\n            i++;\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "it\\'s my life 46/51...whole moral down...\\uD83D\\uDE2A\\uD83D\\uDE2A\\nbut after context solved using Two Pointer"
                    }
                ]
            },
            {
                "id": 1808096,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "it should be like this :  \\n`i != j`"
                    },
                    {
                        "username": "olazznog_88",
                        "content": "It\\'s not as simple as that. Consider this. If the pair (0,3) is a solution, the pair (3,0) must not be counted. By reducing the constraint to i != j you would count those two pairs, where only one (0,3) needs to be counted."
                    },
                    {
                        "username": "user8738ZV",
                        "content": "just sort the array and then apply binary search"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "is it be able to solve using binary search?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "noman598",
                        "content": "Every time I get stuck on this type of problem :)"
                    },
                    {
                        "username": "y-not",
                        "content": "Why is below code failing 2 test cases - \\n\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        int pairs = 0;\\n\\n        for (int i=0; i<nums.length; i++)\\n        {\\n            /*\\n                lower  <= (nums[i] + x)  <=   upper\\n                lower - nums[i]  <=  x <=  upper - nums[i]\\n            */\\n\\n            int l = lowerBound(nums, i+1, nums.length-1, lower - nums[i]);\\n            int u = upperBound(nums, i+1, nums.length-1, upper - nums[i]);\\n\\n            pairs += (u - l);\\n        }\\n        \\n        return pairs;\\n    }\\n\\n    /*\\n        Return value:\\n            - If key is present, return the first idx whose value is k\\n            - If key is not present, return the first idx whose value is greater than k. If no such element is present return r+1\\n    */\\n    int lowerBound(int[] nums, int l, int r, int key)\\n    {\\n        int ret = -1;\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] >= key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n\\n    /*\\n        Returns the first idx whose value is greater than k\\n        If no such element is present return r+1\\n    */\\n    int upperBound(int[] nums, int l, int r, int key)\\n    {\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] > key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }    \\n}"
                    },
                    {
                        "username": "prateek26",
                        "content": "51th test case failed where expected output is 4999950000. lower = -1000000000.  upper =1000000000. Anybody can help. \\n\\n    public int countFairPairs(final int[] a, final int lo, final int hi) {\\n        Arrays.sort(a);\\n        return countGreaterThanTarget(a, lo-1) - countGreaterThanTarget(a, hi);\\n    }\\n\\n    private int countGreaterThanTarget(final int[] a, final int target) {\\n        final int n = a.length;\\n        int i = 0, j = n-1;\\n        int ans = 0;\\n        while (i < j) {\\n            if (a[i] + a[j] > target) {\\n                ans = ans + (j-i);\\n                j--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "i didnt expect the second question in contest is like that"
                    },
                    {
                        "username": "Adonis21",
                        "content": "why it is giving error with 2 pointers ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "`can anyone help me to correct this code passing 49/51 test cases.`\\npublic int countFairPairs(int[] nums, int lower, int upper) {\\nArrays.sort(nums);\\nreturn count(nums,upper+1)-count(nums,lower);\\n}\\npublic int count(int[]nums,int target){\\n    int ans=0,i=0,j=nums.length-1;\\n    while(i<j){\\n        if(nums[i]+nums[j]>=target){\\n            j--;\\n        }\\n        else{\\n            ans+=j-i;\\n            i++;\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "it\\'s my life 46/51...whole moral down...\\uD83D\\uDE2A\\uD83D\\uDE2A\\nbut after context solved using Two Pointer"
                    }
                ]
            },
            {
                "id": 1798180,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "it should be like this :  \\n`i != j`"
                    },
                    {
                        "username": "olazznog_88",
                        "content": "It\\'s not as simple as that. Consider this. If the pair (0,3) is a solution, the pair (3,0) must not be counted. By reducing the constraint to i != j you would count those two pairs, where only one (0,3) needs to be counted."
                    },
                    {
                        "username": "user8738ZV",
                        "content": "just sort the array and then apply binary search"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "is it be able to solve using binary search?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "noman598",
                        "content": "Every time I get stuck on this type of problem :)"
                    },
                    {
                        "username": "y-not",
                        "content": "Why is below code failing 2 test cases - \\n\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        int pairs = 0;\\n\\n        for (int i=0; i<nums.length; i++)\\n        {\\n            /*\\n                lower  <= (nums[i] + x)  <=   upper\\n                lower - nums[i]  <=  x <=  upper - nums[i]\\n            */\\n\\n            int l = lowerBound(nums, i+1, nums.length-1, lower - nums[i]);\\n            int u = upperBound(nums, i+1, nums.length-1, upper - nums[i]);\\n\\n            pairs += (u - l);\\n        }\\n        \\n        return pairs;\\n    }\\n\\n    /*\\n        Return value:\\n            - If key is present, return the first idx whose value is k\\n            - If key is not present, return the first idx whose value is greater than k. If no such element is present return r+1\\n    */\\n    int lowerBound(int[] nums, int l, int r, int key)\\n    {\\n        int ret = -1;\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] >= key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n\\n    /*\\n        Returns the first idx whose value is greater than k\\n        If no such element is present return r+1\\n    */\\n    int upperBound(int[] nums, int l, int r, int key)\\n    {\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] > key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }    \\n}"
                    },
                    {
                        "username": "prateek26",
                        "content": "51th test case failed where expected output is 4999950000. lower = -1000000000.  upper =1000000000. Anybody can help. \\n\\n    public int countFairPairs(final int[] a, final int lo, final int hi) {\\n        Arrays.sort(a);\\n        return countGreaterThanTarget(a, lo-1) - countGreaterThanTarget(a, hi);\\n    }\\n\\n    private int countGreaterThanTarget(final int[] a, final int target) {\\n        final int n = a.length;\\n        int i = 0, j = n-1;\\n        int ans = 0;\\n        while (i < j) {\\n            if (a[i] + a[j] > target) {\\n                ans = ans + (j-i);\\n                j--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "i didnt expect the second question in contest is like that"
                    },
                    {
                        "username": "Adonis21",
                        "content": "why it is giving error with 2 pointers ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "`can anyone help me to correct this code passing 49/51 test cases.`\\npublic int countFairPairs(int[] nums, int lower, int upper) {\\nArrays.sort(nums);\\nreturn count(nums,upper+1)-count(nums,lower);\\n}\\npublic int count(int[]nums,int target){\\n    int ans=0,i=0,j=nums.length-1;\\n    while(i<j){\\n        if(nums[i]+nums[j]>=target){\\n            j--;\\n        }\\n        else{\\n            ans+=j-i;\\n            i++;\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "it\\'s my life 46/51...whole moral down...\\uD83D\\uDE2A\\uD83D\\uDE2A\\nbut after context solved using Two Pointer"
                    }
                ]
            },
            {
                "id": 1797937,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "it should be like this :  \\n`i != j`"
                    },
                    {
                        "username": "olazznog_88",
                        "content": "It\\'s not as simple as that. Consider this. If the pair (0,3) is a solution, the pair (3,0) must not be counted. By reducing the constraint to i != j you would count those two pairs, where only one (0,3) needs to be counted."
                    },
                    {
                        "username": "user8738ZV",
                        "content": "just sort the array and then apply binary search"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "is it be able to solve using binary search?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "noman598",
                        "content": "Every time I get stuck on this type of problem :)"
                    },
                    {
                        "username": "y-not",
                        "content": "Why is below code failing 2 test cases - \\n\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        int pairs = 0;\\n\\n        for (int i=0; i<nums.length; i++)\\n        {\\n            /*\\n                lower  <= (nums[i] + x)  <=   upper\\n                lower - nums[i]  <=  x <=  upper - nums[i]\\n            */\\n\\n            int l = lowerBound(nums, i+1, nums.length-1, lower - nums[i]);\\n            int u = upperBound(nums, i+1, nums.length-1, upper - nums[i]);\\n\\n            pairs += (u - l);\\n        }\\n        \\n        return pairs;\\n    }\\n\\n    /*\\n        Return value:\\n            - If key is present, return the first idx whose value is k\\n            - If key is not present, return the first idx whose value is greater than k. If no such element is present return r+1\\n    */\\n    int lowerBound(int[] nums, int l, int r, int key)\\n    {\\n        int ret = -1;\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] >= key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n\\n    /*\\n        Returns the first idx whose value is greater than k\\n        If no such element is present return r+1\\n    */\\n    int upperBound(int[] nums, int l, int r, int key)\\n    {\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] > key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }    \\n}"
                    },
                    {
                        "username": "prateek26",
                        "content": "51th test case failed where expected output is 4999950000. lower = -1000000000.  upper =1000000000. Anybody can help. \\n\\n    public int countFairPairs(final int[] a, final int lo, final int hi) {\\n        Arrays.sort(a);\\n        return countGreaterThanTarget(a, lo-1) - countGreaterThanTarget(a, hi);\\n    }\\n\\n    private int countGreaterThanTarget(final int[] a, final int target) {\\n        final int n = a.length;\\n        int i = 0, j = n-1;\\n        int ans = 0;\\n        while (i < j) {\\n            if (a[i] + a[j] > target) {\\n                ans = ans + (j-i);\\n                j--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "i didnt expect the second question in contest is like that"
                    },
                    {
                        "username": "Adonis21",
                        "content": "why it is giving error with 2 pointers ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "`can anyone help me to correct this code passing 49/51 test cases.`\\npublic int countFairPairs(int[] nums, int lower, int upper) {\\nArrays.sort(nums);\\nreturn count(nums,upper+1)-count(nums,lower);\\n}\\npublic int count(int[]nums,int target){\\n    int ans=0,i=0,j=nums.length-1;\\n    while(i<j){\\n        if(nums[i]+nums[j]>=target){\\n            j--;\\n        }\\n        else{\\n            ans+=j-i;\\n            i++;\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "it\\'s my life 46/51...whole moral down...\\uD83D\\uDE2A\\uD83D\\uDE2A\\nbut after context solved using Two Pointer"
                    }
                ]
            },
            {
                "id": 1797936,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "it should be like this :  \\n`i != j`"
                    },
                    {
                        "username": "olazznog_88",
                        "content": "It\\'s not as simple as that. Consider this. If the pair (0,3) is a solution, the pair (3,0) must not be counted. By reducing the constraint to i != j you would count those two pairs, where only one (0,3) needs to be counted."
                    },
                    {
                        "username": "user8738ZV",
                        "content": "just sort the array and then apply binary search"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "is it be able to solve using binary search?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "noman598",
                        "content": "Every time I get stuck on this type of problem :)"
                    },
                    {
                        "username": "y-not",
                        "content": "Why is below code failing 2 test cases - \\n\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        int pairs = 0;\\n\\n        for (int i=0; i<nums.length; i++)\\n        {\\n            /*\\n                lower  <= (nums[i] + x)  <=   upper\\n                lower - nums[i]  <=  x <=  upper - nums[i]\\n            */\\n\\n            int l = lowerBound(nums, i+1, nums.length-1, lower - nums[i]);\\n            int u = upperBound(nums, i+1, nums.length-1, upper - nums[i]);\\n\\n            pairs += (u - l);\\n        }\\n        \\n        return pairs;\\n    }\\n\\n    /*\\n        Return value:\\n            - If key is present, return the first idx whose value is k\\n            - If key is not present, return the first idx whose value is greater than k. If no such element is present return r+1\\n    */\\n    int lowerBound(int[] nums, int l, int r, int key)\\n    {\\n        int ret = -1;\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] >= key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n\\n    /*\\n        Returns the first idx whose value is greater than k\\n        If no such element is present return r+1\\n    */\\n    int upperBound(int[] nums, int l, int r, int key)\\n    {\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] > key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }    \\n}"
                    },
                    {
                        "username": "prateek26",
                        "content": "51th test case failed where expected output is 4999950000. lower = -1000000000.  upper =1000000000. Anybody can help. \\n\\n    public int countFairPairs(final int[] a, final int lo, final int hi) {\\n        Arrays.sort(a);\\n        return countGreaterThanTarget(a, lo-1) - countGreaterThanTarget(a, hi);\\n    }\\n\\n    private int countGreaterThanTarget(final int[] a, final int target) {\\n        final int n = a.length;\\n        int i = 0, j = n-1;\\n        int ans = 0;\\n        while (i < j) {\\n            if (a[i] + a[j] > target) {\\n                ans = ans + (j-i);\\n                j--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "i didnt expect the second question in contest is like that"
                    },
                    {
                        "username": "Adonis21",
                        "content": "why it is giving error with 2 pointers ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "`can anyone help me to correct this code passing 49/51 test cases.`\\npublic int countFairPairs(int[] nums, int lower, int upper) {\\nArrays.sort(nums);\\nreturn count(nums,upper+1)-count(nums,lower);\\n}\\npublic int count(int[]nums,int target){\\n    int ans=0,i=0,j=nums.length-1;\\n    while(i<j){\\n        if(nums[i]+nums[j]>=target){\\n            j--;\\n        }\\n        else{\\n            ans+=j-i;\\n            i++;\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "it\\'s my life 46/51...whole moral down...\\uD83D\\uDE2A\\uD83D\\uDE2A\\nbut after context solved using Two Pointer"
                    }
                ]
            },
            {
                "id": 1797883,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "it should be like this :  \\n`i != j`"
                    },
                    {
                        "username": "olazznog_88",
                        "content": "It\\'s not as simple as that. Consider this. If the pair (0,3) is a solution, the pair (3,0) must not be counted. By reducing the constraint to i != j you would count those two pairs, where only one (0,3) needs to be counted."
                    },
                    {
                        "username": "user8738ZV",
                        "content": "just sort the array and then apply binary search"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "is it be able to solve using binary search?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "noman598",
                        "content": "Every time I get stuck on this type of problem :)"
                    },
                    {
                        "username": "y-not",
                        "content": "Why is below code failing 2 test cases - \\n\\nclass Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        int pairs = 0;\\n\\n        for (int i=0; i<nums.length; i++)\\n        {\\n            /*\\n                lower  <= (nums[i] + x)  <=   upper\\n                lower - nums[i]  <=  x <=  upper - nums[i]\\n            */\\n\\n            int l = lowerBound(nums, i+1, nums.length-1, lower - nums[i]);\\n            int u = upperBound(nums, i+1, nums.length-1, upper - nums[i]);\\n\\n            pairs += (u - l);\\n        }\\n        \\n        return pairs;\\n    }\\n\\n    /*\\n        Return value:\\n            - If key is present, return the first idx whose value is k\\n            - If key is not present, return the first idx whose value is greater than k. If no such element is present return r+1\\n    */\\n    int lowerBound(int[] nums, int l, int r, int key)\\n    {\\n        int ret = -1;\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] >= key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n\\n    /*\\n        Returns the first idx whose value is greater than k\\n        If no such element is present return r+1\\n    */\\n    int upperBound(int[] nums, int l, int r, int key)\\n    {\\n        while (l <= r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if (nums[mid] > key)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }    \\n}"
                    },
                    {
                        "username": "prateek26",
                        "content": "51th test case failed where expected output is 4999950000. lower = -1000000000.  upper =1000000000. Anybody can help. \\n\\n    public int countFairPairs(final int[] a, final int lo, final int hi) {\\n        Arrays.sort(a);\\n        return countGreaterThanTarget(a, lo-1) - countGreaterThanTarget(a, hi);\\n    }\\n\\n    private int countGreaterThanTarget(final int[] a, final int target) {\\n        final int n = a.length;\\n        int i = 0, j = n-1;\\n        int ans = 0;\\n        while (i < j) {\\n            if (a[i] + a[j] > target) {\\n                ans = ans + (j-i);\\n                j--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "i didnt expect the second question in contest is like that"
                    },
                    {
                        "username": "Adonis21",
                        "content": "why it is giving error with 2 pointers ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "`can anyone help me to correct this code passing 49/51 test cases.`\\npublic int countFairPairs(int[] nums, int lower, int upper) {\\nArrays.sort(nums);\\nreturn count(nums,upper+1)-count(nums,lower);\\n}\\npublic int count(int[]nums,int target){\\n    int ans=0,i=0,j=nums.length-1;\\n    while(i<j){\\n        if(nums[i]+nums[j]>=target){\\n            j--;\\n        }\\n        else{\\n            ans+=j-i;\\n            i++;\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "it\\'s my life 46/51...whole moral down...\\uD83D\\uDE2A\\uD83D\\uDE2A\\nbut after context solved using Two Pointer"
                    }
                ]
            }
        ]
    }
]