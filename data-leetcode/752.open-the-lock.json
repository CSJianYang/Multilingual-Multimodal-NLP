[
    {
        "title": "Create Maximum Number",
        "question_content": "You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.\nCreate the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.\nReturn an array of the k digits representing the answer.\n&nbsp;\nExample 1:\n\nInput: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\nOutput: [9,8,6,5,3]\n\nExample 2:\n\nInput: nums1 = [6,7], nums2 = [6,0,4], k = 5\nOutput: [6,7,6,0,4]\n\nExample 3:\n\nInput: nums1 = [3,9], nums2 = [8,9], k = 3\nOutput: [9,8,9]\n\n&nbsp;\nConstraints:\n\n\tm == nums1.length\n\tn == nums2.length\n\t1 <= m, n <= 500\n\t0 <= nums1[i], nums2[i] <= 9\n\t1 <= k <= m + n",
        "solutions": [
            {
                "id": 77285,
                "title": "share-my-greedy-solution",
                "content": "Many of the posts have the same algorithm. In short we can first solve 2 simpler problem\\n\\n1. Create the maximum number of one array \\n2. Create the maximum number of two array using all of their digits.\\n\\nFor an long and detailed explanation see my blog [here][1].\\n\\nThe algorithm is O((m+n)^3) in the worst case. It runs in 22 ms.\\n\\n**Java**\\n\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int[] ans = new int[k];\\n        for (int i = Math.max(0, k - m); i <= k && i <= n; ++i) {\\n            int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\\n            if (greater(candidate, 0, ans, 0)) ans = candidate;\\n        }\\n        return ans;\\n    }\\n    private int[] merge(int[] nums1, int[] nums2, int k) {\\n        int[] ans = new int[k];\\n        for (int i = 0, j = 0, r = 0; r < k; ++r)\\n            ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n        return ans;\\n    }\\n    public boolean greater(int[] nums1, int i, int[] nums2, int j) {\\n        while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\\n            i++;\\n            j++;\\n        }\\n        return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\\n    }\\n    public int[] maxArray(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] ans = new int[k];\\n        for (int i = 0, j = 0; i < n; ++i) {\\n            while (n - i + j > k && j > 0 && ans[j - 1] < nums[i]) j--;\\n            if (j < k) ans[j++] = nums[i];\\n        }\\n        return ans;\\n    }\\n\\n\\n  [1]: http://algobox.org/create-maximum-number/",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "Many of the posts have the same algorithm. In short we can first solve 2 simpler problem\\n\\n1. Create the maximum number of one array \\n2. Create the maximum number of two array using all of their digits.\\n\\nFor an long and detailed explanation see my blog [here][1].\\n\\nThe algorithm is O((m+n)^3) in the worst case. It runs in 22 ms.\\n\\n**Java**\\n\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int[] ans = new int[k];\\n        for (int i = Math.max(0, k - m); i <= k && i <= n; ++i) {\\n            int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\\n            if (greater(candidate, 0, ans, 0)) ans = candidate;\\n        }\\n        return ans;\\n    }\\n    private int[] merge(int[] nums1, int[] nums2, int k) {\\n        int[] ans = new int[k];\\n        for (int i = 0, j = 0, r = 0; r < k; ++r)\\n            ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n        return ans;\\n    }\\n    public boolean greater(int[] nums1, int i, int[] nums2, int j) {\\n        while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\\n            i++;\\n            j++;\\n        }\\n        return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\\n    }\\n    public int[] maxArray(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] ans = new int[k];\\n        for (int i = 0, j = 0; i < n; ++i) {\\n            while (n - i + j > k && j > 0 && ans[j - 1] < nums[i]) j--;\\n            if (j < k) ans[j++] = nums[i];\\n        }\\n        return ans;\\n    }\\n\\n\\n  [1]: http://algobox.org/create-maximum-number/",
                "codeTag": "Unknown"
            },
            {
                "id": 77287,
                "title": "c-16ms-fastest-beats-97",
                "content": "The basic idea:\\n\\nTo create max number of length k from two arrays, you need to create max number of length i from array one and max number of length k-i from array two, then combine them together. After trying all possible i, you will get the max number created from two arrays.\\n\\nOptimization: \\n\\n1. Suppose nums1 = [3, 4, 6, 5], nums2 = [9, 1, 2, 5, 8, 3], the maximum number you can create from nums1 is [6, 5] with length 2. For nums2, it's [9, 8, 3] with length 3. Merging the two sequence, we have [9, 8, 6, 5, 3], which is the max number we can create from two arrays without length constraint. If the required length k<=5, we can simply trim the result to required length from front. For instance, if k=3, then [9, 8, 6] is the result. \\n\\n2. Suppose we need to create max number with length 2 from num = [4, 5, 3, 2, 1, 6, 0, 8]. The simple way is to use a stack, first we push 4 and have stack [4], then comes 5 > 4, we pop 4 and push 5, stack becomes [5], 3 < 5, we push 3, stack becomes [5, 3]. Now we have the required length 2, but we need to keep going through the array in case a larger number comes, 2 < 3, we discard it instead of pushing it because the stack already grows to required size 2. 1 < 3, we discard it. 6 > 3, we pop 3, since 6 > 5 and there are still elements left, we can continue to pop 5 and push 6, the stack becomes [6], since 0 < 6, we push 0, the stack becomes [6, 0], the stack grows to required length again. Since 8 > 0, we pop 0, although 8 > 6, we can't continue to pop 6 since there is only one number, which is 8, left, if we pop 6 and push 8, we can't get to length 2, so we push 8 directly, the stack becomes [6, 8]. \\n\\n3. In the basic idea, we mentioned trying all possible length i. If we create max number for different i from scratch each time, that would be a waste of time. Suppose num = [4, 9, 3, 2, 1, 8, 7, 6], we need to create max number with length from 1 to 8. For i==8, result is the original array. For i==7, we need to drop 1 number from array, since 9 > 4, we drop 4, the result is [9, 3, 2, 1, 8, 7, 6]. For i==6, we need to drop 1 more number, 3 < 9, skip, 2 < 3, skip, 1 < 2, skip, 8 > 1, we drop 1, the result is [9, 3, 2, 8, 7, 6]. For i==5, we need to drop 1 more, but this time, we needn't check from beginning, during last scan, we already know [9, 3, 2] is monotonically non-increasing, so we check 8 directly, since 8 > 2, we drop 2, the result is [9, 3, 8, 7, 6]. For i==4, we start with 8, 8 > 3, we drop 3, the result is [9, 8, 7, 6]. For i==3, we start with 8, 8 < 9, skip, 7 < 8, skip, 6 < 7, skip, by now, we've got maximum number we can create from num without length constraint. So from now on, we can drop a number from the end each time. The result is [9, 8, 7], For i==2, we drop last number 7 and have [9, 8]. For i==1, we drop last number 8 and have [9].\\n\\n#\\n\\n    class Solution {\\n    public:\\n        #define MIN(a,b) (a<b?a:b)\\n        #define MAX(a,b) (a>b?a:b)\\n        // create max number of length t from single non-empty vector\\n        void getMax(int* num, int& len, int* result, int& t, int& sortedLen)\\n        {\\n        \\tint n, top = 0;\\n        \\tresult[0] = num[0];\\n        \\tconst int need2drop = len - t;\\n        \\tfor (int i = 1; i < len; ++i){\\n        \\t\\tn = num[i];\\n        \\t\\twhile (top >= 0 && result[top] < n && (i - top) <= need2drop) --top; // i - top means already dropped i - top numbers\\n        \\t\\tif (i - top > need2drop){\\n        \\t\\t\\tsortedLen = MAX(1,top);\\n        \\t\\t\\twhile (++top < t) result[top] = num[i++];\\n        \\t\\t\\treturn;\\n        \\t\\t}\\n        \\t\\tif (++top < t) result[top] = n;\\n        \\t\\telse top = t - 1;\\n        \\t}\\n        }\\n        // create max number of different length from single vector\\n        void dp(int *num, int len, int&sortedLen, int& minL, int& maxL, int *res, int &k){\\n        \\tint  j, *head, *prevhead = res;\\n        \\tconst int soi = sizeof(int);\\n        \\tgetMax(num, len, res, maxL,sortedLen);\\n        \\tfor (int l = maxL; l > MAX(minL,1); --l){\\n        \\t\\thead = prevhead + k;\\n        \\t\\tmemcpy(head, prevhead, l*soi);\\n        \\t\\tfor (j = sortedLen; j < l; ++j){\\n        \\t\\t\\tif (head[j] > head[j - 1]){\\n        \\t\\t\\t\\tsortedLen = MAX(1, j - 1);\\n        \\t\\t\\t\\tmemcpy(head + j - 1, prevhead + j, soi*(l - j));\\n        \\t\\t\\t\\tbreak;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\tif (j == l) sortedLen = l;\\n        \\t\\tprevhead = head;\\n        \\t}\\n        }\\n        // merge max number created from single vector\\n        void merge(int* num1,int len1,int* num2,int len2,int* result,int& resSize){\\n        \\tint i = 0, j = 0, k = 0;\\n        \\twhile (i < resSize){\\n        \\t\\tif (j < len1 && k < len2){\\n        \\t\\t\\tif (num1[j] > num2[k])\\n        \\t\\t\\t\\tresult[i++] = num1[j++];\\n        \\t\\t\\telse if (num1[j] < num2[k])\\n        \\t\\t\\t\\tresult[i++] = num2[k++];\\n        \\t\\t\\telse{\\n        \\t\\t\\t\\tint remaining1 = len1 - j, remaining2 = len2 - k, tmp = num1[j];\\n        \\t\\t\\t\\tint flag = memcmp(num1 + j, num2 + k, sizeof(int) * MIN(remaining1, remaining2));\\n        \\t\\t\\t\\tflag = (flag == 0 ? (remaining1>remaining2 ? 1 : -1) : flag);\\n        \\t\\t\\t\\tint * num = flag > 0 ? num1 : num2;\\n        \\t\\t\\t\\tint & cnt = flag > 0 ? j : k;\\n        \\t\\t\\t\\tint len = flag > 0 ? len1 : len2;\\n        \\t\\t\\t\\twhile (num[cnt]==tmp && cnt < len && i<resSize) result[i++] = num[cnt++];\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\telse if (j < len1) result[i++] = num1[j++];\\n        \\t\\telse result[i++] = num2[k++];\\n        \\t}\\n        }\\n        \\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k){\\n        \\tint soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size(), step = k*soi;\\n        \\tint minL1 = MAX(0, k - len2), maxL1 = MIN(k, len1), minL2 = k - maxL1, maxL2 = k - minL1, range = maxL1 - minL1 + 1;\\n        \\tint * res = new int[range * k * 2 + 2 * k], *dp1 = res + k, *dp2 = res + range*k+k, *tmp=res+range*2*k+k;\\n        \\tmemset(res, 0, step);\\n        \\tint sortedLen1 = 1, sortedLen2 = 1;\\n        \\tif (len1 == 0 && len2 > 0) getMax(&nums2[0], len2, res, k, sortedLen2);\\n        \\telse if (len1 > 0 && len2 == 0) getMax(&nums1[0], len1, res, k, sortedLen2);\\n        \\telse if (len1 > 0 && len2 > 0){\\n        \\t\\tdp(&nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k);\\n        \\t\\tdp(&nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k);\\n        \\t\\tif (sortedLen1 + sortedLen2 > k){\\n        \\t\\t\\tmerge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, tmp, k);\\n        \\t\\t\\tvector<int> resv(tmp, tmp + k);\\n        \\t\\t\\tdelete[] res;\\n        \\t\\t\\treturn resv;\\n        \\t\\t}\\n        \\t\\tfor (int i = minL1; i <= maxL1; ++i){\\n        \\t\\t\\tmerge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k);\\n        \\t\\t\\tif (memcmp(res, tmp, step) < 0) memcpy(res, tmp, step);\\n        \\t\\t}\\n        \\t}\\n        \\tvector<int> resv(res, res + k);\\n        \\tdelete[] res;\\n        \\treturn resv;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        #define MIN(a,b) (a<b?a:b)\\n        #define MAX(a,b) (a>b?a:b)\\n        // create max number of length t from single non-empty vector\\n        void getMax(int* num, int& len, int* result, int& t, int& sortedLen)\\n        {\\n        \\tint n, top = 0;\\n        \\tresult[0] = num[0];\\n        \\tconst int need2drop = len - t;\\n        \\tfor (int i = 1; i < len; ++i){\\n        \\t\\tn = num[i];\\n        \\t\\twhile (top >= 0 && result[top] < n && (i - top) <= need2drop) --top; // i - top means already dropped i - top numbers\\n        \\t\\tif (i - top > need2drop){\\n        \\t\\t\\tsortedLen = MAX(1,top);\\n        \\t\\t\\twhile (++top < t) result[top] = num[i++];\\n        \\t\\t\\treturn;\\n        \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 77286,
                "title": "short-python-ruby-c",
                "content": "**Python**\\n\\n    def maxNumber(self, nums1, nums2, k):\\n\\n        def prep(nums, k):\\n            drop = len(nums) - k\\n            out = []\\n            for num in nums:\\n                while drop and out and out[-1] < num:\\n                    out.pop()\\n                    drop -= 1\\n                out.append(num)\\n            return out[:k]\\n\\n        def merge(a, b):\\n            return [max(a, b).pop(0) for _ in a+b]\\n\\n        return max(merge(prep(nums1, i), prep(nums2, k-i))\\n                   for i in range(k+1)\\n                   if i <= len(nums1) and k-i <= len(nums2))\\n\\nSolved it on my own but now I see others already posted this idea. Oh well, at least it's short, particularly my `merge` function.\\n\\nThe last two lines can be combined, but I find it rather ugly and not worth it:  \\n`for i in range(max(k-len(nums2), 0), min(k, len(nums1))+1))`\\n\\n---\\n\\n**Ruby**\\n\\n    def prep(nums, k)\\n      drop = nums.size - k\\n      out = [9]\\n      nums.each do |num|\\n        while drop > 0 && out[-1] < num\\n          out.pop\\n          drop -= 1\\n        end\\n        out << num\\n      end\\n      out[1..k]\\n    end\\n    \\n    def max_number(nums1, nums2, k)\\n      ([k-nums2.size, 0].max .. [nums1.size, k].min).map { |k1|\\n        parts = [prep(nums1, k1), prep(nums2, k-k1)]\\n        (1..k).map { parts.max.shift }\\n      }.max\\n    end\\n\\n---\\n\\n**C++**\\n\\nTranslated it to C++ as well now. Not as short anymore, but still decent. And C++ allows different functions with the same name, so I chose to do that here to show how nicely the `maxNumber(nums1, nums2, k)` problem can be based on the problems `maxNumber(nums, k)` and `maxNumber(nums1, nums2)`, which would make fine problems on their own.\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        vector<int> best;\\n        for (int k1=max(k-n2, 0); k1<=min(k, n1); ++k1)\\n            best = max(best, maxNumber(maxNumber(nums1, k1),\\n                                       maxNumber(nums2, k-k1)));\\n        return best;\\n    }\\n\\n    vector<int> maxNumber(vector<int> nums, int k) {\\n        int drop = nums.size() - k;\\n        vector<int> out;\\n        for (int num : nums) {\\n            while (drop && out.size() && out.back() < num) {\\n                out.pop_back();\\n                drop--;\\n            }\\n            out.push_back(num);\\n        }\\n        out.resize(k);\\n        return out;\\n    }\\n\\n    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {\\n        vector<int> out;\\n        while (nums1.size() + nums2.size()) {\\n            vector<int>& now = nums1 > nums2 ? nums1 : nums2;\\n            out.push_back(now[0]);\\n            now.erase(now.begin());\\n        }\\n        return out;\\n    }\\n\\nAn alternative for `maxNumber(nums1, nums2)`:\\n\\n    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {\\n        vector<int> out;\\n        auto i1 = nums1.begin(), end1 = nums1.end();\\n        auto i2 = nums2.begin(), end2 = nums2.end();\\n        while (i1 != end1 || i2 != end2)\\n            out.push_back(lexicographical_compare(i1, end1, i2, end2) ? *i2++ : *i1++);\\n        return out;\\n    }",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Ruby"
                ],
                "code": "**Python**\\n\\n    def maxNumber(self, nums1, nums2, k):\\n\\n        def prep(nums, k):\\n            drop = len(nums) - k\\n            out = []\\n            for num in nums:\\n                while drop and out and out[-1] < num:\\n                    out.pop()\\n                    drop -= 1\\n                out.append(num)\\n            return out[:k]\\n\\n        def merge(a, b):\\n            return [max(a, b).pop(0) for _ in a+b]\\n\\n        return max(merge(prep(nums1, i), prep(nums2, k-i))\\n                   for i in range(k+1)\\n                   if i <= len(nums1) and k-i <= len(nums2))\\n\\nSolved it on my own but now I see others already posted this idea. Oh well, at least it's short, particularly my `merge` function.\\n\\nThe last two lines can be combined, but I find it rather ugly and not worth it:  \\n`for i in range(max(k-len(nums2), 0), min(k, len(nums1))+1))`\\n\\n---\\n\\n**Ruby**\\n\\n    def prep(nums, k)\\n      drop = nums.size - k\\n      out = [9]\\n      nums.each do |num|\\n        while drop > 0 && out[-1] < num\\n          out.pop\\n          drop -= 1\\n        end\\n        out << num\\n      end\\n      out[1..k]\\n    end\\n    \\n    def max_number(nums1, nums2, k)\\n      ([k-nums2.size, 0].max .. [nums1.size, k].min).map { |k1|\\n        parts = [prep(nums1, k1), prep(nums2, k-k1)]\\n        (1..k).map { parts.max.shift }\\n      }.max\\n    end\\n\\n---\\n\\n**C++**\\n\\nTranslated it to C++ as well now. Not as short anymore, but still decent. And C++ allows different functions with the same name, so I chose to do that here to show how nicely the `maxNumber(nums1, nums2, k)` problem can be based on the problems `maxNumber(nums, k)` and `maxNumber(nums1, nums2)`, which would make fine problems on their own.\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        vector<int> best;\\n        for (int k1=max(k-n2, 0); k1<=min(k, n1); ++k1)\\n            best = max(best, maxNumber(maxNumber(nums1, k1),\\n                                       maxNumber(nums2, k-k1)));\\n        return best;\\n    }\\n\\n    vector<int> maxNumber(vector<int> nums, int k) {\\n        int drop = nums.size() - k;\\n        vector<int> out;\\n        for (int num : nums) {\\n            while (drop && out.size() && out.back() < num) {\\n                out.pop_back();\\n                drop--;\\n            }\\n            out.push_back(num);\\n        }\\n        out.resize(k);\\n        return out;\\n    }\\n\\n    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {\\n        vector<int> out;\\n        while (nums1.size() + nums2.size()) {\\n            vector<int>& now = nums1 > nums2 ? nums1 : nums2;\\n            out.push_back(now[0]);\\n            now.erase(now.begin());\\n        }\\n        return out;\\n    }\\n\\nAn alternative for `maxNumber(nums1, nums2)`:\\n\\n    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {\\n        vector<int> out;\\n        auto i1 = nums1.begin(), end1 = nums1.end();\\n        auto i2 = nums2.begin(), end2 = nums2.end();\\n        while (i1 != end1 || i2 != end2)\\n            out.push_back(lexicographical_compare(i1, end1, i2, end2) ? *i2++ : *i1++);\\n        return out;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 77291,
                "title": "share-my-python-solution-with-explanation",
                "content": "To create the max number from num1 and nums2 with k elements, we assume the final result combined by i numbers (denotes as **left**) from num1 and j numbers (denotes as **right**) from nums2, where i+j==k.\\n\\nObviously, left and right must be the maximum possible number in num1 and num2 respectively. i.e. num1 = [6,5,7,1] and i == 2, then left must be [7,1]. \\n\\nThe final result is the maximum possible merge of all left and right. \\n\\nSo there're 3 steps:\\n\\n 1. **iterate i from 0 to k.**\\n 2. **find max number from num1, num2 by select i , k-i numbers, denotes as left, right**\\n 3. **find max merge of left, right**\\n\\nfunction **maxSingleNumber** select i elements from num1 that is maximum. The idea find the max number one by one. i.e. assume nums [6,5,7,1,4,2], selects = 3.\\n1st digit: find max digit in [6,5,7,1], the last two digits [4, 2] can not be selected at this moment.\\n2nd digits: find max digit in [1,4], since we have already selects 7, we should consider elements after it, also, we should leave one element out.\\n3rd digits: only one left [2], we select it. and function output [7,4,2]\\n\\nfunction **mergeMax**  find the maximum combination of left, and right. \\n\\n\\n    class Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n, m= len(nums1),len(nums2)\\n        ret = [0] * k\\n        for i in range(0, k+1):\\n            j = k - i\\n            if i > n or j > m: continue\\n            left = self.maxSingleNumber(nums1, i)\\n            right = self.maxSingleNumber(nums2, j)\\n            num = self.mergeMax(left, right)\\n            ret = max(num, ret)\\n        return ret\\n\\n\\n    def mergeMax(self, nums1, nums2):\\n        ans = []\\n        while nums1 or nums2:\\n            if nums1 > nums2:\\n                ans += nums1[0],\\n                nums1 = nums1[1:]\\n            else:\\n                ans += nums2[0],\\n                nums2 = nums2[1:]\\n        return ans\\n\\n    def maxSingleNumber(self, nums, selects):\\n        n = len(nums)\\n        ret = [-1]\\n        if selects > n : return ret\\n        while selects > 0:\\n            start = ret[-1] + 1 #search start\\n            end = n-selects + 1 #search end\\n            ret.append( max(range(start, end), key = nums.__getitem__))\\n            selects -= 1\\n        ret = [nums[item] for item in ret[1:]]\\n        return ret",
                "solutionTags": [],
                "code": "To create the max number from num1 and nums2 with k elements, we assume the final result combined by i numbers (denotes as **left**) from num1 and j numbers (denotes as **right**) from nums2, where i+j==k.\\n\\nObviously, left and right must be the maximum possible number in num1 and num2 respectively. i.e. num1 = [6,5,7,1] and i == 2, then left must be [7,1]. \\n\\nThe final result is the maximum possible merge of all left and right. \\n\\nSo there're 3 steps:\\n\\n 1. **iterate i from 0 to k.**\\n 2. **find max number from num1, num2 by select i , k-i numbers, denotes as left, right**\\n 3. **find max merge of left, right**\\n\\nfunction **maxSingleNumber** select i elements from num1 that is maximum. The idea find the max number one by one. i.e. assume nums [6,5,7,1,4,2], selects = 3.\\n1st digit: find max digit in [6,5,7,1], the last two digits [4, 2] can not be selected at this moment.\\n2nd digits: find max digit in [1,4], since we have already selects 7, we should consider elements after it, also, we should leave one element out.\\n3rd digits: only one left [2], we select it. and function output [7,4,2]\\n\\nfunction **mergeMax**  find the maximum combination of left, and right. \\n\\n\\n    class Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n, m= len(nums1),len(nums2)\\n        ret = [0] * k\\n        for i in range(0, k+1):\\n            j = k - i\\n            if i > n or j > m: continue\\n            left = self.maxSingleNumber(nums1, i)\\n            right = self.maxSingleNumber(nums2, j)\\n            num = self.mergeMax(left, right)\\n            ret = max(num, ret)\\n        return ret\\n\\n\\n    def mergeMax(self, nums1, nums2):\\n        ans = []\\n        while nums1 or nums2:\\n            if nums1 > nums2:\\n                ans += nums1[0],\\n                nums1 = nums1[1:]\\n            else:\\n                ans += nums2[0],\\n                nums2 = nums2[1:]\\n        return ans\\n\\n    def maxSingleNumber(self, nums, selects):\\n        n = len(nums)\\n        ret = [-1]\\n        if selects > n : return ret\\n        while selects > 0:\\n            start = ret[-1] + 1 #search start\\n            end = n-selects + 1 #search end\\n            ret.append( max(range(start, end), key = nums.__getitem__))\\n            selects -= 1\\n        ret = [nums[item] for item in ret[1:]]\\n        return ret",
                "codeTag": "Java"
            },
            {
                "id": 77299,
                "title": "divide-to-three-subproblem-solution-beat-98",
                "content": "subproblem1: \\nget the largest k numbers when keeping the relative order\\n\\nsubproblem2: \\nmerge two arrays which are from subproblem1.\\n\\nsubproblem3: \\ncompare two arrays.\\n\\n```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int len1 = nums1.length;\\n        int len2 = nums2.length;\\n        int[] result = new int[k];\\n        if(len1+len2 < k) {\\n            return result;//bad case\\n        }else if(len1+len2 == k){\\n            result = mergeTwoArrays(nums1, nums2, k);//edge case\\n        }else{\\n            for (int i = 0; i <= k; i++) {\\n                if(i<=len1 && (k-i)<=len2){\\n                    int[] maxNumbers1 = maxNumberOfSingleArray(nums1, i);\\n                    int[] maxNumbers2 = maxNumberOfSingleArray(nums2, k - i);\\n                    int[] maxNumbers = mergeTwoArrays(maxNumbers1, maxNumbers2, k);\\n                    if (compareTwoArrays(maxNumbers, 0, result, 0)) result = maxNumbers;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int[] mergeTwoArrays(int[] nums1, int[] nums2, int k) {\\n        int[] result = new int[k];\\n        int idx1 = 0, idx2 = 0;\\n        int idx = 0;\\n        while(idx < k){\\n            //check the two remain arrays to see which one is larger.\\n            if(compareTwoArrays(nums1, idx1, nums2, idx2)){\\n                result[idx] = nums1[idx1++];\\n            }else{\\n                result[idx] = nums2[idx2++];\\n            }\\n            idx++;\\n        }\\n        return result;\\n    }\\n    \\n    //get the largest k numbers when keeping the relative order\\n    private int[] maxNumberOfSingleArray(int[] nums, int k){\\n        int[] result = new int[k];\\n        if(k == 0) return result;\\n\\n        int len = nums.length;\\n        int idx = 0;\\n        for(int i = 0; i < len; i++){\\n            while((len-i-1) + (idx+1) > k && idx>0 && nums[i] > result[idx-1]) idx--;\\n            if(idx < k) result[idx++] = nums[i];\\n        }\\n        return result;\\n    }\\n    \\n    //compare two arrays at the \"start\" index\\n    public boolean compareTwoArrays(int[] nums1, int startIdx1, int[] nums2, int startIdx2) {\\n        int len1 = nums1.length - startIdx1;\\n        if(len1 <= 0) return false;\\n        int len2 = nums2.length - startIdx2;\\n        if(len2 <= 0) return true;\\n        int len = Math.max(len1, len2);\\n        for (int i = 0; i< len; i++) {\\n        \\tint digit1 = startIdx1 + i < nums1.length ? nums1[startIdx1 + i] : 0;\\n        \\tint digit2 = startIdx2 + i < nums2.length ? nums2[startIdx2 + i] : 0;\\n        \\tif(digit1 != digit2){\\n        \\t    return digit1 > digit2;\\n        \\t}\\n        }\\n        return true;//equal, choose either one is ok\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int len1 = nums1.length;\\n        int len2 = nums2.length;\\n        int[] result = new int[k];\\n        if(len1+len2 < k) {\\n            return result;//bad case\\n        }else if(len1+len2 == k){\\n            result = mergeTwoArrays(nums1, nums2, k);//edge case\\n        }else{\\n            for (int i = 0; i <= k; i++) {\\n                if(i<=len1 && (k-i)<=len2){\\n                    int[] maxNumbers1 = maxNumberOfSingleArray(nums1, i);\\n                    int[] maxNumbers2 = maxNumberOfSingleArray(nums2, k - i);\\n                    int[] maxNumbers = mergeTwoArrays(maxNumbers1, maxNumbers2, k);\\n                    if (compareTwoArrays(maxNumbers, 0, result, 0)) result = maxNumbers;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int[] mergeTwoArrays(int[] nums1, int[] nums2, int k) {\\n        int[] result = new int[k];\\n        int idx1 = 0, idx2 = 0;\\n        int idx = 0;\\n        while(idx < k){\\n            //check the two remain arrays to see which one is larger.\\n            if(compareTwoArrays(nums1, idx1, nums2, idx2)){\\n                result[idx] = nums1[idx1++];\\n            }else{\\n                result[idx] = nums2[idx2++];\\n            }\\n            idx++;\\n        }\\n        return result;\\n    }\\n    \\n    //get the largest k numbers when keeping the relative order\\n    private int[] maxNumberOfSingleArray(int[] nums, int k){\\n        int[] result = new int[k];\\n        if(k == 0) return result;\\n\\n        int len = nums.length;\\n        int idx = 0;\\n        for(int i = 0; i < len; i++){\\n            while((len-i-1) + (idx+1) > k && idx>0 && nums[i] > result[idx-1]) idx--;\\n            if(idx < k) result[idx++] = nums[i];\\n        }\\n        return result;\\n    }\\n    \\n    //compare two arrays at the \"start\" index\\n    public boolean compareTwoArrays(int[] nums1, int startIdx1, int[] nums2, int startIdx2) {\\n        int len1 = nums1.length - startIdx1;\\n        if(len1 <= 0) return false;\\n        int len2 = nums2.length - startIdx2;\\n        if(len2 <= 0) return true;\\n        int len = Math.max(len1, len2);\\n        for (int i = 0; i< len; i++) {\\n        \\tint digit1 = startIdx1 + i < nums1.length ? nums1[startIdx1 + i] : 0;\\n        \\tint digit2 = startIdx2 + i < nums2.length ? nums2[startIdx2 + i] : 0;\\n        \\tif(digit1 != digit2){\\n        \\t    return digit1 > digit2;\\n        \\t}\\n        }\\n        return true;//equal, choose either one is ok\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77283,
                "title": "share-my-21ms-java-solution-with-comments",
                "content": "To find the maximum ,we can enumerate how digits we should get from nums1 , we suppose it is i.\\n\\nSo ,  the digits from nums2 is K - i.\\n\\nAnd we can use a stack to get the get maximum number(x digits) from one array.\\n\\nOK, Once we choose two maximum subarray , we should combine it to the answer.\\n\\nIt is just like merger sort, but we should pay attention to the case: the two digital are equal.\\n\\nwe should find the digits behind it to judge which digital we should choose now.\\n\\nIn other words,we should judge which subarry is bigger than the other.\\n\\nThat's all.\\n\\nIf you have any question or suggest, I am happy you can comment on my blog : [Create Maximum Number][1].\\n\\nThanks, merry christmas :)\\n\\n *update:use stack to find max sub array and it runs 21ms now.( thanks to @dietpepsi )*\\n\\n   \\n\\n     /**  * Created by hrwhisper on 2015/11/23.  * http://www.hrwhisper.me/leetcode-create-maximum-number/  */\\n    \\n    \\n    public class Solution {\\n        public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n            int get_from_nums1 = Math.min(nums1.length, k);\\n            int[] ans = new int[k];\\n            for (int i = Math.max(k - nums2.length, 0); i <= get_from_nums1; i++) {\\n                int[] res1 = new int[i];\\n                int[] res2 = new int[k - i];\\n                int[] res = new int[k];\\n                res1 = solve(nums1, i);\\n                res2 = solve(nums2, k - i);\\n                int pos1 = 0, pos2 = 0, tpos = 0;\\n                \\n                while (res1.length > 0 && res2.length > 0 && pos1 < res1.length && pos2 < res2.length) {\\n                    if (compare(res1, pos1, res2, pos2))\\n                        res[tpos++] = res1[pos1++];\\n                    else\\n                        res[tpos++] = res2[pos2++];\\n                }\\n                while (pos1 < res1.length)\\n                    res[tpos++] = res1[pos1++];\\n                while (pos2 < res2.length)\\n                    res[tpos++] = res2[pos2++];\\n    \\n                if (!compare(ans, 0, res, 0))\\n                    ans = res;\\n            }\\n    \\n            return ans;\\n        }\\n    \\n        public boolean compare(int[] nums1, int start1, int[] nums2, int start2) {\\n            for (; start1 < nums1.length && start2 < nums2.length; start1++, start2++) {\\n                if (nums1[start1] > nums2[start2]) return true;\\n                if (nums1[start1] < nums2[start2]) return false;\\n            }\\n            return start1 != nums1.length;\\n        }\\n    \\n        public int[] solve(int[] nums, int k) {\\n            int[] res = new int[k];\\n            int len = 0;\\n            for (int i = 0; i < nums.length; i++) {\\n                while (len > 0 && len + nums.length - i > k && res[len - 1] < nums[i]) {\\n                    len--;\\n                }\\n                if (len < k)\\n                    res[len++] = nums[i];\\n            }\\n            return res;\\n        } }\\n\\n\\n  [1]: http://www.hrwhisper.me/leetcode-create-maximum-number/",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n            int get_from_nums1 = Math.min(nums1.length, k);\\n            int[] ans = new int[k];\\n            for (int i = Math.max(k - nums2.length, 0); i <= get_from_nums1; i++) {\\n                int[] res1 = new int[i];\\n                int[] res2 = new int[k - i];\\n                int[] res = new int[k];\\n                res1 = solve(nums1, i);\\n                res2 = solve(nums2, k - i);\\n                int pos1 = 0, pos2 = 0, tpos = 0;\\n                \\n                while (res1.length > 0 && res2.length > 0 && pos1 < res1.length && pos2 < res2.length) {\\n                    if (compare(res1, pos1, res2, pos2))\\n                        res[tpos++] = res1[pos1++];\\n                    else\\n                        res[tpos++] = res2[pos2++];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 77325,
                "title": "clean-and-easy-to-understand-c-solution",
                "content": "    vector<int> maxVector(vector<int> nums, int k) {\\n        while (nums.size() > k) {\\n            int i = 0, n = nums.size();\\n            for (; i < n - 1; ++i) {\\n                if (nums[i] < nums[i + 1]) {\\n                    nums.erase(nums.begin() + i);\\n                    break;\\n                }\\n            }\\n            if (i == n - 1) nums.erase(nums.begin() + i);\\n        }\\n    \\n        return nums;\\n    }\\n    \\n    bool compare(vector<int> &nums1, int i, vector<int> &nums2, int j) {\\n        while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j]) {\\n            ++i;\\n            ++j;\\n        }\\n        if (j == nums2.size()) return true;\\n        if (i < nums1.size() && nums1[i] > nums2[j]) return true;\\n        return false;\\n    }\\n    \\n    vector<int> merge(vector<int> &nums1, vector<int> &nums2, int k) {\\n        vector<int> res(k, 0);\\n        for (int i = 0, j = 0, r = 0; r < k; ++r) {\\n            res[r] = compare(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n        }\\n    \\n        return res;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m = nums1.size(), n = nums2.size();\\n        vector<int> res(k, 0);\\n    \\n        for (int i = max(0, k - n); i <= min(k, m); ++i) {\\n            auto v1 = maxVector(nums1, i);\\n            auto v2 = maxVector(nums2, k - i);\\n            auto tmp = merge(v1, v2, k);\\n            if (compare(tmp, 0, res, 0)) res = tmp;\\n        }\\n    \\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> maxVector(vector<int> nums, int k) {\\n        while (nums.size() > k) {\\n            int i = 0, n = nums.size();\\n            for (; i < n - 1; ++i) {\\n                if (nums[i] < nums[i + 1]) {\\n                    nums.erase(nums.begin() + i);\\n                    break;\\n                }\\n            }\\n            if (i == n - 1) nums.erase(nums.begin() + i);\\n        }\\n    \\n        return nums;\\n    }\\n    \\n    bool compare(vector<int> &nums1, int i, vector<int> &nums2, int j) {\\n        while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j]) {\\n            ++i;\\n            ++j;\\n        }\\n        if (j == nums2.size()) return true;\\n        if (i < nums1.size() && nums1[i] > nums2[j]) return true;\\n        return false;\\n    }\\n    \\n    vector<int> merge(vector<int> &nums1, vector<int> &nums2, int k) {\\n        vector<int> res(k, 0);\\n        for (int i = 0, j = 0, r = 0; r < k; ++r) {\\n            res[r] = compare(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n        }\\n    \\n        return res;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m = nums1.size(), n = nums2.size();\\n        vector<int> res(k, 0);\\n    \\n        for (int i = max(0, k - n); i <= min(k, m); ++i) {\\n            auto v1 = maxVector(nums1, i);\\n            auto v2 = maxVector(nums2, k - i);\\n            auto tmp = merge(v1, v2, k);\\n            if (compare(tmp, 0, res, 0)) res = tmp;\\n        }\\n    \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3529919,
                "title": "greedy-intuitive-detailed-explanation",
                "content": "# Intuition\\n\\nThis question is basically a combo of monotonic stack and merging two arrays.\\n\\nSo, to create a maximum number of k size array, we will iterate over the first array to take the size of largest possible number and correspondingly we will take the (k-i) size of largest possible number from the second array.\\nAfter storing the largest arrays in n1 and n2 we are merging them using merge function and then taking maximum of all.\\n\\n```\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size(), m = nums2.size();\\n        string mx = \"\";\\n        for(int i = 0; i <= k && i <= n; i++){\\n            if((k-i) > m) continue; //If we are taking i size of largest array from nums1 then are we capable of building k-i size of largest array from num2 .\\n            vector<int> n1 = maxnum(nums1, i);\\n            vector<int> n2 = maxnum(nums2, k-i);\\n            string s = merge(n1, n2, k);\\n            mx = max(mx, s);\\n        }\\n        vector<int> res;\\n        for(int i = 0; i < mx.size(); i++) res.push_back(mx[i] - \\'0\\');\\n        return res;\\n    }\\n```\\n\\nThis is the code to calculate the largest possible number of kth size from array nums. This is based on monotonic stack.\\n\\nSimilar question(Same logic): https://leetcode.com/submissions/detail/950762503/\\n\\n```\\n    vector<int> maxnum(vector<int> nums, int k){\\n        stack<int> st;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            while(!st.empty() && nums[st.top()] < nums[i] && n - i + st.size() > k) st.pop();\\n            if(st.size() < k) st.push(i);\\n        }\\n        vector<int> ans;\\n        while(!st.empty()) ans.push_back(nums[st.top()]), st.pop();\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\n\\n\\n``` \\n\\nSo, here we are merging both the arrays.\\nIf element of n2 is greater then we will simply take its value in the ans array and vice versa (similar to merging of merge sort).\\n\\n**Most Important**\\nWhen we will encounter equal values in n1 and n2 then we will simply increment both the indices.\\n\\n`nums1 = [5,0,2,1,0,1,0,3,9,1,2,8,0,9,8,1,4,7,3],\\nnums2 = [7,6,7,1,0,1,0,5,6,0,5,0],\\nk = 31`\\n\\nYou can dry run on this test case.\\n\\n```\\n    string merge(vector<int>& n1, vector<int>& n2, int k){\\n        vector<int> ans(k, 0);\\n         int i = 0, j = 0, x = 0;\\n            while(i < n1.size() && j < n2.size()){\\n                if(n2[j] > n1[i]) ans[x++] = n2[j], j++;\\n                else if(n2[j] == n1[i]){\\n                    int indi=i, indj=j;\\n                    while(indi < n1.size() && indj < n2.size() && n1[indi] == n2[indj]) indi++, indj++;\\n                    if(indj == n2.size()) ans[x++] = n1[i], i++;\\n                    else{\\n                        if(indi < n1.size() && n1[indi] > n2[indj]) ans[x++] = n1[i], i++;\\n                        else ans[x++] = n2[j], j++;\\n                    }\\n                }\\n\\n                else ans[x++] = n1[i], i++; \\n            }\\n            while(i < n1.size()) ans[x++] = n1[i], i++;\\n            while(j < n2.size()) ans[x++] = n2[j], j++;\\n            string s = \"\";\\n            for(auto it: ans) s += to_string(it);\\n            return s;\\n    }\\n```\\n\\n\\n\\n# Complete Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> maxnum(vector<int> nums, int k){\\n        stack<int> st;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            while(!st.empty() && nums[st.top()] < nums[i] && n - i + st.size() > k) st.pop();\\n            if(st.size() < k) st.push(i);\\n        }\\n        vector<int> ans;\\n        while(!st.empty()) ans.push_back(nums[st.top()]), st.pop();\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\n    string merge(vector<int>& n1, vector<int>& n2, int k){\\n        vector<int> ans(k, 0);\\n         int i = 0, j = 0, x = 0;\\n            while(i < n1.size() && j < n2.size()){\\n                if(n2[j] > n1[i]) ans[x++] = n2[j], j++;\\n                else if(n2[j] == n1[i]){\\n                    int indi=i, indj=j;\\n                    while(indi < n1.size() && indj < n2.size() && n1[indi] == n2[indj]) indi++, indj++;\\n                    if(indj == n2.size()) ans[x++] = n1[i], i++;\\n                    else{\\n                        if(indi < n1.size() && n1[indi] > n2[indj]) ans[x++] = n1[i], i++;\\n                        else ans[x++] = n2[j], j++;\\n                    }\\n                }\\n\\n                else ans[x++] = n1[i], i++; \\n            }\\n            while(i < n1.size()) ans[x++] = n1[i], i++;\\n            while(j < n2.size()) ans[x++] = n2[j], j++;\\n            string s = \"\";\\n            for(auto it: ans) s += to_string(it);\\n            return s;\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size(), m = nums2.size();\\n        string mx = \"\";\\n        for(int i = 0; i <= k && i <= n; i++){\\n            if((k-i) > m) continue; //If we are taking i size of largest array from nums1 then are we capable of building k-i size of largest array from num2 .\\n            vector<int> n1 = maxnum(nums1, i);\\n            vector<int> n2 = maxnum(nums2, k-i);\\n            string s = merge(n1, n2, k);\\n            mx = max(mx, s);\\n        }\\n        vector<int> res;\\n        for(int i = 0; i < mx.size(); i++) res.push_back(mx[i] - \\'0\\');\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size(), m = nums2.size();\\n        string mx = \"\";\\n        for(int i = 0; i <= k && i <= n; i++){\\n            if((k-i) > m) continue; //If we are taking i size of largest array from nums1 then are we capable of building k-i size of largest array from num2 .\\n            vector<int> n1 = maxnum(nums1, i);\\n            vector<int> n2 = maxnum(nums2, k-i);\\n            string s = merge(n1, n2, k);\\n            mx = max(mx, s);\\n        }\\n        vector<int> res;\\n        for(int i = 0; i < mx.size(); i++) res.push_back(mx[i] - \\'0\\');\\n        return res;\\n    }\\n```\n```\\n    vector<int> maxnum(vector<int> nums, int k){\\n        stack<int> st;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            while(!st.empty() && nums[st.top()] < nums[i] && n - i + st.size() > k) st.pop();\\n            if(st.size() < k) st.push(i);\\n        }\\n        vector<int> ans;\\n        while(!st.empty()) ans.push_back(nums[st.top()]), st.pop();\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\n\\n\\n```\n```\\n    string merge(vector<int>& n1, vector<int>& n2, int k){\\n        vector<int> ans(k, 0);\\n         int i = 0, j = 0, x = 0;\\n            while(i < n1.size() && j < n2.size()){\\n                if(n2[j] > n1[i]) ans[x++] = n2[j], j++;\\n                else if(n2[j] == n1[i]){\\n                    int indi=i, indj=j;\\n                    while(indi < n1.size() && indj < n2.size() && n1[indi] == n2[indj]) indi++, indj++;\\n                    if(indj == n2.size()) ans[x++] = n1[i], i++;\\n                    else{\\n                        if(indi < n1.size() && n1[indi] > n2[indj]) ans[x++] = n1[i], i++;\\n                        else ans[x++] = n2[j], j++;\\n                    }\\n                }\\n\\n                else ans[x++] = n1[i], i++; \\n            }\\n            while(i < n1.size()) ans[x++] = n1[i], i++;\\n            while(j < n2.size()) ans[x++] = n2[j], j++;\\n            string s = \"\";\\n            for(auto it: ans) s += to_string(it);\\n            return s;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> maxnum(vector<int> nums, int k){\\n        stack<int> st;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            while(!st.empty() && nums[st.top()] < nums[i] && n - i + st.size() > k) st.pop();\\n            if(st.size() < k) st.push(i);\\n        }\\n        vector<int> ans;\\n        while(!st.empty()) ans.push_back(nums[st.top()]), st.pop();\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\n    string merge(vector<int>& n1, vector<int>& n2, int k){\\n        vector<int> ans(k, 0);\\n         int i = 0, j = 0, x = 0;\\n            while(i < n1.size() && j < n2.size()){\\n                if(n2[j] > n1[i]) ans[x++] = n2[j], j++;\\n                else if(n2[j] == n1[i]){\\n                    int indi=i, indj=j;\\n                    while(indi < n1.size() && indj < n2.size() && n1[indi] == n2[indj]) indi++, indj++;\\n                    if(indj == n2.size()) ans[x++] = n1[i], i++;\\n                    else{\\n                        if(indi < n1.size() && n1[indi] > n2[indj]) ans[x++] = n1[i], i++;\\n                        else ans[x++] = n2[j], j++;\\n                    }\\n                }\\n\\n                else ans[x++] = n1[i], i++; \\n            }\\n            while(i < n1.size()) ans[x++] = n1[i], i++;\\n            while(j < n2.size()) ans[x++] = n2[j], j++;\\n            string s = \"\";\\n            for(auto it: ans) s += to_string(it);\\n            return s;\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size(), m = nums2.size();\\n        string mx = \"\";\\n        for(int i = 0; i <= k && i <= n; i++){\\n            if((k-i) > m) continue; //If we are taking i size of largest array from nums1 then are we capable of building k-i size of largest array from num2 .\\n            vector<int> n1 = maxnum(nums1, i);\\n            vector<int> n2 = maxnum(nums2, k-i);\\n            string s = merge(n1, n2, k);\\n            mx = max(mx, s);\\n        }\\n        vector<int> res;\\n        for(int i = 0; i < mx.size(); i++) res.push_back(mx[i] - \\'0\\');\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917528,
                "title": "c-intuition-w-reference-question-stack-and-merge-sort-concept",
                "content": "\\nThis question is a combination of multiple topics and also one of the best question i have encountered so far. \\nBefore solving this question, you need have knowledge about merge sort technique and also you need to solve its prerequisite question ([1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/))\\n\\nFirst, Try that question and if you dont get any intuition, don\\'t feel bad. Even i took some help. You can read its editorial from [here](https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/1903056/C%2B%2B-Stack-Solution-intuition-or-Monotonic-Stack)\\n\\n***Basic Idea*** of this problem is that we have two arrays, so we find the largest \\'i\\' digit number from nums1 and largest \\'k-i\\' digit number from nums2. After having these two, we merge them using merge sort algorithm. We use merge sort because it can be proved that largest number will always be sorted in descending order. The only thing to keep in mind while merging is the case where array elements are equal. In that case, we have to loop untill we find a greater element in one of the two arrays and then act accordingly.\\n            So after finding a i digit number from nums1 and k-i digit number from nums2, we merge them to form the maximum k digit number from these two arrays.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector <int>res;\\n\\n        for(int i = 0; i<=k; i++){\\n            vector <int> a = fun(nums1, i);\\n            vector <int> b = fun(nums2, k-i);\\n\\n            vector <int> m;\\n            merge(a, b, m);\\n\\n            if(m.size()==k) res = max(res,m);\\n        }\\n        return res;\\n    }\\nprotected:\\n    // This function is the code of \"Find most consecutive subsequence\" problem, which finds the k digit maximum number possible\\n    vector <int> fun(vector <int>&nums, int k){\\n        if(k>nums.size()) return {};\\n        vector <int> res;\\n        stack <int> st;\\n        int rem = k, n = nums.size();\\n        for(int i = 0; i<n; i++){\\n            if(st.empty()) st.push(nums[i]), rem--;\\n            else{\\n                int avail = n-i;\\n                while(!st.empty() and st.top()<nums[i] and rem<k and avail>rem) st.pop(), rem++;\\n                st.push(nums[i]), rem--;\\n            }\\n        }\\n        while(st.size()>k) st.pop();\\n        while(!st.empty()) res.push_back(st.top()), st.pop();\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    void merge(vector <int>&a, vector <int>&b, vector <int>&res){\\n        int i = 0, j = 0, k = 0;\\n        // This is the only case which we need to take care of. Here, we loop until we find a number greater than another number\\n        // in other array. When we do that, we push the element in result array accordingly. Note that i am not using the pointer\\n        // i and j to loop, instead i have creater a temporary pointers which finds the position where elements are different.\\n        while(i<a.size() and j<b.size()){\\n            if(a[i]==b[j]){\\n                int ti = i, tj = j;\\n                while(ti<a.size() and tj<b.size() and a[ti]==b[tj]) ti++, tj++;\\n\\n                if(tj==b.size()) res.push_back(a[i]), i++;\\n                else\\n                if(ti<a.size() and a[ti]>b[tj]) res.push_back(a[i]), i++;\\n                else res.push_back(b[j]), j++;\\n            }\\n            else\\n            if(a[i]>b[j]) res.push_back(a[i]), i++;\\n            else res.push_back(b[j]), j++;\\n        }\\n        while(i<a.size()) res.push_back(a[i]), i++;\\n        while(j<b.size()) res.push_back(b[j]), j++;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector <int>res;\\n\\n        for(int i = 0; i<=k; i++){\\n            vector <int> a = fun(nums1, i);\\n            vector <int> b = fun(nums2, k-i);\\n\\n            vector <int> m;\\n            merge(a, b, m);\\n\\n            if(m.size()==k) res = max(res,m);\\n        }\\n        return res;\\n    }\\nprotected:\\n    // This function is the code of \"Find most consecutive subsequence\" problem, which finds the k digit maximum number possible\\n    vector <int> fun(vector <int>&nums, int k){\\n        if(k>nums.size()) return {};\\n        vector <int> res;\\n        stack <int> st;\\n        int rem = k, n = nums.size();\\n        for(int i = 0; i<n; i++){\\n            if(st.empty()) st.push(nums[i]), rem--;\\n            else{\\n                int avail = n-i;\\n                while(!st.empty() and st.top()<nums[i] and rem<k and avail>rem) st.pop(), rem++;\\n                st.push(nums[i]), rem--;\\n            }\\n        }\\n        while(st.size()>k) st.pop();\\n        while(!st.empty()) res.push_back(st.top()), st.pop();\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    void merge(vector <int>&a, vector <int>&b, vector <int>&res){\\n        int i = 0, j = 0, k = 0;\\n        // This is the only case which we need to take care of. Here, we loop until we find a number greater than another number\\n        // in other array. When we do that, we push the element in result array accordingly. Note that i am not using the pointer\\n        // i and j to loop, instead i have creater a temporary pointers which finds the position where elements are different.\\n        while(i<a.size() and j<b.size()){\\n            if(a[i]==b[j]){\\n                int ti = i, tj = j;\\n                while(ti<a.size() and tj<b.size() and a[ti]==b[tj]) ti++, tj++;\\n\\n                if(tj==b.size()) res.push_back(a[i]), i++;\\n                else\\n                if(ti<a.size() and a[ti]>b[tj]) res.push_back(a[i]), i++;\\n                else res.push_back(b[j]), j++;\\n            }\\n            else\\n            if(a[i]>b[j]) res.push_back(a[i]), i++;\\n            else res.push_back(b[j]), j++;\\n        }\\n        while(i<a.size()) res.push_back(a[i]), i++;\\n        while(j<b.size()) res.push_back(b[j]), j++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77294,
                "title": "an-accepted-python-solution",
                "content": "This problem could be divided into 2 sub-problems:\\n\\n1. **function getMax(nums, t):**\\n\\n  get t numbers from list *nums* to form one single maximized sub-list, with relative orders preserved\\n\\n2. **function merge(nums1, nums2):**\\n\\n  merge *nums1* and *nums2* to form one single maximized list, with relative orders preserved\\n\\nThe final result could be solved by enumerate the length of sub-list *nums1* and *nums2*, and record the max merged list.\\n\\nPython Code:\\n\\n    class Solution(object):\\n        def maxNumber(self, nums1, nums2, k):\\n            \"\"\"\\n            :type nums1: List[int]\\n            :type nums2: List[int]\\n            :type k: int\\n            :rtype: List[int]\\n            \"\"\"\\n            def getMax(nums, t):\\n                ans = []\\n                size = len(nums)\\n                for x in range(size):\\n                    while ans and len(ans) + size - x > t and ans[-1] < nums[x]:\\n                        ans.pop()\\n                    if len(ans) < t:\\n                        ans += nums[x],\\n                return ans\\n    \\n            def merge(nums1, nums2):\\n                ans = []\\n                while nums1 or nums2:\\n                    if nums1 > nums2:\\n                        ans += nums1[0],\\n                        nums1 = nums1[1:]\\n                    else:\\n                        ans += nums2[0],\\n                        nums2 = nums2[1:]\\n                return ans\\n            \\n            len1, len2 = len(nums1), len(nums2)\\n            res = []\\n            for x in range(max(0, k - len2), min(k, len1) + 1):\\n                tmp = merge(getMax(nums1, x), getMax(nums2, k - x))\\n                res = max(tmp, res)\\n            return res\\n\\nRef: [http://bookshadow.com/weblog/2015/12/24/leetcode-create-maximum-number/][1]\\n\\n\\n  [1]: http://bookshadow.com/weblog/2015/12/24/leetcode-create-maximum-number/",
                "solutionTags": [
                    "Python"
                ],
                "code": "This problem could be divided into 2 sub-problems:\\n\\n1. **function getMax(nums, t):**\\n\\n  get t numbers from list *nums* to form one single maximized sub-list, with relative orders preserved\\n\\n2. **function merge(nums1, nums2):**\\n\\n  merge *nums1* and *nums2* to form one single maximized list, with relative orders preserved\\n\\nThe final result could be solved by enumerate the length of sub-list *nums1* and *nums2*, and record the max merged list.\\n\\nPython Code:\\n\\n    class Solution(object):\\n        def maxNumber(self, nums1, nums2, k):\\n            \"\"\"\\n            :type nums1: List[int]\\n            :type nums2: List[int]\\n            :type k: int\\n            :rtype: List[int]\\n            \"\"\"\\n            def getMax(nums, t):\\n                ans = []\\n                size = len(nums)\\n                for x in range(size):\\n                    while ans and len(ans) + size - x > t and ans[-1] < nums[x]:\\n                        ans.pop()\\n                    if len(ans) < t:\\n                        ans += nums[x],\\n                return ans\\n    \\n            def merge(nums1, nums2):\\n                ans = []\\n                while nums1 or nums2:\\n                    if nums1 > nums2:\\n                        ans += nums1[0],\\n                        nums1 = nums1[1:]\\n                    else:\\n                        ans += nums2[0],\\n                        nums2 = nums2[1:]\\n                return ans\\n            \\n            len1, len2 = len(nums1), len(nums2)\\n            res = []\\n            for x in range(max(0, k - len2), min(k, len1) + 1):\\n                tmp = merge(getMax(nums1, x), getMax(nums2, k - x))\\n                res = max(tmp, res)\\n            return res\\n\\nRef: [http://bookshadow.com/weblog/2015/12/24/leetcode-create-maximum-number/][1]\\n\\n\\n  [1]: http://bookshadow.com/weblog/2015/12/24/leetcode-create-maximum-number/",
                "codeTag": "Java"
            },
            {
                "id": 77310,
                "title": "strictly-o-nk-c-solution-with-detailed-explanation",
                "content": "\\n\\tclass list1\\n    {\\n        vector<int> a;\\n        vector<vector<int>> f;\\n    public:\\n        list1() = delete;\\n        inline int size() {return a.size();}\\n        inline int next(int x,int d) {return f[x][d];}\\n        list1(vector<int>& a0)\\n        {\\n            a = a0;\\n            f = vector<vector<int>>(a0.size() + 1,vector<int>(10,INT_MAX));\\n            for (int i = 0;i<a0.size();i++)\\n            {\\n                f[i][a[i]] = i;\\n                for (int j = i-1;j>=0;j--)\\n                {\\n                    if (a[j] == a[i]) break;\\n                    f[j][a[i]] = i;\\n                }\\n            }\\n        }\\n    };\\n    \\n    //dmd for detect_max_digit\\n    // dmd(a,x,rem) -> (max_digit, pos) , where a[pos-1] == max_digit\\n    // list a , from x, need rem numbers, x not included.\\n        \\n    pair<int,int> dmd(list1& a,int x,int rem)\\n    {\\n        for (int d = 9;d >= 0;d--)\\n        {\\n            int pos = a.next(x,d);\\n            if (pos == INT_MAX) continue;\\n            if (a.size() - (pos + 1) >= rem)\\n            return make_pair(d,pos + 1);\\n        }\\n    }\\n    \\n    \\n    class Solution {\\n    public:\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            list1 a1 = list1(nums1);\\n            int N1 = nums1.size();\\n            list1 a2 = list1(nums2);\\n            int N2 = nums2.size();\\n            \\n            auto ret = vector<int>(k,0);\\n            auto f = vector<int>(N1 + 1,0); \\n            //f[i] denote a1[0..i-1] need a2[0..f[i]-1] to reach the current maximal number, and can expand to length k\\n            // in other words, the state is : the number is current maximal and can be expanded, list1 begin with a1[i] and list2 with a2[f[i]] \\n            for (int d = 1;d <= k;d++)\\n            {\\n                int maxDigit = -1;\\n                auto tmpf = vector<int>(N1 + 1,INT_MAX);\\n                for (int x = 0;x<=N1;x++)\\n                {\\n                    int y = f[x];\\n                    if (y == INT_MAX) continue;\\n                    auto m1 = dmd(a1,x,k-d-(N2-y)); \\n                    auto m2 = dmd(a2,y,k-d-(N1-x));\\n                    maxDigit = max(maxDigit,m1.first);\\n                    maxDigit = max(maxDigit,m2.first);\\n                }\\n                ret[d-1] = maxDigit;\\n                for (int x = 0;x<=N1;x++)\\n                {\\n                    int y = f[x];\\n                    if (y == INT_MAX) continue;\\n                    auto m1 = dmd(a1,x,k-d-(N2-y));\\n                    if (m1.first == maxDigit)\\n                    tmpf[m1.second] = min(tmpf[m1.second],y);\\n                    auto m2 = dmd(a2,y,k-d-(N1-x));\\n                    if (m2.first == maxDigit)\\n                    tmpf[x] = min(tmpf[x],m2.second);\\n                }\\n                f = tmpf;\\n            }\\n            return ret;\\n        }\\n    };\\n\\nAny Question is welcome and will be answered as soon as possible.\\nDetailed explanation is coming soon!\\nYou may firstly read my code, it\\'s quite easy to understand.\\n\\n## Detailed Solution ##\\nLet a1,a2 be the two list from where we construct the maximal number.\\nLet N1,N2 denote the size of a1,a2.\\nWe construct the maximal number digit by digit.\\n\\nSuppose we are constructing the d-th digit(ret[0..d-1] is done)  and we have a set of states S = {(a1,b1),(a2,b2),...(a_N,b_N)},For each state (x,y) in S, it means we use a1[0..(x-1)] and a2[0..(y-1)] to construct ret[0..d-1] and a1[x..N1] and a2[y..N2] are avaliabe to construct the remaining digits.\\n\\nIn the iteration, we need to construct the d-th digit as well as the set S\\', that is from where we can construct the d+1-th digit.\\n\\nFor every state (x,y) in S, we use the function \"dmd\" to obtain the biggest d-th digit we can get from it. \\nLet maxdigit = {max(dmd(x,y)[1])|(x,y) in S}, it is the d-th digit.\\n\\nAs we now the d-th digit,\\nWe scan S again,\\nFor every state (x,y) in S, we use the function \"dmd\" to obtain the (x\\',y) and (x,y\\') it extands to, \\nif a1[x\\'-1] == maxdigit, we add (x\\',y) to S\\'.\\nif a2[y\\'-1] == maxdigit, we add (x,y\\') to S\\'.\\n\\nNow we can construct the d+1-th digit from S\\', note that the size of S\\' is at most N1, for(x,y1) and (x,y2), y1 < y2, (x,y2) is needless to be recorded.\\n\\nFinally I\\'d like to use an typical example to illustrate the process.\\n\\n> a1 = [8,1] a2 = [8,9] k = 4\\n> \\n> S = {(0,0)}\\n\\nthe first digit is 8,\\n\\n> S\\' = {(0,1),(1,0)}\\n\\nthe second digit is 9, we construct it from (0,1)\\n\\n>S\\'\\' = {(0,2)}\\n\\nthe remain digits are 8 and 1,\\nwe finally reach 8981.\\n\\nNow I use python and write a piece of much shorter and more readable code as follows:\\n\\n ```\\nclass Solution:\\n    \\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        \\n        def calcnext(a):\\n            ret = [[-1] * 10 for i in range(len(a) + 1)]\\n            for i in reversed(range(len(a))):\\n                for d in range(0, 10):\\n                    ret[i][d] = i if a[i] == d else ret[i + 1][d]\\n            return ret\\n        \\n        M, N = len(nums1), len(nums2)\\n        next1 = calcnext(nums1)\\n        next2 = calcnext(nums2)\\n        ret = []\\n        S = [(0, 0)]\\n        \\n        for i in range(k):\\n            rem = k - i - 1\\n            found, best = False, [N + 1] * (M + 1)\\n            for d in reversed(range(0, 10)):\\n                for (d1, d2) in S:\\n                    n1 = next1[d1][d] + 1\\n                    if n1 and M - n1 + N - d2 >= rem:\\n                        found, best[n1] = True, min(best[n1], d2)\\n                    n2 = next2[d2][d] + 1\\n                    if n2 and M - d1 + N - n2 >= rem:\\n                        found, best[d1] = True, min(best[d1], n2)\\n                if found:\\n                    ret += [d]\\n                    break\\n            S = [(i, best[i]) for i, x in enumerate(best) if best[i] <= N]\\n\\n        return ret\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            list1 a1 = list1(nums1);\\n            int N1 = nums1.size();\\n            list1 a2 = list1(nums2);\\n            int N2 = nums2.size();\\n            \\n            auto ret = vector<int>(k,0);\\n            auto f = vector<int>(N1 + 1,0); \\n            //f[i] denote a1[0..i-1] need a2[0..f[i]-1] to reach the current maximal number, and can expand to length k\\n            // in other words, the state is : the number is current maximal and can be expanded, list1 begin with a1[i] and list2 with a2[f[i]] \\n            for (int d = 1;d <= k;d++)\\n            {\\n                int maxDigit = -1;\\n                auto tmpf = vector<int>(N1 + 1,INT_MAX);\\n                for (int x = 0;x<=N1;x++)\\n                {\\n                    int y = f[x];\\n                    if (y == INT_MAX) continue;\\n                    auto m1 = dmd(a1,x,k-d-(N2-y)); \\n                    auto m2 = dmd(a2,y,k-d-(N1-x));\\n                    maxDigit = max(maxDigit,m1.first);\\n                    maxDigit = max(maxDigit,m2.first);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 128242,
                "title": "java-self-explanatory-neat-code",
                "content": "The final result res[] would be merged from res1[] and res2[], such that res1[] is max subsequence of nums1 of length ki, then res2[] is max subsequence of nums2 with length k - ki.\\nTo get max subsequence of length cnt, we use stack.\\nTo do with merging and update final result, we use util method greater().\\n```\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] result = new int[k];\\n        \\n        for (int ki = Math.max(0, k - nums2.length); ki <= Math.min(k, nums1.length); ki++) {\\n            int[] res1 = getMaxSubsequence(nums1, ki); // ki < nums1.length\\n            int[] res2 = getMaxSubsequence(nums2, k - ki); // k - ki < nums2.length\\n            int[] resTmp = new int[k];\\n            int p1 = 0, p2 = 0, pt = 0;\\n            while (p1 < res1.length || p2 < res2.length) {\\n                resTmp[pt++] = isGreater(res1, p1, res2, p2) ? res1[p1++] : res2[p2++];\\n            }\\n            if (!isGreater(result, 0, resTmp, 0)) {\\n                result = resTmp;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int[] getMaxSubsequence(int[] nums, int cnt){\\n        Stack<Integer> stack = new Stack<>();\\n        int remain = cnt;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (!stack.isEmpty() && stack.peek() < nums[i] && nums.length - 1 - i >= remain) {\\n                stack.pop();\\n                remain++;\\n            }\\n            if (remain > 0) {\\n                stack.push(nums[i]);\\n                remain--;\\n            }\\n        }\\n        int[] maxSub = new int[cnt];\\n        int mi = maxSub.length - 1;\\n        while (!stack.isEmpty()) {\\n            maxSub[mi--] = stack.pop();\\n        }\\n        return maxSub;\\n    }\\n    \\n    private boolean isGreater(int[] nums1, int p1, int[] nums2, int p2) {\\n        for (; p1 < nums1.length && p2 < nums2.length; p1++, p2++) {\\n            if (nums1[p1] > nums2[p2]) {\\n                return true;\\n            }\\n            if (nums1[p1] < nums2[p2]) {\\n                return false;\\n            }\\n        }\\n        return p1 != nums1.length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] result = new int[k];\\n        \\n        for (int ki = Math.max(0, k - nums2.length); ki <= Math.min(k, nums1.length); ki++) {\\n            int[] res1 = getMaxSubsequence(nums1, ki); // ki < nums1.length\\n            int[] res2 = getMaxSubsequence(nums2, k - ki); // k - ki < nums2.length\\n            int[] resTmp = new int[k];\\n            int p1 = 0, p2 = 0, pt = 0;\\n            while (p1 < res1.length || p2 < res2.length) {\\n                resTmp[pt++] = isGreater(res1, p1, res2, p2) ? res1[p1++] : res2[p2++];\\n            }\\n            if (!isGreater(result, 0, resTmp, 0)) {\\n                result = resTmp;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int[] getMaxSubsequence(int[] nums, int cnt){\\n        Stack<Integer> stack = new Stack<>();\\n        int remain = cnt;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (!stack.isEmpty() && stack.peek() < nums[i] && nums.length - 1 - i >= remain) {\\n                stack.pop();\\n                remain++;\\n            }\\n            if (remain > 0) {\\n                stack.push(nums[i]);\\n                remain--;\\n            }\\n        }\\n        int[] maxSub = new int[cnt];\\n        int mi = maxSub.length - 1;\\n        while (!stack.isEmpty()) {\\n            maxSub[mi--] = stack.pop();\\n        }\\n        return maxSub;\\n    }\\n    \\n    private boolean isGreater(int[] nums1, int p1, int[] nums2, int p2) {\\n        for (; p1 < nums1.length && p2 < nums2.length; p1++, p2++) {\\n            if (nums1[p1] > nums2[p2]) {\\n                return true;\\n            }\\n            if (nums1[p1] < nums2[p2]) {\\n                return false;\\n            }\\n        }\\n        return p1 != nums1.length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1611691,
                "title": "java-easy-to-understand-monotonic-stack-3-subproblems-same-as-leetcode-16737",
                "content": "# 1673. Find the Most Competitive Subsequence\\n```\\n// TC-o(n)- Monotonously increasing stack\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int n=nums.length;\\n        Stack<Integer> st=new Stack<>();\\n        int[] res=new int[k];\\n        int rem=n-k;\\n        for(int i=0;i<n;i++){\\n            while(!st.isEmpty() && st.peek()>nums[i] && rem>0){\\n                st.pop();\\n                rem--;\\n            }\\n            st.push(nums[i]);\\n            \\n        }\\n        while(rem>0){\\n            st.pop();\\n            rem--;\\n        }\\n        for(int i=k-1;i>=0;i--){\\n            res[i]=st.pop();\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n# 321. Create Maximum Number\\n**3 Subproblems-**\\n1. Find greatest numbers from nums1 and nums2 using the concept from leetcode 1673(monotonously decreasing stack here, that is the only change)\\n2. Merge the two numbers(here they are in the form of arrays) such that it forms the greatest number\\n3. Find the greatest among all the formed numbers.\\nHere greatest means the number which is lexicographically greater.\\n\\n```\\n// using the concept of 1673. Find the Most Competitive Subsequence\\n// prob is we dn t know how many elements we will take from nums1 and nums2\\n// so we will try for all combinations of k and find the max out of them\\n\\nclass Solution {\\n    \\n    // monotonic decreasing stack same as leetcode 1673 , only > changed to < \\n\\tpublic int[] findLexMax(int[] nums, int k) {\\n\\t\\tint n = nums.length;\\n\\t\\tStack<Integer> st = new Stack<>();\\n\\t\\tint[] res = new int[k];\\n        \\n        /* we have to form a k digit number which is lexicographically greatest\\n         that gives some hint that we need to maintain a monotonic decreasing stack\\n         and rem=n-k means we will remove n-k smaller digits from stack\\n         lets say nums=[6,7,4,8,9] and k=3, we have to remove 5-3=2 digits from the stack,\\n         while we try to form monotonic decreasing satck\\n         o our max number will be [8,9]\\n         */\\n\\t\\tint rem = n - k;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\twhile (!st.isEmpty() && st.peek() < nums[i] && rem > 0) {\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\trem--;\\n\\t\\t\\t}\\n\\t\\t\\tst.push(nums[i]);\\n\\n\\t\\t}\\n        \\n        /* if still some elements can be removed, the best option would be to remove the\\n        elements from the top of the stack, as we are mainting a monotonic decreasing satck\\n        so elemets at the top would be smaller\\n        take this example arr-[6,4,2] k=2 ans would be [6,4]\\n        */\\n\\t\\twhile (rem > 0) {\\n\\t\\t\\tst.pop();\\n\\t\\t\\trem--;\\n\\t\\t}\\n\\t\\tfor (int i = k - 1; i >= 0; i--) {\\n\\t\\t\\tres[i] = st.pop();\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n    \\n\\n\\tprivate static boolean findMax(int[] arr1, int[] arr2, int p1,int p2) {\\n\\t\\twhile (p1 < arr1.length && p2 < arr2.length) {\\n\\t\\t\\tif (arr1[p1] < arr2[p2]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else if (arr1[p1] > arr2[p2]) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tp1++;\\n\\t\\t\\t\\tp2++;\\n\\t\\t\\t}\\n\\t\\t}\\n        // when p1 is empty returns true, so that in merge function it picks up values of arr2\\n        // when p1==arr1.length, then returns false,so that we keep pn picking arr2 elements\\n\\t\\treturn p1!=arr1.length; // tricky\\n\\t}\\n\\n    \\n\\t// think of the case [6,0,4] and [6,7], can t do simple logic like merge two sorted arrays\\n    // we need to decide which pointer to move forward based on the rest of the array,\\n    // if both elements are same compare the next element, and then decide\\n\\tprivate int[] merge(int[] nums1, int[] nums2, int k) {\\n\\t\\tint[] res = new int[k];\\n\\t\\tint resIndex = 0;\\n\\t\\tint p1 = 0;\\n\\t\\tint p2 = 0;\\n        \\n\\t\\twhile (resIndex<res.length) {\\n\\t\\t\\tres[resIndex++]=findMax(nums1,nums2,p1,p2)?nums1[p1++]:nums2[p2++];// tricky\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\tpublic int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\t\\tint len1 = nums1.length;\\n\\t\\tint len2 = nums2.length;\\n\\t\\tint[] maxRes = new int[k];\\n\\t\\tfor (int i = 0; i <= k; i++) { \\n\\t\\t\\tint j = k - i;\\n\\t\\t\\tif (i <= len1 && (k - i) <= len2) { // skip invalid cases, imp step!\\n\\t\\t\\t\\tint[] maxLex1 = findLexMax(nums1, i);\\n\\t\\t\\t\\tint[] maxLex2 = findLexMax(nums2, j);\\n\\t\\t\\t\\tint[] res = merge(maxLex1, maxLex2, k);\\n\\t\\t\\t\\tboolean compareRes = findMax(res, maxRes,0,0);\\n\\t\\t\\t\\tif (compareRes) {\\n\\t\\t\\t\\t\\tmaxRes = res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn maxRes;\\n\\t}\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\n// TC-o(n)- Monotonously increasing stack\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int n=nums.length;\\n        Stack<Integer> st=new Stack<>();\\n        int[] res=new int[k];\\n        int rem=n-k;\\n        for(int i=0;i<n;i++){\\n            while(!st.isEmpty() && st.peek()>nums[i] && rem>0){\\n                st.pop();\\n                rem--;\\n            }\\n            st.push(nums[i]);\\n            \\n        }\\n        while(rem>0){\\n            st.pop();\\n            rem--;\\n        }\\n        for(int i=k-1;i>=0;i--){\\n            res[i]=st.pop();\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\n// using the concept of 1673. Find the Most Competitive Subsequence\\n// prob is we dn t know how many elements we will take from nums1 and nums2\\n// so we will try for all combinations of k and find the max out of them\\n\\nclass Solution {\\n    \\n    // monotonic decreasing stack same as leetcode 1673 , only > changed to < \\n\\tpublic int[] findLexMax(int[] nums, int k) {\\n\\t\\tint n = nums.length;\\n\\t\\tStack<Integer> st = new Stack<>();\\n\\t\\tint[] res = new int[k];\\n        \\n        /* we have to form a k digit number which is lexicographically greatest\\n         that gives some hint that we need to maintain a monotonic decreasing stack\\n         and rem=n-k means we will remove n-k smaller digits from stack\\n         lets say nums=[6,7,4,8,9] and k=3, we have to remove 5-3=2 digits from the stack,\\n         while we try to form monotonic decreasing satck\\n         o our max number will be [8,9]\\n         */\\n\\t\\tint rem = n - k;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\twhile (!st.isEmpty() && st.peek() < nums[i] && rem > 0) {\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\trem--;\\n\\t\\t\\t}\\n\\t\\t\\tst.push(nums[i]);\\n\\n\\t\\t}\\n        \\n        /* if still some elements can be removed, the best option would be to remove the\\n        elements from the top of the stack, as we are mainting a monotonic decreasing satck\\n        so elemets at the top would be smaller\\n        take this example arr-[6,4,2] k=2 ans would be [6,4]\\n        */\\n\\t\\twhile (rem > 0) {\\n\\t\\t\\tst.pop();\\n\\t\\t\\trem--;\\n\\t\\t}\\n\\t\\tfor (int i = k - 1; i >= 0; i--) {\\n\\t\\t\\tres[i] = st.pop();\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n    \\n\\n\\tprivate static boolean findMax(int[] arr1, int[] arr2, int p1,int p2) {\\n\\t\\twhile (p1 < arr1.length && p2 < arr2.length) {\\n\\t\\t\\tif (arr1[p1] < arr2[p2]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else if (arr1[p1] > arr2[p2]) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tp1++;\\n\\t\\t\\t\\tp2++;\\n\\t\\t\\t}\\n\\t\\t}\\n        // when p1 is empty returns true, so that in merge function it picks up values of arr2\\n        // when p1==arr1.length, then returns false,so that we keep pn picking arr2 elements\\n\\t\\treturn p1!=arr1.length; // tricky\\n\\t}\\n\\n    \\n\\t// think of the case [6,0,4] and [6,7], can t do simple logic like merge two sorted arrays\\n    // we need to decide which pointer to move forward based on the rest of the array,\\n    // if both elements are same compare the next element, and then decide\\n\\tprivate int[] merge(int[] nums1, int[] nums2, int k) {\\n\\t\\tint[] res = new int[k];\\n\\t\\tint resIndex = 0;\\n\\t\\tint p1 = 0;\\n\\t\\tint p2 = 0;\\n        \\n\\t\\twhile (resIndex<res.length) {\\n\\t\\t\\tres[resIndex++]=findMax(nums1,nums2,p1,p2)?nums1[p1++]:nums2[p2++];// tricky\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\tpublic int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\t\\tint len1 = nums1.length;\\n\\t\\tint len2 = nums2.length;\\n\\t\\tint[] maxRes = new int[k];\\n\\t\\tfor (int i = 0; i <= k; i++) { \\n\\t\\t\\tint j = k - i;\\n\\t\\t\\tif (i <= len1 && (k - i) <= len2) { // skip invalid cases, imp step!\\n\\t\\t\\t\\tint[] maxLex1 = findLexMax(nums1, i);\\n\\t\\t\\t\\tint[] maxLex2 = findLexMax(nums2, j);\\n\\t\\t\\t\\tint[] res = merge(maxLex1, maxLex2, k);\\n\\t\\t\\t\\tboolean compareRes = findMax(res, maxRes,0,0);\\n\\t\\t\\t\\tif (compareRes) {\\n\\t\\t\\t\\t\\tmaxRes = res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn maxRes;\\n\\t}\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592042,
                "title": "easy-understanding-and-readable-code-monotonic-stack-c",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI will find lexographically greatest subsequence from both array and then merge them.\\nBut constraint is length=k must be satisfied. So have to find lexographically greater subsequence such that both combinedly have length k.\\n\\nBut how to decide how much length have to take from first array and how much from second array? --> This time go by bruteforce. So for possible {i, k-i} pair of length , we will find our answer.\\n\\nlet\\'s divide the problem into subparts:\\nsubpart-1: find out lexographically greatest subsequence from both array.\\nsubpart-2: Merge them and keep taking maximum.\\n\\nImplemented stack logic through array. You can go through stack .\\n# Complexity\\n- Time complexity:O(K*N + K*N)= O(K*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(K) => for this loop: for(int i=0;i<=k;i++) in maxNumber function.\\nO(N) => for getGrtrSubseq function.\\nO(K*N) => merge Function.\\n- Space complexity: O(N) as all are linear vectors.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Function to calculate maximum number from nums of  requiredLength.\\n    vector<int> getGrtrSubseq(vector<int> nums, int requiredLength)\\n    {\\n        vector<int> ans; // Store the resultant maximum\\n        int n = nums.size();\\n        // i will try to maximize initial digit as much as i can. If falling for shorter length, then i am forced to take last requiredLength-ans.size()\\n        //elements left. So, before popping any element check ((requiredLength-ans.size())<(n-i)) to ensure you have requiredLength of digits.\\n        for(int i=0;i<n;i++)\\n        {\\n            while(ans.size()>0 && ans.back()<nums[i] && ((requiredLength-ans.size())<(n-i))) // If true, then pop out the last element\\n            ans.pop_back();\\n            if(ans.size()<requiredLength)ans.push_back(nums[i]); \\n        }\\n        return ans;\\n    }\\n    void pop_front(std::vector<int> &v)\\n    {\\n        if (v.size() > 0)v.erase(v.begin());\\n    }\\n    vector<int> merge(vector<int> p1, vector<int>p2, int k)\\n    {\\n        vector<int> temp;\\n        for(int j=0;j<k;j++)\\n        { \\n            vector<int> temp2 = max(p1,p2);\\n            int fr = temp2.front();\\n            if(p1>p2)\\n            pop_front(p1);\\n            else\\n            pop_front(p2);\\n            temp.push_back(fr);\\n        }\\n      return temp;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n1=nums1.size(), n2=nums2.size();\\n        vector<int>res;\\n        for(int i=0;i<=k;i++)\\n        {\\n            if(i>n1 || k-i>n2) continue;\\n            vector<int>grtrSubseq1=getGrtrSubseq(nums1,i);; \\n            vector<int>grtrSubseq2=getGrtrSubseq(nums2,k-i); \\n            vector<int>temp=merge(grtrSubseq1,grtrSubseq2,k);      \\n            res = max(res, temp);\\n        }\\n        return res;\\n    }\\n};\\n```\\n.![download (2).jpg](https://assets.leetcode.com/users/images/8eac6c0a-55fa-4b53-abd4-45a92c342e39_1685777059.4901643.jpeg)\\n\\nCorrect me if i am wrong.\\n",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to calculate maximum number from nums of  requiredLength.\\n    vector<int> getGrtrSubseq(vector<int> nums, int requiredLength)\\n    {\\n        vector<int> ans; // Store the resultant maximum\\n        int n = nums.size();\\n        // i will try to maximize initial digit as much as i can. If falling for shorter length, then i am forced to take last requiredLength-ans.size()\\n        //elements left. So, before popping any element check ((requiredLength-ans.size())<(n-i)) to ensure you have requiredLength of digits.\\n        for(int i=0;i<n;i++)\\n        {\\n            while(ans.size()>0 && ans.back()<nums[i] && ((requiredLength-ans.size())<(n-i))) // If true, then pop out the last element\\n            ans.pop_back();\\n            if(ans.size()<requiredLength)ans.push_back(nums[i]); \\n        }\\n        return ans;\\n    }\\n    void pop_front(std::vector<int> &v)\\n    {\\n        if (v.size() > 0)v.erase(v.begin());\\n    }\\n    vector<int> merge(vector<int> p1, vector<int>p2, int k)\\n    {\\n        vector<int> temp;\\n        for(int j=0;j<k;j++)\\n        { \\n            vector<int> temp2 = max(p1,p2);\\n            int fr = temp2.front();\\n            if(p1>p2)\\n            pop_front(p1);\\n            else\\n            pop_front(p2);\\n            temp.push_back(fr);\\n        }\\n      return temp;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n1=nums1.size(), n2=nums2.size();\\n        vector<int>res;\\n        for(int i=0;i<=k;i++)\\n        {\\n            if(i>n1 || k-i>n2) continue;\\n            vector<int>grtrSubseq1=getGrtrSubseq(nums1,i);; \\n            vector<int>grtrSubseq2=getGrtrSubseq(nums2,k-i); \\n            vector<int>temp=merge(grtrSubseq1,grtrSubseq2,k);      \\n            res = max(res, temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027086,
                "title": "python-solution-greedy-search-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:        \\n        def merge(n1, n2):\\n            res = []\\n            while (n1 or n2) :\\n                if n1>n2:\\n                    res.append(n1[0])\\n                    n1 = n1[1:]\\n                else:\\n                    res.append(n2[0])\\n                    n2 = n2[1:]\\n            return res\\n        \\n        def findmax(nums, length):\\n            l = []\\n            maxpop = len(nums)-length\\n            for i in range(len(nums)):\\n                while maxpop>0 and len(l) and nums[i]>l[-1]:\\n                    l.pop()\\n                    maxpop -= 1\\n                l.append(nums[i])\\n            return l[:length]\\n        \\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n        res = [0]*k\\n        for i in range(k+1):\\n            j = k-i\\n            if i>n1 or j>n2:    continue\\n            l1 = findmax(nums1, i)\\n            l2 = findmax(nums2, j)\\n            res = max(res, merge(l1,l2))\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:        \\n        def merge(n1, n2):\\n            res = []\\n            while (n1 or n2) :\\n                if n1>n2:\\n                    res.append(n1[0])\\n                    n1 = n1[1:]\\n                else:\\n                    res.append(n2[0])\\n                    n2 = n2[1:]\\n            return res\\n        \\n        def findmax(nums, length):\\n            l = []\\n            maxpop = len(nums)-length\\n            for i in range(len(nums)):\\n                while maxpop>0 and len(l) and nums[i]>l[-1]:\\n                    l.pop()\\n                    maxpop -= 1\\n                l.append(nums[i])\\n            return l[:length]\\n        \\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n        res = [0]*k\\n        for i in range(k+1):\\n            j = k-i\\n            if i>n1 or j>n2:    continue\\n            l1 = findmax(nums1, i)\\n            l2 = findmax(nums2, j)\\n            res = max(res, merge(l1,l2))\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 620783,
                "title": "java-simple-code-dp",
                "content": "`dp[i][j][k]` is denoted as the maximum string that takes `a` numbers from first `i` numbers from `A`, and `b` numbers from first `j` numbers from `B` to create `a+b = k` numbers.\\n\\nedge case:\\nif `(i+j < k)` then `dp[i][j][k] = empty`\\nif `i = 0` or `j = 0`, the issue turns into `1 array`\\nif `k = 0` then `dp[i][j][0] = empty`\\n\\n```\\n    public int[] maxNumber(int[] A, int[] B, int k) {\\n        int m = A.length, n = B.length;\\n        if (m+n < k) return new int[0];\\n\\n        String[][][] dp = new String[m+1][n+1][k+1];\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                for (int l = 0; l <= k; l++) {\\n                    if (i+j < l) dp[i][j][l] = \"\";\\n                    else {\\n                        String chooseAi = (i == 0 || l == 0) ? \"\" : dp[i-1][j][l-1] + A[i-1];\\n                        String chooseBj = (j == 0 || l == 0) ? \"\" : dp[i][j-1][l-1] + B[j-1];\\n                        String maxChoose = max(chooseAi, chooseBj);\\n\\n                        String ignoreAi = (i == 0) ? \"\" : dp[i-1][j][l];\\n                        String ignoreBj = (j == 0) ? \"\" : dp[i][j-1][l];\\n                        String ignoreBoth = (i == 0 || j == 0) ? \"\" : dp[i-1][j-1][l];\\n                        String maxIgnore = max(max(ignoreAi, ignoreBj), ignoreBoth);\\n\\n                        dp[i][j][l] = max(maxChoose, maxIgnore);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return convert(dp[m][n][k]);\\n    }\\n\\n    private String max(String s1, String s2) {\\n        return (s1.compareTo(s2) < 0) ? s2 : s1;\\n    }\\n\\n    private int[] convert(String s)  {\\n        int n = s.length(), res[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            res[i] = s.charAt(i)-\\'0\\';\\n        }\\n        return res;\\n    }\\n```\\n\\nTime complexity `O(mnk)`, Space complexity `O(mnk)`.\\nthough `MLE`, but space complexity can be improved to `O(mn)` (good practice).",
                "solutionTags": [],
                "code": "```\\n    public int[] maxNumber(int[] A, int[] B, int k) {\\n        int m = A.length, n = B.length;\\n        if (m+n < k) return new int[0];\\n\\n        String[][][] dp = new String[m+1][n+1][k+1];\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                for (int l = 0; l <= k; l++) {\\n                    if (i+j < l) dp[i][j][l] = \"\";\\n                    else {\\n                        String chooseAi = (i == 0 || l == 0) ? \"\" : dp[i-1][j][l-1] + A[i-1];\\n                        String chooseBj = (j == 0 || l == 0) ? \"\" : dp[i][j-1][l-1] + B[j-1];\\n                        String maxChoose = max(chooseAi, chooseBj);\\n\\n                        String ignoreAi = (i == 0) ? \"\" : dp[i-1][j][l];\\n                        String ignoreBj = (j == 0) ? \"\" : dp[i][j-1][l];\\n                        String ignoreBoth = (i == 0 || j == 0) ? \"\" : dp[i-1][j-1][l];\\n                        String maxIgnore = max(max(ignoreAi, ignoreBj), ignoreBoth);\\n\\n                        dp[i][j][l] = max(maxChoose, maxIgnore);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return convert(dp[m][n][k]);\\n    }\\n\\n    private String max(String s1, String s2) {\\n        return (s1.compareTo(s2) < 0) ? s2 : s1;\\n    }\\n\\n    private int[] convert(String s)  {\\n        int n = s.length(), res[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            res[i] = s.charAt(i)-\\'0\\';\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330015,
                "title": "greedy-solution-time-complexity-o-n-2-space-complexity-o-n-with-comments",
                "content": "Basic idea is to find best answer from nums1 with size `i`  and from `nums2` with size `k-i`. Then we merge the two arrays, the merge function has been optimized to be `O(N)` . Overall Complexity is `O(N^2)`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> answer(k);\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        for(int i = 0; i <= k; i++) {\\n            int j = k - i;\\n            if (i <= n1 && j <= n2) {\\n                vector<int> ans1 = maxSingleNumber(nums1, i); // best of size i - O(n)\\n                vector<int> ans2 = maxSingleNumber(nums2, j); // best of size k - i - O(n)\\n                vector<int> ans = merge(ans1, ans2); // merging both - O(n)\\n               \\n                answer = max(ans, answer); // maximize answer - O(n)\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    vector<int> merge(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans; \\n        \\n        int i = 0;\\n        int j = 0;\\n        int k = 0; \\n\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        // Eventhough there are two nested loops, I believe this is linear as the second loop can only run once per element\\n        while(i<n1 && j<n2) {\\n            if (nums1[i] > nums2[j])\\n                ans.push_back(nums1[i++]);\\n            else if (nums1[i] < nums2[j])\\n                ans.push_back(nums2[j++]);\\n            else { // Both are equal, we need to pick the one that is better in the future\\n                int i1 = i + 1;\\n                int j1 = j + 1;\\n                int larger = 0; \\n                \\n                while(i1<n1 && j1 < n2 && !larger) {\\n                    if(nums1[i1] == nums2[j1]) {\\n                        if (nums1[i1] < nums1[i]) // This number is less than the current stopping position, so we would pick that instead \\n                            break;\\n                        i1++;\\n                        j1++;\\n                    }\\n                    else if (nums1[i1] > nums2[j1]) // nums1 is better to pick \\n                        larger = -1;\\n                    else\\n                        larger = 1;  // nums2 is better to pick \\n                }\\n                \\n                if (i1 == n1)\\n                    larger = 1;\\n                if (j1 == n2)\\n                    larger = -1;\\n                \\n                if (larger == -1)\\n                    ans.push_back(nums1[i++]);\\n                else \\n                    ans.push_back(nums2[j++]);\\n            }\\n        }\\n            \\n        // Push Remaining elements\\n        while(i<n1)\\n            ans.push_back(nums1[i++]);\\n        \\n        while(j<n2)\\n            ans.push_back(nums2[j++]);\\n        \\n        return ans;\\n            \\n                \\n    }\\n    \\n    vector<int> maxSingleNumber(vector<int>& nums1, int k) {\\n        \\n        vector<int> stack; \\n        int n = nums1.size();\\n        for(int i = 0; i < n; i++) {\\n            // Pop elements from the stack if current element is greater than head of the stack\\n            // We can pop only if remaining elements in nums1 + remaining elements in stack \\n            // after popping is greater than or equal to k\\n            while(!stack.empty() && (stack.back() < nums1[i] && (stack.size() -1) + (n-i) >=k ))\\n                stack.pop_back();\\n            \\n            // Push if less than k elements\\n            if (stack.size() < k)\\n                stack.push_back(nums1[i]);\\n        }\\n        return stack;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> answer(k);\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        for(int i = 0; i <= k; i++) {\\n            int j = k - i;\\n            if (i <= n1 && j <= n2) {\\n                vector<int> ans1 = maxSingleNumber(nums1, i); // best of size i - O(n)\\n                vector<int> ans2 = maxSingleNumber(nums2, j); // best of size k - i - O(n)\\n                vector<int> ans = merge(ans1, ans2); // merging both - O(n)\\n               \\n                answer = max(ans, answer); // maximize answer - O(n)\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    vector<int> merge(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans; \\n        \\n        int i = 0;\\n        int j = 0;\\n        int k = 0; \\n\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        // Eventhough there are two nested loops, I believe this is linear as the second loop can only run once per element\\n        while(i<n1 && j<n2) {\\n            if (nums1[i] > nums2[j])\\n                ans.push_back(nums1[i++]);\\n            else if (nums1[i] < nums2[j])\\n                ans.push_back(nums2[j++]);\\n            else { // Both are equal, we need to pick the one that is better in the future\\n                int i1 = i + 1;\\n                int j1 = j + 1;\\n                int larger = 0; \\n                \\n                while(i1<n1 && j1 < n2 && !larger) {\\n                    if(nums1[i1] == nums2[j1]) {\\n                        if (nums1[i1] < nums1[i]) // This number is less than the current stopping position, so we would pick that instead \\n                            break;\\n                        i1++;\\n                        j1++;\\n                    }\\n                    else if (nums1[i1] > nums2[j1]) // nums1 is better to pick \\n                        larger = -1;\\n                    else\\n                        larger = 1;  // nums2 is better to pick \\n                }\\n                \\n                if (i1 == n1)\\n                    larger = 1;\\n                if (j1 == n2)\\n                    larger = -1;\\n                \\n                if (larger == -1)\\n                    ans.push_back(nums1[i++]);\\n                else \\n                    ans.push_back(nums2[j++]);\\n            }\\n        }\\n            \\n        // Push Remaining elements\\n        while(i<n1)\\n            ans.push_back(nums1[i++]);\\n        \\n        while(j<n2)\\n            ans.push_back(nums2[j++]);\\n        \\n        return ans;\\n            \\n                \\n    }\\n    \\n    vector<int> maxSingleNumber(vector<int>& nums1, int k) {\\n        \\n        vector<int> stack; \\n        int n = nums1.size();\\n        for(int i = 0; i < n; i++) {\\n            // Pop elements from the stack if current element is greater than head of the stack\\n            // We can pop only if remaining elements in nums1 + remaining elements in stack \\n            // after popping is greater than or equal to k\\n            while(!stack.empty() && (stack.back() < nums1[i] && (stack.size() -1) + (n-i) >=k ))\\n                stack.pop_back();\\n            \\n            // Push if less than k elements\\n            if (stack.size() < k)\\n                stack.push_back(nums1[i]);\\n        }\\n        return stack;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210773,
                "title": "c-fast-and-elegant-new-idea-12ms-100-time-o-k-m-n-space-o-m-n",
                "content": "Iteratively (greedily) find the maximal number of x digits that could potentially be extended to k digits (i.e. there are at least k digits left). To determine whether the number can be extended, it suffices to record the index of the last used digit in both numbers (there can be multiple such pairs of indices leading to the same maximal number), and check that there are at least a total of k-x digits left in both numbers. In the following implementation, the indices following the last used digits are recorded in `list_indices`. (Using set instead of vector or list because it can has at most max(m,n) elements, but with repetition it can blow up to 2^x and TLE.)\\nTo go from step x to x+1, for each pair of indices in `list_indices`, extend the maximum number by one digit chosen from the ranges starting from those indices. Depending on whether the added digit is from the first or the second number, we get two new pairs of indices (stored in `next_list_indices`). We can throw out those pairs whose corresponding added digits are not maximal.\\nIf we index the elements in `list_indices` as (m1,n1), (m2, n2), ... then they can be shown to satisfy m1 > m2 > m3 > ... and n1 < n2 < n3 < ... which shows the size of `list_indices` can be at most max(m,n), so the space complexity is clearly O(m+n). (It helps to plot the indices in a 2D grid.) Further analysis shows that for set insertion we just need to check that the inserted element is not the same as the last inserted element, so we can get rid of a log(m+n) factor for insertion. There are k steps and for each step the total number of indices checked in `getBestIndex` doesn\\'t exceed m+n (e.g. if you extend (m1,n1) by one digit from the first number, you get some (m1\\',n1) with m1\\' <= m2), so the time complexity is O(k(m+n)). With more reasoning you can avoid some of the `getBestIndex` calls under certain conditions, but that doesn\\'t lead to improvement on the asymptotic complexity.\\n\\n```\\nclass Solution {\\npublic:\\n    pair<int,int> getBestIndex(vector<int>& nums, int start, int span) {\\n\\t// get index and maximum\\n        int max_idx = 0;\\n        int max_ = nums[start];\\n        int i = 1;\\n        while (i < span) {\\n            auto val = nums[start+i];\\n            if (val > max_) {\\n                max_idx = i;\\n                max_ = val;\\n                if (max_ == 9) break;\\n            }\\n            i++;\\n        }\\n        return pair<int,int>(max_idx, max_);\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> best_seq;\\n        set<pair<int,int>> list_indices = {{0,0}};\\n        while (k-- > 0) {\\n            set<pair<int,int>> next_list_indices;\\n            int max_ = -1;\\n            for (auto indices : list_indices) {\\n                auto n1 = indices.first;\\n                auto n2 = indices.second;\\n                auto remaining = nums1.size() + nums2.size() - n1 - n2 - k;\\n                int idx1, max1 = -1, idx2, max2 = -1;\\n                auto remaining1 = min(remaining, nums1.size() - n1);\\n                auto remaining2 = min(remaining, nums2.size() - n2);\\n                if (remaining1)\\n                    tie(idx1, max1) = getBestIndex(nums1, n1, remaining1);\\n                if (remaining2)\\n                    tie(idx2, max2) = getBestIndex(nums2, n2, remaining2);\\n                auto max12 = max(max1, max2);\\n                if (max12 < max_) continue;\\n                if (max12 > max_) { max_ = max12; next_list_indices.clear(); }\\n                if (max1 >= max2) next_list_indices.insert({n1+idx1+1, n2});\\n                if (max1 <= max2) next_list_indices.insert({n1, n2+idx2+1});\\n            }\\n            best_seq.emplace_back(max_);\\n            list_indices = move(next_list_indices);\\n        }\\n        return best_seq;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> getBestIndex(vector<int>& nums, int start, int span) {\\n\\t// get index and maximum\\n        int max_idx = 0;\\n        int max_ = nums[start];\\n        int i = 1;\\n        while (i < span) {\\n            auto val = nums[start+i];\\n            if (val > max_) {\\n                max_idx = i;\\n                max_ = val;\\n                if (max_ == 9) break;\\n            }\\n            i++;\\n        }\\n        return pair<int,int>(max_idx, max_);\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> best_seq;\\n        set<pair<int,int>> list_indices = {{0,0}};\\n        while (k-- > 0) {\\n            set<pair<int,int>> next_list_indices;\\n            int max_ = -1;\\n            for (auto indices : list_indices) {\\n                auto n1 = indices.first;\\n                auto n2 = indices.second;\\n                auto remaining = nums1.size() + nums2.size() - n1 - n2 - k;\\n                int idx1, max1 = -1, idx2, max2 = -1;\\n                auto remaining1 = min(remaining, nums1.size() - n1);\\n                auto remaining2 = min(remaining, nums2.size() - n2);\\n                if (remaining1)\\n                    tie(idx1, max1) = getBestIndex(nums1, n1, remaining1);\\n                if (remaining2)\\n                    tie(idx2, max2) = getBestIndex(nums2, n2, remaining2);\\n                auto max12 = max(max1, max2);\\n                if (max12 < max_) continue;\\n                if (max12 > max_) { max_ = max12; next_list_indices.clear(); }\\n                if (max1 >= max2) next_list_indices.insert({n1+idx1+1, n2});\\n                if (max1 <= max2) next_list_indices.insert({n1, n2+idx2+1});\\n            }\\n            best_seq.emplace_back(max_);\\n            list_indices = move(next_list_indices);\\n        }\\n        return best_seq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77300,
                "title": "c-dp-greedy-solution-should-be-easy-to-understand",
                "content": "Here is the idea:\\n                       \\nLet's consider a similar but simple version of this problem: if there is only one array arr of which length is m, how to find the k digits of it to create maximum number preserving the order?\\nSo here comes to my DP solution: DP[ i ][ j ] means that the maximum number that has i digits we can get  when the jth digits is the last one of this number. Thus the formula is as follows:\\n\\n           dp[ i ] [ j ] = max(dp[ i ][ j ], max(dp[ i - 1 ][ 0 ... j - 1 ]))\\n\\nOk. We apply this formula to the two given arrays and then get two DP arrays DP1 and DP2 where DP[ i ] means the largest number with i digits.    \\n\\nBack to our problem: Choose k digits of these two arrays/strings to create the maximum number. Now here is the greedy solution:\\n\\nFor every pair of i and j where i + j == k and i is the number of digits used from array1 and j is the number of digits used from array2, we have to combine to create a new number so that it is the largest of all combinations. Remember a similar greedy problem? The trick here is that we use two pointers for each array and in each iteration, pick up pointers pointing to the larger digit or the larger substring. Then the number created is the largest from the given two arrays/strings.\\n                    \\nStill confused? Plsz read the code below:\\n      \\n    \\n              \\n    class Solution {\\n        public:\\n            vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n                vector<int> ans;\\n                if(!nums1.size() && !nums2.size() || !k)\\n                    return ans;\\n                ans.resize(k);\\n                int n = nums1.size(), m = nums2.size();\\n                vector<string> dp1(min(k, n)), dp2(min(k, m));\\n                vector<string> dpprev1(n), dpcur1(n), dpprev2(m), dpcur2(m);\\n        \\n                for(int i = 0; i < dp1.size(); ++ i){\\n                    string tmpval(i + 1, 0);\\n                    dp1[i] = tmpval;\\n                    if(!i){\\n                        for(int j = 0; j < n; ++ j){\\n                            dpprev1[j] = \"\";\\n                            dpprev1[j] += (char)(nums1[j] + '0');\\n                            dp1[i] = max(dp1[i], dpprev1[j]);\\n                            if(j)\\n                                dpprev1[j] = max(dpprev1[j], dpprev1[j - 1]);\\n        \\n                        }\\n                    }else{\\n                        for(int j = i; j < n; ++ j){\\n                            dpcur1[j] = tmpval;\\n        \\n                            dpcur1[j] = max(dpcur1[j], dpprev1[j - 1] + (char)(nums1[j] + '0'));\\n        \\n                            dp1[i] = max(dp1[i], dpcur1[j]);\\n                            if(j >= i)\\n                                dpcur1[j] = max(dpcur1[j], dpcur1[j - 1]);\\n                        }\\n                        dpprev1 = dpcur1;\\n                    }\\n        \\n                }\\n        \\n        \\n        \\n                for(int i = 0; i < dp2.size(); ++ i){\\n                    string tmpval(i + 1, 0);\\n                    dp2[i] = tmpval;\\n                    if(!i){\\n                        for(int j = 0; j < m; ++ j){\\n                            dpprev2[j] = \"\";\\n                            dpprev2[j] += (char)(nums2[j] + '0');\\n                            dp2[i] = max(dp2[i], dpprev2[j]);\\n                            if(j)\\n                                dpprev2[j] = max(dpprev2[j], dpprev2[j - 1]);\\n                        }\\n                    }else{\\n                        for(int j = i; j < m; ++ j){\\n                            dpcur2[j] = tmpval;\\n        \\n                            dpcur2[j] = max(dpcur2[j], dpprev2[j - 1] + (char)(nums2[j] + '0'));\\n        \\n                            dp2[i] = max(dp2[i], dpcur2[j]);\\n                            if(j >= i)\\n                                dpcur2[j] = max(dpcur2[j], dpcur2[j - 1]);\\n                        }\\n                        dpprev2 = dpcur2;\\n                    }\\n        \\n                }\\n        \\n        \\n                string tmpans(k, 0), v = \"\";\\n        \\n                if(!dp1.size()){\\n                    getAns(v, dp2[k - 1], ans, tmpans);\\n                }else{\\n                    for(int i = 0; i <= min(k, (int)dp1.size()); ++ i){\\n                        if(i == 0){\\n                            if(dp2.size() >= k)\\n                                getAns(v, dp2[k - 1], ans, tmpans);\\n                        }else if(i < k){\\n                            if(dp2.size() >= k - i)\\n                                getAns(dp1[i - 1], dp2[k - i - 1], ans, tmpans);\\n                        }else{\\n                            if(dp1.size() >= k)\\n                                getAns(dp1[k - 1], v, ans, tmpans);\\n                        }\\n                    }\\n        \\n                }\\n        \\n                return ans;\\n            }\\n        \\n        private:\\n            void getAns(string &s1, string &s2, vector<int> &ans, string &tmpans){\\n                string res;\\n                if(!s1.size())\\n                    res = s2;\\n                else if(!s2.size())\\n                    res = s1;\\n                else{\\n                    int id1 = 0, id2 = 0;\\n        \\n                    while(id1 < s1.size() && id2 < s2.size()){\\n                        if(s1[id1] > s2[id2]){\\n                            res += s1[id1 ++];\\n                        }else if(s1[id1] < s2[id2]){\\n                            res += s2[id2 ++];\\n                        }else{\\n                            if(s1.substr(id1) >= s2.substr(id2))\\n                                res += s1[id1 ++];\\n                            else\\n                                res += s2[id2 ++];\\n                        }\\n                    }\\n                    while(id1 < s1.size())\\n                        res += s1[id1 ++];\\n                    while(id2 < s2.size())\\n                        res += s2[id2 ++];\\n                }\\n        \\n                if(res > tmpans){\\n                    tmpans = res;\\n                    for(int i = 0; i < res.size(); ++ i)\\n                        ans[i] = (res[i] - '0');\\n                }\\n            }\\n        };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "class Solution {\\n        public:\\n            vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n                vector<int> ans;\\n                if(!nums1.size() && !nums2.size() || !k)\\n                    return ans;\\n                ans.resize(k);\\n                int n = nums1.size(), m = nums2.size();\\n                vector<string> dp1(min(k, n)), dp2(min(k, m));\\n                vector<string> dpprev1(n), dpcur1(n), dpprev2(m), dpcur2(m);\\n        \\n                for(int i = 0; i < dp1.size(); ++ i){\\n                    string tmpval(i + 1, 0);\\n                    dp1[i] = tmpval;\\n                    if(!i){\\n                        for(int j = 0; j < n; ++ j){\\n                            dpprev1[j] = \"\";\\n                            dpprev1[j] += (char)(nums1[j] + '0');\\n                            dp1[i] = max(dp1[i], dpprev1[j]);\\n                            if(j)\\n                                dpprev1[j] = max(dpprev1[j], dpprev1[j - 1]);\\n        \\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3043133,
                "title": "c-best-and-easiest-solution-monotonic-stack-vector-merging",
                "content": "# Approach\\nTake ans = 0;\\nfor every i from 0 to n-1, do the following : \\n1. Take max number of i digits from nums1 and max number of k-i digits from nums2.\\n2. Merge the above generated numbers to get the maximum number temp of k digits.\\n3. update our ans as ans = max(ans , temp);\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // function to generate maximum number of k digits in the form of vector obtained using elements of array nums.\\n    vector<int> solve(int k , vector<int> &nums){\\n        int n = nums.size();\\n        if(k>n) return {};\\n        vector<int> ans;\\n        int rem = n-k;\\n        ans.push_back(nums[0]);\\n        // monotonic stack\\n        for(int i=1 ; i<n ; i++){\\n            while(!ans.empty() && nums[i]>ans.back() && rem>0){\\n                ans.pop_back();\\n                rem--;\\n            }\\n            ans.push_back(nums[i]);\\n        }\\n        while(rem--){\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n\\n    // function to merge two numbers in the form of vectors (v1 and v2) to get the maximum possible number and store it in another vector temp\\n    void merge(vector<int> &ans , vector<int> &v1 , vector<int> &v2){\\n        int m = v1.size();\\n        int n = v2.size();\\n        int i=0;\\n        int j=0;\\n        \\n        while(i<m && j<n){\\n            // Case1:\\n            // ....5 5 5 5 5 7....     .... 5 5 5 5 5 5...\\n            //     i                        j\\n            //               tempi                     tempj\\n            if(v1[i] == v2[j]){\\n                int tempi= i;\\n                int tempj= j;\\n                while(tempi<m && tempj<n && v1[tempi]==v2[tempj]){\\n                    tempi++;\\n                    tempj++;\\n                }\\n                if(tempj == n){\\n                    ans.push_back(v1[i]);\\n                    i++;\\n                }else if(tempi == m){\\n                    ans.push_back(v2[j]);\\n                    j++;\\n                }else if(v1[tempi]>v2[tempj]){\\n                    ans.push_back(v1[i]);\\n                    i++;\\n                }else{\\n                    ans.push_back(v2[j]);\\n                    j++;\\n                }                \\n            }\\n            // Case2 : ....5 6 7 3 4.....     .....2 3 9 8 7....\\n            //             i                       j\\n            else if(v1[i] > v2[j]){\\n                ans.push_back(v1[i]);\\n                i++;\\n            }\\n            // Case2 : ....2 6 7 3 4.....     .....9 3 9 8 7....\\n            //             i                       j\\n            else{\\n                ans.push_back(v2[j]);\\n                j++;\\n            }\\n        }\\n        // if ......8 9 7   ...3 5 2 8\\n        //          i                j\\n        while(i<m){\\n            ans.push_back(v1[i]);\\n            i++;\\n        }\\n        // if ......8 9 7   ...3 5 2 8\\n        //              i      j\\n        while(j<n){\\n            ans.push_back(v2[j]);\\n            j++;\\n        }\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // We consider every possible case:\\n        // eg.1 Take maximum number of 0 digits from nums1 and maximum number of k digits from nums2 and merge them to get a maximum number of k digits.\\n        // eg2. Take maximum number of 1 digits from nums1 and maximum number of k-1 digits from nums2 and merge them to get a maximum number of k digits.\\n        // eg3. Take maximum number of 2 digits from nums1 and maximum number of k-2 digits from nums2 and merge them to get a maximum number of k digits.\\n        // eg4. Take maximum number of 3 digits from nums1 and maximum number of k-3 digits from nums2 and merge them to get a maximum number of k digits.\\n        // and so on.................\\n        // Then take the maximum among all the above generated numbers as our answer.\\n\\n        vector<int> ans;\\n        for(int i=0 ; i<=k ; i++){\\n            vector<int> temp1 = solve(i , nums1);\\n            vector<int> temp2 = solve(k-i , nums2);\\n            vector<int> temp;\\n            merge(temp , temp1 , temp2);\\n            if(temp.size() == k) ans = max(ans , temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Upvote if you understood the approach and the code!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // function to generate maximum number of k digits in the form of vector obtained using elements of array nums.\\n    vector<int> solve(int k , vector<int> &nums){\\n        int n = nums.size();\\n        if(k>n) return {};\\n        vector<int> ans;\\n        int rem = n-k;\\n        ans.push_back(nums[0]);\\n        // monotonic stack\\n        for(int i=1 ; i<n ; i++){\\n            while(!ans.empty() && nums[i]>ans.back() && rem>0){\\n                ans.pop_back();\\n                rem--;\\n            }\\n            ans.push_back(nums[i]);\\n        }\\n        while(rem--){\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n\\n    // function to merge two numbers in the form of vectors (v1 and v2) to get the maximum possible number and store it in another vector temp\\n    void merge(vector<int> &ans , vector<int> &v1 , vector<int> &v2){\\n        int m = v1.size();\\n        int n = v2.size();\\n        int i=0;\\n        int j=0;\\n        \\n        while(i<m && j<n){\\n            // Case1:\\n            // ....5 5 5 5 5 7....     .... 5 5 5 5 5 5...\\n            //     i                        j\\n            //               tempi                     tempj\\n            if(v1[i] == v2[j]){\\n                int tempi= i;\\n                int tempj= j;\\n                while(tempi<m && tempj<n && v1[tempi]==v2[tempj]){\\n                    tempi++;\\n                    tempj++;\\n                }\\n                if(tempj == n){\\n                    ans.push_back(v1[i]);\\n                    i++;\\n                }else if(tempi == m){\\n                    ans.push_back(v2[j]);\\n                    j++;\\n                }else if(v1[tempi]>v2[tempj]){\\n                    ans.push_back(v1[i]);\\n                    i++;\\n                }else{\\n                    ans.push_back(v2[j]);\\n                    j++;\\n                }                \\n            }\\n            // Case2 : ....5 6 7 3 4.....     .....2 3 9 8 7....\\n            //             i                       j\\n            else if(v1[i] > v2[j]){\\n                ans.push_back(v1[i]);\\n                i++;\\n            }\\n            // Case2 : ....2 6 7 3 4.....     .....9 3 9 8 7....\\n            //             i                       j\\n            else{\\n                ans.push_back(v2[j]);\\n                j++;\\n            }\\n        }\\n        // if ......8 9 7   ...3 5 2 8\\n        //          i                j\\n        while(i<m){\\n            ans.push_back(v1[i]);\\n            i++;\\n        }\\n        // if ......8 9 7   ...3 5 2 8\\n        //              i      j\\n        while(j<n){\\n            ans.push_back(v2[j]);\\n            j++;\\n        }\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // We consider every possible case:\\n        // eg.1 Take maximum number of 0 digits from nums1 and maximum number of k digits from nums2 and merge them to get a maximum number of k digits.\\n        // eg2. Take maximum number of 1 digits from nums1 and maximum number of k-1 digits from nums2 and merge them to get a maximum number of k digits.\\n        // eg3. Take maximum number of 2 digits from nums1 and maximum number of k-2 digits from nums2 and merge them to get a maximum number of k digits.\\n        // eg4. Take maximum number of 3 digits from nums1 and maximum number of k-3 digits from nums2 and merge them to get a maximum number of k digits.\\n        // and so on.................\\n        // Then take the maximum among all the above generated numbers as our answer.\\n\\n        vector<int> ans;\\n        for(int i=0 ; i<=k ; i++){\\n            vector<int> temp1 = solve(i , nums1);\\n            vector<int> temp2 = solve(k-i , nums2);\\n            vector<int> temp;\\n            merge(temp , temp1 , temp2);\\n            if(temp.size() == k) ans = max(ans , temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415185,
                "title": "short-python-code-with-explanation-100-faster",
                "content": "Step1: Create maximum numbers individually from nums1 and nums2. Store \\'j\\' digit max numbers in dictionary. (say dp1 and dp2)  \\nStep2: Combine dp1[i] + dp2[k-i]  to create maximum \\'k\\' digit number\\n\\n```\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        def maximize(nums,length):\\n            dp,i = {length:nums},0\\n            while (length):\\n                while (i+1<length and nums[i]>=nums[i+1]): i+=1\\n                nums,length = nums[:i]+nums[i+1:],length-1\\n                dp[length] = nums\\n                if i>0: i-=1\\n            return dp\\n        m,n,result = len(nums1),len(nums2),[]\\n        dp1,dp2 = maximize(nums1,m),maximize(nums2,n)\\n        for i in range(min(m+1,k+1)):\\n            if k-i not in dp2: continue\\n\\t\\t\\tresult = max(result,[max(dp1[i],dp2[k-i]).pop(0) for _ in range(k)])\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        def maximize(nums,length):\\n            dp,i = {length:nums},0\\n            while (length):\\n                while (i+1<length and nums[i]>=nums[i+1]): i+=1\\n                nums,length = nums[:i]+nums[i+1:],length-1\\n                dp[length] = nums\\n                if i>0: i-=1\\n            return dp\\n        m,n,result = len(nums1),len(nums2),[]\\n        dp1,dp2 = maximize(nums1,m),maximize(nums2,n)\\n        for i in range(min(m+1,k+1)):\\n            if k-i not in dp2: continue\\n\\t\\t\\tresult = max(result,[max(dp1[i],dp2[k-i]).pop(0) for _ in range(k)])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77353,
                "title": "share-c-72ms-with-simple-comments",
                "content": "    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        const int size1 = nums1.size();\\n        const int size2 = nums2.size();\\n        if (size1 + size2 < k) return vector<int>();\\n        vector<int> res(k, 0);\\n        vector<vector<int>> dp1(k+1, vector<int>()), dp2(k+1, vector<int>());\\n        getDp(nums1, k, dp1);\\n        getDp(nums2, k, dp2);\\n        for (int i = 0; i <= min(k, size1); i++) {\\n            int j = k - i;\\n            vector<int> temp_res(k, 0);\\n            myMerge(dp1[i].begin(), dp1[i].end(), dp2[j].begin(), dp2[j].end(), temp_res.begin());\\n            if (j <= size2 && compareVector(temp_res, res)) {\\n                res = temp_res;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    template <class container>\\n    bool compareVector ( container vec1, container vec2)\\n        {\\n          typename container::iterator first1 = vec1.begin(), last1 = vec1.end();\\n          typename container::iterator first2 = vec2.begin(), last2 = vec2.end();\\n          while (first1 != last1 && first2 != last2) {\\n            if (*first1 > *first2)\\n              return true;\\n            else if (*first1 < *first2) return false;\\n            ++first1; ++first2;\\n          }\\n          if (first1 == last1) return false;\\n          else return true;\\n        }\\n        \\n    void getDp(vector<int> nums, int k, vector<vector<int>> &dp) {\\n          while (nums.size() > k) {\\n                int j = 0;\\n                for (; j < nums.size() - 1; ++j) {\\n                    if (nums[j] < nums[j + 1]) {\\n                        nums.erase(nums.begin() + j); \\n                        break;\\n                    }\\n                }\\n                if (j == nums.size() - 1) nums.erase(nums.begin() + j); \\n           }\\n           dp[nums.size()] = nums;\\n           const int size1 = nums.size();\\n           for (int i = k; i > 0; i--) {\\n            if (i >= size1) continue; \\n            else {\\n                dp[i] = dp[i+1];\\n                int j = 0;\\n                const int size_dp = dp[i].size();\\n                for (; j < size_dp - 1; ++j) {\\n                    if (dp[i][j] < dp[i][j + 1]) {\\n                        dp[i].erase(dp[i].begin() + j); \\n                        break;\\n                    }\\n                }\\n                if (j == size_dp - 1) dp[i].erase(dp[i].begin() + j); \\n            }\\n            \\n        }\\n    }\\n    template <class InputIterator1, class InputIterator2, class OutputIterator>\\n    OutputIterator myMerge (InputIterator1 first1, InputIterator1 last1,\\n                        InputIterator2 first2, InputIterator2 last2,\\n                        OutputIterator result)\\n    {\\n      while (true) {\\n        if (first1==last1) return std::copy(first2,last2,result);\\n        if (first2==last2) return std::copy(first1,last1,result);\\n        if (*first2 > *first1) *result++ = *first2++;\\n        else if (*first2 < *first1) *result++ = *first1++;\\n        else { // *first1 == *first2\\n            auto pos1 = first1, pos2 = first2;\\n            while (true) {\\n                int f1 = (++pos1 != last1) ? *(pos1) : INT_MIN;\\n                int f2 = (++pos2 != last2) ? *(pos2) : INT_MIN;\\n                if (f1 > f2) { *result++ = *first1++; break;}\\n                else if (f1 < f2) {*result++ = *first2++; break;}\\n            }\\n        }\\n      }\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        const int size1 = nums1.size();\\n        const int size2 = nums2.size();\\n        if (size1 + size2 < k) return vector<int>();\\n        vector<int> res(k, 0);\\n        vector<vector<int>> dp1(k+1, vector<int>()), dp2(k+1, vector<int>());\\n        getDp(nums1, k, dp1);\\n        getDp(nums2, k, dp2);\\n        for (int i = 0; i <= min(k, size1); i++) {\\n            int j = k - i;\\n            vector<int> temp_res(k, 0);\\n            myMerge(dp1[i].begin(), dp1[i].end(), dp2[j].begin(), dp2[j].end(), temp_res.begin());\\n            if (j <= size2 && compareVector(temp_res, res)) {\\n                res = temp_res;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    template <class container>\\n    bool compareVector ( container vec1, container vec2)\\n        {\\n          typename container::iterator first1 = vec1.begin(), last1 = vec1.end();\\n          typename container::iterator first2 = vec2.begin(), last2 = vec2.end();\\n          while (first1 != last1 && first2 != last2) {\\n            if (*first1 > *first2)\\n              return true;\\n            else if (*first1 < *first2) return false;\\n            ++first1; ++first2;\\n          }\\n          if (first1 == last1) return false;\\n          else return true;\\n        }\\n        \\n    void getDp(vector<int> nums, int k, vector<vector<int>> &dp) {\\n          while (nums.size() > k) {\\n                int j = 0;\\n                for (; j < nums.size() - 1; ++j) {\\n                    if (nums[j] < nums[j + 1]) {\\n                        nums.erase(nums.begin() + j); \\n                        break;\\n                    }\\n                }\\n                if (j == nums.size() - 1) nums.erase(nums.begin() + j); \\n           }\\n           dp[nums.size()] = nums;\\n           const int size1 = nums.size();\\n           for (int i = k; i > 0; i--) {\\n            if (i >= size1) continue; \\n            else {\\n                dp[i] = dp[i+1];\\n                int j = 0;\\n                const int size_dp = dp[i].size();\\n                for (; j < size_dp - 1; ++j) {\\n                    if (dp[i][j] < dp[i][j + 1]) {\\n                        dp[i].erase(dp[i].begin() + j); \\n                        break;\\n                    }\\n                }\\n                if (j == size_dp - 1) dp[i].erase(dp[i].begin() + j); \\n            }\\n            \\n        }\\n    }\\n    template <class InputIterator1, class InputIterator2, class OutputIterator>\\n    OutputIterator myMerge (InputIterator1 first1, InputIterator1 last1,\\n                        InputIterator2 first2, InputIterator2 last2,\\n                        OutputIterator result)\\n    {\\n      while (true) {\\n        if (first1==last1) return std::copy(first2,last2,result);\\n        if (first2==last2) return std::copy(first1,last1,result);\\n        if (*first2 > *first1) *result++ = *first2++;\\n        else if (*first2 < *first1) *result++ = *first1++;\\n        else { // *first1 == *first2\\n            auto pos1 = first1, pos2 = first2;\\n            while (true) {\\n                int f1 = (++pos1 != last1) ? *(pos1) : INT_MIN;\\n                int f2 = (++pos2 != last2) ? *(pos2) : INT_MIN;\\n                if (f1 > f2) { *result++ = *first1++; break;}\\n                else if (f1 < f2) {*result++ = *first2++; break;}\\n            }\\n        }\\n      }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2167532,
                "title": "o-k-m-n-python-solution-with-monotonically-decreasing-stack-commented-for-clarity",
                "content": "This solution is pretty efficient and intuitive.\\nTime complexity is **O(k(n+m))** where n and m is length of each list. \\n\\n\\nTo understand this solution you must also do other problems concerning monotonic stack like LC-402 which are pre-requisites for this problem.\\n\\nDo give me a thumbs up if u like it.\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def maximum_num_each_list(nums: List[int], k_i: int) -> List[int]:\\n            # monotonically decreasing stack\\n            s = []\\n            m = len(nums) - k_i\\n            for n in nums:\\n                while s and s[-1] < n and m > 0:\\n                    s.pop()\\n                    m -= 1\\n                s.append(n)\\n            s = s[:len(s)-m] # very important\\n            return s\\n        def greater(a, b, i , j): # get the number which is lexiographically greater\\n            while i< len(a) or j < len(b): \\n                if i == len(a): return False\\n                if j == len(b): return True\\n                if a[i] > b[j]: return True\\n                if a[i] < b[j]: return False\\n                i += 1 # we increment until each of their elements are same\\n                j += 1\\n        \\n        def merge(x_num, y_num):\\n            n = len(x_num)\\n            m = len(y_num)\\n            i = 0\\n            j = 0\\n            s = []\\n            while i < n or j < m:\\n                a = x_num[i] if i < n else float(\"-inf\") \\n                b = y_num[j] if j < m else float(\"-inf\") \\n\\n                if a > b or greater(x_num, y_num, i , j):\\n# greater(x_num, y_num, i , j): this function is meant for check which list has element lexicographically greater means it will iterate through both arrays incrementing both at the same time until one of them is greater than other.\\n                    chosen = a\\n                    i += 1\\n                else:\\n                    chosen = b\\n                    j += 1\\n                s.append(chosen)\\n            return s\\n\\n        max_num_arr = []\\n        for i in range(k+1): # we check for all values of k and find the maximum number we can create for that value of k and we repeat this for all values of k and then at eacch time merge the numbers to check if arrive at optimal solution\\n            first = maximum_num_each_list(nums1, i)\\n            second = maximum_num_each_list(nums2, k-i)\\n            merged = merge(first, second)\\n            # these two conditions are required because list comparison in python only compares the elements even if one of their lengths is greater, so I had to add these conditions to compare elements only if length is equal.\\n\\t\\t\\t# Alternatively you can avoid this and convert them both to int and then compare, but I wanted to this as  it is somewhat more efficient.\\n            if len(merged) == len(max_num_arr) and  merged > max_num_arr:\\n                max_num_arr = merged\\n            elif len(merged) > len(max_num_arr):\\n                max_num_arr = merged\\n        return max_num_arr\\n\\n```\\nFeel free to ask any questions in the comments.\\nDo suggest improvements if any.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def maximum_num_each_list(nums: List[int], k_i: int) -> List[int]:\\n            # monotonically decreasing stack\\n            s = []\\n            m = len(nums) - k_i\\n            for n in nums:\\n                while s and s[-1] < n and m > 0:\\n                    s.pop()\\n                    m -= 1\\n                s.append(n)\\n            s = s[:len(s)-m] # very important\\n            return s\\n        def greater(a, b, i , j): # get the number which is lexiographically greater\\n            while i< len(a) or j < len(b): \\n                if i == len(a): return False\\n                if j == len(b): return True\\n                if a[i] > b[j]: return True\\n                if a[i] < b[j]: return False\\n                i += 1 # we increment until each of their elements are same\\n                j += 1\\n        \\n        def merge(x_num, y_num):\\n            n = len(x_num)\\n            m = len(y_num)\\n            i = 0\\n            j = 0\\n            s = []\\n            while i < n or j < m:\\n                a = x_num[i] if i < n else float(\"-inf\") \\n                b = y_num[j] if j < m else float(\"-inf\") \\n\\n                if a > b or greater(x_num, y_num, i , j):\\n# greater(x_num, y_num, i , j): this function is meant for check which list has element lexicographically greater means it will iterate through both arrays incrementing both at the same time until one of them is greater than other.\\n                    chosen = a\\n                    i += 1\\n                else:\\n                    chosen = b\\n                    j += 1\\n                s.append(chosen)\\n            return s\\n\\n        max_num_arr = []\\n        for i in range(k+1): # we check for all values of k and find the maximum number we can create for that value of k and we repeat this for all values of k and then at eacch time merge the numbers to check if arrive at optimal solution\\n            first = maximum_num_each_list(nums1, i)\\n            second = maximum_num_each_list(nums2, k-i)\\n            merged = merge(first, second)\\n            # these two conditions are required because list comparison in python only compares the elements even if one of their lengths is greater, so I had to add these conditions to compare elements only if length is equal.\\n\\t\\t\\t# Alternatively you can avoid this and convert them both to int and then compare, but I wanted to this as  it is somewhat more efficient.\\n            if len(merged) == len(max_num_arr) and  merged > max_num_arr:\\n                max_num_arr = merged\\n            elif len(merged) > len(max_num_arr):\\n                max_num_arr = merged\\n        return max_num_arr\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538203,
                "title": "java-segment-tree-3ms-unprecented-100-o-klogn-o-n-for-best-case",
                "content": "Basic idea is pick the maximum from `nums1` and `nums2`, in a way that will ensure enough numbers for later picks. Two points `cur1` and `cur2` is maintained to ensure relative orders of picks.\\n\\nTo make picking a maximum *O(logn)*, segment tree is used, which stores indices and the query function, `reducer`, is max function.\\n\\n```java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        SegmentTreeMax st1 = new SegmentTreeMax(nums1), st2 = new SegmentTreeMax(nums2);\\n        int[] maxN = new int[k];\\n        int cur1 = 0, cur2 = 0, remained = nums1.length + nums2.length - k;\\n        for (int i = 0; i != k; ++i) {\\n            int to1 = remained - cur2 + i,\\n                to2 = remained - cur1 + i;\\n            int picked1 = st1.reduceClosedGuarded(cur1, to1);\\n            int picked2 = st2.reduceClosedGuarded(cur2, to2);\\n            int comparePicked = compareIdx(nums1, picked1, nums2, picked2);\\n            if (comparePicked == 0) {\\n                int p1 = picked1, p2 = picked2;\\n                for (int j = 1; comparePicked == 0; ++j) {\\n                    p1 = st1.reduceClosedGuarded(p1 + 1, to1 + j);\\n                    p2 = st2.reduceClosedGuarded(p2 + 1, to2 + j);\\n                    comparePicked = compareIdx(nums1, p1, nums2, p2);\\n                }\\n                if (p1 == -1 && p2 == -1) {\\n                    comparePicked = 0;\\n                    p1 = picked1; p2 = picked2;\\n                    while (comparePicked == 0) {\\n                        p1 = st1.reduceClosedGuarded(cur1, p1 - 1);\\n                        p2 = st2.reduceClosedGuarded(cur2, p2 - 1);\\n                        comparePicked = -compareIdx(nums1, p1, nums2, p2);\\n                    }\\n                }\\n            }\\n            if (comparePicked == 1) {\\n                maxN[i] = nums1[picked1];\\n                cur1 = picked1 + 1;\\n            }\\n            else {\\n                assert comparePicked == -1;\\n                maxN[i] = nums2[picked2];\\n                cur2 = picked2 + 1;\\n            }\\n        }\\n        return maxN;\\n    }\\n    private int compareIdx(int[] nums1, int i, int[] nums2, int j) {\\n        if (i == -1) return -1;\\n        if (j == -1) return 1;\\n        return Integer.compare(nums1[i], nums2[j]);\\n    }\\n}\\n\\nclass SegmentTreeMax {\\n    private final int[] data;\\n    private final int[] origin;\\n    public SegmentTreeMax(int[] origin) {\\n        data = new int[origin.length << 1];\\n        this.origin = origin;\\n        for (int i = origin.length; i != data.length; ++i) data[i] = i - origin.length;\\n        for (int i = origin.length - 1; i > 0; --i) data[i] = reducer4Build(data[i << 1], data[(i << 1) | 1]);\\n    }\\n    private int reducer4Build(int a, int b) {\\n        return (origin[a] < origin[b]) ? b : a;\\n    }\\n    private int reducer(int a, int b) {\\n        if (a > b) {\\n            a = a ^ b;\\n            b = a ^ b;\\n            a = a ^ b;\\n        }\\n        return (origin[a] < origin[b]) ? b : a;\\n    }\\n    public int reduceClosedGuarded(int from, int to) {\\n        to = Math.min(to, origin.length - 1);\\n        if (from > to) return -1;\\n        int maxima = from;\\n        for (int i = from + origin.length, j = to + origin.length; i <= j; i >>= 1, j >>= 1) {\\n            if ((i & 1) == 1) maxima = reducer(maxima, data[i++]);\\n            if ((j & 1) == 0) maxima = reducer(maxima, data[j--]);\\n        }\\n        return maxima;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        SegmentTreeMax st1 = new SegmentTreeMax(nums1), st2 = new SegmentTreeMax(nums2);\\n        int[] maxN = new int[k];\\n        int cur1 = 0, cur2 = 0, remained = nums1.length + nums2.length - k;\\n        for (int i = 0; i != k; ++i) {\\n            int to1 = remained - cur2 + i,\\n                to2 = remained - cur1 + i;\\n            int picked1 = st1.reduceClosedGuarded(cur1, to1);\\n            int picked2 = st2.reduceClosedGuarded(cur2, to2);\\n            int comparePicked = compareIdx(nums1, picked1, nums2, picked2);\\n            if (comparePicked == 0) {\\n                int p1 = picked1, p2 = picked2;\\n                for (int j = 1; comparePicked == 0; ++j) {\\n                    p1 = st1.reduceClosedGuarded(p1 + 1, to1 + j);\\n                    p2 = st2.reduceClosedGuarded(p2 + 1, to2 + j);\\n                    comparePicked = compareIdx(nums1, p1, nums2, p2);\\n                }\\n                if (p1 == -1 && p2 == -1) {\\n                    comparePicked = 0;\\n                    p1 = picked1; p2 = picked2;\\n                    while (comparePicked == 0) {\\n                        p1 = st1.reduceClosedGuarded(cur1, p1 - 1);\\n                        p2 = st2.reduceClosedGuarded(cur2, p2 - 1);\\n                        comparePicked = -compareIdx(nums1, p1, nums2, p2);\\n                    }\\n                }\\n            }\\n            if (comparePicked == 1) {\\n                maxN[i] = nums1[picked1];\\n                cur1 = picked1 + 1;\\n            }\\n            else {\\n                assert comparePicked == -1;\\n                maxN[i] = nums2[picked2];\\n                cur2 = picked2 + 1;\\n            }\\n        }\\n        return maxN;\\n    }\\n    private int compareIdx(int[] nums1, int i, int[] nums2, int j) {\\n        if (i == -1) return -1;\\n        if (j == -1) return 1;\\n        return Integer.compare(nums1[i], nums2[j]);\\n    }\\n}\\n\\nclass SegmentTreeMax {\\n    private final int[] data;\\n    private final int[] origin;\\n    public SegmentTreeMax(int[] origin) {\\n        data = new int[origin.length << 1];\\n        this.origin = origin;\\n        for (int i = origin.length; i != data.length; ++i) data[i] = i - origin.length;\\n        for (int i = origin.length - 1; i > 0; --i) data[i] = reducer4Build(data[i << 1], data[(i << 1) | 1]);\\n    }\\n    private int reducer4Build(int a, int b) {\\n        return (origin[a] < origin[b]) ? b : a;\\n    }\\n    private int reducer(int a, int b) {\\n        if (a > b) {\\n            a = a ^ b;\\n            b = a ^ b;\\n            a = a ^ b;\\n        }\\n        return (origin[a] < origin[b]) ? b : a;\\n    }\\n    public int reduceClosedGuarded(int from, int to) {\\n        to = Math.min(to, origin.length - 1);\\n        if (from > to) return -1;\\n        int maxima = from;\\n        for (int i = from + origin.length, j = to + origin.length; i <= j; i >>= 1, j >>= 1) {\\n            if ((i & 1) == 1) maxima = reducer(maxima, data[i++]);\\n            if ((j & 1) == 0) maxima = reducer(maxima, data[j--]);\\n        }\\n        return maxima;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384801,
                "title": "java-100-4ms",
                "content": "```\\nclass Solution {\\n    //\\u6838\\u5FC3\\u5C31\\u662F\\u4E24\\u4E2A\\u6307\\u9488\\uFF0C\\u4F9D\\u6B21\\u5BF9\\u6BD4\\uFF0C\\u5728\\u6EE1\\u8DB3canSkip\\u60C5\\u51B5\\u4E0B\\uFF0C\\u627E\\u6700\\u5927\\u7684\\u503C\\u3002\\u96BE\\u70B9\\u662F\\u5982\\u679C\\u6700\\u5927\\u503C\\u76F8\\u540C\\uFF0C\\u5219\\u9700\\u8981\\u8FED\\u4EE3\\u5904\\u7406\\u3002\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        //canSkip : \\u6700\\u591A\\u53EF\\u4EE5\\u8DF3\\u8FC7\\u591A\\u5C11\\u4E2A\\n        int canSkip = nums1.length - 0 + nums2.length - 0 - k;\\n        return helper(nums1, 0, nums2, 0, k, canSkip, 1).result;\\n    }\\n    //\\u6700\\u540E\\u4E00\\u4E2A\\u53C2\\u6570ifSameThenWhich\\u8868\\u793A\\u4E24\\u8005\\u7686\\u53EF\\u9009\\u7684\\u60C5\\u51B5\\u4E0B\\uFF0C\\u9009\\u62E9\\u54EA\\u4E2A1\\u8868\\u793A\\u9009\\u7B2C\\u4E00\\u4E2A\\u6570\\u7EC4\\uFF0C2\\u8868\\u793A\\u9009\\u7B2C\\u4E8C\\u4E2A\\u6570\\u7EC4\\u3002\\n    public ResultInfo helper(int[] nums1, int start1, int[] nums2, int start2, int k, int canSkip, int ifSameThenWhich) {\\n        int[] result = new int[k];\\n        for (int index = 0; index < k; index++) {\\n            int max1Index = maxWithSkip(nums1, start1, canSkip);\\n            int max2Index = maxWithSkip(nums2, start2, canSkip);\\n            if (max1Index != -1 && max2Index != -1 && nums1[max1Index] > nums2[max2Index] || max1Index != -1 && max2Index == -1) {//\\u7B2C\\u4E00\\u4E2A\\u6570\\u7EC4\\u7684\\u5927\\uFF0C\\u9009\\u7B2C\\u4E00\\u4E2A\\u6570\\u7EC4\\n                result[index] = nums1[max1Index];\\n                canSkip = canSkip - (max1Index - start1);\\n                start1 = max1Index + 1;\\n            } else if (max1Index != -1 && max2Index != -1 && nums2[max2Index] > nums1[max1Index] || max2Index != -1 && max1Index == -1) {//\\u7B2C\\u4E8C\\u4E2A\\u6570\\u7EC4\\u7684\\u5927\\uFF0C\\u9009\\u7B2C\\u4E8C\\u4E2A\\u6570\\u7EC4\\n                result[index] = nums2[max2Index];\\n                canSkip = canSkip - (max2Index - start2);\\n                start2 = max2Index + 1;\\n            } else {//\\u4E24\\u503C\\u76F8\\u7B49\\uFF0C\\u5219\\u5047\\u8BBE\\u90091\\u6216\\u90092\\u540E\\u7EED\\u503C\\u6BD4\\u8F83\\n                boolean done = false;\\n                int newK = k - index - 1;//\\u8FD8\\u5269\\u591A\\u5C11\\u4E2A\\u6CA1\\u9009\\n                int newStart1 = max1Index + 1;//\\u5047\\u8BBE\\u90091\\u52191\\u65B0\\u7684start1\\u4E3AnewStart1\\n                int canSkip1 = canSkip - (max1Index - start1);//\\u5047\\u8BBE\\u90091\\u52191\\u65B0\\u7684canSkip\\u4E3AcanSkip1\\n                int newStart2 = max2Index + 1;//\\u5047\\u8BBE\\u90092\\u52192\\u65B0\\u7684start2\\u4E3AnewStart2\\n                int canSkip2 = canSkip - (max2Index - start2);//\\u5047\\u8BBE\\u90092\\u52192\\u65B0\\u7684canSkip\\u4E3AcanSkip2\\n                ResultInfo resultInfo1 = new ResultInfo(null, newStart1, start2, canSkip1);\\n                ResultInfo resultInfo2 = new ResultInfo(null, start1, newStart2, canSkip2);\\n                for (int tmpK = 1; tmpK <= newK; tmpK++) {//\\u6CE8\\u610F\\u4F18\\u5316\\uFF1A\\u6BCF\\u6B21\\u53EA\\u8BA1\\u7B97\\u957F\\u5EA6\\u4E3A1\\u7684\\u6570\\u7EC4\\uFF0C\\u5982\\u679C\\u76F8\\u540C\\uFF0C\\u518D\\u8BA1\\u7B97\\u540E\\u9762\\u7684\\n                    //\\u5047\\u8BBE\\u90091\\n                    resultInfo1 = helper(nums1, resultInfo1.start1, nums2, resultInfo1.start2, 1, resultInfo1.canSkip, 1);\\n                    int result1 = resultInfo1.result[0];\\n                    //\\u5047\\u8BBE\\u90092\\n                    resultInfo2 = helper(nums1, resultInfo2.start1, nums2, resultInfo2.start2, 1, resultInfo2.canSkip, 2);\\n                    int result2 = resultInfo2.result[0];\\n                    if (result1 > result2) {\\n                        //\\u90091\\n                        result[index] = nums1[max1Index];\\n                        canSkip = canSkip - (max1Index - start1);\\n                        start1 = max1Index + 1;\\n                        done = true;\\n                        break;\\n                    } else if (result1 < result2) {\\n                        //\\u90092\\n                        result[index] = nums2[max2Index];\\n                        canSkip = canSkip - (max2Index - start2);\\n                        start2 = max2Index + 1;\\n                        done = true;\\n                        break;\\n                    }\\n                }\\n                if (!done) {//\\u90FD\\u884C\\uFF0C\\u6839\\u636EifSameThenWhich\\u9009\\n                    if (ifSameThenWhich == 1) {\\n                        result[index] = nums1[max1Index];\\n                        canSkip = canSkip - (max1Index - start1);\\n                        start1 = max1Index + 1;\\n                    } else {\\n                        result[index] = nums2[max2Index];\\n                        canSkip = canSkip - (max2Index - start2);\\n                        start2 = max2Index + 1;\\n                    }\\n                }\\n            }\\n        }\\n        return new ResultInfo(result, start1, start2, canSkip);\\n    }\\n    //\\u5728\\u6EE1\\u8DB3canSkip\\u6761\\u4EF6\\u4E0B\\uFF0C\\u627E\\u6700\\u5927\\u503C\\u3002\\n    public int maxWithSkip(int[] nums, int start, int canSkip) {//\\u8FD4\\u56DE\\u6700\\u5927\\u503C\\u4E0B\\u6807\\n        if (start == nums.length) {\\n            return -1;\\n        }\\n        int index = start;\\n        for (int i = 1; i <= canSkip; i++) {\\n            if (start + i < nums.length && nums[start + i] > nums[index]) {\\n                index = start + i;\\n            }\\n        }\\n        return index;\\n    }\\n}\\nclass ResultInfo {//\\u7ED3\\u679C\\u548C\\u7ED3\\u675F\\u65F6\\u7684\\u72B6\\u6001\\u503C\\uFF0C\\u5176\\u4E2D\\u72B6\\u6001\\u503C\\u7528\\u4E8E\\u8FED\\u4EE3\\u4F18\\u5316\\n    int[] result;\\n    int start1;\\n    int start2;\\n    int canSkip;\\n\\n    public ResultInfo(int[] result, int start1, int start2, int canSkip) {\\n        this.result = result;\\n        this.start1 = start1;\\n        this.start2 = start2;\\n        this.canSkip = canSkip;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //\\u6838\\u5FC3\\u5C31\\u662F\\u4E24\\u4E2A\\u6307\\u9488\\uFF0C\\u4F9D\\u6B21\\u5BF9\\u6BD4\\uFF0C\\u5728\\u6EE1\\u8DB3canSkip\\u60C5\\u51B5\\u4E0B\\uFF0C\\u627E\\u6700\\u5927\\u7684\\u503C\\u3002\\u96BE\\u70B9\\u662F\\u5982\\u679C\\u6700\\u5927\\u503C\\u76F8\\u540C\\uFF0C\\u5219\\u9700\\u8981\\u8FED\\u4EE3\\u5904\\u7406\\u3002\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        //canSkip : \\u6700\\u591A\\u53EF\\u4EE5\\u8DF3\\u8FC7\\u591A\\u5C11\\u4E2A\\n        int canSkip = nums1.length - 0 + nums2.length - 0 - k;\\n        return helper(nums1, 0, nums2, 0, k, canSkip, 1).result;\\n    }\\n    //\\u6700\\u540E\\u4E00\\u4E2A\\u53C2\\u6570ifSameThenWhich\\u8868\\u793A\\u4E24\\u8005\\u7686\\u53EF\\u9009\\u7684\\u60C5\\u51B5\\u4E0B\\uFF0C\\u9009\\u62E9\\u54EA\\u4E2A1\\u8868\\u793A\\u9009\\u7B2C\\u4E00\\u4E2A\\u6570\\u7EC4\\uFF0C2\\u8868\\u793A\\u9009\\u7B2C\\u4E8C\\u4E2A\\u6570\\u7EC4\\u3002\\n    public ResultInfo helper(int[] nums1, int start1, int[] nums2, int start2, int k, int canSkip, int ifSameThenWhich) {\\n        int[] result = new int[k];\\n        for (int index = 0; index < k; index++) {\\n            int max1Index = maxWithSkip(nums1, start1, canSkip);\\n            int max2Index = maxWithSkip(nums2, start2, canSkip);\\n            if (max1Index != -1 && max2Index != -1 && nums1[max1Index] > nums2[max2Index] || max1Index != -1 && max2Index == -1) {//\\u7B2C\\u4E00\\u4E2A\\u6570\\u7EC4\\u7684\\u5927\\uFF0C\\u9009\\u7B2C\\u4E00\\u4E2A\\u6570\\u7EC4\\n                result[index] = nums1[max1Index];\\n                canSkip = canSkip - (max1Index - start1);\\n                start1 = max1Index + 1;\\n            } else if (max1Index != -1 && max2Index != -1 && nums2[max2Index] > nums1[max1Index] || max2Index != -1 && max1Index == -1) {//\\u7B2C\\u4E8C\\u4E2A\\u6570\\u7EC4\\u7684\\u5927\\uFF0C\\u9009\\u7B2C\\u4E8C\\u4E2A\\u6570\\u7EC4\\n                result[index] = nums2[max2Index];\\n                canSkip = canSkip - (max2Index - start2);\\n                start2 = max2Index + 1;\\n            } else {//\\u4E24\\u503C\\u76F8\\u7B49\\uFF0C\\u5219\\u5047\\u8BBE\\u90091\\u6216\\u90092\\u540E\\u7EED\\u503C\\u6BD4\\u8F83\\n                boolean done = false;\\n                int newK = k - index - 1;//\\u8FD8\\u5269\\u591A\\u5C11\\u4E2A\\u6CA1\\u9009\\n                int newStart1 = max1Index + 1;//\\u5047\\u8BBE\\u90091\\u52191\\u65B0\\u7684start1\\u4E3AnewStart1\\n                int canSkip1 = canSkip - (max1Index - start1);//\\u5047\\u8BBE\\u90091\\u52191\\u65B0\\u7684canSkip\\u4E3AcanSkip1\\n                int newStart2 = max2Index + 1;//\\u5047\\u8BBE\\u90092\\u52192\\u65B0\\u7684start2\\u4E3AnewStart2\\n                int canSkip2 = canSkip - (max2Index - start2);//\\u5047\\u8BBE\\u90092\\u52192\\u65B0\\u7684canSkip\\u4E3AcanSkip2\\n                ResultInfo resultInfo1 = new ResultInfo(null, newStart1, start2, canSkip1);\\n                ResultInfo resultInfo2 = new ResultInfo(null, start1, newStart2, canSkip2);\\n                for (int tmpK = 1; tmpK <= newK; tmpK++) {//\\u6CE8\\u610F\\u4F18\\u5316\\uFF1A\\u6BCF\\u6B21\\u53EA\\u8BA1\\u7B97\\u957F\\u5EA6\\u4E3A1\\u7684\\u6570\\u7EC4\\uFF0C\\u5982\\u679C\\u76F8\\u540C\\uFF0C\\u518D\\u8BA1\\u7B97\\u540E\\u9762\\u7684\\n                    //\\u5047\\u8BBE\\u90091\\n                    resultInfo1 = helper(nums1, resultInfo1.start1, nums2, resultInfo1.start2, 1, resultInfo1.canSkip, 1);\\n                    int result1 = resultInfo1.result[0];\\n                    //\\u5047\\u8BBE\\u90092\\n                    resultInfo2 = helper(nums1, resultInfo2.start1, nums2, resultInfo2.start2, 1, resultInfo2.canSkip, 2);\\n                    int result2 = resultInfo2.result[0];\\n                    if (result1 > result2) {\\n                        //\\u90091\\n                        result[index] = nums1[max1Index];\\n                        canSkip = canSkip - (max1Index - start1);\\n                        start1 = max1Index + 1;\\n                        done = true;\\n                        break;\\n                    } else if (result1 < result2) {\\n                        //\\u90092\\n                        result[index] = nums2[max2Index];\\n                        canSkip = canSkip - (max2Index - start2);\\n                        start2 = max2Index + 1;\\n                        done = true;\\n                        break;\\n                    }\\n                }\\n                if (!done) {//\\u90FD\\u884C\\uFF0C\\u6839\\u636EifSameThenWhich\\u9009\\n                    if (ifSameThenWhich == 1) {\\n                        result[index] = nums1[max1Index];\\n                        canSkip = canSkip - (max1Index - start1);\\n                        start1 = max1Index + 1;\\n                    } else {\\n                        result[index] = nums2[max2Index];\\n                        canSkip = canSkip - (max2Index - start2);\\n                        start2 = max2Index + 1;\\n                    }\\n                }\\n            }\\n        }\\n        return new ResultInfo(result, start1, start2, canSkip);\\n    }\\n    //\\u5728\\u6EE1\\u8DB3canSkip\\u6761\\u4EF6\\u4E0B\\uFF0C\\u627E\\u6700\\u5927\\u503C\\u3002\\n    public int maxWithSkip(int[] nums, int start, int canSkip) {//\\u8FD4\\u56DE\\u6700\\u5927\\u503C\\u4E0B\\u6807\\n        if (start == nums.length) {\\n            return -1;\\n        }\\n        int index = start;\\n        for (int i = 1; i <= canSkip; i++) {\\n            if (start + i < nums.length && nums[start + i] > nums[index]) {\\n                index = start + i;\\n            }\\n        }\\n        return index;\\n    }\\n}\\nclass ResultInfo {//\\u7ED3\\u679C\\u548C\\u7ED3\\u675F\\u65F6\\u7684\\u72B6\\u6001\\u503C\\uFF0C\\u5176\\u4E2D\\u72B6\\u6001\\u503C\\u7528\\u4E8E\\u8FED\\u4EE3\\u4F18\\u5316\\n    int[] result;\\n    int start1;\\n    int start2;\\n    int canSkip;\\n\\n    public ResultInfo(int[] result, int start1, int start2, int canSkip) {\\n        this.result = result;\\n        this.start1 = start1;\\n        this.start2 = start2;\\n        this.canSkip = canSkip;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77321,
                "title": "a-very-efficient-solution-accepted-as-best-beating-98-16ms-in-c-well-commented",
                "content": "    class Solution {\\n    public:\\n        // create max number of length t from single non-empty vector\\n        // @nums is the array of length @len \\n        // @result will be used to store the max number of length @t \\n        // @sortedLen indicates the prefix length which is in descending order;\\n        void getMax(int* nums, int& len, int* result, int& t, int& sortedLen)\\n        {\\n            int n, top = 0;\\n            result[0] = nums[0];\\n            const int need2drop = len - t;\\n            for (int i = 1; i < len; ++i){\\n                n = nums[i];\\n                while (top >= 0 && result[top] < n && (i - top) <= need2drop) --top; // i - top means already dropped i - top numsbers\\n                if (i - top > need2drop){\\n                    sortedLen = max(1,top);\\n                    while (++top < t) result[top] = nums[i++];\\n                    return;\\n                }\\n                if (++top < t) result[top] = n;\\n                else top = t - 1;\\n            }\\n        }\\n        // create max number of different length from single vector\\n        // @nums is the original array of length @len\\n        // @sortedLen is the longest length of the descending prefix of the max number;\\n        // @minL and @maxL is the min and max length of the result max number\\n        // @res is a pointer which will record the max numbers of length ranging from minL to maxL\\n        // @k is the length of the final max number;\\n        void dp(int *nums, int len, int&sortedLen, int& minL, int& maxL, int *res, int &k)\\n        {\\n            int  j, *head, *preHead = res;\\n            const int soi = sizeof(int);\\n            getMax(nums, len, res, maxL, sortedLen);\\n            for(int l = maxL; l > max(minL,1); --l) //according to the max number of length maxL to generate all the max numbers ranging from minL to maxL (exclusive) and append them;\\n            {\\n                head = preHead + k; //jump to the next max-number pointer;\\n                memcpy(head, preHead, l*soi); \\n                for(j = sortedLen; j < l; ++j)\\n                {\\n                    if(head[j] > head[j - 1]) //remove the previous element encountering the first ascending pair;\\n                    {\\n                        sortedLen = max(1, j - 1); //update the sortedLen;\\n                        memcpy(head + j - 1, preHead + j, soi*(l - j));\\n                        break;\\n                    }\\n                }\\n                if(j == l) sortedLen = l; //it's already descending, remove the last element updating sortedLen to l;\\n                preHead = head; //update preHead;\\n            }\\n        }\\n        // merge max number created from single vector\\n        // @nums1 is the first array of length @len1\\n        // @nums2 is the second array of length @len2\\n        // @result is the array of length @resSize which will contain the max number generated\\n        // by the both two arrays without changing the order in each array;\\n        void merge(int* nums1,int len1,int* nums2,int len2,int* result,int& resSize)\\n        {\\n            int i = 0, j = 0, k = 0; //i -> result, j -> nums1, k -> nums2;\\n            while (i < resSize)\\n            {\\n                if (j < len1 && k < len2) //normal case;\\n                {\\n                    if (nums1[j] > nums2[k]) //collect the bigger element first;\\n                        result[i++] = nums1[j++];\\n                    else if (nums1[j] < nums2[k])\\n                        result[i++] = nums2[k++];\\n                    else //when they are equal, collect the one with bigger lexical order;\\n                    {\\n                        int remaining1 = len1-j, remaining2 = len2-k, tmp = nums1[j];\\n                        int flag = memcmp(nums1+j, nums2+k, sizeof(int)*min(remaining1, remaining2));\\n                        flag = (flag==0 ? (remaining1>remaining2 ? 1 : -1) : flag); //determine which is bigger in lexical order -> when the lexical order are the same the longer one will be bigger in order;\\n                        int * nums = flag > 0 ? nums1 : nums2;\\n                        int & cnt = flag > 0 ? j : k; //using reference to modify j or k;\\n                        int len = flag > 0 ? len1 : len2;\\n                        while (nums[cnt]==tmp && cnt < len && i<resSize) result[i++] = nums[cnt++];\\n                    }\\n                }\\n                else if (j < len1) result[i++] = nums1[j++];\\n                else result[i++] = nums2[k++];\\n            }\\n        }\\n    \\n        //AC - 16ms - the most efficient solution;\\n        // Reference: https://leetcode.com/discuss/85603/c-16ms-fastest-beats-97%25\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k){\\n            int soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size();\\n            int step = k*soi; //the space the final max number might take in memory;\\n            int minL1 = max(0, k-len2), maxL1 = min(k, len1), minL2 = k-maxL1, maxL2 = k-minL1, range = maxL1-minL1+1;\\n            int * res = new int[range*k*2 + 2*k], *dp1 = res+k, *dp2 = res+range*k+k, *tmp=res+range*2*k+k; //using one-dimension array to handle different arrays -> only using the necessary space without any waste;\\n            memset(res, 0, step);\\n            int sortedLen1=1, sortedLen2=1;\\n            if (len1 == 0 && len2 > 0) getMax(&nums2[0], len2, res, k, sortedLen2); //handle corner cases;\\n            else if (len1 > 0 && len2 == 0) getMax(&nums1[0], len1, res, k, sortedLen1);\\n            else if (len1 > 0 && len2 > 0) //the normal case;\\n            {\\n                dp(&nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k);\\n                dp(&nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k);\\n                if (sortedLen1+sortedLen2 > k) //special cases - needless to check each combination accelerating the process from 20ms to 16ms;\\n                    merge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, res, k);\\n                else for(int i = minL1; i <= maxL1; ++i)\\n                {\\n                    merge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k);\\n                    if(memcmp(res, tmp, step) < 0) memcpy(res, tmp, step);\\n                }\\n            }\\n            vector<int> resv(res, res + k);\\n            delete[] res;\\n            return resv;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        // create max number of length t from single non-empty vector\\n        // @nums is the array of length @len \\n        // @result will be used to store the max number of length @t \\n        // @sortedLen indicates the prefix length which is in descending order;\\n        void getMax(int* nums, int& len, int* result, int& t, int& sortedLen)\\n        {\\n            int n, top = 0;\\n            result[0] = nums[0];\\n            const int need2drop = len - t;\\n            for (int i = 1; i < len; ++i){\\n                n = nums[i];\\n                while (top >= 0 && result[top] < n && (i - top) <= need2drop) --top; // i - top means already dropped i - top numsbers\\n                if (i - top > need2drop){\\n                    sortedLen = max(1,top);\\n                    while (++top < t) result[top] = nums[i++];\\n                    return;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 77314,
                "title": "o-m-n-k-dp-solution-tle",
                "content": "Now I find there are O(max(m, n) * k) greedy solution from the posts. My first idea is DP. Let f(i,j,k) represent maximum number of length k generated from nums1[1:i] and nums2[1:j]. the formula is: f(i,j,k) = max{f(i-1,j,k), f(i,j-1,k), f(i-1,j,k-1) + [nums1[i]], f(i,j-1,k-1) + [nums2[j]] } The implementation is as follows,\\n\\n        def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        m = len(nums1)\\n        n = len(nums2)\\n        if k > m + n or k <= 0:\\n            return []\\n        #kk = 0\\n        pre_dp = [[[] for _ in xrange(n + 1)] for __ in xrange(m + 1)]\\n        \\n        for kk in xrange(1, k + 1):\\n            #kk\\n            dp = [[[] for _ in xrange(n + 1)] for __ in xrange(m + 1)]\\n            #i >= kk, j = 0\\n            for i in xrange(kk, m + 1):\\n                dp[i][0] = max(pre_dp[i-1][0] + [nums1[i-1]], dp[i-1][0])\\n                \\n            #i = 0, j >= kk\\n            for j in xrange(kk, n + 1):\\n                dp[0][j] = max(pre_dp[0][j-1] + [nums2[j-1]], dp[0][j-1])\\n            \\n            #i > 0, j > 0\\n            for i in xrange(1, m + 1):\\n                for j in xrange(1, n + 1):\\n                    if i + j < kk:\\n                        continue\\n                    dp[i][j] = max(dp[i-1][j], \\\\\\n                                    dp[i][j-1], \\\\\\n                                    pre_dp[i-1][j] + [nums1[i-1]], \\\\\\n                                    pre_dp[i][j-1] + [nums2[j-1]])\\n            pre_dp, dp = dp, pre_dp\\n        return pre_dp[m][n]",
                "solutionTags": [],
                "code": "Now I find there are O(max(m, n) * k) greedy solution from the posts. My first idea is DP. Let f(i,j,k) represent maximum number of length k generated from nums1[1:i] and nums2[1:j]. the formula is: f(i,j,k) = max{f(i-1,j,k), f(i,j-1,k), f(i-1,j,k-1) + [nums1[i]], f(i,j-1,k-1) + [nums2[j]] } The implementation is as follows,\\n\\n        def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        m = len(nums1)\\n        n = len(nums2)\\n        if k > m + n or k <= 0:\\n            return []\\n        #kk = 0\\n        pre_dp = [[[] for _ in xrange(n + 1)] for __ in xrange(m + 1)]\\n        \\n        for kk in xrange(1, k + 1):\\n            #kk\\n            dp = [[[] for _ in xrange(n + 1)] for __ in xrange(m + 1)]\\n            #i >= kk, j = 0\\n            for i in xrange(kk, m + 1):\\n                dp[i][0] = max(pre_dp[i-1][0] + [nums1[i-1]], dp[i-1][0])\\n                \\n            #i = 0, j >= kk\\n            for j in xrange(kk, n + 1):\\n                dp[0][j] = max(pre_dp[0][j-1] + [nums2[j-1]], dp[0][j-1])\\n            \\n            #i > 0, j > 0\\n            for i in xrange(1, m + 1):\\n                for j in xrange(1, n + 1):\\n                    if i + j < kk:\\n                        continue\\n                    dp[i][j] = max(dp[i-1][j], \\\\\\n                                    dp[i][j-1], \\\\\\n                                    pre_dp[i-1][j] + [nums1[i-1]], \\\\\\n                                    pre_dp[i][j-1] + [nums2[j-1]])\\n            pre_dp, dp = dp, pre_dp\\n        return pre_dp[m][n]",
                "codeTag": "Python3"
            },
            {
                "id": 3242314,
                "title": "321-space-98-63-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a function called \"get_max_subseq\" that takes two inputs: a list of integers called \"nums\" and an integer \"k\" representing the length of the subsequence we want to extract from the list.\\n2. Initialize an empty stack to hold the maximum subsequence and iterate through the input list \"nums\" using a for loop and the enumerate() function.\\n3. For each element \"num\" in \"nums\", do the following:\\na. While the stack is not empty AND the length of the remaining part of \"nums\" (i.e., len(nums) - i) plus the length of the stack is greater than \"k\" AND the last element in the stack is less than \"num\", pop the last element from the stack.\\nb. If the length of the stack is less than \"k\", append \"num\" to the stack.\\n4. Return the resulting stack, which contains the maximum subsequence of \"nums\" of length \"k\".\\n5. Define a function called \"merge\" that takes two inputs: two lists of integers called \"nums1\" and \"nums2\".\\n6. Initialize an empty list called \"merged\" to hold the merged list.\\n7. Initialize two counters i and j to 0 to track the current index of \"nums1\" and \"nums2\", respectively.\\n8. While i is less than the length of \"nums1\" OR j is less than the length of \"nums2\", do the following:\\na. If i is greater than or equal to the length of \"nums1\", append the jth element of \"nums2\" to \"merged\" and increment j by 1.\\nb. Else if j is greater than or equal to the length of \"nums2\", append the ith element of \"nums1\" to \"merged\" and increment i by 1.\\nc. Else if the remaining part of \"nums1\" starting from the ith index is lexicographically greater than the remaining part of \"nums2\" starting from the jth index, append the ith element of \"nums1\" to \"merged\" and increment i by 1.\\nd. Otherwise, append the jth element of \"nums2\" to \"merged\" and increment j by 1.\\n9. Return the resulting merged list.\\n10. Initialize an empty list called \"ans\" to hold the maximum subsequence of length \"k\" from \"nums1\" and \"nums2\".\\n11. Loop through all possible lengths \"i\" of the subsequence from \"nums1\" ranging from max(0, k - len(nums2)) to min(len(nums1), k) + 1.\\n12. Calculate the corresponding subsequence of \"nums2\" of length \"j\" by subtracting \"i\" from \"k\".\\n13. Call the \"get_max_subseq\" function on \"nums1\" with \"i\" as the input \"k\" and store the result in \"subseq1\".\\n14. Call the \"get_max_subseq\" function on \"nums2\" with \"j\" as the input \"k\" and store the result in \"subseq2\".\\n15. Call the \"merge\" function on \"subseq1\" and \"subseq2\" and store the result in \"merged\".\\n16. Update \"ans\" to be the maximum value between the current value of \"ans\" and \"merged\" using the max() function.\\n17. Return the resulting maximum subsequence of length \"k\" from \"nums1\" and \"nums2\", which is stored in \"ans\".\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def get_max_subseq(nums, k):\\n            stack = []\\n            for i, num in enumerate(nums):\\n                while stack and len(nums) - i + len(stack) > k and stack[-1] < num:\\n                    stack.pop()\\n                if len(stack) < k:\\n                    stack.append(num)\\n            return stack\\n        \\n        def merge(nums1, nums2):\\n            merged = []\\n            i, j = 0, 0\\n            while i < len(nums1) or j < len(nums2):\\n                if i >= len(nums1):\\n                    merged.append(nums2[j])\\n                    j += 1\\n                elif j >= len(nums2):\\n                    merged.append(nums1[i])\\n                    i += 1\\n                elif nums1[i:] > nums2[j:]:\\n                    merged.append(nums1[i])\\n                    i += 1\\n                else:\\n                    merged.append(nums2[j])\\n                    j += 1\\n            return merged\\n        \\n        ans = []\\n        for i in range(max(0, k - len(nums2)), min(len(nums1), k) + 1):\\n            j = k - i\\n            subseq1 = get_max_subseq(nums1, i)\\n            subseq2 = get_max_subseq(nums2, j)\\n            merged = merge(subseq1, subseq2)\\n            ans = max(ans, merged)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def get_max_subseq(nums, k):\\n            stack = []\\n            for i, num in enumerate(nums):\\n                while stack and len(nums) - i + len(stack) > k and stack[-1] < num:\\n                    stack.pop()\\n                if len(stack) < k:\\n                    stack.append(num)\\n            return stack\\n        \\n        def merge(nums1, nums2):\\n            merged = []\\n            i, j = 0, 0\\n            while i < len(nums1) or j < len(nums2):\\n                if i >= len(nums1):\\n                    merged.append(nums2[j])\\n                    j += 1\\n                elif j >= len(nums2):\\n                    merged.append(nums1[i])\\n                    i += 1\\n                elif nums1[i:] > nums2[j:]:\\n                    merged.append(nums1[i])\\n                    i += 1\\n                else:\\n                    merged.append(nums2[j])\\n                    j += 1\\n            return merged\\n        \\n        ans = []\\n        for i in range(max(0, k - len(nums2)), min(len(nums1), k) + 1):\\n            j = k - i\\n            subseq1 = get_max_subseq(nums1, i)\\n            subseq2 = get_max_subseq(nums2, j)\\n            merged = merge(subseq1, subseq2)\\n            ans = max(ans, merged)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429774,
                "title": "java-monotonic-stack",
                "content": "Please upvote if you find it useful! Thank you so much!!\\n\\n```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int len1 = nums1.length, len2 = nums2.length;\\n        int[] res = new int[k];\\n        int[] tempRes = null;\\n        \\n        // enumerate all the possible ways to construct an array with len k from two arrays\\n        // the length of the res is k \\n        // we assume that we pick k1 numbers from nums1, therefore we pick (k - k1) numbers\\n        // from nums2. The possible range of k1 is from Math.max(0, k-len2)\\n        // to Math.min(len1, k);\\n        for(int k1 = Math.max(0, k-len2); k1 <= Math.min(len1, k); k1++){\\n            int[] num1Max = findMaxSubsequence(nums1, k1);\\n            int[] num2Max = findMaxSubsequence(nums2, k - k1);\\n            tempRes = merge(num1Max, num2Max);\\n            if(isGreater(tempRes, 0, res, 0)){\\n                res = tempRes;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    // find the largest number that can be constructed from two arrays\\n    private int[] merge(int[] nums1, int[] nums2){\\n        int[] res = new int[nums1.length + nums2.length];\\n        int p1 = 0, p2 = 0, p3 = 0;\\n        \\n        while(p3 < res.length){\\n            res[p3++] = isGreater(nums1, p1, nums2, p2) ? nums1[p1++] : nums2[p2++];     \\n        }\\n        return res;\\n    }\\n    \\n    private boolean isGreater(int[] nums1, int p1, int[] nums2, int p2){\\n        while(p1 < nums1.length && p2 < nums2.length){\\n            if(nums1[p1] > nums2[p2]){\\n                return true;\\n            }else if(nums1[p1] < nums2[p2]){\\n                return false;\\n            }\\n            p1++;\\n            p2++;\\n        }\\n        return p1 != nums1.length;\\n    }\\n    \\n    // this subroutine is similar to leetcode 1673\\n    private int[] findMaxSubsequence(int[] num, int len){\\n        if(num.length == len){return num;}\\n        \\n        int[] stack = new int[len];\\n        int top = -1;\\n        int canRemoveCnt = num.length - len;\\n        \\n        for(int i = 0; i < num.length; i++){\\n            int curNum = num[i];\\n            \\n            while(top >= 0 && canRemoveCnt > 0 && curNum > stack[top]){\\n                top--;\\n                canRemoveCnt--;\\n            }\\n            \\n            if(top + 1 < stack.length){\\n                stack[++top] = curNum;     \\n            }else{\\n                canRemoveCnt--;\\n            }\\n        }\\n        \\n        return stack;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int len1 = nums1.length, len2 = nums2.length;\\n        int[] res = new int[k];\\n        int[] tempRes = null;\\n        \\n        // enumerate all the possible ways to construct an array with len k from two arrays\\n        // the length of the res is k \\n        // we assume that we pick k1 numbers from nums1, therefore we pick (k - k1) numbers\\n        // from nums2. The possible range of k1 is from Math.max(0, k-len2)\\n        // to Math.min(len1, k);\\n        for(int k1 = Math.max(0, k-len2); k1 <= Math.min(len1, k); k1++){\\n            int[] num1Max = findMaxSubsequence(nums1, k1);\\n            int[] num2Max = findMaxSubsequence(nums2, k - k1);\\n            tempRes = merge(num1Max, num2Max);\\n            if(isGreater(tempRes, 0, res, 0)){\\n                res = tempRes;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    // find the largest number that can be constructed from two arrays\\n    private int[] merge(int[] nums1, int[] nums2){\\n        int[] res = new int[nums1.length + nums2.length];\\n        int p1 = 0, p2 = 0, p3 = 0;\\n        \\n        while(p3 < res.length){\\n            res[p3++] = isGreater(nums1, p1, nums2, p2) ? nums1[p1++] : nums2[p2++];     \\n        }\\n        return res;\\n    }\\n    \\n    private boolean isGreater(int[] nums1, int p1, int[] nums2, int p2){\\n        while(p1 < nums1.length && p2 < nums2.length){\\n            if(nums1[p1] > nums2[p2]){\\n                return true;\\n            }else if(nums1[p1] < nums2[p2]){\\n                return false;\\n            }\\n            p1++;\\n            p2++;\\n        }\\n        return p1 != nums1.length;\\n    }\\n    \\n    // this subroutine is similar to leetcode 1673\\n    private int[] findMaxSubsequence(int[] num, int len){\\n        if(num.length == len){return num;}\\n        \\n        int[] stack = new int[len];\\n        int top = -1;\\n        int canRemoveCnt = num.length - len;\\n        \\n        for(int i = 0; i < num.length; i++){\\n            int curNum = num[i];\\n            \\n            while(top >= 0 && canRemoveCnt > 0 && curNum > stack[top]){\\n                top--;\\n                canRemoveCnt--;\\n            }\\n            \\n            if(top + 1 < stack.length){\\n                stack[++top] = curNum;     \\n            }else{\\n                canRemoveCnt--;\\n            }\\n        }\\n        \\n        return stack;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353982,
                "title": "c-solution-greedy-monotonic-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    // pick k numbers from vector num\\n    vector<int> select(vector<int>& nums, int k){\\n        int n = nums.size();\\n        vector<int> res(k, INT_MIN);\\n        for(int i = 0, j = 0;i<nums.size();i++){\\n            int x = nums[i];\\n            // monotonic stack\\n            while(j>0&&x > res[j-1]&&i+k-j<n) j--;\\n            if(j<k) res[j++] = x;\\n        }\\n        return res;\\n    }\\n    vector<int> merge(vector<int>& a, vector<int> &b){\\n        vector<int> c;\\n        while(a.size()&&b.size()){\\n            // The time complexity of compare operation for two vector is order of n.\\n            // Greedy Algorithm:\\n            // If we meet two elements which have the same value, choose the vector which has the higher dictionary order first.\\n            // 1: ...xxxb , 2: ...xxxa, if a > b, then merge sequence 2 first. \\n            if(a > b)\\n                c.push_back(a[0]), a.erase(a.begin());\\n            else\\n                c.push_back(b[0]), b.erase(b.begin());\\n        }\\n        while(a.size())\\n            c.push_back(a[0]), a.erase(a.begin());\\n        while(b.size())\\n            c.push_back(b[0]), b.erase(b.begin());\\n        return c;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> res(k, INT_MIN);\\n        int n = nums1.size(), m = nums2.size();\\n        // s1  => nums1.size(), s2 => nums2.size()\\n        // {0<=i<=k, i<=s1, 0<=k-i<=s2} => i>=max(0, k-s2), i<=min(k, n)\\n        for(int i = max(0, k-m);i<=min(k, n);i++){\\n            vector<int> a = select(nums1, i);\\n            vector<int> b = select(nums2, k - i);\\n            res = max(res, merge(a, b));\\n        }\\n        return res;\\n    }\\n};\\n```\\n// yxc nb!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // pick k numbers from vector num\\n    vector<int> select(vector<int>& nums, int k){\\n        int n = nums.size();\\n        vector<int> res(k, INT_MIN);\\n        for(int i = 0, j = 0;i<nums.size();i++){\\n            int x = nums[i];\\n            // monotonic stack\\n            while(j>0&&x > res[j-1]&&i+k-j<n) j--;\\n            if(j<k) res[j++] = x;\\n        }\\n        return res;\\n    }\\n    vector<int> merge(vector<int>& a, vector<int> &b){\\n        vector<int> c;\\n        while(a.size()&&b.size()){\\n            // The time complexity of compare operation for two vector is order of n.\\n            // Greedy Algorithm:\\n            // If we meet two elements which have the same value, choose the vector which has the higher dictionary order first.\\n            // 1: ...xxxb , 2: ...xxxa, if a > b, then merge sequence 2 first. \\n            if(a > b)\\n                c.push_back(a[0]), a.erase(a.begin());\\n            else\\n                c.push_back(b[0]), b.erase(b.begin());\\n        }\\n        while(a.size())\\n            c.push_back(a[0]), a.erase(a.begin());\\n        while(b.size())\\n            c.push_back(b[0]), b.erase(b.begin());\\n        return c;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> res(k, INT_MIN);\\n        int n = nums1.size(), m = nums2.size();\\n        // s1  => nums1.size(), s2 => nums2.size()\\n        // {0<=i<=k, i<=s1, 0<=k-i<=s2} => i>=max(0, k-s2), i<=min(k, n)\\n        for(int i = max(0, k-m);i<=min(k, n);i++){\\n            vector<int> a = select(nums1, i);\\n            vector<int> b = select(nums2, k - i);\\n            res = max(res, merge(a, b));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112284,
                "title": "cpp-simple-greedy-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> calc(vector<int> &v,int k,int n) {\\n        vector<int> v1;\\n        // IF I replace the current top or not.\\n        int i=-1,j,ind=-1,ans=-1;\\n        while(k) {\\n            j=i+1;ind=-1;ans=-1;\\n            while(j<n&&n-j>=k) {\\n                if(v[j]>ans) {\\n                    ans=v[j];\\n                    ind=j;\\n                }\\n                j++;\\n            }\\n            i=ind;\\n            v1.push_back(ans);\\n            k--;\\n        }\\n        return v1;\\n    }\\n    vector<int> merge(vector<int> &v1,vector<int> &v2,int n,int m) {\\n        vector<int> v;\\n        if(n>m) {\\n            swap(v1,v2);\\n            swap(n,m);\\n        }\\n        int i=0,j=0;\\n        while(i<n && j<m) {\\n            if(v1[i]>v2[j]) {\\n                v.push_back(v1[i]);\\n                i++;\\n            }\\n            else if(v1[i]<v2[j]) {\\n                v.push_back(v2[j]);\\n                j++;\\n            }\\n            else {\\n                int k=i+1,l=j+1,f=1;\\n                while(k<n && l<m) {\\n                    if(v1[k]>v2[l]) { f=0;break; }\\n                    else if(v1[k]<v2[l]) { f=1;break;}\\n                    k++;\\n                    l++;\\n                }\\n                \\n                if(f==0||l==m) { v.push_back(v1[i++]); }\\n                else     { v.push_back(v2[j++]); }\\n            }\\n        }\\n        while(i<n) { v.push_back(v1[i]);i++; }\\n        while(j<m) { v.push_back(v2[j]);j++; }\\n        return v;\\n    }\\n    int comp(vector<int> v1,vector<int> v2,int k) {\\n        for(int i=0;i<k;i++) { \\n            if(v1[i]!=v2[i]) return v1[i]>v2[i];\\n        }\\n        return 0;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size(),m=nums2.size();\\n        // If I have to chose k greatest elements.\\n        // from a vector. how you are going to pick up.\\n        // this task is awesome.\\n        vector<int> ans(k,-1);\\n        for(int i=0;i<=min(n,k);i++) {\\n            int r=k-i;\\n            if(r<=m) { \\n                vector<int> v1=calc(nums1,i,n),v2=calc(nums2,r,m);\\n                vector<int> x=merge(v1,v2,i,r);\\n                if(comp(x,ans,k)>0) ans=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> calc(vector<int> &v,int k,int n) {\\n        vector<int> v1;\\n        // IF I replace the current top or not.\\n        int i=-1,j,ind=-1,ans=-1;\\n        while(k) {\\n            j=i+1;ind=-1;ans=-1;\\n            while(j<n&&n-j>=k) {\\n                if(v[j]>ans) {\\n                    ans=v[j];\\n                    ind=j;\\n                }\\n                j++;\\n            }\\n            i=ind;\\n            v1.push_back(ans);\\n            k--;\\n        }\\n        return v1;\\n    }\\n    vector<int> merge(vector<int> &v1,vector<int> &v2,int n,int m) {\\n        vector<int> v;\\n        if(n>m) {\\n            swap(v1,v2);\\n            swap(n,m);\\n        }\\n        int i=0,j=0;\\n        while(i<n && j<m) {\\n            if(v1[i]>v2[j]) {\\n                v.push_back(v1[i]);\\n                i++;\\n            }\\n            else if(v1[i]<v2[j]) {\\n                v.push_back(v2[j]);\\n                j++;\\n            }\\n            else {\\n                int k=i+1,l=j+1,f=1;\\n                while(k<n && l<m) {\\n                    if(v1[k]>v2[l]) { f=0;break; }\\n                    else if(v1[k]<v2[l]) { f=1;break;}\\n                    k++;\\n                    l++;\\n                }\\n                \\n                if(f==0||l==m) { v.push_back(v1[i++]); }\\n                else     { v.push_back(v2[j++]); }\\n            }\\n        }\\n        while(i<n) { v.push_back(v1[i]);i++; }\\n        while(j<m) { v.push_back(v2[j]);j++; }\\n        return v;\\n    }\\n    int comp(vector<int> v1,vector<int> v2,int k) {\\n        for(int i=0;i<k;i++) { \\n            if(v1[i]!=v2[i]) return v1[i]>v2[i];\\n        }\\n        return 0;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size(),m=nums2.size();\\n        // If I have to chose k greatest elements.\\n        // from a vector. how you are going to pick up.\\n        // this task is awesome.\\n        vector<int> ans(k,-1);\\n        for(int i=0;i<=min(n,k);i++) {\\n            int r=k-i;\\n            if(r<=m) { \\n                vector<int> v1=calc(nums1,i,n),v2=calc(nums2,r,m);\\n                vector<int> x=merge(v1,v2,i,r);\\n                if(comp(x,ans,k)>0) ans=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865712,
                "title": "360-ms-python-solution-with-detailed-explanation",
                "content": "The main idea: \\n\\n1 . get the maximum array with length of s1 from list nums1 called p1 and then get the maximum array with length of k-s1 from list nums2 called p2\\n2 . arrange p1 and p2 to make maximum rs \\n\\nTo get the maximum array with length of c_len and also reserve the relative order in that array:\\n    We use a helper function to get the maximum array with length of c_len\\nas long as ans[-1]< current value and the remaining elements in list nums is enough to form ans with length c_len then we pop the last element in ans\\n```\\n\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        \\n        l1,l2 = len(nums1),len(nums2)\\n        rs = []\\n        \\n        \\n        def helper(nums,c_len):\\n            ans = []\\n            ln = len(nums)\\n            for idx,val in enumerate(nums):\\n                while ans and ans[-1]<val and ln-idx> c_len-len(ans):\\n                    ans.pop(-1)\\n                if len(ans)<c_len:\\n                    ans.append(val)\\n            return ans\\n        \\n        for s1 in range(max(0,k-l2),min(k,l1)+1):\\n            p1,p2 = helper(nums1,s1),helper(nums2,k-s1)\\n            rs = max(rs,[max(p1,p2).pop(0) for _ in range(k)])\\n        return rs\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        \\n        l1,l2 = len(nums1),len(nums2)\\n        rs = []\\n        \\n        \\n        def helper(nums,c_len):\\n            ans = []\\n            ln = len(nums)\\n            for idx,val in enumerate(nums):\\n                while ans and ans[-1]<val and ln-idx> c_len-len(ans):\\n                    ans.pop(-1)\\n                if len(ans)<c_len:\\n                    ans.append(val)\\n            return ans\\n        \\n        for s1 in range(max(0,k-l2),min(k,l1)+1):\\n            p1,p2 = helper(nums1,s1),helper(nums2,k-s1)\\n            rs = max(rs,[max(p1,p2).pop(0) for _ in range(k)])\\n        return rs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539266,
                "title": "help-me-understand-the-question",
                "content": "I have a hard time understanding the question. \\nFor the input:\\n[5,5,4,1,1,6,2], [8,8], 4\\nI think the expected output is [8,8,5,6], which still preserves the order of 2 arrays. \\nHowever, the correct output is [8,8,6,2]\\nAny comments will be helpful.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 155478,
                "title": "c-solution-based-on-stefanpochmann-s-approach-with-very-detailed-explanation",
                "content": "@StefanPochmann solution is great but lacks detailed comments. Here is the solution that explains the process step by step. \\n    Idea - \\n*   K elements can be picked as i elements from nums1 and k-i elements from nums2. \\n*   We slice two lists nums1 and nums2 by choosing series of values for i\\n*   We create biggest number possible from each list for given value of i or k-i\\n*   We combine the two lists to get the biggest number for given slice.\\n*   We choose maximum number for all slices.\\n\\nCode below - \\n```\\nclass Solution {\\n\\nprivate:\\n    //Compare function for two generic collections.\\n    //if collection contains non primitive types then it must overload\\n    //operator \\'<\\'\\n    \\n    //returns true if second list is greater in value than first one\\n    //if all elements are equal then it returns true if second list is\\n    //larger in size\\n    \\n    template <class InputIterator1, class InputIterator2>\\n      bool lexicographical_compare (InputIterator1 first1, InputIterator1 last1,\\n                                    InputIterator2 first2, InputIterator2 last2)\\n    {\\n      while (first1!=last1)\\n      {\\n        if (first2==last2 || *first2<*first1) return false;\\n        else if (*first1<*first2) return true;\\n        ++first1; ++first2;\\n      }\\n      return (first2!=last2);\\n    }\\npublic:\\n    \\n    //subproblem 1 = create the greatest number with K digits from a single list\\n    vector<int> maxNumber(vector<int> nums, int k) {\\n        int drop = nums.size()-k; //number of digits to be dropped\\n        vector<int> out;\\n        for(int num : nums) {\\n            //if there are digits left to be dropped and if we find\\n            //a digit that is greater than the digit we have in our \\n            //output array we drop the digits and add that digit\\n            while(drop > 0 && out.size() != 0 && out.back() < num) {\\n                drop--;\\n                out.pop_back();\\n            }\\n            out.push_back(num);\\n        }\\n        out.resize(k); // this is necessary if there are more than K digits in out\\n        return out;\\n    }\\n    \\n    /*\\n      subproblem 2 = create largest number from the two lists, containing\\n      digits [0-9]. The size of output number is sum of size of two\\n      lists\\n    */\\n    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {\\n        auto start1 = nums1.begin(), end1 = nums1.end(),\\n             start2 = nums2.begin(), end2 = nums2.end();\\n        vector<int> out;\\n        while(start1 != end1 || start2 != end2) {\\n            if(lexicographical_compare(start1,end1,start2,end2)) {\\n                out.push_back(*start2++);\\n            }\\n            else {\\n                out.push_back(*start1++);\\n            }\\n        }\\n        return out;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        vector<int> best;\\n        /* \\n           The start and end range of for the \"for loop\" is computed based on\\n           number of min elements we need to pick from nums1 and number of maximum\\n           elements we can pick from nums1. if k > n2 then we must at least pick up\\n           k-n2 elements from n1\\n           \\n           \\n           Example 1\\n           consider n1 = 4 and n2 = 6 and k = 5\\n           Result can be constructed in following ways \\n           (i:0, k-i:5), (i:1, k-i:4), (i:2, k-i:3), (i:3, k-i:2), (i:4, k-i:1)\\n           where i is number of elements picked from nums1 and k-i is number of elements\\n           picked from nums2. Please note\\n           --> (i:5, k-i:0) is not valid since n1=4\\n           \\n           Example 2\\n           Now consider n1 = 6 and n2 = 4 and k = 5\\n           (i:1, k-i:4), (i:2, k-i:3), (i:3, k-i:2), (i:4, k-i:1), (i:5, k-i:0)\\n           \\n           hence starting index for i that is associated with nums1 is \\n           max(0, k-n2) (in first example k-n2 = -1, in second example k-n2 = 1)\\n           \\n           end index for i associated with nums1 is \\n           min(k,n1) (in first example i can only go up to 4 since n1 = 4, in second example\\n                      i can only go up to 5 since k = 5)\\n                      \\n          Example 3\\n          n1 = 3, n2 = 4, k = 5\\n          we must pick at least 1 element from nums1 (k-n2 = 1) also i can only go up to 3 since\\n          n1 is capped at 3\\n          \\n          Example 4\\n          \\n          n1 = 5, n2=3, k = 4\\n          we must pick up at least 1 element from nums1 (k-n2 = 1) and i can go up to 4\\n           \\n        */\\n          for(int i = max(0,k-n2); i <= min(k,n1); i++) {\\n            \\n            if(best.size() == 0) {\\n                best = maxNumber(maxNumber(nums1,i),\\n                                 maxNumber(nums2,k-i));\\n            }\\n            else {\\n                vector<int> temp = maxNumber(maxNumber(nums1,i),\\n                                             maxNumber(nums2,k-i));\\n                if(lexicographical_compare(best.begin(), best.end(),\\n                                           temp.begin(),temp.end())) {\\n                    best = temp;\\n                }\\n            }\\n            //vector class overloads \"<\" operator hence you could simply use the \\n            //statement below, above code is only to make things simple.\\n            //best = max(best,maxNumber(maxNumber(nums1,i),maxNumber(nums2,k-i)));\\n        }\\n        return best;\\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n    //Compare function for two generic collections.\\n    //if collection contains non primitive types then it must overload\\n    //operator \\'<\\'\\n    \\n    //returns true if second list is greater in value than first one\\n    //if all elements are equal then it returns true if second list is\\n    //larger in size\\n    \\n    template <class InputIterator1, class InputIterator2>\\n      bool lexicographical_compare (InputIterator1 first1, InputIterator1 last1,\\n                                    InputIterator2 first2, InputIterator2 last2)\\n    {\\n      while (first1!=last1)\\n      {\\n        if (first2==last2 || *first2<*first1) return false;\\n        else if (*first1<*first2) return true;\\n        ++first1; ++first2;\\n      }\\n      return (first2!=last2);\\n    }\\npublic:\\n    \\n    //subproblem 1 = create the greatest number with K digits from a single list\\n    vector<int> maxNumber(vector<int> nums, int k) {\\n        int drop = nums.size()-k; //number of digits to be dropped\\n        vector<int> out;\\n        for(int num : nums) {\\n            //if there are digits left to be dropped and if we find\\n            //a digit that is greater than the digit we have in our \\n            //output array we drop the digits and add that digit\\n            while(drop > 0 && out.size() != 0 && out.back() < num) {\\n                drop--;\\n                out.pop_back();\\n            }\\n            out.push_back(num);\\n        }\\n        out.resize(k); // this is necessary if there are more than K digits in out\\n        return out;\\n    }\\n    \\n    /*\\n      subproblem 2 = create largest number from the two lists, containing\\n      digits [0-9]. The size of output number is sum of size of two\\n      lists\\n    */\\n    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {\\n        auto start1 = nums1.begin(), end1 = nums1.end(),\\n             start2 = nums2.begin(), end2 = nums2.end();\\n        vector<int> out;\\n        while(start1 != end1 || start2 != end2) {\\n            if(lexicographical_compare(start1,end1,start2,end2)) {\\n                out.push_back(*start2++);\\n            }\\n            else {\\n                out.push_back(*start1++);\\n            }\\n        }\\n        return out;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        vector<int> best;\\n        /* \\n           The start and end range of for the \"for loop\" is computed based on\\n           number of min elements we need to pick from nums1 and number of maximum\\n           elements we can pick from nums1. if k > n2 then we must at least pick up\\n           k-n2 elements from n1\\n           \\n           \\n           Example 1\\n           consider n1 = 4 and n2 = 6 and k = 5\\n           Result can be constructed in following ways \\n           (i:0, k-i:5), (i:1, k-i:4), (i:2, k-i:3), (i:3, k-i:2), (i:4, k-i:1)\\n           where i is number of elements picked from nums1 and k-i is number of elements\\n           picked from nums2. Please note\\n           --> (i:5, k-i:0) is not valid since n1=4\\n           \\n           Example 2\\n           Now consider n1 = 6 and n2 = 4 and k = 5\\n           (i:1, k-i:4), (i:2, k-i:3), (i:3, k-i:2), (i:4, k-i:1), (i:5, k-i:0)\\n           \\n           hence starting index for i that is associated with nums1 is \\n           max(0, k-n2) (in first example k-n2 = -1, in second example k-n2 = 1)\\n           \\n           end index for i associated with nums1 is \\n           min(k,n1) (in first example i can only go up to 4 since n1 = 4, in second example\\n                      i can only go up to 5 since k = 5)\\n                      \\n          Example 3\\n          n1 = 3, n2 = 4, k = 5\\n          we must pick at least 1 element from nums1 (k-n2 = 1) also i can only go up to 3 since\\n          n1 is capped at 3\\n          \\n          Example 4\\n          \\n          n1 = 5, n2=3, k = 4\\n          we must pick up at least 1 element from nums1 (k-n2 = 1) and i can go up to 4\\n           \\n        */\\n          for(int i = max(0,k-n2); i <= min(k,n1); i++) {\\n            \\n            if(best.size() == 0) {\\n                best = maxNumber(maxNumber(nums1,i),\\n                                 maxNumber(nums2,k-i));\\n            }\\n            else {\\n                vector<int> temp = maxNumber(maxNumber(nums1,i),\\n                                             maxNumber(nums2,k-i));\\n                if(lexicographical_compare(best.begin(), best.end(),\\n                                           temp.begin(),temp.end())) {\\n                    best = temp;\\n                }\\n            }\\n            //vector class overloads \"<\" operator hence you could simply use the \\n            //statement below, above code is only to make things simple.\\n            //best = max(best,maxNumber(maxNumber(nums1,i),maxNumber(nums2,k-i)));\\n        }\\n        return best;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77284,
                "title": "easy-to-understand-greedy-c-solution-o-nmk",
                "content": "We pick optimal digit one by one. At each phase, let dp[sa] be the minimum number of elements we need to use\\nin array b, if we use sa elements in array a, in order to obtain the optimal solution so far. We look ahead to find the next optimal digit then update dp accordingly.\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n        int na = a.size(), nb =b.size();\\n        vector<int> dp(na+1);\\n        vector<int> ans;\\n        while (k) {\\n            int x = 0;\\n            for (int sa = 0; sa <= na; ++sa) if (dp[sa] <= nb && nb- dp[sa] + na - sa >=k) {\\n                for (int i = sa; i < na; ++i) if (na - i + nb- dp[sa] >= k) x = max(x,a[i]);\\n                for (int j = dp[sa]; j < nb; ++j) if (na - sa + nb - j >= k) x = max(x,b[j]);\\n            }\\n            vector<int> dp2(na+1,INT_MAX);\\n            for (int sa = 0; sa <= na; ++sa) if (dp[sa] <= nb && nb- dp[sa] + na - sa >=k) {\\n                for (int i = sa; i < na; ++i) if (na - i + nb- dp[sa] >= k) if (a[i] == x) dp2[i+1] = min(dp2[i+1], dp[sa]);\\n                for (int j = dp[sa]; j < nb; ++j) if (na - sa + nb - j >= k) if (b[j] == x) dp2[sa] = min(dp2[sa], j+1);\\n            }\\n            dp.swap(dp2);\\n            ans.push_back(x);\\n            --k;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n        int na = a.size(), nb =b.size();\\n        vector<int> dp(na+1);\\n        vector<int> ans;\\n        while (k) {\\n            int x = 0;\\n            for (int sa = 0; sa <= na; ++sa) if (dp[sa] <= nb && nb- dp[sa] + na - sa >=k) {\\n                for (int i = sa; i < na; ++i) if (na - i + nb- dp[sa] >= k) x = max(x,a[i]);\\n                for (int j = dp[sa]; j < nb; ++j) if (na - sa + nb - j >= k) x = max(x,b[j]);\\n            }\\n            vector<int> dp2(na+1,INT_MAX);\\n            for (int sa = 0; sa <= na; ++sa) if (dp[sa] <= nb && nb- dp[sa] + na - sa >=k) {\\n                for (int i = sa; i < na; ++i) if (na - i + nb- dp[sa] >= k) if (a[i] == x) dp2[i+1] = min(dp2[i+1], dp[sa]);\\n                for (int j = dp[sa]; j < nb; ++j) if (na - sa + nb - j >= k) if (b[j] == x) dp2[sa] = min(dp2[sa], j+1);\\n            }\\n            dp.swap(dp2);\\n            ans.push_back(x);\\n            --k;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77317,
                "title": "very-straight-forward-solution-yet-still-efficient-in-c",
                "content": "If you prefer performance than anything else then check this [post](https://leetcode.com/discuss/101043/efficient-solution-accepted-best-beating-16ms-well-commented). The following solution is simplified for simplicity and readability, so the performance is reduced.\\n\\n    class Solution \\n    {\\n    public:\\n        //select the maximal number in certain length within one vector;\\n        vector<int> maxVector(vector<int> nums, int k) \\n        {\\n            while (nums.size() > k) \\n            {\\n                int i = 0, n = nums.size();\\n                for (; i < n - 1; ++i)  //at least erase one element each time;\\n                {\\n                    if (nums[i] < nums[i + 1]) \\n                    {\\n                        nums.erase(nums.begin() + i);\\n                        break;\\n                    }\\n                }\\n                if (i == n - 1) nums.erase(nums.begin() + i);\\n            }\\n            return nums;\\n        }\\n    \\n        //compare two vectors from certain index adopting lexical order;\\n        //if the first vector is bigger return true otherwise return false;\\n        bool compare(vector<int> &nums1, int i, vector<int> &nums2, int j) \\n        {\\n            while (i<nums1.size() && j<nums2.size() && nums1[i]==nums2[j]) ++i, ++j;\\n            if (i<nums1.size() && j<nums2.size()) return nums1[i]>nums2[j];\\n            else if(j == nums2.size()) return true;\\n            else return false;\\n        }\\n    \\n        //get the first k numbers which form the largest lexical sequence;\\n        vector<int> merge(vector<int> &nums1, vector<int> &nums2, int k) \\n        {\\n            vector<int> res(k, 0);\\n            for (int i=0, j=0, r=0; r < k; ++r) \\n                res[r] = compare(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n            return res;\\n        }\\n    \\n        //AC - 386ms - the most intuitive solution;\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) \\n        {\\n            int len1=nums1.size(), len2=nums2.size();\\n            vector<int> v(k, 0);\\n            for (int l1 = max(0, k-len2); l1 <= min(k, len1); ++l1) \\n            {\\n                auto v1 = maxVector(nums1, l1);\\n                auto v2 = maxVector(nums2, k-l1);\\n                auto tmp = merge(v1, v2, k);\\n                if (compare(tmp, 0, v, 0)) v = tmp;\\n            }\\n            return v;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution \\n    {\\n    public:\\n        //select the maximal number in certain length within one vector;\\n        vector<int> maxVector(vector<int> nums, int k) \\n        {\\n            while (nums.size() > k) \\n            {\\n                int i = 0, n = nums.size();\\n                for (; i < n - 1; ++i)  //at least erase one element each time;\\n                {\\n                    if (nums[i] < nums[i + 1]) \\n                    {\\n                        nums.erase(nums.begin() + i);\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 77345,
                "title": "c-implementation-of-the-top-voted-answer-without-the-compare-function",
                "content": "    class Solution {\\n    private:\\n        //get the max k-length number of array nums ...\\n        vector<int> helper(vector<int>& nums, int k){\\n            int n=nums.size();\\n            int j=0; // the count of the stacked array \\n            vector<int> result(k,0);\\n            for(int i=0; i<n; i++){\\n                //result[j-1] stores the top of the stack \\n                while(j>0 && n-i+j>k && nums[i]>result[j-1])  j--;\\n                if(j<k) result[j++]=nums[i];\\n            }\\n            return result;\\n        }\\n        \\n        vector<int> merge(vector<int>& nums1, vector<int>& nums2, int k){\\n            vector<int> result(k, 0);\\n            ostringstream num_str1, num_str2;\\n            string str1, str2;\\n            for(auto num:nums1)  num_str1 << num;\\n            for(auto num:nums2)  num_str2 << num;\\n            str1=num_str1.str();\\n            str2=num_str2.str();\\n            for(int i=0, j=0, r=0; r<k; r++){\\n                result[r] = str1.substr(i).compare(str2.substr(j)) > 0 ? nums1[i++] : nums2[j++];\\n            }\\n            return result;\\n        }\\n        \\n    public:\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            int n=nums1.size(), m=nums2.size();\\n            vector<int> result(k, 0);\\n            string result_str;\\n            for(int i=max(0, k-m); i<=k && i<=n; i++){\\n                vector<int> sub_1 = helper(nums1, i);\\n                vector<int> sub_2 = helper(nums2, k-i);\\n                vector<int> candidate = merge(sub_1, sub_2, k);\\n                ostringstream str_c;\\n                for(auto number:candidate)  str_c << number;\\n                if(result_str==\"\" || str_c.str().compare(result_str) > 0 ){\\n                    result_str=str_c.str();\\n                    result=candidate;\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    private:\\n        //get the max k-length number of array nums ...\\n        vector<int> helper(vector<int>& nums, int k){\\n            int n=nums.size();\\n            int j=0; // the count of the stacked array \\n            vector<int> result(k,0);\\n            for(int i=0; i<n; i++){\\n                //result[j-1] stores the top of the stack \\n                while(j>0 && n-i+j>k && nums[i]>result[j-1])  j--;\\n                if(j<k) result[j++]=nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2856490,
                "title": "c-greedy-commented-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //function to find the maximum lexicographic sequence using monotonic stack implemented\\n    //via vector. It will give us maximum lexicographic sequence of length k.\\n    \\n    vector<int> maxLex(vector<int> nums, int k) {\\n        int N = nums.size();\\n        vector<int> res;\\n        \\n        for(int i=0; i<N; i++) {\\n            //condition to pop\\n            //the last condition ensures length k is returned\\n            while(!res.empty() and nums[i] > res.back() and k - (int)res.size() <= N - i - 1) {\\n                res.pop_back();\\n            }\\n            if(res.size() < k)\\n                res.push_back(nums[i]);\\n        }\\n        return res;\\n    }\\n    \\n    //function to return true if vector starting at a is lexicographically greater than nums2 starting at b\\n    \\n    bool greater(vector<int>& nums1, vector<int>& nums2, int a, int b) {\\n        while(a < nums1.size() or b < nums2.size()) {\\n            if(a >= nums1.size())\\n                return false;\\n            else if(b >= nums2.size())\\n                return true;\\n            else if(nums1[a] < nums2[b]) \\n                return false;\\n            else if(nums1[a] > nums2[b])\\n                return true;\\n            else \\n                ++a,++b;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans;\\n        //we are trying to generate all possible max lexicographic sequences from the two vextors\\n        //of different lengths and then we merge them and compare for maximum result\\n        for(int i=0; i<=k; i++) {\\n            int j = k - i;\\n            \\n            if(i > nums1.size() or j > nums2.size())\\n                continue;\\n            \\n            vector<int> max1 = maxLex(nums1,i);\\n            vector<int> max2 = maxLex(nums2,j);\\n            \\n            //using merge sort technique\\n            vector<int> merged;\\n            \\n            int a = 0;\\n            int b = 0;\\n            \\n            while(a < max1.size() or b < max2.size()) {\\n                if(a >= max1.size())\\n                    merged.push_back(max2[b++]);\\n                else if(b >= max2.size())\\n                    merged.push_back(max1[a++]);\\n                else if(max1[a] < max2[b]) \\n                    merged.push_back(max2[b++]);\\n                else if(max1[a] > max2[b])\\n                    merged.push_back(max1[a++]);\\n                //if we have the case where we have got the same value then we have to consider \\n                //which of the two vectors have max lexicographic sequence beginning from a and b pointers\\n                //as a max sequence will affect the answer positively and we would be pushing the result\\n                //from the vector which has a max sequence\\n                else{\\n                    if(greater(max1,max2,a,b)) {\\n                    //if max1 is greater then we enter\\n                        merged.push_back(max1[a++]);\\n                    }\\n                    else {\\n                        merged.push_back(max2[b++]);\\n                    }\\n                }\\n            }\\n            if(merged > ans)\\n                ans = merged;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //function to find the maximum lexicographic sequence using monotonic stack implemented\\n    //via vector. It will give us maximum lexicographic sequence of length k.\\n    \\n    vector<int> maxLex(vector<int> nums, int k) {\\n        int N = nums.size();\\n        vector<int> res;\\n        \\n        for(int i=0; i<N; i++) {\\n            //condition to pop\\n            //the last condition ensures length k is returned\\n            while(!res.empty() and nums[i] > res.back() and k - (int)res.size() <= N - i - 1) {\\n                res.pop_back();\\n            }\\n            if(res.size() < k)\\n                res.push_back(nums[i]);\\n        }\\n        return res;\\n    }\\n    \\n    //function to return true if vector starting at a is lexicographically greater than nums2 starting at b\\n    \\n    bool greater(vector<int>& nums1, vector<int>& nums2, int a, int b) {\\n        while(a < nums1.size() or b < nums2.size()) {\\n            if(a >= nums1.size())\\n                return false;\\n            else if(b >= nums2.size())\\n                return true;\\n            else if(nums1[a] < nums2[b]) \\n                return false;\\n            else if(nums1[a] > nums2[b])\\n                return true;\\n            else \\n                ++a,++b;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans;\\n        //we are trying to generate all possible max lexicographic sequences from the two vextors\\n        //of different lengths and then we merge them and compare for maximum result\\n        for(int i=0; i<=k; i++) {\\n            int j = k - i;\\n            \\n            if(i > nums1.size() or j > nums2.size())\\n                continue;\\n            \\n            vector<int> max1 = maxLex(nums1,i);\\n            vector<int> max2 = maxLex(nums2,j);\\n            \\n            //using merge sort technique\\n            vector<int> merged;\\n            \\n            int a = 0;\\n            int b = 0;\\n            \\n            while(a < max1.size() or b < max2.size()) {\\n                if(a >= max1.size())\\n                    merged.push_back(max2[b++]);\\n                else if(b >= max2.size())\\n                    merged.push_back(max1[a++]);\\n                else if(max1[a] < max2[b]) \\n                    merged.push_back(max2[b++]);\\n                else if(max1[a] > max2[b])\\n                    merged.push_back(max1[a++]);\\n                //if we have the case where we have got the same value then we have to consider \\n                //which of the two vectors have max lexicographic sequence beginning from a and b pointers\\n                //as a max sequence will affect the answer positively and we would be pushing the result\\n                //from the vector which has a max sequence\\n                else{\\n                    if(greater(max1,max2,a,b)) {\\n                    //if max1 is greater then we enter\\n                        merged.push_back(max1[a++]);\\n                    }\\n                    else {\\n                        merged.push_back(max2[b++]);\\n                    }\\n                }\\n            }\\n            if(merged > ans)\\n                ans = merged;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713556,
                "title": "c-94-faster-stack-solution-merge-sort-variation",
                "content": "[**321. Create Maximum Number**](https://leetcode.com/problems/create-maximum-number/)\\n\\n**`Time Complexity : O(n2)`**\\n**`Space Complexity : O(n)`**\\n\\n```\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m=nums1.size(), n=nums2.size();\\n        vector<int>res(k);\\n        for(int i=0; i<=k; i++){\\n            if(i<=m and k-i<=n){\\n                vector<int>v1=maxArray(nums1, i), v2=maxArray(nums2, k-i);\\n                vector<int>v=merge(v1,v2 , k);\\n                res=max(res, v);\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n    vector<int>merge(vector<int>&nums1 , vector<int>&nums2, int k){\\n        vector<int>v(k);\\n        for(int i=0, j=0, t=0;t<k; t++){\\n            v[t]=cmp(nums1,i, nums2, j)?nums1[i++]:nums2[j++];\\n        }\\n        return v;\\n    }\\n\\t\\n    bool cmp(vector<int>&nums1, int i, vector<int>&nums2,int j){\\n        while(i<nums1.size() and j<nums2.size() and nums1[i]==nums2[j]){\\n            i++, j++;\\n        }\\n        return j==nums2.size() or (i<nums1.size() and nums1[i]>nums2[j]);\\n    }\\n\\t\\n    vector<int>maxArray(vector<int>&nums, int k){\\n        int n=nums.size();\\n        vector<int>v;\\n        for(int i=0; i<n; i++){\\n            while(v.size()+n-i>k and !v.empty() and v.back()<nums[i])v.pop_back();\\n            if(v.size()<k)v.push_back(nums[i]);\\n        }\\n        return v;\\n    }\\n```\\n***Happy Coding :)***\\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```\\n![image](https://assets.leetcode.com/users/images/77d4616f-979f-4fd2-acdf-6cf04532de46_1665998757.740748.png)\\n",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Merge Sort"
                ],
                "code": "```\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m=nums1.size(), n=nums2.size();\\n        vector<int>res(k);\\n        for(int i=0; i<=k; i++){\\n            if(i<=m and k-i<=n){\\n                vector<int>v1=maxArray(nums1, i), v2=maxArray(nums2, k-i);\\n                vector<int>v=merge(v1,v2 , k);\\n                res=max(res, v);\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n    vector<int>merge(vector<int>&nums1 , vector<int>&nums2, int k){\\n        vector<int>v(k);\\n        for(int i=0, j=0, t=0;t<k; t++){\\n            v[t]=cmp(nums1,i, nums2, j)?nums1[i++]:nums2[j++];\\n        }\\n        return v;\\n    }\\n\\t\\n    bool cmp(vector<int>&nums1, int i, vector<int>&nums2,int j){\\n        while(i<nums1.size() and j<nums2.size() and nums1[i]==nums2[j]){\\n            i++, j++;\\n        }\\n        return j==nums2.size() or (i<nums1.size() and nums1[i]>nums2[j]);\\n    }\\n\\t\\n    vector<int>maxArray(vector<int>&nums, int k){\\n        int n=nums.size();\\n        vector<int>v;\\n        for(int i=0; i<n; i++){\\n            while(v.size()+n-i>k and !v.empty() and v.back()<nums[i])v.pop_back();\\n            if(v.size()<k)v.push_back(nums[i]);\\n        }\\n        return v;\\n    }\\n```\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2333992,
                "title": "easy-c-solution-with-full-explanation-two-stacks-with-i-k-i-sequences",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n          for(int i=0; i<=k; i++) {\\n                vector<int> s1 , s2;\\n                if(i>0) s1 = getBest(a,i);  // make i length lexographically biggest sequence possible from stack 1 \\n                if(k-i>0) s2 = getBest(b,k-i); // make k-i length lexographically biggest sequence from stack 2\\n                vector<int> s3;\\n                int m = 0 , n = 0;\\n                \\n                // take the element from corresponding stack is is lexographically bigger!\\n                while(m<s1.size() && n<s2.size()) s3.push_back((cmp(s1,s2,m,n) ? s1[m++] : s2[n++]));\\n                \\n                while(m<s1.size()) s3.push_back(s1[m++]);\\n                while(n<s2.size()) s3.push_back(s2[n++]);\\n                \\n                if(s3.size()==k) ans=max(ans,s3);\\n          }\\n         return ans;\\n    }\\n    bool cmp(vector<int>&a,vector<int>&b,int i,int j) {\\n         while(i<a.size() && j<b.size() && a[i]==b[j]) i++,j++;\\n         return (j==b.size() || ((i<(int)a.size()) && (a[i] > b[j])));\\n    }\\n    vector<int> getBest(vector<int> &a,int k) {\\n        vector<int> stk;\\n        int n = a.size();\\n        for(int i=0; i<a.size(); i++) {\\n             // a bigger element is present than current maximum & you can make a sequence >= k !\\n             while(!stk.empty() && stk.back() < a[i] && (((int)stk.size() - 1) + (n - i)) >=k) stk.pop_back();\\n             stk.push_back(a[i]);\\n        }\\n        while(stk.size() > k) stk.pop_back();\\n        return stk;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n          for(int i=0; i<=k; i++) {\\n                vector<int> s1 , s2;\\n                if(i>0) s1 = getBest(a,i);  // make i length lexographically biggest sequence possible from stack 1 \\n                if(k-i>0) s2 = getBest(b,k-i); // make k-i length lexographically biggest sequence from stack 2\\n                vector<int> s3;\\n                int m = 0 , n = 0;\\n                \\n                // take the element from corresponding stack is is lexographically bigger!\\n                while(m<s1.size() && n<s2.size()) s3.push_back((cmp(s1,s2,m,n) ? s1[m++] : s2[n++]));\\n                \\n                while(m<s1.size()) s3.push_back(s1[m++]);\\n                while(n<s2.size()) s3.push_back(s2[n++]);\\n                \\n                if(s3.size()==k) ans=max(ans,s3);\\n          }\\n         return ans;\\n    }\\n    bool cmp(vector<int>&a,vector<int>&b,int i,int j) {\\n         while(i<a.size() && j<b.size() && a[i]==b[j]) i++,j++;\\n         return (j==b.size() || ((i<(int)a.size()) && (a[i] > b[j])));\\n    }\\n    vector<int> getBest(vector<int> &a,int k) {\\n        vector<int> stk;\\n        int n = a.size();\\n        for(int i=0; i<a.size(); i++) {\\n             // a bigger element is present than current maximum & you can make a sequence >= k !\\n             while(!stk.empty() && stk.back() < a[i] && (((int)stk.size() - 1) + (n - i)) >=k) stk.pop_back();\\n             stk.push_back(a[i]);\\n        }\\n        while(stk.size() > k) stk.pop_back();\\n        return stk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243230,
                "title": "c-not-so-simple-warning-just-run-away-don-t-try-this-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> func(vector<int> &nums, int k)\\n    {\\n        vector<int> ret(k, 0);\\n        int n=nums.size();\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(ret.empty() || ret.back()>=nums[i])\\n            {\\n                if(ret.size()<k)\\n                    ret.push_back(nums[i]);\\n            }\\n            else{\\n                while(!ret.empty() && n-i>k-ret.size() && ret.back()<nums[i])\\n                    ret.pop_back();\\n                ret.push_back(nums[i]);\\n            }\\n        }\\n        return ret;\\n    }\\n    bool isGreater(vector<int> &a, vector<int> &b)\\n    {\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(b[i]>a[i])\\n                return false;\\n            else if(b[i]<a[i])\\n                return true;\\n        }\\n        return false;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> v1, v2;\\n        vector<int> ret(k, 0);\\n        for(int i=0; i<=k; i++)\\n        {\\n            if(i>nums1.size() || k-i>nums2.size())\\n                continue;\\n            vector<int> x, y;\\n            if(i)\\n                x=func(nums1, i);\\n            if(k-i)\\n                y=func(nums2, k-i);\\n            vector<int> res;\\n            int p=0, q=0, m=x.size(), n=y.size();\\n            x.push_back(0);\\n            y.push_back(0);\\n            while(p<m && q<n)\\n            {\\n                if(x[p]>y[q])\\n                    res.push_back(x[p++]);\\n                else if(x[p]<y[q])\\n                    res.push_back(y[q++]);\\n                else\\n                {\\n                    bool flag=true;\\n                    int t=1;\\n                    while(p+t<m && q+t<n && x[p+t]==y[q+t])\\n                        t++;\\n                    if(p+t>=m || (q+t<n && x[p+t]<y[q+t]))\\n                        flag=false;\\n                    if(flag)\\n                        res.push_back(x[p++]);\\n                    else\\n                        res.push_back(y[q++]);\\n                }\\n            }\\n            while(p<m)\\n                res.push_back(x[p++]);\\n            while(q<n)\\n                res.push_back(y[q++]);\\n            if(isGreater(res, ret))\\n                ret=res;\\n        }\\n        return ret;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> func(vector<int> &nums, int k)\\n    {\\n        vector<int> ret(k, 0);\\n        int n=nums.size();\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(ret.empty() || ret.back()>=nums[i])\\n            {\\n                if(ret.size()<k)\\n                    ret.push_back(nums[i]);\\n            }\\n            else{\\n                while(!ret.empty() && n-i>k-ret.size() && ret.back()<nums[i])\\n                    ret.pop_back();\\n                ret.push_back(nums[i]);\\n            }\\n        }\\n        return ret;\\n    }\\n    bool isGreater(vector<int> &a, vector<int> &b)\\n    {\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(b[i]>a[i])\\n                return false;\\n            else if(b[i]<a[i])\\n                return true;\\n        }\\n        return false;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> v1, v2;\\n        vector<int> ret(k, 0);\\n        for(int i=0; i<=k; i++)\\n        {\\n            if(i>nums1.size() || k-i>nums2.size())\\n                continue;\\n            vector<int> x, y;\\n            if(i)\\n                x=func(nums1, i);\\n            if(k-i)\\n                y=func(nums2, k-i);\\n            vector<int> res;\\n            int p=0, q=0, m=x.size(), n=y.size();\\n            x.push_back(0);\\n            y.push_back(0);\\n            while(p<m && q<n)\\n            {\\n                if(x[p]>y[q])\\n                    res.push_back(x[p++]);\\n                else if(x[p]<y[q])\\n                    res.push_back(y[q++]);\\n                else\\n                {\\n                    bool flag=true;\\n                    int t=1;\\n                    while(p+t<m && q+t<n && x[p+t]==y[q+t])\\n                        t++;\\n                    if(p+t>=m || (q+t<n && x[p+t]<y[q+t]))\\n                        flag=false;\\n                    if(flag)\\n                        res.push_back(x[p++]);\\n                    else\\n                        res.push_back(y[q++]);\\n                }\\n            }\\n            while(p<m)\\n                res.push_back(x[p++]);\\n            while(q<n)\\n                res.push_back(y[q++]);\\n            if(isGreater(res, ret))\\n                ret=res;\\n        }\\n        return ret;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467230,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        \\n        def fn(arr, k):\\n            \"\"\"Return largest sub-sequence of arr of size k.\"\"\"\\n            ans = []\\n            for i, x in enumerate(arr): \\n                while ans and ans[-1] < x and len(ans) + len(arr) - i > k: ans.pop()\\n                if len(ans) < k: ans.append(x)\\n            return ans\\n            \\n        ans = [0] * k\\n        for i in range(k+1): \\n            if k - len(nums2) <= i <= len(nums1): \\n                val1 = fn(nums1, i)\\n                val2 = fn(nums2, k-i)\\n                cand = []\\n                i1 = i2 = 0\\n                while i1 < len(val1) or i2 < len(val2): \\n                    if val1[i1:] >= val2[i2:]: \\n                        cand.append(val1[i1])\\n                        i1 += 1\\n                    else: \\n                        cand.append(val2[i2])\\n                        i2 += 1\\n                ans = max(ans, cand)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        \\n        def fn(arr, k):\\n            \"\"\"Return largest sub-sequence of arr of size k.\"\"\"\\n            ans = []\\n            for i, x in enumerate(arr): \\n                while ans and ans[-1] < x and len(ans) + len(arr) - i > k: ans.pop()\\n                if len(ans) < k: ans.append(x)\\n            return ans\\n            \\n        ans = [0] * k\\n        for i in range(k+1): \\n            if k - len(nums2) <= i <= len(nums1): \\n                val1 = fn(nums1, i)\\n                val2 = fn(nums2, k-i)\\n                cand = []\\n                i1 = i2 = 0\\n                while i1 < len(val1) or i2 < len(val2): \\n                    if val1[i1:] >= val2[i2:]: \\n                        cand.append(val1[i1])\\n                        i1 += 1\\n                    else: \\n                        cand.append(val2[i2])\\n                        i2 += 1\\n                ans = max(ans, cand)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134816,
                "title": "beginner-friendly-logic-implementation-in-java-easy-to-understand",
                "content": "Algorithm:\\nLet the arrays be arr1 and arr2\\n1. Find the maximum length of arr1 which is less than or equal to k. i.e. n <= k. Create a maximum array for this size using arr1.\\n2.  Now left length is k - n. Lets call it m, which will be the length for arr2. Create maximum array of this size using arr2.\\n\\nNow comes the main logic\\n\\n3. Start a loop \\n4. At every step decrease the size of arr1 by one and increment the size of arr2 by one, so that the sum of both sizes of array is equal to k   i.e.  n-- and m++\\n\\nSo the loop condition will become (m <= k && n>=0 && m <= arr2.length)\\n\\n5. Generate the array and merge both the arrays and store in the form of String for easy lexicographical comparison \\n\\n```\\nclass Solution {\\n\\n    String str_ans;\\n\\n    int[] build(int org[], int size) {\\n\\n        // This function is for generating maximum array\\n\\n        int res[] = new int[size];\\n        ArrayList<Integer> al = new ArrayList<>();\\n\\n        for (int i = 0; i < org.length; i++) {\\n            al.add(i);\\n        }\\n\\n        Collections.sort(al, (Integer a, Integer b) -> {\\n            return org[b] - org[a];\\n        });\\n\\n        int index = 0;\\n        int count = 0;\\n\\n        Arrays.fill(res, -1);\\n\\n        while (count < size) {\\n\\n            int cur_ind = al.get(index++);\\n            int smaller = org.length - cur_ind - 1;\\n\\n            for (int i = Math.max(0, size - smaller - 1); i < size; i++) {\\n                if (res[i] == -1) {\\n                    res[i] = cur_ind;\\n                    count++;\\n                    break;\\n                }\\n                if (res[i] > cur_ind) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < size; i++) {\\n            res[i] = org[res[i]];\\n        }\\n\\n        return res;\\n    }\\n\\n    int[] merge(int arr1[], int arr2[]) {\\n        int n = arr1.length;\\n        int m = arr2.length;\\n\\n        int res[] = new int[n + m];\\n\\n        int ind1 = 0;\\n        int ind2 = 0;\\n\\n        for (int i = 0; i < n + m; i++) {\\n            int val1 = (ind1 >= n ? -1 : arr1[ind1]);\\n            int val2 = (ind2 >= m ? -1 : arr2[ind2]);\\n\\n            if (val1 > val2) {\\n                res[i] = val1;\\n                ind1++;\\n            } else if (val2 > val1) {\\n                res[i] = val2;\\n                ind2++;\\n            } else {\\n\\n                // As both the values are equal find the first unequal element\\n\\n                int next_ind1 = ind1 + 1;\\n                int next_ind2 = ind2 + 1;\\n                while (next_ind1 < n && next_ind2 < m && arr1[next_ind1] == arr2[next_ind2]) {\\n                    next_ind1++;\\n                    next_ind2++;\\n                }\\n                if (next_ind1 == n) {\\n                    res[i] = val2;\\n                    ind2++;\\n                } else if (next_ind2 == m) {\\n                    res[i] = val1;\\n                    ind1++;\\n                } else if (arr1[next_ind1] > arr2[next_ind2]) {\\n                    res[i] = val1;\\n                    ind1++;\\n                } else {\\n                    res[i] = val2;\\n                    ind2++;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    String toString(int arr[]) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            sb.append(arr[i]);\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public int[] maxNumber(int[] arr1, int[] arr2, int k) {\\n        int ans[] = new int[k];\\n\\n        int n = Math.min(arr1.length, k);\\n        int m = k - n;\\n\\n        str_ans = \"\";\\n\\n        while (m <= k && n >= 0 && m <= arr2.length) {\\n\\n            int cur_arr1[] = build(arr1, n);\\n            int cur_arr2[] = build(arr2, m);\\n\\n            int res[] = merge(cur_arr1, cur_arr2);\\n            String str_res = toString(res);\\n\\n            if (str_res.compareTo(str_ans) > 0) {\\n                str_ans = str_res;\\n            }\\n\\n            n--;\\n            m++;\\n        }\\n\\n        char c[] = str_ans.toCharArray();\\n\\n        for (int i = 0; i < k; i++) {\\n            ans[i] = c[i] - \\'0\\';\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\nThe solution can be improved by using better logic for removing and adding of element from both the arrays in the loop avoiding the complexity to build maximum array",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    String str_ans;\\n\\n    int[] build(int org[], int size) {\\n\\n        // This function is for generating maximum array\\n\\n        int res[] = new int[size];\\n        ArrayList<Integer> al = new ArrayList<>();\\n\\n        for (int i = 0; i < org.length; i++) {\\n            al.add(i);\\n        }\\n\\n        Collections.sort(al, (Integer a, Integer b) -> {\\n            return org[b] - org[a];\\n        });\\n\\n        int index = 0;\\n        int count = 0;\\n\\n        Arrays.fill(res, -1);\\n\\n        while (count < size) {\\n\\n            int cur_ind = al.get(index++);\\n            int smaller = org.length - cur_ind - 1;\\n\\n            for (int i = Math.max(0, size - smaller - 1); i < size; i++) {\\n                if (res[i] == -1) {\\n                    res[i] = cur_ind;\\n                    count++;\\n                    break;\\n                }\\n                if (res[i] > cur_ind) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < size; i++) {\\n            res[i] = org[res[i]];\\n        }\\n\\n        return res;\\n    }\\n\\n    int[] merge(int arr1[], int arr2[]) {\\n        int n = arr1.length;\\n        int m = arr2.length;\\n\\n        int res[] = new int[n + m];\\n\\n        int ind1 = 0;\\n        int ind2 = 0;\\n\\n        for (int i = 0; i < n + m; i++) {\\n            int val1 = (ind1 >= n ? -1 : arr1[ind1]);\\n            int val2 = (ind2 >= m ? -1 : arr2[ind2]);\\n\\n            if (val1 > val2) {\\n                res[i] = val1;\\n                ind1++;\\n            } else if (val2 > val1) {\\n                res[i] = val2;\\n                ind2++;\\n            } else {\\n\\n                // As both the values are equal find the first unequal element\\n\\n                int next_ind1 = ind1 + 1;\\n                int next_ind2 = ind2 + 1;\\n                while (next_ind1 < n && next_ind2 < m && arr1[next_ind1] == arr2[next_ind2]) {\\n                    next_ind1++;\\n                    next_ind2++;\\n                }\\n                if (next_ind1 == n) {\\n                    res[i] = val2;\\n                    ind2++;\\n                } else if (next_ind2 == m) {\\n                    res[i] = val1;\\n                    ind1++;\\n                } else if (arr1[next_ind1] > arr2[next_ind2]) {\\n                    res[i] = val1;\\n                    ind1++;\\n                } else {\\n                    res[i] = val2;\\n                    ind2++;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    String toString(int arr[]) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            sb.append(arr[i]);\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public int[] maxNumber(int[] arr1, int[] arr2, int k) {\\n        int ans[] = new int[k];\\n\\n        int n = Math.min(arr1.length, k);\\n        int m = k - n;\\n\\n        str_ans = \"\";\\n\\n        while (m <= k && n >= 0 && m <= arr2.length) {\\n\\n            int cur_arr1[] = build(arr1, n);\\n            int cur_arr2[] = build(arr2, m);\\n\\n            int res[] = merge(cur_arr1, cur_arr2);\\n            String str_res = toString(res);\\n\\n            if (str_res.compareTo(str_ans) > 0) {\\n                str_ans = str_res;\\n            }\\n\\n            n--;\\n            m++;\\n        }\\n\\n        char c[] = str_ans.toCharArray();\\n\\n        for (int i = 0; i < k; i++) {\\n            ans[i] = c[i] - \\'0\\';\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127814,
                "title": "dp-greedy-faster-than-80-c-36ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans;\\n        const int m = nums1.size(), n = nums2.size();\\n        \\n        for (int i = 0; i <= k; i++) {\\n            int j = k - i;  \\n            if (i > m || j > n) continue;\\n            ans = max(ans, maxNumber(maxNumber(nums1,i),maxNumber(nums2,j)));\\n        }\\n        \\n        return ans;\\n    }\\nprivate:\\n    \\n    vector<int> maxNumber(const vector<int>& nums, int k) {\\n        if (k == 0) return {};\\n        int to_pop = nums.size() - k;\\n        vector<int> ans;\\n        for (auto &num : nums) {\\n            while (!ans.empty() && ans.back() < num && 0 < to_pop--)\\n                 ans.pop_back();\\n            ans.push_back(num);\\n        }\\n        ans.resize(k);\\n        return ans;\\n    }\\n    \\n     vector<int> maxNumber(const vector<int>& nums1,const vector<int>& nums2) {\\n        vector<int> ans;\\n        auto s1 = nums1.begin();\\n        auto e1 = nums1.end();\\n        auto s2 = nums2.begin();\\n        auto e2 = nums2.end();\\n        while (s1 != e1 || s2 != e2) {\\n            ans.push_back(lexicographical_compare(s1,e1,s2,e2)?*s2++:*s1++);\\n        }\\n         return ans;\\n     }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans;\\n        const int m = nums1.size(), n = nums2.size();\\n        \\n        for (int i = 0; i <= k; i++) {\\n            int j = k - i;  \\n            if (i > m || j > n) continue;\\n            ans = max(ans, maxNumber(maxNumber(nums1,i),maxNumber(nums2,j)));\\n        }\\n        \\n        return ans;\\n    }\\nprivate:\\n    \\n    vector<int> maxNumber(const vector<int>& nums, int k) {\\n        if (k == 0) return {};\\n        int to_pop = nums.size() - k;\\n        vector<int> ans;\\n        for (auto &num : nums) {\\n            while (!ans.empty() && ans.back() < num && 0 < to_pop--)\\n                 ans.pop_back();\\n            ans.push_back(num);\\n        }\\n        ans.resize(k);\\n        return ans;\\n    }\\n    \\n     vector<int> maxNumber(const vector<int>& nums1,const vector<int>& nums2) {\\n        vector<int> ans;\\n        auto s1 = nums1.begin();\\n        auto e1 = nums1.end();\\n        auto s2 = nums2.begin();\\n        auto e2 = nums2.end();\\n        while (s1 != e1 || s2 != e2) {\\n            ans.push_back(lexicographical_compare(s1,e1,s2,e2)?*s2++:*s1++);\\n        }\\n         return ans;\\n     }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953917,
                "title": "c-find-all-lenth-combination-of-two-then-merge-them",
                "content": "The idea is to \\n1) find max number of each single array of lenght l1, l2 first.  \\n2) Then combine them to form the final largest one.   \\n3) Then select the largest combined one. \\n\\nStep 1 and 2 are both quite tricky to get right.\\n\\n```\\nclass Solution {  \\n    \\n \\n    // 54321  // find first bottom item:  3   \\n    // nums2 = [9, 1, 2, 5, 8, 3], k=3, remain 3    \\n    vector<int> maxNumber (vector<int>& nums1, int k)\\n    {\\n        int sz= nums1.size(), remove = sz-k;\\n        vector<int> res ;\\n        // best code structure: for + while\\n        // goal: generate an all decreasing sequence: remove bottom  < next\\n        for (int i=0; i< nums1.size(); i++)\\n        {\\n            // when to pop the stack:  back< current\\n            while (res.size()>0 && res.back()< nums1[i] && remove)\\n            {\\n                res.pop_back(); remove--;             \\n            }                              \\n              res.push_back(nums1[i]);                    \\n        }                \\n\\n        // finished : res may be too many, we only need k element        \\n        // the case of all decreasing, just remove from back\\n        while (remove)\\n        {\\n            res.pop_back(); remove--; \\n        }        \\n        \\n        return res; \\n    }\\n    \\n    // merge linked list problem: but tricker to handle equal case\\n    // max len 2 : 6,5 \\n   //  max len 3 : 9 8 3\\n    vector<int> combine (vector<int>& v1, vector<int>& v2)\\n    {\\n        vector<int> res; \\n        int p1=0, p2=0;\\n        \\n        while (p1<v1.size() && p2<v2.size())\\n        {\\n        // equal? look after until not equal, pick larger one next non equal one\\n       //nums1: {6, 7}\\n      // nums2: {6, 0, 4} : mistake: naive pick larger one won\\'t work!!\\n       // look after until not equal            \\n            if (v1[p1]==v2[p2])\\n            {\\n                int p1n=p1+1, p2n=p2+1;\\n                while (p1n<v1.size() && p2n<v2.size() && v1[p1n]==v2[p2n])\\n                {\\n                    p1n++; p2n++; \\n                }\\n                // several conditions:  p1n reach the end\\n                // either one reach the end, pick any of they, No! pick the one with remains!!\\n                if (p1n==v1.size() ) \\n                {\\n                    res.push_back(v2[p2++]);    \\n                }\\n                else if  ( p2n==v2.size())\\n                    res.push_back(v1[p1++]);    \\n                else if (v1[p1n]>v2[p2n]) // first non equal element\\n                    res.push_back(v1[p1++]);    \\n                else\\n                    res.push_back(v2[p2++]);                        \\n            }\\n            else if (v1[p1]>v2[p2])\\n                res.push_back(v1[p1++]);\\n            else\\n                res.push_back(v2[p2++]);\\n        }\\n        \\n        while (p1<v1.size())\\n            res.push_back(v1[p1++]);\\n        \\n        while (p2<v2.size())\\n            res.push_back(v2[p2++]);    \\n        \\n        assert (res.size()== v1.size()+v2.size());\\n        return res;\\n    }\\n\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {       \\n      \\n          vector<int> max_res (k, 0); //min value     \\n        for (int l1=0; l1<= nums1.size(); l1++) //select 0 to max from nums1\\n        {     \\n            if (k-l1<0 ) break;    // l1 too large, we stop       \\n            if (k-l1> nums2.size()) continue;  // l1 too small, we continue\\t\\t\\t\\n            vector<int> m1= maxNumber (nums1, l1); \\n            vector<int> m2= maxNumber (nums2, k-l1);            \\n            vector<int> merge1= combine (m1, m2);          \\n\\n           if (merge1>max_res)\\n                max_res= merge1;                        \\n        }          \\n        return max_res; \\n    }\\n};\\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {  \\n    \\n \\n    // 54321  // find first bottom item:  3   \\n    // nums2 = [9, 1, 2, 5, 8, 3], k=3, remain 3    \\n    vector<int> maxNumber (vector<int>& nums1, int k)\\n    {\\n        int sz= nums1.size(), remove = sz-k;\\n        vector<int> res ;\\n        // best code structure: for + while\\n        // goal: generate an all decreasing sequence: remove bottom  < next\\n        for (int i=0; i< nums1.size(); i++)\\n        {\\n            // when to pop the stack:  back< current\\n            while (res.size()>0 && res.back()< nums1[i] && remove)\\n            {\\n                res.pop_back(); remove--;             \\n            }                              \\n              res.push_back(nums1[i]);                    \\n        }                \\n\\n        // finished : res may be too many, we only need k element        \\n        // the case of all decreasing, just remove from back\\n        while (remove)\\n        {\\n            res.pop_back(); remove--; \\n        }        \\n        \\n        return res; \\n    }\\n    \\n    // merge linked list problem: but tricker to handle equal case\\n    // max len 2 : 6,5 \\n   //  max len 3 : 9 8 3\\n    vector<int> combine (vector<int>& v1, vector<int>& v2)\\n    {\\n        vector<int> res; \\n        int p1=0, p2=0;\\n        \\n        while (p1<v1.size() && p2<v2.size())\\n        {\\n        // equal? look after until not equal, pick larger one next non equal one\\n       //nums1: {6, 7}\\n      // nums2: {6, 0, 4} : mistake: naive pick larger one won\\'t work!!\\n       // look after until not equal            \\n            if (v1[p1]==v2[p2])\\n            {\\n                int p1n=p1+1, p2n=p2+1;\\n                while (p1n<v1.size() && p2n<v2.size() && v1[p1n]==v2[p2n])\\n                {\\n                    p1n++; p2n++; \\n                }\\n                // several conditions:  p1n reach the end\\n                // either one reach the end, pick any of they, No! pick the one with remains!!\\n                if (p1n==v1.size() ) \\n                {\\n                    res.push_back(v2[p2++]);    \\n                }\\n                else if  ( p2n==v2.size())\\n                    res.push_back(v1[p1++]);    \\n                else if (v1[p1n]>v2[p2n]) // first non equal element\\n                    res.push_back(v1[p1++]);    \\n                else\\n                    res.push_back(v2[p2++]);                        \\n            }\\n            else if (v1[p1]>v2[p2])\\n                res.push_back(v1[p1++]);\\n            else\\n                res.push_back(v2[p2++]);\\n        }\\n        \\n        while (p1<v1.size())\\n            res.push_back(v1[p1++]);\\n        \\n        while (p2<v2.size())\\n            res.push_back(v2[p2++]);    \\n        \\n        assert (res.size()== v1.size()+v2.size());\\n        return res;\\n    }\\n\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {       \\n      \\n          vector<int> max_res (k, 0); //min value     \\n        for (int l1=0; l1<= nums1.size(); l1++) //select 0 to max from nums1\\n        {     \\n            if (k-l1<0 ) break;    // l1 too large, we stop       \\n            if (k-l1> nums2.size()) continue;  // l1 too small, we continue\\t\\t\\t\\n            vector<int> m1= maxNumber (nums1, l1); \\n            vector<int> m2= maxNumber (nums2, k-l1);            \\n            vector<int> merge1= combine (m1, m2);          \\n\\n           if (merge1>max_res)\\n                max_res= merge1;                        \\n        }          \\n        return max_res; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749965,
                "title": "c-faster-than-75-less-then-100-mem",
                "content": "Runtime: 316 ms\\nMemory Usage: 32.1 MB\\n\\nWhat helped me was thinking in therms of elements that needed to be removed.\\nSay you have 4 elements to remove to get to a total size of k.\\nYou can remove 0 from nums1 and 4 to nums2 or 1-3, 2-2, 3-1 or 4-0.\\nThen at each stage just merge the trimmed arrays taking care of the equal case (see code). Compare the resulting arrays to find the biggest number.\\n\\n```\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) \\n    {\\n        nums1 = Trim(nums1, k);\\n        nums2 = Trim(nums2, k);        \\n        \\n        int dif = (nums1.Length + nums2.Length) - k;\\n\\n        if (dif == 0)\\n        {\\n            return Merge(nums1, nums2, k);\\n        }\\n       \\n        int[] new1;\\n        int[] new2;\\n        int[] crnt;\\n        int[] biggest = null;\\n\\n        for (int i = dif, j = 0; i >= 0; i--, j++)\\n        {\\n            if (nums1.Length < i || nums2.Length < j) { continue; }\\n\\n            new1 = Trim(nums1, nums1.Length - i);\\n            new2 = Trim(nums2, nums2.Length - j);\\n\\n            crnt = Merge(new1, new2, k);\\n\\n            if (biggest == null) \\n            { \\n                biggest = crnt; \\n            }\\n            else\\n            {\\n                for (int s = 0; s < k; s++)\\n                {\\n                    if (biggest[s] < crnt[s]) { biggest = crnt; break; }\\n                    else if (biggest[s] > crnt[s]) { break; }\\n                }\\n            }\\n        }\\n\\n        return biggest;\\n    }\\n    \\n    private int[] Merge(int[] nums1, int[] nums2, int k)\\n    {\\n        int[] result = new int[k];\\n\\n        int i = 0;\\n        int j = 0;\\n        int p = 0;\\n\\n        int h;\\n        int g;\\n\\n        while (i < nums1.Length && j < nums2.Length)\\n        {\\n            if (nums1[i] > nums2[j])\\n            {\\n                result[p++] = nums1[i++];\\n            }\\n            else if (nums1[i] < nums2[j])\\n            {\\n                result[p++] = nums2[j++];\\n            }\\n            else\\n            {\\n                //find next non equal pair.\\n                h = i + 1;\\n                g = j + 1;\\n                while (h < nums1.Length && g < nums2.Length && nums1[h] == nums2[g])\\n                {\\n                    h++; g++;\\n                }\\n\\n                if (h == nums1.Length) { result[p++] = nums2[j++]; }\\n                else if (g == nums2.Length) { result[p++] = nums1[i++]; }\\n                else if (nums1[h] > nums2[g]) { result[p++] = nums1[i++]; }\\n                else { result[p++] = nums2[j++]; }\\n            }\\n        }\\n\\n        while (i < nums1.Length)\\n        {\\n            result[p++] = nums1[i++];\\n        }\\n\\n        while (j < nums2.Length)\\n        {\\n            result[p++] = nums2[j++];\\n        }\\n\\n        return result;\\n    }\\n         \\n    private int[] Trim(int[] nums, int k)\\n    {\\n        if (nums.Length <= k) { return nums; }\\n        \\n        int rem = nums.Length-k;\\n       \\n        Stack<int> stack = new Stack<int>();\\n        \\n        for(int i=0; i< nums.Length; i++)\\n        {\\n            if (stack.Count == 0 || rem == 0) { stack.Push(nums[i]); }\\n            else\\n            {\\n                while(stack.Count > 0 && stack.Peek() < nums[i] && rem > 0)\\n                {\\n                    stack.Pop();\\n                    rem--;\\n                }\\n                stack.Push(nums[i]);\\n            }\\n        }\\n        \\n        while (rem > 0) {  stack.Pop(); rem--;  }\\n        \\n        int[] result = new int[k];\\n        int j = k-1;\\n        while(stack.Count > 0)\\n        {\\n            result[j] = stack.Pop();\\n            j--;\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 316 ms\\nMemory Usage: 32.1 MB\\n\\nWhat helped me was thinking in therms of elements that needed to be removed.\\nSay you have 4 elements to remove to get to a total size of k.\\nYou can remove 0 from nums1 and 4 to nums2 or 1-3, 2-2, 3-1 or 4-0.\\nThen at each stage just merge the trimmed arrays taking care of the equal case (see code). Compare the resulting arrays to find the biggest number.\\n\\n```\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) \\n    {\\n        nums1 = Trim(nums1, k);\\n        nums2 = Trim(nums2, k);        \\n        \\n        int dif = (nums1.Length + nums2.Length) - k;\\n\\n        if (dif == 0)\\n        {\\n            return Merge(nums1, nums2, k);\\n        }\\n       \\n        int[] new1;\\n        int[] new2;\\n        int[] crnt;\\n        int[] biggest = null;\\n\\n        for (int i = dif, j = 0; i >= 0; i--, j++)\\n        {\\n            if (nums1.Length < i || nums2.Length < j) { continue; }\\n\\n            new1 = Trim(nums1, nums1.Length - i);\\n            new2 = Trim(nums2, nums2.Length - j);\\n\\n            crnt = Merge(new1, new2, k);\\n\\n            if (biggest == null) \\n            { \\n                biggest = crnt; \\n            }\\n            else\\n            {\\n                for (int s = 0; s < k; s++)\\n                {\\n                    if (biggest[s] < crnt[s]) { biggest = crnt; break; }\\n                    else if (biggest[s] > crnt[s]) { break; }\\n                }\\n            }\\n        }\\n\\n        return biggest;\\n    }\\n    \\n    private int[] Merge(int[] nums1, int[] nums2, int k)\\n    {\\n        int[] result = new int[k];\\n\\n        int i = 0;\\n        int j = 0;\\n        int p = 0;\\n\\n        int h;\\n        int g;\\n\\n        while (i < nums1.Length && j < nums2.Length)\\n        {\\n            if (nums1[i] > nums2[j])\\n            {\\n                result[p++] = nums1[i++];\\n            }\\n            else if (nums1[i] < nums2[j])\\n            {\\n                result[p++] = nums2[j++];\\n            }\\n            else\\n            {\\n                //find next non equal pair.\\n                h = i + 1;\\n                g = j + 1;\\n                while (h < nums1.Length && g < nums2.Length && nums1[h] == nums2[g])\\n                {\\n                    h++; g++;\\n                }\\n\\n                if (h == nums1.Length) { result[p++] = nums2[j++]; }\\n                else if (g == nums2.Length) { result[p++] = nums1[i++]; }\\n                else if (nums1[h] > nums2[g]) { result[p++] = nums1[i++]; }\\n                else { result[p++] = nums2[j++]; }\\n            }\\n        }\\n\\n        while (i < nums1.Length)\\n        {\\n            result[p++] = nums1[i++];\\n        }\\n\\n        while (j < nums2.Length)\\n        {\\n            result[p++] = nums2[j++];\\n        }\\n\\n        return result;\\n    }\\n         \\n    private int[] Trim(int[] nums, int k)\\n    {\\n        if (nums.Length <= k) { return nums; }\\n        \\n        int rem = nums.Length-k;\\n       \\n        Stack<int> stack = new Stack<int>();\\n        \\n        for(int i=0; i< nums.Length; i++)\\n        {\\n            if (stack.Count == 0 || rem == 0) { stack.Push(nums[i]); }\\n            else\\n            {\\n                while(stack.Count > 0 && stack.Peek() < nums[i] && rem > 0)\\n                {\\n                    stack.Pop();\\n                    rem--;\\n                }\\n                stack.Push(nums[i]);\\n            }\\n        }\\n        \\n        while (rem > 0) {  stack.Pop(); rem--;  }\\n        \\n        int[] result = new int[k];\\n        int j = k-1;\\n        while(stack.Count > 0)\\n        {\\n            result[j] = stack.Pop();\\n            j--;\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 77290,
                "title": "my-easy-c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<int>greatest(vector<int>nums, int k)\\n    {\\n        int leave=nums.size()-k;\\n        vector<int>great;\\n        for(auto i : nums)\\n        {\\n           while(leave && great.size() && great.back()<i)\\n           {\\n              great.pop_back();\\n               leave--;\\n           }\\n           great.push_back(i); \\n        }\\n        great.resize(k);\\n        return great;\\n    }\\n    bool check(vector<int>nums1, int i, vector<int>nums2, int j)\\n    {\\n        while(i<nums1.size() && j<nums2.size() && nums1[i]==nums2[j])\\n        {\\n            i++;\\n            j++;\\n        }\\n        if(j==nums2.size()) return true;\\n        if(i<nums1.size() && nums1[i]>nums2[j]) return true;\\n        return false;\\n    }\\n    // merge the 2 big numbers we have got in 2 vectors into 1 big possible number of size k \\n    vector<int> merge(vector<int>nums1 , vector<int>nums2,int k)\\n    {\\n        int i=0,j=0;\\n        vector<int>great(k,0);\\n        for(int l=0;l<k;l++)\\n        {\\n            great[l]=check(nums1,i,nums2,j)?nums1[i++]:nums2[j++];\\n        }\\n        return great;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        n=nums1.size();\\n        m=nums2.size();\\n        vector<int>res;\\n        for(int i=max(0,k-m);i<=min(k,n);i++)\\n        {\\n            //v1 = greatest possible number stored in vector of length i\\n            //v2 = greatest possible number stored in vector of length k-i;\\n            auto v1 =greatest(nums1,i);\\n            auto v2=greatest(nums2,k-i);\\n            auto candidate=merge(v1,v2,k);\\n            if(check(candidate,0,res,0))\\n                res=candidate;\\n        }\\n        return res;\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<int>greatest(vector<int>nums, int k)\\n    {\\n        int leave=nums.size()-k;\\n        vector<int>great;\\n        for(auto i : nums)\\n        {\\n           while(leave && great.size() && great.back()<i)\\n           {\\n              great.pop_back();\\n               leave--;\\n           }\\n           great.push_back(i); \\n        }\\n        great.resize(k);\\n        return great;\\n    }\\n    bool check(vector<int>nums1, int i, vector<int>nums2, int j)\\n    {\\n        while(i<nums1.size() && j<nums2.size() && nums1[i]==nums2[j])\\n        {\\n            i++;\\n            j++;\\n        }\\n        if(j==nums2.size()) return true;\\n        if(i<nums1.size() && nums1[i]>nums2[j]) return true;\\n        return false;\\n    }\\n    // merge the 2 big numbers we have got in 2 vectors into 1 big possible number of size k \\n    vector<int> merge(vector<int>nums1 , vector<int>nums2,int k)\\n    {\\n        int i=0,j=0;\\n        vector<int>great(k,0);\\n        for(int l=0;l<k;l++)\\n        {\\n            great[l]=check(nums1,i,nums2,j)?nums1[i++]:nums2[j++];\\n        }\\n        return great;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        n=nums1.size();\\n        m=nums2.size();\\n        vector<int>res;\\n        for(int i=max(0,k-m);i<=min(k,n);i++)\\n        {\\n            //v1 = greatest possible number stored in vector of length i\\n            //v2 = greatest possible number stored in vector of length k-i;\\n            auto v1 =greatest(nums1,i);\\n            auto v2=greatest(nums2,k-i);\\n            auto candidate=merge(v1,v2,k);\\n            if(check(candidate,0,res,0))\\n                res=candidate;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77297,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Create Maximum Number** https://leetcode.com/problems/create-maximum-number/\\n\\n**Dynamic Programming/Recursive Solution**\\n* Sketch the recursion and throw in a cache. The complexity will be O(i * j * k). \\n* The recursion is interesting in terms of the number of cases. When you have i,j, you need to think in how many different ways you can advance i and j with and without choosing nums1[i] and nums2[j]. Refer to the code, especially:\\n```\\n            self.max_number(i, j+1, k, nums1, nums2, so_far)            \\n            self.max_number(i+1, j, k, nums1, nums2, so_far)            \\n            self.max_number(i+1, j+1, k, nums1, nums2, so_far)\\n```\\n\\n```\\nclass Solution(object):\\n    def max_number(self, i, j, k, nums1, nums2, so_far):\\n        if len(so_far) == k:\\n            int_number = int(\"\".join(map(str, so_far)))\\n            if int_number > self.maximum_number:\\n                self.maximum_number = int_number\\n                self.max_list = [x for x in so_far]\\n        elif 0<=i<len(nums1) and 0<=j<len(nums2):\\n            if nums1[i] > nums2[j]:\\n                so_far.append(nums1[i])\\n                self.max_number(i+1, j, k, nums1, nums2, so_far)\\n                so_far.pop()\\n            elif nums1[i] < nums2[j]:\\n                so_far.append(nums2[j])\\n                self.max_number(i, j+1, k, nums1, nums2, so_far)\\n                so_far.pop()\\n            elif nums1[i] == nums2[j]:\\n                so_far.append(nums1[i])\\n                self.max_number(i+1, j, k, nums1, nums2, so_far)\\n                so_far.pop()                \\n                so_far.append(nums2[j])\\n                self.max_number(i, j+1, k, nums1, nums2, so_far)\\n                so_far.pop()\\n            # Ignore nums[i]    \\n            self.max_number(i, j+1, k, nums1, nums2, so_far)\\n            # ignore nums[i]\\n            self.max_number(i+1, j, k, nums1, nums2, so_far)\\n            # Ignore both\\n            self.max_number(i+1, j+1, k, nums1, nums2, so_far)\\n        elif i == len(nums1) and 0<=j<len(nums2):\\n            so_far.append(nums2[j])\\n            self.max_number(i, j+1, k, nums1, nums2, so_far)\\n            so_far.pop()\\n            self.max_number(i, j+1, k, nums1, nums2, so_far)\\n        elif j == len(nums2) and 0<=i<len(nums1):\\n            so_far.append(nums1[i])\\n            self.max_number(i+1, j, k, nums1, nums2, so_far)\\n            so_far.pop()\\n            self.max_number(i+1, j, k, nums1, nums2, so_far)\\n        return\\n    \\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        N, M = len(nums1), len(nums2)\\n        self.maximum_number, self.max_list = -2**31, None\\n        self.max_number(0, 0, k, nums1, nums2, [])\\n        return self.max_list\\n```\\n\\n**Optimized Solution using Stacks**\\n* There is a smarter solution to this problem which is a combination of 2 smaller problems. \\n* The solution to this problem will comprise of k digits, i from nums1 and k-i from nums2. \\n* Assume i were 2, then what would be the best candidate? Clearly, the answer is \"maximum number of size 2 from nums1 while keeping the relative order of the digits\". \\n* So lets call that problem as P0: \"Given an array nums and an integer n, return the maximum number of size n that can be formed from nums while keeping the relative order of digits\". Now for i=2, we will have 2 lists from nums1 and nums2 of size i and K-1. \\n* We can merge them to compute a candidate solution of size k. This will be problem P1\\n* What can be all the possible candidate solutions? Clearly when i will range from 0 to K for nums1 we will have a corresponding pair from nums2 ranging in size K to 0. Merging each of these pairs will give us the K+1 candidates. We then choose the largest from this pool and we are done!\\nhttps://discuss.leetcode.com/topic/32281/share-my-python-solution-with-explanation\\n\\nP1: Merge 2 arrays with size i and K-1 formed from nums1 and nums2 to return the maximum possible number array of size K.\\n* This is just like merge-sort merging, except when the elements are same. In that case we need to look beyond the current element (skipping all equal elements) to find the first unequal element and then pick the one which has the higher unequal element. Notice that when nums1[i] (or nums2[j]) is the last element and the value is equal to nums2[j] (or nums1[i]), we always pick the from the sublist which has elements remaining since there is a possibility of finding a greater solution.\\n```\\n                x,y = i, j\\n                while x < N and y < M and left[x] == right[y]:\\n                    x,y = x+1, y+1\\n                if x != N and y != M and left[x] > right[y]:\\n                    result.append(left[i])\\n                    i += 1\\n                elif x != N and y != M and left[x] < right[y]:\\n                    result.append(right[j])\\n                    j += 1\\n                elif x == N:\\n                    result.append(right[j])\\n                    j += 1\\n                elif y == M:\\n                    result.append(left[i])\\n                    i += 1\\n```\\n* Notice that in Python we can compare 2 lists l1 > l2 (merge_solution function) which does the above.\\n```\\n if nums1 > nums2:\\n                ans += nums1[0],\\n```\\n\\nP0: Given an array nums and an integer n, return the maximum number of size n that can be formed from nums while keeping the relative order of digits.\\n\\n**Method 1**\\n* We can maintain a stack. As long as we get input in descending order, just keep pushing on the stack. if you get a number larger than top of stack, then pop till you find a smaller number.While doing this, make sure you do not pop so much that you cannot meet the constraint of K digits. Refer to the code in max_number_list.\\n\\n**Method 2**\\n* Say the size of array is N = 10. Say K = 6. What is the maximum number that can be formed of size N = 10? Answer is the original array. What about K = 6?\\n* This problem can be stated as: \"Remove k1 (4) digits from the array to form the largest number\". This is the opposite of https://leetcode.com/problems/remove-k-digits/ where we remove K digits to form the smallest number\\n* The solution to the smallest number problem was to scan from left to right and remove the first peak element and then the next peak from the solution of previous.\\n* The solution to this problem is opposite - remove the first trough element, i.e. element which is smaller than both its left and right side!\\n\\n```\\nclass Solution(object):\\n    def max_number_list(self, nums, n):\\n        st, required_to_remove = [], len(nums)-n\\n        for idx, x in enumerate(nums):\\n            while required_to_remove and st and st[-1] < x:\\n                st.pop()\\n                required_to_remove = required_to_remove - 1\\n            st.append(x)\\n        while len(st) > n:\\n            st.pop()\\n        return st\\n    \\n    def merge(self, left, right):\\n        i, j = 0, 0\\n        N, M = len(left), len(right)\\n        result = []\\n        while i < N or j < M:\\n            if i == N:\\n                result.append(right[j])\\n                j += 1\\n            elif j == M:\\n                result.append(left[i])\\n                i += 1\\n            elif left[i] < right[j]:\\n                result.append(right[j])\\n                j += 1\\n            elif left[i] > right[j]:\\n                result.append(left[i])\\n                i += 1\\n            else:\\n                x,y = i, j\\n                while x < N and y < M and left[x] == right[y]:\\n                    x,y = x+1, y+1\\n                if x != N and y != M and left[x] > right[y]:\\n                    result.append(left[i])\\n                    i += 1\\n                elif x != N and y != M and left[x] < right[y]:\\n                    result.append(right[j])\\n                    j += 1\\n                elif x == N:\\n                    result.append(right[j])\\n                    j += 1\\n                elif y == M:\\n                    result.append(left[i])\\n                    i += 1\\n        return result\\n\\n    def merge_solution(self, nums1, nums2):\\n        ans = []\\n        while nums1 or nums2:\\n            if nums1 > nums2:\\n                ans += nums1[0],\\n                nums1 = nums1[1:]\\n            else:\\n                ans += nums2[0],\\n                nums2 = nums2[1:]\\n        return ans\\n\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        N, M = len(nums1), len(nums2)\\n        self.max_list = [0]*k\\n        for i in range(k+1):\\n            if i <= N and k-i <= M:\\n                left, right = self.max_number_list(nums1, i), self.max_number_list(nums2, k-i)\\n                merged = self.merge(left, right)\\n                for i in range(k):\\n                    if self.max_list[i] != merged[i]:\\n                        if self.max_list[i] > merged[i]:\\n                            break\\n                        elif merged[i] > self.max_list[i]:\\n                            self.max_list = merged\\n                            break\\n        return self.max_list\\n```",
                "solutionTags": [],
                "code": "```\\n            self.max_number(i, j+1, k, nums1, nums2, so_far)            \\n            self.max_number(i+1, j, k, nums1, nums2, so_far)            \\n            self.max_number(i+1, j+1, k, nums1, nums2, so_far)\\n```\n```\\nclass Solution(object):\\n    def max_number(self, i, j, k, nums1, nums2, so_far):\\n        if len(so_far) == k:\\n            int_number = int(\"\".join(map(str, so_far)))\\n            if int_number > self.maximum_number:\\n                self.maximum_number = int_number\\n                self.max_list = [x for x in so_far]\\n        elif 0<=i<len(nums1) and 0<=j<len(nums2):\\n            if nums1[i] > nums2[j]:\\n                so_far.append(nums1[i])\\n                self.max_number(i+1, j, k, nums1, nums2, so_far)\\n                so_far.pop()\\n            elif nums1[i] < nums2[j]:\\n                so_far.append(nums2[j])\\n                self.max_number(i, j+1, k, nums1, nums2, so_far)\\n                so_far.pop()\\n            elif nums1[i] == nums2[j]:\\n                so_far.append(nums1[i])\\n                self.max_number(i+1, j, k, nums1, nums2, so_far)\\n                so_far.pop()                \\n                so_far.append(nums2[j])\\n                self.max_number(i, j+1, k, nums1, nums2, so_far)\\n                so_far.pop()\\n            # Ignore nums[i]    \\n            self.max_number(i, j+1, k, nums1, nums2, so_far)\\n            # ignore nums[i]\\n            self.max_number(i+1, j, k, nums1, nums2, so_far)\\n            # Ignore both\\n            self.max_number(i+1, j+1, k, nums1, nums2, so_far)\\n        elif i == len(nums1) and 0<=j<len(nums2):\\n            so_far.append(nums2[j])\\n            self.max_number(i, j+1, k, nums1, nums2, so_far)\\n            so_far.pop()\\n            self.max_number(i, j+1, k, nums1, nums2, so_far)\\n        elif j == len(nums2) and 0<=i<len(nums1):\\n            so_far.append(nums1[i])\\n            self.max_number(i+1, j, k, nums1, nums2, so_far)\\n            so_far.pop()\\n            self.max_number(i+1, j, k, nums1, nums2, so_far)\\n        return\\n    \\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        N, M = len(nums1), len(nums2)\\n        self.maximum_number, self.max_list = -2**31, None\\n        self.max_number(0, 0, k, nums1, nums2, [])\\n        return self.max_list\\n```\n```\\n                x,y = i, j\\n                while x < N and y < M and left[x] == right[y]:\\n                    x,y = x+1, y+1\\n                if x != N and y != M and left[x] > right[y]:\\n                    result.append(left[i])\\n                    i += 1\\n                elif x != N and y != M and left[x] < right[y]:\\n                    result.append(right[j])\\n                    j += 1\\n                elif x == N:\\n                    result.append(right[j])\\n                    j += 1\\n                elif y == M:\\n                    result.append(left[i])\\n                    i += 1\\n```\n```\\n if nums1 > nums2:\\n                ans += nums1[0],\\n```\n```\\nclass Solution(object):\\n    def max_number_list(self, nums, n):\\n        st, required_to_remove = [], len(nums)-n\\n        for idx, x in enumerate(nums):\\n            while required_to_remove and st and st[-1] < x:\\n                st.pop()\\n                required_to_remove = required_to_remove - 1\\n            st.append(x)\\n        while len(st) > n:\\n            st.pop()\\n        return st\\n    \\n    def merge(self, left, right):\\n        i, j = 0, 0\\n        N, M = len(left), len(right)\\n        result = []\\n        while i < N or j < M:\\n            if i == N:\\n                result.append(right[j])\\n                j += 1\\n            elif j == M:\\n                result.append(left[i])\\n                i += 1\\n            elif left[i] < right[j]:\\n                result.append(right[j])\\n                j += 1\\n            elif left[i] > right[j]:\\n                result.append(left[i])\\n                i += 1\\n            else:\\n                x,y = i, j\\n                while x < N and y < M and left[x] == right[y]:\\n                    x,y = x+1, y+1\\n                if x != N and y != M and left[x] > right[y]:\\n                    result.append(left[i])\\n                    i += 1\\n                elif x != N and y != M and left[x] < right[y]:\\n                    result.append(right[j])\\n                    j += 1\\n                elif x == N:\\n                    result.append(right[j])\\n                    j += 1\\n                elif y == M:\\n                    result.append(left[i])\\n                    i += 1\\n        return result\\n\\n    def merge_solution(self, nums1, nums2):\\n        ans = []\\n        while nums1 or nums2:\\n            if nums1 > nums2:\\n                ans += nums1[0],\\n                nums1 = nums1[1:]\\n            else:\\n                ans += nums2[0],\\n                nums2 = nums2[1:]\\n        return ans\\n\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        N, M = len(nums1), len(nums2)\\n        self.max_list = [0]*k\\n        for i in range(k+1):\\n            if i <= N and k-i <= M:\\n                left, right = self.max_number_list(nums1, i), self.max_number_list(nums2, k-i)\\n                merged = self.merge(left, right)\\n                for i in range(k):\\n                    if self.max_list[i] != merged[i]:\\n                        if self.max_list[i] > merged[i]:\\n                            break\\n                        elif merged[i] > self.max_list[i]:\\n                            self.max_list = merged\\n                            break\\n        return self.max_list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77312,
                "title": "java-solution-with-comments-inspired-by-dietpepsi",
                "content": "It's almost the same with the solution by @dietpepsi. I changed some code and added comments to make it easier to understand.\\n\\n```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] maxNum = new int[k];\\n        for (int i = 0; i <= k; i++) {\\n            if (nums1.length >= i && nums2.length >= k-i) {\\n                int[] merged = maxMerge(maxNumberSingleArray(nums1, i), maxNumberSingleArray(nums2, k-i));\\n                if (isGreater(merged, 0, maxNum, 0)) {\\n                    maxNum = merged;\\n                }\\n            }\\n        }\\n        return maxNum;\\n    }\\n    \\n    // compute max number of a single array, given available numbers 'nums[]'' and length 'len'\\n    // assume len <= nums.length\\n    private int[] maxNumberSingleArray(int[] nums, int len) {\\n        int[] result = new int[len];\\n        int filledDigits = 0;   // number of digits already filled\\n        for (int i = 0; i < nums.length; i++) {\\n            int j = filledDigits; // default position for current digit = index of last filled digit\\n            while (j > 0 && result[j-1] < nums[i] && nums.length-i >= len-(j-1)) {\\n                // want to place larger numbers to as high digit as possible\\n                j--;\\n            }\\n            if (j < len) {\\n                result[j] = nums[i];\\n                filledDigits = j+1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    // merge two number arrays to create a maximum number array\\n    // want to use digits from the array with the higher lexicographical order\\n    private int[] maxMerge(int[] arr1, int[] arr2) {\\n        int len = arr1.length + arr2.length;\\n        int[] result = new int[len];\\n        int i = 0, j = 0, k = 0;\\n        while (k < len) {\\n            result[k++] = isGreater(arr1, i, arr2, j) ? arr1[i++] : arr2[j++];\\n        }\\n        return result;\\n    }\\n    \\n    // compare which array contains a larger number, returns < 0 if arr1 < arr2, == 0 if equal, > 0 if arr1 > arr2\\n    private boolean isGreater(int[] arr1, int i, int[] arr2, int j) {\\n        while (i < arr1.length && j < arr2.length && arr1[i] == arr2[j]) {\\n            i++;\\n            j++;\\n        }\\n        // arr1 is lexicographically greater if it has a longer length, or  has a digit greater than the digit as same place in arr2\\n        return i < arr1.length && j == arr2.length || (i < arr1.length && j < arr2.length && arr1[i] > arr2[j]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] maxNum = new int[k];\\n        for (int i = 0; i <= k; i++) {\\n            if (nums1.length >= i && nums2.length >= k-i) {\\n                int[] merged = maxMerge(maxNumberSingleArray(nums1, i), maxNumberSingleArray(nums2, k-i));\\n                if (isGreater(merged, 0, maxNum, 0)) {\\n                    maxNum = merged;\\n                }\\n            }\\n        }\\n        return maxNum;\\n    }\\n    \\n    // compute max number of a single array, given available numbers 'nums[]'' and length 'len'\\n    // assume len <= nums.length\\n    private int[] maxNumberSingleArray(int[] nums, int len) {\\n        int[] result = new int[len];\\n        int filledDigits = 0;   // number of digits already filled\\n        for (int i = 0; i < nums.length; i++) {\\n            int j = filledDigits; // default position for current digit = index of last filled digit\\n            while (j > 0 && result[j-1] < nums[i] && nums.length-i >= len-(j-1)) {\\n                // want to place larger numbers to as high digit as possible\\n                j--;\\n            }\\n            if (j < len) {\\n                result[j] = nums[i];\\n                filledDigits = j+1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    // merge two number arrays to create a maximum number array\\n    // want to use digits from the array with the higher lexicographical order\\n    private int[] maxMerge(int[] arr1, int[] arr2) {\\n        int len = arr1.length + arr2.length;\\n        int[] result = new int[len];\\n        int i = 0, j = 0, k = 0;\\n        while (k < len) {\\n            result[k++] = isGreater(arr1, i, arr2, j) ? arr1[i++] : arr2[j++];\\n        }\\n        return result;\\n    }\\n    \\n    // compare which array contains a larger number, returns < 0 if arr1 < arr2, == 0 if equal, > 0 if arr1 > arr2\\n    private boolean isGreater(int[] arr1, int i, int[] arr2, int j) {\\n        while (i < arr1.length && j < arr2.length && arr1[i] == arr2[j]) {\\n            i++;\\n            j++;\\n        }\\n        // arr1 is lexicographically greater if it has a longer length, or  has a digit greater than the digit as same place in arr2\\n        return i < arr1.length && j == arr2.length || (i < arr1.length && j < arr2.length && arr1[i] > arr2[j]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77319,
                "title": "beats-100-00-of-python-submissions-surprisingly",
                "content": "It's a tough way to solve this problem.\\n\\nMy solution is trying to construct the answer.\\n\\n1. At first, using dp[i][j][k] as a set to record the state, which means the k-length result from arr1[i:] and arr[j:]. But got TLE.\\n2. After that, trying to pre-process loc[i][x] to locate the digit x in arr[i:]. But still TLE.\\n3. Finally, handling the case when l1+l2 == k. Got AC.\\n\\nI think the complexity maybe O((m+n+k)*10), since the number of answer is k*10.\\n\\nHere is my code. 128ms in py.\\n\\n    ### 321. Create Maximum Number ###\\n    # @param {integer[]} nums1\\n    # @param {integer[]} nums2\\n    # @param {integer} k\\n    # @return {integer[]}\\n    def maxNumber(self, nums1, nums2, k):\\n        if not k or len(nums1)+len(nums2)<k: return []\\n    \\n        loc1 = [[-1]*10 for _ in range(len(nums1)+1)]\\n        loc2 = [[-1]*10 for _ in range(len(nums2)+1)]\\n        l12 = len(nums1)+len(nums2)\\n        vis, res = set(), [-1]*k\\n    \\n        def make(nums, loc):\\n            pos = [-1]*10\\n            for i in xrange(len(nums)-1,-1,-1):\\n                pos[nums[i]] = i\\n                for j in range(10):\\n                    loc[i][j] = pos[j]\\n    \\n        make(nums1, loc1)\\n        make(nums2, loc2)\\n    \\n        def compare(p1, p2):\\n            if p2 == len(nums2): return 1\\n            if p1 == len(nums1): return 2\\n            if nums1[p1] > nums2[p2]: return 1\\n            if nums1[p1] < nums2[p2]: return 2\\n            return compare(p1+1, p2+1)\\n    \\n        def dfs(p1, p2, k):\\n            if k == 0 or (p1, p2, k) in vis: return\\n    \\n            if l12 == p1+p2+k:\\n                flag, update = True, False\\n                while flag and k>0:\\n                    if compare(p1, p2) == 1:\\n                        if res[-k] <= nums1[p1] or update:\\n                            if res[-k] < nums1[p1]: update = True\\n                            res[-k] = nums1[p1]\\n                            p1 += 1\\n                        else: flag = False\\n                    else:\\n                        if res[-k] <= nums2[p2] or update:\\n                            if res[-k] < nums2[p2]: update = True\\n                            res[-k] = nums2[p2]\\n                            p2 += 1\\n                        else: flag = False\\n                    k -= 1\\n            else:\\n                flag = False\\n                for i in range(9,-1,-1):\\n                    if loc1[p1][i] != -1:\\n                        if l12-loc1[p1][i]-p2 >= k and res[-k] <= i:\\n                            if res[-k] < i: res[-k:] = [-1]*k\\n                            res[-k] = i\\n                            dfs(loc1[p1][i]+1, p2, k-1)\\n                            flag = True\\n                    if loc2[p2][i] != -1:\\n                        if l12-p1-loc2[p2][i] >= k and res[-k] <= i:\\n                            if res[-k] < i: res[-k:] = [-1]*k\\n                            res[-k] = i\\n                            dfs(p1, loc2[p2][i]+1, k-1)\\n                            flag = True\\n                    if flag: break\\n            vis.add((p1, p2, k))\\n    \\n        dfs(0, 0, k)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "It's a tough way to solve this problem.\\n\\nMy solution is trying to construct the answer.\\n\\n1. At first, using dp[i][j][k] as a set to record the state, which means the k-length result from arr1[i:] and arr[j:]. But got TLE.\\n2. After that, trying to pre-process loc[i][x] to locate the digit x in arr[i:]. But still TLE.\\n3. Finally, handling the case when l1+l2 == k. Got AC.\\n\\nI think the complexity maybe O((m+n+k)*10), since the number of answer is k*10.\\n\\nHere is my code. 128ms in py.\\n\\n    ### 321. Create Maximum Number ###\\n    # @param {integer[]} nums1\\n    # @param {integer[]} nums2\\n    # @param {integer} k\\n    # @return {integer[]}\\n    def maxNumber(self, nums1, nums2, k):\\n        if not k or len(nums1)+len(nums2)<k: return []\\n    \\n        loc1 = [[-1]*10 for _ in range(len(nums1)+1)]\\n        loc2 = [[-1]*10 for _ in range(len(nums2)+1)]\\n        l12 = len(nums1)+len(nums2)\\n        vis, res = set(), [-1]*k\\n    \\n        def make(nums, loc):\\n            pos = [-1]*10\\n            for i in xrange(len(nums)-1,-1,-1):\\n                pos[nums[i]] = i\\n                for j in range(10):\\n                    loc[i][j] = pos[j]\\n    \\n        make(nums1, loc1)\\n        make(nums2, loc2)\\n    \\n        def compare(p1, p2):\\n            if p2 == len(nums2): return 1\\n            if p1 == len(nums1): return 2\\n            if nums1[p1] > nums2[p2]: return 1\\n            if nums1[p1] < nums2[p2]: return 2\\n            return compare(p1+1, p2+1)\\n    \\n        def dfs(p1, p2, k):\\n            if k == 0 or (p1, p2, k) in vis: return\\n    \\n            if l12 == p1+p2+k:\\n                flag, update = True, False\\n                while flag and k>0:\\n                    if compare(p1, p2) == 1:\\n                        if res[-k] <= nums1[p1] or update:\\n                            if res[-k] < nums1[p1]: update = True\\n                            res[-k] = nums1[p1]\\n                            p1 += 1\\n                        else: flag = False\\n                    else:\\n                        if res[-k] <= nums2[p2] or update:\\n                            if res[-k] < nums2[p2]: update = True\\n                            res[-k] = nums2[p2]\\n                            p2 += 1\\n                        else: flag = False\\n                    k -= 1\\n            else:\\n                flag = False\\n                for i in range(9,-1,-1):\\n                    if loc1[p1][i] != -1:\\n                        if l12-loc1[p1][i]-p2 >= k and res[-k] <= i:\\n                            if res[-k] < i: res[-k:] = [-1]*k\\n                            res[-k] = i\\n                            dfs(loc1[p1][i]+1, p2, k-1)\\n                            flag = True\\n                    if loc2[p2][i] != -1:\\n                        if l12-p1-loc2[p2][i] >= k and res[-k] <= i:\\n                            if res[-k] < i: res[-k:] = [-1]*k\\n                            res[-k] = i\\n                            dfs(p1, loc2[p2][i]+1, k-1)\\n                            flag = True\\n                    if flag: break\\n            vis.add((p1, p2, k))\\n    \\n        dfs(0, 0, k)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 77341,
                "title": "java-17-ms-o-n-m-k-2-or-3-worst-case-merge-with-lazy-computation",
                "content": "I must admit I found this problem the most difficult so far, and I've solved more than 80 already.\\n\\nAt first my idea was very similar to [this solution][1], which I think is the most awesome so far, but I wasn't able to get it right.\\n\\nSo in the end I had to look up solutions, and I usually don't do that. But once I saw the most common type of solutions so far, I was able to use some of my earlier ideas and came up with this:\\n\\n    public int[] maxNumber(int[] nums1, int[] nums2, final int k) {\\n        if (k > nums1.length + nums2.length)\\n            throw new IllegalArgumentException(\"k=\" + k + \" n=\" + nums1.length + \" m=\" + nums2.length);\\n        int[][] digitPositions1 = findDigitPositions(nums1);\\n        int[][] digitPositions2 = findDigitPositions(nums2);\\n        Merger best = null;\\n        final int l1start = nums2.length >= k ? 0 : k - nums2.length;\\n        final int l1end = Math.min(k, nums1.length);\\n        // Will now try to get the largest sequences of digits from nums1, nums2 of lengths l1, (k - l1)\\n        // and merge them. The largest merge result will be the answer.\\n        for (int l1 = l1start; l1 <= l1end; ++l1) {\\n            MaxFinder res1 = new MaxFinder(nums1, l1, k, digitPositions1);\\n            MaxFinder res2 = new MaxFinder(nums2, k - l1, k, digitPositions2);\\n            Merger merger = new Merger(res1, res2, k);\\n            if (best == null || merger.compareTo(best) > 0) {\\n                best = merger;\\n            }\\n        }\\n        assert best != null;\\n        return best.toIntArray();\\n    }\\n\\n    private static int[][] findDigitPositions(int[] nums) {\\n        int[][] digitPositions = new int[nums.length][];\\n        int[] pos = new int[10];\\n        Arrays.fill(pos, -1);\\n        for (int i = nums.length - 1; i >= 0; --i) {\\n            pos[nums[i]] = i;\\n            digitPositions[i] = Arrays.copyOf(pos, pos.length);\\n        }\\n        return digitPositions;\\n    }\\n    \\n    private static class Merger implements Comparable<Merger> {\\n        private final MaxFinder seq1;\\n        private final MaxFinder seq2;\\n        private final int k; // total length\\n        private final int[] output;\\n        private int outPos = 0, inPos1 = 0, inPos2 = 0;\\n\\n        Merger(MaxFinder seq1, MaxFinder seq2, int k) {\\n            this.seq1 = seq1;\\n            this.seq2 = seq2;\\n            this.k = k;\\n            this.output = new int[k];\\n        }\\n        \\n        int get(int i) {\\n            while (outPos <= i) {\\n                if (seq1.compareTo(seq2) >= 0) {\\n                    output[outPos++] = seq1.get(inPos1++);\\n                } else {\\n                    output[outPos++] = seq2.get(inPos2++);\\n                }\\n            }\\n            return output[i];\\n        }\\n        \\n        @Override\\n        public int compareTo(Merger that) {\\n            for (int i = 0; i < k; ++i) {\\n                int v1 = this.get(i), v2 = that.get(i);\\n                if (v1 > v2) {\\n                    return +1;\\n                } else if (v1 < v2) {\\n                    return -1;\\n                }\\n            }\\n            return 0;\\n        }\\n        \\n        int[] toIntArray() {\\n            get(k - 1); // complete generation\\n            return output;\\n        }\\n    }\\n    \\n    private static class MaxFinder implements Comparable<MaxFinder> {\\n        private final int[] input;\\n        private final int k; // total length of two sequences, needed for comparison caching\\n        private final int[][] digitPositions; // computed by findDigitPositions\\n        private final int[] output;\\n        private final int[] lastDiffPos;\\n        private int inPos = 0, outPos = 0;\\n        private int nextIndex = 0;\\n        \\n        MaxFinder(int[] nums, int length, int k, int[][] digitPositions) {\\n            this.input = nums;\\n            this.k = k;\\n            this.digitPositions = digitPositions;\\n            this.output = new int[length];\\n            this.lastDiffPos = new int[2 * k + 1];\\n        }\\n        \\n        int get(int i) {\\n            this.nextIndex = i + 1; // If we need to compare with the other sequence, here is where we should start.\\n            return compute(i);\\n        }\\n        \\n        // helper for get and compareTo\\n        private int compute(int i) {\\n            while (outPos <= i) {\\n                // Look for the next best digit.\\n                for (int d = 9; d >= 0; --d) {\\n                    final int nextDigitPos = digitPositions[inPos][d];\\n                    // The digit must satisfy two conditions:\\n                    // 1. It must be out there somewhere (obviously).\\n                    // 2. There must be enough digits after it, or we may end up running out of digits too soon.\\n                    if (nextDigitPos != -1 && input.length - (nextDigitPos + 1) >= output.length - outPos - 1) {\\n                        output[outPos++] = d;\\n                        inPos = digitPositions[inPos][d] + 1;\\n                        break;\\n                    }\\n                }\\n            }\\n            return output[i];\\n        }\\n        \\n        @Override\\n        public int compareTo(MaxFinder that) {\\n            final int cacheIndex = k + (this.nextIndex - that.nextIndex);\\n            // We can use the cached position if there is one, but only if we haven't advanced past the last found\\n            // difference position (which is stored in the cache).\\n            if (lastDiffPos[cacheIndex] != 0 && lastDiffPos[cacheIndex] >= this.nextIndex) {\\n                int lastDiffPos1 = lastDiffPos[cacheIndex];\\n                int lastDiffPos2 = lastDiffPos1 + (that.nextIndex - this.nextIndex);\\n                if (lastDiffPos1 < this.output.length && lastDiffPos2 < that.output.length) {\\n                    return Integer.compare(this.output[lastDiffPos1], that.output[lastDiffPos2]);\\n                } else {\\n                    return Integer.compare(this.output.length - this.nextIndex, that.output.length - that.nextIndex);\\n                }\\n            }\\n            // No luck in the cache.\\n            final int end = Math.min(this.output.length - this.nextIndex, that.output.length - that.nextIndex);\\n            int result = 0;\\n            for (int i = 0; i < end; ++i) {\\n                result = this.compute(this.nextIndex + i) - that.compute(that.nextIndex + i);\\n                if (result != 0) {\\n                    lastDiffPos[cacheIndex] = this.nextIndex + i;\\n                    break;\\n                }\\n            }\\n            if (result == 0) {\\n                lastDiffPos[cacheIndex] = this.nextIndex + end;\\n                return Integer.compare(this.output.length - this.nextIndex, that.output.length - that.nextIndex);\\n            } else {\\n                return result;\\n            }\\n        }\\n    }\\n\\nThe code is quite verbose, but the ideas are pretty simple:\\n\\n1. Precompute the table of digit positions so we don't have to search for the next best digit (only have to try from 9 to 0).\\n2. Compute everything lazily. We don't know in advance how many digits we need to compare two sequences, so why generate them fully? The same thing for merging.\\n3. Cache comparison results. When we've already compared two sequences, we don't want to compare them again if we advance both positions by the same amount. Although some suffix tables would probably be better (maybe compute them lazily too).\\n\\nThe resulting code runs in 17 ms. The code without improvements 2\\u20133 ran for 26 ms, but then I introduced classes and it was 37 ms (because local variables moved to heap?). So these improvements turned 37 to 17, actually. Moving back to local variables will probably improve a lot, but the code would be a real mess.\\n\\nP. S. I'm not exactly sure: doesn't this comparison caching technique essentially replaces the suffix array and reduces the complexity to O(n + m + k^2). On the 500/500/500 case `MaxFinder::get` is called 575356 times which is of order (500^2) * 2.\\n\\n  [1]: https://leetcode.com/discuss/75655/strictly-o-nk-c-solution-with-detailed-explanation",
                "solutionTags": [
                    "Java"
                ],
                "code": "I must admit I found this problem the most difficult so far, and I've solved more than 80 already.\\n\\nAt first my idea was very similar to [this solution][1], which I think is the most awesome so far, but I wasn't able to get it right.\\n\\nSo in the end I had to look up solutions, and I usually don't do that. But once I saw the most common type of solutions so far, I was able to use some of my earlier ideas and came up with this:\\n\\n    public int[] maxNumber(int[] nums1, int[] nums2, final int k) {\\n        if (k > nums1.length + nums2.length)\\n            throw new IllegalArgumentException(\"k=\" + k + \" n=\" + nums1.length + \" m=\" + nums2.length);\\n        int[][] digitPositions1 = findDigitPositions(nums1);\\n        int[][] digitPositions2 = findDigitPositions(nums2);\\n        Merger best = null;\\n        final int l1start = nums2.length >= k ? 0 : k - nums2.length;\\n        final int l1end = Math.min(k, nums1.length);\\n        // Will now try to get the largest sequences of digits from nums1, nums2 of lengths l1, (k - l1)\\n        // and merge them. The largest merge result will be the answer.\\n        for (int l1 = l1start; l1 <= l1end; ++l1) {\\n            MaxFinder res1 = new MaxFinder(nums1, l1, k, digitPositions1);\\n            MaxFinder res2 = new MaxFinder(nums2, k - l1, k, digitPositions2);\\n            Merger merger = new Merger(res1, res2, k);\\n            if (best == null || merger.compareTo(best) > 0) {\\n                best = merger;\\n            }\\n        }\\n        assert best != null;\\n        return best.toIntArray();\\n    }\\n\\n    private static int[][] findDigitPositions(int[] nums) {\\n        int[][] digitPositions = new int[nums.length][];\\n        int[] pos = new int[10];\\n        Arrays.fill(pos, -1);\\n        for (int i = nums.length - 1; i >= 0; --i) {\\n            pos[nums[i]] = i;\\n            digitPositions[i] = Arrays.copyOf(pos, pos.length);\\n        }\\n        return digitPositions;\\n    }\\n    \\n    private static class Merger implements Comparable<Merger> {\\n        private final MaxFinder seq1;\\n        private final MaxFinder seq2;\\n        private final int k; // total length\\n        private final int[] output;\\n        private int outPos = 0, inPos1 = 0, inPos2 = 0;\\n\\n        Merger(MaxFinder seq1, MaxFinder seq2, int k) {\\n            this.seq1 = seq1;\\n            this.seq2 = seq2;\\n            this.k = k;\\n            this.output = new int[k];\\n        }\\n        \\n        int get(int i) {\\n            while (outPos <= i) {\\n                if (seq1.compareTo(seq2) >= 0) {\\n                    output[outPos++] = seq1.get(inPos1++);\\n                } else {\\n                    output[outPos++] = seq2.get(inPos2++);\\n                }\\n            }\\n            return output[i];\\n        }\\n        \\n        @Override\\n        public int compareTo(Merger that) {\\n            for (int i = 0; i < k; ++i) {\\n                int v1 = this.get(i), v2 = that.get(i);\\n                if (v1 > v2) {\\n                    return +1;\\n                } else if (v1 < v2) {\\n                    return -1;\\n                }\\n            }\\n            return 0;\\n        }\\n        \\n        int[] toIntArray() {\\n            get(k - 1); // complete generation\\n            return output;\\n        }\\n    }\\n    \\n    private static class MaxFinder implements Comparable<MaxFinder> {\\n        private final int[] input;\\n        private final int k; // total length of two sequences, needed for comparison caching\\n        private final int[][] digitPositions; // computed by findDigitPositions\\n        private final int[] output;\\n        private final int[] lastDiffPos;\\n        private int inPos = 0, outPos = 0;\\n        private int nextIndex = 0;\\n        \\n        MaxFinder(int[] nums, int length, int k, int[][] digitPositions) {\\n            this.input = nums;\\n            this.k = k;\\n            this.digitPositions = digitPositions;\\n            this.output = new int[length];\\n            this.lastDiffPos = new int[2 * k + 1];\\n        }\\n        \\n        int get(int i) {\\n            this.nextIndex = i + 1; // If we need to compare with the other sequence, here is where we should start.\\n            return compute(i);\\n        }\\n        \\n        // helper for get and compareTo\\n        private int compute(int i) {\\n            while (outPos <= i) {\\n                // Look for the next best digit.\\n                for (int d = 9; d >= 0; --d) {\\n                    final int nextDigitPos = digitPositions[inPos][d];\\n                    // The digit must satisfy two conditions:\\n                    // 1. It must be out there somewhere (obviously).\\n                    // 2. There must be enough digits after it, or we may end up running out of digits too soon.\\n                    if (nextDigitPos != -1 && input.length - (nextDigitPos + 1) >= output.length - outPos - 1) {\\n                        output[outPos++] = d;\\n                        inPos = digitPositions[inPos][d] + 1;\\n                        break;\\n                    }\\n                }\\n            }\\n            return output[i];\\n        }\\n        \\n        @Override\\n        public int compareTo(MaxFinder that) {\\n            final int cacheIndex = k + (this.nextIndex - that.nextIndex);\\n            // We can use the cached position if there is one, but only if we haven't advanced past the last found\\n            // difference position (which is stored in the cache).\\n            if (lastDiffPos[cacheIndex] != 0 && lastDiffPos[cacheIndex] >= this.nextIndex) {\\n                int lastDiffPos1 = lastDiffPos[cacheIndex];\\n                int lastDiffPos2 = lastDiffPos1 + (that.nextIndex - this.nextIndex);\\n                if (lastDiffPos1 < this.output.length && lastDiffPos2 < that.output.length) {\\n                    return Integer.compare(this.output[lastDiffPos1], that.output[lastDiffPos2]);\\n                } else {\\n                    return Integer.compare(this.output.length - this.nextIndex, that.output.length - that.nextIndex);\\n                }\\n            }\\n            // No luck in the cache.\\n            final int end = Math.min(this.output.length - this.nextIndex, that.output.length - that.nextIndex);\\n            int result = 0;\\n            for (int i = 0; i < end; ++i) {\\n                result = this.compute(this.nextIndex + i) - that.compute(that.nextIndex + i);\\n                if (result != 0) {\\n                    lastDiffPos[cacheIndex] = this.nextIndex + i;\\n                    break;\\n                }\\n            }\\n            if (result == 0) {\\n                lastDiffPos[cacheIndex] = this.nextIndex + end;\\n                return Integer.compare(this.output.length - this.nextIndex, that.output.length - that.nextIndex);\\n            } else {\\n                return result;\\n            }\\n        }\\n    }\\n\\nThe code is quite verbose, but the ideas are pretty simple:\\n\\n1. Precompute the table of digit positions so we don't have to search for the next best digit (only have to try from 9 to 0).\\n2. Compute everything lazily. We don't know in advance how many digits we need to compare two sequences, so why generate them fully? The same thing for merging.\\n3. Cache comparison results. When we've already compared two sequences, we don't want to compare them again if we advance both positions by the same amount. Although some suffix tables would probably be better (maybe compute them lazily too).\\n\\nThe resulting code runs in 17 ms. The code without improvements 2\\u20133 ran for 26 ms, but then I introduced classes and it was 37 ms (because local variables moved to heap?). So these improvements turned 37 to 17, actually. Moving back to local variables will probably improve a lot, but the code would be a real mess.\\n\\nP. S. I'm not exactly sure: doesn't this comparison caching technique essentially replaces the suffix array and reduces the complexity to O(n + m + k^2). On the 500/500/500 case `MaxFinder::get` is called 575356 times which is of order (500^2) * 2.\\n\\n  [1]: https://leetcode.com/discuss/75655/strictly-o-nk-c-solution-with-detailed-explanation",
                "codeTag": "Java"
            },
            {
                "id": 77352,
                "title": "92ms-cpp-try-first-biggest-num-with-index-pre-process",
                "content": "The basic idea is to find the largest number in answer array's first position: try number from 9 to 0, firstly in nums1: if a number can be found, check if the left numbers (minus numbers before the found number) are sufficient for k.\\n\\nIf we can find a largest number in both nums1 and nums2, we should compare the two answers, and keep the bigger one.\\n\\nA fast pre-process for above solution: for i-th element in array nums1, lowPos1[i][num] is the smallest index of num in range [i, nums1.size()-1]. Since we have this helper, we can use O(1) time to find if num exists in nums1 or nums2 from a given position.\\n\\nAn important special case: when nums1.size() + nums2.size() = k, which means we have to use all elements in both arrays to produce the k-length answer. In such case, set two pointers pointing to the beginning of two arrays. Move the pointer with bigger number. Tricky part is when two pointers point to a same value, in this case we detect the values in two arrays behind the two pointers; we move the two pointers together until we find the values are different or one array is ended. The pointer with bigger value should go first, and if one pointer gets to end of array, the other pointer should go first.\\n\\n\\n    class Solution {\\n    public:\\n        unordered_map<string, vector<int>> store;\\n        deque<vector<int>> lowPos1, lowPos2;\\n        int len1, len2;\\n        \\n        vector<int> get(int p1, int p2, int k, vector<int>& nums1, vector<int>& nums2) {\\n            vector<int> ans;\\n            if (k==0)\\n                return ans;\\n            \\n            char buf[50];\\n            sprintf(buf, \"%d.%d.%d\", p1, p2, k);\\n            string key = buf;\\n            if (store.find(key) != store.end())\\n                return store[key];\\n            \\n            int rest = nums1.size()-p1 + nums2.size()-p2;\\n            if (k==rest) {\\n                while (p1<len1 || p2<len2)\\n                {\\n                    if (p1==len1 || (p2<len2 && nums1[p1] < nums2[p2]))\\n                        ans.push_back(nums2[p2++]);\\n                    else if (p2==len2 || (p1<len1 && nums1[p1] > nums2[p2]))\\n                        ans.push_back(nums1[p1++]);\\n                    else {\\n                        int i=0;\\n                        while (p1+i<len1 && p2+i<len2) {\\n                            if (nums1[p1+i] != nums2[p2+i])\\n                                break;\\n                            i++;\\n                        }\\n                        if (p1+i==len1 || (p2+i<len2 && nums2[p2+i]>nums1[p1+i]))\\n                            ans.push_back(nums2[p2++]);\\n                        else\\n                            ans.push_back(nums1[p1++]);\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for (int i=9; i>=0; i--) \\n                {\\n                    vector<int> ans1, ans2;\\n                    int j = p1==len1 ? -1 : lowPos1[p1][i];\\n                    if (j!=-1 && rest-(j-p1)-1 >= k-1)\\n                    {\\n                        ans1.push_back(i);\\n                        vector<int> temp = get(j+1, p2, k-1, nums1, nums2);\\n                        ans1.insert(ans1.end(), temp.begin(), temp.end());\\n                    }\\n                    \\n                    j = p2==len2 ? -1 : lowPos2[p2][i];\\n                    if (j!=-1 && rest-(j-p2)-1 >= k-1)\\n                    {\\n                        ans2.push_back(i);\\n                        vector<int> temp = get(p1, j+1, k-1, nums1, nums2);\\n                        ans2.insert(ans2.end(), temp.begin(), temp.end());\\n                    }\\n        \\n                    if (ans1.size() + ans2.size())\\n                    {\\n                        if (ans1.size() < ans2.size())\\n                            std::swap(ans1, ans2);\\n                        bool use1=true;\\n                        for (int i=0; i<min(ans1.size(), ans2.size()); i++)\\n                            if (ans2[i] != ans1[i]) {\\n                                use1 = ans1[i]>ans2[i];\\n                                break;\\n                            }\\n                        ans = use1 ? ans1 : ans2;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            store[key] = ans;\\n            return ans;\\n        }\\n        \\n        void preProcess(deque<vector<int>>& lowPos, const vector<int>& nums) {\\n            lowPos.push_back(vector<int> (10, -1));\\n            for (int i=(int)nums.size()-1; i>=0; i--) {\\n                lowPos.push_front(lowPos.front());\\n                lowPos.front()[nums[i]] = i;\\n            }\\n            lowPos.pop_back();\\n        }\\n        \\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            len1=nums1.size(), len2=nums2.size();\\n            preProcess(lowPos1, nums1);\\n            preProcess(lowPos2, nums2);\\n            \\n            return get(0, 0, k, nums1, nums2);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        unordered_map<string, vector<int>> store;\\n        deque<vector<int>> lowPos1, lowPos2;\\n        int len1, len2;\\n        \\n        vector<int> get(int p1, int p2, int k, vector<int>& nums1, vector<int>& nums2) {\\n            vector<int> ans;\\n            if (k==0)\\n                return ans;\\n            \\n            char buf[50];\\n            sprintf(buf, \"%d.%d.%d\", p1, p2, k);\\n            string key = buf;\\n            if (store.find(key) != store.end())\\n                return store[key];\\n            \\n            int rest = nums1.size()-p1 + nums2.size()-p2;\\n            if (k==rest) {\\n                while (p1<len1 || p2<len2)\\n                {\\n                    if (p1==len1 || (p2<len2 && nums1[p1] < nums2[p2]))\\n                        ans.push_back(nums2[p2++]);\\n                    else if (p2==len2 || (p1<len1 && nums1[p1] > nums2[p2]))\\n                        ans.push_back(nums1[p1++]);\\n                    else {\\n                        int i=0;\\n                        while (p1+i<len1 && p2+i<len2) {\\n                            if (nums1[p1+i] != nums2[p2+i])\\n                                break;\\n                            i++;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3592041,
                "title": "easy-understanding-and-readable-code-monotonic-stack-c",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI will find lexographically greatest subsequence from both array and then merge them.\\nBut constraint is length=k must be satisfied. So have to find lexographically greater subsequence such that both combinedly have length k.\\n\\nBut how to decide how much length have to take from first array and how much from second array? --> This time go by bruteforce. So for possible {i, k-i} pair of length , we will find our answer.\\n\\nlet\\'s divide the problem into subparts:\\nsubpart-1: find out lexographically greatest subsequence from both array.\\nsubpart-2: Merge them and keep taking maximum.\\n\\nImplemented stack logic through array. You can go through stack .\\n# Complexity\\n- Time complexity:O(K*N + K*N)= O(K*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(K) => for this loop: for(int i=0;i<=k;i++) in maxNumber function.\\nO(N) => for getGrtrSubseq function.\\nO(K*N) => merge Function.\\n- Space complexity: O(N) as all are linear vectors.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Function to calculate maximum number from nums of  requiredLength.\\n    vector<int> getGrtrSubseq(vector<int> nums, int requiredLength)\\n    {\\n        vector<int> ans; // Store the resultant maximum\\n        int n = nums.size();\\n        // i will try to maximize initial digit as much as i can. If falling for shorter length, then i am forced to take last requiredLength-ans.size()\\n        //elements left. So, before popping any element check ((requiredLength-ans.size())<(n-i)) to ensure you have requiredLength of digits.\\n        for(int i=0;i<n;i++)\\n        {\\n            while(ans.size()>0 && ans.back()<nums[i] && ((requiredLength-ans.size())<(n-i))) // If true, then pop out the last element\\n            ans.pop_back();\\n            if(ans.size()<requiredLength)ans.push_back(nums[i]); \\n        }\\n        return ans;\\n    }\\n    void pop_front(std::vector<int> &v)\\n    {\\n        if (v.size() > 0)v.erase(v.begin());\\n    }\\n    vector<int> merge(vector<int> p1, vector<int>p2, int k)\\n    {\\n        vector<int> temp;\\n        for(int j=0;j<k;j++)\\n        { \\n            vector<int> temp2 = max(p1,p2);\\n            int fr = temp2.front();\\n            if(p1>p2)\\n            pop_front(p1);\\n            else\\n            pop_front(p2);\\n            temp.push_back(fr);\\n        }\\n      return temp;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n1=nums1.size(), n2=nums2.size();\\n        vector<int>res;\\n        for(int i=0;i<=k;i++)\\n        {\\n            if(i>n1 || k-i>n2) continue;\\n            vector<int>grtrSubseq1=getGrtrSubseq(nums1,i);; \\n            vector<int>grtrSubseq2=getGrtrSubseq(nums2,k-i); \\n            vector<int>temp=merge(grtrSubseq1,grtrSubseq2,k);      \\n            res = max(res, temp);\\n        }\\n        return res;\\n    }\\n};\\n```\\n.![download (2).jpg](https://assets.leetcode.com/users/images/8eac6c0a-55fa-4b53-abd4-45a92c342e39_1685777059.4901643.jpeg)\\n\\nCorrect me if i am wrong.\\n",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to calculate maximum number from nums of  requiredLength.\\n    vector<int> getGrtrSubseq(vector<int> nums, int requiredLength)\\n    {\\n        vector<int> ans; // Store the resultant maximum\\n        int n = nums.size();\\n        // i will try to maximize initial digit as much as i can. If falling for shorter length, then i am forced to take last requiredLength-ans.size()\\n        //elements left. So, before popping any element check ((requiredLength-ans.size())<(n-i)) to ensure you have requiredLength of digits.\\n        for(int i=0;i<n;i++)\\n        {\\n            while(ans.size()>0 && ans.back()<nums[i] && ((requiredLength-ans.size())<(n-i))) // If true, then pop out the last element\\n            ans.pop_back();\\n            if(ans.size()<requiredLength)ans.push_back(nums[i]); \\n        }\\n        return ans;\\n    }\\n    void pop_front(std::vector<int> &v)\\n    {\\n        if (v.size() > 0)v.erase(v.begin());\\n    }\\n    vector<int> merge(vector<int> p1, vector<int>p2, int k)\\n    {\\n        vector<int> temp;\\n        for(int j=0;j<k;j++)\\n        { \\n            vector<int> temp2 = max(p1,p2);\\n            int fr = temp2.front();\\n            if(p1>p2)\\n            pop_front(p1);\\n            else\\n            pop_front(p2);\\n            temp.push_back(fr);\\n        }\\n      return temp;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n1=nums1.size(), n2=nums2.size();\\n        vector<int>res;\\n        for(int i=0;i<=k;i++)\\n        {\\n            if(i>n1 || k-i>n2) continue;\\n            vector<int>grtrSubseq1=getGrtrSubseq(nums1,i);; \\n            vector<int>grtrSubseq2=getGrtrSubseq(nums2,k-i); \\n            vector<int>temp=merge(grtrSubseq1,grtrSubseq2,k);      \\n            res = max(res, temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319525,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    #define MIN(a,b) (a<b?a:b)\\n    #define MAX(a,b) (a>b?a:b)\\n    void getMax(int* num, int& len, int* result, int& t, int& sortedLen)\\n    {\\n    \\tint n, top = 0;\\n    \\tresult[0] = num[0];\\n    \\tconst int need2drop = len - t;\\n    \\tfor (int i = 1; i < len; ++i){\\n    \\t\\tn = num[i];\\n    \\t\\twhile (top >= 0 && result[top] < n && (i - top) <= need2drop) --top;\\n    \\t\\tif (i - top > need2drop){\\n    \\t\\t\\tsortedLen = MAX(1,top);\\n    \\t\\t\\twhile (++top < t) result[top] = num[i++];\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tif (++top < t) result[top] = n;\\n    \\t\\telse top = t - 1;\\n    \\t}\\n    }\\n    void dp(int *num, int len, int&sortedLen, int& minL, int& maxL, int *res, int &k){\\n    \\tint  j, *head, *prevhead = res;\\n    \\tconst int soi = sizeof(int);\\n    \\tgetMax(num, len, res, maxL,sortedLen);\\n    \\tfor (int l = maxL; l > MAX(minL,1); --l){\\n    \\t\\thead = prevhead + k;\\n    \\t\\tmemcpy(head, prevhead, l*soi);\\n    \\t\\tfor (j = sortedLen; j < l; ++j){\\n    \\t\\t\\tif (head[j] > head[j - 1]){\\n    \\t\\t\\t\\tsortedLen = MAX(1, j - 1);\\n    \\t\\t\\t\\tmemcpy(head + j - 1, prevhead + j, soi*(l - j));\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif (j == l) sortedLen = l;\\n    \\t\\tprevhead = head;\\n    \\t}\\n    }\\n    void merge(int* num1,int len1,int* num2,int len2,int* result,int& resSize){\\n    \\tint i = 0, j = 0, k = 0;\\n    \\twhile (i < resSize){\\n    \\t\\tif (j < len1 && k < len2){\\n    \\t\\t\\tif (num1[j] > num2[k])\\n    \\t\\t\\t\\tresult[i++] = num1[j++];\\n    \\t\\t\\telse if (num1[j] < num2[k])\\n    \\t\\t\\t\\tresult[i++] = num2[k++];\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tint remaining1 = len1 - j, remaining2 = len2 - k, tmp = num1[j];\\n    \\t\\t\\t\\tint flag = memcmp(num1 + j, num2 + k, sizeof(int) * MIN(remaining1, remaining2));\\n    \\t\\t\\t\\tflag = (flag == 0 ? (remaining1>remaining2 ? 1 : -1) : flag);\\n    \\t\\t\\t\\tint * num = flag > 0 ? num1 : num2;\\n    \\t\\t\\t\\tint & cnt = flag > 0 ? j : k;\\n    \\t\\t\\t\\tint len = flag > 0 ? len1 : len2;\\n    \\t\\t\\t\\twhile (num[cnt]==tmp && cnt < len && i<resSize) result[i++] = num[cnt++];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\telse if (j < len1) result[i++] = num1[j++];\\n    \\t\\telse result[i++] = num2[k++];\\n    \\t}\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k){\\n    \\tint soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size(), step = k*soi;\\n    \\tint minL1 = MAX(0, k - len2), maxL1 = MIN(k, len1), minL2 = k - maxL1, maxL2 = k - minL1, range = maxL1 - minL1 + 1;\\n    \\tint * res = new int[range * k * 2 + 2 * k], *dp1 = res + k, *dp2 = res + range*k+k, *tmp=res+range*2*k+k;\\n    \\tmemset(res, 0, step);\\n    \\tint sortedLen1 = 1, sortedLen2 = 1;\\n    \\tif (len1 == 0 && len2 > 0) getMax(&nums2[0], len2, res, k, sortedLen2);\\n    \\telse if (len1 > 0 && len2 == 0) getMax(&nums1[0], len1, res, k, sortedLen2);\\n    \\telse if (len1 > 0 && len2 > 0){\\n    \\t\\tdp(&nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k);\\n    \\t\\tdp(&nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k);\\n    \\t\\tif (sortedLen1 + sortedLen2 > k){\\n    \\t\\t\\tmerge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, tmp, k);\\n    \\t\\t\\tvector<int> resv(tmp, tmp + k);\\n    \\t\\t\\tdelete[] res;\\n    \\t\\t\\treturn resv;\\n    \\t\\t}\\n    \\t\\tfor (int i = minL1; i <= maxL1; ++i){\\n    \\t\\t\\tmerge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k);\\n    \\t\\t\\tif (memcmp(res, tmp, step) < 0) memcpy(res, tmp, step);\\n    \\t\\t}\\n    \\t}\\n    \\tvector<int> resv(res, res + k);\\n    \\tdelete[] res;\\n    \\treturn resv;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n            \\n        def get_max_subarray(nums, k):\\n            stack = []\\n            drop = len(nums) - k\\n            for num in nums:\\n                while drop and stack and stack[-1] < num:\\n                    stack.pop()\\n                    drop -= 1\\n                stack.append(num)\\n            return stack[:k]\\n\\n        max_num = []\\n\\n        for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\\n            max_subarray1 = get_max_subarray(nums1, i)\\n            max_subarray2 = get_max_subarray(nums2, k - i)\\n\\n            candidate = []\\n            while max_subarray1 or max_subarray2:\\n                if max_subarray1 > max_subarray2:\\n                    candidate.append(max_subarray1.pop(0))\\n                else:\\n                    candidate.append(max_subarray2.pop(0))\\n\\n            if candidate > max_num:\\n                max_num = candidate\\n\\n        return max_num\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\n    int m = nums1.length, n = nums2.length;\\n    int[] ans = new int[k];\\n    \\n    for (int i = Math.max(0, k-n); i <= Math.min(k, m); i++) {\\n        int j = k - i;\\n        int[] maxNum1 = getMax(nums1, i);\\n        int[] maxNum2 = getMax(nums2, j);\\n        int[] merged = merge(maxNum1, maxNum2);\\n        if (compare(merged, 0, ans, 0) > 0) {\\n            ans = merged;\\n        }\\n    }\\n    return ans;\\n}\\nprivate int[] getMax(int[] nums, int k) {\\n    int n = nums.length;\\n    int[] stack = new int[k];\\n    int top = -1, remaining = n - k;\\n    \\n    for (int i = 0; i < n; i++) {\\n        int num = nums[i];\\n        while (top >= 0 && stack[top] < num && remaining > 0) {\\n            top--;\\n            remaining--;\\n        }\\n        if (top < k - 1) {\\n            stack[++top] = num;\\n        } else {\\n            remaining--;\\n        }\\n    }\\n    return stack;\\n}\\nprivate int[] merge(int[] nums1, int[] nums2) {\\n    int m = nums1.length, n = nums2.length;\\n    int[] merged = new int[m + n];\\n    int i = 0, j = 0, k = 0;\\n    \\n    while (i < m && j < n) {\\n        if (compare(nums1, i, nums2, j) > 0) {\\n            merged[k++] = nums1[i++];\\n        } else {\\n            merged[k++] = nums2[j++];\\n        }\\n    }\\n    while (i < m) {\\n        merged[k++] = nums1[i++];\\n    }\\n    while (j < n) {\\n        merged[k++] = nums2[j++];\\n    }\\n    return merged;\\n}\\nprivate int compare(int[] nums1, int i, int[] nums2, int j) {\\n    int m = nums1.length, n = nums2.length;\\n    while (i < m && j < n) {\\n        int diff = nums1[i] - nums2[j];\\n        if (diff != 0) {\\n            return diff;\\n        }\\n        i++;\\n        j++;\\n    }\\n    return (m - i) - (n - j);\\n}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    #define MIN(a,b) (a<b?a:b)\\n    #define MAX(a,b) (a>b?a:b)\\n    void getMax(int* num, int& len, int* result, int& t, int& sortedLen)\\n    {\\n    \\tint n, top = 0;\\n    \\tresult[0] = num[0];\\n    \\tconst int need2drop = len - t;\\n    \\tfor (int i = 1; i < len; ++i){\\n    \\t\\tn = num[i];\\n    \\t\\twhile (top >= 0 && result[top] < n && (i - top) <= need2drop) --top;\\n    \\t\\tif (i - top > need2drop){\\n    \\t\\t\\tsortedLen = MAX(1,top);\\n    \\t\\t\\twhile (++top < t) result[top] = num[i++];\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tif (++top < t) result[top] = n;\\n    \\t\\telse top = t - 1;\\n    \\t}\\n    }\\n    void dp(int *num, int len, int&sortedLen, int& minL, int& maxL, int *res, int &k){\\n    \\tint  j, *head, *prevhead = res;\\n    \\tconst int soi = sizeof(int);\\n    \\tgetMax(num, len, res, maxL,sortedLen);\\n    \\tfor (int l = maxL; l > MAX(minL,1); --l){\\n    \\t\\thead = prevhead + k;\\n    \\t\\tmemcpy(head, prevhead, l*soi);\\n    \\t\\tfor (j = sortedLen; j < l; ++j){\\n    \\t\\t\\tif (head[j] > head[j - 1]){\\n    \\t\\t\\t\\tsortedLen = MAX(1, j - 1);\\n    \\t\\t\\t\\tmemcpy(head + j - 1, prevhead + j, soi*(l - j));\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif (j == l) sortedLen = l;\\n    \\t\\tprevhead = head;\\n    \\t}\\n    }\\n    void merge(int* num1,int len1,int* num2,int len2,int* result,int& resSize){\\n    \\tint i = 0, j = 0, k = 0;\\n    \\twhile (i < resSize){\\n    \\t\\tif (j < len1 && k < len2){\\n    \\t\\t\\tif (num1[j] > num2[k])\\n    \\t\\t\\t\\tresult[i++] = num1[j++];\\n    \\t\\t\\telse if (num1[j] < num2[k])\\n    \\t\\t\\t\\tresult[i++] = num2[k++];\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tint remaining1 = len1 - j, remaining2 = len2 - k, tmp = num1[j];\\n    \\t\\t\\t\\tint flag = memcmp(num1 + j, num2 + k, sizeof(int) * MIN(remaining1, remaining2));\\n    \\t\\t\\t\\tflag = (flag == 0 ? (remaining1>remaining2 ? 1 : -1) : flag);\\n    \\t\\t\\t\\tint * num = flag > 0 ? num1 : num2;\\n    \\t\\t\\t\\tint & cnt = flag > 0 ? j : k;\\n    \\t\\t\\t\\tint len = flag > 0 ? len1 : len2;\\n    \\t\\t\\t\\twhile (num[cnt]==tmp && cnt < len && i<resSize) result[i++] = num[cnt++];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\telse if (j < len1) result[i++] = num1[j++];\\n    \\t\\telse result[i++] = num2[k++];\\n    \\t}\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k){\\n    \\tint soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size(), step = k*soi;\\n    \\tint minL1 = MAX(0, k - len2), maxL1 = MIN(k, len1), minL2 = k - maxL1, maxL2 = k - minL1, range = maxL1 - minL1 + 1;\\n    \\tint * res = new int[range * k * 2 + 2 * k], *dp1 = res + k, *dp2 = res + range*k+k, *tmp=res+range*2*k+k;\\n    \\tmemset(res, 0, step);\\n    \\tint sortedLen1 = 1, sortedLen2 = 1;\\n    \\tif (len1 == 0 && len2 > 0) getMax(&nums2[0], len2, res, k, sortedLen2);\\n    \\telse if (len1 > 0 && len2 == 0) getMax(&nums1[0], len1, res, k, sortedLen2);\\n    \\telse if (len1 > 0 && len2 > 0){\\n    \\t\\tdp(&nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k);\\n    \\t\\tdp(&nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k);\\n    \\t\\tif (sortedLen1 + sortedLen2 > k){\\n    \\t\\t\\tmerge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, tmp, k);\\n    \\t\\t\\tvector<int> resv(tmp, tmp + k);\\n    \\t\\t\\tdelete[] res;\\n    \\t\\t\\treturn resv;\\n    \\t\\t}\\n    \\t\\tfor (int i = minL1; i <= maxL1; ++i){\\n    \\t\\t\\tmerge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k);\\n    \\t\\t\\tif (memcmp(res, tmp, step) < 0) memcpy(res, tmp, step);\\n    \\t\\t}\\n    \\t}\\n    \\tvector<int> resv(res, res + k);\\n    \\tdelete[] res;\\n    \\treturn resv;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n            \\n        def get_max_subarray(nums, k):\\n            stack = []\\n            drop = len(nums) - k\\n            for num in nums:\\n                while drop and stack and stack[-1] < num:\\n                    stack.pop()\\n                    drop -= 1\\n                stack.append(num)\\n            return stack[:k]\\n\\n        max_num = []\\n\\n        for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\\n            max_subarray1 = get_max_subarray(nums1, i)\\n            max_subarray2 = get_max_subarray(nums2, k - i)\\n\\n            candidate = []\\n            while max_subarray1 or max_subarray2:\\n                if max_subarray1 > max_subarray2:\\n                    candidate.append(max_subarray1.pop(0))\\n                else:\\n                    candidate.append(max_subarray2.pop(0))\\n\\n            if candidate > max_num:\\n                max_num = candidate\\n\\n        return max_num\\n```\n```Java []\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\n    int m = nums1.length, n = nums2.length;\\n    int[] ans = new int[k];\\n    \\n    for (int i = Math.max(0, k-n); i <= Math.min(k, m); i++) {\\n        int j = k - i;\\n        int[] maxNum1 = getMax(nums1, i);\\n        int[] maxNum2 = getMax(nums2, j);\\n        int[] merged = merge(maxNum1, maxNum2);\\n        if (compare(merged, 0, ans, 0) > 0) {\\n            ans = merged;\\n        }\\n    }\\n    return ans;\\n}\\nprivate int[] getMax(int[] nums, int k) {\\n    int n = nums.length;\\n    int[] stack = new int[k];\\n    int top = -1, remaining = n - k;\\n    \\n    for (int i = 0; i < n; i++) {\\n        int num = nums[i];\\n        while (top >= 0 && stack[top] < num && remaining > 0) {\\n            top--;\\n            remaining--;\\n        }\\n        if (top < k - 1) {\\n            stack[++top] = num;\\n        } else {\\n            remaining--;\\n        }\\n    }\\n    return stack;\\n}\\nprivate int[] merge(int[] nums1, int[] nums2) {\\n    int m = nums1.length, n = nums2.length;\\n    int[] merged = new int[m + n];\\n    int i = 0, j = 0, k = 0;\\n    \\n    while (i < m && j < n) {\\n        if (compare(nums1, i, nums2, j) > 0) {\\n            merged[k++] = nums1[i++];\\n        } else {\\n            merged[k++] = nums2[j++];\\n        }\\n    }\\n    while (i < m) {\\n        merged[k++] = nums1[i++];\\n    }\\n    while (j < n) {\\n        merged[k++] = nums2[j++];\\n    }\\n    return merged;\\n}\\nprivate int compare(int[] nums1, int i, int[] nums2, int j) {\\n    int m = nums1.length, n = nums2.length;\\n    while (i < m && j < n) {\\n        int diff = nums1[i] - nums2[j];\\n        if (diff != 0) {\\n            return diff;\\n        }\\n        i++;\\n        j++;\\n    }\\n    return (m - i) - (n - j);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948100,
                "title": "c-dynamic-programming-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nm)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(nm)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string findMaxNum(vector<int>& nums1, vector<int>& nums2, int k, int x, int y, vector<vector<string>>& dp) {\\n        if (k == 0) return \"\";\\n        if (!dp[x][y].empty()) return dp[x][y];\\n        string res = \"\";\\n        int idx1 = x, idx2 = y, upperBound1 = nums2.size() + nums1.size() - y - k, upperBound2 = nums2.size() + nums1.size() - x - k;\\n        if (upperBound1 > nums1.size() - 1) upperBound1 = nums1.size() - 1;\\n        if (upperBound2 > nums2.size() - 1) upperBound2 = nums2.size() - 1;\\n        for (int i = x; i <= upperBound1; ++ i) if (nums1[i] > nums1[idx1]) idx1 = i;\\n        for (int i = y; i <= upperBound2; ++ i) if (nums2[i] > nums2[idx2]) idx2 = i;\\n        if (idx1 < nums1.size() && idx2 < nums2.size()) {\\n            if (nums1[idx1] >= nums2[idx2]) res = to_string(nums1[idx1]) + findMaxNum(nums1, nums2, k - 1, idx1 + 1, y, dp);\\n            if (nums1[idx1] <= nums2[idx2]) res = max(res, to_string(nums2[idx2]) + findMaxNum(nums1, nums2, k - 1, x, idx2 + 1, dp));\\n        } \\n        else if (idx1 < nums1.size()) res = to_string(nums1[idx1]) + findMaxNum(nums1, nums2, k - 1, idx1 + 1, y, dp);\\n        else if (idx2 < nums2.size()) res = to_string(nums2[idx2]) + findMaxNum(nums1, nums2, k - 1, x, idx2 + 1, dp);\\n        dp[x][y] = res;\\n        return res;\\n\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<string>> dp(nums1.size() + 1, vector<string>(nums2.size() + 1));\\n        string maxNum = findMaxNum(nums1, nums2, k, 0, 0, dp);\\n        vector<int> res;\\n        for (char c : maxNum) res.push_back(c - \\'0\\');\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findMaxNum(vector<int>& nums1, vector<int>& nums2, int k, int x, int y, vector<vector<string>>& dp) {\\n        if (k == 0) return \"\";\\n        if (!dp[x][y].empty()) return dp[x][y];\\n        string res = \"\";\\n        int idx1 = x, idx2 = y, upperBound1 = nums2.size() + nums1.size() - y - k, upperBound2 = nums2.size() + nums1.size() - x - k;\\n        if (upperBound1 > nums1.size() - 1) upperBound1 = nums1.size() - 1;\\n        if (upperBound2 > nums2.size() - 1) upperBound2 = nums2.size() - 1;\\n        for (int i = x; i <= upperBound1; ++ i) if (nums1[i] > nums1[idx1]) idx1 = i;\\n        for (int i = y; i <= upperBound2; ++ i) if (nums2[i] > nums2[idx2]) idx2 = i;\\n        if (idx1 < nums1.size() && idx2 < nums2.size()) {\\n            if (nums1[idx1] >= nums2[idx2]) res = to_string(nums1[idx1]) + findMaxNum(nums1, nums2, k - 1, idx1 + 1, y, dp);\\n            if (nums1[idx1] <= nums2[idx2]) res = max(res, to_string(nums2[idx2]) + findMaxNum(nums1, nums2, k - 1, x, idx2 + 1, dp));\\n        } \\n        else if (idx1 < nums1.size()) res = to_string(nums1[idx1]) + findMaxNum(nums1, nums2, k - 1, idx1 + 1, y, dp);\\n        else if (idx2 < nums2.size()) res = to_string(nums2[idx2]) + findMaxNum(nums1, nums2, k - 1, x, idx2 + 1, dp);\\n        dp[x][y] = res;\\n        return res;\\n\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<string>> dp(nums1.size() + 1, vector<string>(nums2.size() + 1));\\n        string maxNum = findMaxNum(nums1, nums2, k, 0, 0, dp);\\n        vector<int> res;\\n        for (char c : maxNum) res.push_back(c - \\'0\\');\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862803,
                "title": "python-1-hard-2-easy-1-medium-problems",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf there is only one array, how to solve it, use monotonic stack.\\nIf we can find subarray in nums1 and nums2, then merge them.\\nThe ans is all combinations of the merge\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmonotonic stack is a medium problem\\nmerge is an easy one\\nfind combination should be an easy problem.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nk* O(n^2)\\n\\nmonotonic stack is O(n)\\nmerge is O(n)\\nk loops\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def getMaxOrder(nums, n, total, res): # monotonic stack\\n            for i, v in enumerate(nums):\\n                while res and len(res) + total - i > n and res[-1] < v:\\n                    res.pop()\\n                if len(res) < n:\\n                    res.append(nums[i])\\n            return res\\n\\n        def merge(nums1, nums2, ans): # check lexicographically greater\\n            while nums1 or nums2:\\n                if nums1 > nums2:\\n                    ans.append(nums1[0])\\n                    nums1 = nums1[1:]\\n                else:\\n                    ans.append(nums2[0])\\n                    nums2 = nums2[1:]\\n            return ans\\n\\n        n1, n2 = len(nums1), len(nums2)\\n        res = []\\n        for i in range(max(0, k - n2), min(k, n1) + 1): # find all combinations of nums1 and nums2\\n            ans = merge(getMaxOrder(nums1, i, n1, []), getMaxOrder(nums2, k - i, n2, []), [])\\n            res = max(ans, res)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def getMaxOrder(nums, n, total, res): # monotonic stack\\n            for i, v in enumerate(nums):\\n                while res and len(res) + total - i > n and res[-1] < v:\\n                    res.pop()\\n                if len(res) < n:\\n                    res.append(nums[i])\\n            return res\\n\\n        def merge(nums1, nums2, ans): # check lexicographically greater\\n            while nums1 or nums2:\\n                if nums1 > nums2:\\n                    ans.append(nums1[0])\\n                    nums1 = nums1[1:]\\n                else:\\n                    ans.append(nums2[0])\\n                    nums2 = nums2[1:]\\n            return ans\\n\\n        n1, n2 = len(nums1), len(nums2)\\n        res = []\\n        for i in range(max(0, k - n2), min(k, n1) + 1): # find all combinations of nums1 and nums2\\n            ans = merge(getMaxOrder(nums1, i, n1, []), getMaxOrder(nums2, k - i, n2, []), [])\\n            res = max(ans, res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346274,
                "title": "runtime-216-ms-memory-usage-14-2-mb",
                "content": "![image](https://assets.leetcode.com/users/images/4243db7e-d5e7-4b56-bfb0-03ae0972896b_1659018972.6834903.png)\\n\\n```\\nclass Solution:\\n    def maxNumber(self, n_1: List[int], n_2: List[int], k: int) -> List[int]:\\n        def f1(maxum,s1,s2):\\n            n1, n2 = -1, -1\\n            if M - s1 > maxum: n1 = max(n_1[s1:s1+maxum])\\n            elif s1 < M: n1 = max(n_1[s1:])\\n                \\n            if N - s2 > maxum: n2 = max(n_2[s2:s2+maxum])\\n            elif s2 < N: n2 = max(n_2[s2:])\\n            return n1,n2\\n\\n        M, N = len(n_1), len(n_2)\\n        r, l = [], [[0,0]]\\n        for x in range(k):\\n            n_l, n_r = [], []\\n            for st in l:\\n                n1, n2 = f1(M + N - st[0] - st[1] - k + 1 + x , st[0], st[1])\\n                if n1 > n2:\\n                    n_r.append(n1)\\n                    n_l.append([st[0]+n_1[st[0]:].index(n1)+1,st[1]])\\n                elif n1 < n2:\\n                    n_r.append(n2)\\n                    n_l.append([st[0],st[1]+n_2[st[1]:].index(n2)+1])\\n                elif n1 == n2 and n1 != -1:\\n                    n_r.append(n1)\\n                    n_l.append([st[0]+n_1[st[0]:].index(n1)+1,st[1]])\\n                    n_r.append(n2)\\n                    n_l.append([st[0],st[1]+n_2[st[1]:].index(n1)+1])\\n            nr = -1\\n            for i in range(len(n_r)):\\n                if n_r[i] > nr: n_n_l = set(); n_n_l.add((n_l[i][0],n_l[i][1])); nr = n_r[i]\\n                elif n_r[i] == nr: n_n_l.add((n_l[i][0],n_l[i][1]))\\n            r.append(nr)\\n            l = n_n_l\\n        return r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, n_1: List[int], n_2: List[int], k: int) -> List[int]:\\n        def f1(maxum,s1,s2):\\n            n1, n2 = -1, -1\\n            if M - s1 > maxum: n1 = max(n_1[s1:s1+maxum])\\n            elif s1 < M: n1 = max(n_1[s1:])\\n                \\n            if N - s2 > maxum: n2 = max(n_2[s2:s2+maxum])\\n            elif s2 < N: n2 = max(n_2[s2:])\\n            return n1,n2\\n\\n        M, N = len(n_1), len(n_2)\\n        r, l = [], [[0,0]]\\n        for x in range(k):\\n            n_l, n_r = [], []\\n            for st in l:\\n                n1, n2 = f1(M + N - st[0] - st[1] - k + 1 + x , st[0], st[1])\\n                if n1 > n2:\\n                    n_r.append(n1)\\n                    n_l.append([st[0]+n_1[st[0]:].index(n1)+1,st[1]])\\n                elif n1 < n2:\\n                    n_r.append(n2)\\n                    n_l.append([st[0],st[1]+n_2[st[1]:].index(n2)+1])\\n                elif n1 == n2 and n1 != -1:\\n                    n_r.append(n1)\\n                    n_l.append([st[0]+n_1[st[0]:].index(n1)+1,st[1]])\\n                    n_r.append(n2)\\n                    n_l.append([st[0],st[1]+n_2[st[1]:].index(n1)+1])\\n            nr = -1\\n            for i in range(len(n_r)):\\n                if n_r[i] > nr: n_n_l = set(); n_n_l.add((n_l[i][0],n_l[i][1])); nr = n_r[i]\\n                elif n_r[i] == nr: n_n_l.add((n_l[i][0],n_l[i][1]))\\n            r.append(nr)\\n            l = n_n_l\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205941,
                "title": "c-bfs-hash-t-s-o-n1-n2-k-98-67-fast-89-12-space-notes",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans(k,0);\\n\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        vector<vector<int>> ind1(n1+1);  // direct pointer for each digit for every ix\\n        vector<vector<int>> ind2(n2+1);  // direct pointer for each digit for every ix\\n        vector<int> il(10,n1);\\n        ind1[n1] = il;\\n        int i;\\n        for(i=n1-1; i>=0; i--) \\n        {  // Starting from the end, update the index for the next for each digit\\n            il[nums1[i]]=i;\\n            ind1[i] = il;\\n        }\\n        vector<int> ik(10,n2);\\n        ind2[n2] = ik;\\n        for(i=n2-1; i>=0; i--) \\n        {  // Starting from the end, update the index for the next for each digit\\n            ik[nums2[i]]=i;\\n            ind2[i]=ik;\\n        }\\n        int ix = 0;\\n        queue<pair<int,int>> q1;  // Double queues system to implement BFS\\n        queue<pair<int,int>> q2;\\n        queue<pair<int,int>> &q = q1;        // Current queue\\n        queue<pair<int,int>> &q_next = q2;   // Next queue\\n        q.push({0,0});\\n\\t\\tunordered_map<int,int> hash;         // Hash to avoid duplication\\n        while (ix < k)\\n        {\\n            while(!q.empty())\\n            {\\n                int ix1 = q.front().first;\\n                int ix2 = q.front().second;\\n                q.pop();\\n                if (hash.count(ix1*512+ix2)) continue;  // Avoid duplication\\n                hash[ix1*512+ix2]++;\\n                for(int d = 9; d>=ans[ix]; d--)\\n                {   // Checking the availebility from high to low (the current highest for this ix)\\n                    int i =ind1[ix1][d];\\n                    if (i<n1 && n1+n2-ix2-i>=k-ix)    \\n                    {\\n                        // cout << d << \", \" << i << endl;\\n                         if (ans[ix] < d) \\n                        {  // if better than prev (same ix) clear prev\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;\\n                        }\\n                        q_next.push({i+1,ix2});  // add curent combination\\n                        break;\\n                    }\\n                }\\n                for(int d = 9; d>=ans[ix]; d--) \\n                {   // Checking the availebility from high to low (the current highest for this ix)\\n                    int i =ind2[ix2][d];    // Update the ix for next d (n2 means no next available)\\n                    \\n                    if (i<n2 && n1+n2-ix1-i>=k-ix)  // Check if this ix allow leave enough digit to get to length k\\n                    {  // Yes - \\n                        // cout << d << \",,\" << i << endl;\\n                        if (ans[ix] < d)  // Check if new max for this ix. \\n                        {   // If new max arase acumulated combination of the old max\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;  // Save new max\\n                        }\\n                        q_next.push({ix1,i+1});  //\\xA0Push current combination\\n                        break;\\n                    }\\n                }\\n            }\\n            swap(q,q_next);  // prepare next queue  (next become current)\\n            ix++;\\n        }\\n        return  ans;   \\n    }\\n};\\n\\n```\\n// Simple\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans(k,0);\\n\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        vector<vector<int>> d1(10);\\n        vector<vector<int>> d2(10);\\n        for(int i=0; i<n1; i++) d1[nums1[i]].push_back(i);\\n        for(int i=0; i<n2; i++) d2[nums2[i]].push_back(i);\\n        int ix1[10]={0};\\n        int ix2[10]={0};\\n        int ix = 0;\\n        queue<pair<int,int>> q1;\\n        queue<pair<int,int>> q2;\\n        queue<pair<int,int>> &q = q1;\\n        queue<pair<int,int>> &q_next = q2;\\n        q.push({0,0});\\n        unordered_map<int,int> hash;\\n        while (ix < k)\\n        {\\n            while(!q.empty())\\n            {\\n                int ix1 = q.front().first;\\n                int ix2 = q.front().second;\\n                q.pop();\\n                if (hash.count(ix1*512+ix2)) continue;  // Avoid duplication\\n                hash[ix1*512+ix2]++;\\n                for(int d = 9; d>=ans[ix]; d--)\\n                {\\n                    int i;\\n                    for (i=0; i<d1[d].size(); i++) \\n                    {\\n                        if (d1[d][i] < ix1) continue;\\n                        if (n1+n2-ix2-d1[d][i]>=k-ix) break;  // find largest available\\n                    }\\n                    if (i<d1[d].size())    \\n                    {\\n                         if (ans[ix] < d) \\n                        {  // if better than prev (same ix) clear prev\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;\\n                        }\\n                        q_next.push({d1[d][i]+1,ix2});  // add curent combination\\n                        break;\\n                    }\\n                }\\n                for(int d = 9; d>=ans[ix]; d--) \\n                {\\n                    int i;\\n                    for (i=0; i<d2[d].size(); i++) \\n                    {\\n                        if (d2[d][i] < ix2)continue;\\n                        if (n1+n2-ix1-d2[d][i]>=k-ix) break;\\n                    }\\n                    if (i<d2[d].size())    \\n                    {  \\n                        if (ans[ix] < d) \\n                        {\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;\\n                        }\\n                        q_next.push({ix1,d2[d][i]+1});\\n                        break;\\n                    }\\n                }\\n            }\\n            swap(q,q_next);  // prepare next queue\\n            ix++;\\n        }\\n        return  ans;\\n    }\\n};\\n\\n/*\\n[3,4,6,5]\\n[9,1,2,5,8,3]\\n5\\n\\n[6,7]\\n[6,0,4]\\n5\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans(k,0);\\n\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        vector<vector<int>> ind1(n1+1);  // direct pointer for each digit for every ix\\n        vector<vector<int>> ind2(n2+1);  // direct pointer for each digit for every ix\\n        vector<int> il(10,n1);\\n        ind1[n1] = il;\\n        int i;\\n        for(i=n1-1; i>=0; i--) \\n        {  // Starting from the end, update the index for the next for each digit\\n            il[nums1[i]]=i;\\n            ind1[i] = il;\\n        }\\n        vector<int> ik(10,n2);\\n        ind2[n2] = ik;\\n        for(i=n2-1; i>=0; i--) \\n        {  // Starting from the end, update the index for the next for each digit\\n            ik[nums2[i]]=i;\\n            ind2[i]=ik;\\n        }\\n        int ix = 0;\\n        queue<pair<int,int>> q1;  // Double queues system to implement BFS\\n        queue<pair<int,int>> q2;\\n        queue<pair<int,int>> &q = q1;        // Current queue\\n        queue<pair<int,int>> &q_next = q2;   // Next queue\\n        q.push({0,0});\\n\\t\\tunordered_map<int,int> hash;         // Hash to avoid duplication\\n        while (ix < k)\\n        {\\n            while(!q.empty())\\n            {\\n                int ix1 = q.front().first;\\n                int ix2 = q.front().second;\\n                q.pop();\\n                if (hash.count(ix1*512+ix2)) continue;  // Avoid duplication\\n                hash[ix1*512+ix2]++;\\n                for(int d = 9; d>=ans[ix]; d--)\\n                {   // Checking the availebility from high to low (the current highest for this ix)\\n                    int i =ind1[ix1][d];\\n                    if (i<n1 && n1+n2-ix2-i>=k-ix)    \\n                    {\\n                        // cout << d << \", \" << i << endl;\\n                         if (ans[ix] < d) \\n                        {  // if better than prev (same ix) clear prev\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;\\n                        }\\n                        q_next.push({i+1,ix2});  // add curent combination\\n                        break;\\n                    }\\n                }\\n                for(int d = 9; d>=ans[ix]; d--) \\n                {   // Checking the availebility from high to low (the current highest for this ix)\\n                    int i =ind2[ix2][d];    // Update the ix for next d (n2 means no next available)\\n                    \\n                    if (i<n2 && n1+n2-ix1-i>=k-ix)  // Check if this ix allow leave enough digit to get to length k\\n                    {  // Yes - \\n                        // cout << d << \",,\" << i << endl;\\n                        if (ans[ix] < d)  // Check if new max for this ix. \\n                        {   // If new max arase acumulated combination of the old max\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;  // Save new max\\n                        }\\n                        q_next.push({ix1,i+1});  //\\xA0Push current combination\\n                        break;\\n                    }\\n                }\\n            }\\n            swap(q,q_next);  // prepare next queue  (next become current)\\n            ix++;\\n        }\\n        return  ans;   \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans(k,0);\\n\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        vector<vector<int>> d1(10);\\n        vector<vector<int>> d2(10);\\n        for(int i=0; i<n1; i++) d1[nums1[i]].push_back(i);\\n        for(int i=0; i<n2; i++) d2[nums2[i]].push_back(i);\\n        int ix1[10]={0};\\n        int ix2[10]={0};\\n        int ix = 0;\\n        queue<pair<int,int>> q1;\\n        queue<pair<int,int>> q2;\\n        queue<pair<int,int>> &q = q1;\\n        queue<pair<int,int>> &q_next = q2;\\n        q.push({0,0});\\n        unordered_map<int,int> hash;\\n        while (ix < k)\\n        {\\n            while(!q.empty())\\n            {\\n                int ix1 = q.front().first;\\n                int ix2 = q.front().second;\\n                q.pop();\\n                if (hash.count(ix1*512+ix2)) continue;  // Avoid duplication\\n                hash[ix1*512+ix2]++;\\n                for(int d = 9; d>=ans[ix]; d--)\\n                {\\n                    int i;\\n                    for (i=0; i<d1[d].size(); i++) \\n                    {\\n                        if (d1[d][i] < ix1) continue;\\n                        if (n1+n2-ix2-d1[d][i]>=k-ix) break;  // find largest available\\n                    }\\n                    if (i<d1[d].size())    \\n                    {\\n                         if (ans[ix] < d) \\n                        {  // if better than prev (same ix) clear prev\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;\\n                        }\\n                        q_next.push({d1[d][i]+1,ix2});  // add curent combination\\n                        break;\\n                    }\\n                }\\n                for(int d = 9; d>=ans[ix]; d--) \\n                {\\n                    int i;\\n                    for (i=0; i<d2[d].size(); i++) \\n                    {\\n                        if (d2[d][i] < ix2)continue;\\n                        if (n1+n2-ix1-d2[d][i]>=k-ix) break;\\n                    }\\n                    if (i<d2[d].size())    \\n                    {  \\n                        if (ans[ix] < d) \\n                        {\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;\\n                        }\\n                        q_next.push({ix1,d2[d][i]+1});\\n                        break;\\n                    }\\n                }\\n            }\\n            swap(q,q_next);  // prepare next queue\\n            ix++;\\n        }\\n        return  ans;\\n    }\\n};\\n\\n/*\\n[3,4,6,5]\\n[9,1,2,5,8,3]\\n5\\n\\n[6,7]\\n[6,0,4]\\n5\\n*/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2122879,
                "title": "python-98-faster-greedy-dp-segment-tree-for-range-query",
                "content": "\\n\\n```\\nfrom typing import List\\nfrom collections import defaultdict\\n\\n\\nclass Node(object):\\n    def __init__(self, beg, end):\\n        self.beg = beg\\n        self.end = end\\n        self.range_max = None\\n        self.left = None\\n        self.right = None\\n\\n    def is_leaf(self):\\n        return self.beg == self.end\\n\\n    def __repr__(self):\\n        if self.is_leaf():\\n            return f\"{self.beg}: {self.range_max}\"\\n        else:\\n            return f\"{self.beg}~{self.end}: {self.range_max}\"\\n\\n    def query(self, beg, end):\\n        # Totally out of range\\n        if beg > self.end or end < self.beg:\\n            return float(\"-inf\"), -1\\n\\n        # Query range contains node range\\n        elif self.beg >= beg and self.end <= end:\\n            return self.range_max\\n\\n        # Intersection\\n        else:\\n            return max(self.left.query(beg, end), self.right.query(beg, end))\\n\\n\\ndef build_range_tree(a, beg, end):\\n    node = Node(beg, end)\\n    if beg == end:\\n        node.range_max = (a[beg], -beg)\\n    else:\\n        mid = (beg + end) // 2\\n        node.left = build_range_tree(a, beg, mid)\\n        node.right = build_range_tree(a, mid + 1, end)\\n        node.range_max = max(node.left.range_max, node.right.range_max)\\n\\n    return node\\n\\n\\ndef comp_array(a, b, beg_a, beg_b):\\n    for i, j in zip(range(beg_a, len(a)), range(beg_b, len(b))):\\n        if a[i] > b[j]:\\n            return 1\\n        elif a[i] < b[j]:\\n            return -1\\n\\n    if len(a) - beg_a > len(b) - beg_b:\\n        return 1\\n    elif len(a) - beg_a < len(b) - beg_b:\\n        return -1\\n    else:\\n        return 0\\n\\n\\ndef merge_2_arrays(a, b, beg_a, beg_b):\\n    ptr1 = beg_a\\n    ptr2 = beg_b\\n\\n    while True:\\n        if ptr1 == len(a) or ptr2 == len(b):\\n            break\\n        comp_res = comp_array(a, b, ptr1, ptr2)\\n        if comp_res == 1:\\n            yield a[ptr1]\\n            ptr1 += 1\\n        else:\\n            yield b[ptr2]\\n            ptr2 += 1\\n\\n    for i in range(ptr1, len(a)):\\n        yield a[i]\\n\\n    for i in range(ptr2, len(b)):\\n        yield b[i]\\n\\n\\ndef pick_k_numbers(a, tree_a, beg_a, k):\\n    if k == 0:\\n        return []\\n    len_a = len(a) - beg_a\\n    num_elements_to_drop = len_a - k\\n    if num_elements_to_drop == 0:\\n        return a[beg_a:]\\n\\n    end_a = min(beg_a + num_elements_to_drop, len(a) - 1)\\n\\n    max_val, max_idx = tree_a.query(beg_a, end_a)\\n    max_idx = -max_idx\\n\\n    return [a[max_idx]] + pick_k_numbers(a, tree_a, max_idx + 1, k - 1)\\n\\n\\ndef fetch_dp_table(a, b, tree_a, tree_b, beg_a, beg_b, k, dp_table):\\n\\n    if k == 0:\\n        return []\\n\\n    if (beg_a, beg_b, k) not in dp_table:\\n\\n        len_a = len(a) - beg_a\\n        len_b = len(b) - beg_b\\n\\n        num_elements_to_drop = len_a + len_b - k\\n\\n        if num_elements_to_drop == 0:\\n            res = list(merge_2_arrays(a, b, beg_a, beg_b))\\n\\n        elif len_b == 0:\\n            res = pick_k_numbers(a, tree_a, beg_a, k)\\n\\n        elif len_a == 0:\\n            res = pick_k_numbers(b, tree_b, beg_b, k)\\n\\n        else:\\n            end_a = min(beg_a + num_elements_to_drop, len(a) - 1)\\n            end_b = min(beg_b + num_elements_to_drop, len(b) - 1)\\n\\n            max_val_a, max_idx_a = (\\n                tree_a.query(beg_a, end_a) if len_a > 0 else (float(\"-inf\"), -1)\\n            )\\n            max_idx_a = -max_idx_a\\n\\n            max_val_b, max_idx_b = (\\n                tree_b.query(beg_b, end_b) if len_b > 0 else (float(\"-inf\"), -1)\\n            )\\n            max_idx_b = -max_idx_b\\n\\n            if max_val_a > max_val_b:\\n                next_vals = fetch_dp_table(\\n                    a, b, tree_a, tree_b, max_idx_a + 1, beg_b, k - 1, dp_table\\n                )\\n                res = [max_val_a] + next_vals\\n            elif max_val_b > max_val_a:\\n                next_vals = fetch_dp_table(\\n                    a, b, tree_a, tree_b, beg_a, max_idx_b + 1, k - 1, dp_table\\n                )\\n                res = [max_val_b] + next_vals\\n            else:\\n                vala = fetch_dp_table(\\n                    a, b, tree_a, tree_b, max_idx_a + 1, beg_b, k - 1, dp_table\\n                )\\n                valb = fetch_dp_table(\\n                    a, b, tree_a, tree_b, beg_a, max_idx_b + 1, k - 1, dp_table\\n                )\\n                res = [max_val_a] + max(vala, valb)\\n\\n        dp_table[(beg_a, beg_b, k)] = res\\n    else:\\n        pass\\n\\n    return dp_table[(beg_a, beg_b, k)]\\n\\n\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        tree_1 = build_range_tree(nums1, 0, len(nums1) - 1)\\n        tree_2 = build_range_tree(nums2, 0, len(nums2) - 1)\\n        dp_table = {}\\n        res = fetch_dp_table(nums1, nums2, tree_1, tree_2, 0, 0, k, dp_table)\\n        return res\\n\\n\\nif __name__ == \"__main__\":\\n    nums1 = [3,4,6,5]\\n    nums2 = [9,1,2,5,8,3]\\n    k = 5\\n    # res = Solution().maxNumber(nums1, nums2, k)\\n    # print(res)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom typing import List\\nfrom collections import defaultdict\\n\\n\\nclass Node(object):\\n    def __init__(self, beg, end):\\n        self.beg = beg\\n        self.end = end\\n        self.range_max = None\\n        self.left = None\\n        self.right = None\\n\\n    def is_leaf(self):\\n        return self.beg == self.end\\n\\n    def __repr__(self):\\n        if self.is_leaf():\\n            return f\"{self.beg}: {self.range_max}\"\\n        else:\\n            return f\"{self.beg}~{self.end}: {self.range_max}\"\\n\\n    def query(self, beg, end):\\n        # Totally out of range\\n        if beg > self.end or end < self.beg:\\n            return float(\"-inf\"), -1\\n\\n        # Query range contains node range\\n        elif self.beg >= beg and self.end <= end:\\n            return self.range_max\\n\\n        # Intersection\\n        else:\\n            return max(self.left.query(beg, end), self.right.query(beg, end))\\n\\n\\ndef build_range_tree(a, beg, end):\\n    node = Node(beg, end)\\n    if beg == end:\\n        node.range_max = (a[beg], -beg)\\n    else:\\n        mid = (beg + end) // 2\\n        node.left = build_range_tree(a, beg, mid)\\n        node.right = build_range_tree(a, mid + 1, end)\\n        node.range_max = max(node.left.range_max, node.right.range_max)\\n\\n    return node\\n\\n\\ndef comp_array(a, b, beg_a, beg_b):\\n    for i, j in zip(range(beg_a, len(a)), range(beg_b, len(b))):\\n        if a[i] > b[j]:\\n            return 1\\n        elif a[i] < b[j]:\\n            return -1\\n\\n    if len(a) - beg_a > len(b) - beg_b:\\n        return 1\\n    elif len(a) - beg_a < len(b) - beg_b:\\n        return -1\\n    else:\\n        return 0\\n\\n\\ndef merge_2_arrays(a, b, beg_a, beg_b):\\n    ptr1 = beg_a\\n    ptr2 = beg_b\\n\\n    while True:\\n        if ptr1 == len(a) or ptr2 == len(b):\\n            break\\n        comp_res = comp_array(a, b, ptr1, ptr2)\\n        if comp_res == 1:\\n            yield a[ptr1]\\n            ptr1 += 1\\n        else:\\n            yield b[ptr2]\\n            ptr2 += 1\\n\\n    for i in range(ptr1, len(a)):\\n        yield a[i]\\n\\n    for i in range(ptr2, len(b)):\\n        yield b[i]\\n\\n\\ndef pick_k_numbers(a, tree_a, beg_a, k):\\n    if k == 0:\\n        return []\\n    len_a = len(a) - beg_a\\n    num_elements_to_drop = len_a - k\\n    if num_elements_to_drop == 0:\\n        return a[beg_a:]\\n\\n    end_a = min(beg_a + num_elements_to_drop, len(a) - 1)\\n\\n    max_val, max_idx = tree_a.query(beg_a, end_a)\\n    max_idx = -max_idx\\n\\n    return [a[max_idx]] + pick_k_numbers(a, tree_a, max_idx + 1, k - 1)\\n\\n\\ndef fetch_dp_table(a, b, tree_a, tree_b, beg_a, beg_b, k, dp_table):\\n\\n    if k == 0:\\n        return []\\n\\n    if (beg_a, beg_b, k) not in dp_table:\\n\\n        len_a = len(a) - beg_a\\n        len_b = len(b) - beg_b\\n\\n        num_elements_to_drop = len_a + len_b - k\\n\\n        if num_elements_to_drop == 0:\\n            res = list(merge_2_arrays(a, b, beg_a, beg_b))\\n\\n        elif len_b == 0:\\n            res = pick_k_numbers(a, tree_a, beg_a, k)\\n\\n        elif len_a == 0:\\n            res = pick_k_numbers(b, tree_b, beg_b, k)\\n\\n        else:\\n            end_a = min(beg_a + num_elements_to_drop, len(a) - 1)\\n            end_b = min(beg_b + num_elements_to_drop, len(b) - 1)\\n\\n            max_val_a, max_idx_a = (\\n                tree_a.query(beg_a, end_a) if len_a > 0 else (float(\"-inf\"), -1)\\n            )\\n            max_idx_a = -max_idx_a\\n\\n            max_val_b, max_idx_b = (\\n                tree_b.query(beg_b, end_b) if len_b > 0 else (float(\"-inf\"), -1)\\n            )\\n            max_idx_b = -max_idx_b\\n\\n            if max_val_a > max_val_b:\\n                next_vals = fetch_dp_table(\\n                    a, b, tree_a, tree_b, max_idx_a + 1, beg_b, k - 1, dp_table\\n                )\\n                res = [max_val_a] + next_vals\\n            elif max_val_b > max_val_a:\\n                next_vals = fetch_dp_table(\\n                    a, b, tree_a, tree_b, beg_a, max_idx_b + 1, k - 1, dp_table\\n                )\\n                res = [max_val_b] + next_vals\\n            else:\\n                vala = fetch_dp_table(\\n                    a, b, tree_a, tree_b, max_idx_a + 1, beg_b, k - 1, dp_table\\n                )\\n                valb = fetch_dp_table(\\n                    a, b, tree_a, tree_b, beg_a, max_idx_b + 1, k - 1, dp_table\\n                )\\n                res = [max_val_a] + max(vala, valb)\\n\\n        dp_table[(beg_a, beg_b, k)] = res\\n    else:\\n        pass\\n\\n    return dp_table[(beg_a, beg_b, k)]\\n\\n\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        tree_1 = build_range_tree(nums1, 0, len(nums1) - 1)\\n        tree_2 = build_range_tree(nums2, 0, len(nums2) - 1)\\n        dp_table = {}\\n        res = fetch_dp_table(nums1, nums2, tree_1, tree_2, 0, 0, k, dp_table)\\n        return res\\n\\n\\nif __name__ == \"__main__\":\\n    nums1 = [3,4,6,5]\\n    nums2 = [9,1,2,5,8,3]\\n    k = 5\\n    # res = Solution().maxNumber(nums1, nums2, k)\\n    # print(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105459,
                "title": "python-easy-to-understand-greedy-dynamic-programminng",
                "content": "To solve the problem, we can define the subproblem \"getMaxNumberString(i, j, length)\": get the max number string with \"length\" from index \"i\" in nums1 and index \"j\" in nums2.\\n\\ngetMaxNumberString(i, j, length)\\n- if nums1 has bigger digit, getMaxNumberString(i, j, length) = str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1)\\n- if nums2 has bigger digit, getMaxNumberString(i, j, length) = str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1)\\n- if nums1 and nums2 have the same big digit, getMaxNumberString(i, j, length) = max(str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1),  str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1))\\n\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        m = len(nums1)\\n        n = len(nums2)\\n        dp = {}\\n        \\n        # get the max number string with \"length\" from index \"i\" in nums1 and index \"j\" in nums2\\n        # using number string to easy to compare\\n        def getMaxNumberString(i, j, length):\\n            if length == 0:\\n                return \"\"\\n            \\n            # using memoization to optimize for the overlapping subproblems\\n            key = (i, j, length)\\n            if key in dp:\\n                return dp[key]\\n            \\n            # greedy to find the possible max digit from nums1 and nums2\\n            # 1) bigger digit in the higher position of the number will get bigger number\\n            # 2) at the same time, we need to ensure that we still have enough digits to form a number with \"length\" digits\\n            \\n            # try to find the possible max digit from index i in nums1\\n            index1 = None\\n            for ii in range(i, m):\\n                if (m - ii + n - j) < length:\\n                    break\\n                if index1 is None or nums1[index1] < nums1[ii]:\\n                    index1 = ii\\n            \\n            # try to find the possible max digit from index j in nums2\\n            index2 = None\\n            for jj in range(j, n):\\n                if (m - i + n - jj) < length:\\n                    break\\n                if index2 is None or nums2[index2] < nums2[jj]:\\n                    index2 = jj\\n                    \\n            maxNumberStr = None\\n            if index1 is not None and index2 is not None:\\n                if nums1[index1] > nums2[index2]:\\n                    maxNumberStr = str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1)\\n                elif nums1[index1] < nums2[index2]:\\n                    maxNumberStr = str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1)\\n                else:\\n                    # get the same digit from nums1 and nums2, so need to try two cases and get the max one \\n                    maxNumberStr = max(str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1), str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1))\\n            elif index1 is not None:\\n                maxNumberStr = str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1)\\n            elif index2 is not None:\\n                maxNumberStr = str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1)\\n            \\n            dp[key] = maxNumberStr\\n            return maxNumberStr\\n\\n        result_str = getMaxNumberString(0, 0, k)\\n        \\n        # number string to digit array\\n        result = []\\n        for c in result_str:\\n            result.append(int(c))\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        m = len(nums1)\\n        n = len(nums2)\\n        dp = {}\\n        \\n        # get the max number string with \"length\" from index \"i\" in nums1 and index \"j\" in nums2\\n        # using number string to easy to compare\\n        def getMaxNumberString(i, j, length):\\n            if length == 0:\\n                return \"\"\\n            \\n            # using memoization to optimize for the overlapping subproblems\\n            key = (i, j, length)\\n            if key in dp:\\n                return dp[key]\\n            \\n            # greedy to find the possible max digit from nums1 and nums2\\n            # 1) bigger digit in the higher position of the number will get bigger number\\n            # 2) at the same time, we need to ensure that we still have enough digits to form a number with \"length\" digits\\n            \\n            # try to find the possible max digit from index i in nums1\\n            index1 = None\\n            for ii in range(i, m):\\n                if (m - ii + n - j) < length:\\n                    break\\n                if index1 is None or nums1[index1] < nums1[ii]:\\n                    index1 = ii\\n            \\n            # try to find the possible max digit from index j in nums2\\n            index2 = None\\n            for jj in range(j, n):\\n                if (m - i + n - jj) < length:\\n                    break\\n                if index2 is None or nums2[index2] < nums2[jj]:\\n                    index2 = jj\\n                    \\n            maxNumberStr = None\\n            if index1 is not None and index2 is not None:\\n                if nums1[index1] > nums2[index2]:\\n                    maxNumberStr = str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1)\\n                elif nums1[index1] < nums2[index2]:\\n                    maxNumberStr = str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1)\\n                else:\\n                    # get the same digit from nums1 and nums2, so need to try two cases and get the max one \\n                    maxNumberStr = max(str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1), str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1))\\n            elif index1 is not None:\\n                maxNumberStr = str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1)\\n            elif index2 is not None:\\n                maxNumberStr = str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1)\\n            \\n            dp[key] = maxNumberStr\\n            return maxNumberStr\\n\\n        result_str = getMaxNumberString(0, 0, k)\\n        \\n        # number string to digit array\\n        result = []\\n        for c in result_str:\\n            result.append(int(c))\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982077,
                "title": "python3-monotonic-stack-greedy",
                "content": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        \\n        def find_k_max_number_in_an_array(nums, k):\\n            drop_possible = len(nums) - k\\n            n = len(nums)\\n            stack = []\\n            for i, val in enumerate(nums):\\n                while stack and drop_possible and stack[-1] < val:\\n                    drop_possible -= 1\\n                    stack.pop()\\n                \\n                stack.append(val)\\n            \\n            return stack[:k]\\n                \\n        \\n        def merge_two_array(arr1, arr2):\\n            #print(arr1, arr2)\\n            return [max(arr1, arr2).pop(0) for _ in arr1 + arr2]\\n\\n        def compare_two_array(arr1, arr2):\\n            \"\"\"\\n            determine whether arr1 is greater than arr2\\n            \"\"\"\\n            if not arr2:\\n                return True\\n            i = j = 0\\n            n = len(arr1)\\n            while i < n and j < n:\\n                if arr1[i] > arr2[j]:\\n                    return True\\n                elif arr1[i] < arr2[j]:\\n                    return False\\n                i += 1\\n                j += 1\\n            \\n            return True\\n        \\n        ans = 0\\n        for i in range(k + 1):\\n            p = k - i\\n            \\n            if i > len(nums1) or p > len(nums2):\\n                continue\\n            \\n            # get this two array by solving function find_k_max_number_in_an_array\\n            # using similar concept of 402. Remove K Digits\\n            first_arr = find_k_max_number_in_an_array(nums1, i)\\n            second_arr = find_k_max_number_in_an_array(nums2, p)\\n            \\n            # merge two array with everytime taking lexicographily larger list\\n            # https://leetcode.com/problems/create-maximum-number/discuss/77286/Short-Python-Ruby-C%2B%2B\\n            # see explanation\\n            curr_arr = merge_two_array(first_arr, second_arr)\\n            #print(curr_arr)\\n            \\n            # can be directly use python max function\\n            if compare_two_array(curr_arr, ans):\\n                ans = curr_arr\\n            # ans = max(ans, curr_arr) if ans else curr_arr\\n            \\n            #print(ans)\\n        \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        \\n        def find_k_max_number_in_an_array(nums, k):\\n            drop_possible = len(nums) - k\\n            n = len(nums)\\n            stack = []\\n            for i, val in enumerate(nums):\\n                while stack and drop_possible and stack[-1] < val:\\n                    drop_possible -= 1\\n                    stack.pop()\\n                \\n                stack.append(val)\\n            \\n            return stack[:k]\\n                \\n        \\n        def merge_two_array(arr1, arr2):\\n            #print(arr1, arr2)\\n            return [max(arr1, arr2).pop(0) for _ in arr1 + arr2]\\n\\n        def compare_two_array(arr1, arr2):\\n            \"\"\"\\n            determine whether arr1 is greater than arr2\\n            \"\"\"\\n            if not arr2:\\n                return True\\n            i = j = 0\\n            n = len(arr1)\\n            while i < n and j < n:\\n                if arr1[i] > arr2[j]:\\n                    return True\\n                elif arr1[i] < arr2[j]:\\n                    return False\\n                i += 1\\n                j += 1\\n            \\n            return True\\n        \\n        ans = 0\\n        for i in range(k + 1):\\n            p = k - i\\n            \\n            if i > len(nums1) or p > len(nums2):\\n                continue\\n            \\n            # get this two array by solving function find_k_max_number_in_an_array\\n            # using similar concept of 402. Remove K Digits\\n            first_arr = find_k_max_number_in_an_array(nums1, i)\\n            second_arr = find_k_max_number_in_an_array(nums2, p)\\n            \\n            # merge two array with everytime taking lexicographily larger list\\n            # https://leetcode.com/problems/create-maximum-number/discuss/77286/Short-Python-Ruby-C%2B%2B\\n            # see explanation\\n            curr_arr = merge_two_array(first_arr, second_arr)\\n            #print(curr_arr)\\n            \\n            # can be directly use python max function\\n            if compare_two_array(curr_arr, ans):\\n                ans = curr_arr\\n            # ans = max(ans, curr_arr) if ans else curr_arr\\n            \\n            #print(ans)\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902698,
                "title": "c-solution-well-explained",
                "content": "**Explanation:**\\n\\nIdea 1: the first thing that popped into my head was to use recursion, the initial idea was to select an initial number and in each call stack have three different paths to take.\\n1. \\tchoose a number from array one\\n2. \\tchoose a number from array two\\n3. \\tdon\\'t choose a number and move along \\n\\t\\t\\t* \\tThe problem with this approach is that it is both time and memory expensive\\n\\t\\t\\nIdea 2: a greedy approach where i would take the lexigraphically greatest portion of array one merge it with the lexigraphically greatest portion of array two and collapse the arrays into themselves to be of size k, this idea works but we have to be careful.\\n\\nAlgorithm explained:\\n\\t1. \\tpartition both arrays into a sub array of k, where each array contains the maximum lexigraphical order it can hold.\\n\\t\\tThe subarrays are partitioned as such, (k - i) where i <= k would get you the first half and i gets the other half of that k sized array.\\n*  \\t\\t    auto first = findMax(nums1, k - i);\\n* \\t\\t      auto second = findMax(nums2, i);\\n\\t\\n2. \\tThen merge those two arrays ( k - i) and i into an array of size k , where the array of size K respects the rule of being in the greatest lexigraphical order it can hold.\\n* \\t\\t while (nP < n && mP < m)\\n        {\\n              if(nums1[nP] == nums2[mP]){  \\n                  int i = nP;  \\n                  int j = mP;\\n                  \\n                  while( i < n && j < m && nums1[i] == nums2[j]){\\n                      i++;\\n                      j++;\\n                  } \\n                  \\n                  if(i == n)\\n                      res.push_back(nums2[mP++]);\\n                  \\n                  else if ( j == m)\\n                      res.push_back(nums1[nP++]);\\n                  \\n                  else if(nums1[i] > nums2[j])\\n                     res.push_back(nums1[nP++]); \\n                  \\n                  else\\n                     res.push_back(nums2[mP++]); \\n                    \\n                continue; \\n          } \\n          if (nums1[nP] > nums2[mP])\\n                res.push_back(nums1[nP++]);\\n           else if(nums2[mP] > nums1[nP]) \\n                res.push_back(nums2[mP++]);\\n        }\\n3. Lastly compare with our answer derived from previous iterations and update if needed.\\n\\t\\t*`ans = compare(ans, tmp);`\\n\\n```\\nclass Solution\\n{\\npublic:\\n    void print(vector<int> & res){\\n        for(int x : res)\\n            cout << x << \" \";\\n        cout << endl;\\n    }\\n    \\n    vector<int> findMax(vector<int> &nums, int k)\\n    {\\n        vector<int> res;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int m = res.size();\\n            while (m && res.back() < nums[i])\\n            {\\n                if (((n - i) + m - 1) >= k)\\n                {\\n                    res.pop_back();\\n                    m--;\\n                }\\n                else\\n                    break;\\n            }\\n            if (m < k)\\n            {\\n                m++;\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    vector<int> compare(vector<int> &nums1, vector<int> &nums2)\\n    {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        if (n > m)\\n            return nums1;\\n        if (m > n)\\n            return nums2;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums1[i] > nums2[i])\\n                return nums1;\\n            else if (nums1[i] < nums2[i])\\n                return nums2;\\n        }\\n        return nums1;\\n    }\\n    vector<int> merge(vector<int> &nums1, vector<int> &nums2)\\n    {\\n        vector<int> res;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int nP = 0;\\n        int mP = 0;\\n        while (nP < n && mP < m)\\n        {\\n              if(nums1[nP] == nums2[mP]){  \\n                  int i = nP;  \\n                  int j = mP;\\n                  \\n                  while( i < n && j < m && nums1[i] == nums2[j]){\\n                      i++;\\n                      j++;\\n                  } \\n                  \\n                  if(i == n)\\n                      res.push_back(nums2[mP++]);\\n                  \\n                  else if ( j == m)\\n                      res.push_back(nums1[nP++]);\\n                  \\n                  else if(nums1[i] > nums2[j])\\n                     res.push_back(nums1[nP++]); \\n                  \\n                  else\\n                     res.push_back(nums2[mP++]); \\n                    \\n                continue; \\n          } \\n          if (nums1[nP] > nums2[mP])\\n                res.push_back(nums1[nP++]);\\n           else if(nums2[mP] > nums1[nP]) \\n                res.push_back(nums2[mP++]);\\n        }\\n        while (nP < n)\\n            res.push_back(nums1[nP++]);\\n        while (mP < m)\\n            res.push_back(nums2[mP++]);\\n        return res;\\n    }\\n    \\n    vector<int> maxNumber(vector<int> &nums1, vector<int> &nums2, int k)\\n    {\\n        vector<int> ans;\\n        for (int i = 0; i < k; i++)\\n        {\\n            auto first = findMax(nums1, k - i);\\n            auto second = findMax(nums2, i);\\n            auto tmp = merge(first, second);\\n            ans = compare(ans, tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    void print(vector<int> & res){\\n        for(int x : res)\\n            cout << x << \" \";\\n        cout << endl;\\n    }\\n    \\n    vector<int> findMax(vector<int> &nums, int k)\\n    {\\n        vector<int> res;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int m = res.size();\\n            while (m && res.back() < nums[i])\\n            {\\n                if (((n - i) + m - 1) >= k)\\n                {\\n                    res.pop_back();\\n                    m--;\\n                }\\n                else\\n                    break;\\n            }\\n            if (m < k)\\n            {\\n                m++;\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    vector<int> compare(vector<int> &nums1, vector<int> &nums2)\\n    {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        if (n > m)\\n            return nums1;\\n        if (m > n)\\n            return nums2;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums1[i] > nums2[i])\\n                return nums1;\\n            else if (nums1[i] < nums2[i])\\n                return nums2;\\n        }\\n        return nums1;\\n    }\\n    vector<int> merge(vector<int> &nums1, vector<int> &nums2)\\n    {\\n        vector<int> res;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int nP = 0;\\n        int mP = 0;\\n        while (nP < n && mP < m)\\n        {\\n              if(nums1[nP] == nums2[mP]){  \\n                  int i = nP;  \\n                  int j = mP;\\n                  \\n                  while( i < n && j < m && nums1[i] == nums2[j]){\\n                      i++;\\n                      j++;\\n                  } \\n                  \\n                  if(i == n)\\n                      res.push_back(nums2[mP++]);\\n                  \\n                  else if ( j == m)\\n                      res.push_back(nums1[nP++]);\\n                  \\n                  else if(nums1[i] > nums2[j])\\n                     res.push_back(nums1[nP++]); \\n                  \\n                  else\\n                     res.push_back(nums2[mP++]); \\n                    \\n                continue; \\n          } \\n          if (nums1[nP] > nums2[mP])\\n                res.push_back(nums1[nP++]);\\n           else if(nums2[mP] > nums1[nP]) \\n                res.push_back(nums2[mP++]);\\n        }\\n        while (nP < n)\\n            res.push_back(nums1[nP++]);\\n        while (mP < m)\\n            res.push_back(nums2[mP++]);\\n        return res;\\n    }\\n    \\n    vector<int> maxNumber(vector<int> &nums1, vector<int> &nums2, int k)\\n    {\\n        vector<int> ans;\\n        for (int i = 0; i < k; i++)\\n        {\\n            auto first = findMax(nums1, k - i);\\n            auto second = findMax(nums2, i);\\n            auto tmp = merge(first, second);\\n            ans = compare(ans, tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1860099,
                "title": "java-simple-solution-monotonic-stack-merge-all-combinations",
                "content": "class Solution {\\n    \\n    public int[] largeNum(int[] nums,int k){\\n        int n = nums.length;\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0;i < n;i++){\\n            \\n            while(stack.size() > 0 && stack.peek() < nums[i] && k - stack.size() <= n - i - 1){\\n                stack.pop();\\n            }\\n            \\n            stack.push(nums[i]);\\n        }\\n        \\n        int[] ans = new int[stack.size()];\\n        int ptr = stack.size() - 1;\\n        \\n        while(!stack.isEmpty()){\\n            ans[ptr--] = stack.pop();\\n        }\\n        return ans;\\n    }\\n    \\n    boolean isGreater(int[] max1,int[] max2,int i,int j){\\n        \\n        while(i < max1.length || j < max2.length){\\n            \\n            if(i >= max1.length) return false;\\n            else if(j >= max2.length) return true;\\n            else if(max1[i] < max2[j]) return false;\\n            else if(max1[i] > max2[j]) return true;\\n            else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n    \\n    \\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        \\n        int[] ans = new int[k];\\n        \\n        for(int i = 0;i <= k;i++){\\n            \\n            if(i > nums1.length || k - i > nums2.length) continue;\\n            \\n            int[] max1 = largeNum(nums1,i);\\n            int[] max2 = largeNum(nums2,k - i);\\n            \\n            //merge\\n            int a = 0;\\n            int b = 0;\\n            int[] temp = new int[k];\\n            int ptr = 0;\\n            while(a < max1.length || b < max2.length){\\n                if(ptr >= k){\\n                    break;\\n                }\\n                if(a >= max1.length) temp[ptr++] = max2[b++];\\n                else if(b >= max2.length) temp[ptr++] = max1[a++];\\n                else if(max1[a] < max2[b]) temp[ptr++] = max2[b++];\\n                else if(max1[a] > max2[b]) temp[ptr++] = max1[a++];\\n                else{\\n                    if(isGreater(max1,max2,a,b)){\\n                        temp[ptr++] = max1[a++];\\n                    }\\n                    else{\\n                        temp[ptr++] = max2[b++];\\n                    }\\n                }\\n            }\\n            // for(int j = 0;j < k;j++){\\n            //     System.out.print(temp[j] + \" \");\\n            // }\\n            //System.out.println();\\n            if(isGreater(temp,ans,0,0)){\\n                System.out.print(\"In\");\\n                ans = temp;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\n    \\n    public int[] largeNum(int[] nums,int k){\\n        int n = nums.length;\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0;i < n;i++){\\n            \\n            while(stack.size() > 0 && stack.peek() < nums[i] && k - stack.size() <= n - i - 1){\\n                stack.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1774232,
                "title": "javascript-greedy",
                "content": "```\\nconst maxNumber = (a, b, k) => {\\n    let m = a.length, n = b.length;\\n    let res = [];\\n    for (let i = Math.max(0, k - n); i <= Math.min(k, m); i++) {\\n        let maxA = maxArray(a, i), maxB = maxArray(b, k - i);\\n        let merge = mergeArray(maxA, maxB);\\n        if (merge > res) res = merge;\\n    }\\n    return res;\\n};\\n\\nconst maxArray = (a, k) => {\\n    let drop = a.length - k, res = [];\\n    for (const x of a) {\\n        while (drop > 0 && res.length && res[res.length - 1] < x) {\\n            res.pop();\\n            drop--;\\n        }\\n        res.push(x);\\n    }\\n    if (res.length >= k) {\\n        res = res.slice(0, k);\\n    } else {\\n        res = res.concat(Array(k - res.length).fill(0));\\n    }\\n    return res;\\n};\\n\\nconst mergeArray = (a, b) => {\\n    let res = [];\\n    while (a.length + b.length) res.push(a > b ? a.shift() : b.shift())\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst maxNumber = (a, b, k) => {\\n    let m = a.length, n = b.length;\\n    let res = [];\\n    for (let i = Math.max(0, k - n); i <= Math.min(k, m); i++) {\\n        let maxA = maxArray(a, i), maxB = maxArray(b, k - i);\\n        let merge = mergeArray(maxA, maxB);\\n        if (merge > res) res = merge;\\n    }\\n    return res;\\n};\\n\\nconst maxArray = (a, k) => {\\n    let drop = a.length - k, res = [];\\n    for (const x of a) {\\n        while (drop > 0 && res.length && res[res.length - 1] < x) {\\n            res.pop();\\n            drop--;\\n        }\\n        res.push(x);\\n    }\\n    if (res.length >= k) {\\n        res = res.slice(0, k);\\n    } else {\\n        res = res.concat(Array(k - res.length).fill(0));\\n    }\\n    return res;\\n};\\n\\nconst mergeArray = (a, b) => {\\n    let res = [];\\n    while (a.length + b.length) res.push(a > b ? a.shift() : b.shift())\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1736251,
                "title": "create-maximum-number",
                "content": "c++solution\\ntime and space surpass 90%+\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n// #define DEBUG\\nclass Solution {\\npublic:\\n  vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n    int m = nums1.size(), n = nums2.size();\\n    int *ret = NULL;\\n    if(m > n) {\\n      return maxNumber(nums2, nums1, k);\\n    }\\n    // make sure that m is smaller than or equal to m\\n    int begin = max(0, k-n);\\n    int end = min(m, k);\\n    for(int i = begin; i <= end; i++) {\\n      int *maxSub1 = maxSubsequence(nums1, i);\\n      int *maxSub2 = maxSubsequence(nums2, k - i);\\n      #ifdef DEBUG\\n      cout << i << \"---------------------------\\\\n\";\\n      dump(maxSub1, i);\\n      dump(maxSub2, k-i);\\n      cout << \"-------------------------\\\\n\";\\n      #endif\\n      int *maxSub = merge(maxSub1, i, maxSub2, k-i);\\n      ret = comapreAndSwap(ret, maxSub, k);\\n    }\\n    return vector<int>(ret, ret + k);\\n  }\\n  void dump(int *sub, int size) {\\n    for(int i = 0; i < size; i++) {\\n      cout << sub[i] << \" \";\\n    }\\n    cout << endl;\\n    return;\\n  }\\n  int *maxSubsequence(vector<int> &nums, int k) {\\n    int n = nums.size();\\n    int discard = n-k;\\n    int *ret = (int *)malloc(k * sizeof(int));\\n    int top = 0;\\n    for(auto i : nums) {\\n      while(top > 0 && ret[top-1] < i && discard > 0) {\\n        discard--;\\n        top--;\\n      }\\n\\n      if(top < k) {\\n        ret[top++] = i;\\n      }else{\\n        discard--;\\n      }\\n    }\\n    return ret;\\n  }\\n\\n  int *merge(int *sub1, int size1, int *sub2, int size2) {\\n    int idx1 = 0, idx2 = 0;\\n    int *ret = (int *)malloc((size1 + size2) * sizeof(int));\\n    for(int i = 0; i < size1 + size2; i++) {\\n      if(compare(sub1, size1, idx1, sub2, size2, idx2)) {\\n        ret[i] = sub1[idx1++];\\n      }else{\\n        ret[i] = sub2[idx2++];\\n      }\\n    }\\n    free(sub1);\\n    free(sub2);\\n    return ret;\\n  }\\n\\n  int *comapreAndSwap(int *ret, int *sub, int k) {\\n    if(compare(ret, k, 0, sub, k, 0)) {\\n      free(sub);\\n      return ret;\\n    }else{\\n      free(ret);\\n      return sub;\\n    }\\n  }\\n\\n  int compare(int *sub1, int size1, int idx1, int *sub2, int size2, int idx2) {\\n    if(size1 == idx1 || sub1 == NULL) {\\n      return 0;\\n    }else if(size2 == idx2) {\\n      return 1;\\n    }\\n\\n    if(sub1[idx1] > sub2[idx2]) {\\n      return 1;\\n    }else if(sub1[idx1] < sub2[idx2]){\\n      return 0;\\n    }else{\\n      return compare(sub1, size1, idx1+1, sub2, size2, idx2+1);\\n    }\\n  }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n// #define DEBUG\\nclass Solution {\\npublic:\\n  vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n    int m = nums1.size(), n = nums2.size();\\n    int *ret = NULL;\\n    if(m > n) {\\n      return maxNumber(nums2, nums1, k);\\n    }\\n    // make sure that m is smaller than or equal to m\\n    int begin = max(0, k-n);\\n    int end = min(m, k);\\n    for(int i = begin; i <= end; i++) {\\n      int *maxSub1 = maxSubsequence(nums1, i);\\n      int *maxSub2 = maxSubsequence(nums2, k - i);\\n      #ifdef DEBUG\\n      cout << i << \"---------------------------\\\\n\";\\n      dump(maxSub1, i);\\n      dump(maxSub2, k-i);\\n      cout << \"-------------------------\\\\n\";\\n      #endif\\n      int *maxSub = merge(maxSub1, i, maxSub2, k-i);\\n      ret = comapreAndSwap(ret, maxSub, k);\\n    }\\n    return vector<int>(ret, ret + k);\\n  }\\n  void dump(int *sub, int size) {\\n    for(int i = 0; i < size; i++) {\\n      cout << sub[i] << \" \";\\n    }\\n    cout << endl;\\n    return;\\n  }\\n  int *maxSubsequence(vector<int> &nums, int k) {\\n    int n = nums.size();\\n    int discard = n-k;\\n    int *ret = (int *)malloc(k * sizeof(int));\\n    int top = 0;\\n    for(auto i : nums) {\\n      while(top > 0 && ret[top-1] < i && discard > 0) {\\n        discard--;\\n        top--;\\n      }\\n\\n      if(top < k) {\\n        ret[top++] = i;\\n      }else{\\n        discard--;\\n      }\\n    }\\n    return ret;\\n  }\\n\\n  int *merge(int *sub1, int size1, int *sub2, int size2) {\\n    int idx1 = 0, idx2 = 0;\\n    int *ret = (int *)malloc((size1 + size2) * sizeof(int));\\n    for(int i = 0; i < size1 + size2; i++) {\\n      if(compare(sub1, size1, idx1, sub2, size2, idx2)) {\\n        ret[i] = sub1[idx1++];\\n      }else{\\n        ret[i] = sub2[idx2++];\\n      }\\n    }\\n    free(sub1);\\n    free(sub2);\\n    return ret;\\n  }\\n\\n  int *comapreAndSwap(int *ret, int *sub, int k) {\\n    if(compare(ret, k, 0, sub, k, 0)) {\\n      free(sub);\\n      return ret;\\n    }else{\\n      free(ret);\\n      return sub;\\n    }\\n  }\\n\\n  int compare(int *sub1, int size1, int idx1, int *sub2, int size2, int idx2) {\\n    if(size1 == idx1 || sub1 == NULL) {\\n      return 0;\\n    }else if(size2 == idx2) {\\n      return 1;\\n    }\\n\\n    if(sub1[idx1] > sub2[idx2]) {\\n      return 1;\\n    }else if(sub1[idx1] < sub2[idx2]){\\n      return 0;\\n    }else{\\n      return compare(sub1, size1, idx1+1, sub2, size2, idx2+1);\\n    }\\n  }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1733338,
                "title": "merger-of-nearestgreaterelement-and-lexicographical",
                "content": "**Do below problems before attempt this problem**\\n\\nhttps://leetcode.com/problems/remove-k-digits/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/remove-duplicate-letters/\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\n\\n\\t\\t   vector<int> maxNumber(vector<int> &nums1, vector<int> &nums2, int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int> ans;\\n\\t\\t\\t\\tfor (int i = 0; i <=k; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint j = k - i;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif(i>nums1.size()||j>nums2.size()) continue;\\n\\n\\t\\t\\t\\t\\tvector<int> n1 = calculateNGEType(nums1, i);\\n\\t\\t\\t\\t\\tvector<int> n2 = calculateNGEType(nums2, j);\\n\\t\\t\\t\\t\\tvector<int> t = merge(n1, n2,k);\\n\\t\\t\\t\\t\\tif(t>ans)ans=t;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tbool greater(vector<int> n1, vector<int> n2,int i,int j){\\n\\t\\t\\t\\tint ns1 = n1.size();\\n\\t\\t\\t\\tint ns2 = n2.size();\\n\\t\\t\\t\\twhile (i < ns1 || j < ns2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (i >= ns1)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\telse if (j >= ns2)\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\telse if (n1[i] > n2[j])\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\telse if (n1[i] < n2[j])\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++,j++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> merge(vector<int> n1, vector<int> n2,int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint ns1 = n1.size();\\n\\t\\t\\t\\tint ns2 = n2.size();\\n\\t\\t\\t\\tint i = 0, j = 0, l = 0;\\n\\t\\t\\t\\tvector<int> ans;\\n\\t\\t\\t\\twhile ((i < ns1 || j < ns2)&&k>0 )\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (i >= ns1)\\n\\t\\t\\t\\t\\t\\tans.push_back(n2[j++]);\\n\\t\\t\\t\\t\\telse if (j >= ns2)\\n\\t\\t\\t\\t\\t\\tans.push_back(n1[i++]);\\n\\t\\t\\t\\t\\telse if (n1[i] > n2[j])\\n\\t\\t\\t\\t\\t\\tans.push_back(n1[i++]);\\n\\t\\t\\t\\t\\telse if (n1[i] < n2[j])\\n\\t\\t\\t\\t\\t\\tans.push_back(n2[j++]);\\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(greater(n1,n2,i,j))\\n\\t\\t\\t\\t\\t\\t\\tans.push_back(n1[i++]);\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tans.push_back(n2[j++]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tk--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> calculateNGEType(vector<int> &nums1, int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint removal = nums1.size() - k;\\n\\t\\t\\t\\tvector<int> n1;\\n\\n\\t\\t\\t\\tfor (int i = 0; i < nums1.size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twhile (n1.size() > 0 && removal > 0 && n1.back() < nums1[i])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tremoval--;\\n\\t\\t\\t\\t\\t\\tn1.pop_back();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tn1.push_back(nums1[i]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn n1;\\n\\t\\t\\t}\\n\\n\\n\\t\\t};",
                "solutionTags": [
                    "Stack",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\n\\n\\t\\t   vector<int> maxNumber(vector<int> &nums1, vector<int> &nums2, int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int> ans;\\n\\t\\t\\t\\tfor (int i = 0; i <=k; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint j = k - i;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif(i>nums1.size()||j>nums2.size()) continue;\\n\\n\\t\\t\\t\\t\\tvector<int> n1 = calculateNGEType(nums1, i);\\n\\t\\t\\t\\t\\tvector<int> n2 = calculateNGEType(nums2, j);\\n\\t\\t\\t\\t\\tvector<int> t = merge(n1, n2,k);\\n\\t\\t\\t\\t\\tif(t>ans)ans=t;\\n\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1604538,
                "title": "c-recursion-memo",
                "content": "```cs\\npublic class Solution {\\n\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) {\\n        var lst = MaxNumber(GetMap(nums1), GetMap(nums2), nums1.Length + nums2.Length, 0, 0, k); lst.Reverse();\\n        return lst.ToArray();\\n    }\\n        \\n    \\n    private IDictionary<(int,int,int),List<int>> memo = new Dictionary<(int,int,int),List<int>>();\\n    \\n    private List<int> MaxNumber(IReadOnlyDictionary<int,List<int>> map1, IReadOnlyDictionary<int,List<int>> map2, int count, int pos1, int pos2, int k) {\\n        \\n        if (k == 0)\\n            return new List<int>();\\n        \\n        var key = (pos1,pos2,k);\\n        if (memo.TryGetValue(key, out List<int> m))\\n            return new List<int>(m);\\n        \\n        var has1 = TryGetValue(map1, pos1, count - pos2 - k, out int val1, out int next1);\\n        var has2 = TryGetValue(map2, pos2, count - pos1 - k, out int val2, out int next2);\\n        \\n        if (!has1 || has2 && val2 > val1) {\\n            var list = MaxNumber(map1, map2, count, pos1, next2 + 1, k - 1); list.Add(val2);\\n            memo[key] = new List<int>(list);\\n            return list;\\n        }\\n            \\n        if (!has2 || has1 && val1 > val2) {\\n            var list = MaxNumber(map1, map2, count, next1 + 1, pos2, k - 1); list.Add(val1);\\n            memo[key] = new List<int>(list);\\n            return list;\\n        }\\n        \\n        var list1 = MaxNumber(map1, map2, count, next1 + 1, pos2, k - 1);\\n        var list2 = MaxNumber(map1, map2, count, pos1, next2 + 1, k - 1);\\n        \\n        var lst = IsLess(list1, list2) ? list2 : list1; lst.Add(val1);\\n        memo[key] = new List<int>(lst);\\n        return lst;\\n    }\\n    \\n    private IReadOnlyDictionary<int,List<int>> GetMap(int[] nums) {\\n        var dic = Enumerable.Range(0, 10).ToDictionary(i => i, i => new List<int>());\\n        for(var i = 0; i < nums.Length; i++)\\n            dic[nums[i]].Add(i);\\n        return dic;\\n    }\\n    \\n    private bool TryGetValue(IReadOnlyDictionary<int,List<int>> map, int from, int to, out int value, out int pos) {\\n        for(value = 9; value >= 0; value--) {\\n            var idx = map[value].BinarySearch(from);\\n            if (idx < 0)\\n                idx = ~idx;\\n            if (idx >= map[value].Count)\\n                continue;\\n            if (map[value][idx] > to)\\n                continue;\\n            pos = map[value][idx];\\n            return true;\\n        }\\n        pos = -1;\\n        return false;\\n    }\\n    \\n    private bool IsLess(List<int> lst1, List<int> lst2) {\\n        for(var i = lst1.Count - 1; i >= 0; i--) {\\n            if (lst1[i] < lst2[i])\\n                return true;\\n            if (lst1[i] > lst2[i])\\n                return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```cs\\npublic class Solution {\\n\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) {\\n        var lst = MaxNumber(GetMap(nums1), GetMap(nums2), nums1.Length + nums2.Length, 0, 0, k); lst.Reverse();\\n        return lst.ToArray();\\n    }\\n        \\n    \\n    private IDictionary<(int,int,int),List<int>> memo = new Dictionary<(int,int,int),List<int>>();\\n    \\n    private List<int> MaxNumber(IReadOnlyDictionary<int,List<int>> map1, IReadOnlyDictionary<int,List<int>> map2, int count, int pos1, int pos2, int k) {\\n        \\n        if (k == 0)\\n            return new List<int>();\\n        \\n        var key = (pos1,pos2,k);\\n        if (memo.TryGetValue(key, out List<int> m))\\n            return new List<int>(m);\\n        \\n        var has1 = TryGetValue(map1, pos1, count - pos2 - k, out int val1, out int next1);\\n        var has2 = TryGetValue(map2, pos2, count - pos1 - k, out int val2, out int next2);\\n        \\n        if (!has1 || has2 && val2 > val1) {\\n            var list = MaxNumber(map1, map2, count, pos1, next2 + 1, k - 1); list.Add(val2);\\n            memo[key] = new List<int>(list);\\n            return list;\\n        }\\n            \\n        if (!has2 || has1 && val1 > val2) {\\n            var list = MaxNumber(map1, map2, count, next1 + 1, pos2, k - 1); list.Add(val1);\\n            memo[key] = new List<int>(list);\\n            return list;\\n        }\\n        \\n        var list1 = MaxNumber(map1, map2, count, next1 + 1, pos2, k - 1);\\n        var list2 = MaxNumber(map1, map2, count, pos1, next2 + 1, k - 1);\\n        \\n        var lst = IsLess(list1, list2) ? list2 : list1; lst.Add(val1);\\n        memo[key] = new List<int>(lst);\\n        return lst;\\n    }\\n    \\n    private IReadOnlyDictionary<int,List<int>> GetMap(int[] nums) {\\n        var dic = Enumerable.Range(0, 10).ToDictionary(i => i, i => new List<int>());\\n        for(var i = 0; i < nums.Length; i++)\\n            dic[nums[i]].Add(i);\\n        return dic;\\n    }\\n    \\n    private bool TryGetValue(IReadOnlyDictionary<int,List<int>> map, int from, int to, out int value, out int pos) {\\n        for(value = 9; value >= 0; value--) {\\n            var idx = map[value].BinarySearch(from);\\n            if (idx < 0)\\n                idx = ~idx;\\n            if (idx >= map[value].Count)\\n                continue;\\n            if (map[value][idx] > to)\\n                continue;\\n            pos = map[value][idx];\\n            return true;\\n        }\\n        pos = -1;\\n        return false;\\n    }\\n    \\n    private bool IsLess(List<int> lst1, List<int> lst2) {\\n        for(var i = lst1.Count - 1; i >= 0; i--) {\\n            if (lst1[i] < lst2[i])\\n                return true;\\n            if (lst1[i] > lst2[i])\\n                return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467393,
                "title": "c-321-create-maximum-number",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans(k); \\n        \\n        auto fn = [](vector<int>& arr, int k) {\\n            vector<int> ans(k); \\n            for (int i = 0, n = 0; i < arr.size(); ++i) {\\n                while (n && ans[n-1] < arr[i] && n + arr.size() - i > k) --n; \\n                if (n < k) ans[n++] = arr[i]; \\n            }\\n            return ans; \\n        };\\n        \\n        auto cmp = [](vector<int>& val1, int i1, vector<int>& val2, int i2) {\\n            for (; i1 < val1.size() && i2 < val2.size(); i1++, i2++) {\\n                if (val1[i1] > val2[i2]) return true; \\n                if (val1[i1] < val2[i2]) return false; \\n            }\\n            return i2 == val2.size(); \\n        };\\n        \\n        for (int i = 0; i <= k; ++i) {\\n            if (i <= nums1.size() && k-i <= nums2.size()) {\\n                vector<int> val1 = fn(nums1, i), val2 = fn(nums2, k - i); \\n                vector<int> cand; \\n                for (int i1 = 0, i2 = 0; i1 < val1.size() || i2 < val2.size(); ) \\n                    if (cmp(val1, i1, val2, i2)) cand.push_back(val1[i1++]);\\n                    else cand.push_back(val2[i2++]); \\n                ans = max(ans, cand); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans(k); \\n        \\n        auto fn = [](vector<int>& arr, int k) {\\n            vector<int> ans(k); \\n            for (int i = 0, n = 0; i < arr.size(); ++i) {\\n                while (n && ans[n-1] < arr[i] && n + arr.size() - i > k) --n; \\n                if (n < k) ans[n++] = arr[i]; \\n            }\\n            return ans; \\n        };\\n        \\n        auto cmp = [](vector<int>& val1, int i1, vector<int>& val2, int i2) {\\n            for (; i1 < val1.size() && i2 < val2.size(); i1++, i2++) {\\n                if (val1[i1] > val2[i2]) return true; \\n                if (val1[i1] < val2[i2]) return false; \\n            }\\n            return i2 == val2.size(); \\n        };\\n        \\n        for (int i = 0; i <= k; ++i) {\\n            if (i <= nums1.size() && k-i <= nums2.size()) {\\n                vector<int> val1 = fn(nums1, i), val2 = fn(nums2, k - i); \\n                vector<int> cand; \\n                for (int i1 = 0, i2 = 0; i1 < val1.size() || i2 < val2.size(); ) \\n                    if (cmp(val1, i1, val2, i2)) cand.push_back(val1[i1++]);\\n                    else cand.push_back(val2[i2++]); \\n                ans = max(ans, cand); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403797,
                "title": "c-concise-solution",
                "content": "code comments itself.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    std::deque<int> getMax(const std::vector<int> &nums, int k)\\n    {\\n        if(k == 0){\\n            return {};\\n        }\\n        \\n        std::deque<int> result;\\n        const int drop = std::max<int>(0, nums.size() - k);\\n\\n        for(int d = 0; const auto e: nums){\\n            while(!result.empty() && result.back() < e && d < drop){\\n                result.pop_back();\\n                d++;\\n            }\\n            result.push_back(e);\\n        }\\n        \\n        while(result.size() > k){\\n            result.resize(k);\\n        }\\n        return result;\\n    }\\n    \\n    std::vector<int> merge(std::deque<int> p, std::deque<int> q)\\n    {\\n        std::vector<int> result;\\n        while(!(p.empty() && q.empty())){\\n            if(p > q){\\n                result.push_back(p.front());\\n                p.pop_front();\\n            }\\n            else{\\n                result.push_back(q.front());\\n                q.pop_front();\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k)\\n    {\\n        std::vector<int> result;\\n        for(int i = 0; i <= k && i <= nums1.size(); ++i){\\n            if(int j = k - i; j <= nums2.size()){\\n                result = std::max(result, merge(getMax(nums1, i), getMax(nums2, j)));\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    std::deque<int> getMax(const std::vector<int> &nums, int k)\\n    {\\n        if(k == 0){\\n            return {};\\n        }\\n        \\n        std::deque<int> result;\\n        const int drop = std::max<int>(0, nums.size() - k);\\n\\n        for(int d = 0; const auto e: nums){\\n            while(!result.empty() && result.back() < e && d < drop){\\n                result.pop_back();\\n                d++;\\n            }\\n            result.push_back(e);\\n        }\\n        \\n        while(result.size() > k){\\n            result.resize(k);\\n        }\\n        return result;\\n    }\\n    \\n    std::vector<int> merge(std::deque<int> p, std::deque<int> q)\\n    {\\n        std::vector<int> result;\\n        while(!(p.empty() && q.empty())){\\n            if(p > q){\\n                result.push_back(p.front());\\n                p.pop_front();\\n            }\\n            else{\\n                result.push_back(q.front());\\n                q.pop_front();\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k)\\n    {\\n        std::vector<int> result;\\n        for(int i = 0; i <= k && i <= nums1.size(); ++i){\\n            if(int j = k - i; j <= nums2.size()){\\n                result = std::max(result, merge(getMax(nums1, i), getMax(nums2, j)));\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387317,
                "title": "concise-commented-dp-greedy-soln",
                "content": "\\nclass Solution {\\npublic:\\n    vector<string> single_array(vector<int>& arr1,int k)\\n    {\\n        int n = arr1.size();\\n        vector<vector<string>> dp(min(n,k),vector<string>(n,\"\"));//i+1 digits and ending at j maintaining ordering\\n        vector<string> dp1(min(n,k),\"\"); //max i-digit number formed maintaing ordering\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n            dp[0][j].push_back((char)(arr1[j]+\\'0\\'));\\n            dp1[0] = max(dp1[0],dp[0][j]);\\n            if(j>0) dp[0][j] = max(dp[0][j],dp[0][j-1]);\\n        }\\n        \\n        for(int i=1;i<dp1.size();i++)\\n        {\\n            // num of digits required is i+1\\n            // we start at i, not before that\\n            for(int j=i;j<n;j++)\\n            {\\n                dp[i][j] = max(dp[i][j],dp[i-1][j-1]+(char)(arr1[j]+\\'0\\'));\\n                dp1[i] = max(dp[i][j],dp1[i]);\\n                if(j>i) dp[i][j] = max(dp[i][j],dp[i][j-1]); \\n                // beware : max on strings works as expected when both strings are of same size\\n            }\\n        }\\n        return dp1;\\n        \\n    }\\n    \\n    string merge(string r1,string r2)\\n    {\\n        string fin = \"\";\\n        int n = r1.size();\\n        int m = r2.size();\\n        int p1 = 0;\\n        int p2 = 0;\\n        while(p1<n && p2<m)\\n        {\\n            if(r1[p1]>r2[p2])\\n            {\\n                fin.push_back(r1[p1]);\\n                p1++;\\n            }\\n            else if(r1[p1]<r2[p2])\\n            {\\n                fin.push_back(r2[p2]);\\n                p2++;\\n            }\\n            else\\n            {\\n                if(r1.substr(p1)>=r2.substr(p2))\\n                {\\n                    fin.push_back(r1[p1]);\\n                    p1++;\\n                }\\n                else\\n                {\\n                    fin.push_back(r2[p2]);\\n                    p2++;\\n                }\\n            }\\n        }\\n        while(p1<n) \\n        {\\n            fin.push_back(r1[p1]);p1++;\\n        }\\n        while(p2<m) \\n        {\\n            fin.push_back(r2[p2]);p2++;\\n        }\\n        return fin;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& arr1, vector<int>& arr2, int k) \\n    {\\n        vector<int> ans;\\n        int n = arr1.size();\\n        int m = arr2.size();\\n        if(n==0 && m==0) return ans;\\n        if(k==0) return ans;\\n        \\n        vector<string> dp1 = single_array(arr1,k);\\n        vector<string> dp2 = single_array(arr2,k);\\n        \\n        string an = \"\";\\n        for(int i=0;i<=k;i++)\\n        {\\n            int sz1 = i;\\n            int sz2 = k-i;\\n            if(sz1==0 && sz2<=m) an = max(an,dp2[sz2-1]);\\n            else if(sz2==0 && sz1<=n) an = max(an,dp1[sz1-1]);\\n            else if(sz1<=n && sz2<=m) an = max(an,merge(dp1[sz1-1],dp2[sz2-1]));\\n        }\\n        \\n        \\n        for(auto c:an) ans.push_back(c-\\'0\\');\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> single_array(vector<int>& arr1,int k)\\n    {\\n        int n = arr1.size();\\n        vector<vector<string>> dp(min(n,k),vector<string>(n,\"\"));//i+1 digits and ending at j maintaining ordering\\n        vector<string> dp1(min(n,k),\"\"); //max i-digit number formed maintaing ordering\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n            dp[0][j].push_back((char)(arr1[j]+\\'0\\'));\\n            dp1[0] = max(dp1[0],dp[0][j]);\\n            if(j>0) dp[0][j] = max(dp[0][j],dp[0][j-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 968913,
                "title": "bfs-runtime-112-ms-faster-than-100-00-current-python",
                "content": "Runtime: 112 ms, faster than 100.00%\\nMemory Usage: 14.4 MB, less than 63.64%\\n# Explanation:\\nLet N1 be the lenghth of nums1, and N2 the length of nums2.\\nThe `remain` is initialized to `k`, and reduced by 1 after choosed a candidate every time.\\n\\nThe 1st candidate must be in `nums1[0:min(len(nums1), max_skip+1)]` and `nums2[0:min(len(nums2), max_skip+1)]`, and the `max_skip` is the max number we can drop which equal to `N1 + N2 - remain`.\\n\\nAsume we get the 1st number at index `i1` in nums1.\\nThe 2nd candidate must be in `nums1[i1+1:min(len(nums1), i1+1+max_skip+1)]` and `nums2[0:min(len(nums2), max_skip+1)]`. the `max_skip` is `N1-i1+N2-0-remain`\\n....\\nThe (k+1)th candidate must be in `nums1[i1+1:min(len(nums1), i1+1+max_skip+1)]` and `nums2[i2+1:min(len(nums2), i2+1+max_skip+1)]`. the `max_skip` is `N1-i1+N2-i2-remain`\\n\\nFor each level (represented by remain), we can we choose the best value for the current number.\\n\\nI hope this solution can help you.\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: [int], nums2: [int], k: int) -> [int]:\\n        N1 = len(nums1)\\n        N2 = len(nums2)\\n\\n        def _get_candidate(nums, start, max_skip):\\n            j = start\\n            v = -1\\n            for i in range(start, min(len(nums), start+max_skip+1)):\\n                if v < nums[i]:\\n                    j = i\\n                    v = nums[j]\\n                    if nums[j] == 9:break\\n            return j,v\\n        \\n        next_candidates = {(0,0)}\\n        ret = [0]*k\\n        for remain in range(k,0,-1):\\n            candidates = next_candidates\\n            next_candidates = set()\\n            value_max = -1\\n            for (i1,i2) in candidates:\\n                if i1 >= N1 and i2 >= N2: continue\\n                r1 = N1 - i1\\n                r2 = N2 - i2\\n                max_skip = r1 + r2 - remain\\n\\n                j1,v1 = _get_candidate(nums1, i1, max_skip)\\n                j2,v2 = _get_candidate(nums2, i2, max_skip)\\n\\n                if v1 > value_max:\\n                    next_candidates = {(j1+1, i2)}\\n                    value_max = v1\\n                elif v1 == value_max:\\n                    next_candidates.add((j1+1, i2))\\n                \\n                if v2 > value_max:\\n                    next_candidates = {(i1, j2+1)}\\n                    value_max = v2\\n                elif v2 == value_max:\\n                    next_candidates.add((i1, j2+1))\\n            ret[-remain] = value_max\\n            \\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: [int], nums2: [int], k: int) -> [int]:\\n        N1 = len(nums1)\\n        N2 = len(nums2)\\n\\n        def _get_candidate(nums, start, max_skip):\\n            j = start\\n            v = -1\\n            for i in range(start, min(len(nums), start+max_skip+1)):\\n                if v < nums[i]:\\n                    j = i\\n                    v = nums[j]\\n                    if nums[j] == 9:break\\n            return j,v\\n        \\n        next_candidates = {(0,0)}\\n        ret = [0]*k\\n        for remain in range(k,0,-1):\\n            candidates = next_candidates\\n            next_candidates = set()\\n            value_max = -1\\n            for (i1,i2) in candidates:\\n                if i1 >= N1 and i2 >= N2: continue\\n                r1 = N1 - i1\\n                r2 = N2 - i2\\n                max_skip = r1 + r2 - remain\\n\\n                j1,v1 = _get_candidate(nums1, i1, max_skip)\\n                j2,v2 = _get_candidate(nums2, i2, max_skip)\\n\\n                if v1 > value_max:\\n                    next_candidates = {(j1+1, i2)}\\n                    value_max = v1\\n                elif v1 == value_max:\\n                    next_candidates.add((j1+1, i2))\\n                \\n                if v2 > value_max:\\n                    next_candidates = {(i1, j2+1)}\\n                    value_max = v2\\n                elif v2 == value_max:\\n                    next_candidates.add((i1, j2+1))\\n            ret[-remain] = value_max\\n            \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721063,
                "title": "go-divide-and-conquer",
                "content": "```\\nfunc maxNumber(nums1 []int, nums2 []int, k int) []int {\\n    res := make([]int, k)\\n    for i := 0; i <= k; i++ {\\n        if len(nums1) >= i && len(nums2) >= k - i {\\n            res1 := getMax(nums1, i)\\n            res2 := getMax(nums2, k - i)\\n            temp := merge(res1, res2)\\n            if isLarger(temp, res) {\\n                res = temp\\n            }\\n        }\\n    }\\n    return res\\n}\\n\\nfunc getMax(nums []int, k int) []int {\\n    discard := len(nums) - k\\n    var stack []int\\n    for i := 0; i < len(nums); i++ {\\n        for len(stack) > 0 && discard > 0 && stack[len(stack) - 1] < nums[i] {\\n            stack = stack[:len(stack) - 1]\\n            discard--\\n        }\\n        stack = append(stack, nums[i])\\n    }\\n    return stack[:k]\\n}\\n\\nfunc merge(a []int, b []int) []int {\\n    var res []int\\n    for len(a) > 0 && len(b) > 0 {\\n        if isLarger(a, b) {\\n            res = append(res, a[0])\\n            a = a[1:]\\n        } else {\\n            res = append(res, b[0])\\n            b = b[1:]\\n        }\\n    }\\n    \\n    if len(a) > 0 {\\n        res = append(res, a...)\\n    }\\n    \\n    if len(b) > 0 {\\n        res = append(res, b...)\\n    }\\n    \\n    return res\\n}\\n\\nfunc isLarger(a []int, b []int) bool {\\n    l := min(len(a), len(b))\\n    for i := 0; i < l; i++ {\\n        if a[i] < b[i] {\\n            return false\\n        } else if a[i] > b[i] {\\n            return true\\n        }\\n    }\\n    return len(a) > len(b)\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maxNumber(nums1 []int, nums2 []int, k int) []int {\\n    res := make([]int, k)\\n    for i := 0; i <= k; i++ {\\n        if len(nums1) >= i && len(nums2) >= k - i {\\n            res1 := getMax(nums1, i)\\n            res2 := getMax(nums2, k - i)\\n            temp := merge(res1, res2)\\n            if isLarger(temp, res) {\\n                res = temp\\n            }\\n        }\\n    }\\n    return res\\n}\\n\\nfunc getMax(nums []int, k int) []int {\\n    discard := len(nums) - k\\n    var stack []int\\n    for i := 0; i < len(nums); i++ {\\n        for len(stack) > 0 && discard > 0 && stack[len(stack) - 1] < nums[i] {\\n            stack = stack[:len(stack) - 1]\\n            discard--\\n        }\\n        stack = append(stack, nums[i])\\n    }\\n    return stack[:k]\\n}\\n\\nfunc merge(a []int, b []int) []int {\\n    var res []int\\n    for len(a) > 0 && len(b) > 0 {\\n        if isLarger(a, b) {\\n            res = append(res, a[0])\\n            a = a[1:]\\n        } else {\\n            res = append(res, b[0])\\n            b = b[1:]\\n        }\\n    }\\n    \\n    if len(a) > 0 {\\n        res = append(res, a...)\\n    }\\n    \\n    if len(b) > 0 {\\n        res = append(res, b...)\\n    }\\n    \\n    return res\\n}\\n\\nfunc isLarger(a []int, b []int) bool {\\n    l := min(len(a), len(b))\\n    for i := 0; i < l; i++ {\\n        if a[i] < b[i] {\\n            return false\\n        } else if a[i] > b[i] {\\n            return true\\n        }\\n    }\\n    return len(a) > len(b)\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720999,
                "title": "10-lines-with-explanation",
                "content": "### Gready + Merge Sort\\nSince we need construct the maximum number from given arrays, the gready approach seems to be the core diea resovling this problem, which is to select the maximum number and check if we can pick it. We can\\'t pick the current number if the number of remaining elements are smaller than *K* as we don\\'t have enough elements to pick *k* times. There are two different apparchs for us to select maximum elements. The first one is to find maximum between 2 arrays, namely we combine 2 arraysy and pick the maximum number to construct the global maximum result. The other one is to select maximum number for each array respectively, and merge it as local maximum and return the maximum one. As the local maximum is not always the global maximum in the first approach, we need go with second appraoch, which is much easier to implement as well.\\nHence, the algorithm could be\\n1. We pick the first `length` th maximum numbers from *nums1* and the other `k - length` th maximum numbers from *nums2*\\n2. Construct the local maximum nubmer by merging and record it if it\\'s the maximum so far\\n3. Repeat the process for the `length` + 1 until it reaches the `min(k, nums1.length)`\\n\\nNote, we have variance on the `merge`, where we pick larger one if `nums1[i] != nums2[j]`, otherwise the one with larger successors.\\n\\n```python\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        m = len(nums1)\\n        n = len(nums2)\\n        \\n        def getMax(nums, k):\\n            ans, i, n = [], 0, len(nums)\\n            while i < n:\\n                while ans and nums[i] > ans[-1] and n - i + len(ans) > k:\\n                    ans.pop()\\n                ans.append(nums[i]) \\n                i += 1\\n            return ans[:k]\\n        \\n        def merge(nums1, nums2):\\n            return [max(nums1, nums2).popleft() for _ in range(len(nums1) + len(nums2))]\\n            \\n        return max(merge(deque(getMax(nums1, length)), deque(getMax(nums2, k - length))) for length in range(max(0, k - n), min(k, m) + 1))\\n```\\n\\n*Time Complexity* = **O(k(n1 + n2)^2)**, *n1*, *n2* denotes the length of arrays respectively\\n*Space Complexity* = **O(k)**",
                "solutionTags": [],
                "code": "```python\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        m = len(nums1)\\n        n = len(nums2)\\n        \\n        def getMax(nums, k):\\n            ans, i, n = [], 0, len(nums)\\n            while i < n:\\n                while ans and nums[i] > ans[-1] and n - i + len(ans) > k:\\n                    ans.pop()\\n                ans.append(nums[i]) \\n                i += 1\\n            return ans[:k]\\n        \\n        def merge(nums1, nums2):\\n            return [max(nums1, nums2).popleft() for _ in range(len(nums1) + len(nums2))]\\n            \\n        return max(merge(deque(getMax(nums1, length)), deque(getMax(nums2, k - length))) for length in range(max(0, k - n), min(k, m) + 1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 694946,
                "title": "java-greedy-solution",
                "content": "```\\nclass Solution {\\n    public int[] maxNumber(int[] A, int[] B, int k) {\\n        if(A.length==0)return get(B,k,true);\\n        if(B.length==0)return get(A,k,true);\\n        int res[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            int A1[]=get(A,i,false);\\n            int A2[]=get(B,k-i,false);\\n            if(A1==null||A2==null)continue;\\n            int newA[]=merge(A1,A2);\\n            if(compare(res,newA)){\\n                res=newA;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean compare(int A[],int B[]){\\n        for(int i=0;i<A.length;i++){\\n            if(B[i]==A[i])continue;\\n            if(B[i]>A[i])return true;\\n            else return false;\\n        }\\n        return false;\\n    }\\n    \\n    public int[] merge(int A[],int B[]){\\n        int res[]=new int[A.length+B.length-2];\\n        int i=0,j=0,k=0;\\n        while(i<A.length-1&&j<B.length-1){\\n            if(A[i]>B[j]){\\n                res[k++]=A[i++];\\n            }else if(B[j]>A[i]){\\n                res[k++]=B[j++];\\n            }else{//equal\\n                int ii=i,jj=j;\\n                int prei=i,prej=j;\\n                while(ii<A.length-1&&jj<B.length-1){\\n                    while(ii<A.length-1&&A[ii]==A[prei])ii++;\\n                    while(jj<B.length-1&&B[jj]==B[prej])jj++;\\n                    if(ii<A.length-1&&jj<B.length-1&&A[ii]==B[jj]&&(ii-i==jj-j)){\\n                        prei=ii;prej=jj;\\n                        continue;\\n                    }\\n                    else break;\\n                }\\n                if(ii-i==jj-j){\\n                    if(A[ii]>B[jj])res[k++]=A[i++];\\n                    else res[k++]=B[j++];\\n                }else if(ii-i<jj-j){\\n                    if(A[ii]>B[prej])res[k++]=A[i++];\\n                    else res[k++]=B[j++];\\n                }else{\\n                   if(B[jj]>A[prei])res[k++]=B[j++];\\n                    else res[k++]=A[i++]; \\n                }\\n                \\n            }\\n        }\\n        while(i<A.length-1)res[k++]=A[i++];\\n        while(j<B.length-1)res[k++]=B[j++];\\n        return res;\\n    }\\n    \\n    public void print(int A[]){\\n        for(int i:A)System.out.print(i+\"  \");\\n        System.out.println();\\n    }\\n    \\n    public int[] get(int A[],int k,boolean flag){\\n        if(k>A.length)return null;\\n        Stack<Integer>stack=new Stack<>();\\n        int res[]=new int[k];\\n        for(int i=0;i<A.length;i++){\\n            int remain=A.length-(i+1);\\n            while(stack.size()!=0&&A[i]>stack.peek()&&stack.size()+remain>=k)stack.pop();\\n            stack.push(A[i]);\\n        }\\n        int index=res.length-1;\\n        while(stack.size()>k)stack.pop();\\n        while(stack.size()!=0){\\n            res[index--]=stack.pop();\\n        }\\n        if(flag)return res;\\n        int ans[]=new int[res.length+1];\\n        for(int i=0;i<res.length;i++)ans[i]=res[i];\\n        ans[ans.length-1]=Integer.MIN_VALUE;\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxNumber(int[] A, int[] B, int k) {\\n        if(A.length==0)return get(B,k,true);\\n        if(B.length==0)return get(A,k,true);\\n        int res[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            int A1[]=get(A,i,false);\\n            int A2[]=get(B,k-i,false);\\n            if(A1==null||A2==null)continue;\\n            int newA[]=merge(A1,A2);\\n            if(compare(res,newA)){\\n                res=newA;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean compare(int A[],int B[]){\\n        for(int i=0;i<A.length;i++){\\n            if(B[i]==A[i])continue;\\n            if(B[i]>A[i])return true;\\n            else return false;\\n        }\\n        return false;\\n    }\\n    \\n    public int[] merge(int A[],int B[]){\\n        int res[]=new int[A.length+B.length-2];\\n        int i=0,j=0,k=0;\\n        while(i<A.length-1&&j<B.length-1){\\n            if(A[i]>B[j]){\\n                res[k++]=A[i++];\\n            }else if(B[j]>A[i]){\\n                res[k++]=B[j++];\\n            }else{//equal\\n                int ii=i,jj=j;\\n                int prei=i,prej=j;\\n                while(ii<A.length-1&&jj<B.length-1){\\n                    while(ii<A.length-1&&A[ii]==A[prei])ii++;\\n                    while(jj<B.length-1&&B[jj]==B[prej])jj++;\\n                    if(ii<A.length-1&&jj<B.length-1&&A[ii]==B[jj]&&(ii-i==jj-j)){\\n                        prei=ii;prej=jj;\\n                        continue;\\n                    }\\n                    else break;\\n                }\\n                if(ii-i==jj-j){\\n                    if(A[ii]>B[jj])res[k++]=A[i++];\\n                    else res[k++]=B[j++];\\n                }else if(ii-i<jj-j){\\n                    if(A[ii]>B[prej])res[k++]=A[i++];\\n                    else res[k++]=B[j++];\\n                }else{\\n                   if(B[jj]>A[prei])res[k++]=B[j++];\\n                    else res[k++]=A[i++]; \\n                }\\n                \\n            }\\n        }\\n        while(i<A.length-1)res[k++]=A[i++];\\n        while(j<B.length-1)res[k++]=B[j++];\\n        return res;\\n    }\\n    \\n    public void print(int A[]){\\n        for(int i:A)System.out.print(i+\"  \");\\n        System.out.println();\\n    }\\n    \\n    public int[] get(int A[],int k,boolean flag){\\n        if(k>A.length)return null;\\n        Stack<Integer>stack=new Stack<>();\\n        int res[]=new int[k];\\n        for(int i=0;i<A.length;i++){\\n            int remain=A.length-(i+1);\\n            while(stack.size()!=0&&A[i]>stack.peek()&&stack.size()+remain>=k)stack.pop();\\n            stack.push(A[i]);\\n        }\\n        int index=res.length-1;\\n        while(stack.size()>k)stack.pop();\\n        while(stack.size()!=0){\\n            res[index--]=stack.pop();\\n        }\\n        if(flag)return res;\\n        int ans[]=new int[res.length+1];\\n        for(int i=0;i<res.length;i++)ans[i]=res[i];\\n        ans[ans.length-1]=Integer.MIN_VALUE;\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678498,
                "title": "c-a-horrible-but-efficient-solution",
                "content": "The idea is to build a binary tree based on sorted indices. The binary tree definition is as follows:\\n\\n```\\nstruct MyTreeNode{\\n\\xA0 \\xA0 MyTreeNode(int idx, int val): idx(idx), val(val), left(nullptr), right(nullptr){}\\n\\xA0\\n\\xA0 \\xA0 int idx;\\n\\xA0 \\xA0 int val;\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 MyTreeNode * left;\\n\\xA0 \\xA0 MyTreeNode * right;\\n};\\n```\\n\\nTha property val holds the value and idx holds the corresponding inex.\\nWe build a binary tree from each of the input arrays as follows. First we pick the largest element in the vector. Suppose it has index i. We create the root node from it. The index i splits the vector into two  (not necessarily equal) parts. The right node of the root is the largest element on the right side, i.e. max(nums[j] ) j>i and the left one is the largest in the left side.  \\n\\nThe code that builds the binary tree looks as follows:\\n\\n```\\nMyTreeNode * getTree( const vector<int>& nums){\\n\\xA0 \\xA0 \\xA0 \\xA0 if(nums.empty())\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 return nullptr;\\n\\t\\t\\t\\n\\xA0 \\xA0 \\xA0 \\xA0 vector<int> indices(nums.size());\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i = 0; i < indices.size(); ++i)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 indices[i] = i;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\t\\t// after this the vector indices will hold the indices that sort nums in descending order\\n\\xA0 \\xA0 \\xA0 \\xA0 sort(indices.begin(), indices.end(), [&](const int & a, const int &b){ if(nums[a] == nums[b]) return a <b; else return nums[a] > nums[b]; });\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * head = new MyTreeNode(indices[0], nums[indices[0]]); \\xA0 \\xA0 \\xA0\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i = 1; i < indices.size(); ++i)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 insert(head, indices[i], nums[indices[i]]);\\n\\xA0 \\xA0 \\xA0 \\xA0 return head;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 }\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 void insert(MyTreeNode * head, int idx, int val){\\n\\xA0 \\xA0 \\xA0 \\xA0 if(idx > head->idx) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(head->right)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 insert(head->right, idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 else\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 head->right = new MyTreeNode(idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 else\\n\\xA0 \\xA0 \\xA0 \\xA0 {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(head->left)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 insert(head->left, idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 else\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 head->left = new MyTreeNode(idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 }\\n```\\n\\nHaving the corresponding tree it easy to find the next candidate element to pick. For each array we keep the last picked index idx1 ord idx2. \\n\\nWe start from the root of each tree. The candidate node should have idx value greater than the last picked index. So, if for any node *cur* this condition is not satisfyed we move to its right child.  On the other hand, the element can be so much right in the array, that the number of the remaining items is not enough for filling the resulting vector with k elements. If this is the case then we move to the left. As soon as we arrive to a node, we can be sure that it is the largest node that satifies both requirements.\\n\\nThe code for this navigation reads:\\n\\n```\\nMyTreeNode * \\xA0getCandidate(MyTreeNode * node, int idx1, int remaining_items){\\n\\xA0 \\xA0 while(node){\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 if(remaining_items \\xA0- \\xA0node->idx < 0)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 node = node->left;\\n\\xA0 \\xA0 \\xA0 \\xA0 else if (node->idx <= idx1 )\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 node = node->right;\\n\\xA0 \\xA0 \\xA0 \\xA0 else \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 break;\\n \\xA0 }\\n\\xA0 \\xA0return node;\\n}\\n```\\n\\n**Solution with no collisions** (Attention: this one is not accepted).\\n\\n```\\nclass Solution{\\npublic:\\n   vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        MyTreeNode * t1 = getTree(nums1);\\n\\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * t2 = getTree(nums2);\\n\\xA0 \\xA0 \\xA0 \\xA0 vector<int> result;\\n\\t\\t\\n\\t\\tint idx1 = -1, idx2 = -1;\\n\\t\\twhile(k > result.size()){\\n\\t\\t    MyTreeNode * cur1 = getCandidate(t1, idx1, nums1.size() \\xA0+ nums2.size() - idx2 -1 - k + result.size());\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * cur2 = getCandidate(t2, idx2, nums1.size() \\xA0+ nums2.size() - idx1 -1 - k + result.size());\\n\\t\\t\\t\\n\\t\\t\\t// We then merge sort these trees into the result\\n\\t\\t\\tif(cur1 && cur2){\\n\\t\\t\\t    if(cur1->val == cur2->val){\\n\\t\\t\\t\\t    // this one is tricky so let us for a moment assume that we do not encounter such cases\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(cur1->val > cur2->val){\\n\\t\\t\\t\\t    // Move the last picked index of the first array \\n\\t\\t\\t\\t    idx1 = cur1->idx;\\n\\t\\t\\t\\t\\t// Append to the result\\n\\t\\t\\t\\t\\tresult.push_back(cur1->val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t    idx2 = cur2->idx;\\n\\t\\t\\t\\t\\tresult.push_back(cur2->val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(cur1){\\n\\t\\t\\t     idx1 = cur1->idx;\\n\\t\\t\\t     result.push_back(cur1->val);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t    idx2 = cur2->idx;\\n\\t\\t\\t\\tresult.push_back(cur2->val);\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\n    }\\n\\n};\\n```\\n\\nThe problem arises when the values of the candidate nodes are equal. I could not find a better solution to this rather than to maintain all possible paths until at some stage some of the paths give a smaller value to pick. For this reason let us introduce\\n\\n```\\nstruct State{\\n\\xA0 \\xA0 State(int idx1, int idx2, int value=numeric_limits<int>::min()): idx1(idx1), idx2(idx2), max_value(value){}\\n\\t\\n\\tint idx1;\\n\\xA0 \\xA0 int idx2; \\xA0 \\n\\xA0 \\xA0 int max_value;\\n\\t\\n    bool operator ==(const State & other) const {\\n        return idx1 == other.idx1 && idx2 == other.idx2;\\n    }\\n};\\n```\\n\\n\\nAnd the code becomes (ugly!!!):\\n\\n```\\nclass Solution{\\npublic:\\n   vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        MyTreeNode * t1 = getTree(nums1);\\n\\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * t2 = getTree(nums2);\\n\\xA0 \\xA0 \\xA0 \\xA0 vector<int> result;\\n\\t\\t\\n\\t\\tlist<State> states;\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 states.push_front (State(-1,-1));\\n\\t\\t\\n\\t\\tint idx1 = -1, idx2 = -1;\\n\\t\\twhile(k > result.size()){\\n\\t\\t    int max_value = numeric_limits<int>::min();\\n\\t\\t\\tlist<State> states_to_add;\\n\\t\\t    for(State & st: states){\\n\\n                MyTreeNode * cur1 = getCandidate(t1, st.idx1, nums1.size() \\xA0+ nums2.size() - st.idx2 -1 - k + result.size());\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0     MyTreeNode * cur2 = getCandidate(t2, st.idx2, nums1.size() \\xA0+ nums2.size() - st.idx1 -1 - k + result.size());\\n\\t\\t\\t\\n\\t\\t\\t    // We then merge sort these trees into the result\\n\\t\\t\\t    if(cur1 && cur2){\\n\\t\\t\\t        if(cur1->val == cur2->val){\\n\\t\\t\\t\\t        // We create 2 new states instead of one so that the comuptation will be done for both possible paths\\n\\t\\t\\t\\t\\t\\tmax_value  = max(max_value, cur1->val );\\n\\t\\t\\t\\t\\t\\tstates_to_add.push_front(State(cur1->idx, st.idx2, cur1->value));\\n\\t\\t\\t\\t\\t\\tstates_to_add.push_front(State(st.idx1, cur2->idx, cur2->value));\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// We set this so it is removed in below\\n\\t\\t\\t\\t\\t\\tst.max_value = numeric_limits<int>::min();\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    else if(cur1->val > cur2->val){\\t\\t\\t\\t    \\n\\t\\t\\t\\t        st.idx1 = cur1->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t    max_value  = max(max_value, cur1->val );\\n\\t\\t\\t\\t\\t    st.max_value = cur1->val;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    else {\\n\\t\\t\\t\\t         st.idx2 = cur2->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t     max_value  = max(max_value, cur2->val );\\n\\t\\t\\t\\t\\t     st.max_value = cur2->val;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t    }\\n\\t\\t\\t    else if(cur1){\\n\\t\\t\\t        st.idx1 = cur1->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t    max_value  = max(max_value, cur1->val );\\n\\t\\t\\t\\t    st.max_value = cur1->val;\\n\\t\\t\\t    }\\n\\t\\t\\t    else{\\n\\t\\t\\t        st.idx2 = cur2->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t    max_value  = max(max_value, cur2->val );\\n\\t\\t\\t\\t    st.max_value = cur2->val;\\t\\n\\t\\t\\t    }\\n\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t    result.push_back(max_value);\\n\\t\\t\\t// We should remove all the states which are doing worse than the best one\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n            states.remove_if([&](const State & st){return st.max_value < max_value;});\\n\\t\\t\\t\\n\\t\\t\\t// Add newly create states\\n\\t\\t\\tfor(State st: states_to_add)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(st.max_value == max_value)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 states.push_front(st);\\n\\t\\t}\\n\\n    }\\n\\n};\\n```\\n\\nIt turns out, however, that the picking paths are not unique and states can merge later. I was lazy to find a good solution for this so just copy-pasted a similar code from one of my projects. We just add hashing function to the std namespace (outside any scope )\\n\\n```\\nnamespace std{\\ntemplate<>\\nstruct hash<State> {\\n  std::size_t operator()(const State & state) const noexcept {\\n    std::hash<int> hasher;\\n    size_t seed = hasher(state.idx1);\\n\\t// from boost\\n    seed ^= hasher(state.idx2) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n    return seed;\\n  }\\n};\\n}\\n```\\n\\nAnd at the very end of the while(k > result.size()) loop just add this stupid code \\n\\n```\\nunordered_set<State> unique_states(states.begin(), states.end());\\nif(unique_states.size()!= states.size()){\\n    states.clear();\\n    for(const State &st: unique_states)\\n        states.push_front(st);\\n}\\n```\\n\\n\\nI will appretiate if someone points a good way to tackle the state problem and/or any other comments",
                "solutionTags": [],
                "code": "```\\nstruct MyTreeNode{\\n\\xA0 \\xA0 MyTreeNode(int idx, int val): idx(idx), val(val), left(nullptr), right(nullptr){}\\n\\xA0\\n\\xA0 \\xA0 int idx;\\n\\xA0 \\xA0 int val;\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 MyTreeNode * left;\\n\\xA0 \\xA0 MyTreeNode * right;\\n};\\n```\n```\\nMyTreeNode * getTree( const vector<int>& nums){\\n\\xA0 \\xA0 \\xA0 \\xA0 if(nums.empty())\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 return nullptr;\\n\\t\\t\\t\\n\\xA0 \\xA0 \\xA0 \\xA0 vector<int> indices(nums.size());\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i = 0; i < indices.size(); ++i)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 indices[i] = i;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\t\\t// after this the vector indices will hold the indices that sort nums in descending order\\n\\xA0 \\xA0 \\xA0 \\xA0 sort(indices.begin(), indices.end(), [&](const int & a, const int &b){ if(nums[a] == nums[b]) return a <b; else return nums[a] > nums[b]; });\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * head = new MyTreeNode(indices[0], nums[indices[0]]); \\xA0 \\xA0 \\xA0\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i = 1; i < indices.size(); ++i)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 insert(head, indices[i], nums[indices[i]]);\\n\\xA0 \\xA0 \\xA0 \\xA0 return head;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 }\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 void insert(MyTreeNode * head, int idx, int val){\\n\\xA0 \\xA0 \\xA0 \\xA0 if(idx > head->idx) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(head->right)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 insert(head->right, idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 else\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 head->right = new MyTreeNode(idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 else\\n\\xA0 \\xA0 \\xA0 \\xA0 {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(head->left)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 insert(head->left, idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 else\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 head->left = new MyTreeNode(idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 }\\n```\n```\\nMyTreeNode * \\xA0getCandidate(MyTreeNode * node, int idx1, int remaining_items){\\n\\xA0 \\xA0 while(node){\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 if(remaining_items \\xA0- \\xA0node->idx < 0)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 node = node->left;\\n\\xA0 \\xA0 \\xA0 \\xA0 else if (node->idx <= idx1 )\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 node = node->right;\\n\\xA0 \\xA0 \\xA0 \\xA0 else \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 break;\\n \\xA0 }\\n\\xA0 \\xA0return node;\\n}\\n```\n```\\nclass Solution{\\npublic:\\n   vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        MyTreeNode * t1 = getTree(nums1);\\n\\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * t2 = getTree(nums2);\\n\\xA0 \\xA0 \\xA0 \\xA0 vector<int> result;\\n\\t\\t\\n\\t\\tint idx1 = -1, idx2 = -1;\\n\\t\\twhile(k > result.size()){\\n\\t\\t    MyTreeNode * cur1 = getCandidate(t1, idx1, nums1.size() \\xA0+ nums2.size() - idx2 -1 - k + result.size());\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * cur2 = getCandidate(t2, idx2, nums1.size() \\xA0+ nums2.size() - idx1 -1 - k + result.size());\\n\\t\\t\\t\\n\\t\\t\\t// We then merge sort these trees into the result\\n\\t\\t\\tif(cur1 && cur2){\\n\\t\\t\\t    if(cur1->val == cur2->val){\\n\\t\\t\\t\\t    // this one is tricky so let us for a moment assume that we do not encounter such cases\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(cur1->val > cur2->val){\\n\\t\\t\\t\\t    // Move the last picked index of the first array \\n\\t\\t\\t\\t    idx1 = cur1->idx;\\n\\t\\t\\t\\t\\t// Append to the result\\n\\t\\t\\t\\t\\tresult.push_back(cur1->val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t    idx2 = cur2->idx;\\n\\t\\t\\t\\t\\tresult.push_back(cur2->val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(cur1){\\n\\t\\t\\t     idx1 = cur1->idx;\\n\\t\\t\\t     result.push_back(cur1->val);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t    idx2 = cur2->idx;\\n\\t\\t\\t\\tresult.push_back(cur2->val);\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\n    }\\n\\n};\\n```\n```\\nstruct State{\\n\\xA0 \\xA0 State(int idx1, int idx2, int value=numeric_limits<int>::min()): idx1(idx1), idx2(idx2), max_value(value){}\\n\\t\\n\\tint idx1;\\n\\xA0 \\xA0 int idx2; \\xA0 \\n\\xA0 \\xA0 int max_value;\\n\\t\\n    bool operator ==(const State & other) const {\\n        return idx1 == other.idx1 && idx2 == other.idx2;\\n    }\\n};\\n```\n```\\nclass Solution{\\npublic:\\n   vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        MyTreeNode * t1 = getTree(nums1);\\n\\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * t2 = getTree(nums2);\\n\\xA0 \\xA0 \\xA0 \\xA0 vector<int> result;\\n\\t\\t\\n\\t\\tlist<State> states;\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 states.push_front (State(-1,-1));\\n\\t\\t\\n\\t\\tint idx1 = -1, idx2 = -1;\\n\\t\\twhile(k > result.size()){\\n\\t\\t    int max_value = numeric_limits<int>::min();\\n\\t\\t\\tlist<State> states_to_add;\\n\\t\\t    for(State & st: states){\\n\\n                MyTreeNode * cur1 = getCandidate(t1, st.idx1, nums1.size() \\xA0+ nums2.size() - st.idx2 -1 - k + result.size());\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0     MyTreeNode * cur2 = getCandidate(t2, st.idx2, nums1.size() \\xA0+ nums2.size() - st.idx1 -1 - k + result.size());\\n\\t\\t\\t\\n\\t\\t\\t    // We then merge sort these trees into the result\\n\\t\\t\\t    if(cur1 && cur2){\\n\\t\\t\\t        if(cur1->val == cur2->val){\\n\\t\\t\\t\\t        // We create 2 new states instead of one so that the comuptation will be done for both possible paths\\n\\t\\t\\t\\t\\t\\tmax_value  = max(max_value, cur1->val );\\n\\t\\t\\t\\t\\t\\tstates_to_add.push_front(State(cur1->idx, st.idx2, cur1->value));\\n\\t\\t\\t\\t\\t\\tstates_to_add.push_front(State(st.idx1, cur2->idx, cur2->value));\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// We set this so it is removed in below\\n\\t\\t\\t\\t\\t\\tst.max_value = numeric_limits<int>::min();\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    else if(cur1->val > cur2->val){\\t\\t\\t\\t    \\n\\t\\t\\t\\t        st.idx1 = cur1->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t    max_value  = max(max_value, cur1->val );\\n\\t\\t\\t\\t\\t    st.max_value = cur1->val;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    else {\\n\\t\\t\\t\\t         st.idx2 = cur2->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t     max_value  = max(max_value, cur2->val );\\n\\t\\t\\t\\t\\t     st.max_value = cur2->val;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t    }\\n\\t\\t\\t    else if(cur1){\\n\\t\\t\\t        st.idx1 = cur1->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t    max_value  = max(max_value, cur1->val );\\n\\t\\t\\t\\t    st.max_value = cur1->val;\\n\\t\\t\\t    }\\n\\t\\t\\t    else{\\n\\t\\t\\t        st.idx2 = cur2->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t    max_value  = max(max_value, cur2->val );\\n\\t\\t\\t\\t    st.max_value = cur2->val;\\t\\n\\t\\t\\t    }\\n\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t    result.push_back(max_value);\\n\\t\\t\\t// We should remove all the states which are doing worse than the best one\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n            states.remove_if([&](const State & st){return st.max_value < max_value;});\\n\\t\\t\\t\\n\\t\\t\\t// Add newly create states\\n\\t\\t\\tfor(State st: states_to_add)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(st.max_value == max_value)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 states.push_front(st);\\n\\t\\t}\\n\\n    }\\n\\n};\\n```\n```\\nnamespace std{\\ntemplate<>\\nstruct hash<State> {\\n  std::size_t operator()(const State & state) const noexcept {\\n    std::hash<int> hasher;\\n    size_t seed = hasher(state.idx1);\\n\\t// from boost\\n    seed ^= hasher(state.idx2) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n    return seed;\\n  }\\n};\\n}\\n```\n```\\nunordered_set<State> unique_states(states.begin(), states.end());\\nif(unique_states.size()!= states.size()){\\n    states.clear();\\n    for(const State &st: unique_states)\\n        states.push_front(st);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454161,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nbool compare(vector<int>& nums1, vector<int>& nums2, int start_i, int start_j)\\n{\\n\\tint loop_size = min(nums1.size() - start_i, nums2.size() - start_j);\\n\\n\\tfor (int i = 0; i < loop_size; i++)\\n\\t{\\n\\t\\tif (nums1[i + start_i] < nums2[i + start_j])\\n\\t\\t\\treturn true;\\n\\t\\telse if (nums1[i + start_i] > nums2[i + start_j])\\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn nums1.size() - start_i < nums2.size() - start_j;\\n}\\n\\nvector<vector<int>> largetsNum(vector<int>& nums)\\n{\\n\\tvector<vector<int>> res;\\n\\tres.resize(nums.size() + 1);\\n\\tres.back() = nums;\\n\\n\\tfor (int i = res.size() - 2; i >= 0; i--)\\n\\t{\\t\\n\\t\\tint idx = 0;\\n\\t\\twhile (idx + 1 < res[i + 1].size())\\n\\t\\t{\\n\\t\\t\\tif (res[i + 1][idx] < res[i + 1][idx + 1])\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\n\\t\\tfor (int j = 0; j < res[i + 1].size(); j++)\\n\\t\\t{\\n\\t\\t\\tif (idx != j)\\n\\t\\t\\t\\tres[i].push_back(res[i + 1][j]);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\nvector<int> merge(vector<int>& nums1, vector<int>& nums2)\\n{\\n\\tvector<int> res;\\n\\tint i = 0, j = 0;\\n\\twhile (i < nums1.size() || j < nums2.size())\\n\\t{\\n\\t\\t\\tif (compare(nums1, nums2, i, j))\\n\\t\\t\\t\\tres.push_back(nums2[j++]);\\n\\t\\t\\telse\\n\\t\\t\\t\\tres.push_back(nums1[i++]);\\n\\t}\\n\\treturn res;\\n}\\n\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, size_t k) \\n{\\n\\tvector<vector<int>> largest_num1 = largetsNum(nums1);\\n\\tvector<vector<int>> largest_num2 = largetsNum(nums2);\\n\\n\\tvector<int> res;\\n\\n\\tint start = k > nums2.size() ? k - nums2.size() : 0;\\n\\n\\tfor (int i = start; i < largest_num1.size() && i <= k; i++)\\n\\t{\\n\\t\\tvector<int> tmp = merge(largest_num1[i], largest_num2[k - i]);\\n\\t\\tif (res.empty() || compare(res, tmp, 0, 0))\\n\\t\\t\\tres = tmp;\\n\\t}\\n\\n\\treturn res;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nbool compare(vector<int>& nums1, vector<int>& nums2, int start_i, int start_j)\\n{\\n\\tint loop_size = min(nums1.size() - start_i, nums2.size() - start_j);\\n\\n\\tfor (int i = 0; i < loop_size; i++)\\n\\t{\\n\\t\\tif (nums1[i + start_i] < nums2[i + start_j])\\n\\t\\t\\treturn true;\\n\\t\\telse if (nums1[i + start_i] > nums2[i + start_j])\\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn nums1.size() - start_i < nums2.size() - start_j;\\n}\\n\\nvector<vector<int>> largetsNum(vector<int>& nums)\\n{\\n\\tvector<vector<int>> res;\\n\\tres.resize(nums.size() + 1);\\n\\tres.back() = nums;\\n\\n\\tfor (int i = res.size() - 2; i >= 0; i--)\\n\\t{\\t\\n\\t\\tint idx = 0;\\n\\t\\twhile (idx + 1 < res[i + 1].size())\\n\\t\\t{\\n\\t\\t\\tif (res[i + 1][idx] < res[i + 1][idx + 1])\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\n\\t\\tfor (int j = 0; j < res[i + 1].size(); j++)\\n\\t\\t{\\n\\t\\t\\tif (idx != j)\\n\\t\\t\\t\\tres[i].push_back(res[i + 1][j]);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\nvector<int> merge(vector<int>& nums1, vector<int>& nums2)\\n{\\n\\tvector<int> res;\\n\\tint i = 0, j = 0;\\n\\twhile (i < nums1.size() || j < nums2.size())\\n\\t{\\n\\t\\t\\tif (compare(nums1, nums2, i, j))\\n\\t\\t\\t\\tres.push_back(nums2[j++]);\\n\\t\\t\\telse\\n\\t\\t\\t\\tres.push_back(nums1[i++]);\\n\\t}\\n\\treturn res;\\n}\\n\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, size_t k) \\n{\\n\\tvector<vector<int>> largest_num1 = largetsNum(nums1);\\n\\tvector<vector<int>> largest_num2 = largetsNum(nums2);\\n\\n\\tvector<int> res;\\n\\n\\tint start = k > nums2.size() ? k - nums2.size() : 0;\\n\\n\\tfor (int i = start; i < largest_num1.size() && i <= k; i++)\\n\\t{\\n\\t\\tvector<int> tmp = merge(largest_num1[i], largest_num2[k - i]);\\n\\t\\tif (res.empty() || compare(res, tmp, 0, 0))\\n\\t\\t\\tres = tmp;\\n\\t}\\n\\n\\treturn res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325763,
                "title": "python-simple-intuitive-3-dimention-solution",
                "content": "```\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, length):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(nums1) + len(nums2) < length:\\n            return []\\n    \\n        dp = [[[0 for _ in xrange(length + 1)] for _ in xrange(len(nums2) + 1)] for _ in xrange(len(nums1) + 1)]\\n        for k in xrange(1,length + 1):\\n            for j in xrange(k,len(nums2) + 1):\\n                dp[0][j][k] = max(dp[0][j - 1][k],10 * dp[0][j - 1][k - 1] + nums2[j - 1])\\n            for i in xrange(k,len(nums1) + 1):\\n                dp[i][0][k] = max(dp[i - 1][0][k],10 * dp[i - 1][0][k - 1] + nums1[i - 1])\\n                \\n            for i in xrange(1,len(nums1) + 1):\\n                for j in xrange(1,len(nums2) + 1):\\n                    if i + j < k:\\n                        continue\\n                    dp[i][j][k] = max(dp[i][j][k],dp[i - 1][j][k],dp[i][j - 1][k])\\n                    dp[i][j][k] = max(dp[i][j][k],dp[i - 1][j][k - 1] * 10 + nums1[i - 1])\\n                    dp[i][j][k] = max(dp[i][j][k],dp[i][j - 1][k - 1] * 10 + nums2[j - 1])\\n            \\n        return map(int,list(str(dp[-1][-1][-1])))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, length):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(nums1) + len(nums2) < length:\\n            return []\\n    \\n        dp = [[[0 for _ in xrange(length + 1)] for _ in xrange(len(nums2) + 1)] for _ in xrange(len(nums1) + 1)]\\n        for k in xrange(1,length + 1):\\n            for j in xrange(k,len(nums2) + 1):\\n                dp[0][j][k] = max(dp[0][j - 1][k],10 * dp[0][j - 1][k - 1] + nums2[j - 1])\\n            for i in xrange(k,len(nums1) + 1):\\n                dp[i][0][k] = max(dp[i - 1][0][k],10 * dp[i - 1][0][k - 1] + nums1[i - 1])\\n                \\n            for i in xrange(1,len(nums1) + 1):\\n                for j in xrange(1,len(nums2) + 1):\\n                    if i + j < k:\\n                        continue\\n                    dp[i][j][k] = max(dp[i][j][k],dp[i - 1][j][k],dp[i][j - 1][k])\\n                    dp[i][j][k] = max(dp[i][j][k],dp[i - 1][j][k - 1] * 10 + nums1[i - 1])\\n                    dp[i][j][k] = max(dp[i][j][k],dp[i][j - 1][k - 1] * 10 + nums2[j - 1])\\n            \\n        return map(int,list(str(dp[-1][-1][-1])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221188,
                "title": "python-greedy",
                "content": "```\\nclass Solution:\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n, m = len(nums1), len(nums2)\\n        ans = [0] * k\\n        for i in range(0, k+1):\\n            j = k - i\\n            if i > n or j > m: \\n                continue\\n                \\n            left = self.maxOneNumber(nums1, n, i)\\n            right = self.maxOneNumber(nums2, m, j)\\n            cur = self.merge(collections.deque(left), collections.deque(right))\\n            ans = max(ans, cur)\\n\\n        return ans\\n    \\n    def maxOneNumber(self, nums, n, k):\\n        ans = [-1] * k\\n        j = 0\\n        for i in range(n):\\n            while n - i > k - j and j > 0 and ans[j-1] < nums[i]:\\n                j -= 1\\n            if j < k:\\n                ans[j] = nums[i]\\n                j += 1\\n        return ans\\n    \\n    def merge(self, nums1, nums2):\\n        ans = []\\n        while nums1 or nums2:\\n            if nums1 > nums2:\\n                ans.append(nums1.popleft())\\n            else:\\n                ans.append(nums2.popleft())\\n        return ans\\n            \\n        \\n    \\n            \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n, m = len(nums1), len(nums2)\\n        ans = [0] * k\\n        for i in range(0, k+1):\\n            j = k - i\\n            if i > n or j > m: \\n                continue\\n                \\n            left = self.maxOneNumber(nums1, n, i)\\n            right = self.maxOneNumber(nums2, m, j)\\n            cur = self.merge(collections.deque(left), collections.deque(right))\\n            ans = max(ans, cur)\\n\\n        return ans\\n    \\n    def maxOneNumber(self, nums, n, k):\\n        ans = [-1] * k\\n        j = 0\\n        for i in range(n):\\n            while n - i > k - j and j > 0 and ans[j-1] < nums[i]:\\n                j -= 1\\n            if j < k:\\n                ans[j] = nums[i]\\n                j += 1\\n        return ans\\n    \\n    def merge(self, nums1, nums2):\\n        ans = []\\n        while nums1 or nums2:\\n            if nums1 > nums2:\\n                ans.append(nums1.popleft())\\n            else:\\n                ans.append(nums2.popleft())\\n        return ans\\n            \\n        \\n    \\n            \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 190916,
                "title": "the-basic-traditional-dp-solution",
                "content": "Tips: Also this is not the final solution, As you need change the int to string , to solve the integer overload issue.\nbut i think this is the basic DP. thanks\n\nDP[m][i][j] means the largest value when select m elements from A[0]-A[i] and B[0]- B[j] \n\nInit:\nDP[m][0][j] >> seleect 0-m  from  B[0]- B[j] \nDP[m][i][0] >>seleect 0-m  from  A[0]- A[i] \n\nDP:\nDP[m][i][j] = Max(\n\t                                   ++++ did not inlcude [i][j] in m elements+++++\n\t\t\t              res[m][i][j-1];                                              >> select m elements from [i][j-1]\n\t\t\t\t\t\t\t\t\t\tres[m][i-1][j];                                             >> select m elements from [i-1][j]\n\t\t\t\t\t\t\t\t\t\t                   ++++ inlcude [i][j] in m elements+++++                                            \n\t\t\t\t\t\t\t\t\t\tres[m-1][i-1][j]*10+nums1[i-1];                >> end with nums1[i-1]\n\t\t\t\t\t\t\t\t\t\tres[m-1][i][j-1]*10+nums2[j-1];\n\t\t\t\t\t\t\t\t\t\tnums1[i-1]*10^m-1+res[m-1][0][j];         >> start with nums1[i-1]\n\t\t\t\t\t\t\t\t\t\tnums2[j-1]*10^m-1+res[m-1][i][0];\n)\n'''\nclass Solution {\npublic:\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n        \n        int len1 = nums1.size();\n        int len2 = nums2.size();\n        \n        vector<vector<vector<int> > > res (k+1,vector<vector<int>>(len1+1,vector<int>(len2+1,0)));\n        \n        \n        for(int m=1;m<=k;m++)\n        {\n                for(int j =1;j<=len2;j++)\n                {\n                    if(j >=m)\n                    {\n                        res[m][0][j] = max(res[m][0][j-1],res[m-1][0][j-1]*10+nums2[j-1]);\n                    }\n                }\n        }\n        \n        for(int m=1;m<=k;m++)\n        {\n                for(int i =1;i<=len1;i++)\n                {\n                    if(i >=m)\n                    {\n                        res[m][i][0] = max(res[m][i-1][0],res[m-1][i-1][0]*10+nums1[i-1]);\n                    }\n                }\n        }\n        \n        for(int m=1;m<=k;m++)\n        {\n            for(int i=1; i<=len1;i++)\n            {\n                for(int j =1;j<=len2;j++)\n                {\n                    if(i+j >=m)\n                    {\n                        vector<int> tmp;\n                        tmp.push_back(res[m][i][j-1]);\n                        tmp.push_back(res[m][i-1][j]);\n                        \n                        tmp.push_back(res[m-1][i-1][j]*10+nums1[i-1]);\n                        tmp.push_back(res[m-1][i][j-1]*10+nums2[j-1]);\n                        \n                        int dl = 0;\n                        int dt = 0;\n                        for(int p=0;p<m-1;p++)\n                        {\n                           dl = nums1[i-1]*10;\n                           dt = nums2[j-1]*10;\n                        }\n                        tmp.push_back(dl+res[m-1][0][j]);\n                        tmp.push_back(dt+res[m-1][i][0]);\n                        \n                        sort(tmp.begin(),tmp.end());\n                        res[m][i][j] = tmp[tmp.size()-1];\n                    }\n                }\n                   \n            }\n        }\n        \n        int ans = res[k][len1][len2];\n        vector<int> data;\n        while(ans!=0)\n        {\n            data.push_back(ans%10);\n            ans =ans/10;\n        }\n        reverse(data.begin(),data.end());\n        return data;\n    }\n};\n'''",
                "solutionTags": [],
                "code": "class Solution {\npublic:\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n        \n        int len1 = nums1.size();\n        int len2 = nums2.size();\n        \n        vector<vector<vector<int> > > res (k+1,vector<vector<int>>(len1+1,vector<int>(len2+1,0)));\n        \n        \n        for(int m=1;m<=k;m++)\n        {\n                for(int j =1;j<=len2;j++)\n                {\n                    if(j >=m)\n                    {\n                        res[m][0][j] = max(res[m][0][j-1],res[m-1][0][j-1]*10+nums2[j-1]);\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 174212,
                "title": "my-readable-python-solution",
                "content": "* After struggling for awhile, i came with this solution and i think most of the solutions are similar.\\n* If we will make an array of length k, we can take some elements from nums1, and complete rest from nums2.\\n* Logic is simple. Get the max possible array from the targeted array in makeArr function.\\n* Merge two array one by one to get merged max array.\\n* Return max merged array from choices.\\n```\\nclass Solution:\\n    def maxNumber(self, nums1, nums2, k):\\n        def merge(arr1, arr2):\\n            res, i, j = [], 0, 0\\n            while i < len(arr1) and j < len(arr2):\\n                if arr1[i:] >= arr2[j:]:\\n                    res.append(arr1[i])\\n                    i += 1\\n                else: \\n                    res.append(arr2[j])\\n                    j += 1\\n            if i < len(arr1): res += arr1[i:]\\n            elif j < len(arr2): res += arr2[j:]\\n            return res     \\n        \\n        def makeArr(arr, l):\\n            i, res = 0, []\\n            for r in range(l - 1, -1, -1):\\n                num, i = max(arr[i:-r] or arr[i:])\\n                i = -i + 1\\n                res.append(num)\\n            return res\\n        \\n        nums1, nums2, choices = [(num, -i) for i, num in enumerate(nums1)], [(num, -i) for i, num in enumerate(nums2)], []\\n        for m in range(k + 1):\\n            if m > len(nums1) or k - m > len(nums2): continue\\n            arr1, arr2 = makeArr(nums1, m), makeArr(nums2, k - m)  \\n            choices.append(merge(arr1, arr2))\\n        return max(choices)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1, nums2, k):\\n        def merge(arr1, arr2):\\n            res, i, j = [], 0, 0\\n            while i < len(arr1) and j < len(arr2):\\n                if arr1[i:] >= arr2[j:]:\\n                    res.append(arr1[i])\\n                    i += 1\\n                else: \\n                    res.append(arr2[j])\\n                    j += 1\\n            if i < len(arr1): res += arr1[i:]\\n            elif j < len(arr2): res += arr2[j:]\\n            return res     \\n        \\n        def makeArr(arr, l):\\n            i, res = 0, []\\n            for r in range(l - 1, -1, -1):\\n                num, i = max(arr[i:-r] or arr[i:])\\n                i = -i + 1\\n                res.append(num)\\n            return res\\n        \\n        nums1, nums2, choices = [(num, -i) for i, num in enumerate(nums1)], [(num, -i) for i, num in enumerate(nums2)], []\\n        for m in range(k + 1):\\n            if m > len(nums1) or k - m > len(nums2): continue\\n            arr1, arr2 = makeArr(nums1, m), makeArr(nums2, k - m)  \\n            choices.append(merge(arr1, arr2))\\n        return max(choices)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169934,
                "title": "a-tip-for-c-programmer",
                "content": "The basic idea is sorts of like brute force, since we just pick 1 number from nums1, k-1 from nums2, \\nnext we pick 2 from nums1, k-2 from nums2 , and so on........\\nThanks to post \"share my greedy solution\"(ranking number 1 under this topic), I write a similiar one, but in C++.\\nThe only thing I\\'d like to share is, under such situation, it seems that we need to always copy a vector to another. And this will cost a lot. \\nBut actually it shouldn\\'t. Unlike Java, if you do something like`int a[] , int b[], a = b`, in java, the just a copy of **reference** , but in c++, it will automatically call the **copy** method, which indeed costs a lot.\\nHowever we can still use assignment in term of reference by calling std::move. And if you do not know the method or the difference between rvalue and lvalue, please look up on C++ reference......\\n```\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans(k,0);\\n        for (int i=std::max(0,k-m);i<=k && i<=n;i++){\\n            vector<int> candidate = std::move(merge(maxArray(nums1,i),maxArray(nums2,k-i)));\\n            if (greater(candidate,0,ans,0)) ans = std::move(candidate);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    bool greater(vector<int>& nums1, int i, vector<int>& nums2, int j){\\n        while (i<nums1.size() && j< nums2.size() && nums1[i] == nums2[j]){i++;j++;}\\n        return (j == nums2.size()) || (i<nums1.size() && nums1[i] > nums2[j]);\\n    }\\n    vector<int> merge(vector<int> && nums1, vector<int> && nums2){\\n        int k = nums1.size() + nums2.size();\\n        vector<int> ans(k);\\n        for (int r=0, i = 0 , j = 0; r < k ;r++)\\n             ans[r] = greater(nums1,i,nums2,j) ? nums1[i++] : nums2[j++];\\n        return ans;\\n    }\\n    vector<int> maxArray(vector<int> & nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans(k);\\n        for (int i=0,j=0;i<n;i++){\\n            while (n-i+j > k && j > 0 && ans[j-1] < nums[i]) j--;\\n            if (j<k) ans[j++] = nums[i];\\n        }\\n        return ans;\\n    }\\n```\\nHope it helps.",
                "solutionTags": [],
                "code": "```\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans(k,0);\\n        for (int i=std::max(0,k-m);i<=k && i<=n;i++){\\n            vector<int> candidate = std::move(merge(maxArray(nums1,i),maxArray(nums2,k-i)));\\n            if (greater(candidate,0,ans,0)) ans = std::move(candidate);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    bool greater(vector<int>& nums1, int i, vector<int>& nums2, int j){\\n        while (i<nums1.size() && j< nums2.size() && nums1[i] == nums2[j]){i++;j++;}\\n        return (j == nums2.size()) || (i<nums1.size() && nums1[i] > nums2[j]);\\n    }\\n    vector<int> merge(vector<int> && nums1, vector<int> && nums2){\\n        int k = nums1.size() + nums2.size();\\n        vector<int> ans(k);\\n        for (int r=0, i = 0 , j = 0; r < k ;r++)\\n             ans[r] = greater(nums1,i,nums2,j) ? nums1[i++] : nums2[j++];\\n        return ans;\\n    }\\n    vector<int> maxArray(vector<int> & nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans(k);\\n        for (int i=0,j=0;i<n;i++){\\n            while (n-i+j > k && j > 0 && ans[j-1] < nums[i]) j--;\\n            if (j<k) ans[j++] = nums[i];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 111742,
                "title": "share-my-java-solution",
                "content": "find(): for every possible combination of digit counts from the two arrays, find the digits from each array that is the largest.\\nmerge(): merge two arrays of digits found from the two arrays.\\ncompare(): compare the current merged number with existing one.\\n\\n```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] res = new int[k];\\n        for(int i = 0; i <= k; i ++) {\\n            int j = k - i;\\n            if(i > nums1.length || j > nums2.length) continue;\\n            int[] digits1 = find(nums1, i);\\n            int[] digits2 = find(nums2, j);\\n            int[] digits = merge(digits1, digits2);\\n            res = compare(digits, res) > 0? digits: res;\\n        }\\n        return res;\\n    }\\n    \\n    public int[] find(int[] nums, int count) {\\n        int n = nums.length, remain = count;\\n        Stack<Integer> stack = new Stack<Integer>();\\n        for(int i = 0; i < n; i ++) {\\n            while(!stack.isEmpty() && nums[i] > stack.peek() && n - i - 1 >= remain) {\\n                stack.pop();\\n                remain ++;\\n            }\\n            if(remain > 0) {\\n                stack.push(nums[i]);\\n                remain --;\\n            }\\n        }\\n        int[] num = new int[count];\\n        int i = 0;\\n        for(Integer s: stack) {\\n            num[i ++] = s.intValue();\\n        }\\n        return num;\\n    }\\n    \\n    public int[] merge(int[] digits1, int[] digits2) {\\n        int i = 0, j = 0, p = 0, len1 = digits1.length, len2 = digits2.length;\\n        int[] res = new int[len1 + len2];\\n        while(i < len1 && j < len2) {\\n            if(digits1[i] > digits2[j]) {\\n                res[p ++] = digits1[i ++];\\n            } else if(digits1[i] < digits2[j]) {\\n                res[p ++] = digits2[j ++];\\n            } else {\\n                int istart = i, jstart = j;\\n                while(i < len1 && j < len2 && digits1[i] == digits2[j]) {\\n                    i ++;\\n                    j ++;\\n                }\\n                if(( i < len1 & j < len2 && digits1[i] > digits2[j]) \\n                  || (j == len2)) {\\n                    res[p ++] = digits1[istart ++];\\n                } else {\\n                    res[p ++] = digits2[jstart ++];\\n                }\\n                i = istart;\\n                j = jstart;\\n            }\\n        }\\n        while(i < len1) {\\n            res[p ++] = digits1[i ++];\\n        }\\n        while(j < len2) {\\n            res[p ++] = digits2[j ++];\\n        }\\n        return res;\\n    }\\n    \\n    public int compare(int[] n1, int[] n2) {\\n        for(int i = 0; i < n1.length; i ++) {\\n            if(n1[i] < n2[i]) return -1;\\n            else if(n1[i] > n2[i]) return 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] res = new int[k];\\n        for(int i = 0; i <= k; i ++) {\\n            int j = k - i;\\n            if(i > nums1.length || j > nums2.length) continue;\\n            int[] digits1 = find(nums1, i);\\n            int[] digits2 = find(nums2, j);\\n            int[] digits = merge(digits1, digits2);\\n            res = compare(digits, res) > 0? digits: res;\\n        }\\n        return res;\\n    }\\n    \\n    public int[] find(int[] nums, int count) {\\n        int n = nums.length, remain = count;\\n        Stack<Integer> stack = new Stack<Integer>();\\n        for(int i = 0; i < n; i ++) {\\n            while(!stack.isEmpty() && nums[i] > stack.peek() && n - i - 1 >= remain) {\\n                stack.pop();\\n                remain ++;\\n            }\\n            if(remain > 0) {\\n                stack.push(nums[i]);\\n                remain --;\\n            }\\n        }\\n        int[] num = new int[count];\\n        int i = 0;\\n        for(Integer s: stack) {\\n            num[i ++] = s.intValue();\\n        }\\n        return num;\\n    }\\n    \\n    public int[] merge(int[] digits1, int[] digits2) {\\n        int i = 0, j = 0, p = 0, len1 = digits1.length, len2 = digits2.length;\\n        int[] res = new int[len1 + len2];\\n        while(i < len1 && j < len2) {\\n            if(digits1[i] > digits2[j]) {\\n                res[p ++] = digits1[i ++];\\n            } else if(digits1[i] < digits2[j]) {\\n                res[p ++] = digits2[j ++];\\n            } else {\\n                int istart = i, jstart = j;\\n                while(i < len1 && j < len2 && digits1[i] == digits2[j]) {\\n                    i ++;\\n                    j ++;\\n                }\\n                if(( i < len1 & j < len2 && digits1[i] > digits2[j]) \\n                  || (j == len2)) {\\n                    res[p ++] = digits1[istart ++];\\n                } else {\\n                    res[p ++] = digits2[jstart ++];\\n                }\\n                i = istart;\\n                j = jstart;\\n            }\\n        }\\n        while(i < len1) {\\n            res[p ++] = digits1[i ++];\\n        }\\n        while(j < len2) {\\n            res[p ++] = digits2[j ++];\\n        }\\n        return res;\\n    }\\n    \\n    public int compare(int[] n1, int[] n2) {\\n        for(int i = 0; i < n1.length; i ++) {\\n            if(n1[i] < n2[i]) return -1;\\n            else if(n1[i] > n2[i]) return 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77292,
                "title": "fastest-c-solution-13ms-beasts-100",
                "content": "The basic idea:\\n    First, find i max numbers (arr1[]) from nums1, and j max numbers (arr2[]) from nums2. (i + j = k)\\n    Then, merge arr1[] and arr2[] to get a max number.\\n```\\nvoid getMaxNumber(int *nums, int size, int outsize, int *out) {\\n    int len = 0, i, k = size - outsize;\\n    out[0] = nums[0];\\n    for (i = 1; i < size; i++) {\\n        while (len >= 0 && k > 0 && nums[i] > out[len]) k--, len--;\\n        out[++len] = nums[i];\\n    }\\n}\\n\\nint compareArr(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int i;\\n    for (i = 0; i < nums1Size && i < nums2Size && nums1[i] == nums2[i]; i++);\\n    //if (i == nums1Size && i == nums2Size) return 0;\\n    if (i == nums1Size) return -1;\\n    if (i == nums2Size) return 1;\\n    return (nums1[i] - nums2[i]);\\n}\\n\\nvoid merge(int* nums1, int nums1Size, int* nums2, int nums2Size, int *out) {\\n    int len = 0, i = 0, j = 0;\\n    while (i < nums1Size && j < nums2Size) {\\n        if (nums1[i] > nums2[j]) out[len++] = nums1[i++];\\n        else if (nums1[i] < nums2[j]) out[len++] = nums2[j++];\\n        else if (compareArr(nums1 + i, nums1Size - i, nums2 + j, nums2Size - j) >= 0) out[len++] = nums1[i++];\\n        else out[len++] = nums2[j++];\\n    }\\n    while (i < nums1Size) out[len++] = nums1[i++];\\n    while (j < nums2Size) out[len++] = nums2[j++];\\n}\\n\\nint compare(int *arr1, int *arr2, int len) {\\n    int i = 0;\\n    for (; i < len && arr1[i] == arr2[i]; i++);\\n    if (i < len) return arr1[i] - arr2[i];\\n    return 0;\\n}\\n\\nint min(int x, int y) {return x <= y ? x: y;}\\n\\n/**\\n * Return an array of size *returnSize.\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* maxNumber(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize) {\\n    int i = 0, j = 0;\\n    int *arr1, *arr2, *ans, *tmp;\\n    if (k <= 0) {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    arr1 = malloc(sizeof(int) * (nums1Size + nums2Size));\\n    arr2 = arr1 + nums1Size;\\n    ans = malloc(sizeof(int) * k);\\n    tmp = malloc(sizeof(int) * k);\\n    for (j = 0; j < k; j++) ans[j] = 0;\\n    for (i = min(k, nums1Size); i >= 0; i--) {\\n        j = k - i;\\n        if (j > nums2Size) break;\\n        if (i > 0) getMaxNumber(nums1, nums1Size, i, arr1);\\n        if (j > 0) getMaxNumber(nums2, nums2Size, j, arr2);\\n        merge(arr1, i, arr2, j, tmp);\\n        if (compare(tmp, ans, k) > 0) {\\n            for (j = 0; j < k; j++) ans[j] = tmp[j];\\n        }\\n    }\\n    free(tmp);\\n    free(arr1);\\n    *returnSize = k; \\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid getMaxNumber(int *nums, int size, int outsize, int *out) {\\n    int len = 0, i, k = size - outsize;\\n    out[0] = nums[0];\\n    for (i = 1; i < size; i++) {\\n        while (len >= 0 && k > 0 && nums[i] > out[len]) k--, len--;\\n        out[++len] = nums[i];\\n    }\\n}\\n\\nint compareArr(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int i;\\n    for (i = 0; i < nums1Size && i < nums2Size && nums1[i] == nums2[i]; i++);\\n    //if (i == nums1Size && i == nums2Size) return 0;\\n    if (i == nums1Size) return -1;\\n    if (i == nums2Size) return 1;\\n    return (nums1[i] - nums2[i]);\\n}\\n\\nvoid merge(int* nums1, int nums1Size, int* nums2, int nums2Size, int *out) {\\n    int len = 0, i = 0, j = 0;\\n    while (i < nums1Size && j < nums2Size) {\\n        if (nums1[i] > nums2[j]) out[len++] = nums1[i++];\\n        else if (nums1[i] < nums2[j]) out[len++] = nums2[j++];\\n        else if (compareArr(nums1 + i, nums1Size - i, nums2 + j, nums2Size - j) >= 0) out[len++] = nums1[i++];\\n        else out[len++] = nums2[j++];\\n    }\\n    while (i < nums1Size) out[len++] = nums1[i++];\\n    while (j < nums2Size) out[len++] = nums2[j++];\\n}\\n\\nint compare(int *arr1, int *arr2, int len) {\\n    int i = 0;\\n    for (; i < len && arr1[i] == arr2[i]; i++);\\n    if (i < len) return arr1[i] - arr2[i];\\n    return 0;\\n}\\n\\nint min(int x, int y) {return x <= y ? x: y;}\\n\\n/**\\n * Return an array of size *returnSize.\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* maxNumber(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize) {\\n    int i = 0, j = 0;\\n    int *arr1, *arr2, *ans, *tmp;\\n    if (k <= 0) {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    arr1 = malloc(sizeof(int) * (nums1Size + nums2Size));\\n    arr2 = arr1 + nums1Size;\\n    ans = malloc(sizeof(int) * k);\\n    tmp = malloc(sizeof(int) * k);\\n    for (j = 0; j < k; j++) ans[j] = 0;\\n    for (i = min(k, nums1Size); i >= 0; i--) {\\n        j = k - i;\\n        if (j > nums2Size) break;\\n        if (i > 0) getMaxNumber(nums1, nums1Size, i, arr1);\\n        if (j > 0) getMaxNumber(nums2, nums2Size, j, arr2);\\n        merge(arr1, i, arr2, j, tmp);\\n        if (compare(tmp, ans, k) > 0) {\\n            for (j = 0; j < k; j++) ans[j] = tmp[j];\\n        }\\n    }\\n    free(tmp);\\n    free(arr1);\\n    *returnSize = k; \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 77296,
                "title": "python-solution-172ms-beats-100",
                "content": "```python\\nimport math\\n\\nclass RMQ(object):\\n    def __init__(self, nums):\\n        self.nums = nums\\n        n = len(nums)\\n        if n:\\n            d = int(math.log(n, 2)) + 1;\\n            self.table = [[-1 for _ in range(n)] for _ in range(d)]\\n            for j in range(n):\\n                self.table[0][j] = j;\\n            for i in range(1, d):\\n                for j in range(n - (1 << i) + 1):\\n                    i1 = self.table[i-1][j]\\n                    i2 = self.table[i-1][j+(1<<(i-1))]\\n                    if nums[i1] >= nums[i2]:\\n                        self.table[i][j] = i1\\n                    else:\\n                        self.table[i][j] = i2\\n\\n    def get(self, left, right):\\n        if right < left:\\n            return -1\\n        l = right - left + 1\\n        d = int(math.log(l, 2))\\n        i1 = self.table[d][left]\\n        i2 = self.table[d][right+1-(1<<d)]\\n        if self.nums[i1] >= self.nums[i2]:\\n            return i1\\n        return i2\\n\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        n, m = len(nums1), len(nums2)\\n        rmq1, rmq2 = RMQ(nums1), RMQ(nums2)\\n        \\n        start_positions = {0: 0}\\n        \\n        res = []\\n        while k:\\n            max_digit = 0\\n            new_start_positions = {}\\n            for s1, s2 in start_positions.items():\\n                e1 = n - max(1, k - (m - s2))\\n                e2 = m - max(1, k - (n - s1))\\n    \\n                if s1 < n and s2 < m:\\n                    i1 = rmq1.get(s1, e1)\\n                    i2 = rmq2.get(s2, e2)\\n                    if nums1[i1] > nums2[i2]:\\n                        if nums1[i1] >= max_digit:\\n                            if nums1[i1] > max_digit:\\n                                max_digit = nums1[i1]\\n                                new_start_positions = {}\\n                            new_start_positions[i1 + 1] = s2\\n                    elif nums1[i1] < nums2[i2]:\\n                        if nums2[i2] >= max_digit:\\n                            if nums2[i2] > max_digit:\\n                                max_digit = nums2[i2]\\n                                new_start_positions = {}\\n                            new_start_positions[s1] = i2 + 1\\n                    else:\\n                        if nums1[i1] >= max_digit:\\n                            if nums1[i1] > max_digit:\\n                                max_digit = nums1[i1]\\n                                new_start_positions = {}\\n                            new_start_positions[i1 + 1] = s2\\n                            new_start_positions[s1] = i2 + 1\\n                elif s1 < n:\\n                    i = rmq1.get(s1, e1)\\n                    if nums1[i] >= max_digit:\\n                        if nums1[i] > max_digit:\\n                            max_digit = nums1[i]\\n                            new_start_positions = {}\\n                        new_start_positions[i + 1] = s2\\n                else:\\n                    i = rmq2.get(s2, e2)\\n                    if nums2[i] >= max_digit:\\n                        if nums2[i] > max_digit:\\n                            max_digit = nums2[i]\\n                            new_start_positions = {}\\n                        new_start_positions[s1] = i + 1\\n            res.append(max_digit)\\n            start_positions = new_start_positions\\n            k -= 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nimport math\\n\\nclass RMQ(object):\\n    def __init__(self, nums):\\n        self.nums = nums\\n        n = len(nums)\\n        if n:\\n            d = int(math.log(n, 2)) + 1;\\n            self.table = [[-1 for _ in range(n)] for _ in range(d)]\\n            for j in range(n):\\n                self.table[0][j] = j;\\n            for i in range(1, d):\\n                for j in range(n - (1 << i) + 1):\\n                    i1 = self.table[i-1][j]\\n                    i2 = self.table[i-1][j+(1<<(i-1))]\\n                    if nums[i1] >= nums[i2]:\\n                        self.table[i][j] = i1\\n                    else:\\n                        self.table[i][j] = i2\\n\\n    def get(self, left, right):\\n        if right < left:\\n            return -1\\n        l = right - left + 1\\n        d = int(math.log(l, 2))\\n        i1 = self.table[d][left]\\n        i2 = self.table[d][right+1-(1<<d)]\\n        if self.nums[i1] >= self.nums[i2]:\\n            return i1\\n        return i2\\n\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        n, m = len(nums1), len(nums2)\\n        rmq1, rmq2 = RMQ(nums1), RMQ(nums2)\\n        \\n        start_positions = {0: 0}\\n        \\n        res = []\\n        while k:\\n            max_digit = 0\\n            new_start_positions = {}\\n            for s1, s2 in start_positions.items():\\n                e1 = n - max(1, k - (m - s2))\\n                e2 = m - max(1, k - (n - s1))\\n    \\n                if s1 < n and s2 < m:\\n                    i1 = rmq1.get(s1, e1)\\n                    i2 = rmq2.get(s2, e2)\\n                    if nums1[i1] > nums2[i2]:\\n                        if nums1[i1] >= max_digit:\\n                            if nums1[i1] > max_digit:\\n                                max_digit = nums1[i1]\\n                                new_start_positions = {}\\n                            new_start_positions[i1 + 1] = s2\\n                    elif nums1[i1] < nums2[i2]:\\n                        if nums2[i2] >= max_digit:\\n                            if nums2[i2] > max_digit:\\n                                max_digit = nums2[i2]\\n                                new_start_positions = {}\\n                            new_start_positions[s1] = i2 + 1\\n                    else:\\n                        if nums1[i1] >= max_digit:\\n                            if nums1[i1] > max_digit:\\n                                max_digit = nums1[i1]\\n                                new_start_positions = {}\\n                            new_start_positions[i1 + 1] = s2\\n                            new_start_positions[s1] = i2 + 1\\n                elif s1 < n:\\n                    i = rmq1.get(s1, e1)\\n                    if nums1[i] >= max_digit:\\n                        if nums1[i] > max_digit:\\n                            max_digit = nums1[i]\\n                            new_start_positions = {}\\n                        new_start_positions[i + 1] = s2\\n                else:\\n                    i = rmq2.get(s2, e2)\\n                    if nums2[i] >= max_digit:\\n                        if nums2[i] > max_digit:\\n                            max_digit = nums2[i]\\n                            new_start_positions = {}\\n                        new_start_positions[s1] = i + 1\\n            res.append(max_digit)\\n            start_positions = new_start_positions\\n            k -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77313,
                "title": "questions-about-the-merge-function",
                "content": "Here I am talking about the most common merge() function appearing in the posted solutions. Actually, I am not quite convinced about the way to handle the cases where we have two equal elements. I know, intuitively, we should move forward the pointer of the array that has a larger element after passing through the equal part, as this makes the larger element more likely to be encountered sooner, thus appear in a more significant digit. But can anyone post a rigorous mathematical proof of this?\\n```\\nprivate int[] merge(int[] nums1, int[] nums2) {\\n            int[] merged = new int[ nums1.length+nums2.length ];\\n            int cnt, cnt1, cnt2;\\n\\n            for(cnt = cnt1 = cnt2 = 0; cnt1<nums1.length && cnt2<nums2.length; ) {\\n                merged[ cnt++ ] = greater(nums1, nums2, cnt1, cnt2)?nums1[ cnt1++ ]:nums2[ cnt2++ ];\\n            }\\n\\n            for(; cnt1 < nums1.length; merged[ cnt++ ] = nums1[ cnt1++ ]);\\n            for(; cnt2 < nums2.length; merged[ cnt++ ] = nums2[ cnt2++ ]);\\n\\n            return merged;\\n        }\\n\\n        private boolean greater(int[] nums1, int[] nums2, int start1, int start2) {\\n            for (; start1 < nums1.length && start2 < nums2.length; start1++, start2++) {\\n                if (nums1[start1] > nums2[start2]) return true;\\n                if (nums1[start1] < nums2[start2]) return false;\\n            }\\n            return start1 != nums1.length;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate int[] merge(int[] nums1, int[] nums2) {\\n            int[] merged = new int[ nums1.length+nums2.length ];\\n            int cnt, cnt1, cnt2;\\n\\n            for(cnt = cnt1 = cnt2 = 0; cnt1<nums1.length && cnt2<nums2.length; ) {\\n                merged[ cnt++ ] = greater(nums1, nums2, cnt1, cnt2)?nums1[ cnt1++ ]:nums2[ cnt2++ ];\\n            }\\n\\n            for(; cnt1 < nums1.length; merged[ cnt++ ] = nums1[ cnt1++ ]);\\n            for(; cnt2 < nums2.length; merged[ cnt++ ] = nums2[ cnt2++ ]);\\n\\n            return merged;\\n        }\\n\\n        private boolean greater(int[] nums1, int[] nums2, int start1, int start2) {\\n            for (; start1 < nums1.length && start2 < nums2.length; start1++, start2++) {\\n                if (nums1[start1] > nums2[start2]) return true;\\n                if (nums1[start1] < nums2[start2]) return false;\\n            }\\n            return start1 != nums1.length;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 77318,
                "title": "c-greedy-method",
                "content": "    class Solution {\\n    public:\\n        vector<int> getMaxArray(vector<int>& nums, int k){\\n            vector<int> ans;\\n            int len = nums.size();\\n            for(int i = 0, j = 0; i < len; ++i){\\n                while(j > 0 && len - i + j > k && ans[j - 1] < nums[i]){\\n                    ans.pop_back();\\n                    --j;\\n                }\\n                if(j < k){\\n                    ans.push_back(nums[i]);\\n                    ++j;\\n                }\\n            }\\n            return ans;\\n        }\\n        bool greater(vector<int>& nums1, int i, vector<int>& nums2, int j){\\n            int len1 = nums1.size();\\n            int len2 = nums2.size();\\n            while(i < len1 && j < len2 && nums1[i] == nums2[j]){\\n                ++i;\\n                ++j;\\n            }\\n            if(j == len2 || (i < len1 && nums1[i] > nums2[j])){\\n                return true;\\n            }\\n            return false;\\n        }\\n        vector<int> merge(vector<int>& nums1, vector<int>& nums2){\\n            int len1 = nums1.size();\\n            int len2 = nums2.size();\\n            vector<int> ans;\\n            //for_each(nums1.begin(), nums1.end(), [](int x){cout<<x<<\" \";}), cout<<endl;\\n            //for_each(nums2.begin(), nums2.end(), [](int x){cout<<x<<\" \";}), cout<<endl;\\n            for(int i = 0, j = 0, m = 0;i < len1 || j < len2;){\\n                ans.push_back((greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++]));\\n            }\\n            //for_each(ans.begin(), ans.end(), [](int x){cout<<x<<\" \";}), cout<<endl;\\n            return ans;\\n        }\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            int len1 = nums1.size();\\n            int len2 = nums2.size();\\n            if(len1 < len2){\\n                return maxNumber(nums2, nums1, k);\\n            }\\n            vector<int> ans;\\n            for(int i = max(0, k - len1); i <= min(k, len2); ++i){\\n                vector<int> c2 = getMaxArray(nums2, i);\\n                vector<int> c1 = getMaxArray(nums1, k - i);\\n                vector<int> c = merge(c1, c2);\\n                if(ans.empty() || greater(c, 0, ans, 0)){\\n                    ans = c;\\n                }\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> getMaxArray(vector<int>& nums, int k){\\n            vector<int> ans;\\n            int len = nums.size();\\n            for(int i = 0, j = 0; i < len; ++i){\\n                while(j > 0 && len - i + j > k && ans[j - 1] < nums[i]){\\n                    ans.pop_back();\\n                    --j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 77322,
                "title": "intuitive-solution-yet-efficient-enough-in-c-well-commented",
                "content": "    class Solution \\n    {\\n    public:\\n        //select the maximal number in certain length within one vector;\\n        vector<int> maxVector(vector<int> nums, int k) \\n        {\\n            while (nums.size() > k) \\n            {\\n                int i = 0, n = nums.size();\\n                for (; i < n - 1; ++i)  //at least erase one element each time;\\n                {\\n                    if (nums[i] < nums[i + 1]) \\n                    {\\n                        nums.erase(nums.begin() + i);\\n                        break;\\n                    }\\n                }\\n                if (i == n - 1) nums.erase(nums.begin() + i);\\n            }\\n            return nums;\\n        }\\n    \\n        //compare two vectors from certain index adopting lexical order;\\n        //if the first vector is bigger return true otherwise return false;\\n        bool compare(vector<int> &nums1, int i, vector<int> &nums2, int j) \\n        {\\n            while (i<nums1.size() && j<nums2.size() && nums1[i]==nums2[j]) ++i, ++j;\\n            if (j == nums2.size()) return true;\\n            if (i<nums1.size() && nums1[i]>nums2[j]) return true;\\n            return false;\\n        }\\n    \\n        vector<int> merge(vector<int> &nums1, vector<int> &nums2, int k) \\n        {\\n            vector<int> res(k, 0);\\n            for (int i=0, j=0, r=0; r < k; ++r) \\n                res[r] = compare(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n            return res;\\n        }\\n    \\n        //AC - 386ms - the most intuitive solution;\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) \\n        {\\n            int len1=nums1.size(), len2=nums2.size();\\n            vector<int> res(k, 0);\\n            for (int i = max(0, k-len2); i <= min(k, len1); ++i) \\n            {\\n                auto v1 = maxVector(nums1, i);\\n                auto v2 = maxVector(nums2, k - i);\\n                auto tmp = merge(v1, v2, k);\\n                if (compare(tmp, 0, res, 0)) res = tmp;\\n            }\\n            return res;\\n        }\\n    };\\n\\n\\n----------",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution \\n    {\\n    public:\\n        //select the maximal number in certain length within one vector;\\n        vector<int> maxVector(vector<int> nums, int k) \\n        {\\n            while (nums.size() > k) \\n            {\\n                int i = 0, n = nums.size();\\n                for (; i < n - 1; ++i)  //at least erase one element each time;\\n                {\\n                    if (nums[i] < nums[i + 1]) \\n                    {\\n                        nums.erase(nums.begin() + i);\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 77332,
                "title": "c-136ms-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            \\n            vector<int> res;\\n            bool first = true;\\n            for (int i=0; i<=k; i++) {\\n                \\n                if (i > nums1.size() || k-i > nums2.size())\\n                    continue;\\n                \\n                // Find max number from nums1 of length i\\n                vector<int> maxNum1 = findMax(nums1, i);\\n    \\n                // Find max number from nums2 of length k-i\\n                vector<int> maxNum2 = findMax(nums2, k-i);\\n    \\n                // Interleave to find the global max number\\n                vector<int> candidate = interleave(maxNum1, maxNum2);\\n                \\n                if (first) {\\n                    res = candidate;\\n                    first = false;\\n                }\\n                else if (compare(res, 0, candidate, 0))\\n                    res = candidate;\\n            }\\n            return res;\\n        }\\n        vector<int> findMax(vector<int>& nums, int len) {\\n            vector<int> maxNum;\\n            int prev_pos = -1;\\n            int maxi;\\n            for (int i=0; i<len; i++) {\\n                maxi = -1;\\n                int limit = nums.size()-len+i;\\n                for (int j=prev_pos+1; j<=limit; j++) {\\n                    if (nums[j] > maxi) {\\n                        maxi = nums[j];\\n                        prev_pos = j;\\n                    }\\n                }\\n                maxNum.push_back(maxi);\\n            }\\n            return maxNum;\\n        }\\n        vector<int> interleave(vector<int>& maxNum1, vector<int>& maxNum2) {\\n            vector<int> res;\\n            int i1=0, i2=0;\\n            while (i1<maxNum1.size() || i2<maxNum2.size()) {\\n                if (compare(maxNum1, i1, maxNum2, i2)) {\\n                    res.push_back(maxNum2[i2++]);\\n                }\\n                else {\\n                    res.push_back(maxNum1[i1++]);\\n                }\\n            }\\n            return res;\\n        }\\n        // Returns true if the new vec (starting at position j) is better than the old vec (starting at position i)\\n        bool compare(vector<int>& old_vec, int i, vector<int>& new_vec, int j) {\\n            \\n            while (i < old_vec.size() && j < new_vec.size() && old_vec[i]==new_vec[j]) {\\n                i++;\\n                j++;\\n            }\\n            return i==old_vec.size() || (j!=new_vec.size() && old_vec[i] < new_vec[j]);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            \\n            vector<int> res;\\n            bool first = true;\\n            for (int i=0; i<=k; i++) {\\n                \\n                if (i > nums1.size() || k-i > nums2.size())\\n                    continue;\\n                \\n                // Find max number from nums1 of length i\\n                vector<int> maxNum1 = findMax(nums1, i);\\n    \\n                // Find max number from nums2 of length k-i\\n                vector<int> maxNum2 = findMax(nums2, k-i);\\n    \\n                // Interleave to find the global max number\\n                vector<int> candidate = interleave(maxNum1, maxNum2);\\n                \\n                if (first) {\\n                    res = candidate;\\n                    first = false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 77334,
                "title": "easy-to-understand-dp-c-implementation-but-with-tle",
                "content": "As we can see, this problem is really fuck!!!\\n\\nUsing directly with THE DP idea will cause TLE problem !!\\n\\nBut it is also good for us to use the traditional DP ideas to solve this kind of problem.\\n\\nYou can get the recursion equation from my code implementation.\\n\\nHere is the DP code implemented by myself without referring any others' post.\\n\\nWelcome your advice !\\n\\nCode : \\n\\n\\n     class Solution {\\n    public:\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            /**\\n             * dp[k][i][j] = max(nums1[i-1]+10*dp[k-1][i-1][j], nums2[j-1]+10*dp[k-1][i][j-1], \\n             *                    dp[k][i-1][j-1])\\n             * \\n             **/\\n            vector<int> result;\\n            int len1=nums1.size(), len2=nums2.size();\\n            if(len1+len2<k)  return result;\\n            vector<vector<vector<int>>> dp(2, vector<vector<int>>(len1+1, vector<int>(len2+1, 0)));\\n            for(int kk=0; kk<=k; kk++){\\n                for(int i=0; i<=len1; i++){\\n                    for(int j=0; j<=len2; j++){\\n                        if(kk==0)    \\n                            dp[0][i][j]=0;\\n                        else if(i==0 && j==0)   \\n                            dp[kk&1][0][0]=0;\\n                        else if(i==0){\\n                            if(kk>j)  \\n                                dp[kk&1][0][j]=0;\\n                            else \\n                                dp[kk&1][0][j]=max(dp[kk&1][0][j-1], 10*dp[(kk-1)&1][0][j-1]+nums2[j-1]);\\n                        }\\n                        else if(j==0){\\n                            if(kk>i)  \\n                                dp[kk&1][i][0]=0;\\n                            else \\n                                dp[kk&1][i][0]=max(dp[kk&1][i-1][0], 10*dp[(kk-1)&1][i-1][0]+nums1[i-1]);\\n                        }\\n                        else{\\n                             dp[kk&1][i][j] = max(max(nums1[i-1]+10*dp[(kk-1)&1][i-1][j], \\n                                nums2[j-1]+10*dp[(kk-1)&1][i][j-1]), dp[kk&1][i-1][j-1]);\\n                        }   \\n                    }\\n                }\\n            }\\n            int value=dp[k&1][len1][len2];\\n            while(value>0){\\n                result.push_back(value%10);\\n                value=value/10;\\n            }\\n            reverse(result.begin(), result.end());\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            /**\\n             * dp[k][i][j] = max(nums1[i-1]+10*dp[k-1][i-1][j], nums2[j-1]+10*dp[k-1][i][j-1], \\n             *                    dp[k][i-1][j-1])\\n             * \\n             **/\\n            vector<int> result;\\n            int len1=nums1.size(), len2=nums2.size();\\n            if(len1+len2<k)  return result;\\n            vector<vector<vector<int>>> dp(2, vector<vector<int>>(len1+1, vector<int>(len2+1, 0)));\\n            for(int kk=0; kk<=k; kk++){\\n                for(int i=0; i<=len1; i++){\\n                    for(int j=0; j<=len2; j++){\\n                        if(kk==0)    \\n                            dp[0][i][j]=0;\\n                        else if(i==0 && j==0)   \\n                            dp[kk&1][0][0]=0;\\n                        else if(i==0){\\n                            if(kk>j)  \\n                                dp[kk&1][0][j]=0;\\n                            else \\n                                dp[kk&1][0][j]=max(dp[kk&1][0][j-1], 10*dp[(kk-1)&1][0][j-1]+nums2[j-1]);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 77340,
                "title": "my-c-solution-just-want-to-give-a-c-solution-because-it-seem-there-are-no-c-submission",
                "content": "###Here is my code, used 58ms, if someone has a better solution in c, please contact me.\\n\\n    void Findmax(int *nums, int size, int *cache, int length);\\n    void Merge(int *nums1, int left, int* nums2, int right, int* cache);\\n    int compare(int* nums1, int *nums2, int size);\\n    \\n    int* maxNumber(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize){\\n    \\tint* cache = (int*)malloc(sizeof(int) * k);\\n    \\tmemset(cache, 0, k * sizeof(int));\\n    \\tint* cache3 = (int*)malloc(sizeof(int) * k);\\n    \\tint i, j, t;\\n    \\t*returnSize = k;\\n    \\tfor(i = 0; i <= k; ++i){\\n    \\t\\tint left = i;\\n    \\t\\tint cache1[left];\\n    \\t\\tint right = k - i;\\n    \\t\\tint cache2[right];\\n    \\n    \\t\\tif(left > nums1Size || right > nums2Size){\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tFindmax(nums1, nums1Size, cache1, left);\\n    \\t\\tFindmax(nums2, nums2Size, cache2, right);\\n    \\n    \\t\\tMerge(cache1, left, cache2, right, cache3);\\n    \\t\\tt = compare(cache, cache3, k);\\n    \\t\\tif(t < 0){\\n    \\t\\t\\tfor(j = 0; j < k; ++j){\\n    \\t\\t\\t\\tcache[j] = cache3[j];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\n    \\treturn cache;\\n    }\\n    \\n    void Findmax(int *nums, int size, int *cache, int length){\\n    \\tint start = 0;\\n    \\tint end = size - length;\\n    \\tint i, j, sum;\\n    \\tfor(i = 0; i < length; ++i){\\n    \\t\\tsum = -1;\\n    \\t\\tfor(j = start; j <= end; ++j)\\n    \\t\\t{\\n    \\t\\t\\tif(sum < nums[j]){\\n    \\t\\t\\t\\tsum = nums[j];\\n    \\t\\t\\t\\tstart = j + 1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif(end != size - 1){\\n    \\t\\t\\tend += 1;\\n    \\t\\t}\\n    \\t\\tcache[i] = sum;\\n    \\t}\\n    }\\n    \\n    void Merge(int *nums1, int left, int* nums2, int right, int* cache){\\n    \\tint i = 0;\\n    \\tint j = 0;\\n    \\tint k = 0;\\n    \\twhile(i < left && j < right){\\n    \\t\\tif(nums1[i] > nums2[j]){\\n    \\t\\t\\tcache[k++] = nums1[i++];\\n    \\t\\t}\\n    \\t\\telse if(nums1[i] == nums2[j]){\\n    \\t\\t\\tint temp = left - i <= right - j ? \\tleft - i : right - j;\\n    \\t\\t\\tint temp2 = compare(nums1 + i, nums2 + j, temp);\\n    \\t\\t\\tif(temp2 == 0){\\n    \\t\\t\\t\\tif(temp == left - i){\\n    \\t\\t\\t\\t\\ttemp2 = -1;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\ttemp2 = 1;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tif(temp2 > 0){\\n    \\t\\t\\t\\tcache[k++] = nums1[i++];\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tcache[k++] = nums2[j++];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\telse{\\n    \\t\\t\\tcache[k++] = nums2[j++];\\n    \\t\\t}\\n    \\t}\\n    \\twhile(i < left){\\n    \\t\\tcache[k++] = nums1[i++];\\n    \\t}\\n    \\twhile(j < right){\\n    \\t\\tcache[k++] = nums2[j++];\\n    \\t}\\n    }\\n    \\n    int compare(int* nums1, int *nums2, int size){\\n    \\tint i;\\n    \\tfor(i = 0; i < size; ++i){\\n    \\t\\tif(nums1[i] > nums2[i]){\\n    \\t\\t\\treturn 1;\\n    \\t\\t}\\n    \\t\\tif(nums1[i] < nums2[i]){\\n    \\t\\t\\treturn -1;\\n    \\t\\t}\\n    \\t}\\n    \\treturn 0;\\n    }",
                "solutionTags": [],
                "code": "###Here is my code, used 58ms, if someone has a better solution in c, please contact me.\\n\\n    void Findmax(int *nums, int size, int *cache, int length);\\n    void Merge(int *nums1, int left, int* nums2, int right, int* cache);\\n    int compare(int* nums1, int *nums2, int size);\\n    \\n    int* maxNumber(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize){\\n    \\tint* cache = (int*)malloc(sizeof(int) * k);\\n    \\tmemset(cache, 0, k * sizeof(int));\\n    \\tint* cache3 = (int*)malloc(sizeof(int) * k);\\n    \\tint i, j, t;\\n    \\t*returnSize = k;\\n    \\tfor(i = 0; i <= k; ++i){\\n    \\t\\tint left = i;\\n    \\t\\tint cache1[left];\\n    \\t\\tint right = k - i;\\n    \\t\\tint cache2[right];\\n    \\n    \\t\\tif(left > nums1Size || right > nums2Size){\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tFindmax(nums1, nums1Size, cache1, left);\\n    \\t\\tFindmax(nums2, nums2Size, cache2, right);\\n    \\n    \\t\\tMerge(cache1, left, cache2, right, cache3);\\n    \\t\\tt = compare(cache, cache3, k);\\n    \\t\\tif(t < 0){\\n    \\t\\t\\tfor(j = 0; j < k; ++j){\\n    \\t\\t\\t\\tcache[j] = cache3[j];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\n    \\treturn cache;\\n    }\\n    \\n    void Findmax(int *nums, int size, int *cache, int length){\\n    \\tint start = 0;\\n    \\tint end = size - length;\\n    \\tint i, j, sum;\\n    \\tfor(i = 0; i < length; ++i){\\n    \\t\\tsum = -1;\\n    \\t\\tfor(j = start; j <= end; ++j)\\n    \\t\\t{\\n    \\t\\t\\tif(sum < nums[j]){\\n    \\t\\t\\t\\tsum = nums[j];\\n    \\t\\t\\t\\tstart = j + 1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif(end != size - 1){\\n    \\t\\t\\tend += 1;\\n    \\t\\t}\\n    \\t\\tcache[i] = sum;\\n    \\t}\\n    }\\n    \\n    void Merge(int *nums1, int left, int* nums2, int right, int* cache){\\n    \\tint i = 0;\\n    \\tint j = 0;\\n    \\tint k = 0;\\n    \\twhile(i < left && j < right){\\n    \\t\\tif(nums1[i] > nums2[j]){\\n    \\t\\t\\tcache[k++] = nums1[i++];\\n    \\t\\t}\\n    \\t\\telse if(nums1[i] == nums2[j]){\\n    \\t\\t\\tint temp = left - i <= right - j ? \\tleft - i : right - j;\\n    \\t\\t\\tint temp2 = compare(nums1 + i, nums2 + j, temp);\\n    \\t\\t\\tif(temp2 == 0){\\n    \\t\\t\\t\\tif(temp == left - i){\\n    \\t\\t\\t\\t\\ttemp2 = -1;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\ttemp2 = 1;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tif(temp2 > 0){\\n    \\t\\t\\t\\tcache[k++] = nums1[i++];\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tcache[k++] = nums2[j++];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\telse{\\n    \\t\\t\\tcache[k++] = nums2[j++];\\n    \\t\\t}\\n    \\t}\\n    \\twhile(i < left){\\n    \\t\\tcache[k++] = nums1[i++];\\n    \\t}\\n    \\twhile(j < right){\\n    \\t\\tcache[k++] = nums2[j++];\\n    \\t}\\n    }\\n    \\n    int compare(int* nums1, int *nums2, int size){\\n    \\tint i;\\n    \\tfor(i = 0; i < size; ++i){\\n    \\t\\tif(nums1[i] > nums2[i]){\\n    \\t\\t\\treturn 1;\\n    \\t\\t}\\n    \\t\\tif(nums1[i] < nums2[i]){\\n    \\t\\t\\treturn -1;\\n    \\t\\t}\\n    \\t}\\n    \\treturn 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 77320,
                "title": "o-m-n-k-k-algorithm-with-dp-and-greedy",
                "content": "This is a very challenging problem.\\n\\nThe first step is to use dp solution find the num[m, i], which means the max number with i digits from num[0]~num[m]. This part of DP is already a hard question, and many similar questions can be found (e.g.: Problem 72 or 115). The recursive equation is: dp(m,k) = max(dp(m-1, k), dp(m-1,k-1)+num[m]). But, here, since the backtrace is only 1 step ahead, we can save memory to be O(k) of less-than-k-digit numbers. We can use O(m*k) time to run through the dp, and each max comparison will take another O(k) time to finish. Thus the overall the generation of maxNum(m, k) is O(m*k*k). This piece of function is here:\\n\\n    vector<vector<int>> maxNum(vector<int> & nums, int k) {\\n        vector<vector<int> > record(k+1);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int kk = k; kk >= 1; --kk) {\\n                if (kk>i) record[kk].clear();\\n                vector<int> temp = record[kk-1];\\n                temp.push_back(nums[i]);\\n                record[kk] = maxVector(record[kk], temp);\\n            }\\n        }\\n        return record;     \\n    }\\n\\nThe rest will be a greedy algorithm. For each i in [0,k], we have maxNum(num1, i) and maxNum(num2, k-i). The maximized merged number can be easily generated by a greedy algorithm follow a lex order. The largest merged number will be the final solution. This piece of algorithm with known maxNum(num1, i) and maxNum(num2, k-i) from DP is only O(k*k). \\n\\nThus the overall time complexity of algorithm is O((m+n)*k*k). The space complexity is O((m+n)*k). \\n\\nHere is the overall solution:\\n\\n    vector<int> maxVector(vector<int> &a, vector<int> &b) {\\n        if (a.size() > b.size()) return a;\\n        else if (a.size() < b.size()) return b;\\n        else {\\n            for (int i = 0; i<a.size(); ++i) {\\n                if (a[i] > b[i]) return a;\\n                else if (a[i] < b[i]) return b;\\n            }\\n            return a;\\n        }\\n    }\\n    \\n    vector<vector<int>> maxNum(vector<int> & nums, int k) {\\n        vector<vector<int> > record(k+1);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int kk = k; kk >= 1; --kk) {\\n                if (kk>i) record[kk].clear();\\n                vector<int> temp = record[kk-1];\\n                temp.push_back(nums[i]);\\n                record[kk] = maxVector(record[kk], temp);\\n            }\\n        }\\n        return record;     \\n    }\\n    \\n    vector<int> maxMerge(vector<int> & a, vector<int> & b) {\\n        vector<int> res;\\n        int i = 0;\\n        int j = 0;\\n        while (i<a.size() || j<b.size()) {\\n            if (i == a.size()) res.push_back(b[j++]);\\n            else if (j == b.size()) res.push_back(a[i++]);\\n            else if (a[i]>b[j]) res.push_back(a[i++]);\\n            else if (a[i]<b[j]) res.push_back(b[j++]);\\n            else {\\n                int ii = i, jj = j;\\n                while (ii<a.size() && jj<b.size() && a[ii] == b[jj]) {ii++; jj++;}\\n                if (ii == a.size() && jj == b.size()) res.push_back(a[i++]);\\n                else if (ii == a.size() || a[ii] < b[jj]) res.push_back(b[j++]);\\n                else if (jj == b.size() || a[ii] > b[jj]) res.push_back(a[i++]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if (nums1.size()+nums2.size() == k) return maxMerge(nums1, nums2);\\n        vector<vector<int> > range1 = maxNum(nums1, k);\\n        vector<vector<int> > range2 = maxNum(nums2, k);\\n    \\n        vector<int> maxResult;\\n        for (int n1 = 0; n1 <= k; ++n1) {\\n            int n2 = k-n1;\\n            vector<int> temp = maxMerge(range1[n1], range2[n2]);\\n            maxResult = maxVector(maxResult, temp);\\n        }\\n        return maxResult;\\n    }\\n\\nBTW, this piece of code passes all my local tests, but it always reports failure in a simple test case in the leetcode test environment. \\n\\n    [5,0,2,1,0,1,0,3,9,1,2,8,0,9,8,1,4,7,3]\\n    [7,6,7,1,0,1,0,5,6,0,5,0]\\n    31\\n\\nI suspect the leetcode compiling system might have some bugs somewhere.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "This is a very challenging problem.\\n\\nThe first step is to use dp solution find the num[m, i], which means the max number with i digits from num[0]~num[m]. This part of DP is already a hard question, and many similar questions can be found (e.g.: Problem 72 or 115). The recursive equation is: dp(m,k) = max(dp(m-1, k), dp(m-1,k-1)+num[m]). But, here, since the backtrace is only 1 step ahead, we can save memory to be O(k) of less-than-k-digit numbers. We can use O(m*k) time to run through the dp, and each max comparison will take another O(k) time to finish. Thus the overall the generation of maxNum(m, k) is O(m*k*k). This piece of function is here:\\n\\n    vector<vector<int>> maxNum(vector<int> & nums, int k) {\\n        vector<vector<int> > record(k+1);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int kk = k; kk >= 1; --kk) {\\n                if (kk>i) record[kk].clear();\\n                vector<int> temp = record[kk-1];\\n                temp.push_back(nums[i]);\\n                record[kk] = maxVector(record[kk], temp);\\n            }\\n        }\\n        return record;     \\n    }\\n\\nThe rest will be a greedy algorithm. For each i in [0,k], we have maxNum(num1, i) and maxNum(num2, k-i). The maximized merged number can be easily generated by a greedy algorithm follow a lex order. The largest merged number will be the final solution. This piece of algorithm with known maxNum(num1, i) and maxNum(num2, k-i) from DP is only O(k*k). \\n\\nThus the overall time complexity of algorithm is O((m+n)*k*k). The space complexity is O((m+n)*k). \\n\\nHere is the overall solution:\\n\\n    vector<int> maxVector(vector<int> &a, vector<int> &b) {\\n        if (a.size() > b.size()) return a;\\n        else if (a.size() < b.size()) return b;\\n        else {\\n            for (int i = 0; i<a.size(); ++i) {\\n                if (a[i] > b[i]) return a;\\n                else if (a[i] < b[i]) return b;\\n            }\\n            return a;\\n        }\\n    }\\n    \\n    vector<vector<int>> maxNum(vector<int> & nums, int k) {\\n        vector<vector<int> > record(k+1);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int kk = k; kk >= 1; --kk) {\\n                if (kk>i) record[kk].clear();\\n                vector<int> temp = record[kk-1];\\n                temp.push_back(nums[i]);\\n                record[kk] = maxVector(record[kk], temp);\\n            }\\n        }\\n        return record;     \\n    }\\n    \\n    vector<int> maxMerge(vector<int> & a, vector<int> & b) {\\n        vector<int> res;\\n        int i = 0;\\n        int j = 0;\\n        while (i<a.size() || j<b.size()) {\\n            if (i == a.size()) res.push_back(b[j++]);\\n            else if (j == b.size()) res.push_back(a[i++]);\\n            else if (a[i]>b[j]) res.push_back(a[i++]);\\n            else if (a[i]<b[j]) res.push_back(b[j++]);\\n            else {\\n                int ii = i, jj = j;\\n                while (ii<a.size() && jj<b.size() && a[ii] == b[jj]) {ii++; jj++;}\\n                if (ii == a.size() && jj == b.size()) res.push_back(a[i++]);\\n                else if (ii == a.size() || a[ii] < b[jj]) res.push_back(b[j++]);\\n                else if (jj == b.size() || a[ii] > b[jj]) res.push_back(a[i++]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if (nums1.size()+nums2.size() == k) return maxMerge(nums1, nums2);\\n        vector<vector<int> > range1 = maxNum(nums1, k);\\n        vector<vector<int> > range2 = maxNum(nums2, k);\\n    \\n        vector<int> maxResult;\\n        for (int n1 = 0; n1 <= k; ++n1) {\\n            int n2 = k-n1;\\n            vector<int> temp = maxMerge(range1[n1], range2[n2]);\\n            maxResult = maxVector(maxResult, temp);\\n        }\\n        return maxResult;\\n    }\\n\\nBTW, this piece of code passes all my local tests, but it always reports failure in a simple test case in the leetcode test environment. \\n\\n    [5,0,2,1,0,1,0,3,9,1,2,8,0,9,8,1,4,7,3]\\n    [7,6,7,1,0,1,0,5,6,0,5,0]\\n    31\\n\\nI suspect the leetcode compiling system might have some bugs somewhere.",
                "codeTag": "Unknown"
            },
            {
                "id": 77344,
                "title": "40ms-clean-c-solution",
                "content": "    class Solution {\\n    public:\\n    \\n        vector<vector<int>> dp(const vector<int>& nums)\\n        {\\n            int len = nums.size();\\n            vector< vector<int> > mem(len+1);\\n            mem[len] = nums;\\n            for (int i=len-1; i >=0; i--)\\n            {\\n                mem[i] = mem[i+1];\\n                for (int j=1; j <  mem[i].size(); j++)\\n                {\\n                    if ( mem[i][j] > mem[i][j-1])\\n                    {\\n                        mem[i].erase( mem[i].begin() + j-1);\\n                        break;\\n                    }\\n                }\\n                mem[i].resize(i);\\n            }\\n            \\n            return mem;\\n        }\\n    \\n        vector<int> special_merge(const vector<int>& res1,const vector<int>& res2, int k)\\n        {\\n                vector<int> res(k);\\n                int idx1=0, idx2=0, idx=0;\\n         \\n                // take the largest number. In case of equality take from the sequence that leads faster to a larger number.\\n                while ( idx1 < res1.size() && idx2 < res2.size())\\n                {\\n                    if (res1[idx1] > res2[idx2]) \\n                    {\\n                        res[idx++] =  res1[idx1++];\\n                    }\\n                    else if (res1[idx1] < res2[idx2])\\n                    {\\n                        res[idx++] = res2[idx2++];\\n                    }\\n                    else\\n                    {\\n                        int tmp = res1[idx1];\\n                        auto r = lexicographical_compare( res1.begin() + idx1, res1.end(), res2.begin() + idx2, res2.end() )\\n                        ? make_pair( ref(res2), ref(idx2)) : make_pair( ref(res1), ref(idx1));\\n                       \\n                        while ( r.second < r.first.size() && r.first[r.second] == tmp)\\n                        {\\n                            res[idx++] =  r.first[r.second++];\\n                        }\\n                    }\\n                }\\n                auto it = copy(res1.begin()+idx1, res1.end(), res.begin() + idx );\\n                copy( res2.begin()+idx2, res2.end(), it );\\n                return res;\\n        }\\n        \\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) \\n        {\\n            // find best sub-sequences of nums1 and nums2 for all possible lengths\\n            auto mem1 = dp(nums1); \\n            auto mem2 = dp(nums2);\\n            \\n            int M = min( k ,  (int) nums1.size());  // Maximum items we can take from nums1\\n            int m = std::max(0, k - (int) nums2.size() ); // Minimum items we can take from nums1\\n            \\n            vector<int> result;\\n            for (int n1 =m; n1 <= M; n1++)\\n            {\\n                result = max( result,  special_merge( mem1[ n1], mem2[k-n1], k) );\\n            }\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\n        vector<vector<int>> dp(const vector<int>& nums)\\n        {\\n            int len = nums.size();\\n            vector< vector<int> > mem(len+1);\\n            mem[len] = nums;\\n            for (int i=len-1; i >=0; i--)\\n            {\\n                mem[i] = mem[i+1];\\n                for (int j=1; j <  mem[i].size(); j++)\\n                {\\n                    if ( mem[i][j] > mem[i][j-1])\\n                    {\\n                        mem[i].erase( mem[i].begin() + j-1);\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 77350,
                "title": "o-m-n-2-with-linear-time-suffix-array-construction",
                "content": "    #define FOR(i, a, b) for (int i = (a); i < (b); i++)\\n    #define REP(i, n) for (int i = 0; i < (n); i++)\\n    #define ROF(i, a, b) for (int i = (b); --i >= (a); )\\n    \\n    namespace KoAluru\\n    {\\n      bool *t;\\n      int *b;\\n    \\n      template<typename T>\\n      void bucket(T a[], int n, int k, bool end)\\n      {\\n        fill_n(b, k, 0);\\n        REP(i, n) b[a[i]]++;\\n        if (end)\\n          FOR(i, 1, k)\\n            b[i] += b[i-1];\\n        else {\\n          int s = 0;\\n          REP(i, k)\\n            s += b[i], b[i] = s-b[i];\\n        }\\n      }\\n    \\n      template<typename T>\\n      void plus_to_minus(T a[], int sa[], int n, int k)\\n      {\\n        bucket(a, n, k, false);\\n        sa[b[a[n-1]]++] = n-1;\\n        REP(i, n-1) {\\n          int j = sa[i]-1;\\n          if (j >= 0 && ! t[j])\\n            sa[b[a[j]]++] = j;\\n        }\\n      }\\n    \\n      template<typename T>\\n      void minus_to_plus(T a[], int sa[], int n, int k)\\n      {\\n        bucket(a, n, k, true);\\n        ROF(i, 0, n) {\\n          int j = sa[i]-1;\\n          if (j >= 0 && t[j])\\n            sa[--b[a[j]]] = j;\\n        }\\n      }\\n    \\n      template<typename T>\\n      void ka(const T a[], int n, int k, int sa[])\\n      {\\n        t[n-1] = false;\\n        ROF(i, 0, n-1)\\n          t[i] = a[i] < a[i+1] || a[i] == a[i+1] && t[i+1];\\n        bool minor = 2 * count(t, t+n, false) > n;\\n    \\n        bucket(a, n, k, minor);\\n        fill_n(sa, n, -1);\\n        if (minor) {\\n          REP(i, n)\\n            if (t[i])\\n              sa[--b[a[i]]] = i;\\n          plus_to_minus(a, sa, n, k);\\n          minus_to_plus(a, sa, n, k);\\n        } else {\\n          sa[b[a[n-1]]++] = n-1;\\n          REP(i, n-1)\\n            if (! t[i])\\n              sa[b[a[i]]++] = i;\\n          minus_to_plus(a, sa, n, k);\\n          plus_to_minus(a, sa, n, k);\\n        }\\n    \\n        int last = -1, name = 0, nn = count(t, t+n, minor);\\n        int *sa2, *pi;\\n        if (minor)\\n          sa2 = sa, pi = sa+n-nn;\\n        else\\n          sa2 = sa+n-nn, pi = sa;\\n        fill_n(b, n, -1);\\n        REP(i, n)\\n          if (sa[i] >= 0 && minor == t[sa[i]]) {\\n            bool diff = last == -1;\\n            int p = sa[i];\\n            if (! diff)\\n              REP(j, n) {\\n                if (last+j >= n || p+j >= n || a[last+j] != a[p+j] || t[last+j] != t[p+j]) {\\n                  diff = true;\\n                  break;\\n                } else if (j > 0 && (minor == t[last+j] || minor == t[p+j]))\\n                  break;\\n              }\\n            if (diff) {\\n              name++;\\n              last = p;\\n            }\\n            b[p] = name-1;\\n          }\\n        nn = 0;\\n        REP(i, n)\\n          if (b[i] >= 0)\\n            pi[nn++] = b[i];\\n    \\n        if (name < nn)\\n          ka(pi, nn, name, sa2);\\n        else\\n          REP(i, nn)\\n            sa2[pi[i]] = i;\\n    \\n        ROF(i, 0, nn)\\n          t[i] = a[i] < a[i+1] || a[i] == a[i+1] && t[i+1];\\n    \\n        nn = 0;\\n        bucket(a, n, k, minor);\\n        if (minor) {\\n          REP(i, n)\\n            if (minor == t[i])\\n              pi[nn++] = i;\\n          REP(i, nn)\\n            sa[i] = pi[sa2[i]];\\n          ROF(i, 0, nn) {\\n            int j = sa[i];\\n            sa[i] = -1;\\n            sa[--b[a[j]]] = j;\\n          }\\n        } else {\\n          REP(i, n)\\n            if (minor == t[i])\\n              pi[nn++] = i;\\n          ROF(i, 0, nn)\\n            sa[n-nn+i] = pi[sa2[i]];\\n          REP(i, nn) {\\n            int j = sa[n-nn+i];\\n            sa[n-nn+i] = -1;\\n            sa[b[a[j]]++] = j;\\n          }\\n        }\\n        if (minor)\\n          plus_to_minus(a, sa, n, k);\\n        else\\n          minus_to_plus(a, sa, n, k);\\n      }\\n    \\n      template<typename T>\\n      void main(const T a[], int n, int k, int sa[], int b[])\\n      {\\n        if (n > 0) {\\n          KoAluru::b = b;\\n          t = new bool[n];\\n          ka(a, n, k, sa);\\n          delete[] t;\\n        }\\n      }\\n    };\\n    \\n    class Solution {\\n      vector<int> maxSubseq(const vector<int> &a, int c) {\\n        vector<int> r;\\n        REP(i, a.size()) {\\n          while (r.size()+a.size()-i > c && r.size() && r.back() < a[i])\\n            r.pop_back();\\n          if (r.size() < c)\\n            r.push_back(a[i]);\\n        }\\n        return r;\\n      }\\n      vector<int> interleave(vector<int> a, const vector<int> &b) {\\n        int m = a.size(), n = b.size(), i = 0, j = 0, k = 0;\\n        vector<int> sa(m+n+1), rnk(max(m+n+1, 10+1));\\n        a.resize(m+n+1);\\n        REP(i, m)\\n          a[i]++;\\n        a[m] = 0;\\n        REP(i, n)\\n          a[m+1+i] = b[i]+1;\\n        KoAluru::main(&a[0], m+n+1, 10+1, &sa[0], &rnk[0]);\\n        REP(i, m+n+1)\\n          rnk[sa[i]] = i;\\n        while (i < m || j < n)\\n          if (j == n || i < m && rnk[i] > rnk[m+1+j])\\n            sa[k++] = a[i++]-1;\\n          else\\n            sa[k++] = b[j++];\\n        sa.pop_back();\\n        return sa;\\n      }\\n    public:\\n      vector<int> maxNumber(vector<int> &a, vector<int> &b, int k) {\\n        int m = a.size(), n = b.size();\\n        vector<int> mx;\\n        for (int i = max(k-n, 0); i <= min(k, m); i++) {\\n          auto t = interleave(maxSubseq(a, i), maxSubseq(b, k-i));\\n          if (lexicographical_compare(mx.begin(), mx.end(), t.begin(), t.end()))\\n            mx.swap(t);\\n        }\\n        return mx;\\n      }\\n    };\\n\\n[https://github.com/MaskRay/LeetCode/blob/master/create-maximum-number.cc][1]\\n\\n\\n  [1]: https://github.com/MaskRay/LeetCode/blob/master/create-maximum-number.cc",
                "solutionTags": [],
                "code": "class Solution {\\n      vector<int> maxSubseq(const vector<int> &a, int c) {\\n        vector<int> r;\\n        REP(i, a.size()) {\\n          while (r.size()+a.size()-i > c && r.size() && r.back() < a[i])\\n            r.pop_back();\\n          if (r.size() < c)\\n            r.push_back(a[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 77351,
                "title": "tle-python-dp-solution-o-k-m-n-m-n",
                "content": "Short but TLE... :P\\n\\nPython Code:\\n\\n    class Solution(object):\\n        def maxNumber(self, nums1, nums2, k):\\n            len1 = len(nums1)\\n            len2 = len(nums2)\\n            dp = [[[[]] * (len2 + 1) for x in range(len1 + 1)] for y in range(k + 1)]\\n            for z in range(1, k + 1):\\n                for x in range(len1 + 1):\\n                    for y in range(len2 + 1):\\n                        for p in range(x):\\n                            if len(dp[z-1][p][y]) == z - 1:\\n                                dp[z][x][y] = max(dp[z][x][y], dp[z-1][p][y]+[nums1[p]])\\n                        for q in range(y):\\n                            if len(dp[z-1][x][q]) == z - 1:\\n                                dp[z][x][y] = max(dp[z][x][y], dp[z-1][x][q]+[nums2[q]])\\n            return dp[k][len1][len2]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "Short but TLE... :P\\n\\nPython Code:\\n\\n    class Solution(object):\\n        def maxNumber(self, nums1, nums2, k):\\n            len1 = len(nums1)\\n            len2 = len(nums2)\\n            dp = [[[[]] * (len2 + 1) for x in range(len1 + 1)] for y in range(k + 1)]\\n            for z in range(1, k + 1):\\n                for x in range(len1 + 1):\\n                    for y in range(len2 + 1):\\n                        for p in range(x):\\n                            if len(dp[z-1][p][y]) == z - 1:\\n                                dp[z][x][y] = max(dp[z][x][y], dp[z-1][p][y]+[nums1[p]])\\n                        for q in range(y):\\n                            if len(dp[z-1][x][q]) == z - 1:\\n                                dp[z][x][y] = max(dp[z][x][y], dp[z-1][x][q]+[nums2[q]])\\n            return dp[k][len1][len2]",
                "codeTag": "Java"
            },
            {
                "id": 4077513,
                "title": "c-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string&str1 , string&str2 , int i , int j){\\n        while(i < str1.size() || j < str2.size()){\\n            if(i >= str1.size()) return false;\\n            else if(j >= str2.size())return true;\\n            else if(str1[i] < str2[j])return false;\\n            else if(str1[i] > str2[j])return true;\\n            else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n    string mergeSort(string &str1 , string str2){\\n        int n = str1.size();\\n        int m = str2.size();\\n\\n        string result = \"\";\\n        int i = 0 , j = 0;\\n        while(i < n && j < m){\\n            if(str1[i]==str2[j]){\\n                if(check(str1 , str2 , i + 1 , j + 1)==true){\\n                    result+=str1[i++];\\n                }else{\\n                    result+=str2[j++];\\n                }\\n            }\\n            else if(str1[i] > str2[j]){\\n                result += str1[i];\\n                i++;\\n            }else{\\n                result+=str2[j];\\n                j++;\\n            }\\n        }\\n        while(i < n){\\n            result += str1[i++];\\n        }\\n        while(j < m){\\n            result += str2[j++];\\n        }\\n        return result;\\n    }\\n    string findMaxK(vector<int>&nums , int k){\\n        int n = nums.size();\\n        int toRemove = n - k;\\n        stack<int> st;\\n        st.push(nums[0]);\\n        for(int i = 1 ; i < n ; i++){\\n            int number = nums[i];\\n            while(st.size() && st.top()<number && toRemove>0){\\n                toRemove--;\\n                st.pop();\\n            }\\n            st.push(number);\\n        }\\n        while(toRemove>0){\\n            st.pop();\\n            toRemove--;\\n        }\\n        string result = \"\";\\n        while(st.size()){\\n            result += (st.top() + \\'0\\');\\n            st.pop();\\n        }\\n        reverse(result.begin() , result.end());\\n        return result;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        string result(k , \\'0\\');\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        for(int i = 0 ; i <= k ; i++){\\n            int fromFirst = i;\\n            int fromSecond = k - i;\\n            if(fromFirst > n || fromSecond > m)continue;\\n            string first = findMaxK(nums1 , fromFirst);\\n            string second = findMaxK(nums2 , fromSecond);\\n            string answer = mergeSort(first , second);\\n            result = max(result , answer);\\n            cout<<result<<endl;\\n        }\\n        cout<<findMaxK(nums1 , 1)<<endl;\\n        vector<int> answer;\\n        for(auto ch : result)answer.push_back(ch - \\'0\\');\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string&str1 , string&str2 , int i , int j){\\n        while(i < str1.size() || j < str2.size()){\\n            if(i >= str1.size()) return false;\\n            else if(j >= str2.size())return true;\\n            else if(str1[i] < str2[j])return false;\\n            else if(str1[i] > str2[j])return true;\\n            else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n    string mergeSort(string &str1 , string str2){\\n        int n = str1.size();\\n        int m = str2.size();\\n\\n        string result = \"\";\\n        int i = 0 , j = 0;\\n        while(i < n && j < m){\\n            if(str1[i]==str2[j]){\\n                if(check(str1 , str2 , i + 1 , j + 1)==true){\\n                    result+=str1[i++];\\n                }else{\\n                    result+=str2[j++];\\n                }\\n            }\\n            else if(str1[i] > str2[j]){\\n                result += str1[i];\\n                i++;\\n            }else{\\n                result+=str2[j];\\n                j++;\\n            }\\n        }\\n        while(i < n){\\n            result += str1[i++];\\n        }\\n        while(j < m){\\n            result += str2[j++];\\n        }\\n        return result;\\n    }\\n    string findMaxK(vector<int>&nums , int k){\\n        int n = nums.size();\\n        int toRemove = n - k;\\n        stack<int> st;\\n        st.push(nums[0]);\\n        for(int i = 1 ; i < n ; i++){\\n            int number = nums[i];\\n            while(st.size() && st.top()<number && toRemove>0){\\n                toRemove--;\\n                st.pop();\\n            }\\n            st.push(number);\\n        }\\n        while(toRemove>0){\\n            st.pop();\\n            toRemove--;\\n        }\\n        string result = \"\";\\n        while(st.size()){\\n            result += (st.top() + \\'0\\');\\n            st.pop();\\n        }\\n        reverse(result.begin() , result.end());\\n        return result;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        string result(k , \\'0\\');\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        for(int i = 0 ; i <= k ; i++){\\n            int fromFirst = i;\\n            int fromSecond = k - i;\\n            if(fromFirst > n || fromSecond > m)continue;\\n            string first = findMaxK(nums1 , fromFirst);\\n            string second = findMaxK(nums2 , fromSecond);\\n            string answer = mergeSort(first , second);\\n            result = max(result , answer);\\n            cout<<result<<endl;\\n        }\\n        cout<<findMaxK(nums1 , 1)<<endl;\\n        vector<int> answer;\\n        for(auto ch : result)answer.push_back(ch - \\'0\\');\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4022386,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSub(vector<int>&num,int l){\\n        vector<int>ans;\\n        int n=num.size();\\n        for(int i=0;i<num.size();i++){\\n            while(!ans.empty() && ans.back()<num[i] && n-i-1>=l-ans.size()){\\n                ans.pop_back();\\n            }\\n            if(ans.size()<l){\\n                ans.push_back(num[i]);\\n            }\\n        }\\n        // for(auto it:ans){cout<<it;}cout<<endl;\\n        return ans;\\n    }\\n    bool check(vector<int>&s1,vector<int>&s2,int i,int j){\\n        // int i=0;\\n        // int j=0;\\n        vector<int>ans;\\n        //checks whether s1>s2 lexo or not\\n        while(i<s1.size() || j<s2.size()){\\n            if(i>=s1.size()){\\n                return 0;\\n            }else if(j>=s2.size()){\\n                return 1;\\n            }else if(s1[i]>s2[j]){\\n                return 1;\\n            }else if(s2[j]>s1[i]){\\n                return 0;\\n            }else{\\n               i++;j++;\\n            }\\n        }\\n        return 1;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int>res;\\n        for(int k1=0;k1<=k;k1++){\\n            int k2=k-k1;\\n            if(k1>nums1.size() || k2>nums2.size()){\\n                continue;\\n            }\\n            vector<int>s1=maxSub(nums1,k1);\\n            vector<int>s2=maxSub(nums2,k2);\\n            int i=0;\\n            int j=0;\\n            vector<int>ans;\\n            while(i<s1.size() || j<s2.size()){\\n                if(i>=s1.size()){\\n                    ans.push_back(s2[j++]);\\n                }else if(j>=s2.size()){\\n                    ans.push_back(s1[i++]);\\n                }else if(s1[i]>s2[j]){\\n                    ans.push_back(s1[i++]);\\n                }else if(s2[j]>s1[i]){\\n                    ans.push_back(s2[j++]);\\n                }else{\\n                    //find the greater subs vector\\n                    if(check(s1,s2,i,j)){\\n                        ans.push_back(s1[i++]);\\n                    }else{\\n                        ans.push_back(s2[j++]);\\n                    }\\n                }\\n            }\\n            if(res<ans){\\n                res=ans;\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# **PLEASE UPVOTE IF YOU LIKED!!**\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSub(vector<int>&num,int l){\\n        vector<int>ans;\\n        int n=num.size();\\n        for(int i=0;i<num.size();i++){\\n            while(!ans.empty() && ans.back()<num[i] && n-i-1>=l-ans.size()){\\n                ans.pop_back();\\n            }\\n            if(ans.size()<l){\\n                ans.push_back(num[i]);\\n            }\\n        }\\n        // for(auto it:ans){cout<<it;}cout<<endl;\\n        return ans;\\n    }\\n    bool check(vector<int>&s1,vector<int>&s2,int i,int j){\\n        // int i=0;\\n        // int j=0;\\n        vector<int>ans;\\n        //checks whether s1>s2 lexo or not\\n        while(i<s1.size() || j<s2.size()){\\n            if(i>=s1.size()){\\n                return 0;\\n            }else if(j>=s2.size()){\\n                return 1;\\n            }else if(s1[i]>s2[j]){\\n                return 1;\\n            }else if(s2[j]>s1[i]){\\n                return 0;\\n            }else{\\n               i++;j++;\\n            }\\n        }\\n        return 1;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int>res;\\n        for(int k1=0;k1<=k;k1++){\\n            int k2=k-k1;\\n            if(k1>nums1.size() || k2>nums2.size()){\\n                continue;\\n            }\\n            vector<int>s1=maxSub(nums1,k1);\\n            vector<int>s2=maxSub(nums2,k2);\\n            int i=0;\\n            int j=0;\\n            vector<int>ans;\\n            while(i<s1.size() || j<s2.size()){\\n                if(i>=s1.size()){\\n                    ans.push_back(s2[j++]);\\n                }else if(j>=s2.size()){\\n                    ans.push_back(s1[i++]);\\n                }else if(s1[i]>s2[j]){\\n                    ans.push_back(s1[i++]);\\n                }else if(s2[j]>s1[i]){\\n                    ans.push_back(s2[j++]);\\n                }else{\\n                    //find the greater subs vector\\n                    if(check(s1,s2,i,j)){\\n                        ans.push_back(s1[i++]);\\n                    }else{\\n                        ans.push_back(s2[j++]);\\n                    }\\n                }\\n            }\\n            if(res<ans){\\n                res=ans;\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3909404,
                "title": "monotonic-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& v1, vector<int>& v2, int k) {\\n        int n = v1.size(), m = v2.size();\\n        // 1st wale se i, le rha , second se k - i\\n        vector<int> chk;\\n        for(int i=0;i<k;i++){\\n            chk.push_back(0);\\n        }\\n        for(int i=0;i<=n and k-i>=0;i++){\\n            int fstNeed = i, secNeed = k - i;\\n            int fstRem = n - fstNeed, secRem = m - secNeed;\\n            vector<int> ans;\\n            if(secRem < 0) continue;\\n            stack<int> s;\\n            vector<int> fst;\\n            for(int j=0;j<n;j++){\\n                while(s.size() > 0 and v1[j] > s.top() and fstRem){\\n                    s.pop();\\n                    fstRem --;\\n                }\\n                s.push(v1[j]);\\n            }\\n            while(fstRem --) s.pop();\\n            while(s.size() > 0) fst.push_back(s.top()), s.pop();\\n            reverse(fst.begin(), fst.end());\\n            vector<int> sec;\\n            for(int j=0;j<m;j++){\\n                while(s.size() > 0 and v2[j] > s.top() and secRem){\\n                    s.pop(); secRem --;\\n                }\\n                s.push(v2[j]);\\n            }\\n            while(secRem --) s.pop();\\n            while(s.size() > 0) sec.push_back(s.top()), s.pop();\\n            reverse(sec.begin(), sec.end());\\n            if(sec.size() == 0 or fst.size() == 0){\\n                if(sec.size() == 0) ans = fst;\\n                else ans = sec;\\n            }\\n            else{\\n                int k1 = 0, k2 = 0;\\n                while(k1 < ((int)fst.size()) and k2 < ((int)sec.size())){\\n                    if(fst[k1] > sec[k2]){\\n                        ans.push_back(fst[k1]);\\n                        k1++;\\n                    }\\n                    else if(sec[k2] > fst[k1]){\\n                        ans.push_back(sec[k2]);\\n                        k2++;\\n                    }\\n                    else{\\n                        // equal wala scene\\n                        int vp = -1;\\n                        for(int l=0;;l++){\\n                            if(k1+l >= fst.size()){\\n                                ans.push_back(sec[k2]), k2++;\\n                                break;\\n                            }\\n                            if(k2+l >= sec.size()){\\n                                ans.push_back(fst[k1]), k1++;\\n                                break;\\n                            }\\n                            if(fst[k1+l] > sec[k2+l]){\\n                                vp = 1;\\n                                break;\\n                            }\\n                            else if(fst[k1+l] < sec[k2+l]){\\n                                vp = 0;\\n                                break;\\n                            }\\n                        }\\n                        if(vp == 1) ans.push_back(fst[k1]), k1++;\\n                        else if(vp == 0) ans.push_back(sec[k2]), k2++;\\n                    }\\n                }\\n                for(int j=k1;j<fst.size();j++){\\n                    ans.push_back(fst[j]);\\n                }\\n                for(int j=k2;j<sec.size();j++){\\n                    ans.push_back(sec[j]);\\n                }\\n            }\\n            if(ans > chk){\\n                chk = ans;\\n            }\\n        }\\n        return chk;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& v1, vector<int>& v2, int k) {\\n        int n = v1.size(), m = v2.size();\\n        // 1st wale se i, le rha , second se k - i\\n        vector<int> chk;\\n        for(int i=0;i<k;i++){\\n            chk.push_back(0);\\n        }\\n        for(int i=0;i<=n and k-i>=0;i++){\\n            int fstNeed = i, secNeed = k - i;\\n            int fstRem = n - fstNeed, secRem = m - secNeed;\\n            vector<int> ans;\\n            if(secRem < 0) continue;\\n            stack<int> s;\\n            vector<int> fst;\\n            for(int j=0;j<n;j++){\\n                while(s.size() > 0 and v1[j] > s.top() and fstRem){\\n                    s.pop();\\n                    fstRem --;\\n                }\\n                s.push(v1[j]);\\n            }\\n            while(fstRem --) s.pop();\\n            while(s.size() > 0) fst.push_back(s.top()), s.pop();\\n            reverse(fst.begin(), fst.end());\\n            vector<int> sec;\\n            for(int j=0;j<m;j++){\\n                while(s.size() > 0 and v2[j] > s.top() and secRem){\\n                    s.pop(); secRem --;\\n                }\\n                s.push(v2[j]);\\n            }\\n            while(secRem --) s.pop();\\n            while(s.size() > 0) sec.push_back(s.top()), s.pop();\\n            reverse(sec.begin(), sec.end());\\n            if(sec.size() == 0 or fst.size() == 0){\\n                if(sec.size() == 0) ans = fst;\\n                else ans = sec;\\n            }\\n            else{\\n                int k1 = 0, k2 = 0;\\n                while(k1 < ((int)fst.size()) and k2 < ((int)sec.size())){\\n                    if(fst[k1] > sec[k2]){\\n                        ans.push_back(fst[k1]);\\n                        k1++;\\n                    }\\n                    else if(sec[k2] > fst[k1]){\\n                        ans.push_back(sec[k2]);\\n                        k2++;\\n                    }\\n                    else{\\n                        // equal wala scene\\n                        int vp = -1;\\n                        for(int l=0;;l++){\\n                            if(k1+l >= fst.size()){\\n                                ans.push_back(sec[k2]), k2++;\\n                                break;\\n                            }\\n                            if(k2+l >= sec.size()){\\n                                ans.push_back(fst[k1]), k1++;\\n                                break;\\n                            }\\n                            if(fst[k1+l] > sec[k2+l]){\\n                                vp = 1;\\n                                break;\\n                            }\\n                            else if(fst[k1+l] < sec[k2+l]){\\n                                vp = 0;\\n                                break;\\n                            }\\n                        }\\n                        if(vp == 1) ans.push_back(fst[k1]), k1++;\\n                        else if(vp == 0) ans.push_back(sec[k2]), k2++;\\n                    }\\n                }\\n                for(int j=k1;j<fst.size();j++){\\n                    ans.push_back(fst[j]);\\n                }\\n                for(int j=k2;j<sec.size();j++){\\n                    ans.push_back(sec[j]);\\n                }\\n            }\\n            if(ans > chk){\\n                chk = ans;\\n            }\\n        }\\n        return chk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885687,
                "title": "bfs-solution-c-93-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n    If you are interested in knowing how the solution is working, please reply below as I would like to explain the approach only if there is someone interested in knowing. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct Comb {\\n        int i;\\n        int j;\\n        int lastNum;\\n        Comb(){\\n            i=0;\\n            j=0;\\n        }\\n    };\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> res;\\n        queue<Comb> q;\\n        Comb cmb;\\n        q.push(cmb);\\n        vector<vector<bool>> done(n+1, vector<bool>(m+1, false));\\n        while(!q.empty()){\\n            int siz = q.size();\\n            vector<Comb> combStk;\\n            int mxLastVal = 0;\\n\\n            while(siz--){\\n                Comb top = q.front();\\n                q.pop();\\n                if (done[top.i][top.j]) continue;\\n                done[top.i][top.j] = true;\\n                int rem = k - res.size();\\n                int tot = (n-top.i) + (m-top.j);\\n                \\n                int iMax = min(tot-rem+top.i, n-1);\\n                int jMax = min(tot-rem+top.j, m-1);\\n\\n                int imxIdx = top.i;\\n                int jmxIdx = top.j;\\n\\n                for(int i=top.i; i<= iMax; i++){\\n                    if (nums1[i] > nums1[imxIdx]) imxIdx = i;\\n                }\\n                for(int j=top.j; j<= jMax; j++){\\n                    if (nums2[j] > nums2[jmxIdx]) jmxIdx = j;\\n                }\\n\\n                if ( (imxIdx <= iMax && jmxIdx > jMax) ||  ( imxIdx <= iMax && nums1[imxIdx] >= nums2[jmxIdx]) ){\\n                    Comb iChild;\\n                    iChild.lastNum = nums1[imxIdx];\\n                    iChild.i = imxIdx+1;\\n                    iChild.j = top.j;\\n                    combStk.push_back(iChild);\\n                    mxLastVal = max(mxLastVal, nums1[imxIdx]);\\n                }\\n                if ( (jmxIdx <= jMax && imxIdx > iMax) ||   ( jmxIdx <= jMax &&  nums1[imxIdx] <= nums2[jmxIdx]) ){\\n                    Comb jChild;\\n                    jChild.lastNum = nums2[jmxIdx];\\n                    jChild.i = top.i;\\n                    jChild.j = jmxIdx+1;\\n                    combStk.push_back(jChild);\\n                    mxLastVal = max(mxLastVal, nums2[jmxIdx]);\\n                }\\n\\n            }\\n            res.push_back(mxLastVal);\\n\\n            if (k == res.size()) return res;\\n            for(Comb comb : combStk){\\n                if (comb.lastNum < mxLastVal) continue;\\n                q.push(comb);\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Comb {\\n        int i;\\n        int j;\\n        int lastNum;\\n        Comb(){\\n            i=0;\\n            j=0;\\n        }\\n    };\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> res;\\n        queue<Comb> q;\\n        Comb cmb;\\n        q.push(cmb);\\n        vector<vector<bool>> done(n+1, vector<bool>(m+1, false));\\n        while(!q.empty()){\\n            int siz = q.size();\\n            vector<Comb> combStk;\\n            int mxLastVal = 0;\\n\\n            while(siz--){\\n                Comb top = q.front();\\n                q.pop();\\n                if (done[top.i][top.j]) continue;\\n                done[top.i][top.j] = true;\\n                int rem = k - res.size();\\n                int tot = (n-top.i) + (m-top.j);\\n                \\n                int iMax = min(tot-rem+top.i, n-1);\\n                int jMax = min(tot-rem+top.j, m-1);\\n\\n                int imxIdx = top.i;\\n                int jmxIdx = top.j;\\n\\n                for(int i=top.i; i<= iMax; i++){\\n                    if (nums1[i] > nums1[imxIdx]) imxIdx = i;\\n                }\\n                for(int j=top.j; j<= jMax; j++){\\n                    if (nums2[j] > nums2[jmxIdx]) jmxIdx = j;\\n                }\\n\\n                if ( (imxIdx <= iMax && jmxIdx > jMax) ||  ( imxIdx <= iMax && nums1[imxIdx] >= nums2[jmxIdx]) ){\\n                    Comb iChild;\\n                    iChild.lastNum = nums1[imxIdx];\\n                    iChild.i = imxIdx+1;\\n                    iChild.j = top.j;\\n                    combStk.push_back(iChild);\\n                    mxLastVal = max(mxLastVal, nums1[imxIdx]);\\n                }\\n                if ( (jmxIdx <= jMax && imxIdx > iMax) ||   ( jmxIdx <= jMax &&  nums1[imxIdx] <= nums2[jmxIdx]) ){\\n                    Comb jChild;\\n                    jChild.lastNum = nums2[jmxIdx];\\n                    jChild.i = top.i;\\n                    jChild.j = jmxIdx+1;\\n                    combStk.push_back(jChild);\\n                    mxLastVal = max(mxLastVal, nums2[jmxIdx]);\\n                }\\n\\n            }\\n            res.push_back(mxLastVal);\\n\\n            if (k == res.size()) return res;\\n            for(Comb comb : combStk){\\n                if (comb.lastNum < mxLastVal) continue;\\n                q.push(comb);\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838340,
                "title": "java-solution-with-descriptive-comments-on-each-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    /*\\n    * This function firstly fetches the digits from each array with all combinations\\n    * By combination I mean, let say k = 5, then from both the arrays number of digits can be any number less than equal to k\\n    * For eg, [6,7,1] [6,0,4] and k =5 -> we can choose 3 digits from first array and 2 from second; or vice-a-versa.\\n    * Note : the digits it chooses(let say of size 3) are the best 3 digits of that array.\\n    *\\n    *\\n    * This function creates all those combinations and then merges the chosen digits from 1st array and 2nd array.\\n    *\\n    * Then it sorts all the merged combinations and return the largest one.\\n    */\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        List<String> allPossibleNumbers = new ArrayList<>();\\n        int num1Start = Math.min(k, nums1.length);\\n        for (int i = 0; i < k; i++) {\\n            String num1LargestNumberOfSizeRem = getLargestNumber(nums1, num1Start);\\n            int rem = k - (num1LargestNumberOfSizeRem.length());\\n            if (rem > nums2.length) {\\n                break;\\n            }\\n            String num2LargestNumberOfSizeRem = getLargestNumber(nums2, rem);\\n            String mergedNumber = mergeNumbers(num1LargestNumberOfSizeRem, num2LargestNumberOfSizeRem);\\n            allPossibleNumbers.add(mergedNumber);\\n            num1Start--;\\n        }\\n        allPossibleNumbers.sort((o1, o2) -> -1 * (o1.compareTo(o2)));\\n        String largestNumber = allPossibleNumbers.get(0);\\n        int[] res = new int[k];\\n        int index = 0;\\n        while (index < largestNumber.length()) {\\n            res[index] = largestNumber.charAt(index) - \\'0\\';\\n            index++;\\n        }\\n        return res;\\n    }\\n\\n    /*\\n    *  We\\'ll not do the direct comparison of digits as it can give wrong answer\\n    *  So, we\\'ll use compare function to check which string digit should be used. By checking which one is small, and if equal\\n        then what are the subsequent digits.\\n    *  For example - Let say we get two strings - 6,7 and 6,0,4. If we want to compare the characters of these two strings in\\n        case of first element which is 6, it is mandatory that I choose from string 1, as i should be pointing at 7\\n        so that on next comparison 7 should be compared with 6 of second string.\\n        If we do Vice-a-Versa, 0 will compared with 6 of string 1 and we\\'ll get two 66 in the start which will be wrong.\\n    */\\n    private String mergeNumbers(String num1LargestNumberOfSizeRem, String num2LargestNumberOfSizeRem) {\\n        StringBuilder largestNumber = new StringBuilder();\\n        int i = 0, j = 0, indexOfMergedString = 0;\\n        int num1Len = num1LargestNumberOfSizeRem.length();\\n        int num2Len = num2LargestNumberOfSizeRem.length();\\n        while (i < num1Len && j < num2Len) {\\n            if (considerNum1Character(num1LargestNumberOfSizeRem, num2LargestNumberOfSizeRem, i, j)) {\\n                largestNumber.insert(indexOfMergedString, num1LargestNumberOfSizeRem.charAt(i));\\n                i++;\\n            } else {\\n                largestNumber.insert(indexOfMergedString, num2LargestNumberOfSizeRem.charAt(j));\\n                j++;\\n            }\\n            indexOfMergedString++;\\n        }\\n        while (i < num1Len) {\\n            largestNumber.insert(indexOfMergedString++, num1LargestNumberOfSizeRem.charAt(i));\\n            i++;\\n        }\\n        while (j < num2Len) {\\n            largestNumber.insert(indexOfMergedString++, num2LargestNumberOfSizeRem.charAt(j));\\n            j++;\\n        }\\n        return largestNumber.toString();\\n    }\\n\\n    /*\\n        This method is to check if we can consider the first string, by comparing both the string subsequent characters\\n    */\\n    private boolean considerNum1Character(String num1LargestNumberOfSizeRem, String num2LargestNumberOfSizeRem, int i, int j) {\\n        int num1Len = num1LargestNumberOfSizeRem.length();\\n        int num2Len = num2LargestNumberOfSizeRem.length();\\n\\n        while (i < num1Len && j < num2Len && num1LargestNumberOfSizeRem.charAt(i) == num2LargestNumberOfSizeRem.charAt(j)) {\\n            i++;\\n            j++;\\n        }\\n        return j == num2Len || (i < num1Len && num1LargestNumberOfSizeRem.charAt(i) > num2LargestNumberOfSizeRem.charAt(j));\\n    }\\n\\n    /*\\n    * The digits it chooses(let say of size 3) are the best 3 digits of that array.\\n    * It uses monotonously decreasing stack algorithm.\\n    */\\n    private String getLargestNumber(int[] number, int size) {\\n        if (size <= 0) {\\n            return \"\";\\n        }\\n        int maxDigitsThatCanBeIgnored = number.length - size;\\n        Stack<Integer> stack = new Stack<>();\\n        int i = 0;\\n        while (i < number.length) {\\n            while (maxDigitsThatCanBeIgnored > 0 && stack.size() > 0 && stack.peek() < number[i]) {\\n                stack.pop();\\n                maxDigitsThatCanBeIgnored--;\\n            }\\n            stack.push(number[i]);\\n            i++;\\n        }\\n        StringBuilder res = new StringBuilder();\\n        while (stack.size() > 0) {\\n            res.insert(0, stack.pop());\\n        }\\n        return res.substring(0, size);\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    * This function firstly fetches the digits from each array with all combinations\\n    * By combination I mean, let say k = 5, then from both the arrays number of digits can be any number less than equal to k\\n    * For eg, [6,7,1] [6,0,4] and k =5 -> we can choose 3 digits from first array and 2 from second; or vice-a-versa.\\n    * Note : the digits it chooses(let say of size 3) are the best 3 digits of that array.\\n    *\\n    *\\n    * This function creates all those combinations and then merges the chosen digits from 1st array and 2nd array.\\n    *\\n    * Then it sorts all the merged combinations and return the largest one.\\n    */\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        List<String> allPossibleNumbers = new ArrayList<>();\\n        int num1Start = Math.min(k, nums1.length);\\n        for (int i = 0; i < k; i++) {\\n            String num1LargestNumberOfSizeRem = getLargestNumber(nums1, num1Start);\\n            int rem = k - (num1LargestNumberOfSizeRem.length());\\n            if (rem > nums2.length) {\\n                break;\\n            }\\n            String num2LargestNumberOfSizeRem = getLargestNumber(nums2, rem);\\n            String mergedNumber = mergeNumbers(num1LargestNumberOfSizeRem, num2LargestNumberOfSizeRem);\\n            allPossibleNumbers.add(mergedNumber);\\n            num1Start--;\\n        }\\n        allPossibleNumbers.sort((o1, o2) -> -1 * (o1.compareTo(o2)));\\n        String largestNumber = allPossibleNumbers.get(0);\\n        int[] res = new int[k];\\n        int index = 0;\\n        while (index < largestNumber.length()) {\\n            res[index] = largestNumber.charAt(index) - \\'0\\';\\n            index++;\\n        }\\n        return res;\\n    }\\n\\n    /*\\n    *  We\\'ll not do the direct comparison of digits as it can give wrong answer\\n    *  So, we\\'ll use compare function to check which string digit should be used. By checking which one is small, and if equal\\n        then what are the subsequent digits.\\n    *  For example - Let say we get two strings - 6,7 and 6,0,4. If we want to compare the characters of these two strings in\\n        case of first element which is 6, it is mandatory that I choose from string 1, as i should be pointing at 7\\n        so that on next comparison 7 should be compared with 6 of second string.\\n        If we do Vice-a-Versa, 0 will compared with 6 of string 1 and we\\'ll get two 66 in the start which will be wrong.\\n    */\\n    private String mergeNumbers(String num1LargestNumberOfSizeRem, String num2LargestNumberOfSizeRem) {\\n        StringBuilder largestNumber = new StringBuilder();\\n        int i = 0, j = 0, indexOfMergedString = 0;\\n        int num1Len = num1LargestNumberOfSizeRem.length();\\n        int num2Len = num2LargestNumberOfSizeRem.length();\\n        while (i < num1Len && j < num2Len) {\\n            if (considerNum1Character(num1LargestNumberOfSizeRem, num2LargestNumberOfSizeRem, i, j)) {\\n                largestNumber.insert(indexOfMergedString, num1LargestNumberOfSizeRem.charAt(i));\\n                i++;\\n            } else {\\n                largestNumber.insert(indexOfMergedString, num2LargestNumberOfSizeRem.charAt(j));\\n                j++;\\n            }\\n            indexOfMergedString++;\\n        }\\n        while (i < num1Len) {\\n            largestNumber.insert(indexOfMergedString++, num1LargestNumberOfSizeRem.charAt(i));\\n            i++;\\n        }\\n        while (j < num2Len) {\\n            largestNumber.insert(indexOfMergedString++, num2LargestNumberOfSizeRem.charAt(j));\\n            j++;\\n        }\\n        return largestNumber.toString();\\n    }\\n\\n    /*\\n        This method is to check if we can consider the first string, by comparing both the string subsequent characters\\n    */\\n    private boolean considerNum1Character(String num1LargestNumberOfSizeRem, String num2LargestNumberOfSizeRem, int i, int j) {\\n        int num1Len = num1LargestNumberOfSizeRem.length();\\n        int num2Len = num2LargestNumberOfSizeRem.length();\\n\\n        while (i < num1Len && j < num2Len && num1LargestNumberOfSizeRem.charAt(i) == num2LargestNumberOfSizeRem.charAt(j)) {\\n            i++;\\n            j++;\\n        }\\n        return j == num2Len || (i < num1Len && num1LargestNumberOfSizeRem.charAt(i) > num2LargestNumberOfSizeRem.charAt(j));\\n    }\\n\\n    /*\\n    * The digits it chooses(let say of size 3) are the best 3 digits of that array.\\n    * It uses monotonously decreasing stack algorithm.\\n    */\\n    private String getLargestNumber(int[] number, int size) {\\n        if (size <= 0) {\\n            return \"\";\\n        }\\n        int maxDigitsThatCanBeIgnored = number.length - size;\\n        Stack<Integer> stack = new Stack<>();\\n        int i = 0;\\n        while (i < number.length) {\\n            while (maxDigitsThatCanBeIgnored > 0 && stack.size() > 0 && stack.peek() < number[i]) {\\n                stack.pop();\\n                maxDigitsThatCanBeIgnored--;\\n            }\\n            stack.push(number[i]);\\n            i++;\\n        }\\n        StringBuilder res = new StringBuilder();\\n        while (stack.size() > 0) {\\n            res.insert(0, stack.pop());\\n        }\\n        return res.substring(0, size);\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806927,
                "title": "efficient-js-solution-beat-100-both-time-and-memory",
                "content": "![image.png](https://assets.leetcode.com/users/images/d0b8979a-7415-4d0f-aec0-5b7c82007afe_1690136461.6128085.png)\\n\\n# Complexity\\n- Time complexity: $$O(k * (m+n))$$\\n- Space complexity: $$O(k + m + n)$$\\n\\n# Code\\n```jsx\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxNumber = function (nums1, nums2, k) {\\n  const n1 = nums1.length;\\n  const n2 = nums2.length;\\n  let result = Array(k).fill(0);\\n  let candidate = Array(k).fill(0);\\n  const part1 = Array(k + 1).fill(0);\\n  const part2 = Array(k + 1).fill(0);\\n\\n  /**\\n   * @param {number[]} source\\n   * @param {number[]} target\\n   * @param {number} k\\n   */\\n  function pickPart(source, target, k) {\\n    let rm = source.length - k;\\n    let j = 0;\\n\\n    for (let i = 0; i < source.length; i++) {\\n      while (rm && j && source[i] > target[j - 1]) {\\n        rm--;\\n        j--;\\n      }\\n      target[j++] = source[i];\\n    }\\n\\n    target[k] = -1;\\n    return target;\\n  }\\n\\n  const lowerL = Math.max(0, k - n2);\\n  const upperL = Math.min(n1, k);\\n  let l2, opt;\\n\\n  function merge() {\\n    let i1 = 0;\\n    let i2 = 0;\\n    let flagOpt = false;\\n\\n    for (let i = 0; i < k; i++) {\\n      let r1 = i1;\\n      let r2 = i2;\\n      while (part1[r1] === part2[r2] && part1[r1] !== -1) {\\n        r1++;\\n        r2++;\\n      }\\n      if (part1[r1] > part2[r2]) {\\n        candidate[i] = part1[i1++];\\n      } else {\\n        candidate[i] = part2[i2++];\\n      }\\n      if (!flagOpt) {\\n        if (candidate[i] > result[i]) flagOpt = true;\\n        else if (candidate[i] < result[i]) return false;\\n      }\\n    }\\n\\n    return flagOpt;\\n  }\\n\\n  for (let l1 = lowerL; l1 <= upperL; l1++) {\\n    l2 = k - l1;\\n    pickPart(nums1, part1, l1);\\n    pickPart(nums2, part2, l2);\\n    opt = merge(l1, l2);\\n    if (opt) [result, candidate] = [candidate, result];\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Greedy"
                ],
                "code": "```jsx\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxNumber = function (nums1, nums2, k) {\\n  const n1 = nums1.length;\\n  const n2 = nums2.length;\\n  let result = Array(k).fill(0);\\n  let candidate = Array(k).fill(0);\\n  const part1 = Array(k + 1).fill(0);\\n  const part2 = Array(k + 1).fill(0);\\n\\n  /**\\n   * @param {number[]} source\\n   * @param {number[]} target\\n   * @param {number} k\\n   */\\n  function pickPart(source, target, k) {\\n    let rm = source.length - k;\\n    let j = 0;\\n\\n    for (let i = 0; i < source.length; i++) {\\n      while (rm && j && source[i] > target[j - 1]) {\\n        rm--;\\n        j--;\\n      }\\n      target[j++] = source[i];\\n    }\\n\\n    target[k] = -1;\\n    return target;\\n  }\\n\\n  const lowerL = Math.max(0, k - n2);\\n  const upperL = Math.min(n1, k);\\n  let l2, opt;\\n\\n  function merge() {\\n    let i1 = 0;\\n    let i2 = 0;\\n    let flagOpt = false;\\n\\n    for (let i = 0; i < k; i++) {\\n      let r1 = i1;\\n      let r2 = i2;\\n      while (part1[r1] === part2[r2] && part1[r1] !== -1) {\\n        r1++;\\n        r2++;\\n      }\\n      if (part1[r1] > part2[r2]) {\\n        candidate[i] = part1[i1++];\\n      } else {\\n        candidate[i] = part2[i2++];\\n      }\\n      if (!flagOpt) {\\n        if (candidate[i] > result[i]) flagOpt = true;\\n        else if (candidate[i] < result[i]) return false;\\n      }\\n    }\\n\\n    return flagOpt;\\n  }\\n\\n  for (let l1 = lowerL; l1 <= upperL; l1++) {\\n    l2 = k - l1;\\n    pickPart(nums1, part1, l1);\\n    pickPart(nums2, part2, l2);\\n    opt = merge(l1, l2);\\n    if (opt) [result, candidate] = [candidate, result];\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3800466,
                "title": "python-divide-into-subproblems",
                "content": "The credits to this approach -> https://www.youtube.com/watch?v=ZHexy3JW2JA\\n\\nBasically, we can divide this problem into sub problems and then solve each of the subproblem.\\n\\nWe want to make the maximum number by picking numbers from two different lists but the thing is we can only pick them in the same order as they appear in each of the lists.\\n\\nWhat that means is,\\n\\n    Suppose, we have nums1 = [1,8,9] and nums2 = [3,4] and k = 4\\n\\n    We are asked to create the maximum number of length \"4\"\\n\\n    In that case, we cannot pick \"9\" to be the first digit\\n    Because if we do that, then we only have two numbers left to choose from  - \"3\" and \"4\".\\n    We cannot choose \"1\" and \"8\" because we have already chosen \"9\" and we are asked to preserve the order\\n\\n    So, we have to choose \"8\" as the first digit, \"9\" as second, \"3\" as third and \"4\" as forth.\\n\\n    So, the output in this case will be [8,9,3,4]\\n\\n\\nSo, as we see, we have to make a choice of picking numbers. We can take some amount of numbers from one list and some amount from other.\\nIt is also possible that we take numbers from only one list.\\n\\n    E.g. if nums1 = [9,9,9] and nums2 = [1,2,3] and k = 3\\n\\n    Then we simply return [9,9,9] since there cannot be any greater number that we can create of length 3\\n\\n    So, in this case, we picked 0 elements from second list.\\n\\n\\nSo, how can we know how many numbers we should take from one list and how many we should take from the other?\\n\\nWell, we cannot. So, we have to try all the possible combinations.\\n\\nThat is, suppose, k = 4 and nums1 = [1,2,3] and nums2 = [1,5,4]\\n\\n\\tPick 0 numbers from nums1 and 4 numbers from nums2 -> Invalid since length of nums2 is \"3\"\\n\\tPick 1 number from nums1 and 3 numbers from nums2 -> [3] and [1,5,4] will be the best combo\\n\\tPick 2 numbers from nums1 and 2 numbers from nums2 -> [2,3] and [5,4] will be the best combo\\n\\tPick 3 numbers from nums1 and 1 number from nums2 -> [1,2,3] and [5] will be the best combo\\n\\tPick 4 numbers from nums1 and 0 number from nums2 -> Invalid since length of nums1 is \"3\"\\n\\nHence, for all the valid cases, we will get two lists and those two lists have to be the most optimal ones. \\n\\nThat is, if we want to pick \"2\" numbers from nums1, that subsequence of length 2 should be the lexicographically greatest subsequence of nums1.\\n\\nOnce we get these two lists, now it\\'s time to merge the two together to form one single list of length \"k\". We have to merge the two such that we generate the maximum possible number by combining the two.\\n\\n\\tFor example, if list1 is [2,3] and list2 is [5,4] the merged result will be [5,4,2,3]\\n\\nBut, it is not always the case that we have different numbers in both lists.\\n\\nWe may encounter cases when there are same numbers so we have to choose which one to put in our merged list and what pointer to increment.\\n\\nAnd for that case, we have to write a separate logic.\\n\\nSince we want the lexicographically largest subsequence, if we have a case where both pointers are pointing to the same number, we will then compare the values after those pointers to see which subsequence will give us a bigger value first. We will then pick that subsequence. In short, we will pick the lexicographically greater subsequence out of the two.\\n\\nLet\\'s take an example to understand it - \\n\\n    Suppose, list1 is [2,1,1,0,2,0] and list2 is [1,1,1,0,2,1]\\n\\n    At first, we will put the item \"2\" in the merged list as first digit since it is greater than \"1\" in list2\\n\\t\\n\\t\\n\\t [2,1,1,0,2,0]\\n\\t    p1\\n\\t \\n\\t [1,1,1,0,2,1]\\n\\t  p2\\n\\n    so, after that pointer1 will be at index 1 in list1\\n    And pointer2 will still be at index 0\\n\\n    And as we can see, at both pointers we have the element \"1\"\\n\\n    So, which one to pick and which pointer to increment?\\n\\n    At this point, we have to see which subarray will give us a greater element first.\\n\\t\\n\\t[2,1,1,0,2,0]\\n\\t   i\\n\\t \\n\\t [1,1,1,0,2,1]\\n\\t  j\\n\\n    At i index we have element \"1\"\\n    But at j as well, we have \"1\"\\n\\n    So, we increment both of them since so far, both subsequences the same.\\n\\t\\n\\t[2,1,1,0,2,0]\\n\\t     i\\n\\t \\n\\t [1,1,1,0,2,1]\\n\\t    j\\n\\t\\n\\tAt i index we have element \"1\"\\n    But at j as well, we have \"1\"\\n\\n    So, we increment both of them since so far, both subsequences the same.\\n\\t\\n\\t[2,1,1,0,2,0]\\n\\t       i\\n\\t \\n\\t [1,1,1,0,2,1]\\n\\t      j\\n\\n    Now, At i index we have element \"0\"\\n    But at j, we have \"1\" \\n\\n    This means, the second subarray is lexicographically greater than first one.\\n\\n    So, we will pick element at pointer2 and increment pointer2. \\n\\nThis situation will come when elements are equal at both pointers.\\n\\nAlright. So, let\\'s say we formed a merged list.\\n\\nNow, whether it is the maximum or not, that depends on whether it is greater than the previous merged list we formed.\\n\\nSo, whenever we form a merged list, we compare it with the previous one and update accordingly.\\n\\nAnd so, finally, our output will point to the maximum number generated.\\n\\n```\\nclass Solution:\\n    # Helper method to get the greatest subsequence out of a list of a given length\\n    def getGreatestSubsequence(self, nums, subsequenceLength):\\n        # Length of the list\\n        n = len(nums)\\n        \\n        # Stack to efficiently compare numbers\\n        stack = []\\n        \\n        # Loop over the list\\n        for i in range(n):\\n            \\n            # If current element is greater than element on top of stack\\n            # We can remove it\\n            # But only if we have enough elements to put in stack so that required subsequenceLength is matched\\n            # (n-i) gives us the remaining elements to traverse\\n            # (len(stack) - 1) gives us the length of stack if we pop one element\\n            # So, what we are saying is \"The elements in stack after we pop + elements left to traverse\" should be >= subsequenceLength\\n            # Only then we can pop\\n            while stack and stack[-1] < nums[i] and (n - i) + (len(stack) - 1) >= subsequenceLength: stack.pop()\\n                \\n            \\n            # Now we can put the index of current element in the stack (only if we don\\'t already have \\'subsequenceLength\\' elements in the stack)\\n            if len(stack) < subsequenceLength: stack.append(nums[i])\\n            \\n        # Return this stack\\n        return stack\\n            \\n    # Helper method to compare subarrays of two lists such that one starts at index i and the other at index j\\n    # We do this comparison when we have same value at the two pointers so we have to decide which one to choose\\n    def isGreater(self, nums1, nums2, i, j):\\n        \\n        # Length of first list\\n        m = len(nums1)\\n        \\n        # Length of second list\\n        n = len(nums2)\\n        \\n        # While Loop to compare by positions\\n        while i < m or j < n:\\n            \\n            # If indices go out of bounds\\n            \\n            # If i is >= m, then nums1 is not lexicographically greater than nums2\\n            if i >= m: return False\\n            \\n            # If j is >= n, then nums1 is lexicographically greater than nums2\\n            elif j >= n: return True\\n        \\n            # If indices are not out of bounds, we can compare the elements\\n            \\n            # If \"i\" element in nums1 is greater than \"j\" element in nums2\\n            # Then nums1 is lexicographically greater than nums2\\n            elif nums1[i] > nums2[j]: return True\\n            \\n            # If \"i\" element in nums1 is smaller than \"j\" element in nums2\\n            # Then nums1 is not lexicographically greater than nums2\\n            elif nums1[i] < nums2[j]: return False\\n            \\n            # If both are equal, move on to next comparison\\n            i += 1\\n            j += 1\\n            \\n        # If we didn\\'t return anything, then both subarrays are the same\\n        # So we can return either True or False since we can choose any of the two\\n        # Let\\'s return true\\n        return True\\n            \\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        \\n        # Final output to return\\n        output = []\\n        \\n        # If we had only one list then it would\\'ve been super simple \\n        # to get a lexicographically greatest number\\n        # But, in this problem, we have two numbers\\n        # And what we don\\'t exactly know is, how many numbers we should take from nums1 and how many from nums2\\n        \\n        \\n        # Since k <= m + n\\n        # We can try every possible combination. Since m and n can be at most 500 so it shouldn\\'t give us TLE\\n        \\n        # For example, if k = 5 then we can maybe take 1 number from nums1 and 4 from nums2\\n        # Or maybe take 2 from nums1 and 3 from nums2\\n        # And so on...\\n        \\n        # And then, we will merge the two lists that we will get to get the final output\\n        # And return the output that gives us the maximum number\\n        \\n        # So, first step is to go through every possible choice of taking numbers from nums1 and nums2\\n        for count in range(k + 1):\\n            \\n            # Suppose k = 5 but nums1 has only 2 elements\\n            # In that case, we can only pick either 0 or 1 or 2 elements from nums1\\n            # It doesn\\'t make sense when we say pick \"3\" elements from nums1 and \"2\" from nums2\\n            # Because nums1 doesn\\'t even have 3 elements in the first place\\n            # So, in such case, we won\\'t do anything and we will move on to next combination\\n            if count > len(nums1) or (k - count) > len(nums2): continue\\n            \\n            list1 = self.getGreatestSubsequence(nums1, count)\\n            list2 = self.getGreatestSubsequence(nums2, k - count)\\n            \\n            # After we get the two lists, we will now merge them\\n            mergedList = []\\n            \\n            # Pointers for the two lists\\n            i,j = 0,0\\n            \\n            # While Loop to compare by positions\\n            while i < len(list1) or j < len(list2):\\n\\n                # If indices go out of bounds\\n\\n                # If i is >= m, then pick \"j\" element in list2\\n                if i >= len(list1): \\n                    mergedList.append(list2[j])\\n                    j += 1\\n\\n                # If j is >= n, then pick \"i\" element in list1\\n                elif j >= len(list2):\\n                    mergedList.append(list1[i])\\n                    i += 1\\n                    \\n                    \\n                # If indices are not out of bounds, we can compare the elements\\n\\n                # If \"i\" element in nums1 is greater than \"j\" element in nums2\\n                # Then pick the i element of nums1\\n                elif list1[i] > list2[j]: \\n                    mergedList.append(list1[i])\\n                    i += 1\\n\\n                # If \"i\" element in nums1 is smaller than \"j\" element in nums2\\n                # Then pick the j element of nums2\\n                elif list1[i] < list2[j]: \\n                    mergedList.append(list2[j])\\n                    j += 1\\n\\n                # If both are equal, we use the helper method to choose \\n                else:\\n                    # If subsequence of nums1 starting at index \"i\"\\n                    # if lexicographically greater than subsequence of nums2 starting at \"j\"\\n                    # We pick the i element\\n                    if self.isGreater(list1, list2, i, j):\\n                        mergedList.append(list1[i])\\n                        i += 1\\n                        \\n                    # Otherwise, we pick the \"j\" element\\n                    else:\\n                        mergedList.append(list2[j])\\n                        j += 1\\n            \\n            \\n            # Finally, we get our merged list\\n            # Now we can compare it with previous merged list to see which one is the bigger lexicographically\\n            # Based on that we can update the output list\\n            if output < mergedList: output = mergedList\\n        return output\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    # Helper method to get the greatest subsequence out of a list of a given length\\n    def getGreatestSubsequence(self, nums, subsequenceLength):\\n        # Length of the list\\n        n = len(nums)\\n        \\n        # Stack to efficiently compare numbers\\n        stack = []\\n        \\n        # Loop over the list\\n        for i in range(n):\\n            \\n            # If current element is greater than element on top of stack\\n            # We can remove it\\n            # But only if we have enough elements to put in stack so that required subsequenceLength is matched\\n            # (n-i) gives us the remaining elements to traverse\\n            # (len(stack) - 1) gives us the length of stack if we pop one element\\n            # So, what we are saying is \"The elements in stack after we pop + elements left to traverse\" should be >= subsequenceLength\\n            # Only then we can pop\\n            while stack and stack[-1] < nums[i] and (n - i) + (len(stack) - 1) >= subsequenceLength: stack.pop()\\n                \\n            \\n            # Now we can put the index of current element in the stack (only if we don\\'t already have \\'subsequenceLength\\' elements in the stack)\\n            if len(stack) < subsequenceLength: stack.append(nums[i])\\n            \\n        # Return this stack\\n        return stack\\n            \\n    # Helper method to compare subarrays of two lists such that one starts at index i and the other at index j\\n    # We do this comparison when we have same value at the two pointers so we have to decide which one to choose\\n    def isGreater(self, nums1, nums2, i, j):\\n        \\n        # Length of first list\\n        m = len(nums1)\\n        \\n        # Length of second list\\n        n = len(nums2)\\n        \\n        # While Loop to compare by positions\\n        while i < m or j < n:\\n            \\n            # If indices go out of bounds\\n            \\n            # If i is >= m, then nums1 is not lexicographically greater than nums2\\n            if i >= m: return False\\n            \\n            # If j is >= n, then nums1 is lexicographically greater than nums2\\n            elif j >= n: return True\\n        \\n            # If indices are not out of bounds, we can compare the elements\\n            \\n            # If \"i\" element in nums1 is greater than \"j\" element in nums2\\n            # Then nums1 is lexicographically greater than nums2\\n            elif nums1[i] > nums2[j]: return True\\n            \\n            # If \"i\" element in nums1 is smaller than \"j\" element in nums2\\n            # Then nums1 is not lexicographically greater than nums2\\n            elif nums1[i] < nums2[j]: return False\\n            \\n            # If both are equal, move on to next comparison\\n            i += 1\\n            j += 1\\n            \\n        # If we didn\\'t return anything, then both subarrays are the same\\n        # So we can return either True or False since we can choose any of the two\\n        # Let\\'s return true\\n        return True\\n            \\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        \\n        # Final output to return\\n        output = []\\n        \\n        # If we had only one list then it would\\'ve been super simple \\n        # to get a lexicographically greatest number\\n        # But, in this problem, we have two numbers\\n        # And what we don\\'t exactly know is, how many numbers we should take from nums1 and how many from nums2\\n        \\n        \\n        # Since k <= m + n\\n        # We can try every possible combination. Since m and n can be at most 500 so it shouldn\\'t give us TLE\\n        \\n        # For example, if k = 5 then we can maybe take 1 number from nums1 and 4 from nums2\\n        # Or maybe take 2 from nums1 and 3 from nums2\\n        # And so on...\\n        \\n        # And then, we will merge the two lists that we will get to get the final output\\n        # And return the output that gives us the maximum number\\n        \\n        # So, first step is to go through every possible choice of taking numbers from nums1 and nums2\\n        for count in range(k + 1):\\n            \\n            # Suppose k = 5 but nums1 has only 2 elements\\n            # In that case, we can only pick either 0 or 1 or 2 elements from nums1\\n            # It doesn\\'t make sense when we say pick \"3\" elements from nums1 and \"2\" from nums2\\n            # Because nums1 doesn\\'t even have 3 elements in the first place\\n            # So, in such case, we won\\'t do anything and we will move on to next combination\\n            if count > len(nums1) or (k - count) > len(nums2): continue\\n            \\n            list1 = self.getGreatestSubsequence(nums1, count)\\n            list2 = self.getGreatestSubsequence(nums2, k - count)\\n            \\n            # After we get the two lists, we will now merge them\\n            mergedList = []\\n            \\n            # Pointers for the two lists\\n            i,j = 0,0\\n            \\n            # While Loop to compare by positions\\n            while i < len(list1) or j < len(list2):\\n\\n                # If indices go out of bounds\\n\\n                # If i is >= m, then pick \"j\" element in list2\\n                if i >= len(list1): \\n                    mergedList.append(list2[j])\\n                    j += 1\\n\\n                # If j is >= n, then pick \"i\" element in list1\\n                elif j >= len(list2):\\n                    mergedList.append(list1[i])\\n                    i += 1\\n                    \\n                    \\n                # If indices are not out of bounds, we can compare the elements\\n\\n                # If \"i\" element in nums1 is greater than \"j\" element in nums2\\n                # Then pick the i element of nums1\\n                elif list1[i] > list2[j]: \\n                    mergedList.append(list1[i])\\n                    i += 1\\n\\n                # If \"i\" element in nums1 is smaller than \"j\" element in nums2\\n                # Then pick the j element of nums2\\n                elif list1[i] < list2[j]: \\n                    mergedList.append(list2[j])\\n                    j += 1\\n\\n                # If both are equal, we use the helper method to choose \\n                else:\\n                    # If subsequence of nums1 starting at index \"i\"\\n                    # if lexicographically greater than subsequence of nums2 starting at \"j\"\\n                    # We pick the i element\\n                    if self.isGreater(list1, list2, i, j):\\n                        mergedList.append(list1[i])\\n                        i += 1\\n                        \\n                    # Otherwise, we pick the \"j\" element\\n                    else:\\n                        mergedList.append(list2[j])\\n                        j += 1\\n            \\n            \\n            # Finally, we get our merged list\\n            # Now we can compare it with previous merged list to see which one is the bigger lexicographically\\n            # Based on that we can update the output list\\n            if output < mergedList: output = mergedList\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792618,
                "title": "easy-to-understand-c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) {\\n        int m = nums1.Length;\\n        int n = nums2.Length;\\n        int[] result = new int[k];\\n        for (int i = Math.Max(0, k - n); i <= k && i <= m; i++)\\n        {\\n            int[] candidate = MergeArrays(GetMaxSubsequence(nums1, i), GetMaxSubsequence(nums2, k - i));\\n            if (IsGreater(candidate, 0, result, 0)) result = candidate;\\n        }\\n        return result;\\n    }\\n\\n    private int[] GetMaxSubsequence(int[] nums, int k)\\n    {\\n        int[] result = new int[k];\\n        int length = 0;\\n        \\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            while (length > 0 && nums[i] > result[length - 1] && nums.Length - i + length > k) length--;\\n            if (length < k) result[length++] = nums[i];\\n        }\\n        \\n        return result;\\n    }\\n\\n    private int[] MergeArrays(int[] nums1, int[] nums2)\\n    {\\n        int m = nums1.Length;\\n        int n = nums2.Length;\\n        int[] merged = new int[m + n];\\n        int i = 0, j = 0, idx = 0;\\n    \\n        while (i < m && j < n)\\n        {\\n            if (IsGreater(nums1, i, nums2, j)) merged[idx++] = nums1[i++];\\n            else merged[idx++] = nums2[j++]; \\n        }   \\n        while (i < m) merged[idx++] = nums1[i++];\\n        while (j < n) merged[idx++] = nums2[j++];\\n        \\n        return merged;\\n    }\\n\\n    private bool IsGreater(int[] nums1, int idx1, int[] nums2, int idx2)\\n    {\\n        int m = nums1.Length;\\n        int n = nums2.Length;\\n        \\n        while (idx1 < m && idx2 < n)\\n        {\\n            if (nums1[idx1] > nums2[idx2]) return true;\\n            else if (nums1[idx1] < nums2[idx2]) return false;\\n                   \\n            idx1++;\\n            idx2++;\\n        }\\n        \\n        return idx1 != m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) {\\n        int m = nums1.Length;\\n        int n = nums2.Length;\\n        int[] result = new int[k];\\n        for (int i = Math.Max(0, k - n); i <= k && i <= m; i++)\\n        {\\n            int[] candidate = MergeArrays(GetMaxSubsequence(nums1, i), GetMaxSubsequence(nums2, k - i));\\n            if (IsGreater(candidate, 0, result, 0)) result = candidate;\\n        }\\n        return result;\\n    }\\n\\n    private int[] GetMaxSubsequence(int[] nums, int k)\\n    {\\n        int[] result = new int[k];\\n        int length = 0;\\n        \\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            while (length > 0 && nums[i] > result[length - 1] && nums.Length - i + length > k) length--;\\n            if (length < k) result[length++] = nums[i];\\n        }\\n        \\n        return result;\\n    }\\n\\n    private int[] MergeArrays(int[] nums1, int[] nums2)\\n    {\\n        int m = nums1.Length;\\n        int n = nums2.Length;\\n        int[] merged = new int[m + n];\\n        int i = 0, j = 0, idx = 0;\\n    \\n        while (i < m && j < n)\\n        {\\n            if (IsGreater(nums1, i, nums2, j)) merged[idx++] = nums1[i++];\\n            else merged[idx++] = nums2[j++]; \\n        }   \\n        while (i < m) merged[idx++] = nums1[i++];\\n        while (j < n) merged[idx++] = nums2[j++];\\n        \\n        return merged;\\n    }\\n\\n    private bool IsGreater(int[] nums1, int idx1, int[] nums2, int idx2)\\n    {\\n        int m = nums1.Length;\\n        int n = nums2.Length;\\n        \\n        while (idx1 < m && idx2 < n)\\n        {\\n            if (nums1[idx1] > nums2[idx2]) return true;\\n            else if (nums1[idx1] < nums2[idx2]) return false;\\n                   \\n            idx1++;\\n            idx2++;\\n        }\\n        \\n        return idx1 != m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779111,
                "title": "greedy-algorithm-and-merge-operation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. the **everymax fuction** use the greedy algorithm to create the maximum number of length **n** from a given array.\\n\\n    it iterate through the array, maintain a stack to store the maximum number sofar. it campare each element with the top of the stack to decide whether to discard it or include it and also maintain the desired length of \"n\".\\n\\n**the greedy algorithm ensure the resulting number is lexicographically maximum** \\n\\n2. the **merge** function compre the first element of two arrays and append it to result until one of the array is exhuasted. this operation maintain the relative order of elements ensuring the resulting number is maximum possible.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def everymax(nums,n):\\n            stack=[]\\n            to_pop=len(nums)-n\\n            for num in nums:\\n                while to_pop and stack and num>stack[-1]:\\n                    stack.pop()\\n                    to_pop-=1\\n                stack.append(num)\\n            return stack[:n]\\n\\n        def merge(nums1,nums2):\\n            result=[]\\n            while nums1 and nums2:\\n                if nums1>nums2:\\n                    result.append(nums1[0])\\n                    nums1=nums1[1:]\\n                else:\\n                    result.append(nums2[0])\\n                    nums2=nums2[1:]\\n            result.extend(nums1)\\n            result.extend(nums2)\\n            return result\\n\\n        ans=[]\\n        for i in range(k+1):\\n            if i <=len(nums1) and (k-i)<=len(nums2):\\n                maxnums1=everymax(nums1,i)\\n                maxnums2=everymax(nums2,k-i)\\n                merged=merge(maxnums1,maxnums2)\\n                ans=max(ans,merged)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def everymax(nums,n):\\n            stack=[]\\n            to_pop=len(nums)-n\\n            for num in nums:\\n                while to_pop and stack and num>stack[-1]:\\n                    stack.pop()\\n                    to_pop-=1\\n                stack.append(num)\\n            return stack[:n]\\n\\n        def merge(nums1,nums2):\\n            result=[]\\n            while nums1 and nums2:\\n                if nums1>nums2:\\n                    result.append(nums1[0])\\n                    nums1=nums1[1:]\\n                else:\\n                    result.append(nums2[0])\\n                    nums2=nums2[1:]\\n            result.extend(nums1)\\n            result.extend(nums2)\\n            return result\\n\\n        ans=[]\\n        for i in range(k+1):\\n            if i <=len(nums1) and (k-i)<=len(nums2):\\n                maxnums1=everymax(nums1,i)\\n                maxnums2=everymax(nums2,k-i)\\n                merged=merge(maxnums1,maxnums2)\\n                ans=max(ans,merged)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773836,
                "title": "o-n-3-stack-c",
                "content": "# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> getNums(vector<int> &nums, int x){\\n        if (x == 0) {\\n            return {};\\n        }\\n        stack<int>s;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if (s.empty()) {\\n                s.push(nums[i]);\\n            } else {\\n                while(s.size() > 0 && s.top() < nums[i] && s.size()-1 + nums.size() - i >= x) {\\n                    s.pop();\\n                }\\n                s.push(nums[i]);\\n            }\\n        }\\n\\n        while(s.size() > x) {\\n            s.pop();\\n        }\\n\\n        vector<int> ans;\\n        while(!s.empty()) {\\n            ans.push_back(s.top());\\n            s.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\n\\n    bool isGreater(vector<int> &n1, vector<int> &n2, int i, int j) {\\n        while(i < n1.size() && j <n2.size()) {\\n            if (n1[i] > n2[j]){\\n                return true;\\n            }\\n            if (n1[i] < n2[j]) {\\n                return false;\\n            }\\n            i++;\\n            j++;\\n        }\\n        if (i < n1.size()) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<int> merge(vector<int> &n1, vector<int> &n2) {\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n        while(i < n1.size() && j < n2.size()) {\\n            if (isGreater(n1, n2, i, j)) {\\n                ans.push_back(n1[i]);\\n                i++;\\n            } else {\\n                ans.push_back(n2[j]);\\n                j++;\\n            }\\n        }\\n        while(i < n1.size()) {\\n            ans.push_back(n1[i]);\\n            i++;\\n        }\\n        while(j < n2.size()) {\\n            ans.push_back(n2[j]);\\n            j++;\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> getMaxArray(vector<int> &ans, vector<int> &mergedSub){\\n        if (ans.size() == 0) {\\n            return mergedSub;\\n        }\\n        for (int i = 0 ; i < mergedSub.size(); i++) {\\n            if (ans[i] > mergedSub[i]) {\\n                return ans;\\n            } else if (ans[i] < mergedSub[i]) {\\n                return mergedSub;\\n            }\\n        }\\n        return mergedSub;\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans;\\n        for (int i = 0 ; i <= k; i++) {\\n            int nums1Elements = i;\\n            int nums2Elements = k-i;\\n            if (nums2Elements < 0 || nums2Elements > nums2.size()) {\\n                continue;\\n            }\\n            if (nums1Elements < 0 || nums1Elements > nums1.size()) {\\n                continue;\\n            }\\n\\n            vector<int> nums1Sub = getNums(nums1, i);\\n            vector<int> nums2Sub = getNums(nums2, k-i);\\n\\n            vector<int> mergedSub = merge(nums1Sub, nums2Sub);\\n            ans = getMaxArray(ans, mergedSub);\\n        } \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> getNums(vector<int> &nums, int x){\\n        if (x == 0) {\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 3746717,
                "title": "java-solution-explained",
                "content": "# Intuition - \\nThe problem requires finding the maximum number that can be formed by selecting k elements from two input arrays, nums1 and nums2. The elements should maintain their relative order within each array. The solution involves dividing the problem into smaller subproblems, finding the maximum numbers that can be formed by selecting a certain number of elements from each array, and then merging those numbers to form the overall maximum number.\\n\\n# Approach - \\n1. Initialize the result array of size k to store the maximum number.\\n2. Iterate over the number of elements (i) to be selected from nums1, which ranges from 0 to the minimum of k and the length of nums1.\\n   - Calculate the corresponding number of elements (j) to be selected from nums2, which is equal to k - i.\\n   - Find the maximum subsequence of length i from nums1 using the `findMax` function.\\n   - Find the maximum subsequence of length j from nums2 using the `findMax` function.\\n   - Merge the two subsequences obtained from nums1 and nums2 using the `merge` function.\\n   - If the merged sequence is greater than the current result, update the result to the merged sequence.\\n3. Return the resulting maximum number.\\n\\n# Complexity Analysis - \\nLet n be the length of nums1 and m be the length of nums2.\\n- The overall **time complexity of the solution is O((n + m)^3)** since we have three nested loops: one for iterating over the number of elements to be selected from nums1, one for iterating over the elements of nums1 and nums2 in the `merge` function, and one for iterating over the elements of nums in the `findMax` function.\\n- The **space complexity is O(k)** since we are using a result array of size k to store the maximum number.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] result = new int[k];\\n        for (int i = Math.max(0, k - nums2.length); i <= Math.min(nums1.length, k); i++) {\\n            int j = k - i;\\n            int[] part1 = findMax(nums1, i);\\n            int[] part2 = findMax(nums2, j);\\n            int[] cand = merge(part1, part2);\\n            if (greater(cand, 0, result, 0)) {\\n                result = cand;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private boolean greater(int[] nums1, int start1, int[] nums2, int start2) {\\n        while (start1 < nums1.length && start2 < nums2.length && nums1[start1] == nums2[start2]) {\\n            start1++;\\n            start2++;\\n        }\\n        return start2 == nums2.length || (start1 < nums1.length && nums1[start1] > nums2[start2]);\\n    }\\n\\n    private int[] merge(int[] nums1, int[] nums2) {\\n        int[] result = new int[nums1.length + nums2.length];\\n        int i = 0, j = 0, k = 0;\\n        while (i < nums1.length && j < nums2.length) {\\n            if (greater(nums1, i, nums2, j)) {\\n                result[k++] = nums1[i++];\\n            } else {\\n                result[k++] = nums2[j++];\\n            }\\n        }\\n        while (i < nums1.length) {\\n            result[k++] = nums1[i++];\\n        }\\n        while (j < nums2.length) {\\n            result[k++] = nums2[j++];\\n        }\\n        return result;\\n    }\\n\\n    private int[] findMax(int[] nums, int k) {\\n        int[] result = new int[k];\\n        int j = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (j > 0 && result[j - 1] < nums[i] && j + nums.length - i > k) {\\n                j--;\\n            }\\n            if (j < k) {\\n                result[j++] = nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] result = new int[k];\\n        for (int i = Math.max(0, k - nums2.length); i <= Math.min(nums1.length, k); i++) {\\n            int j = k - i;\\n            int[] part1 = findMax(nums1, i);\\n            int[] part2 = findMax(nums2, j);\\n            int[] cand = merge(part1, part2);\\n            if (greater(cand, 0, result, 0)) {\\n                result = cand;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private boolean greater(int[] nums1, int start1, int[] nums2, int start2) {\\n        while (start1 < nums1.length && start2 < nums2.length && nums1[start1] == nums2[start2]) {\\n            start1++;\\n            start2++;\\n        }\\n        return start2 == nums2.length || (start1 < nums1.length && nums1[start1] > nums2[start2]);\\n    }\\n\\n    private int[] merge(int[] nums1, int[] nums2) {\\n        int[] result = new int[nums1.length + nums2.length];\\n        int i = 0, j = 0, k = 0;\\n        while (i < nums1.length && j < nums2.length) {\\n            if (greater(nums1, i, nums2, j)) {\\n                result[k++] = nums1[i++];\\n            } else {\\n                result[k++] = nums2[j++];\\n            }\\n        }\\n        while (i < nums1.length) {\\n            result[k++] = nums1[i++];\\n        }\\n        while (j < nums2.length) {\\n            result[k++] = nums2[j++];\\n        }\\n        return result;\\n    }\\n\\n    private int[] findMax(int[] nums, int k) {\\n        int[] result = new int[k];\\n        int j = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (j > 0 && result[j - 1] < nums[i] && j + nums.length - i > k) {\\n                j--;\\n            }\\n            if (j < k) {\\n                result[j++] = nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698678,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int m = nums1.length, n=nums2.length;\\n        int sol[] = new int [k];\\n\\n        for (int i= 0; i <= m ; i++){  // number of items taken form nums1 in the solution\\n            if (i > k || i+n < k) continue;\\n\\n            int [] nums1contibution = chooseK(nums1,i); \\n            int [] nums2contibution = chooseK(nums2,k-i);\\n\\n            boolean bestSol = false;\\n            int iter1=0 , iter2=0;\\n\\n            for (int j=0; j<k ; j++){\\n                boolean useNums1 = false; \\n                if (iter1 == i)  useNums1 = false; \\n                else {\\n                    if (iter2 == k-i) useNums1 = true; \\n                    else {\\n                        if (nums2contibution[iter2] > nums1contibution[iter1]) useNums1 = false; \\n                        else if (nums2contibution[iter2] < nums1contibution[iter1]) useNums1 = true; \\n                        else useNums1 = firstBigger (nums1contibution,iter1, nums2contibution,iter2);\\n                    }\\n                }\\n                int next = (useNums1) ? nums1contibution[iter1++] : nums2contibution[iter2++];\\n\\n                if (!bestSol && next < sol[j]) break; // better solution already exist\\n                if (next > sol[j]) bestSol = true; // this is the best solution so far - write it down to the end\\n                sol[j] = next; \\n            }\\n        }\\n        return sol;\\n    }\\n\\n    private boolean firstBigger(int[] nums1,int start1, int []nums2, int start2){\\n        int next1 = nums1[start1] , next2 = nums2[start2];\\n        while (next1 == next2){\\n            next1 = (++start1 == nums1.length) ? -1 : nums1[start1];\\n            next2 = (++start2 == nums2.length) ? -1 : nums2[start2];\\n            if (next1 == -1) return false;\\n        }\\n        return (next1>next2);\\n    }\\n\\n    private int[] chooseK(int[] nums, int k) { // choose best k lexicographic order from nums \\n        //could be optimaized a lot: given choosek(k) we can use it to calculate choosek(k-1) \\n        int [] sol = new int [k];\\n        int choosen = 0 , iter = 0; // left to choose = k - choosen\\n        while (choosen < k){\\n            int max = nums[iter], indexMax = iter;\\n            for (int i = iter; i + (k - choosen) <= nums.length; i++){\\n                if (max == 9) break;\\n                if (nums[i] > max){\\n                    max = nums[i];\\n                    indexMax = i;\\n                }\\n            }\\n            iter = indexMax +1; \\n            sol[choosen++] = max; \\n        }\\n        return sol;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int m = nums1.length, n=nums2.length;\\n        int sol[] = new int [k];\\n\\n        for (int i= 0; i <= m ; i++){  // number of items taken form nums1 in the solution\\n            if (i > k || i+n < k) continue;\\n\\n            int [] nums1contibution = chooseK(nums1,i); \\n            int [] nums2contibution = chooseK(nums2,k-i);\\n\\n            boolean bestSol = false;\\n            int iter1=0 , iter2=0;\\n\\n            for (int j=0; j<k ; j++){\\n                boolean useNums1 = false; \\n                if (iter1 == i)  useNums1 = false; \\n                else {\\n                    if (iter2 == k-i) useNums1 = true; \\n                    else {\\n                        if (nums2contibution[iter2] > nums1contibution[iter1]) useNums1 = false; \\n                        else if (nums2contibution[iter2] < nums1contibution[iter1]) useNums1 = true; \\n                        else useNums1 = firstBigger (nums1contibution,iter1, nums2contibution,iter2);\\n                    }\\n                }\\n                int next = (useNums1) ? nums1contibution[iter1++] : nums2contibution[iter2++];\\n\\n                if (!bestSol && next < sol[j]) break; // better solution already exist\\n                if (next > sol[j]) bestSol = true; // this is the best solution so far - write it down to the end\\n                sol[j] = next; \\n            }\\n        }\\n        return sol;\\n    }\\n\\n    private boolean firstBigger(int[] nums1,int start1, int []nums2, int start2){\\n        int next1 = nums1[start1] , next2 = nums2[start2];\\n        while (next1 == next2){\\n            next1 = (++start1 == nums1.length) ? -1 : nums1[start1];\\n            next2 = (++start2 == nums2.length) ? -1 : nums2[start2];\\n            if (next1 == -1) return false;\\n        }\\n        return (next1>next2);\\n    }\\n\\n    private int[] chooseK(int[] nums, int k) { // choose best k lexicographic order from nums \\n        //could be optimaized a lot: given choosek(k) we can use it to calculate choosek(k-1) \\n        int [] sol = new int [k];\\n        int choosen = 0 , iter = 0; // left to choose = k - choosen\\n        while (choosen < k){\\n            int max = nums[iter], indexMax = iter;\\n            for (int i = iter; i + (k - choosen) <= nums.length; i++){\\n                if (max == 9) break;\\n                if (nums[i] > max){\\n                    max = nums[i];\\n                    indexMax = i;\\n                }\\n            }\\n            iter = indexMax +1; \\n            sol[choosen++] = max; \\n        }\\n        return sol;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609231,
                "title": "simple-monotonic-stack-merge-vector-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMonotonic stack and merge sorted vector\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    For all i possible brute \\n    split k into i and k-i\\n    i-> the no of element from a \\n    k-i -> the no of element from b\\n    Use Monotonic stack to find the max subseq of req. length\\n    Merge the 2 sorted vectors\\n    Find max of all such vectors\\n\\n\\n# Complexity\\n- Time complexity $$O(nk + nk)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n        int n=a.size(), m=b.size();\\n        vector<int> ans(k,0);\\n        //For all i possible brute \\n        for(int i=max(0,k-m);i<=min(n,k);i++){\\n            //i-> the no of element from a \\n            //k-i -> the no of element from b\\n            vector<int> stk1,stk2;\\n            int rem1=n-i;\\n            int rem2=m-(k-i);\\n            //Use Monotonic stack to find the max subseq of req. length\\n            for(int i=0;i<n;i++){\\n                while(stk1.size() && rem1 && a[i]>stk1.back()) stk1.pop_back(), rem1--;\\n                stk1.push_back(a[i]);\\n            }\\n            while(rem1>0 && rem1--) stk1.pop_back();\\n\\n            for(int i=0;i<m;i++){\\n                while(stk2.size() && rem2 && b[i]>stk2.back()) stk2.pop_back(), rem2--;\\n                stk2.push_back(b[i]);\\n            }\\n            //Merge the 2 sorted vectors\\n            while(rem2>0 && rem2--) stk2.pop_back();\\n            vector<int> temp;\\n            int p1=0,p2=0;\\n            while(p1<i && p2<k-i){\\n                if(stk1[p1] == stk2[p2]){\\n                    int ti= p1;\\n                    int tj= p2;\\n                    while(ti<i && tj<k-i && stk1[ti]==stk2[tj]){\\n                        ti++;\\n                        tj++;\\n                    }\\n                    if(tj == k-i) temp.push_back(stk1[p1]), p1++;\\n                    else if(ti == i) temp.push_back(stk2[p2]), p2++;\\n                    else if(stk1[ti]>stk2[tj]) temp.push_back(stk1[p1]), p1++;\\n                    else temp.push_back(stk2[p2]), p2++;\\n                }\\n                else if(stk1[p1]>stk2[p2]){\\n                    temp.push_back(stk1[p1]);\\n                    p1++;\\n                }\\n                else{\\n                    temp.push_back(stk2[p2]);\\n                    p2++;\\n                }\\n            }\\n            while(p1<i) temp.push_back(stk1[p1]), p1++;\\n            while(p2<k-i) temp.push_back(stk2[p2]), p2++;\\n            //Find max of all such vectors\\n            ans=max(ans,temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n        int n=a.size(), m=b.size();\\n        vector<int> ans(k,0);\\n        //For all i possible brute \\n        for(int i=max(0,k-m);i<=min(n,k);i++){\\n            //i-> the no of element from a \\n            //k-i -> the no of element from b\\n            vector<int> stk1,stk2;\\n            int rem1=n-i;\\n            int rem2=m-(k-i);\\n            //Use Monotonic stack to find the max subseq of req. length\\n            for(int i=0;i<n;i++){\\n                while(stk1.size() && rem1 && a[i]>stk1.back()) stk1.pop_back(), rem1--;\\n                stk1.push_back(a[i]);\\n            }\\n            while(rem1>0 && rem1--) stk1.pop_back();\\n\\n            for(int i=0;i<m;i++){\\n                while(stk2.size() && rem2 && b[i]>stk2.back()) stk2.pop_back(), rem2--;\\n                stk2.push_back(b[i]);\\n            }\\n            //Merge the 2 sorted vectors\\n            while(rem2>0 && rem2--) stk2.pop_back();\\n            vector<int> temp;\\n            int p1=0,p2=0;\\n            while(p1<i && p2<k-i){\\n                if(stk1[p1] == stk2[p2]){\\n                    int ti= p1;\\n                    int tj= p2;\\n                    while(ti<i && tj<k-i && stk1[ti]==stk2[tj]){\\n                        ti++;\\n                        tj++;\\n                    }\\n                    if(tj == k-i) temp.push_back(stk1[p1]), p1++;\\n                    else if(ti == i) temp.push_back(stk2[p2]), p2++;\\n                    else if(stk1[ti]>stk2[tj]) temp.push_back(stk1[p1]), p1++;\\n                    else temp.push_back(stk2[p2]), p2++;\\n                }\\n                else if(stk1[p1]>stk2[p2]){\\n                    temp.push_back(stk1[p1]);\\n                    p1++;\\n                }\\n                else{\\n                    temp.push_back(stk2[p2]);\\n                    p2++;\\n                }\\n            }\\n            while(p1<i) temp.push_back(stk1[p1]), p1++;\\n            while(p2<k-i) temp.push_back(stk2[p2]), p2++;\\n            //Find max of all such vectors\\n            ans=max(ans,temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564988,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(k * n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def maxNumber(nums1: Array[Int], nums2: Array[Int], k: Int): Array[Int] = {\\n      val res = Array.ofDim[Int](k)\\n      for (i <- Math.max(0, k - nums2.length) to Math.min(k, nums1.length)) {\\n        val candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k)\\n        if (greater(candidate, 0, res, 0)) res.indices.foreach(j => res(j) = candidate(j))\\n      }\\n      res\\n    }\\n\\n    def merge(nums1: Array[Int], nums2: Array[Int], k: Int): Array[Int] = {\\n      val res = Array.ofDim[Int](k)\\n      var i = 0\\n      var j = 0\\n      for (r <- res.indices)\\n        res(r) = if (greater(nums1, i, nums2, j)) {\\n            i += 1\\n            nums1(i - 1)\\n          } else {\\n            j += 1\\n            nums2(j - 1)\\n          }\\n      res\\n    }\\n\\n    def greater(nums1: Array[Int], i: Int, nums2: Array[Int], j: Int): Boolean = {\\n      var ii = i\\n      var jj = j\\n      while (ii < nums1.length && jj < nums2.length && nums1(ii) == nums2(jj)) {\\n        ii += 1\\n        jj += 1\\n      }\\n      jj == nums2.length || (ii < nums1.length && nums1(ii) > nums2(jj))\\n    }\\n\\n    def maxArray(nums: Array[Int], k: Int): Array[Int] = {\\n      val ans = Array.ofDim[Int](k)\\n      var j = 0\\n      for (i <- nums.indices) {\\n        while (nums.length - i + j > k && j > 0 && ans(j - 1) < nums(i)) j -= 1\\n        if (j < k) {\\n          ans(j) = nums(i)\\n          j += 1\\n        }\\n      }\\n      ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def maxNumber(nums1: Array[Int], nums2: Array[Int], k: Int): Array[Int] = {\\n      val res = Array.ofDim[Int](k)\\n      for (i <- Math.max(0, k - nums2.length) to Math.min(k, nums1.length)) {\\n        val candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k)\\n        if (greater(candidate, 0, res, 0)) res.indices.foreach(j => res(j) = candidate(j))\\n      }\\n      res\\n    }\\n\\n    def merge(nums1: Array[Int], nums2: Array[Int], k: Int): Array[Int] = {\\n      val res = Array.ofDim[Int](k)\\n      var i = 0\\n      var j = 0\\n      for (r <- res.indices)\\n        res(r) = if (greater(nums1, i, nums2, j)) {\\n            i += 1\\n            nums1(i - 1)\\n          } else {\\n            j += 1\\n            nums2(j - 1)\\n          }\\n      res\\n    }\\n\\n    def greater(nums1: Array[Int], i: Int, nums2: Array[Int], j: Int): Boolean = {\\n      var ii = i\\n      var jj = j\\n      while (ii < nums1.length && jj < nums2.length && nums1(ii) == nums2(jj)) {\\n        ii += 1\\n        jj += 1\\n      }\\n      jj == nums2.length || (ii < nums1.length && nums1(ii) > nums2(jj))\\n    }\\n\\n    def maxArray(nums: Array[Int], k: Int): Array[Int] = {\\n      val ans = Array.ofDim[Int](k)\\n      var j = 0\\n      for (i <- nums.indices) {\\n        while (nums.length - i + j > k && j > 0 && ans(j - 1) < nums(i)) j -= 1\\n        if (j < k) {\\n          ans(j) = nums(i)\\n          j += 1\\n        }\\n      }\\n      ans\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3538339,
                "title": "fast-solution-using-slice-and-hashmap",
                "content": "# Intuition\\n\\n- `nums1.length + nums2.length - k` digits can be dropped.\\n- Taking largest digit first and drop all digits before it.\\n- Recursive solve when there is tie, dynamic programming can be of help.\\n\\n# Approach\\n\\n- If digits can be dropped,\\n  Get max digit in each array in first `drop + 1` digits.\\n    - if one array\\'s max digit is greater than other,\\n      take that digit, drop all previous before it.\\n    - if both are equal then check both option using recursion.\\n- Else add node from larger array to smaller one.\\n\\n# Code\\n```rust\\nimpl Solution {\\n    fn merge(mut nums1: &[i32], mut nums2: &[i32], merged: &mut Vec<i32>) {\\n        while !nums1.is_empty() || !nums2.is_empty() {\\n            // pop from bigger vector\\n            if nums1 > nums2 {\\n                merged.push(nums1[0]);\\n                nums1 = &nums1[1..];\\n            } else {\\n                merged.push(nums2[0]);\\n                nums2 = &nums2[1..];\\n            }\\n        }\\n    }\\n\\n    fn get_max_index(nums: &[i32]) -> Option<usize> {\\n        nums.iter()\\n            .enumerate()\\n            .min_by_key(|(idx, &value)| (-value, *idx))\\n            .map(|(idx, _)| idx)\\n    }\\n\\n    pub fn max_number_dp<\\'a>(\\n        mut nums1: &[i32],\\n        mut nums2: &[i32],\\n        mut k: usize,\\n        memory: &\\'a mut HashMap<(usize, usize, usize), Vec<i32>>,\\n    ) -> &\\'a std::vec::Vec<i32> {\\n        let key = (nums1.len(), nums2.len(), k);\\n        if memory.contains_key(&key) {\\n            return memory.get(&key).unwrap();\\n        } else {\\n            let mut ans = Vec::with_capacity(k);\\n            while k > 0 {\\n                // number of drop allowed\\n                let drop_allowed = nums1.len() + nums2.len() - k;\\n                if drop_allowed == 0 {\\n                    Self::merge(nums1, nums2, &mut ans);\\n                    break;\\n                } else {\\n                    let nums1_idx =\\n                        Self::get_max_index(&nums1[..(drop_allowed + 1).min(nums1.len())]);\\n                    let nums2_idx =\\n                        Self::get_max_index(&nums2[..(drop_allowed + 1).min(nums2.len())]);\\n                    match nums1_idx\\n                        .and_then(|x| nums1.get(x))\\n                        .cmp(&nums2_idx.and_then(|x| nums2.get(x)))\\n                    {\\n                        std::cmp::Ordering::Less => {\\n                            let idx = nums2_idx.unwrap();\\n                            ans.push(nums2[idx]);\\n                            nums2 = &nums2[idx + 1..];\\n                            k -= 1;\\n                        }\\n                        std::cmp::Ordering::Greater => {\\n                            let idx = nums1_idx.unwrap();\\n                            ans.push(nums1[idx]);\\n                            nums1 = &nums1[idx + 1..];\\n                            k -= 1;\\n                        }\\n                        std::cmp::Ordering::Equal => {\\n                            let nums2_ = &nums2[nums2_idx.unwrap() + 1..];\\n                            let nums1_ = &nums1[nums1_idx.unwrap() + 1..];\\n                            ans.push(nums1[nums1_idx.unwrap()]);\\n\\n                            let len = ans.len();\\n                            k -= 1;\\n                            ans.extend(Self::max_number_dp(nums1_, nums2, k, memory));\\n                            let nums = Self::max_number_dp(nums1, nums2_, k, memory);\\n                            if &ans[len..] < nums {\\n                                ans.truncate(len);\\n                                ans.extend(nums);\\n                            }\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            memory.entry(key).or_insert(ans)\\n        }\\n    }\\n\\n    pub fn max_number(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        let mut memory = HashMap::new();\\n        Self::max_number_dp(&nums1, &nums2, k as usize, &mut memory);\\n        memory\\n            .remove(&(nums1.len(), nums2.len(), k as usize))\\n            .unwrap()\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    fn merge(mut nums1: &[i32], mut nums2: &[i32], merged: &mut Vec<i32>) {\\n        while !nums1.is_empty() || !nums2.is_empty() {\\n            // pop from bigger vector\\n            if nums1 > nums2 {\\n                merged.push(nums1[0]);\\n                nums1 = &nums1[1..];\\n            } else {\\n                merged.push(nums2[0]);\\n                nums2 = &nums2[1..];\\n            }\\n        }\\n    }\\n\\n    fn get_max_index(nums: &[i32]) -> Option<usize> {\\n        nums.iter()\\n            .enumerate()\\n            .min_by_key(|(idx, &value)| (-value, *idx))\\n            .map(|(idx, _)| idx)\\n    }\\n\\n    pub fn max_number_dp<\\'a>(\\n        mut nums1: &[i32],\\n        mut nums2: &[i32],\\n        mut k: usize,\\n        memory: &\\'a mut HashMap<(usize, usize, usize), Vec<i32>>,\\n    ) -> &\\'a std::vec::Vec<i32> {\\n        let key = (nums1.len(), nums2.len(), k);\\n        if memory.contains_key(&key) {\\n            return memory.get(&key).unwrap();\\n        } else {\\n            let mut ans = Vec::with_capacity(k);\\n            while k > 0 {\\n                // number of drop allowed\\n                let drop_allowed = nums1.len() + nums2.len() - k;\\n                if drop_allowed == 0 {\\n                    Self::merge(nums1, nums2, &mut ans);\\n                    break;\\n                } else {\\n                    let nums1_idx =\\n                        Self::get_max_index(&nums1[..(drop_allowed + 1).min(nums1.len())]);\\n                    let nums2_idx =\\n                        Self::get_max_index(&nums2[..(drop_allowed + 1).min(nums2.len())]);\\n                    match nums1_idx\\n                        .and_then(|x| nums1.get(x))\\n                        .cmp(&nums2_idx.and_then(|x| nums2.get(x)))\\n                    {\\n                        std::cmp::Ordering::Less => {\\n                            let idx = nums2_idx.unwrap();\\n                            ans.push(nums2[idx]);\\n                            nums2 = &nums2[idx + 1..];\\n                            k -= 1;\\n                        }\\n                        std::cmp::Ordering::Greater => {\\n                            let idx = nums1_idx.unwrap();\\n                            ans.push(nums1[idx]);\\n                            nums1 = &nums1[idx + 1..];\\n                            k -= 1;\\n                        }\\n                        std::cmp::Ordering::Equal => {\\n                            let nums2_ = &nums2[nums2_idx.unwrap() + 1..];\\n                            let nums1_ = &nums1[nums1_idx.unwrap() + 1..];\\n                            ans.push(nums1[nums1_idx.unwrap()]);\\n\\n                            let len = ans.len();\\n                            k -= 1;\\n                            ans.extend(Self::max_number_dp(nums1_, nums2, k, memory));\\n                            let nums = Self::max_number_dp(nums1, nums2_, k, memory);\\n                            if &ans[len..] < nums {\\n                                ans.truncate(len);\\n                                ans.extend(nums);\\n                            }\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            memory.entry(key).or_insert(ans)\\n        }\\n    }\\n\\n    pub fn max_number(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        let mut memory = HashMap::new();\\n        Self::max_number_dp(&nums1, &nums2, k as usize, &mut memory);\\n        memory\\n            .remove(&(nums1.len(), nums2.len(), k as usize))\\n            .unwrap()\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3517799,
                "title": "java-7ms-beats-98-56",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(k*(m+n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(m+n)\\n<!-- Add your\\n-  space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n       int[] res = null;\\n        for (int i = 0; i <= k; i++) {\\n            if (i <= nums1.length && k - i <= nums2.length) {\\n                int[] max1 = getMaxSub(nums1, i);\\n                int[] max2 = getMaxSub(nums2, k - i);\\n                if (max1 == null || max2 == null) continue;\\n                int[] tmp = mergeMax(max1, max2);\\n                if (compareArr(tmp, res)) {\\n                    res = tmp;\\n                }\\n            }\\n        }\\n    return res;\\n}\\n\\n    private boolean compareArr(int[] tmp, int[] res) {\\n        if(res == null) return true;\\n        for (int i = 0; i < res.length; i++) {\\n            if (tmp[i] < res[i]) return false;\\n            if (tmp[i] > res[i]) return true;\\n        }\\n        return true;\\n    }\\n\\n    public int[] mergeMax(int[] max1, int[] max2) {\\n        int i = 0, j = 0, id = 0;\\n        int size1 = max1.length;\\n        int size2 = max2.length;\\n        int[] res = new int[size1 + size2];\\n        while (size1 > 0 && size2 > 0 && i < size1 && j < size2) {\\n            if (max1[i] > max2[j]) {\\n                res[id++] = max1[i++];\\n            } else if (max1[i] == (max2[j])) {\\n                if (i + 1 < size1 && j + 1 < size2) {\\n                    if (max1[i + 1] == max2[j + 1]) {\\n                        if (max1[i + 1] >= max1[i]) {\\n                            int m = i + 2, n = j + 2;\\n                            boolean goToMax1 = true;\\n                            boolean isTracking = false;\\n                            while (m < size1 && n < size2) {\\n                                if (max1[m] != max2[n]) {\\n                                    if (max1[m] > max2[n]) {\\n                                        isTracking = true;\\n                                    } else {\\n                                        isTracking = true;\\n                                        goToMax1 = false;\\n                                    }\\n                                    break;\\n                                }\\n                                m++;\\n                                n++;\\n                            }\\n                            if (isTracking) {\\n                                if (goToMax1) {\\n                                    res[id++] = max1[i++];\\n                                } else {\\n                                    res[id++] = max2[j++];\\n                                }\\n                            } else {\\n                                if (m >= size1 && n < size2) {\\n                                    if (max2[--n] > max1[i]) {\\n                                        res[id++] = max2[j++];\\n                                    } else if (max2[--n] == max1[i]) {\\n                                        res[id++] = max2[j++];\\n                                    } else {\\n                                        res[id++] = max1[i++];\\n                                    }\\n\\n                                } else if (m < size1) {\\n                                    if (max1[--m] > max2[j]) {\\n                                        res[id++] = max1[i++];\\n                                    } else if (max2[--n] == max1[i]) {\\n                                        res[id++] = max1[i++];\\n                                    } else {\\n                                        res[id++] = max2[j++];\\n                                    }\\n                                } else {\\n                                    res[id++] = max1[i++];\\n                                    res[id++] = max2[j++];\\n                                }\\n                            }\\n                        } else {\\n                            res[id++] = max1[i++];\\n                            res[id++] = max2[j++];\\n                        }\\n                    } else if (max1[i + 1] > max2[j] && max1[i + 1] > max2[j + 1]) {\\n                        res[id++] = max1[i++]; // [6, 8] vs [6, 7]\\n                    } else if (max2[j + 1] > max1[i] && max2[j + 1] > max1[i + 1]) {\\n                        res[id++] = max2[j++]; // [6, 7] vs [6, 8]\\n                    } else {\\n                        res[id++] = max1[i++];\\n                        res[id++] = max2[j++];\\n                    }\\n                } else if (i + 1 >= size1 && j + 1 >= size2) {\\n                    if (max1[i] > max2[j]) {\\n                        res[id++] = max1[i++];\\n                        res[id++] = max2[j++];\\n                    } else {\\n                        res[id++] = max2[j++];\\n                        res[id++] = max1[i++];\\n                    }\\n                } else if (i + 1 < size1) {\\n                    if (max1[i + 1] >= max2[j]) {\\n                        res[id++] = max1[i++];\\n                    } else {\\n                        res[id++] = max2[j++];\\n                    }\\n                } else {\\n                    if (max2[j + 1] >= max1[i]) {\\n                        // [1, 3] vs [1]\\n                        res[id++] = max2[j++];\\n                    } else {\\n                        res[id++] = max1[i++];\\n                    }\\n                }\\n            } else {\\n                res[id++] = max2[j++];\\n            }\\n        }\\n        if (size1 == 0 || i >= size1) {\\n            for (int k = j; k < size2; k++) {\\n                res[id++] = max2[k];\\n            }\\n        } else {\\n            for (int k = i; k < size1; k++) {\\n                res[id++] = max1[k];\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int[] getMaxSub(int[] nums, int k) {\\n        if (k == 0) return new int[]{};\\n        if (k > nums.length) return null;\\n        int[] res = new int[k];\\n        res[0] = nums[0];\\n        int last = nums.length - 1;\\n        int cnt = 1;\\n        // 5 6 4 2 3 6 k = 3\\n        // 5 6  and k = 1\\n        for (int i = 1; i <= last; i++) {\\n            while (cnt > 0 && res[cnt - 1] < nums[i] && last - i >= k - cnt) {\\n                cnt--;\\n            }\\n            if (cnt < k) {\\n                res[cnt] = nums[i];\\n                cnt++;\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n       int[] res = null;\\n        for (int i = 0; i <= k; i++) {\\n            if (i <= nums1.length && k - i <= nums2.length) {\\n                int[] max1 = getMaxSub(nums1, i);\\n                int[] max2 = getMaxSub(nums2, k - i);\\n                if (max1 == null || max2 == null) continue;\\n                int[] tmp = mergeMax(max1, max2);\\n                if (compareArr(tmp, res)) {\\n                    res = tmp;\\n                }\\n            }\\n        }\\n    return res;\\n}\\n\\n    private boolean compareArr(int[] tmp, int[] res) {\\n        if(res == null) return true;\\n        for (int i = 0; i < res.length; i++) {\\n            if (tmp[i] < res[i]) return false;\\n            if (tmp[i] > res[i]) return true;\\n        }\\n        return true;\\n    }\\n\\n    public int[] mergeMax(int[] max1, int[] max2) {\\n        int i = 0, j = 0, id = 0;\\n        int size1 = max1.length;\\n        int size2 = max2.length;\\n        int[] res = new int[size1 + size2];\\n        while (size1 > 0 && size2 > 0 && i < size1 && j < size2) {\\n            if (max1[i] > max2[j]) {\\n                res[id++] = max1[i++];\\n            } else if (max1[i] == (max2[j])) {\\n                if (i + 1 < size1 && j + 1 < size2) {\\n                    if (max1[i + 1] == max2[j + 1]) {\\n                        if (max1[i + 1] >= max1[i]) {\\n                            int m = i + 2, n = j + 2;\\n                            boolean goToMax1 = true;\\n                            boolean isTracking = false;\\n                            while (m < size1 && n < size2) {\\n                                if (max1[m] != max2[n]) {\\n                                    if (max1[m] > max2[n]) {\\n                                        isTracking = true;\\n                                    } else {\\n                                        isTracking = true;\\n                                        goToMax1 = false;\\n                                    }\\n                                    break;\\n                                }\\n                                m++;\\n                                n++;\\n                            }\\n                            if (isTracking) {\\n                                if (goToMax1) {\\n                                    res[id++] = max1[i++];\\n                                } else {\\n                                    res[id++] = max2[j++];\\n                                }\\n                            } else {\\n                                if (m >= size1 && n < size2) {\\n                                    if (max2[--n] > max1[i]) {\\n                                        res[id++] = max2[j++];\\n                                    } else if (max2[--n] == max1[i]) {\\n                                        res[id++] = max2[j++];\\n                                    } else {\\n                                        res[id++] = max1[i++];\\n                                    }\\n\\n                                } else if (m < size1) {\\n                                    if (max1[--m] > max2[j]) {\\n                                        res[id++] = max1[i++];\\n                                    } else if (max2[--n] == max1[i]) {\\n                                        res[id++] = max1[i++];\\n                                    } else {\\n                                        res[id++] = max2[j++];\\n                                    }\\n                                } else {\\n                                    res[id++] = max1[i++];\\n                                    res[id++] = max2[j++];\\n                                }\\n                            }\\n                        } else {\\n                            res[id++] = max1[i++];\\n                            res[id++] = max2[j++];\\n                        }\\n                    } else if (max1[i + 1] > max2[j] && max1[i + 1] > max2[j + 1]) {\\n                        res[id++] = max1[i++]; // [6, 8] vs [6, 7]\\n                    } else if (max2[j + 1] > max1[i] && max2[j + 1] > max1[i + 1]) {\\n                        res[id++] = max2[j++]; // [6, 7] vs [6, 8]\\n                    } else {\\n                        res[id++] = max1[i++];\\n                        res[id++] = max2[j++];\\n                    }\\n                } else if (i + 1 >= size1 && j + 1 >= size2) {\\n                    if (max1[i] > max2[j]) {\\n                        res[id++] = max1[i++];\\n                        res[id++] = max2[j++];\\n                    } else {\\n                        res[id++] = max2[j++];\\n                        res[id++] = max1[i++];\\n                    }\\n                } else if (i + 1 < size1) {\\n                    if (max1[i + 1] >= max2[j]) {\\n                        res[id++] = max1[i++];\\n                    } else {\\n                        res[id++] = max2[j++];\\n                    }\\n                } else {\\n                    if (max2[j + 1] >= max1[i]) {\\n                        // [1, 3] vs [1]\\n                        res[id++] = max2[j++];\\n                    } else {\\n                        res[id++] = max1[i++];\\n                    }\\n                }\\n            } else {\\n                res[id++] = max2[j++];\\n            }\\n        }\\n        if (size1 == 0 || i >= size1) {\\n            for (int k = j; k < size2; k++) {\\n                res[id++] = max2[k];\\n            }\\n        } else {\\n            for (int k = i; k < size1; k++) {\\n                res[id++] = max1[k];\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int[] getMaxSub(int[] nums, int k) {\\n        if (k == 0) return new int[]{};\\n        if (k > nums.length) return null;\\n        int[] res = new int[k];\\n        res[0] = nums[0];\\n        int last = nums.length - 1;\\n        int cnt = 1;\\n        // 5 6 4 2 3 6 k = 3\\n        // 5 6  and k = 1\\n        for (int i = 1; i <= last; i++) {\\n            while (cnt > 0 && res[cnt - 1] < nums[i] && last - i >= k - cnt) {\\n                cnt--;\\n            }\\n            if (cnt < k) {\\n                res[cnt] = nums[i];\\n                cnt++;\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425897,
                "title": "python-constructive-please-update-constraints",
                "content": "Leetcode , Please update constraints in Question.\\nTime Complexity - O(k*(m+n)^2)\\nSolve independantly for both arrays for all possible combinations for i and j such that i+j==k and 0<=i<=k and 0<=j<=k.\\nUse next greater or equal to array to check if subarray starting from next greater on right can complete our length.\\nThen use solve function to merge both arrays. Cant merge them lineraly coz both arrays are not sorted.So we need to check at every comparsion which of both subarray can give lexicographically max array and update pointer accordingly.\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        m,n=len(nums1),len(nums2)\\n        def nge(arr,par):\\n            x=m if par==1 else n\\n            right=[-1]*x\\n            stack,temp=[],nums1 if par==1 else nums2\\n            for i in range(x-1,-1,-1):\\n                while stack and temp[stack[-1]]<=temp[i]: stack.pop()\\n                if stack: right[i]=stack[-1]\\n                stack.append(i)\\n            return right\\n        right1,right2=nge(nums1,1),nge(nums2,2)\\n        def mmax1(x):\\n            res=[]\\n            for i in range(m):\\n                if x==0: break\\n                r1=right1[i]\\n                if r1==-1 or m-r1<x:\\n                    res.append(nums1[i])\\n                    x-=1\\n            return res\\n        def mmax2(x):\\n            res=[]\\n            for i in range(n):\\n                if x==0: break\\n                r2=right2[i]\\n                if r2==-1 or n-r2<x:\\n                    res.append(nums2[i])\\n                    x-=1\\n            return res\\n        def isgreater(gg1, gg2, i, j):\\n            while i < len(gg1) and j < len(gg2) and gg1[i] == gg2[j]:\\n                i += 1\\n                j += 1\\n            if(j == len(gg2)): return 1\\n            if (i < len(gg1) and gg1[i] > gg2[j]): return 1\\n            return 0\\n        def solve(gg1,gg2):\\n            l1,l2=len(gg1),len(gg2)\\n            i,j=0,0\\n            res=[]\\n            while i<l1 and j<l2:\\n                if isgreater(gg1, gg2, i, j):\\n                    res.append(gg1[i])\\n                    i+=1\\n                else:\\n                    res.append(gg2[j])\\n                    j+=1\\n            while i<l1:\\n                res.append(gg1[i])\\n                i+=1\\n            while j<l2:\\n                res.append(gg2[j])\\n                j+=1\\n            return res\\n        ans=[]\\n        for i in range(k+1):\\n            j=k-i\\n            if i<=m and j<=n:\\n                res=solve(mmax1(i),mmax2(j))\\n                if not ans or res>ans:\\n                    ans=res\\n        return ans\\n            \\n            \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        m,n=len(nums1),len(nums2)\\n        def nge(arr,par):\\n            x=m if par==1 else n\\n            right=[-1]*x\\n            stack,temp=[],nums1 if par==1 else nums2\\n            for i in range(x-1,-1,-1):\\n                while stack and temp[stack[-1]]<=temp[i]: stack.pop()\\n                if stack: right[i]=stack[-1]\\n                stack.append(i)\\n            return right\\n        right1,right2=nge(nums1,1),nge(nums2,2)\\n        def mmax1(x):\\n            res=[]\\n            for i in range(m):\\n                if x==0: break\\n                r1=right1[i]\\n                if r1==-1 or m-r1<x:\\n                    res.append(nums1[i])\\n                    x-=1\\n            return res\\n        def mmax2(x):\\n            res=[]\\n            for i in range(n):\\n                if x==0: break\\n                r2=right2[i]\\n                if r2==-1 or n-r2<x:\\n                    res.append(nums2[i])\\n                    x-=1\\n            return res\\n        def isgreater(gg1, gg2, i, j):\\n            while i < len(gg1) and j < len(gg2) and gg1[i] == gg2[j]:\\n                i += 1\\n                j += 1\\n            if(j == len(gg2)): return 1\\n            if (i < len(gg1) and gg1[i] > gg2[j]): return 1\\n            return 0\\n        def solve(gg1,gg2):\\n            l1,l2=len(gg1),len(gg2)\\n            i,j=0,0\\n            res=[]\\n            while i<l1 and j<l2:\\n                if isgreater(gg1, gg2, i, j):\\n                    res.append(gg1[i])\\n                    i+=1\\n                else:\\n                    res.append(gg2[j])\\n                    j+=1\\n            while i<l1:\\n                res.append(gg1[i])\\n                i+=1\\n            while j<l2:\\n                res.append(gg2[j])\\n                j+=1\\n            return res\\n        ans=[]\\n        for i in range(k+1):\\n            j=k-i\\n            if i<=m and j<=n:\\n                res=solve(mmax1(i),mmax2(j))\\n                if not ans or res>ans:\\n                    ans=res\\n        return ans\\n            \\n            \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396659,
                "title": "share-my-rust-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// pub struct Solution;\\n\\nimpl Solution {\\n    /* \\u4ECE\\u6570\\u7EC4\\u4E2D\\u9009\\u51FAk\\u4E2A\\u6570\\uFF0C\\u4F7F\\u4ED6\\u6700\\u5927\\u3002 */\\n    pub fn helper(nums: & Vec<i32>, k: usize) -> Vec<i32> {\\n        let mut stk: Vec<i32> = Vec::new();\\n        if k == 0 {\\n            return stk;\\n        }\\n        let mut size = k; /* \\u6808\\u5269\\u4F59\\u7684\\u5BB9\\u91CF */\\n        let mut left = nums.len(); /* \\u5269\\u4F59\\u7684\\u6570\\u5B57 */\\n        for v in nums {\\n            let v = *v;\\n            /* \\u5BB9\\u91CF\\u521A\\u597D\\u586B\\u6EE1\\u65F6\\uFF0Call in\\u3002 */\\n            if size == left || stk.is_empty() {\\n                stk.push(v);\\n                size -= 1;\\n                left -= 1;\\n                continue;\\n            }\\n            let mut top = *stk.last().unwrap();\\n            if top >= v && size == 0 {\\n                left -= 1;\\n                continue;\\n            }\\n            if top >= v && size > 0 {\\n                stk.push(v);\\n                size -= 1;\\n                left -= 1;\\n                continue;\\n            }\\n            /* \\u53EA\\u8981\\u8FD8\\u80FD\\u586B\\u6EE1\\uFF0C\\u5E76\\u4E14\\u6808\\u9876\\u7684\\u503C\\u6BD4\\u5F53\\u524D\\u503C\\u8981\\u5C0F\\uFF0C\\u5C31\\u4E00\\u76F4\\u51FA\\u6808\\u3002 */\\n            while size < left && !stk.is_empty() {\\n                top = *stk.last().unwrap();\\n                if top < v {\\n                    stk.pop();\\n                    size += 1;\\n                } else {\\n                    break;\\n                }\\n            }\\n            stk.push(v);\\n            size -= 1;\\n            left -= 1;\\n        }\\n        stk\\n    }\\n    /* \\u628A\\u4E24\\u4E2A\\u6570\\u7EC4\\u7EC4\\u5408\\u8D77\\u6765\\u627E\\u6700\\u5927\\u7684\\u503C */\\n    fn combine(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\\n        let mut i = 0;\\n        let mut k = 0;\\n        let mut res = Vec::new();\\n        while i < nums1.len() && k < nums2.len() {\\n            /* \\u8C01\\u5927\\u9009\\u8C01 */\\n            if nums1[i] < nums2[k] {\\n                res.push(nums2[k]);\\n                k += 1;\\n            } else if nums1[i] > nums2[k] {\\n                res.push(nums1[i]);\\n                i += 1;\\n            } else {\\n                /* \\u5982\\u679C\\u5019\\u9009\\u4EBA\\u4E00\\u6837\\u7684\\u8BDD\\uFF0C\\u5C31\\u6709\\u4E9B\\u96BE\\u5904\\u7406\\u4E86\\u3002\\n                 * \\u9700\\u8981\\u6328\\u4E2A\\u770B\\u540E\\u9762\\u7684\\u503C\\u8C01\\u5927\\uFF0C\\u9009\\u5927\\u7684\\u3002 */\\n                let ori_i = i;\\n                let ori_k = k;\\n                i += 1;\\n                k += 1;\\n                let mut use_i = false;\\n                while i < nums1.len() && k < nums2.len() {\\n                    if nums1[i] < nums2[k] {\\n                        use_i = false;\\n                        break;\\n                    } else if nums1[i] > nums2[k] {\\n                        use_i = true;\\n                        break;\\n                    }\\n                    i += 1;\\n                    k += 1;\\n                }\\n                /* \\u6BD4\\u5230\\u6700\\u540E\\u8FD8\\u662F\\u4E00\\u6837\\uFF0C\\u9009\\u540E\\u9762\\u8FD8\\u6709\\u6570\\u7684\\u3002 */\\n                if i == nums1.len() && k < nums2.len() {\\n                    use_i = false;\\n                } else if i < nums1.len() && k == nums2.len() {\\n                    use_i = true;\\n                }\\n                /* \\u8BB0\\u5F97\\u628A\\u5E8F\\u53F7\\u6062\\u590D\\u56DE\\u6765\\u3002 */\\n                if use_i {\\n                    res.push(nums1[ori_i]);\\n                    i = ori_i + 1;\\n                    k = ori_k;\\n                } else {\\n                    res.push(nums2[ori_k]);\\n                    i = ori_i;\\n                    k = ori_k + 1;\\n                }\\n            }\\n        }\\n        while i < nums1.len() {\\n            res.push(nums1[i]);\\n            i += 1;\\n        }\\n        while k < nums2.len() {\\n            res.push(nums2[k]);\\n            k += 1;\\n        }\\n        res\\n    }\\n    /* \\u6BD4\\u8F83\\u4E24\\u4E2A\\u6570\\u7EC4\\u54EA\\u4E2A\\u5927 */\\n    fn nums1_larger(nums1: & Vec<i32>, nums2: & Vec<i32>) -> bool {\\n        let length = nums1.len();\\n        for i in 0..length {\\n            if nums1[i] > nums2[i] {\\n                return true;\\n            } else if nums1[i] < nums2[i] {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    pub fn max_number(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        let large: Vec<i32>;\\n        let small: Vec<i32>;\\n        if nums1.len() > nums2.len() {\\n            large = nums1;\\n            small = nums2;\\n        } else {\\n            large = nums2;\\n            small = nums1;\\n        }\\n        let start = if k as usize > large.len() {\\n            k as usize - large.len()\\n        } else {\\n            0\\n        };\\n        let stop = std::cmp::min(k as usize + 1, small.len() + 1);\\n        let mut res = vec![0; k as usize];\\n        for i in start..stop {\\n            let v1 = Solution::helper(&small, i);\\n            let v2 = Solution::helper(&large, k as usize - i);\\n            let cur = Solution::combine(v1, v2);\\n            if Solution::nums1_larger(&cur, &res) {\\n                res = cur;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// pub struct Solution;\\n\\nimpl Solution {\\n    /* \\u4ECE\\u6570\\u7EC4\\u4E2D\\u9009\\u51FAk\\u4E2A\\u6570\\uFF0C\\u4F7F\\u4ED6\\u6700\\u5927\\u3002 */\\n    pub fn helper(nums: & Vec<i32>, k: usize) -> Vec<i32> {\\n        let mut stk: Vec<i32> = Vec::new();\\n        if k == 0 {\\n            return stk;\\n        }\\n        let mut size = k; /* \\u6808\\u5269\\u4F59\\u7684\\u5BB9\\u91CF */\\n        let mut left = nums.len(); /* \\u5269\\u4F59\\u7684\\u6570\\u5B57 */\\n        for v in nums {\\n            let v = *v;\\n            /* \\u5BB9\\u91CF\\u521A\\u597D\\u586B\\u6EE1\\u65F6\\uFF0Call in\\u3002 */\\n            if size == left || stk.is_empty() {\\n                stk.push(v);\\n                size -= 1;\\n                left -= 1;\\n                continue;\\n            }\\n            let mut top = *stk.last().unwrap();\\n            if top >= v && size == 0 {\\n                left -= 1;\\n                continue;\\n            }\\n            if top >= v && size > 0 {\\n                stk.push(v);\\n                size -= 1;\\n                left -= 1;\\n                continue;\\n            }\\n            /* \\u53EA\\u8981\\u8FD8\\u80FD\\u586B\\u6EE1\\uFF0C\\u5E76\\u4E14\\u6808\\u9876\\u7684\\u503C\\u6BD4\\u5F53\\u524D\\u503C\\u8981\\u5C0F\\uFF0C\\u5C31\\u4E00\\u76F4\\u51FA\\u6808\\u3002 */\\n            while size < left && !stk.is_empty() {\\n                top = *stk.last().unwrap();\\n                if top < v {\\n                    stk.pop();\\n                    size += 1;\\n                } else {\\n                    break;\\n                }\\n            }\\n            stk.push(v);\\n            size -= 1;\\n            left -= 1;\\n        }\\n        stk\\n    }\\n    /* \\u628A\\u4E24\\u4E2A\\u6570\\u7EC4\\u7EC4\\u5408\\u8D77\\u6765\\u627E\\u6700\\u5927\\u7684\\u503C */\\n    fn combine(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\\n        let mut i = 0;\\n        let mut k = 0;\\n        let mut res = Vec::new();\\n        while i < nums1.len() && k < nums2.len() {\\n            /* \\u8C01\\u5927\\u9009\\u8C01 */\\n            if nums1[i] < nums2[k] {\\n                res.push(nums2[k]);\\n                k += 1;\\n            } else if nums1[i] > nums2[k] {\\n                res.push(nums1[i]);\\n                i += 1;\\n            } else {\\n                /* \\u5982\\u679C\\u5019\\u9009\\u4EBA\\u4E00\\u6837\\u7684\\u8BDD\\uFF0C\\u5C31\\u6709\\u4E9B\\u96BE\\u5904\\u7406\\u4E86\\u3002\\n                 * \\u9700\\u8981\\u6328\\u4E2A\\u770B\\u540E\\u9762\\u7684\\u503C\\u8C01\\u5927\\uFF0C\\u9009\\u5927\\u7684\\u3002 */\\n                let ori_i = i;\\n                let ori_k = k;\\n                i += 1;\\n                k += 1;\\n                let mut use_i = false;\\n                while i < nums1.len() && k < nums2.len() {\\n                    if nums1[i] < nums2[k] {\\n                        use_i = false;\\n                        break;\\n                    } else if nums1[i] > nums2[k] {\\n                        use_i = true;\\n                        break;\\n                    }\\n                    i += 1;\\n                    k += 1;\\n                }\\n                /* \\u6BD4\\u5230\\u6700\\u540E\\u8FD8\\u662F\\u4E00\\u6837\\uFF0C\\u9009\\u540E\\u9762\\u8FD8\\u6709\\u6570\\u7684\\u3002 */\\n                if i == nums1.len() && k < nums2.len() {\\n                    use_i = false;\\n                } else if i < nums1.len() && k == nums2.len() {\\n                    use_i = true;\\n                }\\n                /* \\u8BB0\\u5F97\\u628A\\u5E8F\\u53F7\\u6062\\u590D\\u56DE\\u6765\\u3002 */\\n                if use_i {\\n                    res.push(nums1[ori_i]);\\n                    i = ori_i + 1;\\n                    k = ori_k;\\n                } else {\\n                    res.push(nums2[ori_k]);\\n                    i = ori_i;\\n                    k = ori_k + 1;\\n                }\\n            }\\n        }\\n        while i < nums1.len() {\\n            res.push(nums1[i]);\\n            i += 1;\\n        }\\n        while k < nums2.len() {\\n            res.push(nums2[k]);\\n            k += 1;\\n        }\\n        res\\n    }\\n    /* \\u6BD4\\u8F83\\u4E24\\u4E2A\\u6570\\u7EC4\\u54EA\\u4E2A\\u5927 */\\n    fn nums1_larger(nums1: & Vec<i32>, nums2: & Vec<i32>) -> bool {\\n        let length = nums1.len();\\n        for i in 0..length {\\n            if nums1[i] > nums2[i] {\\n                return true;\\n            } else if nums1[i] < nums2[i] {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    pub fn max_number(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        let large: Vec<i32>;\\n        let small: Vec<i32>;\\n        if nums1.len() > nums2.len() {\\n            large = nums1;\\n            small = nums2;\\n        } else {\\n            large = nums2;\\n            small = nums1;\\n        }\\n        let start = if k as usize > large.len() {\\n            k as usize - large.len()\\n        } else {\\n            0\\n        };\\n        let stop = std::cmp::min(k as usize + 1, small.len() + 1);\\n        let mut res = vec![0; k as usize];\\n        for i in start..stop {\\n            let v1 = Solution::helper(&small, i);\\n            let v2 = Solution::helper(&large, k as usize - i);\\n            let cur = Solution::combine(v1, v2);\\n            if Solution::nums1_larger(&cur, &res) {\\n                res = cur;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3323553,
                "title": "javascript-321-create-maximum-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMain function is more difficult to understand\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar maxNumber = function (a, b, k) {\\n    let m = a.length,\\n        n = b.length,\\n        ss = Math.max(0, k - n),\\n        ee = Math.min(k, m),\\n        maxSubsequence = new Array(k).fill(0);\\n    for (let i = ss; i <= ee; i++) {\\n        let ss1 = new MaxSubsequence(a, i);\\n        let ss2 = new MaxSubsequence(b, k - i);\\n        let curMaxSubsequence = merge(ss1, ss2);\\n        if (compare(curMaxSubsequence, 0, maxSubsequence, 0) > 0) {\\n            maxSubsequence.splice(0, k, ...curMaxSubsequence);\\n        }\\n    }\\n    return maxSubsequence;\\n};\\n\\nvar MaxSubsequence = function (a, mustTakeOptions) {\\n    let n = a.length;\\n\\n    let canThrowAwayOptions = n - mustTakeOptions;\\n    let st = [];\\n    let top = -1;\\n    for (let e of a) {\\n        if (\\n            top + 1 < mustTakeOptions || //\\n            (canThrowAwayOptions && st[top] < e)\\n        ) {\\n            while (canThrowAwayOptions && st[top] < e) {\\n                top--;\\n                canThrowAwayOptions--;\\n            }\\n            top++;\\n            st[top] = e;\\n        } else {\\n            canThrowAwayOptions--;\\n        }\\n    }\\n    return st;\\n};\\n\\nvar merge = (a, b) => {\\n    let m = a.length;\\n    let n = b.length;\\n    let o = m + n;\\n\\n    let c = new Array(o);\\n    let i = 0;\\n    let j = 0;\\n    for (let k = 0; k < o; k++) {\\n        if (compare(a, i, b, j) > 0) {\\n            c[k] = a[i];\\n            i++;\\n        } else {\\n            c[k] = b[j];\\n            j++;\\n        }\\n    }\\n    return c;\\n};\\n\\nvar compare = (a, i, b, j) => {\\n    let m = a.length;\\n    let n = b.length;\\n    while (i < m && j < n) {\\n        if (a[i] !== b[j]) {\\n            return a[i] - b[j];\\n        }\\n        i++;\\n        j++;\\n    }\\n    return m - i - (n - j);\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxNumber = function (a, b, k) {\\n    let m = a.length,\\n        n = b.length,\\n        ss = Math.max(0, k - n),\\n        ee = Math.min(k, m),\\n        maxSubsequence = new Array(k).fill(0);\\n    for (let i = ss; i <= ee; i++) {\\n        let ss1 = new MaxSubsequence(a, i);\\n        let ss2 = new MaxSubsequence(b, k - i);\\n        let curMaxSubsequence = merge(ss1, ss2);\\n        if (compare(curMaxSubsequence, 0, maxSubsequence, 0) > 0) {\\n            maxSubsequence.splice(0, k, ...curMaxSubsequence);\\n        }\\n    }\\n    return maxSubsequence;\\n};\\n\\nvar MaxSubsequence = function (a, mustTakeOptions) {\\n    let n = a.length;\\n\\n    let canThrowAwayOptions = n - mustTakeOptions;\\n    let st = [];\\n    let top = -1;\\n    for (let e of a) {\\n        if (\\n            top + 1 < mustTakeOptions || //\\n            (canThrowAwayOptions && st[top] < e)\\n        ) {\\n            while (canThrowAwayOptions && st[top] < e) {\\n                top--;\\n                canThrowAwayOptions--;\\n            }\\n            top++;\\n            st[top] = e;\\n        } else {\\n            canThrowAwayOptions--;\\n        }\\n    }\\n    return st;\\n};\\n\\nvar merge = (a, b) => {\\n    let m = a.length;\\n    let n = b.length;\\n    let o = m + n;\\n\\n    let c = new Array(o);\\n    let i = 0;\\n    let j = 0;\\n    for (let k = 0; k < o; k++) {\\n        if (compare(a, i, b, j) > 0) {\\n            c[k] = a[i];\\n            i++;\\n        } else {\\n            c[k] = b[j];\\n            j++;\\n        }\\n    }\\n    return c;\\n};\\n\\nvar compare = (a, i, b, j) => {\\n    let m = a.length;\\n    let n = b.length;\\n    while (i < m && j < n) {\\n        if (a[i] !== b[j]) {\\n            return a[i] - b[j];\\n        }\\n        i++;\\n        j++;\\n    }\\n    return m - i - (n - j);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3283742,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nchecking every possible subarray and comparing with previously calculated max subarray\\n if it is greater than previous we update it,other wise we just check other possible subarrays\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        return this.sol(nums1,nums2,k);\\n    }\\n    public int[] sol(int[] nums1,int[] nums2,int k) {\\n        int start = Math.max(k - nums2.length,0);\\n        int end = Math.min(nums1.length,k);\\n        int[] nums = new int[k];\\n        for(int i = start;i <= end;i++) {\\n            int[] first = new int[i];\\n            int[] second = new int[k - i];\\n            int[] result = new int[k];\\n            first = this.max(nums1,i);\\n            second = this.max(nums2,k - i);\\n            int start1 = 0,start2  =0,counter =0;\\n            int i1 = 0,j1 = 0;\\n            while(i1  < first.length && j1 < second.length) {\\n                if(first[i1] == second[j1]) {\\n                    int temp1 = i1;\\n                    int temp2 = j1;\\n                    while(temp1 < first.length && temp2 < second.length && first[temp1] == second[temp2]) {\\n                        temp1++;\\n                        temp2++;\\n                    }\\n                    if(temp1 == first.length) {\\n                        result[counter++] = second[j1++]; \\n                    }\\n                    else if(temp2 == second.length) {\\n                        result[counter++] = first[i1++];\\n                    }\\n                    else {\\n                        if(first[temp1] > second[temp2]) {\\n                            result[counter++] = first[i1++];\\n                        }\\n                        else {\\n                            result[counter++] = second[j1++];\\n                        }\\n                    }\\n                }\\n                else if(first[i1] > second[j1]) {\\n                    result[counter++] = first[i1++];\\n                }\\n                else {\\n                    result[counter++] = second[j1++];\\n                }\\n            }\\n            while(i1 < first.length) {\\n                result[counter++] = first[i1++];\\n            }\\n            while(j1 < second.length) {\\n                result[counter++] = second[j1++];\\n            }\\n            boolean visited = false;\\n            start1 = 0;\\n            start2 = 0;\\n            while(start1 < result.length || start2 < nums.length) {\\n                if(result[start1] > nums[start2]) {\\n                    visited = true;\\n                    break;\\n                }\\n                else if(nums[start2] > result[start1]) {\\n                    break;\\n                }\\n                else {\\n                    start1++;\\n                    start2++;\\n                    if(start1 == result.length) {\\n                        visited = true;\\n                    }\\n                }\\n            }\\n            if(visited) {\\n                nums  = result;\\n            }\\n\\n        }\\n        return nums;\\n    }\\n    \\n    public int[] max(int[] nums,int k) {\\n        int[] res = new int[k];\\n        int len =0;\\n        for(int i =0;i < nums.length;i++) {\\n            while( len > 0 && res[len - 1] < nums[i] && k - len < nums.length - i) {\\n                len--;\\n            }\\n            if(len < k) {\\n                res[len++] = nums[i];\\n            }\\n        }\\n        return  res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        return this.sol(nums1,nums2,k);\\n    }\\n    public int[] sol(int[] nums1,int[] nums2,int k) {\\n        int start = Math.max(k - nums2.length,0);\\n        int end = Math.min(nums1.length,k);\\n        int[] nums = new int[k];\\n        for(int i = start;i <= end;i++) {\\n            int[] first = new int[i];\\n            int[] second = new int[k - i];\\n            int[] result = new int[k];\\n            first = this.max(nums1,i);\\n            second = this.max(nums2,k - i);\\n            int start1 = 0,start2  =0,counter =0;\\n            int i1 = 0,j1 = 0;\\n            while(i1  < first.length && j1 < second.length) {\\n                if(first[i1] == second[j1]) {\\n                    int temp1 = i1;\\n                    int temp2 = j1;\\n                    while(temp1 < first.length && temp2 < second.length && first[temp1] == second[temp2]) {\\n                        temp1++;\\n                        temp2++;\\n                    }\\n                    if(temp1 == first.length) {\\n                        result[counter++] = second[j1++]; \\n                    }\\n                    else if(temp2 == second.length) {\\n                        result[counter++] = first[i1++];\\n                    }\\n                    else {\\n                        if(first[temp1] > second[temp2]) {\\n                            result[counter++] = first[i1++];\\n                        }\\n                        else {\\n                            result[counter++] = second[j1++];\\n                        }\\n                    }\\n                }\\n                else if(first[i1] > second[j1]) {\\n                    result[counter++] = first[i1++];\\n                }\\n                else {\\n                    result[counter++] = second[j1++];\\n                }\\n            }\\n            while(i1 < first.length) {\\n                result[counter++] = first[i1++];\\n            }\\n            while(j1 < second.length) {\\n                result[counter++] = second[j1++];\\n            }\\n            boolean visited = false;\\n            start1 = 0;\\n            start2 = 0;\\n            while(start1 < result.length || start2 < nums.length) {\\n                if(result[start1] > nums[start2]) {\\n                    visited = true;\\n                    break;\\n                }\\n                else if(nums[start2] > result[start1]) {\\n                    break;\\n                }\\n                else {\\n                    start1++;\\n                    start2++;\\n                    if(start1 == result.length) {\\n                        visited = true;\\n                    }\\n                }\\n            }\\n            if(visited) {\\n                nums  = result;\\n            }\\n\\n        }\\n        return nums;\\n    }\\n    \\n    public int[] max(int[] nums,int k) {\\n        int[] res = new int[k];\\n        int len =0;\\n        for(int i =0;i < nums.length;i++) {\\n            while( len > 0 && res[len - 1] < nums[i] && k - len < nums.length - i) {\\n                len--;\\n            }\\n            if(len < k) {\\n                res[len++] = nums[i];\\n            }\\n        }\\n        return  res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239435,
                "title": "rust-short-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_number(mut nums1: Vec<i32>, mut nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        fn prepare(nums: &mut Vec<i32>, k: usize) -> Vec<i32> {\\n            let mut drop = nums.len() - k;\\n            let mut stack = vec![];\\n            for n in nums.iter() {\\n                while !stack.is_empty() && drop > 0 && *stack.last().unwrap() < *n {\\n                    stack.pop();\\n                    drop -= 1;\\n                }\\n                stack.push(*n);\\n            }\\n            stack[0..k].iter().copied().take(k).collect()\\n        }\\n\\n        fn merge(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\\n            use std::collections::VecDeque;\\n            let mut a = VecDeque::from(a);\\n            let mut b = VecDeque::from(b);\\n            let mut merged = vec![];\\n            while a.len() + b.len() > 0 {\\n                let n = if a > b { &mut a } else { &mut b };\\n                merged.push(n.pop_front().unwrap());\\n            }\\n            merged\\n        }\\n\\n        let k = k as usize;\\n        let mut ans = vec![];\\n        let mut k1 = (k as i32 - nums2.len() as i32).max(0) as usize;\\n        while k1 <= k.min(nums1.len()) {\\n            let p1 = prepare(&mut nums1, k1);\\n            let p2 = prepare(&mut nums2, k - k1);\\n            let merged = merge(p1, p2);\\n            ans = ans.max(merged);\\n            k1 += 1;\\n        }\\n        ans        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_number(mut nums1: Vec<i32>, mut nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        fn prepare(nums: &mut Vec<i32>, k: usize) -> Vec<i32> {\\n            let mut drop = nums.len() - k;\\n            let mut stack = vec![];\\n            for n in nums.iter() {\\n                while !stack.is_empty() && drop > 0 && *stack.last().unwrap() < *n {\\n                    stack.pop();\\n                    drop -= 1;\\n                }\\n                stack.push(*n);\\n            }\\n            stack[0..k].iter().copied().take(k).collect()\\n        }\\n\\n        fn merge(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\\n            use std::collections::VecDeque;\\n            let mut a = VecDeque::from(a);\\n            let mut b = VecDeque::from(b);\\n            let mut merged = vec![];\\n            while a.len() + b.len() > 0 {\\n                let n = if a > b { &mut a } else { &mut b };\\n                merged.push(n.pop_front().unwrap());\\n            }\\n            merged\\n        }\\n\\n        let k = k as usize;\\n        let mut ans = vec![];\\n        let mut k1 = (k as i32 - nums2.len() as i32).max(0) as usize;\\n        while k1 <= k.min(nums1.len()) {\\n            let p1 = prepare(&mut nums1, k1);\\n            let p2 = prepare(&mut nums2, k - k1);\\n            let merged = merge(p1, p2);\\n            ans = ans.max(merged);\\n            k1 += 1;\\n        }\\n        ans        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3184102,
                "title": "collection-of-3-subproblems",
                "content": "# Easy C++ Solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxArray(vector<int>&nums,int k){\\n        int n=nums.size();\\n        stack<int>seen;\\n        for(int i=0;i<n;i++){\\n            int right=n-i-1;\\n            while(not seen.empty() and seen.top()<nums[i] and right+seen.size()>=k)seen.pop();\\n            if(seen.size()<k)seen.push(nums[i]);\\n        }\\n        vector<int>res(k,0);\\n        for(int i=res.size()-1;i>=0;i--){\\n            res[i]=seen.top();\\n            seen.pop();\\n        }\\n        return res;\\n    }\\n    bool greater(vector<int>&arr1,int i,vector<int>&arr2,int j){\\n        for(;i<arr1.size() and j<arr2.size();i++,j++){\\n            if(arr1[i]==arr2[j])continue;\\n            return arr1[i]>arr2[j];\\n        }\\n        return i!=arr1.size();\\n    }\\n    vector<int> merge(vector<int>&arr1,vector<int>&arr2){\\n        vector<int>res(arr1.size()+arr2.size());\\n        for(int ind=0,i=0,j=0;ind<res.size();ind++){\\n            if(greater(arr1,i,arr2,j)){\\n                res[ind]=arr1[i];\\n                i++;\\n            }else{\\n                res[ind]=arr2[j];\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m=nums1.size(),n=nums2.size();\\n        vector<int>ans;\\n        for(int len1=max(0,k-n);len1<=min(m,k);len1++){\\n            int len2 = k-len1;\\n            vector<int> arr1 = maxArray(nums1,len1);\\n            vector<int> arr2 = maxArray(nums2,len2);\\n            vector<int> temp_res = merge(arr1,arr2);\\n            if(greater(temp_res,0,ans,0)){\\n                ans.resize(temp_res.size());\\n                for(int i=0;i<temp_res.size();i++){\\n                    ans[i]=temp_res[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxArray(vector<int>&nums,int k){\\n        int n=nums.size();\\n        stack<int>seen;\\n        for(int i=0;i<n;i++){\\n            int right=n-i-1;\\n            while(not seen.empty() and seen.top()<nums[i] and right+seen.size()>=k)seen.pop();\\n            if(seen.size()<k)seen.push(nums[i]);\\n        }\\n        vector<int>res(k,0);\\n        for(int i=res.size()-1;i>=0;i--){\\n            res[i]=seen.top();\\n            seen.pop();\\n        }\\n        return res;\\n    }\\n    bool greater(vector<int>&arr1,int i,vector<int>&arr2,int j){\\n        for(;i<arr1.size() and j<arr2.size();i++,j++){\\n            if(arr1[i]==arr2[j])continue;\\n            return arr1[i]>arr2[j];\\n        }\\n        return i!=arr1.size();\\n    }\\n    vector<int> merge(vector<int>&arr1,vector<int>&arr2){\\n        vector<int>res(arr1.size()+arr2.size());\\n        for(int ind=0,i=0,j=0;ind<res.size();ind++){\\n            if(greater(arr1,i,arr2,j)){\\n                res[ind]=arr1[i];\\n                i++;\\n            }else{\\n                res[ind]=arr2[j];\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m=nums1.size(),n=nums2.size();\\n        vector<int>ans;\\n        for(int len1=max(0,k-n);len1<=min(m,k);len1++){\\n            int len2 = k-len1;\\n            vector<int> arr1 = maxArray(nums1,len1);\\n            vector<int> arr2 = maxArray(nums2,len2);\\n            vector<int> temp_res = merge(arr1,arr2);\\n            if(greater(temp_res,0,ans,0)){\\n                ans.resize(temp_res.size());\\n                for(int i=0;i<temp_res.size();i++){\\n                    ans[i]=temp_res[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002707,
                "title": "c-easy-greedy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<int> maxLex(vector<int> nums, int k) {\\n        int N = nums.size();\\n        vector<int> res;\\n        \\n        for(int i=0; i<N; i++) {\\n            while(!res.empty() and nums[i] > res.back() and k - (int)res.size() <= N - i - 1) {\\n                res.pop_back();\\n            }\\n            if(res.size() < k)\\n                res.push_back(nums[i]);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    bool greater(vector<int>& nums1, vector<int>& nums2, int a, int b) {\\n        while(a < nums1.size() or b < nums2.size()) {\\n            if(a >= nums1.size())\\n                return false;\\n            else if(b >= nums2.size())\\n                return true;\\n            else if(nums1[a] < nums2[b]) \\n                return false;\\n            else if(nums1[a] > nums2[b])\\n                return true;\\n            else \\n                ++a,++b;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans;\\n        for(int i=0; i<=k; i++) {\\n            int j = k - i;\\n            \\n            if(i > nums1.size() or j > nums2.size())\\n                continue;\\n            \\n            vector<int> max1 = maxLex(nums1,i);\\n            vector<int> max2 = maxLex(nums2,j);\\n            \\n            vector<int> merged;\\n            \\n            int a = 0;\\n            int b = 0;\\n            \\n            while(a < max1.size() or b < max2.size()) {\\n                if(a >= max1.size())\\n                    merged.push_back(max2[b++]);\\n                else if(b >= max2.size())\\n                    merged.push_back(max1[a++]);\\n                else if(max1[a] < max2[b]) \\n                    merged.push_back(max2[b++]);\\n                else if(max1[a] > max2[b])\\n                    merged.push_back(max1[a++]);\\n                else{\\n                    if(greater(max1,max2,a,b)) {\\n                        merged.push_back(max1[a++]);\\n                    }\\n                    else {\\n                        merged.push_back(max2[b++]);\\n                    }\\n                }\\n            }\\n            if(merged > ans)\\n                ans = merged;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<int> maxLex(vector<int> nums, int k) {\\n        int N = nums.size();\\n        vector<int> res;\\n        \\n        for(int i=0; i<N; i++) {\\n            while(!res.empty() and nums[i] > res.back() and k - (int)res.size() <= N - i - 1) {\\n                res.pop_back();\\n            }\\n            if(res.size() < k)\\n                res.push_back(nums[i]);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    bool greater(vector<int>& nums1, vector<int>& nums2, int a, int b) {\\n        while(a < nums1.size() or b < nums2.size()) {\\n            if(a >= nums1.size())\\n                return false;\\n            else if(b >= nums2.size())\\n                return true;\\n            else if(nums1[a] < nums2[b]) \\n                return false;\\n            else if(nums1[a] > nums2[b])\\n                return true;\\n            else \\n                ++a,++b;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans;\\n        for(int i=0; i<=k; i++) {\\n            int j = k - i;\\n            \\n            if(i > nums1.size() or j > nums2.size())\\n                continue;\\n            \\n            vector<int> max1 = maxLex(nums1,i);\\n            vector<int> max2 = maxLex(nums2,j);\\n            \\n            vector<int> merged;\\n            \\n            int a = 0;\\n            int b = 0;\\n            \\n            while(a < max1.size() or b < max2.size()) {\\n                if(a >= max1.size())\\n                    merged.push_back(max2[b++]);\\n                else if(b >= max2.size())\\n                    merged.push_back(max1[a++]);\\n                else if(max1[a] < max2[b]) \\n                    merged.push_back(max2[b++]);\\n                else if(max1[a] > max2[b])\\n                    merged.push_back(max1[a++]);\\n                else{\\n                    if(greater(max1,max2,a,b)) {\\n                        merged.push_back(max1[a++]);\\n                    }\\n                    else {\\n                        merged.push_back(max2[b++]);\\n                    }\\n                }\\n            }\\n            if(merged > ans)\\n                ans = merged;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844981,
                "title": "efficient-c-solution-beat-96-runtime-beat-99-6-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> construct(const vector<int>& nums){\\n        int sz = nums.size();\\n        vector<int> ret(sz, sz);\\n        vector<int> pos(10, sz);\\n        for(int i = sz-1; i >= 0; i--){\\n            for(int j = nums[i]+1; j <= 9; j++) ret[i] = min(ret[i], pos[j]);\\n            pos[nums[i]] = i;\\n        }\\n        return ret;\\n    }\\n\\n    int next_pos(const vector<int>& larger_pos, int p, int len, int remain_len){\\n        while(remain_len > 0 && len-larger_pos[p] >= remain_len) p= larger_pos[p];\\n        return p;\\n    }\\n\\n    int get_x(const vector<int>& nums, int p, int remain_len){\\n        if(remain_len <=0 || p >= nums.size()) return -1;\\n        return nums[p];\\n    }\\n\\n    void explore(const vector<int>& nums1, const vector<int>& nums2,const vector<int>& larger_pos1, const vector<int>& larger_pos2, vector<int>& ret, int len1, int len2) {\\n        int p1 = 0; int p2 = 0;\\n        int sz1 = nums1.size();\\n        int sz2 = nums2.size();\\n        bool is_larger = false;\\n        p1= next_pos(larger_pos1, p1, sz1, len1);\\n        p2= next_pos(larger_pos2, p2, sz2, len2);\\n        for(int i = 0; i < k; ++i){\\n            int x1 = len1? nums1[p1] : -1;\\n            int x2 = len2? nums2[p2] : -1;\\n            if((!is_larger) && ret[i] > max(x1, x2)) return;\\n            int iter = 1; int nxp1 = p1; int nxp2 = p2;\\n            int x1_ =  0; int x2_ = 0;\\n            while(x1_ == x2_ && x1_ != -1){\\n                nxp1 = next_pos(larger_pos1, nxp1+1, sz1, len1-iter);\\n                nxp2 = next_pos(larger_pos2, nxp2+1, sz2, len2-iter);\\n                x1_ = get_x(nums1, nxp1, len1-iter);\\n                x2_ = get_x(nums2, nxp2, len2-iter);\\n                iter++;\\n            }\\n            if(x1 > x2 || (x1==x2&&(x1_ > x2_))){\\n                p1 = next_pos(larger_pos1, p1+1, sz1, len1-1);\\n                len1--;\\n            } else {\\n                p2 = next_pos(larger_pos2, p2+1, sz2, len2-1);\\n                len2--;\\n            }\\n            if(ret[i] < max(x1, x2)) is_larger = true;\\n            ret[i] = max(x1, x2);\\n        }\\n    }\\n\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k_) {\\n        int sz1 = nums1.size();\\n        int sz2 = nums2.size();\\n        k = k_;\\n        vector<int> ret(k);\\n        auto larger_pos1 = construct(nums1);\\n        auto larger_pos2 = construct(nums2);\\n\\n        for(int i = max(k-sz2, 0); i <= min(sz1, k); ++i){\\n            explore(nums1, nums2, larger_pos1, larger_pos2, ret, i, k-i);\\n        }\\n\\n        return ret;\\n    }\\n\\nint k;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> construct(const vector<int>& nums){\\n        int sz = nums.size();\\n        vector<int> ret(sz, sz);\\n        vector<int> pos(10, sz);\\n        for(int i = sz-1; i >= 0; i--){\\n            for(int j = nums[i]+1; j <= 9; j++) ret[i] = min(ret[i], pos[j]);\\n            pos[nums[i]] = i;\\n        }\\n        return ret;\\n    }\\n\\n    int next_pos(const vector<int>& larger_pos, int p, int len, int remain_len){\\n        while(remain_len > 0 && len-larger_pos[p] >= remain_len) p= larger_pos[p];\\n        return p;\\n    }\\n\\n    int get_x(const vector<int>& nums, int p, int remain_len){\\n        if(remain_len <=0 || p >= nums.size()) return -1;\\n        return nums[p];\\n    }\\n\\n    void explore(const vector<int>& nums1, const vector<int>& nums2,const vector<int>& larger_pos1, const vector<int>& larger_pos2, vector<int>& ret, int len1, int len2) {\\n        int p1 = 0; int p2 = 0;\\n        int sz1 = nums1.size();\\n        int sz2 = nums2.size();\\n        bool is_larger = false;\\n        p1= next_pos(larger_pos1, p1, sz1, len1);\\n        p2= next_pos(larger_pos2, p2, sz2, len2);\\n        for(int i = 0; i < k; ++i){\\n            int x1 = len1? nums1[p1] : -1;\\n            int x2 = len2? nums2[p2] : -1;\\n            if((!is_larger) && ret[i] > max(x1, x2)) return;\\n            int iter = 1; int nxp1 = p1; int nxp2 = p2;\\n            int x1_ =  0; int x2_ = 0;\\n            while(x1_ == x2_ && x1_ != -1){\\n                nxp1 = next_pos(larger_pos1, nxp1+1, sz1, len1-iter);\\n                nxp2 = next_pos(larger_pos2, nxp2+1, sz2, len2-iter);\\n                x1_ = get_x(nums1, nxp1, len1-iter);\\n                x2_ = get_x(nums2, nxp2, len2-iter);\\n                iter++;\\n            }\\n            if(x1 > x2 || (x1==x2&&(x1_ > x2_))){\\n                p1 = next_pos(larger_pos1, p1+1, sz1, len1-1);\\n                len1--;\\n            } else {\\n                p2 = next_pos(larger_pos2, p2+1, sz2, len2-1);\\n                len2--;\\n            }\\n            if(ret[i] < max(x1, x2)) is_larger = true;\\n            ret[i] = max(x1, x2);\\n        }\\n    }\\n\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k_) {\\n        int sz1 = nums1.size();\\n        int sz2 = nums2.size();\\n        k = k_;\\n        vector<int> ret(k);\\n        auto larger_pos1 = construct(nums1);\\n        auto larger_pos2 = construct(nums2);\\n\\n        for(int i = max(k-sz2, 0); i <= min(sz1, k); ++i){\\n            explore(nums1, nums2, larger_pos1, larger_pos2, ret, i, k-i);\\n        }\\n\\n        return ret;\\n    }\\n\\nint k;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714234,
                "title": "i-finally-tend-this-beast",
                "content": "```cpp\\n// generate all the maximum number from `nums\\' that with length from `n\\' to 1.\\nvoid max_nu(vector<int>& nums, vector<vector<int>>& ret)\\n{\\n\\t// the original `nums\\' is the maximum number of length `n\\'\\n\\tret.push_back(nums);\\n\\tint n = nums.size();\\n\\t\\n\\t// in each iteration, we generate the maximum number of length `n - 1\\'\\n\\t// from the previous maximum number of length `n\\', \\n\\t// by droping one digit.\\n\\twhile (n)\\n\\t{\\n\\t\\tvector<int> nu;\\n\\t\\tint i = 1;\\n\\t\\t\\n\\t\\t// for each digit in the maximum number of length `n\\', \\n\\t\\twhile (i < n)\\n\\t\\t{\\n\\t\\t\\t// drop this digit\\n\\t\\t\\tif (ret.back()[i - 1] < ret.back()[i])\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\n\\t\\t\\t// keep this digit\\n\\t\\t\\tnu.push_back(ret.back()[i - 1]);\\n\\t\\t\\t++ i;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// append the rest digits\\n\\t\\twhile (i < n)\\n\\t\\t\\tnu.push_back(ret.back()[i ++]);\\n\\t\\t\\n\\t\\t// save the maximum number of length `n - 1\\'\\n\\t\\t// move to next iteration\\n\\t\\tret.push_back(nu);\\n\\t\\tn = nu.size();\\n\\t}\\n}\\n\\n// check if the number from the index `i\\' of `n1\\' is larger than the number from the index `j\\' of `n2\\'\\nbool isLarger(vector<int>& n1, vector<int>& n2, int i = 0, int j = 0)\\n{\\n\\tfor (; i < n1.size() && j < n2.size(); ++i, ++j)\\n\\t\\tif (n1[i] != n2[j])\\n\\t\\t\\tbreak;\\n\\t\\n\\t// if the length of `n1\\' from index `i\\' is longer than that of `n2\\' from index `j\\', or\\n\\t// a digit in `n1\\' is larger than the corresponding digit in `n2\\' \\n\\treturn i < n1.size() && (j == n2.size() || n1[i] > n2[j]);\\n}\\n\\n// `nn\\' will be the maximum number constructed by merge `n1\\' and `n2\\'\\nvoid merge(vector<int>& n1, vector<int>& n2, vector<int>& nn)\\n{\\n\\tint m = n1.size();\\n\\tint n = n2.size();\\n\\tint i = 0;\\n\\tint j = 0;\\n\\t\\n\\twhile (i < m && j < n)\\n\\t{\\n\\t\\tif (isLarger(n1, n2, i, j))\\n\\t\\t\\tnn.push_back(n1[i ++]);\\n\\t\\telse\\n\\t\\t\\tnn.push_back(n2[j ++]);\\n\\t}\\n\\t\\n\\twhile (i < m)\\n\\t\\tnn.push_back(n1[i ++]);\\n\\t\\n\\twhile (j < n)\\n\\t\\tnn.push_back(n2[j ++]);\\n}\\n\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\tvector<int> ret;\\n\\tvector<vector<int>> nu1, nu2;\\n\\tint m = nums1.size();\\n\\tint n = nums2.size();\\n\\t\\n\\t// generate maximum numbers of all length from `m\\' to 1 using `nums1\\'\\n\\tmax_nu(nums1, nu1);\\n\\t// likewise.\\n\\tmax_nu(nums2, nu2);\\n\\t\\n\\t// the overall maximum number must come from a maximum number of `nums1\\' of length k1 and\\n\\t// a maximum number of `nums2\\' of length k2, where k1 + k2 == k\\n\\tfor (auto& n1 : nu1)\\n\\t{\\n\\t\\tint k1 = n1.size();\\n\\t\\tint k2 = k - k1;\\n\\t\\t\\n\\t\\tif (k2 < 0 || k2 > n)\\n\\t\\t\\tcontinue;\\n\\t\\t\\n\\t\\t// the corresponding maximum number of `nums2\\' of length k2\\n\\t\\tauto& n2 = nu2[nu2.size() - 1 - k2];\\n\\n\\t\\t// merge them to form a local maximum number of length k\\n\\t\\tvector<int> nn;\\n\\t\\tmerge(n1, n2, nn);\\n\\n\\t\\t// determin the global maximum number of length k\\n\\t\\tif (ret.empty() || isLarger(nn, ret))\\n\\t\\t\\tret = nn;\\n\\t}\\n\\t\\n\\treturn ret;        \\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n// generate all the maximum number from `nums\\' that with length from `n\\' to 1.\\nvoid max_nu(vector<int>& nums, vector<vector<int>>& ret)\\n{\\n\\t// the original `nums\\' is the maximum number of length `n\\'\\n\\tret.push_back(nums);\\n\\tint n = nums.size();\\n\\t\\n\\t// in each iteration, we generate the maximum number of length `n - 1\\'\\n\\t// from the previous maximum number of length `n\\', \\n\\t// by droping one digit.\\n\\twhile (n)\\n\\t{\\n\\t\\tvector<int> nu;\\n\\t\\tint i = 1;\\n\\t\\t\\n\\t\\t// for each digit in the maximum number of length `n\\', \\n\\t\\twhile (i < n)\\n\\t\\t{\\n\\t\\t\\t// drop this digit\\n\\t\\t\\tif (ret.back()[i - 1] < ret.back()[i])\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\n\\t\\t\\t// keep this digit\\n\\t\\t\\tnu.push_back(ret.back()[i - 1]);\\n\\t\\t\\t++ i;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// append the rest digits\\n\\t\\twhile (i < n)\\n\\t\\t\\tnu.push_back(ret.back()[i ++]);\\n\\t\\t\\n\\t\\t// save the maximum number of length `n - 1\\'\\n\\t\\t// move to next iteration\\n\\t\\tret.push_back(nu);\\n\\t\\tn = nu.size();\\n\\t}\\n}\\n\\n// check if the number from the index `i\\' of `n1\\' is larger than the number from the index `j\\' of `n2\\'\\nbool isLarger(vector<int>& n1, vector<int>& n2, int i = 0, int j = 0)\\n{\\n\\tfor (; i < n1.size() && j < n2.size(); ++i, ++j)\\n\\t\\tif (n1[i] != n2[j])\\n\\t\\t\\tbreak;\\n\\t\\n\\t// if the length of `n1\\' from index `i\\' is longer than that of `n2\\' from index `j\\', or\\n\\t// a digit in `n1\\' is larger than the corresponding digit in `n2\\' \\n\\treturn i < n1.size() && (j == n2.size() || n1[i] > n2[j]);\\n}\\n\\n// `nn\\' will be the maximum number constructed by merge `n1\\' and `n2\\'\\nvoid merge(vector<int>& n1, vector<int>& n2, vector<int>& nn)\\n{\\n\\tint m = n1.size();\\n\\tint n = n2.size();\\n\\tint i = 0;\\n\\tint j = 0;\\n\\t\\n\\twhile (i < m && j < n)\\n\\t{\\n\\t\\tif (isLarger(n1, n2, i, j))\\n\\t\\t\\tnn.push_back(n1[i ++]);\\n\\t\\telse\\n\\t\\t\\tnn.push_back(n2[j ++]);\\n\\t}\\n\\t\\n\\twhile (i < m)\\n\\t\\tnn.push_back(n1[i ++]);\\n\\t\\n\\twhile (j < n)\\n\\t\\tnn.push_back(n2[j ++]);\\n}\\n\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\tvector<int> ret;\\n\\tvector<vector<int>> nu1, nu2;\\n\\tint m = nums1.size();\\n\\tint n = nums2.size();\\n\\t\\n\\t// generate maximum numbers of all length from `m\\' to 1 using `nums1\\'\\n\\tmax_nu(nums1, nu1);\\n\\t// likewise.\\n\\tmax_nu(nums2, nu2);\\n\\t\\n\\t// the overall maximum number must come from a maximum number of `nums1\\' of length k1 and\\n\\t// a maximum number of `nums2\\' of length k2, where k1 + k2 == k\\n\\tfor (auto& n1 : nu1)\\n\\t{\\n\\t\\tint k1 = n1.size();\\n\\t\\tint k2 = k - k1;\\n\\t\\t\\n\\t\\tif (k2 < 0 || k2 > n)\\n\\t\\t\\tcontinue;\\n\\t\\t\\n\\t\\t// the corresponding maximum number of `nums2\\' of length k2\\n\\t\\tauto& n2 = nu2[nu2.size() - 1 - k2];\\n\\n\\t\\t// merge them to form a local maximum number of length k\\n\\t\\tvector<int> nn;\\n\\t\\tmerge(n1, n2, nn);\\n\\n\\t\\t// determin the global maximum number of length k\\n\\t\\tif (ret.empty() || isLarger(nn, ret))\\n\\t\\t\\tret = nn;\\n\\t}\\n\\t\\n\\treturn ret;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2663123,
                "title": "create-maximum-number-c",
                "content": "```\\nvoid getMaxNumber(int *nums, int size, int outsize, int *out) {\\n    int len = 0, i, k = size - outsize;\\n    out[0] = nums[0];\\n    for (i = 1; i < size; i++) {\\n        while (len >= 0 && k > 0 && nums[i] > out[len]) k--, len--;\\n        out[++len] = nums[i];\\n    }\\n}\\n\\nint compareArr(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int i;\\n    for (i = 0; i < nums1Size && i < nums2Size && nums1[i] == nums2[i]; i++);\\n    //if (i == nums1Size && i == nums2Size) return 0;\\n    if (i == nums1Size) return -1;\\n    if (i == nums2Size) return 1;\\n    return (nums1[i] - nums2[i]);\\n}\\n\\nvoid merge(int* nums1, int nums1Size, int* nums2, int nums2Size, int *out) {\\n    int len = 0, i = 0, j = 0;\\n    while (i < nums1Size && j < nums2Size) {\\n        if (nums1[i] > nums2[j]) out[len++] = nums1[i++];\\n        else if (nums1[i] < nums2[j]) out[len++] = nums2[j++];\\n        else if (compareArr(nums1 + i, nums1Size - i, nums2 + j, nums2Size - j) >= 0) out[len++] = nums1[i++];\\n        else out[len++] = nums2[j++];\\n    }\\n    while (i < nums1Size) out[len++] = nums1[i++];\\n    while (j < nums2Size) out[len++] = nums2[j++];\\n}\\n\\nint compare(int *arr1, int *arr2, int len) {\\n    int i = 0;\\n    for (; i < len && arr1[i] == arr2[i]; i++);\\n    if (i < len) return arr1[i] - arr2[i];\\n    return 0;\\n}\\n\\nint min(int x, int y) {return x <= y ? x: y;}\\n\\nint* maxNumber(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize) {\\n    int i = 0, j = 0;\\n    int *arr1, *arr2, *ans, *tmp;\\n    if (k <= 0) {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    arr1 = malloc(sizeof(int) * (nums1Size + nums2Size));\\n    arr2 = arr1 + nums1Size;\\n    ans = malloc(sizeof(int) * k);\\n    tmp = malloc(sizeof(int) * k);\\n    for (j = 0; j < k; j++) ans[j] = 0;\\n    for (i = min(k, nums1Size); i >= 0; i--) {\\n        j = k - i;\\n        if (j > nums2Size) break;\\n        if (i > 0) getMaxNumber(nums1, nums1Size, i, arr1);\\n        if (j > 0) getMaxNumber(nums2, nums2Size, j, arr2);\\n        merge(arr1, i, arr2, j, tmp);\\n        if (compare(tmp, ans, k) > 0) {\\n            for (j = 0; j < k; j++) ans[j] = tmp[j];\\n        }\\n    }\\n    free(tmp);\\n    free(arr1);\\n    *returnSize = k; \\n    return ans;\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nvoid getMaxNumber(int *nums, int size, int outsize, int *out) {\\n    int len = 0, i, k = size - outsize;\\n    out[0] = nums[0];\\n    for (i = 1; i < size; i++) {\\n        while (len >= 0 && k > 0 && nums[i] > out[len]) k--, len--;\\n        out[++len] = nums[i];\\n    }\\n}\\n\\nint compareArr(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int i;\\n    for (i = 0; i < nums1Size && i < nums2Size && nums1[i] == nums2[i]; i++);\\n    //if (i == nums1Size && i == nums2Size) return 0;\\n    if (i == nums1Size) return -1;\\n    if (i == nums2Size) return 1;\\n    return (nums1[i] - nums2[i]);\\n}\\n\\nvoid merge(int* nums1, int nums1Size, int* nums2, int nums2Size, int *out) {\\n    int len = 0, i = 0, j = 0;\\n    while (i < nums1Size && j < nums2Size) {\\n        if (nums1[i] > nums2[j]) out[len++] = nums1[i++];\\n        else if (nums1[i] < nums2[j]) out[len++] = nums2[j++];\\n        else if (compareArr(nums1 + i, nums1Size - i, nums2 + j, nums2Size - j) >= 0) out[len++] = nums1[i++];\\n        else out[len++] = nums2[j++];\\n    }\\n    while (i < nums1Size) out[len++] = nums1[i++];\\n    while (j < nums2Size) out[len++] = nums2[j++];\\n}\\n\\nint compare(int *arr1, int *arr2, int len) {\\n    int i = 0;\\n    for (; i < len && arr1[i] == arr2[i]; i++);\\n    if (i < len) return arr1[i] - arr2[i];\\n    return 0;\\n}\\n\\nint min(int x, int y) {return x <= y ? x: y;}\\n\\nint* maxNumber(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize) {\\n    int i = 0, j = 0;\\n    int *arr1, *arr2, *ans, *tmp;\\n    if (k <= 0) {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    arr1 = malloc(sizeof(int) * (nums1Size + nums2Size));\\n    arr2 = arr1 + nums1Size;\\n    ans = malloc(sizeof(int) * k);\\n    tmp = malloc(sizeof(int) * k);\\n    for (j = 0; j < k; j++) ans[j] = 0;\\n    for (i = min(k, nums1Size); i >= 0; i--) {\\n        j = k - i;\\n        if (j > nums2Size) break;\\n        if (i > 0) getMaxNumber(nums1, nums1Size, i, arr1);\\n        if (j > 0) getMaxNumber(nums2, nums2Size, j, arr2);\\n        merge(arr1, i, arr2, j, tmp);\\n        if (compare(tmp, ans, k) > 0) {\\n            for (j = 0; j < k; j++) ans[j] = tmp[j];\\n        }\\n    }\\n    free(tmp);\\n    free(arr1);\\n    *returnSize = k; \\n    return ans;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2577370,
                "title": "very-short-c",
                "content": "```\\nclass Solution {\\n    vector<int> removek(vector<int> &nums, int k) {\\n        vector<int> res;\\n        for (auto num : nums) {\\n            while (res.size() && res.back() < num && k) {\\n                res.pop_back();\\n                k--;\\n            }\\n            res.push_back(num);\\n        }\\n        while(k) {\\n            res.pop_back();\\n            k--;\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> merge(vector<int> &arr1, vector<int> &arr2) {\\n        vector<int> res;\\n        int i = 0, j = 0;\\n        int N1 = arr1.size(), N2 = arr2.size();\\n        while(i < N1 && j < N2) {\\n            vector<int> tmp1(arr1.begin() + i, arr1.end());\\n            vector<int> tmp2(arr2.begin() + j, arr2.end());\\n            if (tmp1 > tmp2) {\\n                res.push_back(arr1[i++]);\\n            } else {\\n                res.push_back(arr2[j++]);\\n            }\\n        }\\n        while(i < N1) {\\n            res.push_back(arr1[i++]);\\n        }\\n        while(j < N2) {\\n            res.push_back(arr2[j++]);\\n        }\\n        return res;\\n    }\\n    \\n    \\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int N1 = nums1.size(), N2 = nums2.size();\\n        vector<int> res;\\n        \\n        // N1 - i >= 0 && N2 - (k - i) >= 0\\n        for (int i = max(0, k - N2); i <= k && i <= N1; i++) {\\n            auto arr1 = removek(nums1, N1 - i);\\n            auto arr2 = removek(nums2, N2 - (k - i));\\n            auto arr = merge(arr1, arr2);\\n            res = max(res, arr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> removek(vector<int> &nums, int k) {\\n        vector<int> res;\\n        for (auto num : nums) {\\n            while (res.size() && res.back() < num && k) {\\n                res.pop_back();\\n                k--;\\n            }\\n            res.push_back(num);\\n        }\\n        while(k) {\\n            res.pop_back();\\n            k--;\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> merge(vector<int> &arr1, vector<int> &arr2) {\\n        vector<int> res;\\n        int i = 0, j = 0;\\n        int N1 = arr1.size(), N2 = arr2.size();\\n        while(i < N1 && j < N2) {\\n            vector<int> tmp1(arr1.begin() + i, arr1.end());\\n            vector<int> tmp2(arr2.begin() + j, arr2.end());\\n            if (tmp1 > tmp2) {\\n                res.push_back(arr1[i++]);\\n            } else {\\n                res.push_back(arr2[j++]);\\n            }\\n        }\\n        while(i < N1) {\\n            res.push_back(arr1[i++]);\\n        }\\n        while(j < N2) {\\n            res.push_back(arr2[j++]);\\n        }\\n        return res;\\n    }\\n    \\n    \\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int N1 = nums1.size(), N2 = nums2.size();\\n        vector<int> res;\\n        \\n        // N1 - i >= 0 && N2 - (k - i) >= 0\\n        for (int i = max(0, k - N2); i <= k && i <= N1; i++) {\\n            auto arr1 = removek(nums1, N1 - i);\\n            auto arr2 = removek(nums2, N2 - (k - i));\\n            auto arr = merge(arr1, arr2);\\n            res = max(res, arr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470003,
                "title": "finally",
                "content": "**Solution:**\\n`TC = O((m+n)*(m+n-k)), SC = O(k*(m+n-k))`\\n```\\nvector<int> removeDigits(vector<int> &nums, int k) {\\n\\tif(k == 0) return nums;\\n\\tif(k == nums.size()) return {};\\n\\tstack<int> st;\\n\\tst.push(nums[0]);\\n\\tfor(int i = 1; i < nums.size(); i++) {\\n\\t\\twhile(!st.empty() && st.top() < nums[i] && k > 0) {\\n\\t\\t\\tst.pop();\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\tst.push(nums[i]);\\n\\t}\\n\\twhile(k > 0) {\\n\\t\\tst.pop();\\n\\t\\tk--;\\n\\t}\\n\\tvector<int> ans;\\n\\twhile(!st.empty()) {\\n\\t\\tans.push_back(st.top());\\n\\t\\tst.pop();\\n\\t}\\n\\treverse(ans.begin(), ans.end());\\n\\treturn ans;\\n}\\n\\nvector<int> merge(vector<int> &v1, vector<int> &v2) {\\n\\tif(v1.size() == 0) return v2;\\n\\tif(v2.size() == 0) return v1;\\n\\tvector<int> v;\\n\\tint i = 0, j = 0;\\n\\twhile(i < v1.size() && j < v2.size()) {\\n\\t\\tif(v1[i] == v2[j]) {\\n\\t\\t\\tint a, b;\\n\\t\\t\\tint i1 = i, j1 = j;\\n\\t\\t\\twhile(i1 < v1.size() && j1 < v2.size() && v1[i1] == v2[j1]) {\\n\\t\\t\\t\\ti1++;\\n\\t\\t\\t\\tj1++;\\n\\t\\t\\t}\\n\\t\\t\\tif(i1 < v1.size()) a = v1[i1];\\n\\t\\t\\telse a = INT_MIN;\\n\\t\\t\\tif(j1 < v2.size()) b = v2[j1];\\n\\t\\t\\telse b = INT_MIN;\\n\\t\\t\\tif(a >= b) {\\n\\t\\t\\t\\tv.push_back(v1[i]);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tv.push_back(v2[j]);\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(v1[i] > v2[j]) {\\n\\t\\t\\tv.push_back(v1[i]);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tv.push_back(v2[j]);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\twhile(i < v1.size()) {\\n\\t\\tv.push_back(v1[i]);\\n\\t\\ti++;\\n\\t}\\n\\twhile(j < v2.size()) {\\n\\t\\tv.push_back(v2[j]);\\n\\t\\tj++;\\n\\t}\\n\\treturn v;\\n}\\n\\nbool isLargest(vector<int> &nums1, vector<int> &nums2) {\\n\\tint i = 0;\\n\\twhile(i < nums1.size() && nums1[i] == nums2[i]) i++;\\n\\tif(i == nums1.size()) return true;\\n\\tif(nums1[i] > nums2[i]) return true;\\n\\treturn false;\\n}\\n\\nvector<int> findLargest(vector<vector<int>> &possibleAnswers) {\\n\\tint idx = 0;\\n\\tfor(int i = 1; i < possibleAnswers.size(); i++) {\\n\\t\\tif(isLargest(possibleAnswers[i], possibleAnswers[idx])) \\n\\t\\t\\tidx = i;\\n\\t}\\n\\treturn possibleAnswers[idx];\\n}\\n\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\tint digitsToRemove = nums1.size() + nums2.size() - k;\\n\\tvector<vector<int>> possibleAnswers;\\n\\tfor(int i = 0; i <= digitsToRemove; i++) {\\n\\t\\tint digitsToRemoveFromNums1 = i;\\n\\t\\tint digitsToRemoveFromNums2 = digitsToRemove - i;\\n\\t\\tif(digitsToRemoveFromNums1 <= nums1.size() && \\n\\t\\t   digitsToRemoveFromNums2 <= nums2.size()) {\\n\\t\\t\\tvector<int> nums1AfterRemovingDigits = removeDigits(nums1, digitsToRemoveFromNums1);\\n\\t\\t\\tvector<int> nums2AfterRemovingDigits = removeDigits(nums2, digitsToRemoveFromNums2);\\n\\t\\t\\tpossibleAnswers.push_back(merge(nums1AfterRemovingDigits, nums2AfterRemovingDigits));\\n\\t\\t}\\n\\t}\\n\\treturn findLargest(possibleAnswers);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> removeDigits(vector<int> &nums, int k) {\\n\\tif(k == 0) return nums;\\n\\tif(k == nums.size()) return {};\\n\\tstack<int> st;\\n\\tst.push(nums[0]);\\n\\tfor(int i = 1; i < nums.size(); i++) {\\n\\t\\twhile(!st.empty() && st.top() < nums[i] && k > 0) {\\n\\t\\t\\tst.pop();\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\tst.push(nums[i]);\\n\\t}\\n\\twhile(k > 0) {\\n\\t\\tst.pop();\\n\\t\\tk--;\\n\\t}\\n\\tvector<int> ans;\\n\\twhile(!st.empty()) {\\n\\t\\tans.push_back(st.top());\\n\\t\\tst.pop();\\n\\t}\\n\\treverse(ans.begin(), ans.end());\\n\\treturn ans;\\n}\\n\\nvector<int> merge(vector<int> &v1, vector<int> &v2) {\\n\\tif(v1.size() == 0) return v2;\\n\\tif(v2.size() == 0) return v1;\\n\\tvector<int> v;\\n\\tint i = 0, j = 0;\\n\\twhile(i < v1.size() && j < v2.size()) {\\n\\t\\tif(v1[i] == v2[j]) {\\n\\t\\t\\tint a, b;\\n\\t\\t\\tint i1 = i, j1 = j;\\n\\t\\t\\twhile(i1 < v1.size() && j1 < v2.size() && v1[i1] == v2[j1]) {\\n\\t\\t\\t\\ti1++;\\n\\t\\t\\t\\tj1++;\\n\\t\\t\\t}\\n\\t\\t\\tif(i1 < v1.size()) a = v1[i1];\\n\\t\\t\\telse a = INT_MIN;\\n\\t\\t\\tif(j1 < v2.size()) b = v2[j1];\\n\\t\\t\\telse b = INT_MIN;\\n\\t\\t\\tif(a >= b) {\\n\\t\\t\\t\\tv.push_back(v1[i]);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tv.push_back(v2[j]);\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(v1[i] > v2[j]) {\\n\\t\\t\\tv.push_back(v1[i]);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tv.push_back(v2[j]);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\twhile(i < v1.size()) {\\n\\t\\tv.push_back(v1[i]);\\n\\t\\ti++;\\n\\t}\\n\\twhile(j < v2.size()) {\\n\\t\\tv.push_back(v2[j]);\\n\\t\\tj++;\\n\\t}\\n\\treturn v;\\n}\\n\\nbool isLargest(vector<int> &nums1, vector<int> &nums2) {\\n\\tint i = 0;\\n\\twhile(i < nums1.size() && nums1[i] == nums2[i]) i++;\\n\\tif(i == nums1.size()) return true;\\n\\tif(nums1[i] > nums2[i]) return true;\\n\\treturn false;\\n}\\n\\nvector<int> findLargest(vector<vector<int>> &possibleAnswers) {\\n\\tint idx = 0;\\n\\tfor(int i = 1; i < possibleAnswers.size(); i++) {\\n\\t\\tif(isLargest(possibleAnswers[i], possibleAnswers[idx])) \\n\\t\\t\\tidx = i;\\n\\t}\\n\\treturn possibleAnswers[idx];\\n}\\n\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\tint digitsToRemove = nums1.size() + nums2.size() - k;\\n\\tvector<vector<int>> possibleAnswers;\\n\\tfor(int i = 0; i <= digitsToRemove; i++) {\\n\\t\\tint digitsToRemoveFromNums1 = i;\\n\\t\\tint digitsToRemoveFromNums2 = digitsToRemove - i;\\n\\t\\tif(digitsToRemoveFromNums1 <= nums1.size() && \\n\\t\\t   digitsToRemoveFromNums2 <= nums2.size()) {\\n\\t\\t\\tvector<int> nums1AfterRemovingDigits = removeDigits(nums1, digitsToRemoveFromNums1);\\n\\t\\t\\tvector<int> nums2AfterRemovingDigits = removeDigits(nums2, digitsToRemoveFromNums2);\\n\\t\\t\\tpossibleAnswers.push_back(merge(nums1AfterRemovingDigits, nums2AfterRemovingDigits));\\n\\t\\t}\\n\\t}\\n\\treturn findLargest(possibleAnswers);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2238372,
                "title": "java-convert-to-string-for-easy-comparison-greedy",
                "content": "The merge operation is tricky because, say, we have the following 2 sequences\\n```\\n0, 1, 8 ,5 (A)\\n0, 1, 8 ,4 (B)\\n```\\nIf both pointers are at 0, should we pick `A` or `B`? \\nWe should pick `A` as the resulting sequence would be `0,1,8,5,0,1,8,4`\\nWe can either advance both pointers and determine which to pick until they differ or meet the end, \\nor we can just convert it to string and use `compareTo()`\\n\\n```Java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        String ans=\"\";\\n        for (int i = Math.max(0, k-nums2.length); i <= Math.min(nums1.length, k); i++){ // try all possible lengths from each seq\\n            String one = solve(nums1, i); // find the best seq matching len of i\\n            String two = solve(nums2, k-i); // len of k-i\\n            StringBuilder sb = new StringBuilder();\\n            int a = 0, b = 0;\\n            while(a < i || b < k-i){ // merge it to the max\\n                sb.append(one.substring(a).compareTo(two.substring(b))>=0?one.charAt(a++):two.charAt(b++));\\n            }\\n            if (sb.toString().compareTo(ans)>0){ // if better, we replace.\\n                ans=sb.toString();\\n            }\\n        }\\n        int[] res = new int[k];\\n        for (int i = 0; i < k;++i){\\n            res[i]=ans.charAt(i)-\\'0\\';\\n        }\\n        return res;\\n    }\\n\\n    private String solve(int[] arr, int k){\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (int i = 0;i<arr.length;++i){\\n            while(!stack.isEmpty()&&arr.length-i+stack.size()>k&&stack.peek()<arr[i]){\\n                stack.pop();\\n            }\\n            stack.push(arr[i]);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < k;i++){\\n            sb.append(stack.pollLast());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n0, 1, 8 ,5 (A)\\n0, 1, 8 ,4 (B)\\n```\n```Java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        String ans=\"\";\\n        for (int i = Math.max(0, k-nums2.length); i <= Math.min(nums1.length, k); i++){ // try all possible lengths from each seq\\n            String one = solve(nums1, i); // find the best seq matching len of i\\n            String two = solve(nums2, k-i); // len of k-i\\n            StringBuilder sb = new StringBuilder();\\n            int a = 0, b = 0;\\n            while(a < i || b < k-i){ // merge it to the max\\n                sb.append(one.substring(a).compareTo(two.substring(b))>=0?one.charAt(a++):two.charAt(b++));\\n            }\\n            if (sb.toString().compareTo(ans)>0){ // if better, we replace.\\n                ans=sb.toString();\\n            }\\n        }\\n        int[] res = new int[k];\\n        for (int i = 0; i < k;++i){\\n            res[i]=ans.charAt(i)-\\'0\\';\\n        }\\n        return res;\\n    }\\n\\n    private String solve(int[] arr, int k){\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (int i = 0;i<arr.length;++i){\\n            while(!stack.isEmpty()&&arr.length-i+stack.size()>k&&stack.peek()<arr[i]){\\n                stack.pop();\\n            }\\n            stack.push(arr[i]);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < k;i++){\\n            sb.append(stack.pollLast());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190731,
                "title": "create-maximum-number",
                "content": "class Solution {\\npublic:\\nbool Greater(vector<int> &nums1, int i, vector<int> &nums2, int j)\\n{\\n    while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j])\\n    {\\n        ++i;\\n        ++j;\\n    }\\n    if (j == nums2.size())\\n        return true;\\n    if (i < nums1.size() && nums1[i] > nums2[j])\\n        return true;\\n    return false;\\n}\\n    vector<int>HighestNum(vector<int>nums,int k){\\n        int n=nums.size();\\n        vector<int>ans(k);\\n        for(int i=0,j=0;i<n;++i){\\n            while(n -i + j > k && j > 0 && ans[j-1] < nums[i]){\\n                j--; \\n            }\\n            if(j<k){\\n                ans[j++]=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\nvector<int> merge(vector<int> &nums1, vector<int> &nums2, int k)\\n{\\n    vector<int> res(k, 0);\\n    for (int i = 0, j = 0, r = 0; r < k; ++r)\\n    {\\n        res[r] = Greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n    }\\n    return res;\\n}\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans(k, -1);\\n        for (int i = max(0, k - m); i <= min(k, n); i++)\\n        {\\n            vector<int> a = HighestNum(nums1, i);\\n            vector<int> b = HighestNum(nums2, k - i);\\n            ans = max(ans, merge(a, b, k));\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\nbool Greater(vector<int> &nums1, int i, vector<int> &nums2, int j)\\n{\\n    while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j])\\n    {\\n        ++i;\\n        ++j;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2113081,
                "title": "python-optimised-solution-90",
                "content": "Optimised various available codes in discussion forum.\\n```\\n\\nfrom copy import copy\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def pre_process(self, num):\\n        l = len(num)\\n        summary = [[] for _ in range(l)]\\n        last = [l] * 10\\n        for i in range(l - 1, -1, -1):\\n            last[num[i]] = i\\n            summary[i] = copy(last)\\n        return summary\\n\\n    def get_next(self, summary, start, end):\\n        for i in range(9, -1, -1):\\n            if summary[start][i] < end:\\n                return summary[start][i], i\\n\\n    def maxNumber(self, nums1, nums2, k):\\n\\n        if len(nums1) > len(nums2):\\n            nums1, nums2 = nums2, nums1\\n        summary1 = self.pre_process(nums1)\\n        summary2 = self.pre_process(nums2)\\n        candidates = {0:0}\\n        max_val = []\\n        l1 = len(nums1)\\n        l2 = len(nums2)\\n        for i in range(k):\\n            print(max_val)\\n            updated_candidates = defaultdict(lambda: (l2, 0))\\n            round_max = -1\\n            for x, y in candidates.items():\\n                remain = max(0, (k - i) - (l2 - y) - 1)\\n                if l1 - x >= remain and l1 - x > 0:\\n                    if x + 1 == l1 - remain:\\n                        pos1, max1 = x, nums1[x]\\n                    else:\\n                        pos1, max1 = self.get_next(summary1, x, l1 - remain)\\n                else:\\n                    pos1, max1 = l1, -1\\n                remain = max(0, (k - i) - (l1 - x) - 1)\\n                if l2 - y >= remain and l2 - y > 0:\\n                    if y + 1 == l2 - remain:\\n                        pos2, max2 = y, nums2[y]\\n                    else:\\n                        pos2, max2 = self.get_next(summary2, y, l2 - remain)\\n                else:\\n                    pos2, max2 = l2, -1\\n                round_max = max(max1, max2, round_max)\\n                if max1 == round_max:\\n                    updated_candidates[pos1 + 1] = (y, max1)\\n                if max2 == round_max:\\n                    updated_candidates[x] = (pos2 + 1, max2)\\n            max_val.append(round_max)\\n            candidates.clear()\\n            for l, v in updated_candidates.items():\\n                if v[1] == round_max:\\n                    candidates[l] = v[0]\\n        return max_val",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def pre_process(self, num):\\n        l = len(num)\\n        summary = [[] for _ in range(l)]\\n        last = [l] * 10\\n        for i in range(l - 1, -1, -1):\\n            last[num[i]] = i\\n            summary[i] = copy(last)\\n        return summary\\n\\n    def get_next(self, summary, start, end):\\n        for i in range(9, -1, -1):\\n            if summary[start][i] < end:\\n                return summary[start][i], i\\n\\n    def maxNumber(self, nums1, nums2, k):\\n\\n        if len(nums1) > len(nums2):\\n            nums1, nums2 = nums2, nums1\\n        summary1 = self.pre_process(nums1)\\n        summary2 = self.pre_process(nums2)\\n        candidates = {0:0}",
                "codeTag": "Java"
            },
            {
                "id": 2094585,
                "title": "c-bfs-pruning",
                "content": "```\\nclass Solution {\\nprivate:\\n\\tint next1[500+1][10];\\n\\tint next2[500+1][10];\\n\\n\\tvoid fillNext(int next[][10], vector<int> &nums) {\\n\\t\\tmemset(next, 0, sizeof next1);\\n\\t\\tfor(int i = nums.size() - 1; i >= 0; i--) {\\n\\t\\t\\tmemcpy(next[i], next[i+1], sizeof next[i]);\\n\\t\\t\\tnext[i][nums[i]] = i+1;\\n\\t\\t}\\n\\t}\\npublic:\\n\\tvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n#define N nums1.size()\\n#define M nums2.size()\\n\\t\\tvector<int> max;\\n\\t\\tunordered_map<int, int> states = { {0, 0} };\\n\\n\\t\\tfillNext(next1, nums1);\\n\\t\\tfillNext(next2, nums2);\\n\\t\\tmax.reserve(k);\\n\\t\\t\\n\\t\\twhile(max.size() < k) {\\n\\t\\t\\tunordered_map<int, int> newStates;\\n\\t\\t\\tint d;\\n\\t\\t\\tbool found = false;\\n\\t\\t\\tfor(d = 9; d >= 0; d--) {\\n\\t\\t\\t\\tfor(const auto& [i, j] : states) {\\n\\t\\t\\t\\t\\tint nexti, nextj;\\n\\t\\t\\t\\t\\tif((nexti  = next1[i][d]) && N - nexti + M - j >= k - max.size() - 1) {\\n\\t\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\t\\tnewStates[nexti] = newStates[nexti] ? min(newStates[nexti], j) : j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif((nextj = next2[j][d]) && N - i + M - nextj >= k - max.size() - 1) {\\n\\t\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\t\\tnewStates[i] = newStates[i] ? min(newStates[i], nextj) : nextj;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(found) break;\\n\\t\\t\\t}\\n\\t\\t\\tstates = std::move(newStates);\\n\\t\\t\\tmax.push_back(d);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tint next1[500+1][10];\\n\\tint next2[500+1][10];\\n\\n\\tvoid fillNext(int next[][10], vector<int> &nums) {\\n\\t\\tmemset(next, 0, sizeof next1);\\n\\t\\tfor(int i = nums.size() - 1; i >= 0; i--) {\\n\\t\\t\\tmemcpy(next[i], next[i+1], sizeof next[i]);\\n\\t\\t\\tnext[i][nums[i]] = i+1;\\n\\t\\t}\\n\\t}\\npublic:\\n\\tvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n#define N nums1.size()\\n#define M nums2.size()\\n\\t\\tvector<int> max;\\n\\t\\tunordered_map<int, int> states = { {0, 0} };\\n\\n\\t\\tfillNext(next1, nums1);\\n\\t\\tfillNext(next2, nums2);\\n\\t\\tmax.reserve(k);\\n\\t\\t\\n\\t\\twhile(max.size() < k) {\\n\\t\\t\\tunordered_map<int, int> newStates;\\n\\t\\t\\tint d;\\n\\t\\t\\tbool found = false;\\n\\t\\t\\tfor(d = 9; d >= 0; d--) {\\n\\t\\t\\t\\tfor(const auto& [i, j] : states) {\\n\\t\\t\\t\\t\\tint nexti, nextj;\\n\\t\\t\\t\\t\\tif((nexti  = next1[i][d]) && N - nexti + M - j >= k - max.size() - 1) {\\n\\t\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\t\\tnewStates[nexti] = newStates[nexti] ? min(newStates[nexti], j) : j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif((nextj = next2[j][d]) && N - i + M - nextj >= k - max.size() - 1) {\\n\\t\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\t\\tnewStates[i] = newStates[i] ? min(newStates[i], nextj) : nextj;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(found) break;\\n\\t\\t\\t}\\n\\t\\t\\tstates = std::move(newStates);\\n\\t\\t\\tmax.push_back(d);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030040,
                "title": "java-solution-with-comments",
                "content": "class Solution {\\n   public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\n        \\n\\n       \\n\\n       //LEFT boundary can start with max of 0 or k-num2.length\\n       //end or RIGHT boundary ends wid Min(k, num1.length)\\n        //If I take x from first array then remaining k-x from second array \\n        // boundary where we can traverse array element for subSeq is  \\n        //start with 0 or k-num2.len\\n        //e.g. num1=5 and num2=3 and k = 5\\n        // LEFT boundary 5-3 = 2  RIGHT = 5 \\n        int start = Math.max(0,k-nums2.length);  \\n        int end = Math.min(k, nums1.length);   \\n        int[] result =new int[k];\\n        int[] tmp=null;\\n    //try all combination in boundary which can result in max  \\n        for(int i=start;i<=end;i++){\\n\\t\\t\\t//find max subseqences\\n            int[] sub1 = getMaxSubsequence(nums1,i); \\n            int[] sub2 = getMaxSubsequence (nums2,k-i);\\n            //merge array\\n            tmp = merge(sub1,sub2);\\n\\t\\t\\t//store max in result\\n            if(isGreater(tmp,0,result,0)){\\n                result = tmp;\\n            }\\n\\n\\n        }\\n\\n        return result;\\n\\n\\n    }\\n\\n    int[] merge(int[] num1, int[] num2){\\n        int[] res = new int[num1.length+num2.length];\\n        int l1=0,l2=0,l3=0;\\n        while(l3<res.length){\\n            res[l3++] = isGreater(num1,l1,num2,l2)? num1[l1++]:num2[l2++];\\n        }\\n        return res;\\n    }\\n\\n    boolean isGreater(int[] num1, int l1, int[] num2, int l2){\\n        while(l1<num1.length && l2<num2.length){\\n            if(num1[l1]>num2[l2]){\\n                return true;\\n            }else if(num2[l2]>num1[l1]){\\n                return false;\\n            }\\n            l1++;\\n            l2++;\\n        }\\n\\n        return l1!=num1.length;\\n\\n    }\\n\\n    \\n   \\n    \\n    //decreasing Monostack here max odering we can do is numlen-i-1>=remain keeping rest untouched\\n    public int[] getMaxSubsequence(int[] num, int maxSubArrCnt){\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int remain =maxSubArrCnt;\\n        for(int i =0;i<num.length;i++){\\n            while(!stack.isEmpty() && stack.peek()<num[i] && num.length-1-i>=remain){\\n                stack.pop();\\n                remain++;\\n            }\\n            if(remain>0){\\n                stack.push(num[i]);\\n                remain--;\\n            }\\n\\n        }\\n\\n        int[] maxSubArr = new int[maxSubArrCnt];\\n        int len = maxSubArr.length-1;\\n        while(!stack.isEmpty()){\\n            maxSubArr[len--] = stack.pop();\\n        }\\n\\n        return maxSubArr;\\n\\n    }\\n    \\n    \\n    \\n    \\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\n   public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\n        \\n\\n       \\n\\n       //LEFT boundary can start with max of 0 or k-num2.length\\n       //end or RIGHT boundary ends wid Min(k, num1.length)\\n        //If I take x from first array then remaining k-x from second array \\n        // boundary where we can traverse array element for subSeq is  \\n        //start with 0 or k-num2.len\\n        //e.g. num1=5 and num2=3 and k = 5\\n        // LEFT boundary 5-3 = 2  RIGHT = 5 \\n        int start = Math.max(0,k-nums2.length);  \\n        int end = Math.min(k, nums1.length);   \\n        int[] result =new int[k];\\n        int[] tmp=null;\\n    //try all combination in boundary which can result in max  \\n        for(int i=start;i<=end;i++){\\n\\t\\t\\t//find max subseqences\\n            int[] sub1 = getMaxSubsequence(nums1,i); \\n            int[] sub2 = getMaxSubsequence (nums2,k-i);\\n            //merge array\\n            tmp = merge(sub1,sub2);\\n\\t\\t\\t//store max in result\\n            if(isGreater(tmp,0,result,0)){\\n                result = tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1981642,
                "title": "c-wow-greedy-my-solution-haha",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool compute(vector<int> &s, vector<int> &nums, int k){\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(s.size() + (nums.size()-i) < k) break;\\n            while(s.size() && s.size() + (nums.size()-i) > k && s.back() < nums[i]) s.pop_back();\\n            if(s.size() < k) s.push_back(nums[i]);\\n        }\\n        \\n        return s.size() >= k;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<string, vector<string>, less<string>> q;\\n        string maxStr = \"\";\\n\\n        for(int i=0;i<=k;i++){\\n            vector<int> s1;\\n            vector<int> s2; \\n            \\n            int ptr1 = i;\\n            int ptr2 = k-i;\\n            \\n            bool ret1 = compute(s1, nums1, ptr1);\\n            bool ret2 = compute(s2, nums2, ptr2);\\n            \\n            string retStr = \"\";\\n            if(ret1 && ret2){\\n                int idx1 = 0;\\n                int idx2 = 0;\\n                while(idx1 < s1.size() && idx2 < s2.size()){               \\n                    if(s1 >= s2) retStr+=s1[idx1]+\\'0\\', s1.erase(s1.begin());\\n                    else retStr+=s2[idx2]+\\'0\\', s2.erase(s2.begin());\\n                }\\n                while(idx1 < s1.size()) retStr += s1[idx1++]+\\'0\\';\\n                while(idx2 < s2.size()) retStr += s2[idx2++]+\\'0\\';   \\n                \\n                if(maxStr < retStr) maxStr = retStr;\\n                // q.push(retStr);\\n            }\\n        }\\n        \\n        vector<int> vec;\\n        for(int i=0;i<maxStr.size();i++){\\n            vec.push_back(maxStr[i]-\\'0\\');\\n        }\\n        \\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool compute(vector<int> &s, vector<int> &nums, int k){\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(s.size() + (nums.size()-i) < k) break;\\n            while(s.size() && s.size() + (nums.size()-i) > k && s.back() < nums[i]) s.pop_back();\\n            if(s.size() < k) s.push_back(nums[i]);\\n        }\\n        \\n        return s.size() >= k;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<string, vector<string>, less<string>> q;\\n        string maxStr = \"\";\\n\\n        for(int i=0;i<=k;i++){\\n            vector<int> s1;\\n            vector<int> s2; \\n            \\n            int ptr1 = i;\\n            int ptr2 = k-i;\\n            \\n            bool ret1 = compute(s1, nums1, ptr1);\\n            bool ret2 = compute(s2, nums2, ptr2);\\n            \\n            string retStr = \"\";\\n            if(ret1 && ret2){\\n                int idx1 = 0;\\n                int idx2 = 0;\\n                while(idx1 < s1.size() && idx2 < s2.size()){               \\n                    if(s1 >= s2) retStr+=s1[idx1]+\\'0\\', s1.erase(s1.begin());\\n                    else retStr+=s2[idx2]+\\'0\\', s2.erase(s2.begin());\\n                }\\n                while(idx1 < s1.size()) retStr += s1[idx1++]+\\'0\\';\\n                while(idx2 < s2.size()) retStr += s2[idx2++]+\\'0\\';   \\n                \\n                if(maxStr < retStr) maxStr = retStr;\\n                // q.push(retStr);\\n            }\\n        }\\n        \\n        vector<int> vec;\\n        for(int i=0;i<maxStr.size();i++){\\n            vec.push_back(maxStr[i]-\\'0\\');\\n        }\\n        \\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950401,
                "title": "recurrsion-approach-92-test-passed",
                "content": "\\'\\'\\'\\n#include<bits/stdc++.h>\\nusing namespace std;\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    vector<int> ans ;\\n    vector<int> maxNumber(vector<int>& v1, vector<int>& v2, int k) \\n    {\\n        if(k == 0)\\n        {\\n            return ans ;\\n        }\\n        else\\n        {\\n            if(v1.size() < v2.size())\\n            {\\n                swap(v1 ,v2) ;\\n            }\\n            if(v2.size() == 0)\\n            {\\n                \\n                \\n                    int max = v1[0] ;\\n                    int indx = 0 ;\\n                    for (int i = 0; i < v1.size(); i++)\\n                    {\\n                        if(v1.size() - i >= k)\\n                        {\\n                            if(v1[i] > max)\\n                            {\\n                                max = v1[i] ;\\n                                indx = i ;\\n                            }\\n                        }\\n                        else\\n                        {\\n                            break ;\\n                        }\\n                    }\\n                    ans.push_back(max) ;\\n                    v1.erase(v1.begin() , v1.begin() + indx + 1) ;\\n                    k-- ;\\n                    return  maxNumber( v1, v2,  k) ;\\n                    \\n                \\n            }\\n\\n\\n            if(v1.size() == v2.size())\\n            {\\n                for (int i = 0; i < v1.size(); i++)\\n                {\\n                    if(v1[i] > v2[i])\\n                    {\\n                        break ;\\n                    }\\n                    else if(v1[i] == v2[i])\\n                    {\\n                        continue ;\\n                    }\\n                    else\\n                    {\\n                        swap(v1,v2) ;\\n                        break ;\\n                    }\\n                }\\n                \\n            }\\n            int m = v1.size() , n = v2.size() ; \\n            pair<int,int> max ;\\n            if(k == v1.size() + v2.size())\\n            {\\n                for (int i = 0; i < min(v1.size() , v2.size()); i++)\\n                {\\n                    if(v1[i] > v2[i])\\n                    {\\n                        break ;\\n                    }\\n                    if(v2[i] > v1[i])\\n                    {\\n                        swap(v1,v2) ;\\n                        break ;\\n                    }\\n                }\\n\\n                ans.push_back(v1[0]) ;\\n                v1.erase(v1.begin()) ;\\n                k-- ;\\n                return maxNumber( v1,  v2,  k) ;\\n                \\n            }\\n            if(v2.size() != 0)\\n            {\\n                max.first = v2[0] ;\\n                max.second = 2 ;\\n            }\\n            else\\n            {\\n                max.first = v1[0] ;\\n                max.second = 1 ;\\n            }\\n\\n\\n            int i = 0 , j = 0 ;\\n            for (int i = 0; i < m; i++)\\n            {\\n                for (int j = 0; j < n; j++)\\n                {\\n                    if(m - i + n - j >= k)\\n                    {\\n                        if(v1[i] > max.first)\\n                        {\\n                            max.first = v1[i] ;\\n                            max.second = 1 ;\\n                        }\\n                        if(v2[j] > max.first)\\n                        {\\n                            max.first = v2[j] ;\\n                            max.second = 2 ;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        break ;\\n                    }\\n                }\\n                \\n            }\\n\\n            ans.push_back(max.first) ;\\n\\n            if(max.second == 1)\\n            {\\n                int indx = 0 ;\\n                for (int i = 0; i < v1.size(); i++)\\n                {\\n                    if(v1[i] == max.first)\\n                    {\\n                        indx = i ;\\n                        break ;\\n                    }\\n                }\\n                v1.erase(v1.begin() , v1.begin() + indx + 1 ) ;\\n                k-- ;\\n                return maxNumber(v1, v2, k) ;\\n                \\n            }\\n            else\\n            {\\n                int indx = 0 ;\\n                for (int i = 0; i < v2.size(); i++)\\n                {\\n                    if(v2[i] == max.first)\\n                    {\\n                        indx = i ;\\n                        break ;\\n                    }\\n                }\\n                v2.erase(v2.begin() , v2.begin() + indx + 1 ) ;\\n                k-- ;\\n                return maxNumber(v1, v2, k) ;\\n            }\\n            \\n        \\n        }\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> ans ;\\n    vector<int> maxNumber(vector<int>& v1, vector<int>& v2, int k) \\n    {\\n        if(k == 0)\\n        {\\n            return ans ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1812492,
                "title": "c-merge-sln-o-max-n-m-3",
                "content": "```\\nvector<int> findMaxSubsequnce(const vector<int>& v, int k) {\\n        vector<int> ans;\\n        for (int i = 0, n = size(v); i < n; ++i) {\\n            const int left = n - i;\\n            while (!empty(ans) && size(ans) + left > k && v[i] > ans.back()) {\\n                ans.pop_back();\\n            }\\n            if (size(ans) < k) {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> merge(const vector<int>& v1, const vector<int>& v2) {\\n        const int n = size(v1);\\n        const int m = size(v2);\\n        int i = 0;\\n        int j = 0;\\n        vector<int> ans;\\n        while (i < n && j < m) {\\n            if (v1[i] > v2[j]) {\\n                ans.push_back(v1[i++]);\\n            }\\n            else if (v1[i] < v2[j]) {\\n                ans.push_back(v2[j++]);\\n            }\\n            else {\\n                if (!lexicographical_compare(cbegin(v1) + i, cend(v1), cbegin(v2) + j, cend(v2))) {\\n                    ans.push_back(v1[i++]);\\n                }\\n                else {\\n                    ans.push_back(v2[j++]);\\n                }\\n            }\\n        }\\n        while (i < n) {\\n            ans.push_back(v1[i++]);\\n        }\\n        while (j < m) {\\n            ans.push_back(v2[j++]);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& v1, vector<int>& v2, int k) {\\n        const int n = size(v1);\\n        const int m = size(v2);\\n        vector<int> ans;\\n        for (int i = 0; i <= k; ++i) {\\n            if (i <= n && k - i <= m) {\\n                ans = max(ans, merge(findMaxSubsequnce(v1, i), findMaxSubsequnce(v2, k - i)));\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nvector<int> findMaxSubsequnce(const vector<int>& v, int k) {\\n        vector<int> ans;\\n        for (int i = 0, n = size(v); i < n; ++i) {\\n            const int left = n - i;\\n            while (!empty(ans) && size(ans) + left > k && v[i] > ans.back()) {\\n                ans.pop_back();\\n            }\\n            if (size(ans) < k) {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> merge(const vector<int>& v1, const vector<int>& v2) {\\n        const int n = size(v1);\\n        const int m = size(v2);\\n        int i = 0;\\n        int j = 0;\\n        vector<int> ans;\\n        while (i < n && j < m) {\\n            if (v1[i] > v2[j]) {\\n                ans.push_back(v1[i++]);\\n            }\\n            else if (v1[i] < v2[j]) {\\n                ans.push_back(v2[j++]);\\n            }\\n            else {\\n                if (!lexicographical_compare(cbegin(v1) + i, cend(v1), cbegin(v2) + j, cend(v2))) {\\n                    ans.push_back(v1[i++]);\\n                }\\n                else {\\n                    ans.push_back(v2[j++]);\\n                }\\n            }\\n        }\\n        while (i < n) {\\n            ans.push_back(v1[i++]);\\n        }\\n        while (j < m) {\\n            ans.push_back(v2[j++]);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& v1, vector<int>& v2, int k) {\\n        const int n = size(v1);\\n        const int m = size(v2);\\n        vector<int> ans;\\n        for (int i = 0; i <= k; ++i) {\\n            if (i <= n && k - i <= m) {\\n                ans = max(ans, merge(findMaxSubsequnce(v1, i), findMaxSubsequnce(v2, k - i)));\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1742638,
                "title": "clear-and-concise-prerequisite-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void extract(vector<int>& nums, int m, vector<int>& t){\\n        int n = nums.size();\\n        int canBeRemoved = n-m;\\n        t.clear();\\n        for(int i:nums){\\n            while(canBeRemoved && !t.empty() && t.back() < i)\\n                t.pop_back(), canBeRemoved--;\\n            t.push_back(i);\\n        }\\n        while(canBeRemoved)\\n            t.pop_back(), canBeRemoved--;\\n    }\\n    \\n    int comparator(vector<int>& t1, vector<int>& t2, int m1, int m2){\\n        int n1 = t1.size();\\n        int n2 = t2.size();\\n        while(m1 < n1 && m2 < n2){\\n            if(t1[m1] > t2[m2])\\n                return 0;\\n            else if(t1[m1] < t2[m2])\\n                return 1;\\n            else\\n                m1++, m2++;\\n        }\\n        if(m1 == n1 && m2 == n2)\\n            return -1;\\n        if(m1 < n1)\\n            return 0;\\n        return 1;\\n    }\\n    \\n    void merge(vector<int>& t1, vector<int>& t2, vector<int>& maxi){\\n        vector<int> t;\\n        int i = 0, j = 0, n1 = t1.size(), n2 = t2.size(), idx1,idx2;\\n        while(i < n1 && j < n2){\\n            if(t1[i] > t2[j])\\n                t.push_back(t1[i++]);\\n            else if(t1[i] < t2[j])\\n                t.push_back(t2[j++]);\\n            else{\\n                if(comparator(t1,t2,i,j) == 0){\\n                    t.push_back(t1[i++]);\\n                } else\\n                    t.push_back(t2[j++]);\\n            }\\n        }\\n        while(i < n1)\\n            t.push_back(t1[i++]);\\n        while(j < n2)\\n            t.push_back(t2[j++]);\\n        \\n        if(t > maxi)\\n            for(int i = 0; i < t.size(); i++)\\n                maxi[i] = t[i];\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int rem = k;\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        int m1,m2;\\n        vector<int> t1, t2, ans(k,-1);\\n            for(int i = 0; i <= k; i++){\\n                m1 = i, m2 = k-i;\\n                if(m1 > n1 || m2 > n2)\\n                    continue;\\n                extract(nums1,m1,t1);\\n                extract(nums2,m2,t2);\\n                merge(t1,t2,ans);\\n            }\\n        return ans;\\n    }\\n};\\n```\\n\\nI suggest you to please solve this problem: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/)\\n\\nHere You will choose k elements from single array, you will come to know that my goal is\\n1. to maintain the sequence as increasing as possible, till you have option to ignore numbers\\n2. When k becomes zero, you will append all the elements at the end\\n\\nSame applies over here.\\nSince you will be given k <= m+n. It is impossible to find the sequence having any k elements from two arrays resulting into max number.\\n\\nchoices: \\n1. Array1: 0 element, Array2: k element\\n2. Array2: 1 element, Array2: k-1 element\\n3. ...\\n4. Array1: k. element, Array2: 0 element.\\n\\nFor each of the choice you apply the algorithm of Competitve sequence, after getting i, k-i element, merge them. Since now only motto is the rearrange the all k elements in the final vector, using merging of two sorted array time algorithm will suffice.",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void extract(vector<int>& nums, int m, vector<int>& t){\\n        int n = nums.size();\\n        int canBeRemoved = n-m;\\n        t.clear();\\n        for(int i:nums){\\n            while(canBeRemoved && !t.empty() && t.back() < i)\\n                t.pop_back(), canBeRemoved--;\\n            t.push_back(i);\\n        }\\n        while(canBeRemoved)\\n            t.pop_back(), canBeRemoved--;\\n    }\\n    \\n    int comparator(vector<int>& t1, vector<int>& t2, int m1, int m2){\\n        int n1 = t1.size();\\n        int n2 = t2.size();\\n        while(m1 < n1 && m2 < n2){\\n            if(t1[m1] > t2[m2])\\n                return 0;\\n            else if(t1[m1] < t2[m2])\\n                return 1;\\n            else\\n                m1++, m2++;\\n        }\\n        if(m1 == n1 && m2 == n2)\\n            return -1;\\n        if(m1 < n1)\\n            return 0;\\n        return 1;\\n    }\\n    \\n    void merge(vector<int>& t1, vector<int>& t2, vector<int>& maxi){\\n        vector<int> t;\\n        int i = 0, j = 0, n1 = t1.size(), n2 = t2.size(), idx1,idx2;\\n        while(i < n1 && j < n2){\\n            if(t1[i] > t2[j])\\n                t.push_back(t1[i++]);\\n            else if(t1[i] < t2[j])\\n                t.push_back(t2[j++]);\\n            else{\\n                if(comparator(t1,t2,i,j) == 0){\\n                    t.push_back(t1[i++]);\\n                } else\\n                    t.push_back(t2[j++]);\\n            }\\n        }\\n        while(i < n1)\\n            t.push_back(t1[i++]);\\n        while(j < n2)\\n            t.push_back(t2[j++]);\\n        \\n        if(t > maxi)\\n            for(int i = 0; i < t.size(); i++)\\n                maxi[i] = t[i];\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int rem = k;\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        int m1,m2;\\n        vector<int> t1, t2, ans(k,-1);\\n            for(int i = 0; i <= k; i++){\\n                m1 = i, m2 = k-i;\\n                if(m1 > n1 || m2 > n2)\\n                    continue;\\n                extract(nums1,m1,t1);\\n                extract(nums2,m2,t2);\\n                merge(t1,t2,ans);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629689,
                "title": "java-intuitive",
                "content": "Here in this solution 2 Utility functions are cretaed\\n1. **getMaxNumber(int[] arr, i9nt countOfRemove) :** This function takes the array and creates a maximum number by removing **countOfRemove** elements from the array.\\n2. **mergetwoArrays(String arr1, String arr2) :** This function takes two array in form of string and merges them. The concept is same as wer merge two arrays in merge sort, the difference is when we encounter equal element in both the array, in that case we simply  compare  the substring from that particular index and whichever is greater we take that value.\\n```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\t\\tString str = \"0\";\\n\\t\\tfor(int i=0;i<=k;i++){\\n\\t\\t\\tString temp1 = getMaxNumber(nums1,nums1.length - i);\\n\\t\\t\\tString temp2 = getMaxNumber(nums2,nums2.length - k+i);\\n\\t\\t\\tString finalAns = mergeTwoArray(temp1, temp2);\\n\\t\\t\\tif(str.length() <= finalAns.length()){\\n\\t\\t\\t\\tif(str.length() < finalAns.length())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr = finalAns;\\n\\t\\t\\t\\t}else if(str.compareTo(finalAns) < 0){\\n\\t\\t\\t\\t\\tstr = finalAns;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] arr = new int[str.length()];\\n\\t\\tint m = 0;\\n\\t\\tfor(char ch: str.toCharArray()){\\n\\t\\t\\tarr[m++] = ch - \\'0\\';\\n\\t\\t}\\n\\t\\treturn arr;\\n\\t}\\n\\n\\tprivate String getMaxNumber(int[] arr, int countOfRemove){\\n\\t\\tif(countOfRemove > arr.length) return Arrays.stream(arr).mapToObj(String::valueOf).collect(Collectors.joining());\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tint i = 0;\\n\\t\\twhile(i< arr.length && countOfRemove > 0){\\n\\t\\t\\tif(stack.isEmpty() || stack.peek() >= arr[i]){\\n\\t\\t\\t\\tstack.push(arr[i]);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\tcountOfRemove--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(i<arr.length){\\n\\t\\t\\tstack.push(arr[i++]);\\n\\t\\t}\\n\\t\\twhile(countOfRemove > 0){\\n\\t\\t\\tstack.pop();\\n\\t\\t\\tcountOfRemove--;\\n\\t\\t}\\n\\t\\treturn stack.stream().map(String::valueOf).collect(Collectors.joining());\\n\\t}\\n\\tprivate String mergeTwoArray(String str1, String str2){\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint left = 0, right = 0;\\n\\t\\twhile(left < str1.length() && right < str2.length()){\\n\\t\\t\\tif(str1.charAt(left) < str2.charAt(right)){\\n\\t\\t\\t\\tsb.append(str2.charAt(right));\\n\\t\\t\\t\\tright++;\\n\\t\\t\\t}else if(str1.charAt(left) > str2.charAt(right)){\\n\\t\\t\\t\\tsb.append(str1.charAt(left));\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tif(str1.substring(left).compareTo(str2.substring(right)) > 0){\\n\\t\\t\\t\\t\\tsb.append(str1.charAt(left));\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tsb.append(str2.charAt(right));\\n\\t\\t\\t\\t\\tright++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(left < str1.length()){\\n\\t\\t\\tsb.append(str1.charAt(left++));\\n\\t\\t}\\n\\t\\twhile(right < str2.length()){\\n\\t\\t\\tsb.append(str2.charAt(right++));\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\n\\t}\\n}\\n```\\n**Let me kow if video is required for explanation, happy to help !!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\t\\tString str = \"0\";\\n\\t\\tfor(int i=0;i<=k;i++){\\n\\t\\t\\tString temp1 = getMaxNumber(nums1,nums1.length - i);\\n\\t\\t\\tString temp2 = getMaxNumber(nums2,nums2.length - k+i);\\n\\t\\t\\tString finalAns = mergeTwoArray(temp1, temp2);\\n\\t\\t\\tif(str.length() <= finalAns.length()){\\n\\t\\t\\t\\tif(str.length() < finalAns.length())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr = finalAns;\\n\\t\\t\\t\\t}else if(str.compareTo(finalAns) < 0){\\n\\t\\t\\t\\t\\tstr = finalAns;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] arr = new int[str.length()];\\n\\t\\tint m = 0;\\n\\t\\tfor(char ch: str.toCharArray()){\\n\\t\\t\\tarr[m++] = ch - \\'0\\';\\n\\t\\t}\\n\\t\\treturn arr;\\n\\t}\\n\\n\\tprivate String getMaxNumber(int[] arr, int countOfRemove){\\n\\t\\tif(countOfRemove > arr.length) return Arrays.stream(arr).mapToObj(String::valueOf).collect(Collectors.joining());\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tint i = 0;\\n\\t\\twhile(i< arr.length && countOfRemove > 0){\\n\\t\\t\\tif(stack.isEmpty() || stack.peek() >= arr[i]){\\n\\t\\t\\t\\tstack.push(arr[i]);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\tcountOfRemove--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(i<arr.length){\\n\\t\\t\\tstack.push(arr[i++]);\\n\\t\\t}\\n\\t\\twhile(countOfRemove > 0){\\n\\t\\t\\tstack.pop();\\n\\t\\t\\tcountOfRemove--;\\n\\t\\t}\\n\\t\\treturn stack.stream().map(String::valueOf).collect(Collectors.joining());\\n\\t}\\n\\tprivate String mergeTwoArray(String str1, String str2){\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint left = 0, right = 0;\\n\\t\\twhile(left < str1.length() && right < str2.length()){\\n\\t\\t\\tif(str1.charAt(left) < str2.charAt(right)){\\n\\t\\t\\t\\tsb.append(str2.charAt(right));\\n\\t\\t\\t\\tright++;\\n\\t\\t\\t}else if(str1.charAt(left) > str2.charAt(right)){\\n\\t\\t\\t\\tsb.append(str1.charAt(left));\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tif(str1.substring(left).compareTo(str2.substring(right)) > 0){\\n\\t\\t\\t\\t\\tsb.append(str1.charAt(left));\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tsb.append(str2.charAt(right));\\n\\t\\t\\t\\t\\tright++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(left < str1.length()){\\n\\t\\t\\tsb.append(str1.charAt(left++));\\n\\t\\t}\\n\\t\\twhile(right < str2.length()){\\n\\t\\t\\tsb.append(str2.charAt(right++));\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593682,
                "title": "java-merging-solution",
                "content": "```\\nimport java.math.BigInteger;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\n\\nclass Leetcode {\\n    static boolean gt(ArrayList<Integer> a1, ArrayList<Integer> a2, int a1i, int a2i) {\\n        while (a1i < a1.size() && a2i < a2.size()) {\\n            if (a1.get(a1i) > a2.get(a2i))\\n                return true;\\n            if (a2.get(a2i) > a1.get(a1i))\\n                return false;\\n            a1i++;\\n            a2i++;\\n        }\\n        if (a1i >= a1.size())\\n            return false;\\n        else\\n            return true;\\n    }\\n\\n    static BigInteger merge(ArrayList<Integer> a1, ArrayList<Integer> a2) {\\n        StringBuilder num = new StringBuilder();\\n        int i = 0, j = 0;\\n        while (i < a1.size() || j < a2.size()) {\\n            if (gt(a1, a2, i, j)) {\\n                num.append(a1.get(i++));\\n            } else {\\n                num.append(a2.get(j++));\\n            }\\n        }\\n        return new BigInteger(num.toString());\\n    }\\n\\n\\n    static ArrayList<Integer> buildMaxSegmentUtil(int[] a, int sz) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        int taken = 0;\\n        int i = 0;\\n        while (taken < sz) {\\n            int remain = sz - taken;\\n            int j = a.length - remain;\\n            int maxi = i;\\n            int max = -1;\\n            for (int k = i; k <= j; k++)\\n                if (a[k] > max) {\\n                    max = a[k];\\n                    maxi = k;\\n                }\\n            res.add(a[maxi]);\\n            i = maxi + 1;\\n            taken++;\\n        }\\n        return res;\\n    }\\n\\n    static ArrayList<Integer>[] buildMaxSegment(int[] a, int k) {\\n        ArrayList<Integer>[] res = new ArrayList[k + 1];\\n        for (int i = 0; i <= k; i++) {\\n            if (i <= a.length)\\n                res[i] = buildMaxSegmentUtil(a, i);\\n        }\\n        return res;\\n    }\\n\\n\\n    public static int[] maxNumber(int[] x, int[] y, int k) {\\n        ArrayList<Integer>[] maxSegmentX = buildMaxSegment(x, k);\\n        ArrayList<Integer>[] maxSegmentY = buildMaxSegment(y, k);\\n        BigInteger mx = new BigInteger(\"-1\");\\n        for (int xCnt = 0; xCnt <= k; xCnt++) {\\n            int yCnt = k - xCnt;\\n            if (xCnt <= x.length && yCnt <= y.length) {\\n                BigInteger tmp = merge(maxSegmentX[xCnt], maxSegmentY[yCnt]);\\n                if (tmp.compareTo(mx) > 0)\\n                    mx = tmp;\\n            }\\n        }\\n        String mxSt = mx.toString();\\n        int[] res = new int[k];\\n        for (int i = 0; i < k; i++)\\n            res[i] = mxSt.charAt(i) - \\'0\\';\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\n\\nclass Leetcode {\\n    static boolean gt(ArrayList<Integer> a1, ArrayList<Integer> a2, int a1i, int a2i) {\\n        while (a1i < a1.size() && a2i < a2.size()) {\\n            if (a1.get(a1i) > a2.get(a2i))\\n                return true;\\n            if (a2.get(a2i) > a1.get(a1i))\\n                return false;\\n            a1i++;\\n            a2i++;\\n        }\\n        if (a1i >= a1.size())\\n            return false;\\n        else\\n            return true;\\n    }\\n\\n    static BigInteger merge(ArrayList<Integer> a1, ArrayList<Integer> a2) {\\n        StringBuilder num = new StringBuilder();\\n        int i = 0, j = 0;\\n        while (i < a1.size() || j < a2.size()) {\\n            if (gt(a1, a2, i, j)) {\\n                num.append(a1.get(i++));\\n            } else {\\n                num.append(a2.get(j++));\\n            }\\n        }\\n        return new BigInteger(num.toString());\\n    }\\n\\n\\n    static ArrayList<Integer> buildMaxSegmentUtil(int[] a, int sz) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        int taken = 0;\\n        int i = 0;\\n        while (taken < sz) {\\n            int remain = sz - taken;\\n            int j = a.length - remain;\\n            int maxi = i;\\n            int max = -1;\\n            for (int k = i; k <= j; k++)\\n                if (a[k] > max) {\\n                    max = a[k];\\n                    maxi = k;\\n                }\\n            res.add(a[maxi]);\\n            i = maxi + 1;\\n            taken++;\\n        }\\n        return res;\\n    }\\n\\n    static ArrayList<Integer>[] buildMaxSegment(int[] a, int k) {\\n        ArrayList<Integer>[] res = new ArrayList[k + 1];\\n        for (int i = 0; i <= k; i++) {\\n            if (i <= a.length)\\n                res[i] = buildMaxSegmentUtil(a, i);\\n        }\\n        return res;\\n    }\\n\\n\\n    public static int[] maxNumber(int[] x, int[] y, int k) {\\n        ArrayList<Integer>[] maxSegmentX = buildMaxSegment(x, k);\\n        ArrayList<Integer>[] maxSegmentY = buildMaxSegment(y, k);\\n        BigInteger mx = new BigInteger(\"-1\");\\n        for (int xCnt = 0; xCnt <= k; xCnt++) {\\n            int yCnt = k - xCnt;\\n            if (xCnt <= x.length && yCnt <= y.length) {\\n                BigInteger tmp = merge(maxSegmentX[xCnt], maxSegmentY[yCnt]);\\n                if (tmp.compareTo(mx) > 0)\\n                    mx = tmp;\\n            }\\n        }\\n        String mxSt = mx.toString();\\n        int[] res = new int[k];\\n        for (int i = 0; i < k; i++)\\n            res[i] = mxSt.charAt(i) - \\'0\\';\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453068,
                "title": "rust-translation-from-c",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_number(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        let n1 = nums1.len();\\n        let n2 = nums2.len();\\n        let k = k as usize;\\n        let mut max_merged = None;\\n        for size1 in 0..=k.min(n1) {\\n            let size2 = k - size1;\\n            if size2 > n2 {\\n                continue;\\n            }\\n            let max1 = Self::max_one(&nums1, size1);\\n            let max2 = Self::max_one(&nums2, size2);\\n            let max3 = Self::max_merge(max1, max2);\\n            if let Some(max) = max_merged {\\n                if max < max3 {\\n                    max_merged = Some(max3);\\n                } else {\\n                    max_merged = Some(max);\\n                }\\n            } else {\\n                max_merged = Some(max3);\\n            }\\n        }\\n        max_merged.unwrap()\\n    }\\n\\n    fn max_one(nums: &[i32], k: usize) -> Vec<i32> {\\n        let mut stack = Vec::new();\\n        let n = nums.len();\\n        for (i, &num) in nums.iter().enumerate().take(n) {\\n            let right = n - i;\\n            while let Some(&top) = stack.last() {\\n                if top < num && stack.len() + right > k {\\n                    stack.pop();\\n                } else {\\n                    break;\\n                }\\n            }\\n            stack.push(num);\\n        }\\n        while stack.len() > k {\\n            stack.pop();\\n        }\\n        stack\\n    }\\n\\n    fn max_merge(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\\n        let mut res = Vec::new();\\n        let mut i = 0;\\n        let mut j = 0;\\n        loop {\\n            if i < nums1.len() && j < nums2.len() {\\n                if Self::greater(&nums1, &nums2, i, j) {\\n                    res.push(nums1[i]);\\n                    i += 1;\\n                } else {\\n                    res.push(nums2[j]);\\n                    j += 1;\\n                }\\n                continue;\\n            }\\n            if i < nums1.len() {\\n                res.push(nums1[i]);\\n                i += 1;\\n                continue;\\n            }\\n            if j < nums2.len() {\\n                res.push(nums2[j]);\\n                j += 1;\\n                continue;\\n            }\\n            break;\\n        }\\n        res\\n    }\\n\\n    fn greater(nums1: &[i32], nums2: &[i32], mut i: usize, mut j: usize) -> bool {\\n        while i < nums1.len() && j < nums2.len() && nums1[i] == nums2[j] {\\n            i += 1;\\n            j += 1;\\n        }\\n        j == nums2.len() || (i < nums1.len() && nums1[i] > nums2[j])\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_number(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        let n1 = nums1.len();\\n        let n2 = nums2.len();\\n        let k = k as usize;\\n        let mut max_merged = None;\\n        for size1 in 0..=k.min(n1) {\\n            let size2 = k - size1;\\n            if size2 > n2 {\\n                continue;\\n            }\\n            let max1 = Self::max_one(&nums1, size1);\\n            let max2 = Self::max_one(&nums2, size2);\\n            let max3 = Self::max_merge(max1, max2);\\n            if let Some(max) = max_merged {\\n                if max < max3 {\\n                    max_merged = Some(max3);\\n                } else {\\n                    max_merged = Some(max);\\n                }\\n            } else {\\n                max_merged = Some(max3);\\n            }\\n        }\\n        max_merged.unwrap()\\n    }\\n\\n    fn max_one(nums: &[i32], k: usize) -> Vec<i32> {\\n        let mut stack = Vec::new();\\n        let n = nums.len();\\n        for (i, &num) in nums.iter().enumerate().take(n) {\\n            let right = n - i;\\n            while let Some(&top) = stack.last() {\\n                if top < num && stack.len() + right > k {\\n                    stack.pop();\\n                } else {\\n                    break;\\n                }\\n            }\\n            stack.push(num);\\n        }\\n        while stack.len() > k {\\n            stack.pop();\\n        }\\n        stack\\n    }\\n\\n    fn max_merge(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\\n        let mut res = Vec::new();\\n        let mut i = 0;\\n        let mut j = 0;\\n        loop {\\n            if i < nums1.len() && j < nums2.len() {\\n                if Self::greater(&nums1, &nums2, i, j) {\\n                    res.push(nums1[i]);\\n                    i += 1;\\n                } else {\\n                    res.push(nums2[j]);\\n                    j += 1;\\n                }\\n                continue;\\n            }\\n            if i < nums1.len() {\\n                res.push(nums1[i]);\\n                i += 1;\\n                continue;\\n            }\\n            if j < nums2.len() {\\n                res.push(nums2[j]);\\n                j += 1;\\n                continue;\\n            }\\n            break;\\n        }\\n        res\\n    }\\n\\n    fn greater(nums1: &[i32], nums2: &[i32], mut i: usize, mut j: usize) -> bool {\\n        while i < nums1.len() && j < nums2.len() && nums1[i] == nums2[j] {\\n            i += 1;\\n            j += 1;\\n        }\\n        j == nums2.len() || (i < nums1.len() && nums1[i] > nums2[j])\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1427203,
                "title": "c-dp-and-merge-solution",
                "content": "we first find out all of possible length combination of nums1 and nums2, and try all of them.\\nwe build a dp array to construct largest lexicographical subseqence of specific length, and merge two subseqence into required answer.\\nmy code:\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> d1,d2;\\n    vector<int> a,b;\\n    void merge(vector<int> &ans,vector<int> &num1,vector<int> &num2,int len1,int len2) {\\n        a.resize(len1+1,0),b.resize(len2+1,0);\\n        a[len1]=INT_MIN,b[len2]=INT_MIN;\\n        int len=0,pos=0;\\n        while(len!=len1){\\n            pos=d1[pos][num1.size()-1-len1+len],a[len]=num1[pos],len++,pos++;\\n        }\\n        len=0,pos=0;\\n        while(len!=len2){\\n            pos=d2[pos][num2.size()-1-len2+len],b[len]=num2[pos],len++,pos++;\\n        }\\n        bool equal=true;\\n        for(int i=0,j=0,k=0;i<len1+len2;i++){\\n            if(a[j]>b[k]){\\n                if(ans[i]>a[j]&&equal) return;\\n                if(ans[i]!=a[j]) equal=false;\\n                ans[i]=a[j],j++;\\n            }\\n            else if(b[k]>a[j]){\\n                if(ans[i]>b[k]&&equal) return;\\n                if(ans[i]!=b[k]) equal=false;\\n                ans[i]=b[k],k++;\\n            }\\n            else{\\n                bool ct=true;\\n                if(ans[i]>a[j]&&equal) return;\\n                int x=j,y=k;\\n                while(1){\\n                    if(a[x]>b[y]){\\n                        ct=true;\\n                        break;\\n                    } \\n                    if(b[y]>a[x]){\\n                        ct=false;\\n                        break;\\n                    }\\n                    if(x==len1&&y==len2){\\n                        ct=true;\\n                        break;\\n                    }\\n                    x++,y++;\\n                }\\n                if(ct){\\n                    if(ans[i]!=a[j]) equal=false;\\n                    ans[i]=a[j],j++;\\n                }\\n                else{\\n                    if(ans[i]!=b[k]) equal=false;\\n                    ans[i]=b[k],k++;\\n                }\\n            }\\n        }\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size(),m=nums2.size();\\n        vector<int> ans(k,0);\\n        nums1.push_back(-1),nums2.push_back(-1);\\n        d1.resize(n,vector<int>(n,n));\\n        d2.resize(m,vector<int>(m,m));\\n        d1[0][0]=0;\\n        for(int i=1;i<n;i++){\\n            d1[0][i]=d1[0][i-1];\\n            if(nums1[i]>nums1[d1[0][i-1]]) d1[0][i]=i;\\n        }\\n        for(int i=1;i<n;i++)\\n            for(int j=i;j<n;j++){\\n                d1[i][j]=d1[i][j-1];\\n                if(nums1[j]>nums1[d1[i][j-1]]) d1[i][j]=j;\\n            }\\n        d2[0][0]=0;\\n        for(int i=1;i<m;i++){\\n            d2[0][i]=d2[0][i-1];\\n            if(nums2[i]>nums2[d2[0][i-1]]) d2[0][i]=i;\\n        }\\n        for(int i=1;i<m;i++)\\n            for(int j=i;j<m;j++){\\n                d2[i][j]=d2[i][j-1];\\n                if(nums2[j]>nums2[d2[i][j-1]]) d2[i][j]=j;\\n            }\\n        for(int j=m,i=k-m;i<=n;i++,j--){\\n            if(i>=0&&j>=0) merge(ans,nums1,nums2,i,j);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> d1,d2;\\n    vector<int> a,b;\\n    void merge(vector<int> &ans,vector<int> &num1,vector<int> &num2,int len1,int len2) {\\n        a.resize(len1+1,0),b.resize(len2+1,0);\\n        a[len1]=INT_MIN,b[len2]=INT_MIN;\\n        int len=0,pos=0;\\n        while(len!=len1){\\n            pos=d1[pos][num1.size()-1-len1+len],a[len]=num1[pos],len++,pos++;\\n        }\\n        len=0,pos=0;\\n        while(len!=len2){\\n            pos=d2[pos][num2.size()-1-len2+len],b[len]=num2[pos],len++,pos++;\\n        }\\n        bool equal=true;\\n        for(int i=0,j=0,k=0;i<len1+len2;i++){\\n            if(a[j]>b[k]){\\n                if(ans[i]>a[j]&&equal) return;\\n                if(ans[i]!=a[j]) equal=false;\\n                ans[i]=a[j],j++;\\n            }\\n            else if(b[k]>a[j]){\\n                if(ans[i]>b[k]&&equal) return;\\n                if(ans[i]!=b[k]) equal=false;\\n                ans[i]=b[k],k++;\\n            }\\n            else{\\n                bool ct=true;\\n                if(ans[i]>a[j]&&equal) return;\\n                int x=j,y=k;\\n                while(1){\\n                    if(a[x]>b[y]){\\n                        ct=true;\\n                        break;\\n                    } \\n                    if(b[y]>a[x]){\\n                        ct=false;\\n                        break;\\n                    }\\n                    if(x==len1&&y==len2){\\n                        ct=true;\\n                        break;\\n                    }\\n                    x++,y++;\\n                }\\n                if(ct){\\n                    if(ans[i]!=a[j]) equal=false;\\n                    ans[i]=a[j],j++;\\n                }\\n                else{\\n                    if(ans[i]!=b[k]) equal=false;\\n                    ans[i]=b[k],k++;\\n                }\\n            }\\n        }\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size(),m=nums2.size();\\n        vector<int> ans(k,0);\\n        nums1.push_back(-1),nums2.push_back(-1);\\n        d1.resize(n,vector<int>(n,n));\\n        d2.resize(m,vector<int>(m,m));\\n        d1[0][0]=0;\\n        for(int i=1;i<n;i++){\\n            d1[0][i]=d1[0][i-1];\\n            if(nums1[i]>nums1[d1[0][i-1]]) d1[0][i]=i;\\n        }\\n        for(int i=1;i<n;i++)\\n            for(int j=i;j<n;j++){\\n                d1[i][j]=d1[i][j-1];\\n                if(nums1[j]>nums1[d1[i][j-1]]) d1[i][j]=j;\\n            }\\n        d2[0][0]=0;\\n        for(int i=1;i<m;i++){\\n            d2[0][i]=d2[0][i-1];\\n            if(nums2[i]>nums2[d2[0][i-1]]) d2[0][i]=i;\\n        }\\n        for(int i=1;i<m;i++)\\n            for(int j=i;j<m;j++){\\n                d2[i][j]=d2[i][j-1];\\n                if(nums2[j]>nums2[d2[i][j-1]]) d2[i][j]=j;\\n            }\\n        for(int j=m,i=k-m;i<=n;i++,j--){\\n            if(i>=0&&j>=0) merge(ans,nums1,nums2,i,j);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402477,
                "title": "greedy-javascript-solution",
                "content": "```\\nvar maxNumber = function (nums1, nums2, k) {\\n    let max = Array(k).fill(0);\\n\\n    const findMaxArray = (num, len) => {\\n        let pop = num.length - len,\\n            stack = [],\\n            i = 0;\\n        while (i < num.length) {\\n            while (pop && stack.length && stack[stack.length - 1] < num[i]) {\\n                stack.pop();\\n                pop--;\\n            }\\n            stack.push(num[i++]);\\n        }\\n        return stack.slice(0, len);\\n    };\\n    \\n    const greater = (num1, i, num2, j) => {\\n        while (i < num1.length && j < num2.length && num1[i] == num2[j]) {\\n            i++;\\n            j++;\\n        }\\n        return j == num2.length || num1[i] > num2[j];\\n    };\\n\\n    const merge = (num1, num2) => {\\n        let i = 0,\\n            j = 0,\\n            combinedArr = [];\\n        while (i < num1.length || j < num2.length)\\n            combinedArr.push(greater(num1, i, num2, j) ? num1[i++] : num2[j++]);\\n        return combinedArr;\\n    };\\n\\n    for (let i = Math.min(k, nums1.length); i >= 0 && k - i <= nums2.length; i--) {\\n        let combinedArray = merge(findMaxArray(nums1, i), findMaxArray(nums2, k - i));\\n        if (greater(combinedArray, 0, max, 0))\\n            max = combinedArray;\\n    }\\n    return max;\\n};\\n",
                "solutionTags": [],
                "code": "```\\nvar maxNumber = function (nums1, nums2, k) {\\n    let max = Array(k).fill(0);\\n\\n    const findMaxArray = (num, len) => {\\n        let pop = num.length - len,\\n            stack = [],\\n            i = 0;\\n        while (i < num.length) {\\n            while (pop && stack.length && stack[stack.length - 1] < num[i]) {\\n                stack.pop();\\n                pop--;\\n            }\\n            stack.push(num[i++]);\\n        }\\n        return stack.slice(0, len);\\n    };\\n    \\n    const greater = (num1, i, num2, j) => {\\n        while (i < num1.length && j < num2.length && num1[i] == num2[j]) {\\n            i++;\\n            j++;\\n        }\\n        return j == num2.length || num1[i] > num2[j];\\n    };\\n\\n    const merge = (num1, num2) => {\\n        let i = 0,\\n            j = 0,\\n            combinedArr = [];\\n        while (i < num1.length || j < num2.length)\\n            combinedArr.push(greater(num1, i, num2, j) ? num1[i++] : num2[j++]);\\n        return combinedArr;\\n    };\\n\\n    for (let i = Math.min(k, nums1.length); i >= 0 && k - i <= nums2.length; i--) {\\n        let combinedArray = merge(findMaxArray(nums1, i), findMaxArray(nums2, k - i));\\n        if (greater(combinedArray, 0, max, 0))\\n            max = combinedArray;\\n    }\\n    return max;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1380730,
                "title": "java-drop-and-merge-for-differet-intervals",
                "content": "**Explanation:**\\n1. Code may seem to be un readable.\\n2. Logic is simple.\\n3. add() -\\n\\t1.  finds max number for one array at a time for different size (0<=size<=k)\\n\\t2.  logic - by dropping the lower number (a[i]<a[i+1]) from the given array.\\n4. updateResult() -\\n\\t1. merges the two lists representing maximum number of the 2 given arrays for different sizes.\\n\\t2. while merging itself it compare with previous result and breaks if current number seems to be lower else continues.\\n\\t2. consider k=5, one possible merge will be - maximum number of size 2 from 1st array + maximum number of size 3 from 2nd array. After merge, 2+3=5 will give the answer.\\n\\t3. logic - like merging used in merge sort. But there is a problem, the 2 maximum number lists are not guranteed to be in sorted way.\\n\\t4. list1 - represents maximum number from nums1,\\n\\t5. list2 - represents maximum number from nums2,\\n\\t6. if list1[i]>list2[j], add list1[i] to the result and iterate i.\\n\\t7. if list1[i]<list2[j], add list2[j] to the result and iterate j.\\n\\t8. if they are equal, find in which list, greater number pops up earlier. if it happens in list1, add list1[i] to result and increment i else add list2[j] and increment j.\\n\\n```\\nclass Solution {\\n    public void add(ArrayList<Integer> list, int[] nums, int k)\\n    {\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            list.add(nums[i]);\\n        }\\n        int l=list.size();\\n        int i=0;\\n        while(l>k && i<l-1)\\n        {\\n            if(list.get(i)<list.get(i+1))\\n            {\\n                list.remove(i);\\n                i=0;\\n                l--;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        while(l>k)\\n        {\\n            list.remove(l-1);\\n            l--;\\n        }\\n    }\\n    public void updateResult(int[] res, ArrayList<Integer> list1, ArrayList<Integer> list2, int k)\\n    {\\n        if(list1.size()+list2.size()<k)\\n        {\\n            return;\\n        }\\n        int i=0, j=0, t=0;\\n        int accepted=0;\\n        while(i<list1.size() && j<list2.size())\\n        {\\n            if(list1.get(i)>list2.get(j))\\n            {\\n                if(accepted!=2)\\n                {\\n                    if(res[t]<list1.get(i))\\n                    {\\n                        accepted=2;\\n                    }\\n                    else if(accepted!=2 && res[t]==list1.get(i))\\n                    {\\n                        accepted=1;\\n                    }\\n                    if(accepted==0)\\n                    {\\n                        break;\\n                    }   \\n                }\\n                res[t]=list1.get(i);\\n                i++;\\n                t++;\\n            }\\n            else if(list1.get(i)<list2.get(j))\\n            {\\n                if(accepted!=2)\\n                {\\n                    if(res[t]<list2.get(j))\\n                    {\\n                        accepted=2;\\n                    }\\n                    else if(accepted!=2 && res[t]==list2.get(j))\\n                    {\\n                        accepted=1;\\n                    }\\n                    if(accepted==0)\\n                    {\\n                        break;\\n                    }   \\n                }\\n                res[t]=list2.get(j);\\n                j++;\\n                t++;\\n            }\\n            else\\n            {\\n                if(accepted!=2)\\n                {\\n                    if(res[t]<list1.get(i))\\n                    {\\n                        accepted=2;\\n                    }\\n                    else if(res[t]==list1.get(i))\\n                    {\\n                        accepted=1;\\n                    }\\n                    if(accepted==0)\\n                    {\\n                        break;\\n                    }\\n                }\\n                res[t]=list1.get(i);\\n                int x=i+1, y=j+1;\\n                boolean unEqualFound=false;\\n                while(x<list1.size() && y<list2.size())\\n                {\\n                    if(list1.get(x)>list2.get(y))\\n                    {\\n                        i++;\\n                    }\\n                    else if(list1.get(x)<list2.get(y))\\n                    {\\n                        j++;\\n                    }\\n                    if(list1.get(x)==list2.get(y))\\n                    {\\n                        x++;\\n                        y++;\\n                    }\\n                    else\\n                    {\\n                        unEqualFound=true;\\n                        break;\\n                    }\\n                }\\n                if(!unEqualFound)\\n                {\\n                    if(x<list1.size())\\n                    {\\n                        i++;\\n                    }\\n                    else\\n                    {\\n                        j++;\\n                    }   \\n                }\\n                t++;\\n            }\\n            if(t==k)\\n            {\\n                break;\\n            }\\n            if(accepted==1)\\n            {\\n                accepted=0;\\n            }\\n        }\\n        while(i<list1.size())\\n        {\\n            if(accepted!=2)\\n            {\\n                if(res[t]<list1.get(i))\\n                {\\n                    accepted=2;\\n                }\\n                else if(accepted!=2 && res[t]==list1.get(i))\\n                {\\n                    accepted=1;\\n                }\\n                if(accepted==0)\\n                {\\n                    break;\\n                }   \\n            }\\n            res[t]=list1.get(i);\\n            t++;\\n            i++;\\n            if(t==k)\\n            {\\n                break;\\n            }\\n            if(accepted==1)\\n            {\\n                accepted=0;\\n            }\\n        }\\n        while(j<list2.size())\\n        {\\n            if(accepted!=2)\\n            {\\n                if(res[t]<list2.get(j))\\n                {\\n                    accepted=2;\\n                }\\n                else if(accepted!=2 && res[t]==list2.get(j))\\n                {\\n                    accepted=1;\\n                }\\n                if(accepted==0)\\n                {\\n                    break;\\n                }   \\n            }\\n            res[t]=list2.get(j);\\n            j++;\\n            t++;\\n            if(t==k)\\n            {\\n                break;\\n            }\\n            if(accepted==1)\\n            {\\n                accepted=0;\\n            }\\n        }\\n    }\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] res=new int[k];\\n        for(int j=0; j<=k; j++)\\n        {\\n            ArrayList<Integer> list1=new ArrayList<>();\\n            ArrayList<Integer> list2=new ArrayList<>();\\n            add(list1, nums1, k-j);\\n            add(list2, nums2, k-list1.size());\\n            updateResult(res, list1, list2, k);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void add(ArrayList<Integer> list, int[] nums, int k)\\n    {\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            list.add(nums[i]);\\n        }\\n        int l=list.size();\\n        int i=0;\\n        while(l>k && i<l-1)\\n        {\\n            if(list.get(i)<list.get(i+1))\\n            {\\n                list.remove(i);\\n                i=0;\\n                l--;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        while(l>k)\\n        {\\n            list.remove(l-1);\\n            l--;\\n        }\\n    }\\n    public void updateResult(int[] res, ArrayList<Integer> list1, ArrayList<Integer> list2, int k)\\n    {\\n        if(list1.size()+list2.size()<k)\\n        {\\n            return;\\n        }\\n        int i=0, j=0, t=0;\\n        int accepted=0;\\n        while(i<list1.size() && j<list2.size())\\n        {\\n            if(list1.get(i)>list2.get(j))\\n            {\\n                if(accepted!=2)\\n                {\\n                    if(res[t]<list1.get(i))\\n                    {\\n                        accepted=2;\\n                    }\\n                    else if(accepted!=2 && res[t]==list1.get(i))\\n                    {\\n                        accepted=1;\\n                    }\\n                    if(accepted==0)\\n                    {\\n                        break;\\n                    }   \\n                }\\n                res[t]=list1.get(i);\\n                i++;\\n                t++;\\n            }\\n            else if(list1.get(i)<list2.get(j))\\n            {\\n                if(accepted!=2)\\n                {\\n                    if(res[t]<list2.get(j))\\n                    {\\n                        accepted=2;\\n                    }\\n                    else if(accepted!=2 && res[t]==list2.get(j))\\n                    {\\n                        accepted=1;\\n                    }\\n                    if(accepted==0)\\n                    {\\n                        break;\\n                    }   \\n                }\\n                res[t]=list2.get(j);\\n                j++;\\n                t++;\\n            }\\n            else\\n            {\\n                if(accepted!=2)\\n                {\\n                    if(res[t]<list1.get(i))\\n                    {\\n                        accepted=2;\\n                    }\\n                    else if(res[t]==list1.get(i))\\n                    {\\n                        accepted=1;\\n                    }\\n                    if(accepted==0)\\n                    {\\n                        break;\\n                    }\\n                }\\n                res[t]=list1.get(i);\\n                int x=i+1, y=j+1;\\n                boolean unEqualFound=false;\\n                while(x<list1.size() && y<list2.size())\\n                {\\n                    if(list1.get(x)>list2.get(y))\\n                    {\\n                        i++;\\n                    }\\n                    else if(list1.get(x)<list2.get(y))\\n                    {\\n                        j++;\\n                    }\\n                    if(list1.get(x)==list2.get(y))\\n                    {\\n                        x++;\\n                        y++;\\n                    }\\n                    else\\n                    {\\n                        unEqualFound=true;\\n                        break;\\n                    }\\n                }\\n                if(!unEqualFound)\\n                {\\n                    if(x<list1.size())\\n                    {\\n                        i++;\\n                    }\\n                    else\\n                    {\\n                        j++;\\n                    }   \\n                }\\n                t++;\\n            }\\n            if(t==k)\\n            {\\n                break;\\n            }\\n            if(accepted==1)\\n            {\\n                accepted=0;\\n            }\\n        }\\n        while(i<list1.size())\\n        {\\n            if(accepted!=2)\\n            {\\n                if(res[t]<list1.get(i))\\n                {\\n                    accepted=2;\\n                }\\n                else if(accepted!=2 && res[t]==list1.get(i))\\n                {\\n                    accepted=1;\\n                }\\n                if(accepted==0)\\n                {\\n                    break;\\n                }   \\n            }\\n            res[t]=list1.get(i);\\n            t++;\\n            i++;\\n            if(t==k)\\n            {\\n                break;\\n            }\\n            if(accepted==1)\\n            {\\n                accepted=0;\\n            }\\n        }\\n        while(j<list2.size())\\n        {\\n            if(accepted!=2)\\n            {\\n                if(res[t]<list2.get(j))\\n                {\\n                    accepted=2;\\n                }\\n                else if(accepted!=2 && res[t]==list2.get(j))\\n                {\\n                    accepted=1;\\n                }\\n                if(accepted==0)\\n                {\\n                    break;\\n                }   \\n            }\\n            res[t]=list2.get(j);\\n            j++;\\n            t++;\\n            if(t==k)\\n            {\\n                break;\\n            }\\n            if(accepted==1)\\n            {\\n                accepted=0;\\n            }\\n        }\\n    }\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] res=new int[k];\\n        for(int j=0; j<=k; j++)\\n        {\\n            ArrayList<Integer> list1=new ArrayList<>();\\n            ArrayList<Integer> list2=new ArrayList<>();\\n            add(list1, nums1, k-j);\\n            add(list2, nums2, k-list1.size());\\n            updateResult(res, list1, list2, k);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270634,
                "title": "go-4ms-100-100-standard-greedy-solution",
                "content": "Leaving this here in case someone is more comfortable with Go than the previously posted solutions / languages.\\n\\n```go\\nfunc maxNumber(nums1 []int, nums2 []int, k int) []int {\\n\\tn := len(nums1)\\n\\tm := len(nums2)\\n\\n\\t// Each number is definitely smaller than 256 => uint8\\n\\tn1 := make([]uint8, n)\\n\\tfor i, n := range nums1 {\\n\\t\\tn1[i] = uint8(n)\\n\\t}\\n\\tn2 := make([]uint8, m)\\n\\tfor i, n := range nums2 {\\n\\t\\tn2[i] = uint8(n)\\n\\t}\\n\\n\\t// The goal is to pick k items from the two arrays so that the combination\\n\\t// is the greatest possible sequence. The problem is that it is not clear how\\n\\t// many items should be picked from each array, let\\'s call this (k1, k2) where\\n\\t// k = k1+k2. Assuming k == 2, then (k1, k2) can take on (0,2), (1,1), (2,0).\\n\\t// Then combine the max sequence given k1 items in nums1, and k2 items \\n\\t// in nums2.\\n\\tfromFirst := min(n, k)\\n\\tfromSecond := max(0, k-fromFirst)\\n\\n\\tvar bestResult []uint8\\n\\tfor fromFirst >= 0 && fromSecond <= min(k, m) {\\n\\t\\ta := maxNumSingle(n1, fromFirst)\\n\\t\\tb := maxNumSingle(n2, fromSecond)\\n\\t\\tmerged := merge(a, b, fromFirst, fromSecond)\\n\\t\\tif len(bestResult) == 0 || greater(merged, bestResult, k, k, 0, 0) {\\n\\t\\t\\tbestResult = merged\\n\\t\\t}\\n\\t\\tfromFirst--\\n\\t\\tfromSecond++\\n\\t}\\n\\tres := make([]int, k)\\n\\tfor i, num := range bestResult {\\n\\t\\tres[i] = int(num)\\n\\t}\\n\\treturn res\\n}\\n\\n// merge merges the two arrays a and b optimally.\\nfunc merge(a, b []uint8, n, m int) []uint8 {\\n\\tres := make([]uint8, m+n)\\n\\tvar i, j int\\n\\tfor k := 0; k < m+n; k++ {\\n\\t\\tif greater(a, b, n, m, i, j) {\\n\\t\\t\\tres[k] = a[i]\\n\\t\\t\\ti++\\n\\t\\t} else {\\n\\t\\t\\tres[k] = b[j]\\n\\t\\t\\tj++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n// greater compares the provided lists of integers. If the length of one array\\n// is shorted than another, and they are otherwise equal, the longer array is\\n// returned. The reasoning behind this is that the partial array is always at\\n// least as good as the full array. For example, given [1,2], [1,2,3], choosing\\n// the first shorter array would force the use of 1 in the second array, which\\n// is sub-optimal.\\nfunc greater(a, b []uint8, n, m, i, j int) bool {\\n\\tfor ; i < n && j < m; i, j = i+1, j+1 {\\n\\t\\tif a[i] != b[j] {\\n\\t\\t\\treturn a[i] > b[j]\\n\\t\\t}\\n\\t}\\n\\treturn i != n\\n}\\n\\n// maxNumSingle calculates the max sequence in nums of length k.\\nfunc maxNumSingle(nums []uint8, k int) []uint8 {\\n\\t// Stack contains k elements sorted in descending order until it is absolutely\\n\\t// necessary to add more elements. For example, if k == len(nums), then the\\n\\t// result is simply the entire nums array. If k == len(nums)-1, it is ok to\\n\\t// bubble a number at most once.\\n\\tstack := make(uint8Stack, 0, k)\\n\\tn := len(nums)\\n\\tfor i, num := range nums {\\n\\t\\t// If num is greater than any elements in the stack, and there is enough\\n\\t\\t// elements in nums to fill up the remainder, then clean up the stack to\\n\\t\\t// make room for num.\\n\\t\\titemsLeft := n - i\\n\\t\\tfor len(stack) > 0 && itemsLeft > k-len(stack) && num > stack.peek() {\\n\\t\\t\\tstack.pop()\\n\\t\\t}\\n\\t\\tif len(stack) < k {\\n\\t\\t\\tstack.push(num)\\n\\t\\t}\\n\\t}\\n\\treturn stack\\n}\\n\\ntype uint8Stack []uint8\\n\\nfunc (s uint8Stack) peek() uint8 {\\n\\treturn s[len(s)-1]\\n}\\n\\nfunc (s *uint8Stack) pop() uint8 {\\n\\tn := len(*s)\\n\\tit := (*s)[n-1]\\n\\t*s = (*s)[:n-1]\\n\\treturn it\\n}\\n\\nfunc (s *uint8Stack) push(x uint8) {\\n\\t*s = append(*s, x)\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc maxNumber(nums1 []int, nums2 []int, k int) []int {\\n\\tn := len(nums1)\\n\\tm := len(nums2)\\n\\n\\t// Each number is definitely smaller than 256 => uint8\\n\\tn1 := make([]uint8, n)\\n\\tfor i, n := range nums1 {\\n\\t\\tn1[i] = uint8(n)\\n\\t}\\n\\tn2 := make([]uint8, m)\\n\\tfor i, n := range nums2 {\\n\\t\\tn2[i] = uint8(n)\\n\\t}\\n\\n\\t// The goal is to pick k items from the two arrays so that the combination\\n\\t// is the greatest possible sequence. The problem is that it is not clear how\\n\\t// many items should be picked from each array, let\\'s call this (k1, k2) where\\n\\t// k = k1+k2. Assuming k == 2, then (k1, k2) can take on (0,2), (1,1), (2,0).\\n\\t// Then combine the max sequence given k1 items in nums1, and k2 items \\n\\t// in nums2.\\n\\tfromFirst := min(n, k)\\n\\tfromSecond := max(0, k-fromFirst)\\n\\n\\tvar bestResult []uint8\\n\\tfor fromFirst >= 0 && fromSecond <= min(k, m) {\\n\\t\\ta := maxNumSingle(n1, fromFirst)\\n\\t\\tb := maxNumSingle(n2, fromSecond)\\n\\t\\tmerged := merge(a, b, fromFirst, fromSecond)\\n\\t\\tif len(bestResult) == 0 || greater(merged, bestResult, k, k, 0, 0) {\\n\\t\\t\\tbestResult = merged\\n\\t\\t}\\n\\t\\tfromFirst--\\n\\t\\tfromSecond++\\n\\t}\\n\\tres := make([]int, k)\\n\\tfor i, num := range bestResult {\\n\\t\\tres[i] = int(num)\\n\\t}\\n\\treturn res\\n}\\n\\n// merge merges the two arrays a and b optimally.\\nfunc merge(a, b []uint8, n, m int) []uint8 {\\n\\tres := make([]uint8, m+n)\\n\\tvar i, j int\\n\\tfor k := 0; k < m+n; k++ {\\n\\t\\tif greater(a, b, n, m, i, j) {\\n\\t\\t\\tres[k] = a[i]\\n\\t\\t\\ti++\\n\\t\\t} else {\\n\\t\\t\\tres[k] = b[j]\\n\\t\\t\\tj++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n// greater compares the provided lists of integers. If the length of one array\\n// is shorted than another, and they are otherwise equal, the longer array is\\n// returned. The reasoning behind this is that the partial array is always at\\n// least as good as the full array. For example, given [1,2], [1,2,3], choosing\\n// the first shorter array would force the use of 1 in the second array, which\\n// is sub-optimal.\\nfunc greater(a, b []uint8, n, m, i, j int) bool {\\n\\tfor ; i < n && j < m; i, j = i+1, j+1 {\\n\\t\\tif a[i] != b[j] {\\n\\t\\t\\treturn a[i] > b[j]\\n\\t\\t}\\n\\t}\\n\\treturn i != n\\n}\\n\\n// maxNumSingle calculates the max sequence in nums of length k.\\nfunc maxNumSingle(nums []uint8, k int) []uint8 {\\n\\t// Stack contains k elements sorted in descending order until it is absolutely\\n\\t// necessary to add more elements. For example, if k == len(nums), then the\\n\\t// result is simply the entire nums array. If k == len(nums)-1, it is ok to\\n\\t// bubble a number at most once.\\n\\tstack := make(uint8Stack, 0, k)\\n\\tn := len(nums)\\n\\tfor i, num := range nums {\\n\\t\\t// If num is greater than any elements in the stack, and there is enough\\n\\t\\t// elements in nums to fill up the remainder, then clean up the stack to\\n\\t\\t// make room for num.\\n\\t\\titemsLeft := n - i\\n\\t\\tfor len(stack) > 0 && itemsLeft > k-len(stack) && num > stack.peek() {\\n\\t\\t\\tstack.pop()\\n\\t\\t}\\n\\t\\tif len(stack) < k {\\n\\t\\t\\tstack.push(num)\\n\\t\\t}\\n\\t}\\n\\treturn stack\\n}\\n\\ntype uint8Stack []uint8\\n\\nfunc (s uint8Stack) peek() uint8 {\\n\\treturn s[len(s)-1]\\n}\\n\\nfunc (s *uint8Stack) pop() uint8 {\\n\\tn := len(*s)\\n\\tit := (*s)[n-1]\\n\\t*s = (*s)[:n-1]\\n\\treturn it\\n}\\n\\nfunc (s *uint8Stack) push(x uint8) {\\n\\t*s = append(*s, x)\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1135237,
                "title": "swift-greedy-solution",
                "content": "Inspired from https://leetcode.com/problems/create-maximum-number/discuss/77285/Share-my-greedy-solution\\n\\n```\\nclass Solution {\\n    func maxNumber(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [Int] {\\n        let m = nums1.count\\n        let n = nums2.count\\n\\n        var res = Array(repeating: 0, count: k)\\n        for i in max(k-n, 0)...min(k, m) {\\n            let temp = merge(getMaxArr(nums1, i), getMaxArr(nums2, k-i), k)\\n            if larger(temp, 0, res, 0) {\\n                res = temp\\n            }\\n        }\\n        return res\\n    }\\n\\n    func merge(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [Int] {\\n        var res = Array(repeating: 0, count: k)\\n        var i = 0\\n        var j = 0\\n        for index in 0..<k {\\n             if larger(nums1, i, nums2, j) {\\n                 res[index] = nums1[i]\\n                 i += 1\\n             } else {\\n                 res[index] = nums2[j]\\n                 j += 1\\n             }\\n        }\\n        return res\\n    }\\n\\n    // Given one array of length n, create the maximum number of length k\\n    func getMaxArr(_ nums: [Int], _ k: Int) -> [Int] {\\n        let n = nums.count\\n\\n        var stack = [Int]()\\n\\n        for i in 0..<n {\\n            while stack.count + n - i > k, !stack.isEmpty, stack.last! < nums[i] {\\n                stack.removeLast()\\n            }\\n            if stack.count < k {\\n                stack.append(nums[i])\\n            }\\n        }\\n\\n        var remain = k-stack.count\\n        while remain > 0 {\\n            stack.insert(0, at: 0)\\n            remain -= 1\\n        }\\n        return stack\\n    }\\n\\n    func larger(_ nums1: [Int], _ i1: Int, _ nums2: [Int], _ i2: Int) -> Bool {\\n        var i1 = i1\\n        var i2 = i2\\n        while i1 < nums1.count, i2 < nums2.count, nums1[i1] == nums2[i2] {\\n            i1 += 1\\n            i2 += 1\\n        }\\n        return i2 == nums2.count\\n        ? true\\n        : (i1 < nums1.count && nums1[i1] > nums2[i2])\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func maxNumber(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [Int] {\\n        let m = nums1.count\\n        let n = nums2.count\\n\\n        var res = Array(repeating: 0, count: k)\\n        for i in max(k-n, 0)...min(k, m) {\\n            let temp = merge(getMaxArr(nums1, i), getMaxArr(nums2, k-i), k)\\n            if larger(temp, 0, res, 0) {\\n                res = temp\\n            }\\n        }\\n        return res\\n    }\\n\\n    func merge(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [Int] {\\n        var res = Array(repeating: 0, count: k)\\n        var i = 0\\n        var j = 0\\n        for index in 0..<k {\\n             if larger(nums1, i, nums2, j) {\\n                 res[index] = nums1[i]\\n                 i += 1\\n             } else {\\n                 res[index] = nums2[j]\\n                 j += 1\\n             }\\n        }\\n        return res\\n    }\\n\\n    // Given one array of length n, create the maximum number of length k\\n    func getMaxArr(_ nums: [Int], _ k: Int) -> [Int] {\\n        let n = nums.count\\n\\n        var stack = [Int]()\\n\\n        for i in 0..<n {\\n            while stack.count + n - i > k, !stack.isEmpty, stack.last! < nums[i] {\\n                stack.removeLast()\\n            }\\n            if stack.count < k {\\n                stack.append(nums[i])\\n            }\\n        }\\n\\n        var remain = k-stack.count\\n        while remain > 0 {\\n            stack.insert(0, at: 0)\\n            remain -= 1\\n        }\\n        return stack\\n    }\\n\\n    func larger(_ nums1: [Int], _ i1: Int, _ nums2: [Int], _ i2: Int) -> Bool {\\n        var i1 = i1\\n        var i2 = i2\\n        while i1 < nums1.count, i2 < nums2.count, nums1[i1] == nums2[i2] {\\n            i1 += 1\\n            i2 += 1\\n        }\\n        return i2 == nums2.count\\n        ? true\\n        : (i1 < nums1.count && nums1[i1] > nums2[i2])\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132471,
                "title": "85-71-faster-time-o-k-2-n-m-space-o-max-n-m-k-clear-soln",
                "content": "![image](https://assets.leetcode.com/users/images/24596989-6803-4d61-b13f-208b7ceb37d4_1617004877.3851686.png)\\nFirst we trim the original arrays(if possible)\\nthan we try every combination of removing i,j elements from A & B\\nex: if k = 3 we try these >> i=0 j=3 >> i=1 j=2 >> i=2 j =1 >> i=3 j =0\\nafter trying removing minimum digits from both array we merge trimmed A & B to check if we have landed upon biggest number possible\\n```\\npublic class Solution {\\n    // Time O(k^2*(n+m)) || Space O(Max(n,m,k))\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) {\\n        nums1 = Trim(nums1, k);     // O(n)\\n        nums2 = Trim(nums2, k);     // O(m)\\n\\n        if (nums1.Length + nums2.Length <= k)\\n            return Merge(nums1, nums2, k);      // O((n+m)*k)\\n\\n        int[] max = null, curr;\\n        for (int i = k, j = 0; i >= 0; i--, j++)// O(k^2*(n+m))\\n            // Make sure we can remove i & j no of nums from A & B respectively\\n            if (nums1.Length >= i && nums2.Length >= j)\\n            {\\n                curr = Merge(Trim(nums1, i), Trim(nums2, j), k);\\n\\n                if (max == null)\\n                    max = curr;\\n                else\\n                    for (int idx = 0; idx < k; idx++)\\n                        // Atleast one non-equal digit is bigger in max\\n                        if (max[idx] > curr[idx])\\n                            break;\\n                        // Atleast one non-equal digit is bigger in curr\\n                        else if (max[idx] < curr[idx])\\n                        {\\n                            max = curr;\\n                            break;\\n                        }\\n            }\\n        return max;\\n\\n        // local helper functions\\n\\n        // Function which trims \\'k\\' elements to maximimze array \\'A\\'\\n        // Time = Space = O(n), n = len of \\'A\"\\n        int[] Trim(int[] A, int toTrim)\\n        {\\n            toTrim = A.Length - toTrim;\\n            // Not enouf elements to trim, return original array\\n            if (toTrim <= 0) return A;\\n\\n            Stack<int> st = new Stack<int>();\\n            for (int i = 0; i < A.Length; i++)\\n            {\\n                // stack top num is smaller than curr than remove stack top\\n                while (st.Count > 0 && st.Peek() < A[i] && toTrim > 0)\\n                {\\n                    st.Pop();\\n                    toTrim--;\\n                }\\n                st.Push(A[i]);\\n            }\\n            // if still nums left to trim\\n            while (toTrim-- > 0) st.Pop();\\n\\n            return st.Reverse().ToArray();\\n        }\\n\\n        // Merge max possible digits from \\'A\\' & \\'B\\' and return merged max possible array of size \\'l\\'\\n        // Time = O(n+m)*l, n = len of A, m = len of \\'B\\', l = len of Merged Arr\\n        int[] Merge(int[] A, int[] B, int l)\\n        {\\n            int[] merged = new int[l];\\n            int i = 0, j = 0, idx = 0, lenA = A.Length, lenB = B.Length, n1, n2;\\n            while (idx < l)\\n            {\\n                n1 = i < lenA ? A[i] : -1;\\n                n2 = j < lenB ? B[j] : -1;\\n                if (n1 > n2)\\n                    merged[idx] = A[i++];\\n                else if (n1 < n2)\\n                    merged[idx] = B[j++];\\n                else\\n                {\\n                    // find next num which is not equal\\n                    int i1 = i + 1, j1 = j + 1;\\n                    while (i1 < lenA && j1 < lenB && A[i1] == B[j1])\\n                    { i1++; j1++; }\\n\\n                    if (i1 == lenA)\\n                        merged[idx] = B[j++];\\n                    else if (j1 == lenB)\\n                        merged[idx] = A[i++];\\n                    else if (A[i1] < B[j1])\\n                        merged[idx] = B[j++];\\n                    else // if (A[i1] >= B[j1])\\n                        merged[idx] = A[i++];\\n                }\\n                idx++;\\n            }\\n            return merged;\\n        }\\n    }\\n    /*\\n    public int[] MaxNumberBruteForce(int[] nums1, int[] nums2, int k) {\\n        int[] maxNum = new int[k], currNum = new int[k];\\n        int l1 = nums1.Length, l2 = nums2.Length;\\n        CreateMax();\\n        return maxNum;\\n        // local func\\n        void CreateMax(int i = 0, int j = 0, int idx = 0)\\n        {\\n            if (idx == k)\\n            {\\n                bool newNumIsBigger = false;\\n                // find out if there is atleast one leading digit which is not same in both max and curr array\\n                // and if that digit is greater in currNum array than update the max array\\n                for (int index = 0; index < k; index++)\\n                    if (maxNum[index] != currNum[index])\\n                    {\\n                        if (maxNum[index] < currNum[index])\\n                            newNumIsBigger = true;\\n                        break;\\n                    }\\n\\n                if (newNumIsBigger)\\n                    for (int index = 0; index < k; index++)\\n                        maxNum[index] = currNum[index];\\n            }\\n            else\\n            {\\n                for (int i1 = i; i1 < l1; i1++)\\n                {\\n                    if ((l1 - i1) + (l2 - j) < k - idx) break;\\n                    currNum[idx] = nums1[i1];\\n                    CreateMax(i1 + 1, j, idx + 1);\\n                }\\n\\n                for (int j1 = j; j1 < l2; j1++)\\n                {\\n                    if ((l1 - i) + (l2 - j1) < k - idx) break;\\n                    currNum[idx] = nums2[j1];\\n                    CreateMax(i, j1 + 1, idx + 1);\\n                }\\n            }\\n        }\\n    }\\n    */\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // Time O(k^2*(n+m)) || Space O(Max(n,m,k))\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) {\\n        nums1 = Trim(nums1, k);     // O(n)\\n        nums2 = Trim(nums2, k);     // O(m)\\n\\n        if (nums1.Length + nums2.Length <= k)\\n            return Merge(nums1, nums2, k);      // O((n+m)*k)\\n\\n        int[] max = null, curr;\\n        for (int i = k, j = 0; i >= 0; i--, j++)// O(k^2*(n+m))\\n            // Make sure we can remove i & j no of nums from A & B respectively\\n            if (nums1.Length >= i && nums2.Length >= j)\\n            {\\n                curr = Merge(Trim(nums1, i), Trim(nums2, j), k);\\n\\n                if (max == null)\\n                    max = curr;\\n                else\\n                    for (int idx = 0; idx < k; idx++)\\n                        // Atleast one non-equal digit is bigger in max\\n                        if (max[idx] > curr[idx])\\n                            break;\\n                        // Atleast one non-equal digit is bigger in curr\\n                        else if (max[idx] < curr[idx])\\n                        {\\n                            max = curr;\\n                            break;\\n                        }\\n            }\\n        return max;\\n\\n        // local helper functions\\n\\n        // Function which trims \\'k\\' elements to maximimze array \\'A\\'\\n        // Time = Space = O(n), n = len of \\'A\"\\n        int[] Trim(int[] A, int toTrim)\\n        {\\n            toTrim = A.Length - toTrim;\\n            // Not enouf elements to trim, return original array\\n            if (toTrim <= 0) return A;\\n\\n            Stack<int> st = new Stack<int>();\\n            for (int i = 0; i < A.Length; i++)\\n            {\\n                // stack top num is smaller than curr than remove stack top\\n                while (st.Count > 0 && st.Peek() < A[i] && toTrim > 0)\\n                {\\n                    st.Pop();\\n                    toTrim--;\\n                }\\n                st.Push(A[i]);\\n            }\\n            // if still nums left to trim\\n            while (toTrim-- > 0) st.Pop();\\n\\n            return st.Reverse().ToArray();\\n        }\\n\\n        // Merge max possible digits from \\'A\\' & \\'B\\' and return merged max possible array of size \\'l\\'\\n        // Time = O(n+m)*l, n = len of A, m = len of \\'B\\', l = len of Merged Arr\\n        int[] Merge(int[] A, int[] B, int l)\\n        {\\n            int[] merged = new int[l];\\n            int i = 0, j = 0, idx = 0, lenA = A.Length, lenB = B.Length, n1, n2;\\n            while (idx < l)\\n            {\\n                n1 = i < lenA ? A[i] : -1;\\n                n2 = j < lenB ? B[j] : -1;\\n                if (n1 > n2)\\n                    merged[idx] = A[i++];\\n                else if (n1 < n2)\\n                    merged[idx] = B[j++];\\n                else\\n                {\\n                    // find next num which is not equal\\n                    int i1 = i + 1, j1 = j + 1;\\n                    while (i1 < lenA && j1 < lenB && A[i1] == B[j1])\\n                    { i1++; j1++; }\\n\\n                    if (i1 == lenA)\\n                        merged[idx] = B[j++];\\n                    else if (j1 == lenB)\\n                        merged[idx] = A[i++];\\n                    else if (A[i1] < B[j1])\\n                        merged[idx] = B[j++];\\n                    else // if (A[i1] >= B[j1])\\n                        merged[idx] = A[i++];\\n                }\\n                idx++;\\n            }\\n            return merged;\\n        }\\n    }\\n    /*\\n    public int[] MaxNumberBruteForce(int[] nums1, int[] nums2, int k) {\\n        int[] maxNum = new int[k], currNum = new int[k];\\n        int l1 = nums1.Length, l2 = nums2.Length;\\n        CreateMax();\\n        return maxNum;\\n        // local func\\n        void CreateMax(int i = 0, int j = 0, int idx = 0)\\n        {\\n            if (idx == k)\\n            {\\n                bool newNumIsBigger = false;\\n                // find out if there is atleast one leading digit which is not same in both max and curr array\\n                // and if that digit is greater in currNum array than update the max array\\n                for (int index = 0; index < k; index++)\\n                    if (maxNum[index] != currNum[index])\\n                    {\\n                        if (maxNum[index] < currNum[index])\\n                            newNumIsBigger = true;\\n                        break;\\n                    }\\n\\n                if (newNumIsBigger)\\n                    for (int index = 0; index < k; index++)\\n                        maxNum[index] = currNum[index];\\n            }\\n            else\\n            {\\n                for (int i1 = i; i1 < l1; i1++)\\n                {\\n                    if ((l1 - i1) + (l2 - j) < k - idx) break;\\n                    currNum[idx] = nums1[i1];\\n                    CreateMax(i1 + 1, j, idx + 1);\\n                }\\n\\n                for (int j1 = j; j1 < l2; j1++)\\n                {\\n                    if ((l1 - i) + (l2 - j1) < k - idx) break;\\n                    currNum[idx] = nums2[j1];\\n                    CreateMax(i, j1 + 1, idx + 1);\\n                }\\n            }\\n        }\\n    }\\n    */\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976186,
                "title": "javascript-solution-easy-to-understand",
                "content": "```\\nvar maxNumber = function(a1, a2, k) {\\n    var tp = a1.concat(a2).slice(0,k).join(\\'\\')\\n    \\n    var len1 = a1.length, len2 = a2.length\\n    \\n    for(var i=Math.max(0, k-len2); i<=len1 && i<=k; i++) {\\n        \\n        var tp1 = getMax(a1,i)\\n        var tp2 = getMax(a2, k-i)\\n        var tp3 = merge(tp1, tp2)\\n        var tps = tp3.join(\\'\\')\\n        if(tps.localeCompare(tp)>0) {\\n            tp = tps\\n        }\\n    }\\n    return tp.split(\\'\\').map(c=>+c)\\n};\\n\\nvar merge = (a1, a2)=>{\\n    var len1 = a1.length, len2 = a2.length\\n    var res = []\\n    var i=0,j=0\\n    \\n    var greater = (i, j)=>{\\n        while(i<len1 && j<len2 && a1[i]==a2[j]) {\\n            i++\\n            j++\\n        }\\n        return j==len2 || (i<len1 && a1[i]>a2[j])\\n    }\\n    \\n    while(i<len1 && j<len2) {\\n        if(greater(i,j)){\\n            res.push(a1[i])\\n            i++\\n        }else{\\n            res.push(a2[j])\\n            j++\\n        }\\n        \\n    }\\n\\n    while(i<len1){\\n        res.push(a1[i])\\n            i++\\n    }\\n    while(j<len2){\\n        res.push(a2[j])\\n            j++\\n    }\\n    return res\\n}\\n\\n\\nvar getMax = (arr, k) => {\\n    var len = arr.length\\n    if(k==0) return []\\n    var res = new Array(k).fill(0)\\n    for(var i=0, j=0; i<len; i++) {\\n        while(len-i>k-j && j>0 && res[j-1]<arr[i]){\\n            j--\\n        }\\n        if(j<k){\\n            res[j] = arr[i]\\n            j++\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxNumber = function(a1, a2, k) {\\n    var tp = a1.concat(a2).slice(0,k).join(\\'\\')\\n    \\n    var len1 = a1.length, len2 = a2.length\\n    \\n    for(var i=Math.max(0, k-len2); i<=len1 && i<=k; i++) {\\n        \\n        var tp1 = getMax(a1,i)\\n        var tp2 = getMax(a2, k-i)\\n        var tp3 = merge(tp1, tp2)\\n        var tps = tp3.join(\\'\\')\\n        if(tps.localeCompare(tp)>0) {\\n            tp = tps\\n        }\\n    }\\n    return tp.split(\\'\\').map(c=>+c)\\n};\\n\\nvar merge = (a1, a2)=>{\\n    var len1 = a1.length, len2 = a2.length\\n    var res = []\\n    var i=0,j=0\\n    \\n    var greater = (i, j)=>{\\n        while(i<len1 && j<len2 && a1[i]==a2[j]) {\\n            i++\\n            j++\\n        }\\n        return j==len2 || (i<len1 && a1[i]>a2[j])\\n    }\\n    \\n    while(i<len1 && j<len2) {\\n        if(greater(i,j)){\\n            res.push(a1[i])\\n            i++\\n        }else{\\n            res.push(a2[j])\\n            j++\\n        }\\n        \\n    }\\n\\n    while(i<len1){\\n        res.push(a1[i])\\n            i++\\n    }\\n    while(j<len2){\\n        res.push(a2[j])\\n            j++\\n    }\\n    return res\\n}\\n\\n\\nvar getMax = (arr, k) => {\\n    var len = arr.length\\n    if(k==0) return []\\n    var res = new Array(k).fill(0)\\n    for(var i=0, j=0; i<len; i++) {\\n        while(len-i>k-j && j>0 && res[j-1]<arr[i]){\\n            j--\\n        }\\n        if(j<k){\\n            res[j] = arr[i]\\n            j++\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 975787,
                "title": "brute-force-pretty-straight-forward-less-comments-for-explanation",
                "content": "```\\nclass Solution {\\n    public int[] maxNumber(int[] a, int[] b, int k) {\\n        int n = a.length;\\n        int m = b.length;\\n        \\n        int x[][] = new int[n][];\\n        int y[][] = new int[m][];\\n        for(int i=0;i<n;i++)\\n            x[i] = new int[i+1];\\n        for(int i=0;i<m;i++)\\n            y[i] = new int[i+1];\\n        \\n        build(a , x);\\n        build(b , y);\\n        \\n        int ans[] = new int[k];\\n        \\n        for(int i=0;i<=k;i++){\\n            int count1 = i;\\n            int count2 = k-i;\\n            if(count1<=n && count2<=m){\\n                int left[] = new int[0];\\n                int right[] = new int[0];\\n                if(count1>0)\\n                    left = x[count1-1];\\n                if(count2>0)\\n                    right = y[count2-1];\\n                int now[] = max(left , right);\\n                if(less(ans , now)<0){\\n                    ans = now;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public int[] max(int a[] , int b[]){\\n        int c[] = new int[a.length+b.length];\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        while(i<a.length && j<b.length){\\n            if(a[i] == b[j]){\\n                int x = check(a , b , i , j);\\n                if(x == 0)\\n                    c[k++] = a[i++];\\n                else\\n                    c[k++] = b[j++];\\n            }\\n            else if(a[i]>b[j])\\n                c[k++] = a[i++];\\n            else\\n                c[k++] = b[j++];\\n        }\\n        while(i<a.length)\\n            c[k++] = a[i++];\\n        while(j<b.length)\\n            c[k++] = b[j++];\\n        return c;\\n    }\\n    \\n    public int check(int a[] , int b[] , int s1 , int s2){\\n        // 0 -> a 1 -> b\\n        int i=s1;\\n        int j=s2;\\n        while(i<a.length && j<b.length){\\n            if(a[i] == b[j]){\\n                i++;\\n                j++;\\n                continue;\\n            }\\n            if(a[i]<b[j])\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        if(i == a.length)\\n            return 1;\\n        return 0;\\n    }\\n    \\n    public void build(int a[] , int x[][]){\\n        for(int i=0;i<a.length;i++){\\n            int num = a[i];\\n            if(i == 0){\\n                x[i][0] = num;\\n                continue;\\n            }\\n            for(int j=i;j>0;j--){\\n                int res = less(x[j] , x[j-1]);\\n                if(res>0);\\n                else if(res == 0){\\n                    if(x[j][j]<num){\\n                        x[j][j] = num;\\n                    }\\n                }\\n                else{\\n                    copy(x[j-1] , x[j]);\\n                    x[j][j] = num;\\n                }\\n            }\\n            if(x[0][0]<num)\\n                x[0][0] = num;\\n        }\\n    }\\n    \\n    public void copy(int a[] , int b[]){\\n        for(int i=0;i<a.length;i++)\\n            b[i] = a[i];\\n    }\\n    \\n    public int less(int a[] , int b[]){\\n        // 0 -> equal -1 -> less 1 -> more\\n        for(int i=0;i<Math.min(a.length , b.length);i++){\\n            if(a[i] == b[i])\\n                continue;\\n            else if(a[i]<b[i])\\n                return -1;\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxNumber(int[] a, int[] b, int k) {\\n        int n = a.length;\\n        int m = b.length;\\n        \\n        int x[][] = new int[n][];\\n        int y[][] = new int[m][];\\n        for(int i=0;i<n;i++)\\n            x[i] = new int[i+1];\\n        for(int i=0;i<m;i++)\\n            y[i] = new int[i+1];\\n        \\n        build(a , x);\\n        build(b , y);\\n        \\n        int ans[] = new int[k];\\n        \\n        for(int i=0;i<=k;i++){\\n            int count1 = i;\\n            int count2 = k-i;\\n            if(count1<=n && count2<=m){\\n                int left[] = new int[0];\\n                int right[] = new int[0];\\n                if(count1>0)\\n                    left = x[count1-1];\\n                if(count2>0)\\n                    right = y[count2-1];\\n                int now[] = max(left , right);\\n                if(less(ans , now)<0){\\n                    ans = now;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public int[] max(int a[] , int b[]){\\n        int c[] = new int[a.length+b.length];\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        while(i<a.length && j<b.length){\\n            if(a[i] == b[j]){\\n                int x = check(a , b , i , j);\\n                if(x == 0)\\n                    c[k++] = a[i++];\\n                else\\n                    c[k++] = b[j++];\\n            }\\n            else if(a[i]>b[j])\\n                c[k++] = a[i++];\\n            else\\n                c[k++] = b[j++];\\n        }\\n        while(i<a.length)\\n            c[k++] = a[i++];\\n        while(j<b.length)\\n            c[k++] = b[j++];\\n        return c;\\n    }\\n    \\n    public int check(int a[] , int b[] , int s1 , int s2){\\n        // 0 -> a 1 -> b\\n        int i=s1;\\n        int j=s2;\\n        while(i<a.length && j<b.length){\\n            if(a[i] == b[j]){\\n                i++;\\n                j++;\\n                continue;\\n            }\\n            if(a[i]<b[j])\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        if(i == a.length)\\n            return 1;\\n        return 0;\\n    }\\n    \\n    public void build(int a[] , int x[][]){\\n        for(int i=0;i<a.length;i++){\\n            int num = a[i];\\n            if(i == 0){\\n                x[i][0] = num;\\n                continue;\\n            }\\n            for(int j=i;j>0;j--){\\n                int res = less(x[j] , x[j-1]);\\n                if(res>0);\\n                else if(res == 0){\\n                    if(x[j][j]<num){\\n                        x[j][j] = num;\\n                    }\\n                }\\n                else{\\n                    copy(x[j-1] , x[j]);\\n                    x[j][j] = num;\\n                }\\n            }\\n            if(x[0][0]<num)\\n                x[0][0] = num;\\n        }\\n    }\\n    \\n    public void copy(int a[] , int b[]){\\n        for(int i=0;i<a.length;i++)\\n            b[i] = a[i];\\n    }\\n    \\n    public int less(int a[] , int b[]){\\n        // 0 -> equal -1 -> less 1 -> more\\n        for(int i=0;i<Math.min(a.length , b.length);i++){\\n            if(a[i] == b[i])\\n                continue;\\n            else if(a[i]<b[i])\\n                return -1;\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946759,
                "title": "why-this-question-tagged-with-dynamic-programming",
                "content": "TLE since 88th test case\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef recursion(i: int, j: int, left: int) -> int:\\n\\t\\t\\t\\tif left == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif len(nums1) - i + len(nums2) - j < left:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tval1 = val2 = val3 = 0\\n\\t\\t\\t\\tif i < len(nums1):\\n\\t\\t\\t\\t\\tval1 += nums1[i] * 10**(left - 1) + recursion(i + 1, j, left - 1)\\n\\t\\t\\t\\t\\tval1 = max(val1, recursion(i + 1, j, left))\\n\\t\\t\\t\\tif j < len(nums2):\\n\\t\\t\\t\\t\\tval2 += nums2[j] * 10**(left - 1) + recursion(i, j + 1, left - 1)\\n\\t\\t\\t\\t\\tval2 = max(val2, recursion(i, j + 1, left))\\n\\t\\t\\t\\tif i < len(nums1) and j < len(nums2):\\n\\t\\t\\t\\t\\tval3 = recursion(i + 1, j + 1, left)\\n\\t\\t\\t\\treturn max(val1, max(val2, val3))\\n\\n\\t\\t\\tres = recursion(0, 0, k)\\n\\n\\t\\t\\toutput = []\\n\\t\\t\\twhile res != 0:\\n\\t\\t\\t\\toutput.append(res % 10)\\n\\t\\t\\t\\tres //= 10\\n\\t\\t\\toutput.reverse()\\n\\t\\t\\treturn output",
                "solutionTags": [],
                "code": "TLE since 88th test case\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef recursion(i: int, j: int, left: int) -> int:\\n\\t\\t\\t\\tif left == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif len(nums1) - i + len(nums2) - j < left:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tval1 = val2 = val3 = 0\\n\\t\\t\\t\\tif i < len(nums1):\\n\\t\\t\\t\\t\\tval1 += nums1[i] * 10**(left - 1) + recursion(i + 1, j, left - 1)\\n\\t\\t\\t\\t\\tval1 = max(val1, recursion(i + 1, j, left))\\n\\t\\t\\t\\tif j < len(nums2):\\n\\t\\t\\t\\t\\tval2 += nums2[j] * 10**(left - 1) + recursion(i, j + 1, left - 1)\\n\\t\\t\\t\\t\\tval2 = max(val2, recursion(i, j + 1, left))\\n\\t\\t\\t\\tif i < len(nums1) and j < len(nums2):\\n\\t\\t\\t\\t\\tval3 = recursion(i + 1, j + 1, left)\\n\\t\\t\\t\\treturn max(val1, max(val2, val3))\\n\\n\\t\\t\\tres = recursion(0, 0, k)\\n\\n\\t\\t\\toutput = []\\n\\t\\t\\twhile res != 0:\\n\\t\\t\\t\\toutput.append(res % 10)\\n\\t\\t\\t\\tres //= 10\\n\\t\\t\\toutput.reverse()\\n\\t\\t\\treturn output",
                "codeTag": "Java"
            },
            {
                "id": 865383,
                "title": "c-simplest-solution-break-into-two-problem-and-enjoy",
                "content": "class Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n      int n=a.size();int m=b.size();\\n        vector<int> ans;\\n        for(int i=0;i<=k;i++)\\n        {\\n            if(i>n || k-i>m)continue;\\n            ans=max(ans,merge(findmax(a,i),findmax(b,k-i)));\\n        }\\n        return ans;\\n    }\\n    vector<int> findmax(vector<int> &a,int k)\\n    {\\n        vector<int> res;\\n        int to_pop=a.size()-k;\\n       for(int i=0;i<a.size();i++)\\n       {\\n           while(!res.empty() && to_pop && *res.rbegin()<a[i])\\n               res.pop_back(),to_pop--;\\n           res.push_back(a[i]);\\n       }\\n        res.resize(k);\\n        return res;\\n    }\\n    vector<int> merge(vector<int> a,vector<int> b)\\n    {\\n        vector<int> ans;\\n        auto s1=a.begin();\\n        auto e1=a.end();\\n        auto s2=b.begin();\\n        auto e2=b.end();\\n        while(s1!=e1 || s2!=e2)\\n            ans.push_back(lexicographical_compare(s1,e1,s2,e2)?*s2++:*s1++);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n      int n=a.size();int m=b.size();\\n        vector<int> ans;\\n        for(int i=0;i<=k;i++)\\n        {\\n            if(i>n || k-i>m)continue;\\n            ans=max(ans,merge(findmax(a,i),findmax(b,k-i)));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 732222,
                "title": "sharing-my-dp-solution",
                "content": "If you are going to calculate max in both array simultaneously, it is going to be order of  (m*n*k) where m = arr1.length, n=arr2.length;\\nIdea is calculate max in first array (m*k), calculate max in second array(n*k), then merge both max array to get final answer. complexity would be (m+n+k)*k;\\n\\n```\\n// get max of two string\\n    private String max(String s1, String s2) {\\n        return (s1.compareTo(s2) < 0) ? s2 : s1;\\n    }\\n    \\n    // calculate max in one array\\n    public String[] helper1(int[] A, int k) {\\n        int m = A.length;\\n        String[][] dp = new String[m+1][k+1];\\n        for (int i = 0; i <= m; i++) {\\n            for (int l = 0; l <= k; l++) {\\n                String chooseAi = (i == 0 || l == 0) ? \"\" : dp[i - 1][l - 1] + A[i - 1];\\n                String ignoreAi = (i == 0) ? \"\" : dp[i - 1][l];\\n                dp[i][l] = max(chooseAi, ignoreAi);\\n            }\\n        }\\n        return dp[m];\\n    }\\n\\n    \\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\n        String[] max1= helper1(nums1, Math.min(nums1.length,k));  // calculate max for num1\\n        String[] max2= helper1(nums2, Math.min(nums2.length,k)); // calculate max for num2\\n        \\n        // merge two max array \\n        String ans = \"\";\\n        for(int t=0;t<=k;t++) { // k*k*k\\n            int len1 = Math.min(nums1.length, t);\\n            int len2 = Math.min(nums2.length, k-t);\\n            if(len1+len2 != k) continue;\\n            String ans1 = max1[len1];\\n            String ans2 = max2[len2];\\n            StringBuilder tmp = new StringBuilder();\\n            while (tmp.length() < k) {\\n                char ch;\\n                if(ans1.compareTo(ans2)>=0){\\n                    ch=ans1.charAt(0);\\n                    ans1=ans1.substring(1);\\n                }\\n                else {\\n                    ch=ans2.charAt(0);\\n                    ans2=ans2.substring(1);\\n                }\\n                tmp.append(ch);\\n            }\\n            ans=max(ans,tmp.toString());\\n\\n        }\\n\\n        int[] tmp = new int[ans.length()];\\n        for(int i=0;i<tmp.length;i++){\\n            tmp[i]=ans.charAt(i)-\\'0\\';\\n        }\\n        return tmp;\\n    }\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n// get max of two string\\n    private String max(String s1, String s2) {\\n        return (s1.compareTo(s2) < 0) ? s2 : s1;\\n    }\\n    \\n    // calculate max in one array\\n    public String[] helper1(int[] A, int k) {\\n        int m = A.length;\\n        String[][] dp = new String[m+1][k+1];\\n        for (int i = 0; i <= m; i++) {\\n            for (int l = 0; l <= k; l++) {\\n                String chooseAi = (i == 0 || l == 0) ? \"\" : dp[i - 1][l - 1] + A[i - 1];\\n                String ignoreAi = (i == 0) ? \"\" : dp[i - 1][l];\\n                dp[i][l] = max(chooseAi, ignoreAi);\\n            }\\n        }\\n        return dp[m];\\n    }\\n\\n    \\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\n        String[] max1= helper1(nums1, Math.min(nums1.length,k));  // calculate max for num1\\n        String[] max2= helper1(nums2, Math.min(nums2.length,k)); // calculate max for num2\\n        \\n        // merge two max array \\n        String ans = \"\";\\n        for(int t=0;t<=k;t++) { // k*k*k\\n            int len1 = Math.min(nums1.length, t);\\n            int len2 = Math.min(nums2.length, k-t);\\n            if(len1+len2 != k) continue;\\n            String ans1 = max1[len1];\\n            String ans2 = max2[len2];\\n            StringBuilder tmp = new StringBuilder();\\n            while (tmp.length() < k) {\\n                char ch;\\n                if(ans1.compareTo(ans2)>=0){\\n                    ch=ans1.charAt(0);\\n                    ans1=ans1.substring(1);\\n                }\\n                else {\\n                    ch=ans2.charAt(0);\\n                    ans2=ans2.substring(1);\\n                }\\n                tmp.append(ch);\\n            }\\n            ans=max(ans,tmp.toString());\\n\\n        }\\n\\n        int[] tmp = new int[ans.length()];\\n        for(int i=0;i<tmp.length;i++){\\n            tmp[i]=ans.charAt(i)-\\'0\\';\\n        }\\n        return tmp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 709875,
                "title": "c-greedy",
                "content": "I have used too much memory to make this code working great. Please keep in mind that while merging we are not merging two sorted arrays so do not use traditional approach for merging.\\n```C++\\n#define ll int\\n#define pb push_back\\nvoid genMax(ll arr[],ll n, vector<ll> nos[]){\\n        ll i=1;\\n        for(ll len=n;len>=1;len--)\\n        {\\n            if(len==n){\\n                for(ll i=1;i<=n;i++)\\n                    nos[len].pb(arr[i]);\\n            }\\n            else\\n            {\\n                i=1;\\n               while(i+1<=n and arr[i]>=arr[i+1])i++;\\n               n-=1;\\n               for(ll j=i;j<=n;j++)arr[j]=arr[j+1];\\n               for(ll j=1;j<=n;j++)nos[len].pb(arr[j]);\\n            }\\n        }\\n    }\\n    bool greater1(vector<ll> v1,int i,vector<ll> v2,int j)\\n    {\\n        while (i < v1.size() && j < v2.size() && v1[i] == v2[j]) {\\n            i++;\\n            j++;\\n        }\\n        return j == v2.size() || (i < v1.size() && v1[i] > v2[j]);\\n    }\\n    vector<int> merge(vector<int>& v1,vector<int> &v2){\\n        int n=v1.size(),m=v2.size();\\n        int k=n+m;\\n        vector<int> ans(k);\\n        for (int i = 0, j = 0, r = 0; r < k; ++r)\\n        ans[r] = greater1(v1, i, v2, j) ? v1[i++] : v2[j++];\\n            return ans;\\n    }\\n    bool great(vector<int> &result,vector<int> &temp){\\n        int k=result.size();\\n        int i=0;\\n        while(i<k and result[i]==temp[i])i++;\\n        if(i<k and result[i] < temp[i])return true;\\n        return false;\\n    }\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size(),m=nums2.size();\\n        int arr1[n+1],arr2[m+1];\\n        for(int i=0;i<n;i++)\\n            arr1[i+1]=nums1[i];\\n        for(int i=0;i<m;i++)\\n            arr2[i+1]=nums2[i];\\n        vector<int> v1[n+1];\\n        vector<int> v2[m+1];\\n        genMax(arr1,n,v1);\\n        genMax(arr2,m,v2);\\n        // for(ll i=n;i>=1;i--)\\n        // {\\n        //     cout<<\"len= \"<<i<<\" : \";\\n        //     for(auto it:v1[i])\\n        //         cout<<it<<\" \";cout<<endl;\\n        // }\\n        // for(ll i=m;i>=1;i--)\\n        // {\\n        //     cout<<\"len= \"<<i<<\" : \";\\n        //     for(auto it:v2[i])\\n        //         cout<<it<<\" \";cout<<endl;\\n        // }\\n        vector<int> result(k,-1);\\n        for(int i=0;i<=k;i++)\\n        {\\n            // cout<<\"i_start= \"<<i<<endl;\\n            // cout<<\"result= \";\\n            // for(auto it:result)cout<<it<<\" \";cout<<endl;\\n            int first=i,second=k-i;\\n            // cout<<\"first= \"<<first<<\" second= \"<<second<<endl;\\n            if(first>n or second>m)continue;\\n            if(first==0)\\n            {\\n                if(great(result,v2[second]))\\n                    result=v2[second];\\n                continue;\\n            }\\n            if(second==0)\\n            {\\n                if(great(result,v1[first]))\\n                    result=v1[first];\\n                continue;\\n            }\\n            // cout<<\"i_end= \"<<i<<endl;\\n            vector<int> temp=merge(v1[first],v2[second]);\\n            if(great(result,temp))\\n                result=temp;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\n#define ll int\\n#define pb push_back\\nvoid genMax(ll arr[],ll n, vector<ll> nos[]){\\n        ll i=1;\\n        for(ll len=n;len>=1;len--)\\n        {\\n            if(len==n){\\n                for(ll i=1;i<=n;i++)\\n                    nos[len].pb(arr[i]);\\n            }\\n            else\\n            {\\n                i=1;\\n               while(i+1<=n and arr[i]>=arr[i+1])i++;\\n               n-=1;\\n               for(ll j=i;j<=n;j++)arr[j]=arr[j+1];\\n               for(ll j=1;j<=n;j++)nos[len].pb(arr[j]);\\n            }\\n        }\\n    }\\n    bool greater1(vector<ll> v1,int i,vector<ll> v2,int j)\\n    {\\n        while (i < v1.size() && j < v2.size() && v1[i] == v2[j]) {\\n            i++;\\n            j++;\\n        }\\n        return j == v2.size() || (i < v1.size() && v1[i] > v2[j]);\\n    }\\n    vector<int> merge(vector<int>& v1,vector<int> &v2){\\n        int n=v1.size(),m=v2.size();\\n        int k=n+m;\\n        vector<int> ans(k);\\n        for (int i = 0, j = 0, r = 0; r < k; ++r)\\n        ans[r] = greater1(v1, i, v2, j) ? v1[i++] : v2[j++];\\n            return ans;\\n    }\\n    bool great(vector<int> &result,vector<int> &temp){\\n        int k=result.size();\\n        int i=0;\\n        while(i<k and result[i]==temp[i])i++;\\n        if(i<k and result[i] < temp[i])return true;\\n        return false;\\n    }\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size(),m=nums2.size();\\n        int arr1[n+1],arr2[m+1];\\n        for(int i=0;i<n;i++)\\n            arr1[i+1]=nums1[i];\\n        for(int i=0;i<m;i++)\\n            arr2[i+1]=nums2[i];\\n        vector<int> v1[n+1];\\n        vector<int> v2[m+1];\\n        genMax(arr1,n,v1);\\n        genMax(arr2,m,v2);\\n        // for(ll i=n;i>=1;i--)\\n        // {\\n        //     cout<<\"len= \"<<i<<\" : \";\\n        //     for(auto it:v1[i])\\n        //         cout<<it<<\" \";cout<<endl;\\n        // }\\n        // for(ll i=m;i>=1;i--)\\n        // {\\n        //     cout<<\"len= \"<<i<<\" : \";\\n        //     for(auto it:v2[i])\\n        //         cout<<it<<\" \";cout<<endl;\\n        // }\\n        vector<int> result(k,-1);\\n        for(int i=0;i<=k;i++)\\n        {\\n            // cout<<\"i_start= \"<<i<<endl;\\n            // cout<<\"result= \";\\n            // for(auto it:result)cout<<it<<\" \";cout<<endl;\\n            int first=i,second=k-i;\\n            // cout<<\"first= \"<<first<<\" second= \"<<second<<endl;\\n            if(first>n or second>m)continue;\\n            if(first==0)\\n            {\\n                if(great(result,v2[second]))\\n                    result=v2[second];\\n                continue;\\n            }\\n            if(second==0)\\n            {\\n                if(great(result,v1[first]))\\n                    result=v1[first];\\n                continue;\\n            }\\n            // cout<<\"i_end= \"<<i<<endl;\\n            vector<int> temp=merge(v1[first],v2[second]);\\n            if(great(result,temp))\\n                result=temp;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 692570,
                "title": "tle-naive-dp-solution",
                "content": "Just sharing my pain with others who may have tried similar regular DP approaches instead of breaking it down into smaller sub-problems first.\\n\\nThis does pass 86/102 test cases so I hope it\\'s at least passable for an interview.\\n\\nI wonder if it would fare better if I didn\\'t make as heavy use of strings.\\n\\n```\\nclass Solution {\\n    \\n    int[] nums1;\\n    int[] nums2;\\n    \\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        this.nums1 = nums1;\\n        this.nums2 = nums2;\\n        Map<String, StringBuilder> memo = new HashMap<>();\\n        StringBuilder sb = helper(0, 0, k, memo);\\n        int[] output = new int[k];\\n        for (int i = 0; i < k; i++) {\\n            output[i] = sb.charAt(i) - \\'0\\';\\n        }\\n        return output;\\n    }\\n    \\n    private String getKey(int i, int j, int k) {\\n        return i + \"_\" + j + \"_\" + k;\\n    }\\n    \\n    private StringBuilder helper(int i, int j, int k, Map<String, StringBuilder> memo) {\\n        if (k == 0) {\\n            return new StringBuilder();\\n        }\\n        String key = getKey(i, j, k);\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int nLeft = nums1.length - i + nums2.length - j;\\n        // Take digit\\n        if (i >= nums1.length) {\\n            sb.append(nums2[j]);\\n            sb.append(helper(i, j + 1, k - 1, memo));\\n        } else if (j >= nums2.length) {\\n            sb.append(nums1[i]);\\n            sb.append(helper(i + 1, j, k - 1, memo));\\n        } else if (nums1[i] == nums2[j]) {\\n            sb.append(nums2[j]);\\n            String left = helper(i + 1, j, k - 1, memo).toString();\\n            String right = helper(i, j + 1, k - 1, memo).toString();\\n            if (left.compareTo(right) >= 0) {\\n                sb.append(left);\\n            } else {\\n                sb.append(right);\\n            }\\n        } else if (nums1[i] > nums2[j]) {\\n            sb.append(nums1[i]);\\n            sb.append(helper(i + 1, j, k - 1, memo));\\n        } else {\\n            sb.append(nums2[j]);\\n            sb.append(helper(i, j + 1, k - 1, memo));\\n        }\\n        \\n        if (nLeft > k) {\\n            // can choose not to take anything\\n            StringBuilder sb1 = helper(i + 1, j, k, memo);\\n            StringBuilder sb2 = helper(i, j + 1, k, memo);\\n                    // return the biggest one\\n            String s1 = sb.toString();\\n            String s2 = sb1.toString();\\n            String s3 = sb2.toString();\\n\\n            if (s1.compareTo(s2) >= 0 && s1.compareTo(s3) >= 0) {\\n                memo.put(key, sb);\\n                return sb;\\n            } \\n\\n            if (s2.compareTo(s3) >= 0 && s2.compareTo(s1) >= 0) {\\n                memo.put(key, sb1);\\n                return sb1;\\n            } \\n            memo.put(key, sb2);\\n            return sb2;\\n        }\\n        \\n        memo.put(key, sb);\\n        return sb;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[] nums1;\\n    int[] nums2;\\n    \\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        this.nums1 = nums1;\\n        this.nums2 = nums2;\\n        Map<String, StringBuilder> memo = new HashMap<>();\\n        StringBuilder sb = helper(0, 0, k, memo);\\n        int[] output = new int[k];\\n        for (int i = 0; i < k; i++) {\\n            output[i] = sb.charAt(i) - \\'0\\';\\n        }\\n        return output;\\n    }\\n    \\n    private String getKey(int i, int j, int k) {\\n        return i + \"_\" + j + \"_\" + k;\\n    }\\n    \\n    private StringBuilder helper(int i, int j, int k, Map<String, StringBuilder> memo) {\\n        if (k == 0) {\\n            return new StringBuilder();\\n        }\\n        String key = getKey(i, j, k);\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int nLeft = nums1.length - i + nums2.length - j;\\n        // Take digit\\n        if (i >= nums1.length) {\\n            sb.append(nums2[j]);\\n            sb.append(helper(i, j + 1, k - 1, memo));\\n        } else if (j >= nums2.length) {\\n            sb.append(nums1[i]);\\n            sb.append(helper(i + 1, j, k - 1, memo));\\n        } else if (nums1[i] == nums2[j]) {\\n            sb.append(nums2[j]);\\n            String left = helper(i + 1, j, k - 1, memo).toString();\\n            String right = helper(i, j + 1, k - 1, memo).toString();\\n            if (left.compareTo(right) >= 0) {\\n                sb.append(left);\\n            } else {\\n                sb.append(right);\\n            }\\n        } else if (nums1[i] > nums2[j]) {\\n            sb.append(nums1[i]);\\n            sb.append(helper(i + 1, j, k - 1, memo));\\n        } else {\\n            sb.append(nums2[j]);\\n            sb.append(helper(i, j + 1, k - 1, memo));\\n        }\\n        \\n        if (nLeft > k) {\\n            // can choose not to take anything\\n            StringBuilder sb1 = helper(i + 1, j, k, memo);\\n            StringBuilder sb2 = helper(i, j + 1, k, memo);\\n                    // return the biggest one\\n            String s1 = sb.toString();\\n            String s2 = sb1.toString();\\n            String s3 = sb2.toString();\\n\\n            if (s1.compareTo(s2) >= 0 && s1.compareTo(s3) >= 0) {\\n                memo.put(key, sb);\\n                return sb;\\n            } \\n\\n            if (s2.compareTo(s3) >= 0 && s2.compareTo(s1) >= 0) {\\n                memo.put(key, sb1);\\n                return sb1;\\n            } \\n            memo.put(key, sb2);\\n            return sb2;\\n        }\\n        \\n        memo.put(key, sb);\\n        return sb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651565,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool compare(vector<int>& nums1, vector<int>& nums2, int start_i, int start_j){\\n        int loop_size = min(nums1.size() - start_i, nums2.size() - start_j);\\n\\n        for (int i = 0; i < loop_size; i++){\\n            if (nums1[i + start_i] < nums2[i + start_j])\\n                return true;\\n            else if (nums1[i + start_i] > nums2[i + start_j])\\n                return false;\\n        }\\n        return nums1.size() - start_i < nums2.size() - start_j;\\n    }\\n\\n    vector<vector<int>> largetsNum(vector<int>& nums){\\n        vector<vector<int>> res;\\n        res.resize(nums.size() + 1);\\n        res.back() = nums;\\n\\n        for (int i = res.size() - 2; i >= 0; i--){\\t\\n            int idx = 0;\\n            while (idx + 1 < res[i + 1].size()){\\n                if (res[i + 1][idx] < res[i + 1][idx + 1])\\n                    break;\\n                idx++;\\n            }\\n\\n            for (int j = 0; j < res[i + 1].size(); j++){\\n                if (idx != j)\\n                    res[i].push_back(res[i + 1][j]);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    vector<int> merge(vector<int>& nums1, vector<int>& nums2){\\n        vector<int> res;\\n        int i = 0, j = 0;\\n        while (i < nums1.size() || j < nums2.size()){\\n                if (compare(nums1, nums2, i, j))\\n                    res.push_back(nums2[j++]);\\n                else\\n                    res.push_back(nums1[i++]);\\n        }\\n        return res;\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, size_t k) {\\n        vector<vector<int>> largest_num1 = largetsNum(nums1);\\n        vector<vector<int>> largest_num2 = largetsNum(nums2);\\n\\n        vector<int> res;\\n        int start = k > nums2.size() ? k - nums2.size() : 0;\\n\\n        for (int i = start; i < largest_num1.size() && i <= k; i++){\\n            vector<int> tmp = merge(largest_num1[i], largest_num2[k - i]);\\n            if (res.empty() || compare(res, tmp, 0, 0)) res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool compare(vector<int>& nums1, vector<int>& nums2, int start_i, int start_j){\\n        int loop_size = min(nums1.size() - start_i, nums2.size() - start_j);\\n\\n        for (int i = 0; i < loop_size; i++){\\n            if (nums1[i + start_i] < nums2[i + start_j])\\n                return true;\\n            else if (nums1[i + start_i] > nums2[i + start_j])\\n                return false;\\n        }\\n        return nums1.size() - start_i < nums2.size() - start_j;\\n    }\\n\\n    vector<vector<int>> largetsNum(vector<int>& nums){\\n        vector<vector<int>> res;\\n        res.resize(nums.size() + 1);\\n        res.back() = nums;\\n\\n        for (int i = res.size() - 2; i >= 0; i--){\\t\\n            int idx = 0;\\n            while (idx + 1 < res[i + 1].size()){\\n                if (res[i + 1][idx] < res[i + 1][idx + 1])\\n                    break;\\n                idx++;\\n            }\\n\\n            for (int j = 0; j < res[i + 1].size(); j++){\\n                if (idx != j)\\n                    res[i].push_back(res[i + 1][j]);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    vector<int> merge(vector<int>& nums1, vector<int>& nums2){\\n        vector<int> res;\\n        int i = 0, j = 0;\\n        while (i < nums1.size() || j < nums2.size()){\\n                if (compare(nums1, nums2, i, j))\\n                    res.push_back(nums2[j++]);\\n                else\\n                    res.push_back(nums1[i++]);\\n        }\\n        return res;\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, size_t k) {\\n        vector<vector<int>> largest_num1 = largetsNum(nums1);\\n        vector<vector<int>> largest_num2 = largetsNum(nums2);\\n\\n        vector<int> res;\\n        int start = k > nums2.size() ? k - nums2.size() : 0;\\n\\n        for (int i = start; i < largest_num1.size() && i <= k; i++){\\n            vector<int> tmp = merge(largest_num1[i], largest_num2[k - i]);\\n            if (res.empty() || compare(res, tmp, 0, 0)) res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575872,
                "title": "python-solution",
                "content": "```\\nimport functools\\nclass Solution:\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n1,n2 = len(nums1),len(nums2)\\n        @functools.lru_cache(maxsize=2048)\\n        def recursive(i,j,k):\\n            if k == 0:\\n                return []\\n\\n            m1 = -1\\n            if i < n1:\\n                m1 = max(nums1[i:min(n1,n1+n2-j-k+1)])\\n\\n            m2 = -1\\n            if j < n2:\\n                m2 = max(nums2[j:min(n2,n1+n2-i-k+1)])\\n\\n            if m1 > m2:\\n                ii = i + nums1[i:].index(m1) + 1\\n                return [m1] + recursive(ii,j,k-1)\\n            elif m2 > m1:\\n                jj = j + nums2[j:].index(m2) + 1\\n                return [m2] + recursive(i,jj,k-1)\\n            else:\\n                ii = i + nums1[i:].index(m1) + 1\\n                jj = j + nums2[j:].index(m2) + 1\\n                ans1 = [m1] + recursive(ii,j,k-1)\\n                ans2 = [m2] + recursive(i,jj,k-1)\\n\\n                for a1,a2 in zip(ans1,ans2):\\n                    if a1 > a2:\\n                        return ans1\\n                    elif a2 > a1:\\n                        return ans2\\n\\n                return ans1\\n        \\n        return recursive(0,0,k)\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools\\nclass Solution:\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n1,n2 = len(nums1),len(nums2)\\n        @functools.lru_cache(maxsize=2048)\\n        def recursive(i,j,k):\\n            if k == 0:\\n                return []\\n\\n            m1 = -1\\n            if i < n1:\\n                m1 = max(nums1[i:min(n1,n1+n2-j-k+1)])\\n\\n            m2 = -1\\n            if j < n2:\\n                m2 = max(nums2[j:min(n2,n1+n2-i-k+1)])\\n\\n            if m1 > m2:\\n                ii = i + nums1[i:].index(m1) + 1\\n                return [m1] + recursive(ii,j,k-1)\\n            elif m2 > m1:\\n                jj = j + nums2[j:].index(m2) + 1\\n                return [m2] + recursive(i,jj,k-1)\\n            else:\\n                ii = i + nums1[i:].index(m1) + 1\\n                jj = j + nums2[j:].index(m2) + 1\\n                ans1 = [m1] + recursive(ii,j,k-1)\\n                ans2 = [m2] + recursive(i,jj,k-1)\\n\\n                for a1,a2 in zip(ans1,ans2):\\n                    if a1 > a2:\\n                        return ans1\\n                    elif a2 > a1:\\n                        return ans2\\n\\n                return ans1\\n        \\n        return recursive(0,0,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573843,
                "title": "my-three-solutions-dp-recursive-greedy-not-totally-correct-solution-all-not-ac",
                "content": "Divide and Conquer, Recursive solution (will trigger time limit exceed, 88 / 102 test cases passed.)\\n``` java\\nclass Solution {\\n    int k, h = 0;\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int [] result = new int[k];\\n        this.k = k;\\n        if(k > nums1.length + nums2.length){\\n            return null;\\n        }\\n        String resultValue = getMaxNumber(nums1, nums2, 0);\\n        \\n        int i = 0;\\n        while(i < this.k){\\n            result[i] = resultValue.charAt(i++) - \\'0\\';\\n        }\\n        return result;\\n\\n    }\\n\\n    public String getMaxNumber(int[] nums1, int[] nums2, int h){\\n        StringBuilder result = new StringBuilder();\\n        if(h >= this.k){\\n            return result.toString();\\n        }\\n        Map<String, Integer> map1 = findMax(nums1, nums1.length, nums2.length, h);\\n        Map<String, Integer> map2 = findMax(nums2, nums2.length, nums1.length, h);\\n        if(map1.get(\"maxValue\") == map2.get(\"maxValue\") && map1.get(\"maxIndex\") == -1){\\n            return result.toString();\\n        }\\n        if(map1.get(\"maxValue\") == map2.get(\"maxValue\")){\\n            String tmp1 = getMaxNumber(Arrays.copyOfRange(nums1, map1.get(\"maxIndex\") + 1, nums1.length), nums2, 1 + h);\\n            String tmp2 = getMaxNumber(nums1, Arrays.copyOfRange(nums2, map2.get(\"maxIndex\") + 1, nums2.length), 1 + h);\\n            //get max of tmp1 and tmp2\\n            for(int i = 0; i < tmp1.length(); i++){\\n                if(tmp1.charAt(i) > tmp2.charAt(i)){\\n                    return result.append(map1.get(\"maxValue\")).append(tmp1).toString();\\n                } else if(tmp1.charAt(i) < tmp2.charAt(i)) {\\n                    return result.append(map1.get(\"maxValue\")).append(tmp2).toString();\\n                }\\n            }\\n            return result.append(map1.get(\"maxValue\")).append(tmp1).toString();\\n        } else if (map1.get(\"maxValue\") > map2.get(\"maxValue\")){\\n            return result.append(map1.get(\"maxValue\")).append(getMaxNumber(Arrays.copyOfRange(nums1, map1.get(\"maxIndex\") + 1, nums1.length), nums2, ++h)).toString();\\n        } else {\\n            return result.append(map2.get(\"maxValue\")).append(getMaxNumber(nums1, Arrays.copyOfRange(nums2, map2.get(\"maxIndex\") + 1, nums2.length), ++h)).toString();\\n        }\\n    }\\n\\n    public Map<String, Integer> findMax(int[] nums, int m, int n, int h){\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"maxIndex\", -1);\\n        map.put(\"maxValue\", -1);\\n        if(m == 0){\\n            return map;\\n        }\\n        int maxIndex = 0;\\n        int maxValue = nums[maxIndex];\\n        for(int i = maxIndex + 1; i < Math.min(m, m + n - this.k + h + 1); i++){\\n            if(nums[i] > maxValue){\\n                maxIndex = i;\\n                maxValue = nums[i];\\n            }\\n        }\\n        map.put(\"maxIndex\", maxIndex);\\n        map.put(\"maxValue\", maxValue);\\n        return map;\\n    }\\n}\\n```\\n\\nDynamic Programming solution (will trigger time limit exceed, 85 / 102 test cases passed.)\\n``` java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int [] result = new int[k];\\n        if(k > nums1.length + nums2.length){\\n            return null;\\n        }\\n        String [][][] resultValues = getMaxNumber(nums1, nums2, k);\\n        String resultValue = resultValues[nums1.length][nums2.length][k];\\n        int i = 0;\\n        while(i < k){\\n            result[i] = resultValue.charAt(i++) - \\'0\\';\\n        }\\n        return result;\\n    }\\n\\n    public String[][][] getMaxNumber(int[] nums1, int[] nums2, int k){\\n        String [][][] result = new String[nums1.length + 1][nums2.length + 1][k + 1];\\n        int m = nums1.length, n = nums2.length;\\n\\n        //init\\n        Map<String, Integer> map1, map2;\\n        for(int h = 0; h < k + 1; h++){\\n            for(int i = 1; i < m + 1; i++){\\n                if(h == 0 || h > i){\\n                    result[i][0][h] = \"\";\\n                    continue;\\n                }\\n                map1 = findMax(Arrays.copyOfRange(nums1, m - i, m), i, 0, h);\\n                result[i][0][h] = map1.get(\"maxValue\") + result[i - (map1.get(\"maxIndex\") + 1)][0][h - 1];\\n            }\\n            for(int j = 1; j < n + 1; j++){\\n                if(h == 0 || h > j){\\n                    result[0][j][h] = \"\";\\n                    continue;\\n                }\\n                map2 = findMax(Arrays.copyOfRange(nums2, n - j, n), j, 0, h);\\n                result[0][j][h] = map2.get(\"maxValue\") + result[0][j - (map2.get(\"maxIndex\") + 1)][h - 1];\\n            }\\n            result[0][0][h] = \"\";\\n        }\\n\\n        for(int h = 0; h < k + 1; h++){\\n            for(int i = 1; i < m + 1; i++){\\n                for(int j = 1; j < n + 1; j++){\\n                    if(h > i + j || h == 0){\\n                        result[i][j][h] = \"\";\\n                        continue;\\n                    }\\n                    map1 = findMax(Arrays.copyOfRange(nums1, m - i, m), i, j, h);\\n                    map2 = findMax(Arrays.copyOfRange(nums2, n - j, n), j, i, h);\\n                    if(map1.get(\"maxValue\") == map2.get(\"maxValue\")){\\n                        String tmp1 = result[i - (map1.get(\"maxIndex\") + 1)][j][h - 1];\\n                        String tmp2 = result[i][j - (map2.get(\"maxIndex\") + 1)][h - 1];\\n                        //get max of tmp1 and tmp2\\n                        for(int l = 0; l < tmp1.length(); l++){\\n                            if(tmp1.charAt(l) > tmp2.charAt(l)){\\n                                result[i][j][h] = map1.get(\"maxValue\") + tmp1;\\n                                break;\\n                            } else if(tmp1.charAt(l) < tmp2.charAt(l)) {\\n                                result[i][j][h] = map2.get(\"maxValue\") + tmp2;\\n                                break;\\n                            }\\n                        }\\n                        if(result[i][j][h] == null) result[i][j][h] = map1.get(\"maxValue\") + tmp1;\\n                    } else if (map1.get(\"maxValue\") > map2.get(\"maxValue\")){\\n                        result[i][j][h] = map1.get(\"maxValue\") + result[i - (map1.get(\"maxIndex\") + 1)][j][h - 1];\\n                    } else {\\n                        result[i][j][h] = map2.get(\"maxValue\") + result[i][j - (map2.get(\"maxIndex\") + 1)][h - 1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n\\n    }\\n\\n    public Map<String, Integer> findMax(int[] nums, int m, int n, int k){\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"maxIndex\", -1);\\n        map.put(\"maxValue\", -1);\\n        if(m == 0){\\n            return map;\\n        }\\n        int maxIndex = 0;\\n        int maxValue = nums[maxIndex];\\n        for(int i = maxIndex + 1; i < Math.min(m, m + n - k + 1); i++){\\n            if(nums[i] > maxValue){\\n                maxIndex = i;\\n                maxValue = nums[i];\\n            }\\n        }\\n        map.put(\"maxIndex\", maxIndex);\\n        map.put(\"maxValue\", maxValue);\\n        return map;\\n    }\\n}\\n```\\n\\nGreedy solution (not completely correct, 91 / 102 test cases passed.)\\n``` java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int [] result = new int[k];\\n        if(k > nums1.length + nums2.length || k <= 0){\\n            return null;\\n        }\\n        result = getMaxNumber(nums1, nums2, k);\\n        return result;\\n    }\\n\\n    public int[] getMaxNumber(int[] nums1, int[] nums2, int k){\\n        int [] result = new int[k];\\n        int m = nums1.length, n = nums2.length;\\n        Map<String, Integer> map1, map2, tmpMapi1, tmpMapj1, tmpMapi2, tmpMapj2;\\n        int i = 0, j = 0, tmpi = 0, tmpj = 0;\\n        \\n        for(int h = 0; h < k; h++){\\n            map1 = findMax(Arrays.copyOfRange(nums1, i, m), m - i, n - j, k - h);\\n            map2 = findMax(Arrays.copyOfRange(nums2, j, n), n - j, m - i, k - h);\\n            if(map1.get(\"maxValue\") == map2.get(\"maxValue\")){\\n                tmpMapi1 = map1;\\n                tmpMapj1 = map2;\\n                tmpMapi2 = map1;\\n                tmpMapj2 = map2;\\n                tmpi = i;\\n                tmpj = j;\\n                //9\\uFF0C10 \\uFF1B 9\\uFF0C10  \\u600E\\u4E48\\u5904\\u7406\\u3002\\n                while(h < k && Math.max(tmpMapi1.get(\"maxValue\"), tmpMapj1.get(\"maxValue\")) == Math.max(tmpMapi2.get(\"maxValue\"), tmpMapj2.get(\"maxValue\"))\\n                        && tmpMapi1.get(\"maxValue\") >= tmpMapj1.get(\"maxValue\") \\n                        && tmpMapj2.get(\"maxValue\") >= tmpMapi2.get(\"maxValue\")){\\n                    result[h++] = Math.max(tmpMapi1.get(\"maxValue\"), tmpMapj1.get(\"maxValue\"));\\n                    //always choose nums1\\n                    tmpi = tmpi + tmpMapi1.get(\"maxIndex\") + 1;\\n                    tmpMapi1 = findMax(Arrays.copyOfRange(nums1, tmpi, m), m - tmpi, n - j, k - h);\\n                    tmpMapj1 = findMax(Arrays.copyOfRange(nums2, j, n), n - j, m - tmpi, k - h);\\n                    //always choose nums2\\n                    tmpj = tmpj + tmpMapj2.get(\"maxIndex\") + 1;\\n                    tmpMapi2 = findMax(Arrays.copyOfRange(nums1, i, m), m - i, n - tmpj, k - h);\\n                    tmpMapj2 = findMax(Arrays.copyOfRange(nums2, tmpj, n), n - tmpj, m - i, k - h);\\n                    if(tmpMapi1.get(\"maxIndex\") == -1 || tmpMapj2.get(\"maxIndex\") == -1){\\n                        break;\\n                    }\\n                }\\n                if(Math.max(tmpMapi1.get(\"maxValue\"), tmpMapj1.get(\"maxValue\")) > Math.max(tmpMapi2.get(\"maxValue\"), tmpMapj2.get(\"maxValue\"))){\\n                    i = tmpi;\\n                    h--;\\n                } else {\\n                    j = tmpj;\\n                    h--;\\n                }\\n            } else if (map1.get(\"maxValue\") > map2.get(\"maxValue\")){\\n                i = i + map1.get(\"maxIndex\") + 1;\\n                result[h] = map1.get(\"maxValue\");\\n            } else {\\n                j = j + map2.get(\"maxIndex\") + 1;\\n                result[h] = map2.get(\"maxValue\");\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Map<String, Integer> findMax(int[] nums, int m, int n, int k){\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"maxIndex\", -1);\\n        map.put(\"maxValue\", -1);\\n        if(m == 0){\\n            return map;\\n        }\\n        int maxIndex = 0;\\n        int maxValue = nums[maxIndex];\\n        for(int i = maxIndex + 1; i < Math.min(m, m + n - k + 1); i++){\\n            if(nums[i] > maxValue){\\n                maxIndex = i;\\n                maxValue = nums[i];\\n            }\\n        }\\n        map.put(\"maxIndex\", maxIndex);\\n        map.put(\"maxValue\", maxValue);\\n        return map;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    int k, h = 0;\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int [] result = new int[k];\\n        this.k = k;\\n        if(k > nums1.length + nums2.length){\\n            return null;\\n        }\\n        String resultValue = getMaxNumber(nums1, nums2, 0);\\n        \\n        int i = 0;\\n        while(i < this.k){\\n            result[i] = resultValue.charAt(i++) - \\'0\\';\\n        }\\n        return result;\\n\\n    }\\n\\n    public String getMaxNumber(int[] nums1, int[] nums2, int h){\\n        StringBuilder result = new StringBuilder();\\n        if(h >= this.k){\\n            return result.toString();\\n        }\\n        Map<String, Integer> map1 = findMax(nums1, nums1.length, nums2.length, h);\\n        Map<String, Integer> map2 = findMax(nums2, nums2.length, nums1.length, h);\\n        if(map1.get(\"maxValue\") == map2.get(\"maxValue\") && map1.get(\"maxIndex\") == -1){\\n            return result.toString();\\n        }\\n        if(map1.get(\"maxValue\") == map2.get(\"maxValue\")){\\n            String tmp1 = getMaxNumber(Arrays.copyOfRange(nums1, map1.get(\"maxIndex\") + 1, nums1.length), nums2, 1 + h);\\n            String tmp2 = getMaxNumber(nums1, Arrays.copyOfRange(nums2, map2.get(\"maxIndex\") + 1, nums2.length), 1 + h);\\n            //get max of tmp1 and tmp2\\n            for(int i = 0; i < tmp1.length(); i++){\\n                if(tmp1.charAt(i) > tmp2.charAt(i)){\\n                    return result.append(map1.get(\"maxValue\")).append(tmp1).toString();\\n                } else if(tmp1.charAt(i) < tmp2.charAt(i)) {\\n                    return result.append(map1.get(\"maxValue\")).append(tmp2).toString();\\n                }\\n            }\\n            return result.append(map1.get(\"maxValue\")).append(tmp1).toString();\\n        } else if (map1.get(\"maxValue\") > map2.get(\"maxValue\")){\\n            return result.append(map1.get(\"maxValue\")).append(getMaxNumber(Arrays.copyOfRange(nums1, map1.get(\"maxIndex\") + 1, nums1.length), nums2, ++h)).toString();\\n        } else {\\n            return result.append(map2.get(\"maxValue\")).append(getMaxNumber(nums1, Arrays.copyOfRange(nums2, map2.get(\"maxIndex\") + 1, nums2.length), ++h)).toString();\\n        }\\n    }\\n\\n    public Map<String, Integer> findMax(int[] nums, int m, int n, int h){\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"maxIndex\", -1);\\n        map.put(\"maxValue\", -1);\\n        if(m == 0){\\n            return map;\\n        }\\n        int maxIndex = 0;\\n        int maxValue = nums[maxIndex];\\n        for(int i = maxIndex + 1; i < Math.min(m, m + n - this.k + h + 1); i++){\\n            if(nums[i] > maxValue){\\n                maxIndex = i;\\n                maxValue = nums[i];\\n            }\\n        }\\n        map.put(\"maxIndex\", maxIndex);\\n        map.put(\"maxValue\", maxValue);\\n        return map;\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int [] result = new int[k];\\n        if(k > nums1.length + nums2.length){\\n            return null;\\n        }\\n        String [][][] resultValues = getMaxNumber(nums1, nums2, k);\\n        String resultValue = resultValues[nums1.length][nums2.length][k];\\n        int i = 0;\\n        while(i < k){\\n            result[i] = resultValue.charAt(i++) - \\'0\\';\\n        }\\n        return result;\\n    }\\n\\n    public String[][][] getMaxNumber(int[] nums1, int[] nums2, int k){\\n        String [][][] result = new String[nums1.length + 1][nums2.length + 1][k + 1];\\n        int m = nums1.length, n = nums2.length;\\n\\n        //init\\n        Map<String, Integer> map1, map2;\\n        for(int h = 0; h < k + 1; h++){\\n            for(int i = 1; i < m + 1; i++){\\n                if(h == 0 || h > i){\\n                    result[i][0][h] = \"\";\\n                    continue;\\n                }\\n                map1 = findMax(Arrays.copyOfRange(nums1, m - i, m), i, 0, h);\\n                result[i][0][h] = map1.get(\"maxValue\") + result[i - (map1.get(\"maxIndex\") + 1)][0][h - 1];\\n            }\\n            for(int j = 1; j < n + 1; j++){\\n                if(h == 0 || h > j){\\n                    result[0][j][h] = \"\";\\n                    continue;\\n                }\\n                map2 = findMax(Arrays.copyOfRange(nums2, n - j, n), j, 0, h);\\n                result[0][j][h] = map2.get(\"maxValue\") + result[0][j - (map2.get(\"maxIndex\") + 1)][h - 1];\\n            }\\n            result[0][0][h] = \"\";\\n        }\\n\\n        for(int h = 0; h < k + 1; h++){\\n            for(int i = 1; i < m + 1; i++){\\n                for(int j = 1; j < n + 1; j++){\\n                    if(h > i + j || h == 0){\\n                        result[i][j][h] = \"\";\\n                        continue;\\n                    }\\n                    map1 = findMax(Arrays.copyOfRange(nums1, m - i, m), i, j, h);\\n                    map2 = findMax(Arrays.copyOfRange(nums2, n - j, n), j, i, h);\\n                    if(map1.get(\"maxValue\") == map2.get(\"maxValue\")){\\n                        String tmp1 = result[i - (map1.get(\"maxIndex\") + 1)][j][h - 1];\\n                        String tmp2 = result[i][j - (map2.get(\"maxIndex\") + 1)][h - 1];\\n                        //get max of tmp1 and tmp2\\n                        for(int l = 0; l < tmp1.length(); l++){\\n                            if(tmp1.charAt(l) > tmp2.charAt(l)){\\n                                result[i][j][h] = map1.get(\"maxValue\") + tmp1;\\n                                break;\\n                            } else if(tmp1.charAt(l) < tmp2.charAt(l)) {\\n                                result[i][j][h] = map2.get(\"maxValue\") + tmp2;\\n                                break;\\n                            }\\n                        }\\n                        if(result[i][j][h] == null) result[i][j][h] = map1.get(\"maxValue\") + tmp1;\\n                    } else if (map1.get(\"maxValue\") > map2.get(\"maxValue\")){\\n                        result[i][j][h] = map1.get(\"maxValue\") + result[i - (map1.get(\"maxIndex\") + 1)][j][h - 1];\\n                    } else {\\n                        result[i][j][h] = map2.get(\"maxValue\") + result[i][j - (map2.get(\"maxIndex\") + 1)][h - 1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n\\n    }\\n\\n    public Map<String, Integer> findMax(int[] nums, int m, int n, int k){\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"maxIndex\", -1);\\n        map.put(\"maxValue\", -1);\\n        if(m == 0){\\n            return map;\\n        }\\n        int maxIndex = 0;\\n        int maxValue = nums[maxIndex];\\n        for(int i = maxIndex + 1; i < Math.min(m, m + n - k + 1); i++){\\n            if(nums[i] > maxValue){\\n                maxIndex = i;\\n                maxValue = nums[i];\\n            }\\n        }\\n        map.put(\"maxIndex\", maxIndex);\\n        map.put(\"maxValue\", maxValue);\\n        return map;\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int [] result = new int[k];\\n        if(k > nums1.length + nums2.length || k <= 0){\\n            return null;\\n        }\\n        result = getMaxNumber(nums1, nums2, k);\\n        return result;\\n    }\\n\\n    public int[] getMaxNumber(int[] nums1, int[] nums2, int k){\\n        int [] result = new int[k];\\n        int m = nums1.length, n = nums2.length;\\n        Map<String, Integer> map1, map2, tmpMapi1, tmpMapj1, tmpMapi2, tmpMapj2;\\n        int i = 0, j = 0, tmpi = 0, tmpj = 0;\\n        \\n        for(int h = 0; h < k; h++){\\n            map1 = findMax(Arrays.copyOfRange(nums1, i, m), m - i, n - j, k - h);\\n            map2 = findMax(Arrays.copyOfRange(nums2, j, n), n - j, m - i, k - h);\\n            if(map1.get(\"maxValue\") == map2.get(\"maxValue\")){\\n                tmpMapi1 = map1;\\n                tmpMapj1 = map2;\\n                tmpMapi2 = map1;\\n                tmpMapj2 = map2;\\n                tmpi = i;\\n                tmpj = j;\\n                //9\\uFF0C10 \\uFF1B 9\\uFF0C10  \\u600E\\u4E48\\u5904\\u7406\\u3002\\n                while(h < k && Math.max(tmpMapi1.get(\"maxValue\"), tmpMapj1.get(\"maxValue\")) == Math.max(tmpMapi2.get(\"maxValue\"), tmpMapj2.get(\"maxValue\"))\\n                        && tmpMapi1.get(\"maxValue\") >= tmpMapj1.get(\"maxValue\") \\n                        && tmpMapj2.get(\"maxValue\") >= tmpMapi2.get(\"maxValue\")){\\n                    result[h++] = Math.max(tmpMapi1.get(\"maxValue\"), tmpMapj1.get(\"maxValue\"));\\n                    //always choose nums1\\n                    tmpi = tmpi + tmpMapi1.get(\"maxIndex\") + 1;\\n                    tmpMapi1 = findMax(Arrays.copyOfRange(nums1, tmpi, m), m - tmpi, n - j, k - h);\\n                    tmpMapj1 = findMax(Arrays.copyOfRange(nums2, j, n), n - j, m - tmpi, k - h);\\n                    //always choose nums2\\n                    tmpj = tmpj + tmpMapj2.get(\"maxIndex\") + 1;\\n                    tmpMapi2 = findMax(Arrays.copyOfRange(nums1, i, m), m - i, n - tmpj, k - h);\\n                    tmpMapj2 = findMax(Arrays.copyOfRange(nums2, tmpj, n), n - tmpj, m - i, k - h);\\n                    if(tmpMapi1.get(\"maxIndex\") == -1 || tmpMapj2.get(\"maxIndex\") == -1){\\n                        break;\\n                    }\\n                }\\n                if(Math.max(tmpMapi1.get(\"maxValue\"), tmpMapj1.get(\"maxValue\")) > Math.max(tmpMapi2.get(\"maxValue\"), tmpMapj2.get(\"maxValue\"))){\\n                    i = tmpi;\\n                    h--;\\n                } else {\\n                    j = tmpj;\\n                    h--;\\n                }\\n            } else if (map1.get(\"maxValue\") > map2.get(\"maxValue\")){\\n                i = i + map1.get(\"maxIndex\") + 1;\\n                result[h] = map1.get(\"maxValue\");\\n            } else {\\n                j = j + map2.get(\"maxIndex\") + 1;\\n                result[h] = map2.get(\"maxValue\");\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Map<String, Integer> findMax(int[] nums, int m, int n, int k){\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"maxIndex\", -1);\\n        map.put(\"maxValue\", -1);\\n        if(m == 0){\\n            return map;\\n        }\\n        int maxIndex = 0;\\n        int maxValue = nums[maxIndex];\\n        for(int i = maxIndex + 1; i < Math.min(m, m + n - k + 1); i++){\\n            if(nums[i] > maxValue){\\n                maxIndex = i;\\n                maxValue = nums[i];\\n            }\\n        }\\n        map.put(\"maxIndex\", maxIndex);\\n        map.put(\"maxValue\", maxValue);\\n        return map;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567690,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1569073,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1567248,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1814460,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1575654,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1574818,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1573634,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1570516,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1571577,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 2045990,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1567690,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1569073,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1567248,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1814460,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1575654,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1574818,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1573634,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1570516,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1571577,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 2045990,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! 🤯\n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Open the Lock",
        "question_content": "<p>You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: <code>&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;</code>. The wheels can rotate freely and wrap around: for example we can turn <code>&#39;9&#39;</code> to be <code>&#39;0&#39;</code>, or <code>&#39;0&#39;</code> to be <code>&#39;9&#39;</code>. Each move consists of turning one wheel one slot.</p>\n\n<p>The lock initially starts at <code>&#39;0000&#39;</code>, a string representing the state of the 4 wheels.</p>\n\n<p>You are given a list of <code>deadends</code> dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.</p>\n\n<p>Given a <code>target</code> representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> \nA sequence of valid moves would be &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;.\nNote that a sequence like &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; would be invalid,\nbecause the wheels of the lock become stuck after the display becomes the dead end &quot;0102&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> deadends = [&quot;8888&quot;], target = &quot;0009&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We can turn the last wheel in reverse to move from &quot;0000&quot; -&gt; &quot;0009&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> We cannot reach the target without getting stuck.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= deadends.length &lt;= 500</code></li>\n\t<li><code>deadends[i].length == 4</code></li>\n\t<li><code>target.length == 4</code></li>\n\t<li>target <strong>will not be</strong> in the list <code>deadends</code>.</li>\n\t<li><code>target</code> and <code>deadends[i]</code> consist of digits only.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 110237,
                "title": "regular-java-bfs-solution-and-2-end-bfs-solution-with-improvement",
                "content": "Basic solution, runtime: 260ms\\n```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Queue<String> q = new LinkedList<>();\\n        Set<String> deads = new HashSet<>(Arrays.asList(deadends));\\n        Set<String> visited = new HashSet<>();\\n        q.offer(\"0000\");\\n        visited.add(\"0000\");\\n        int level = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            while(size > 0) {\\n                String s = q.poll();\\n                if(deads.contains(s)) {\\n                    size --;\\n                    continue;\\n                }\\n                if(s.equals(target)) return level;\\n                StringBuilder sb = new StringBuilder(s);\\n                for(int i = 0; i < 4; i ++) {\\n                    char c = sb.charAt(i);\\n                    String s1 = sb.substring(0, i) + (c == '9' ? 0 : c - '0' + 1) + sb.substring(i + 1);\\n                    String s2 = sb.substring(0, i) + (c == '0' ? 9 : c - '0' - 1) + sb.substring(i + 1);\\n                    if(!visited.contains(s1) && !deads.contains(s1)) {\\n                        q.offer(s1);\\n                        visited.add(s1);\\n                    }\\n                    if(!visited.contains(s2) && !deads.contains(s2)) {\\n                        q.offer(s2);\\n                        visited.add(s2);\\n                    }\\n                }\\n                size --;\\n            }\\n            level ++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\nRegular 2 - end solution, runtime: 85ms\\n```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> begin = new HashSet<>();\\n        Set<String> end = new HashSet<>();\\n        Set<String> deads = new HashSet<>(Arrays.asList(deadends));\\n        begin.add(\"0000\");\\n        end.add(target);\\n        int level = 0;\\n        while(!begin.isEmpty() && !end.isEmpty()) {\\n            Set<String> temp = new HashSet<>();\\n            for(String s : begin) {\\n                if(end.contains(s)) return level;\\n                if(deads.contains(s)) continue;\\n                deads.add(s);\\n                StringBuilder sb = new StringBuilder(s);\\n                for(int i = 0; i < 4; i ++) {\\n                    char c = sb.charAt(i);\\n                    String s1 = sb.substring(0, i) + (c == '9' ? 0 : c - '0' + 1) + sb.substring(i + 1);\\n                    String s2 = sb.substring(0, i) + (c == '0' ? 9 : c - '0' - 1) + sb.substring(i + 1);\\n                    if(!deads.contains(s1))\\n                        temp.add(s1);\\n                    if(!deads.contains(s2))\\n                        temp.add(s2);\\n                }\\n            }\\n            level ++;\\n            begin = end;\\n            end = temp;\\n        }\\n        return -1;\\n    }\\n}\\n```\\nYou can still improve this 2-end solution, by adding:\\n```\\nif (begin.size() > end.size()) {\\n    temp = begin;\\n    begin = end;\\n    end = temp;\\n}\\n```\\nBy always picking a smaller set, this process could reduce a little(since in this problem the scale on both sides are similar) time complexity and memory complexity. Here's the full version, runtime: 80ms\\n```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> begin = new HashSet<>();\\n        Set<String> end = new HashSet<>();\\n        Set<String> deads = new HashSet<>(Arrays.asList(deadends));\\n        begin.add(\"0000\");\\n        end.add(target);\\n        int level = 0;\\n        Set<String> temp;\\n        while(!begin.isEmpty() && !end.isEmpty()) {\\n            if (begin.size() > end.size()) {\\n                temp = begin;\\n                begin = end;\\n                end = temp;\\n            }\\n            temp = new HashSet<>();\\n            for(String s : begin) {\\n                if(end.contains(s)) return level;\\n                if(deads.contains(s)) continue;\\n                deads.add(s);\\n                StringBuilder sb = new StringBuilder(s);\\n                for(int i = 0; i < 4; i ++) {\\n                    char c = sb.charAt(i);\\n                    String s1 = sb.substring(0, i) + (c == '9' ? 0 : c - '0' + 1) + sb.substring(i + 1);\\n                    String s2 = sb.substring(0, i) + (c == '0' ? 9 : c - '0' - 1) + sb.substring(i + 1);\\n                    if(!deads.contains(s1))\\n                        temp.add(s1);\\n                    if(!deads.contains(s2))\\n                        temp.add(s2);\\n                }\\n            }\\n            level ++;\\n            begin = temp;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Queue<String> q = new LinkedList<>();\\n        Set<String> deads = new HashSet<>(Arrays.asList(deadends));\\n        Set<String> visited = new HashSet<>();\\n        q.offer(\"0000\");\\n        visited.add(\"0000\");\\n        int level = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            while(size > 0) {\\n                String s = q.poll();\\n                if(deads.contains(s)) {\\n                    size --;\\n                    continue;\\n                }\\n                if(s.equals(target)) return level;\\n                StringBuilder sb = new StringBuilder(s);\\n                for(int i = 0; i < 4; i ++) {\\n                    char c = sb.charAt(i);\\n                    String s1 = sb.substring(0, i) + (c == '9' ? 0 : c - '0' + 1) + sb.substring(i + 1);\\n                    String s2 = sb.substring(0, i) + (c == '0' ? 9 : c - '0' - 1) + sb.substring(i + 1);\\n                    if(!visited.contains(s1) && !deads.contains(s1)) {\\n                        q.offer(s1);\\n                        visited.add(s1);\\n                    }\\n                    if(!visited.contains(s2) && !deads.contains(s2)) {\\n                        q.offer(s2);\\n                        visited.add(s2);\\n                    }\\n                }\\n                size --;\\n            }\\n            level ++;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> begin = new HashSet<>();\\n        Set<String> end = new HashSet<>();\\n        Set<String> deads = new HashSet<>(Arrays.asList(deadends));\\n        begin.add(\"0000\");\\n        end.add(target);\\n        int level = 0;\\n        while(!begin.isEmpty() && !end.isEmpty()) {\\n            Set<String> temp = new HashSet<>();\\n            for(String s : begin) {\\n                if(end.contains(s)) return level;\\n                if(deads.contains(s)) continue;\\n                deads.add(s);\\n                StringBuilder sb = new StringBuilder(s);\\n                for(int i = 0; i < 4; i ++) {\\n                    char c = sb.charAt(i);\\n                    String s1 = sb.substring(0, i) + (c == '9' ? 0 : c - '0' + 1) + sb.substring(i + 1);\\n                    String s2 = sb.substring(0, i) + (c == '0' ? 9 : c - '0' - 1) + sb.substring(i + 1);\\n                    if(!deads.contains(s1))\\n                        temp.add(s1);\\n                    if(!deads.contains(s2))\\n                        temp.add(s2);\\n                }\\n            }\\n            level ++;\\n            begin = end;\\n            end = temp;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nif (begin.size() > end.size()) {\\n    temp = begin;\\n    begin = end;\\n    end = temp;\\n}\\n```\n```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> begin = new HashSet<>();\\n        Set<String> end = new HashSet<>();\\n        Set<String> deads = new HashSet<>(Arrays.asList(deadends));\\n        begin.add(\"0000\");\\n        end.add(target);\\n        int level = 0;\\n        Set<String> temp;\\n        while(!begin.isEmpty() && !end.isEmpty()) {\\n            if (begin.size() > end.size()) {\\n                temp = begin;\\n                begin = end;\\n                end = temp;\\n            }\\n            temp = new HashSet<>();\\n            for(String s : begin) {\\n                if(end.contains(s)) return level;\\n                if(deads.contains(s)) continue;\\n                deads.add(s);\\n                StringBuilder sb = new StringBuilder(s);\\n                for(int i = 0; i < 4; i ++) {\\n                    char c = sb.charAt(i);\\n                    String s1 = sb.substring(0, i) + (c == '9' ? 0 : c - '0' + 1) + sb.substring(i + 1);\\n                    String s2 = sb.substring(0, i) + (c == '0' ? 9 : c - '0' - 1) + sb.substring(i + 1);\\n                    if(!deads.contains(s1))\\n                        temp.add(s1);\\n                    if(!deads.contains(s2))\\n                        temp.add(s2);\\n                }\\n            }\\n            level ++;\\n            begin = temp;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250580,
                "title": "c-java-python-bfs-level-order-traverse-clean-concise",
                "content": "**Idea**\\n- By using BFS, we can generate all possible of locks, initialize with `\"0000\"`.\\n- For each step, we can generates neighbors of current lock state (by turning clockwise or counter-clockwise of 4 circular wheels) and go to its neighbors if neighbor is not in our `deadends`.\\n- If we meet the `target` then the current `steps` is minimum number of turns to open the target lock.\\n\\n**Complexity**\\n- Time: `O(N^2 * A^N + D)`, where `N` is number of dials (4 in our case), `A` is number of alphabet (10 in our case), `D` is size of `deadends`.\\n\\t- There are 10^4 possible combinations => `O(A^N)`\\n\\t- To get neighbors, for each combination, we are looping 4 times (which is `N`) and in each iteration, there are substring operations which costs `O(N)` => `O(N^2)`\\n\\t- Total `O(D)` to create the hashset\\n- Space: `O(A^N)`, in worst case equal to number of combinations.\\n\\n<iframe src=\"https://leetcode.com/playground/iLJVZUzU/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>",
                "solutionTags": [],
                "code": "**Idea**\\n- By using BFS, we can generate all possible of locks, initialize with `\"0000\"`.\\n- For each step, we can generates neighbors of current lock state (by turning clockwise or counter-clockwise of 4 circular wheels) and go to its neighbors if neighbor is not in our `deadends`.\\n- If we meet the `target` then the current `steps` is minimum number of turns to open the target lock.\\n\\n**Complexity**\\n- Time: `O(N^2 * A^N + D)`, where `N` is number of dials (4 in our case), `A` is number of alphabet (10 in our case), `D` is size of `deadends`.\\n\\t- There are 10^4 possible combinations => `O(A^N)`\\n\\t- To get neighbors, for each combination, we are looping 4 times (which is `N`) and in each iteration, there are substring operations which costs `O(N)` => `O(N^2)`\\n\\t- Total `O(D)` to create the hashset\\n- Space: `O(A^N)`, in worst case equal to number of combinations.\\n\\n<iframe src=\"https://leetcode.com/playground/iLJVZUzU/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 110232,
                "title": "accepted-python-java-bfs-how-to-avoid-tle",
                "content": "Shortest path finding, when the weights are constant, as in this case = 1, BFS is the best way to go.\\nBest way to avoid TLE is by using deque and popleft() .\\n[Using list() and pop(0) is a linear operation in Python, resulting in TLE]\\n\\nPython:\\n\\n```\\n    def openLock(self, deadends, target):\\n        marker, depth = \\'x\\', -1\\n        visited, q = set(deadends), deque([\\'0000\\'])\\n\\n        while q:\\n            size = len(q)\\n            depth += 1\\n            for _ in range(size):\\n                node = q.popleft()\\n                if node == target: return depth\\n                if node in visited: continue\\n                visited.add(node)\\n                q.extend(self.successors(node))\\n        return -1\\n\\n    def successors(self, src):\\n        res = []\\n        for i, ch in enumerate(src):\\n            num = int(ch)\\n            res.append(src[:i] + str((num - 1) % 10) + src[i+1:])\\n            res.append(src[:i] + str((num + 1) % 10) + src[i+1:])\\n        return res\\n```\\n\\nJava:\\n\\n```\\npublic static int openLock(String[] deadends, String target) {\\n        Queue<String> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>(Arrays.asList(deadends));\\n        int depth = -1;\\n        q.addAll(Arrays.asList(\"0000\"));\\n        while(!q.isEmpty()) {\\n            depth++;\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                String node = q.poll();\\n                if(node.equals(target))\\n                    return depth;\\n                if(visited.contains(node))\\n                    continue;\\n                visited.add(node);\\n                q.addAll(getSuccessors(node));\\n            }\\n        }\\n        return -1;\\n    }\\n\\t\\n    private static List<String> getSuccessors(String str) {\\n        List<String> res = new LinkedList<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            res.add(str.substring(0, i) + (str.charAt(i) == \\'0\\' ? 9 :  str.charAt(i) - \\'0\\' - 1) + str.substring(i+1));\\n            res.add(str.substring(0, i) + (str.charAt(i) == \\'9\\' ? 0 :  str.charAt(i) - \\'0\\' + 1) + str.substring(i+1));\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    def openLock(self, deadends, target):\\n        marker, depth = \\'x\\', -1\\n        visited, q = set(deadends), deque([\\'0000\\'])\\n\\n        while q:\\n            size = len(q)\\n            depth += 1\\n            for _ in range(size):\\n                node = q.popleft()\\n                if node == target: return depth\\n                if node in visited: continue\\n                visited.add(node)\\n                q.extend(self.successors(node))\\n        return -1\\n\\n    def successors(self, src):\\n        res = []\\n        for i, ch in enumerate(src):\\n            num = int(ch)\\n            res.append(src[:i] + str((num - 1) % 10) + src[i+1:])\\n            res.append(src[:i] + str((num + 1) % 10) + src[i+1:])\\n        return res\\n```\n```\\npublic static int openLock(String[] deadends, String target) {\\n        Queue<String> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>(Arrays.asList(deadends));\\n        int depth = -1;\\n        q.addAll(Arrays.asList(\"0000\"));\\n        while(!q.isEmpty()) {\\n            depth++;\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                String node = q.poll();\\n                if(node.equals(target))\\n                    return depth;\\n                if(visited.contains(node))\\n                    continue;\\n                visited.add(node);\\n                q.addAll(getSuccessors(node));\\n            }\\n        }\\n        return -1;\\n    }\\n\\t\\n    private static List<String> getSuccessors(String str) {\\n        List<String> res = new LinkedList<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            res.add(str.substring(0, i) + (str.charAt(i) == \\'0\\' ? 9 :  str.charAt(i) - \\'0\\' - 1) + str.substring(i+1));\\n            res.add(str.substring(0, i) + (str.charAt(i) == \\'9\\' ? 0 :  str.charAt(i) - \\'0\\' + 1) + str.substring(i+1));\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 110230,
                "title": "bfs-solution-c",
                "content": "Every node has 8 edges. The nodes in dead ends cannot be visited. Find the shortest path from the initial node to the target.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> dds(deadends.begin(), deadends.end());\\n        unordered_set<string> visited;\\n        queue<string> bfs;\\n        string init = \"0000\";\\n        if (dds.find(init) != dds.end()) return -1;\\n        visited.insert(\"0000\");\\n        bfs.push(\"0000\");\\n        int res = 0;\\n        while (!bfs.empty()) {\\n            int sz = bfs.size();\\n            for (int i = 0; i < sz; i++) {\\n                string t = bfs.front(); bfs.pop();\\n                vector<string> nbrs = move(nbrStrs(t));\\n                for (auto s : nbrs) {\\n                    if (s == target) return ++res;\\n                    if (visited.find(s) != visited.end()) continue;\\n                    if (dds.find(s) == dds.end()) {\\n                        bfs.push(s);\\n                        visited.insert(s);\\n                    }\\n                }\\n            }\\n            ++res;\\n        }\\n        return -1;\\n    }\\n    \\n    \\n    vector<string> nbrStrs(string key) {\\n        vector<string> res;\\n        for (int i = 0 ; i < 4; i++) {\\n            string tmp = key;\\n            tmp[i] = (key[i] - '0' + 1) % 10 + '0';\\n            res.push_back(tmp);\\n            tmp[i] = (key[i] - '0' - 1 + 10) % 10 + '0';\\n            res.push_back(tmp);\\n         }\\n        return res;\\n    }\\n};\\n```\\n\\nBidirectional BFS improves the efficiency\\n```\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> dds(deadends.begin(), deadends.end());\\n        unordered_set<string> q1, q2, pass, visited;\\n        string init = \"0000\";\\n        if (dds.find(init) != dds.end() || dds.find(target) != dds.end()) return -1;\\n        visited.insert(\"0000\");\\n        q1.insert(\"0000\"), q2.insert(target);\\n        int res = 0;\\n        while (!q1.empty() && !q2.empty()) {\\n            if (q1.size() > q2.size()) swap(q1, q2);\\n            pass.clear();\\n            for (auto ss : q1) {\\n                vector<string> nbrs = nbrStrs(ss);\\n                for (auto s : nbrs) {\\n                    if (q2.find(s) != q2.end()) return res + 1;\\n                    if (visited.find(s) != visited.end()) continue;\\n                    if (dds.find(s) == dds.end()) {\\n                        pass.insert(s);\\n                        visited.insert(s);\\n                    }\\n                }\\n            }\\n            swap(q1, pass);\\n            res++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> dds(deadends.begin(), deadends.end());\\n        unordered_set<string> visited;\\n        queue<string> bfs;\\n        string init = \"0000\";\\n        if (dds.find(init) != dds.end()) return -1;\\n        visited.insert(\"0000\");\\n        bfs.push(\"0000\");\\n        int res = 0;\\n        while (!bfs.empty()) {\\n            int sz = bfs.size();\\n            for (int i = 0; i < sz; i++) {\\n                string t = bfs.front(); bfs.pop();\\n                vector<string> nbrs = move(nbrStrs(t));\\n                for (auto s : nbrs) {\\n                    if (s == target) return ++res;\\n                    if (visited.find(s) != visited.end()) continue;\\n                    if (dds.find(s) == dds.end()) {\\n                        bfs.push(s);\\n                        visited.insert(s);\\n                    }\\n                }\\n            }\\n            ++res;\\n        }\\n        return -1;\\n    }\\n    \\n    \\n    vector<string> nbrStrs(string key) {\\n        vector<string> res;\\n        for (int i = 0 ; i < 4; i++) {\\n            string tmp = key;\\n            tmp[i] = (key[i] - '0' + 1) % 10 + '0';\\n            res.push_back(tmp);\\n            tmp[i] = (key[i] - '0' - 1 + 10) % 10 + '0';\\n            res.push_back(tmp);\\n         }\\n        return res;\\n    }\\n};\\n```\n```\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> dds(deadends.begin(), deadends.end());\\n        unordered_set<string> q1, q2, pass, visited;\\n        string init = \"0000\";\\n        if (dds.find(init) != dds.end() || dds.find(target) != dds.end()) return -1;\\n        visited.insert(\"0000\");\\n        q1.insert(\"0000\"), q2.insert(target);\\n        int res = 0;\\n        while (!q1.empty() && !q2.empty()) {\\n            if (q1.size() > q2.size()) swap(q1, q2);\\n            pass.clear();\\n            for (auto ss : q1) {\\n                vector<string> nbrs = nbrStrs(ss);\\n                for (auto s : nbrs) {\\n                    if (q2.find(s) != q2.end()) return res + 1;\\n                    if (visited.find(s) != visited.end()) continue;\\n                    if (dds.find(s) == dds.end()) {\\n                        pass.insert(s);\\n                        visited.insert(s);\\n                    }\\n                }\\n            }\\n            swap(q1, pass);\\n            res++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250656,
                "title": "short-easy-solution-bfs-traversal-explained-w-commented-code",
                "content": "\\u2714\\uFE0F ***Solution - I (BFS)***\\n\\nFirst, let\\'s simplify the problem statement. We are given a string *`start = \"0000\"`* and asked to reach *`target`* by turning (minimum times) a digit forward or backward one at a time without reaching any of the strings in *`deadends`*.\\n\\nWe can\\'t just turn a digit forward or backward just based on which turn gets us quicker to the corresponding digit of target faster because this approach may lead us towards a **deadend**. So, it makes sense to try and turn a digit in both the direction and return the one that leads to *`target`* in minimum moves.\\n\\nThe solution can be modelled as a **BFS traversal**, wherein we try to shift each digit of current string *`curstr`* in both the possible direction. We **increment *`turns`* at each level of BFS and return when *`target`*** is reached during the traversal.\\n\\nWe use a hashset to insert all the *`deadends`* string for efficient check on whether we reach a deadend at anytime. Similarly, we store all the visited string in *`visited`* to ensure that we won\\'t revisit a string again. For BFS traversal, we would also require to maintain a queue. The algorithm can be summed up into following steps:-\\n\\n1. Insert all strings from *`deadends`* into a hashset and also maintain a *`visited`* set for all strings traversed so far.\\n2. Start BFS traversal from `\"0000\"` by pushing it into the queue and looping till the queue becomes empty.\\n3. At each level of BFS, take the current string and try turning each digit in both forward & backward direction. For eg. we can apply the turning process on `\"0000\"` to get `[\"1000\", \"9000\", \"0100\", \"0900\", \"0010\", \"0090\", \"0001\", \"0009\"]`.\\n4. If any of the strings after applying turning process become equal to *`target`*, return the *`turns`* required till now.\\n5. Else, just push the turned strings into the queue, insert it into *`visited`* set and repeat the same process for all strings in the queue.\\n6. If the queue becomes empty, we have tried all possible paths to reach *`target`* and failed. So return -1.\\n\\n**C++**\\n```\\nint openLock(vector<string>& deadends, string target) {\\n\\tunordered_set<string> dead(begin(deadends), end(deadends)), seen({\"0000\"});\\n\\tif(dead.find(\"0000\") != end(dead)) return -1; // if start string itself is a deadend\\n\\tif(target == \"0000\") return 0; // if start string itself is the target string.\\n\\tqueue<string> q({\"0000\"});\\n\\tint n, minTurns = 0;\\n\\twhile(!q.empty()) {            \\n\\t\\tn = size(q), minTurns++;\\n\\t\\tfor(int i = 0; i < n; i++) { // traversing all nodes on the current level of BFS traversal\\n\\t\\t\\tauto cur_str = q.front(); q.pop();       \\n\\t\\t\\t// Trying forward and backward turn for each digit of current string\\n\\t\\t\\tfor(int j = 0; j < 4; j++) \\n\\t\\t\\t\\tfor(auto adj_str : turn(cur_str, j)) \\n\\t\\t\\t\\t\\tif(seen.find(adj_str) == end(seen) && dead.find(adj_str) == end(dead)) // adjacent (turned) string is not visited earlier, nor a dead end\\n\\t\\t\\t\\t\\t\\tif(adj_str == target) return minTurns;\\n\\t\\t\\t\\t\\t\\telse q.push(adj_str), seen.insert(adj_str);\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n// turns the ith digit of s in forward and backward direction and returns the turned string as vector\\nvector<string> turn(string s, int i) {\\n\\tvector<string> res(2, s);\\n\\tres[0][i] = \\'0\\' + (res[0][i] - \\'0\\' + 1) % 10;        // forward turn\\n\\tres[1][i] = \\'0\\' + (res[1][i] - \\'0\\' - 1 + 10) % 10;   // backward turn\\n\\treturn res;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the number of strings in deadends and `O(N)` is required to insert all the strings into the hashset. The BFS traversal requires `O(1)`. It may be strange but that\\'s how you calculate big O complexity. The time required by our BFS traversal doesn\\'t depend on the input and in the worst case, we end up making 10000 iterations at max. Please let me know if there\\'s any mistake in this analysis\\n\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint openLock(vector<string>& deadends, string target) {\\n\\tunordered_set<string> dead(begin(deadends), end(deadends)), seen({\"0000\"});\\n\\tif(dead.find(\"0000\") != end(dead)) return -1; // if start string itself is a deadend\\n\\tif(target == \"0000\") return 0; // if start string itself is the target string.\\n\\tqueue<string> q({\"0000\"});\\n\\tint n, minTurns = 0;\\n\\twhile(!q.empty()) {            \\n\\t\\tn = size(q), minTurns++;\\n\\t\\tfor(int i = 0; i < n; i++) { // traversing all nodes on the current level of BFS traversal\\n\\t\\t\\tauto cur_str = q.front(); q.pop();       \\n\\t\\t\\t// Trying forward and backward turn for each digit of current string\\n\\t\\t\\tfor(int j = 0; j < 4; j++) \\n\\t\\t\\t\\tfor(auto adj_str : turn(cur_str, j)) \\n\\t\\t\\t\\t\\tif(seen.find(adj_str) == end(seen) && dead.find(adj_str) == end(dead)) // adjacent (turned) string is not visited earlier, nor a dead end\\n\\t\\t\\t\\t\\t\\tif(adj_str == target) return minTurns;\\n\\t\\t\\t\\t\\t\\telse q.push(adj_str), seen.insert(adj_str);\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n// turns the ith digit of s in forward and backward direction and returns the turned string as vector\\nvector<string> turn(string s, int i) {\\n\\tvector<string> res(2, s);\\n\\tres[0][i] = \\'0\\' + (res[0][i] - \\'0\\' + 1) % 10;        // forward turn\\n\\tres[1][i] = \\'0\\' + (res[1][i] - \\'0\\' - 1 + 10) % 10;   // backward turn\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 368316,
                "title": "simple-java-bfs-solution-for-slow-learners-like-myself",
                "content": "```\\nclass Solution {\\n    \\n    private static final String START = \"0000\";\\n    \\n    public int openLock(String[] deadends, String target) {\\n        if (target == null || target.length() == 0) return -1;\\n        Set<String> visited = new HashSet<>(Arrays.asList(deadends));\\n        Queue<String> queue = new LinkedList<>();\\n        int level = 0;\\n        queue.offer(START);\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                String currentLock = queue.poll();\\n                if (!visited.add(currentLock)) continue;\\n                if (currentLock.equals(target)) return level;\\n                \\n                for (String nextLock : getNextStates(currentLock)) {\\n                    if (!visited.contains(nextLock)) queue.offer(nextLock);\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private List<String> getNextStates(String lock) {\\n        List<String> locks = new LinkedList<>();\\n        char[] arr = lock.toCharArray();\\n        for (int i = 0; i < arr.length; i++) {\\n            char c = arr[i];\\n            arr[i] = c == \\'9\\' ? \\'0\\' : (char) (c + ((char) 1));\\n            locks.add(String.valueOf(arr));\\n            arr[i] = c == \\'0\\' ? \\'9\\' : (char) (c - ((char) 1));\\n            locks.add(String.valueOf(arr));\\n            arr[i] = c;\\n        }\\n        return locks;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private static final String START = \"0000\";\\n    \\n    public int openLock(String[] deadends, String target) {\\n        if (target == null || target.length() == 0) return -1;\\n        Set<String> visited = new HashSet<>(Arrays.asList(deadends));\\n        Queue<String> queue = new LinkedList<>();\\n        int level = 0;\\n        queue.offer(START);\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                String currentLock = queue.poll();\\n                if (!visited.add(currentLock)) continue;\\n                if (currentLock.equals(target)) return level;\\n                \\n                for (String nextLock : getNextStates(currentLock)) {\\n                    if (!visited.contains(nextLock)) queue.offer(nextLock);\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private List<String> getNextStates(String lock) {\\n        List<String> locks = new LinkedList<>();\\n        char[] arr = lock.toCharArray();\\n        for (int i = 0; i < arr.length; i++) {\\n            char c = arr[i];\\n            arr[i] = c == \\'9\\' ? \\'0\\' : (char) (c + ((char) 1));\\n            locks.add(String.valueOf(arr));\\n            arr[i] = c == \\'0\\' ? \\'9\\' : (char) (c - ((char) 1));\\n            locks.add(String.valueOf(arr));\\n            arr[i] = c;\\n        }\\n        return locks;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888436,
                "title": "c-explained-with-pictures-for-the-ones-who-comes-up-from-behind",
                "content": "**BFS Solution**\\n\\nSince there is no brute force solution, my initial solution is basically trying each lock state one by one by using the BFS algorithm and then checking if we are able to reach the target state. There is also one case that we should take care of: if the newly explored state is in the deadends states, then we can\\u2019t go over that state. You can also think of these states as a graph node, this problem is very similar to shortest path problem, finding a target node in a graph where the graph has some dead-end nodes basically if we can reach out to the target node by counting the steps we can find the answer. We can find each state by adding and subtracting \\u201C1\\u201D to each digit of the current state from left to right (It does not matter where we start from). Please see the following image to understand how we explore new states;\\n\\n![image](https://assets.leetcode.com/users/images/34621845-1d47-4ad5-a2d3-87f25500b5e7_1602354020.2690804.png)\\n\\nWe can even shrink the space of the problem to a lock in front of you with 1 circular wheel, just to understand the process easily. Let\\'s assume that we have the lock that has only one digit just for now;\\n\\n![image](https://assets.leetcode.com/users/images/7103423f-648c-4ce0-bb17-cd3d71606620_1602354910.327869.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string> &deadends, string target) {\\n        unordered_set<string> deadendsSet(deadends.begin(), deadends.end());\\n        unordered_set<string> visited;\\n        int result = 0;\\n        if (deadendsSet.find(\"0000\") != deadendsSet.end()) {\\n            return -1;\\n        }\\n        queue<string> wheelQueue;\\n        wheelQueue.push(\"0000\");\\n        visited.insert(\"0000\");\\n        while (!wheelQueue.empty()) {\\n            int levelSize = wheelQueue.size();\\n            while (levelSize--) {\\n                string up, down, currentWheel = wheelQueue.front();\\n                wheelQueue.pop();\\n                if (currentWheel == target) {\\n                    return result;\\n                }\\n                for (int i = 0; i < 4; i++) {\\n                    down = up = currentWheel;\\n                    char upCh = up[i], downCh = down[i];\\n                    up[i] = (upCh == \\'9\\' ? \\'0\\' : upCh + 1);\\n                    down[i] = (downCh == \\'0\\' ? \\'9\\' : downCh - 1);\\n                    if (visited.find(up) == visited.end() && deadendsSet.find(up) == deadendsSet.end()) {\\n                        wheelQueue.push(up);\\n                        visited.insert(up);\\n                    }\\n                    if (visited.find(down) == visited.end() && deadendsSet.find(down) == deadendsSet.end()) {\\n                        wheelQueue.push(down);\\n                        visited.insert(down);\\n                    }\\n                }\\n            }\\n            result++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string> &deadends, string target) {\\n        unordered_set<string> deadendsSet(deadends.begin(), deadends.end());\\n        unordered_set<string> visited;\\n        int result = 0;\\n        if (deadendsSet.find(\"0000\") != deadendsSet.end()) {\\n            return -1;\\n        }\\n        queue<string> wheelQueue;\\n        wheelQueue.push(\"0000\");\\n        visited.insert(\"0000\");\\n        while (!wheelQueue.empty()) {\\n            int levelSize = wheelQueue.size();\\n            while (levelSize--) {\\n                string up, down, currentWheel = wheelQueue.front();\\n                wheelQueue.pop();\\n                if (currentWheel == target) {\\n                    return result;\\n                }\\n                for (int i = 0; i < 4; i++) {\\n                    down = up = currentWheel;\\n                    char upCh = up[i], downCh = down[i];\\n                    up[i] = (upCh == \\'9\\' ? \\'0\\' : upCh + 1);\\n                    down[i] = (downCh == \\'0\\' ? \\'9\\' : downCh - 1);\\n                    if (visited.find(up) == visited.end() && deadendsSet.find(up) == deadendsSet.end()) {\\n                        wheelQueue.push(up);\\n                        visited.insert(up);\\n                    }\\n                    if (visited.find(down) == visited.end() && deadendsSet.find(down) == deadendsSet.end()) {\\n                        wheelQueue.push(down);\\n                        visited.insert(down);\\n                    }\\n                }\\n            }\\n            result++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201608,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def openLock(self, deadends, target):\\n        \"\"\"\\n        :type deadends: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n        dead_set = set(deadends)\\n        queue = collections.deque([(\\'0000\\', 0)])\\n        visited = set(\\'0000\\')\\n\\n        while queue:\\n            (string, steps) = queue.popleft()\\n            if string == target:\\n                return steps\\n            elif string in dead_set:\\n                continue\\n            for i in range(4):\\n                digit = int(string[i])\\n                for move in [-1, 1]:\\n                    new_digit = (digit + move) % 10\\n                    new_string = string[:i]+str(new_digit)+string[i+1:]\\n                    if new_string not in visited:\\n                        visited.add(new_string)\\n                        queue.append((new_string, steps+1))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def openLock(self, deadends, target):\\n        \"\"\"\\n        :type deadends: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n        dead_set = set(deadends)\\n        queue = collections.deque([(\\'0000\\', 0)])\\n        visited = set(\\'0000\\')\\n\\n        while queue:\\n            (string, steps) = queue.popleft()\\n            if string == target:\\n                return steps\\n            elif string in dead_set:\\n                continue\\n            for i in range(4):\\n                digit = int(string[i])\\n                for move in [-1, 1]:\\n                    new_digit = (digit + move) % 10\\n                    new_string = string[:i]+str(new_digit)+string[i+1:]\\n                    if new_string not in visited:\\n                        visited.add(new_string)\\n                        queue.append((new_string, steps+1))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250683,
                "title": "open-the-lock-js-python-java-c-easy-shortest-path-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThere are **10^4** combinations for the lock, and we can think of each one as a node on a graph. We then have to find the shortest path from **\"0000\"** to the **target** combination without going through one of the **deadends**.\\n\\nIn a normal problem dealing with a shortest path on a graph, we keep track of previously visited nodes in a boolean array of combinations (**seen**), so we can just go ahead and add all of the **deadends** into **seen** by converting the strings to numbers.\\n\\nThen, we can solve the shortest path problem with a standard **queue**. We\\'ll have an outer loop to keep track of the number of **turns** we\\'ve taken, while the inner loop will run the length of the current turn (**qlen**).\\n\\nOn each turn, we\\'ll take the current **queue** entry (**curr**), then we\\'ll iterate through the four digits and create both a **mask** for that digit as well as a **masked** version of **curr**. (For example, if **curr = 4213** and we\\'re on the **2nd** digit, **mask** would be **1** and **masked** would be **4203**.) This way we can change the **mask** and add it back to **masked** to form the **next** combination. For each digit, we\\'ll also have to attempt both the forward and backward move, so we can add **1** and then **9** to the **mask**, before applying **modulo 10**, to get the new values.\\n\\nFor each **next** combination, if it\\'s our **target** we should **return turns**, and if it\\'s been **seen**, we should **continue** to the next iteration. Otherwise, we should consider it **seen** and add it to the **queue**. If we ever completely empty the **queue**, then there are no more possible moves, so we should **return -1**.\\n\\nWe also need to remember to account for edge cases where **\"0000\"** is either a **deadend** or the **target**.\\n\\n - _**Time Complexity: O(1e4) or O(1)** because there are always a maximum of **1e4** possible combinations_\\n - _**Space Complexity: O(2e4) or O(1)** for **seen** and the maximum length of the **queue**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **96ms / 41.7MB** (beats 100% / 100%).\\n```javascript\\nvar openLock = function(deadends, target) {\\n    if (target === \"0000\") return 0\\n    let queue = [0], seen = new Uint8Array(10000)\\n    for (let d of deadends)\\n        seen[~~d] = 1\\n    target = ~~target\\n    if (seen[0]) return -1\\n    for (let turns = 1; queue.length; turns++) {\\n        let qlen = queue.length\\n        for (let i = 0; i < qlen; i++) {\\n            let curr = queue.shift()\\n            for (let j = 1; j < 10000; j *= 10) {\\n                let mask = ~~(curr % (j * 10) / j),\\n                    masked = curr - (mask * j)\\n                for (let k = 1; k < 10; k += 8) {\\n                    let next = masked + (mask + k) % 10 * j\\n                    if (seen[next]) continue\\n                    if (next === target) return turns\\n                    seen[next] = 1\\n                    queue.push(next)\\n                }\\n            }\\n        }\\n    }\\n    return -1\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **284ms / 14.3MB** (beats 96% / 100%).\\n```python\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        if target == \"0000\": return 0\\n        queue, target = deque([0]), int(target)\\n        seen, turns = [0] * 10000, 1\\n        for d in deadends: seen[int(d)] = 1\\n        if seen[0]: return -1\\n        while len(queue):\\n            qlen = len(queue)\\n            for i in range(qlen):\\n                curr, j = queue.popleft(), 1\\n                while j < 10000:\\n                    mask = curr % (j * 10) // j\\n                    masked = curr - (mask * j)\\n                    for k in range(1,10,8):\\n                        nxt = masked + (mask + k) % 10 * j\\n                        if seen[nxt]: continue\\n                        if nxt == target: return turns\\n                        seen[nxt] = 1\\n                        queue.append(nxt)\\n                    j *= 10\\n            turns += 1\\n        return -1\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **12ms / 39.1MB** (beats 99% / 99%).\\n```java\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        if (target.equals(\"0000\")) return 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        boolean[] seen = new boolean[10000];\\n        for (String el : deadends)\\n            seen[Integer.parseInt(el)] = true;\\n        int targ = Integer.parseInt(target);\\n        if (seen[0]) return -1;\\n        for (int turns = 1; !queue.isEmpty(); turns++) {\\n            int qlen = queue.size();\\n            for (int i = 0; i < qlen; i++) {\\n                int curr = queue.poll();\\n                for (int j = 1; j < 10000; j *= 10) {\\n                    int mask = curr % (j * 10) / j,\\n                        masked = curr - (mask * j);\\n                    for (int k = 1; k < 10; k += 8) {\\n                        int next = masked + (mask + k) % 10 * j;\\n                        if (seen[next]) continue;\\n                        if (next == targ) return turns;\\n                        seen[next] = true;\\n                        queue.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **12ms / 9.8MB** (beats 100% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        if (target == \"0000\") return 0;\\n        queue<int> queue;\\n        queue.push(0);\\n        bool seen[10000]{false};\\n        for (auto& d : deadends)\\n            seen[stoi(d)] = true;\\n        int targ = stoi(target);\\n        if (seen[0]) return -1;\\n        for (int turns = 1; queue.size(); turns++) {\\n            int qlen = queue.size();\\n            for (int i = 0; i < qlen; i++) {\\n                int curr = queue.front();\\n                queue.pop();\\n                for (int j = 1; j < 10000; j *= 10) {\\n                    int mask = curr % (j * 10) / j,\\n                        masked = curr - (mask * j);\\n                    for (int k = 1; k < 10; k += 8) {\\n                        int next = masked + (mask + k) % 10 * j;\\n                        if (seen[next]) continue;\\n                        if (next == targ) return turns;\\n                        seen[next] = true;\\n                        queue.push(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar openLock = function(deadends, target) {\\n    if (target === \"0000\") return 0\\n    let queue = [0], seen = new Uint8Array(10000)\\n    for (let d of deadends)\\n        seen[~~d] = 1\\n    target = ~~target\\n    if (seen[0]) return -1\\n    for (let turns = 1; queue.length; turns++) {\\n        let qlen = queue.length\\n        for (let i = 0; i < qlen; i++) {\\n            let curr = queue.shift()\\n            for (let j = 1; j < 10000; j *= 10) {\\n                let mask = ~~(curr % (j * 10) / j),\\n                    masked = curr - (mask * j)\\n                for (let k = 1; k < 10; k += 8) {\\n                    let next = masked + (mask + k) % 10 * j\\n                    if (seen[next]) continue\\n                    if (next === target) return turns\\n                    seen[next] = 1\\n                    queue.push(next)\\n                }\\n            }\\n        }\\n    }\\n    return -1\\n};\\n```\n```python\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        if target == \"0000\": return 0\\n        queue, target = deque([0]), int(target)\\n        seen, turns = [0] * 10000, 1\\n        for d in deadends: seen[int(d)] = 1\\n        if seen[0]: return -1\\n        while len(queue):\\n            qlen = len(queue)\\n            for i in range(qlen):\\n                curr, j = queue.popleft(), 1\\n                while j < 10000:\\n                    mask = curr % (j * 10) // j\\n                    masked = curr - (mask * j)\\n                    for k in range(1,10,8):\\n                        nxt = masked + (mask + k) % 10 * j\\n                        if seen[nxt]: continue\\n                        if nxt == target: return turns\\n                        seen[nxt] = 1\\n                        queue.append(nxt)\\n                    j *= 10\\n            turns += 1\\n        return -1\\n```\n```java\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        if (target.equals(\"0000\")) return 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        boolean[] seen = new boolean[10000];\\n        for (String el : deadends)\\n            seen[Integer.parseInt(el)] = true;\\n        int targ = Integer.parseInt(target);\\n        if (seen[0]) return -1;\\n        for (int turns = 1; !queue.isEmpty(); turns++) {\\n            int qlen = queue.size();\\n            for (int i = 0; i < qlen; i++) {\\n                int curr = queue.poll();\\n                for (int j = 1; j < 10000; j *= 10) {\\n                    int mask = curr % (j * 10) / j,\\n                        masked = curr - (mask * j);\\n                    for (int k = 1; k < 10; k += 8) {\\n                        int next = masked + (mask + k) % 10 * j;\\n                        if (seen[next]) continue;\\n                        if (next == targ) return turns;\\n                        seen[next] = true;\\n                        queue.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        if (target == \"0000\") return 0;\\n        queue<int> queue;\\n        queue.push(0);\\n        bool seen[10000]{false};\\n        for (auto& d : deadends)\\n            seen[stoi(d)] = true;\\n        int targ = stoi(target);\\n        if (seen[0]) return -1;\\n        for (int turns = 1; queue.size(); turns++) {\\n            int qlen = queue.size();\\n            for (int i = 0; i < qlen; i++) {\\n                int curr = queue.front();\\n                queue.pop();\\n                for (int j = 1; j < 10000; j *= 10) {\\n                    int mask = curr % (j * 10) / j,\\n                        masked = curr - (mask * j);\\n                    for (int k = 1; k < 10; k += 8) {\\n                        int next = masked + (mask + k) % 10 * j;\\n                        if (seen[next]) continue;\\n                        if (next == targ) return turns;\\n                        seen[next] = true;\\n                        queue.push(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730358,
                "title": "simple-and-readable-bfs-solution-in-javascript-explanation",
                "content": "We start from the \"0000\" combination and then moves to the adjacent combinations. Basically turn up and down each of the wheels to generate \"1000\", \"9000\", \"0100\", \"0900\", \"0010\", \"0090\", \"0001\", \"0009\".\\n\\nYou can think of this problem as graph, where the node \"0000\" will have 8 edges. Each one of the new combinations will have 8 more adjacent nodes. However, we will start to have duplicates. For instance:\\n\\n- \"**0000**\" -> [\"1000\", \"9000\", \"0100\", \"0900\", \"0010\", \"0090\", \"**0001**\", \"0009\"]\\n- \"**0001**\" -> [\"1001\", \"9001\", \"0101\", \"0901\", \"0011\", \"0091\", \"0002\", \"**0000**\"]\\n\\nAs you can see \"0001\" will lead to \"0000\", again! So we have to keep track of seen combinations.\\n\\nSince, it\\'s a graph problem we can use BFS to fine the combination.\\n\\nHere\\'s the implementation in JavaScript/Typescript\\n```typescript\\nfunction openLock(deadends: string[], target: string): number {\\n  const dead = new Set(deadends);\\n  const queue: [string, number][] = [[\\'0000\\', 0]];\\n  const seen = new Set([\\'0000\\']);\\n  \\n  for (let [curr, turns] of queue) {\\n    if (curr === target) return turns;\\n    if (dead.has(curr)) continue;    \\n    for (let next of getNextStates(curr)) {\\n      if (seen.has(next)) continue;\\n      seen.add(next);\\n      queue.push([next, turns + 1]);\\n    }\\n  }\\n  \\n  return -1;\\n};\\n  \\nfunction getNextStates(s = \\'0000\\'): string[] {\\n  const ans: string[] = [];\\n  \\n  for (let i = 0; i < s.length; i++) {\\n    ans.push(s.slice(0, i) + ((+s[i] + 1) % 10).toString() + s.slice(i + 1));\\n    ans.push(s.slice(0, i) + ((+s[i] + 9) % 10).toString() + s.slice(i + 1));\\n  }\\n  \\n  return ans;\\n}\\n```\\n\\nThere are two tricky parts:\\n- Circular module for negative numbers. At first I was doing ` ((+s[i] - 1) % 10)`. That didn\\'t work `-1 % 10 === -1`. So, I changed to `((+s[i] + 9) % 10)`.\\n- Where you mark your nodes as visited matters. I got time out errors, when I was marking it as visited, AFTER they were dequeue. I solved the issue by marking the nodes as visited right before they are enqueue. That way we don\\'t fill the queue with unecessary values.\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Breadth-First Search"
                ],
                "code": "```typescript\\nfunction openLock(deadends: string[], target: string): number {\\n  const dead = new Set(deadends);\\n  const queue: [string, number][] = [[\\'0000\\', 0]];\\n  const seen = new Set([\\'0000\\']);\\n  \\n  for (let [curr, turns] of queue) {\\n    if (curr === target) return turns;\\n    if (dead.has(curr)) continue;    \\n    for (let next of getNextStates(curr)) {\\n      if (seen.has(next)) continue;\\n      seen.add(next);\\n      queue.push([next, turns + 1]);\\n    }\\n  }\\n  \\n  return -1;\\n};\\n  \\nfunction getNextStates(s = \\'0000\\'): string[] {\\n  const ans: string[] = [];\\n  \\n  for (let i = 0; i < s.length; i++) {\\n    ans.push(s.slice(0, i) + ((+s[i] + 1) % 10).toString() + s.slice(i + 1));\\n    ans.push(s.slice(0, i) + ((+s[i] + 9) % 10).toString() + s.slice(i + 1));\\n  }\\n  \\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1253043,
                "title": "open-the-lock-why-dfs-or-recursion-traversal-will-not-work-explainition",
                "content": "Taking the help of Hint provided, we can think to generate all possible paths to reach target (one digit changes by +1 pr -1 , as we can go clockwise or anti-clockwise , at each step) and return the shortest path.\\n\\n**Algorithm may follow as below :**\\nMove forward if possible and increment the size of path by 1.\\nElse return\\nif we reached target value, return\\nGet the min of paths uptil now. and return this min value\\n\\n**Code can be as follow:**  *(read comments to understand code)*\\n\\n```\\nclass Solution {\\npublic:\\n    set<string> dead;\\n    int dfs(string start, string target, set<string>& visit){  //dfs function\\n        visit.insert(start); //marking it as visited\\n        if(dead.find(start) != dead.end())  // dead end is reach, so return infinite value\\n\\t\\t\\treturn INT_MAX;\\n        if(start==target) { //target reached, return 0\\n            // cout<<\"start=\"<<start<<\",\"<<\"path=\"<<0<<\"\\\\n\";\\n            return 0;   \\n        }\\n        \\n        int path = INT_MAX; //infinite default value, as we need to use min function\\n        string temp = start; //copy of string created\\n        for(int i =0; i<start.length(); i++)\\n\\t\\t{\\n             int k = temp[i]-\\'0\\'; \\n             temp[i] = ((k+1)%10)+\\'0\\';      // +1 : clockwise movement\\n             if(visit.find(temp)==visit.end() && visit.find(target)==visit.end())\\n                 path = min (path, dfs(temp, target, visit));\\n\\n             temp[i] = ((k-1+10)%10)+\\'0\\';    // -1 : anti-clockwise movement\\n             if(visit.find(temp)==visit.end() && visit.find(target)==visit.end())\\n\\t\\t\\t\\t path = min (path , dfs(temp, target, visit)); \\n        }\\n        // visit.erase(visit.find(start)); // use it for backtracking solution\\n        if(path ==INT_MAX) return INT_MAX;\\n        // cout<<\"start=\"<<start<<\",\"<<\"path=\"<<path<<\"\\\\n\";\\n        return path+1;   \\n    }\\n   \\n    int openLock(vector<string>& deadends, string target) {\\n        for(string d : deadends)\\n            dead.insert(d);\\n\\t\\t\\t\\n        string start=\"0000\"; //starting value\\n        set<string> visit;\\n        int ans = dfs(start, target, visit); // start dfs\\n        if(ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```\\n\\nAll looks good and should work. Right?\\nNo\\nWhy?\\nCause we are using a visited set/array and doing dfs. This will create a grave problem by marking those nodes as visited which are common in both shortest path and non-shortest path. If we happen to traverse a non-shortest path before, its nodes will be marked visited and we get some path length , say **P\\'** . Now when we need to traverse a differnet path (may be the shortest path this time), it will not traverse those nodes , which are already traversed (marked visited). Hence we will never be able to know the value of shortest path length, say **P** . **(P  < P\\')**\\n\\nTherefore DFS will not work.\\n![image](https://assets.leetcode.com/users/images/2950c164-e79b-4b35-a3fa-7d3474acab76_1622908859.296736.png)\\n\\n\\n\\n\\nYou must be thinking , ok, can we mark those node as un-visited after we have traversed a path. \\nSure, **this method is called BACKTRACKING**; where we reverse what was done.\\nBacktracking could solve the problem, but remember, this is not a tree, so you might end up re-traverseing the common node; For Example: in above figure, path after node **M** will we re-traversed in purple path although we have traversed it in path black, and can cause TLE\\n\\nSo the best method, to solve it is using BFS. As it will not mark any node visited before the shortest path reached its destination.\\n\\nHappy coding! \\n:)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<string> dead;\\n    int dfs(string start, string target, set<string>& visit){  //dfs function\\n        visit.insert(start); //marking it as visited\\n        if(dead.find(start) != dead.end())  // dead end is reach, so return infinite value\\n\\t\\t\\treturn INT_MAX;\\n        if(start==target) { //target reached, return 0\\n            // cout<<\"start=\"<<start<<\",\"<<\"path=\"<<0<<\"\\\\n\";\\n            return 0;   \\n        }\\n        \\n        int path = INT_MAX; //infinite default value, as we need to use min function\\n        string temp = start; //copy of string created\\n        for(int i =0; i<start.length(); i++)\\n\\t\\t{\\n             int k = temp[i]-\\'0\\'; \\n             temp[i] = ((k+1)%10)+\\'0\\';      // +1 : clockwise movement\\n             if(visit.find(temp)==visit.end() && visit.find(target)==visit.end())\\n                 path = min (path, dfs(temp, target, visit));\\n\\n             temp[i] = ((k-1+10)%10)+\\'0\\';    // -1 : anti-clockwise movement\\n             if(visit.find(temp)==visit.end() && visit.find(target)==visit.end())\\n\\t\\t\\t\\t path = min (path , dfs(temp, target, visit)); \\n        }\\n        // visit.erase(visit.find(start)); // use it for backtracking solution\\n        if(path ==INT_MAX) return INT_MAX;\\n        // cout<<\"start=\"<<start<<\",\"<<\"path=\"<<path<<\"\\\\n\";\\n        return path+1;   \\n    }\\n   \\n    int openLock(vector<string>& deadends, string target) {\\n        for(string d : deadends)\\n            dead.insert(d);\\n\\t\\t\\t\\n        string start=\"0000\"; //starting value\\n        set<string> visit;\\n        int ans = dfs(start, target, visit); // start dfs\\n        if(ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1250675,
                "title": "python-2-solutions-bfs-and-bidirectional-bfs-expalined",
                "content": "#### Solution 1: Usual bfs\\n\\nWe can look at this problem as graph problem, where we need to find shortest way between given two nodes. We can do classical bfs to do it.\\n\\n#### Complexity\\nThe worst time complexity is `O(E)`, where `E` is number of edges and it can be `10000 * 8/2`, because we have `10000` nodes and each node is connected with `8` others. Space complexity `O(N)`, where `N` is size of `deadends`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def openLock(self, deadends, target):\\n        \\n        dead = set(deadends)\\n        queue = deque([(0, \"0000\")])\\n        \\n        if \"0000\" in dead: return -1\\n        \\n        while queue:\\n            steps, code = queue.popleft()\\n            if code == target: return steps\\n            \\n            for i in range(4):\\n                d = int(code[i])\\n                for k in (d-1)%10, (d+1)%10:\\n                    cand = code[:i] + str(k) + code[i+1:]\\n                    if cand not in dead: \\n                        dead.add(cand)\\n                        queue.append((steps+1, cand))\\n\\n        return -1\\n```\\n\\n#### Solution 2: Bidirectional bfs\\n\\nThere is also bidirectional bfs, which has the same worst time complexity, but which in average will work several times faster. The idea is to start from both ends and each time choose the end with smaller size of queue. Here we need to be careful: Our invariant, that at each moment of time in our queues we have number of steps (first elements):\\n\\n`[i,i,..., i, i+1, i+1, ..., i+1]` and  `[j,j,..., j, j+1, j+1, ..., j+1]`\\n\\nWe extract left element from first queue and we need to check if it is in second. At this moment we for sure know that distance is not more than `i + j`. However, it can be either `i+j` or `i+j+1`, and we need to check all elements with length `i` to mare sure there is no element from second queue with steps `j`. So, first time we see that sum of first elements from our queue is more than `limit`, it means that we finished to process all candidates, so we can return answer.\\n\\n#### Remark\\nIn this specific problem, because of bipartite structure of our graph, bidirectional bfs can be optimized: for given `i` it can happen than only `j` or `j+1` is in visited set, but not both of them, so 2 lines when we check `limit` can be removed. However in this case alrorithm become less universal, so I prefer it as it is, so you can reuse this pattern in other problems. Actually I already used it in some other problem, but I do not remember what exacty, please let me know if you have any idea.\\n\\n#### Complexity\\nIs the same as previous approach, but in practice it works much faster\\n\\n#### Code\\n```python\\nclass Solution:\\n    def openLock(self, deadends, target):\\n        dead = set(deadends)\\n        if \"0000\" in dead: return -1\\n        \\n        queue1 = deque([(0, \"0000\")])\\n        queue2 = deque([(0, target)])\\n        visited1 = {\"0000\": 0}\\n        visited2 = {target: 0}\\n        \\n        limit, ans = float(\"inf\"), float(\"inf\")\\n\\n        while queue1:\\n            if len(queue1) > len(queue2):\\n                queue1, queue2 = queue2, queue1\\n                visited1, visited2 = visited2, visited1\\n                \\n            steps, code = queue1.popleft()\\n            if steps + queue2[0][0] > limit: return ans\\n            \\n            if code in visited2:\\n                limit = steps + queue2[0][0]\\n                ans = min(visited1[code] + visited2[code], ans)\\n            \\n            for i in range(4):\\n                d = int(code[i])\\n                for k in (d-1)%10, (d+1)%10:\\n                    cand = code[:i] + str(k) + code[i+1:]\\n                    if cand not in visited1 and cand not in dead:\\n                        visited1[cand] = steps + 1\\n                        queue1.append((steps+1, cand))\\n        return -1\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def openLock(self, deadends, target):\\n        \\n        dead = set(deadends)\\n        queue = deque([(0, \"0000\")])\\n        \\n        if \"0000\" in dead: return -1\\n        \\n        while queue:\\n            steps, code = queue.popleft()\\n            if code == target: return steps\\n            \\n            for i in range(4):\\n                d = int(code[i])\\n                for k in (d-1)%10, (d+1)%10:\\n                    cand = code[:i] + str(k) + code[i+1:]\\n                    if cand not in dead: \\n                        dead.add(cand)\\n                        queue.append((steps+1, cand))\\n\\n        return -1\\n```\n```python\\nclass Solution:\\n    def openLock(self, deadends, target):\\n        dead = set(deadends)\\n        if \"0000\" in dead: return -1\\n        \\n        queue1 = deque([(0, \"0000\")])\\n        queue2 = deque([(0, target)])\\n        visited1 = {\"0000\": 0}\\n        visited2 = {target: 0}\\n        \\n        limit, ans = float(\"inf\"), float(\"inf\")\\n\\n        while queue1:\\n            if len(queue1) > len(queue2):\\n                queue1, queue2 = queue2, queue1\\n                visited1, visited2 = visited2, visited1\\n                \\n            steps, code = queue1.popleft()\\n            if steps + queue2[0][0] > limit: return ans\\n            \\n            if code in visited2:\\n                limit = steps + queue2[0][0]\\n                ans = min(visited1[code] + visited2[code], ans)\\n            \\n            for i in range(4):\\n                d = int(code[i])\\n                for k in (d-1)%10, (d+1)%10:\\n                    cand = code[:i] + str(k) + code[i+1:]\\n                    if cand not in visited1 and cand not in dead:\\n                        visited1[cand] = steps + 1\\n                        queue1.append((steps+1, cand))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 634990,
                "title": "bfs-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        queue<string> bfs;\\n        unordered_set<string> hash(deadends.begin(), deadends.end());\\n        unordered_set<string> visited;\\n        \\n        if (hash.find(\"0000\") != hash.end())\\n            return -1;\\n        \\n        int depth = 0;\\n        bfs.push(\"0000\");\\n\\t\\tvisited.insert(\"0000\");\\n        \\n        while(!bfs.empty())\\n        {\\n            int siz=bfs.size();\\n            \\n            for(int k=0;k<siz;k++)\\n            {\\n                string current_stage = bfs.front();\\n                bfs.pop();\\n\\n                if (current_stage == target)\\n                {\\n                    return depth;\\n                }\\n\\n\\n                for (int i = 0; i < 4; i++)\\n                {\\n                    char temp = current_stage[i];\\n                    current_stage[i] = temp == \\'9\\' ? \\'0\\' : temp + 1;\\n                    if (hash.find(current_stage) == hash.end() && visited.find(current_stage)==visited.end())\\n                    {\\n                        bfs.push(current_stage);\\n                        visited.insert(current_stage);\\n                    }\\n\\n\\n                    current_stage[i] = temp == \\'0\\' ? \\'9\\' : temp - 1;\\n                    if (hash.find(current_stage) == hash.end() && visited.find(current_stage)==visited.end())\\n                    {\\n                        bfs.push(current_stage);\\n                        visited.insert(current_stage);\\n                    }\\n                    current_stage[i] = temp;\\n                }\\n            }\\n            \\n           depth++;\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        queue<string> bfs;\\n        unordered_set<string> hash(deadends.begin(), deadends.end());\\n        unordered_set<string> visited;\\n        \\n        if (hash.find(\"0000\") != hash.end())\\n            return -1;\\n        \\n        int depth = 0;\\n        bfs.push(\"0000\");\\n\\t\\tvisited.insert(\"0000\");\\n        \\n        while(!bfs.empty())\\n        {\\n            int siz=bfs.size();\\n            \\n            for(int k=0;k<siz;k++)\\n            {\\n                string current_stage = bfs.front();\\n                bfs.pop();\\n\\n                if (current_stage == target)\\n                {\\n                    return depth;\\n                }\\n\\n\\n                for (int i = 0; i < 4; i++)\\n                {\\n                    char temp = current_stage[i];\\n                    current_stage[i] = temp == \\'9\\' ? \\'0\\' : temp + 1;\\n                    if (hash.find(current_stage) == hash.end() && visited.find(current_stage)==visited.end())\\n                    {\\n                        bfs.push(current_stage);\\n                        visited.insert(current_stage);\\n                    }\\n\\n\\n                    current_stage[i] = temp == \\'0\\' ? \\'9\\' : temp - 1;\\n                    if (hash.find(current_stage) == hash.end() && visited.find(current_stage)==visited.end())\\n                    {\\n                        bfs.push(current_stage);\\n                        visited.insert(current_stage);\\n                    }\\n                    current_stage[i] = temp;\\n                }\\n            }\\n            \\n           depth++;\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142561,
                "title": "python-16-lines-simple-and-readable-bfs-solution-beats-94",
                "content": "```\\nclass Solution:\\n    def openLock(self, deadends, target):\\n        moved, q, cnt, move = set(deadends), [\"0000\"], 0, {str(i): [str((i + 1) % 10), str((i - 1) % 10)] for i in range(10)}\\n        if \"0000\" in moved:\\n            return -1\\n        while q:\\n            new = []\\n            cnt += 1\\n            for s in q:\\n                for i, c in enumerate(s):\\n                    for cur in (s[:i] + move[c][0] + s[i + 1:], s[:i] + move[c][1] + s[i + 1:]):\\n                        if cur not in moved:\\n                            if cur == target:\\n                                return cnt\\n                            new.append(cur)\\n                            moved.add(cur)\\n            q = new\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def openLock(self, deadends, target):\\n        moved, q, cnt, move = set(deadends), [\"0000\"], 0, {str(i): [str((i + 1) % 10), str((i - 1) % 10)] for i in range(10)}\\n        if \"0000\" in moved:\\n            return -1\\n        while q:\\n            new = []\\n            cnt += 1\\n            for s in q:\\n                for i, c in enumerate(s):\\n                    for cur in (s[:i] + move[c][0] + s[i + 1:], s[:i] + move[c][1] + s[i + 1:]):\\n                        if cur not in moved:\\n                            if cur == target:\\n                                return cnt\\n                            new.append(cur)\\n                            moved.add(cur)\\n            q = new\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110247,
                "title": "java-c-clean-code",
                "content": "**java**\\n```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> dead = new HashSet<>();\\n        for (String s : deadends) dead.add(s);\\n        if (dead.contains(\"0000\")) return -1;\\n        if (\"0000\".equals(target)) return 0;\\n        Set<String> v = new HashSet<>();\\n        Queue<String> q = new LinkedList<>();\\n        q.add(\"0000\");\\n        for (int d = 1; !q.isEmpty(); d++) {\\n            for (int n = q.size(); n > 0; n--) {\\n                String cur = q.poll();\\n                for (int i = 0; i < 4; i++) {\\n                    for (int dif = 1; dif <= 9; dif += 8) {\\n                        char[] ca = cur.toCharArray();\\n                        ca[i] = (char)((ca[i] - '0' + dif) % 10 + '0');\\n                        String s = new String(ca);\\n                        if (target.equals(s)) return d;\\n                        if (!dead.contains(s) && !v.contains(s)) q.add(s);\\n                        v.add(s);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;        \\n    }\\n}\\n```\\n**c++**\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        set<string> dead(deadends.begin(), deadends.end());\\n        if (dead.count(\"0000\")) return -1;\\n        if (target == \"0000\") return 0;\\n        set<string> v;\\n        queue<string> q;\\n        q.push(\"0000\");\\n        for (int d = 1; !q.empty(); d++) {\\n            for (int n = q.size(); n > 0; n--) {\\n                string cur = q.front(); q.pop();\\n                for (int i = 0; i < 4; i++) {\\n                    for (int dif = 1; dif <= 9; dif += 8) {\\n                        string s = cur;\\n                        s[i] = (s[i] - '0' + dif) % 10 + '0';\\n                        if (s == target) return d;\\n                        if (!dead.count(s) && !v.count(s)) q.push(s);\\n                        v.insert(s);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> dead = new HashSet<>();\\n        for (String s : deadends) dead.add(s);\\n        if (dead.contains(\"0000\")) return -1;\\n        if (\"0000\".equals(target)) return 0;\\n        Set<String> v = new HashSet<>();\\n        Queue<String> q = new LinkedList<>();\\n        q.add(\"0000\");\\n        for (int d = 1; !q.isEmpty(); d++) {\\n            for (int n = q.size(); n > 0; n--) {\\n                String cur = q.poll();\\n                for (int i = 0; i < 4; i++) {\\n                    for (int dif = 1; dif <= 9; dif += 8) {\\n                        char[] ca = cur.toCharArray();\\n                        ca[i] = (char)((ca[i] - '0' + dif) % 10 + '0');\\n                        String s = new String(ca);\\n                        if (target.equals(s)) return d;\\n                        if (!dead.contains(s) && !v.contains(s)) q.add(s);\\n                        v.add(s);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        set<string> dead(deadends.begin(), deadends.end());\\n        if (dead.count(\"0000\")) return -1;\\n        if (target == \"0000\") return 0;\\n        set<string> v;\\n        queue<string> q;\\n        q.push(\"0000\");\\n        for (int d = 1; !q.empty(); d++) {\\n            for (int n = q.size(); n > 0; n--) {\\n                string cur = q.front(); q.pop();\\n                for (int i = 0; i < 4; i++) {\\n                    for (int dif = 1; dif <= 9; dif += 8) {\\n                        string s = cur;\\n                        s[i] = (s[i] - '0' + dif) % 10 + '0';\\n                        if (s == target) return d;\\n                        if (!dead.count(s) && !v.count(s)) q.push(s);\\n                        v.insert(s);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250681,
                "title": "js-python-java-c-easy-shortest-path-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThere are **10^4** combinations for the lock, and we can think of each one as a node on a graph. We then have to find the shortest path from **\"0000\"** to the **target** combination without going through one of the **deadends**.\\n\\nIn a normal problem dealing with a shortest path on a graph, we keep track of previously visited nodes in a boolean array of combinations (**seen**), so we can just go ahead and add all of the **deadends** into **seen** by converting the strings to numbers.\\n\\nThen, we can solve the shortest path problem with a standard **queue**. We\\'ll have an outer loop to keep track of the number of **turns** we\\'ve taken, while the inner loop will run the length of the current turn (**qlen**).\\n\\nOn each turn, we\\'ll take the current **queue** entry (**curr**), then we\\'ll iterate through the four digits and create both a **mask** for that digit as well as a **masked** version of **curr**. (For example, if **curr = 4213** and we\\'re on the **2nd** digit, **mask** would be **1** and **masked** would be **4203**.) This way we can change the **mask** and add it back to **masked** to form the **next** combination. For each digit, we\\'ll also have to attempt both the forward and backward move, so we can add **1** and then **9** to the **mask**, before applying **modulo 10**, to get the new values.\\n\\nFor each **next** combination, if it\\'s our **target** we should **return turns**, and if it\\'s been **seen**, we should **continue** to the next iteration. Otherwise, we should consider it **seen** and add it to the **queue**. If we ever completely empty the **queue**, then there are no more possible moves, so we should **return -1**.\\n\\nWe also need to remember to account for edge cases where **\"0000\"** is either a **deadend** or the **target**.\\n\\n - _**Time Complexity: O(1e4) or O(1)** because there are always a maximum of **1e4** possible combinations_\\n - _**Space Complexity: O(2e4) or O(1)** for **seen** and the maximum length of the **queue**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **96ms / 41.7MB** (beats 100% / 100%).\\n```javascript\\nvar openLock = function(deadends, target) {\\n    if (target === \"0000\") return 0\\n    let queue = [0], seen = new Uint8Array(10000)\\n    for (let d of deadends)\\n        seen[~~d] = 1\\n    target = ~~target\\n    if (seen[0]) return -1\\n    for (let turns = 1; queue.length; turns++) {\\n        let qlen = queue.length\\n        for (let i = 0; i < qlen; i++) {\\n            let curr = queue.shift()\\n            for (let j = 1; j < 10000; j *= 10) {\\n                let mask = ~~(curr % (j * 10) / j),\\n                    masked = curr - (mask * j)\\n                for (let k = 1; k < 10; k += 8) {\\n                    let next = masked + (mask + k) % 10 * j\\n                    if (seen[next]) continue\\n                    if (next === target) return turns\\n                    seen[next] = 1\\n                    queue.push(next)\\n                }\\n            }\\n        }\\n    }\\n    return -1\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **284ms / 14.3MB** (beats 96% / 100%).\\n```python\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        if target == \"0000\": return 0\\n        queue, target = deque([0]), int(target)\\n        seen, turns = [0] * 10000, 1\\n        for d in deadends: seen[int(d)] = 1\\n        if seen[0]: return -1\\n        while len(queue):\\n            qlen = len(queue)\\n            for i in range(qlen):\\n                curr, j = queue.popleft(), 1\\n                while j < 10000:\\n                    mask = curr % (j * 10) // j\\n                    masked = curr - (mask * j)\\n                    for k in range(1,10,8):\\n                        nxt = masked + (mask + k) % 10 * j\\n                        if seen[nxt]: continue\\n                        if nxt == target: return turns\\n                        seen[nxt] = 1\\n                        queue.append(nxt)\\n                    j *= 10\\n            turns += 1\\n        return -1\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **12ms / 39.1MB** (beats 99% / 99%).\\n```java\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        if (target.equals(\"0000\")) return 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        boolean[] seen = new boolean[10000];\\n        for (String el : deadends)\\n            seen[Integer.parseInt(el)] = true;\\n        int targ = Integer.parseInt(target);\\n        if (seen[0]) return -1;\\n        for (int turns = 1; !queue.isEmpty(); turns++) {\\n            int qlen = queue.size();\\n            for (int i = 0; i < qlen; i++) {\\n                int curr = queue.poll();\\n                for (int j = 1; j < 10000; j *= 10) {\\n                    int mask = curr % (j * 10) / j,\\n                        masked = curr - (mask * j);\\n                    for (int k = 1; k < 10; k += 8) {\\n                        int next = masked + (mask + k) % 10 * j;\\n                        if (seen[next]) continue;\\n                        if (next == targ) return turns;\\n                        seen[next] = true;\\n                        queue.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **12ms / 9.8MB** (beats 100% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        if (target == \"0000\") return 0;\\n        queue<int> queue;\\n        queue.push(0);\\n        bool seen[10000]{false};\\n        for (auto& d : deadends)\\n            seen[stoi(d)] = true;\\n        int targ = stoi(target);\\n        if (seen[0]) return -1;\\n        for (int turns = 1; queue.size(); turns++) {\\n            int qlen = queue.size();\\n            for (int i = 0; i < qlen; i++) {\\n                int curr = queue.front();\\n                queue.pop();\\n                for (int j = 1; j < 10000; j *= 10) {\\n                    int mask = curr % (j * 10) / j,\\n                        masked = curr - (mask * j);\\n                    for (int k = 1; k < 10; k += 8) {\\n                        int next = masked + (mask + k) % 10 * j;\\n                        if (seen[next]) continue;\\n                        if (next == targ) return turns;\\n                        seen[next] = true;\\n                        queue.push(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar openLock = function(deadends, target) {\\n    if (target === \"0000\") return 0\\n    let queue = [0], seen = new Uint8Array(10000)\\n    for (let d of deadends)\\n        seen[~~d] = 1\\n    target = ~~target\\n    if (seen[0]) return -1\\n    for (let turns = 1; queue.length; turns++) {\\n        let qlen = queue.length\\n        for (let i = 0; i < qlen; i++) {\\n            let curr = queue.shift()\\n            for (let j = 1; j < 10000; j *= 10) {\\n                let mask = ~~(curr % (j * 10) / j),\\n                    masked = curr - (mask * j)\\n                for (let k = 1; k < 10; k += 8) {\\n                    let next = masked + (mask + k) % 10 * j\\n                    if (seen[next]) continue\\n                    if (next === target) return turns\\n                    seen[next] = 1\\n                    queue.push(next)\\n                }\\n            }\\n        }\\n    }\\n    return -1\\n};\\n```\n```python\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        if target == \"0000\": return 0\\n        queue, target = deque([0]), int(target)\\n        seen, turns = [0] * 10000, 1\\n        for d in deadends: seen[int(d)] = 1\\n        if seen[0]: return -1\\n        while len(queue):\\n            qlen = len(queue)\\n            for i in range(qlen):\\n                curr, j = queue.popleft(), 1\\n                while j < 10000:\\n                    mask = curr % (j * 10) // j\\n                    masked = curr - (mask * j)\\n                    for k in range(1,10,8):\\n                        nxt = masked + (mask + k) % 10 * j\\n                        if seen[nxt]: continue\\n                        if nxt == target: return turns\\n                        seen[nxt] = 1\\n                        queue.append(nxt)\\n                    j *= 10\\n            turns += 1\\n        return -1\\n```\n```java\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        if (target.equals(\"0000\")) return 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        boolean[] seen = new boolean[10000];\\n        for (String el : deadends)\\n            seen[Integer.parseInt(el)] = true;\\n        int targ = Integer.parseInt(target);\\n        if (seen[0]) return -1;\\n        for (int turns = 1; !queue.isEmpty(); turns++) {\\n            int qlen = queue.size();\\n            for (int i = 0; i < qlen; i++) {\\n                int curr = queue.poll();\\n                for (int j = 1; j < 10000; j *= 10) {\\n                    int mask = curr % (j * 10) / j,\\n                        masked = curr - (mask * j);\\n                    for (int k = 1; k < 10; k += 8) {\\n                        int next = masked + (mask + k) % 10 * j;\\n                        if (seen[next]) continue;\\n                        if (next == targ) return turns;\\n                        seen[next] = true;\\n                        queue.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        if (target == \"0000\") return 0;\\n        queue<int> queue;\\n        queue.push(0);\\n        bool seen[10000]{false};\\n        for (auto& d : deadends)\\n            seen[stoi(d)] = true;\\n        int targ = stoi(target);\\n        if (seen[0]) return -1;\\n        for (int turns = 1; queue.size(); turns++) {\\n            int qlen = queue.size();\\n            for (int i = 0; i < qlen; i++) {\\n                int curr = queue.front();\\n                queue.pop();\\n                for (int j = 1; j < 10000; j *= 10) {\\n                    int mask = curr % (j * 10) / j,\\n                        masked = curr - (mask * j);\\n                    for (int k = 1; k < 10; k += 8) {\\n                        int next = masked + (mask + k) % 10 * j;\\n                        if (seen[next]) continue;\\n                        if (next == targ) return turns;\\n                        seen[next] = true;\\n                        queue.push(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250660,
                "title": "open-the-lock-short-easy-solution-w-explanation-comments-bfs-traversal",
                "content": "\\u2714\\uFE0F ***Solution - I (BFS)***\\n\\nFirst, let\\'s simplify the problem statement. We are given a string *`start = \"0000\"`* and asked to reach *`target`* by turning (minimum times) a digit forward or backward one at a time without reaching any of the strings in *`deadends`*.\\n\\nWe can\\'t just turn a digit forward or backward just based on which turn gets us quicker to the corresponding digit of target faster because this approach may lead us towards a **deadend**. So, it makes sense to try and turn a digit in both the direction and return the one that leads to *`target`* in minimum moves.\\n\\nThe solution can be modelled as a **BFS traversal**, wherein we try to shift each digit of current string *`curstr`* in both the possible direction. We **increment *`turns`* at each level of BFS and return when *`target`*** is reached during the traversal.\\n\\nWe use a hashset to insert all the *`deadends`* string for efficient check on whether we reach a deadend at anytime. Similarly, we store all the visited string in *`visited`* to ensure that we won\\'t revisit a string again. For BFS traversal, we would also require to maintain a queue. The algorithm can be summed up into following steps:-\\n\\n1. Insert all strings from *`deadends`* into a hashset and also maintain a *`visited`* set for all strings traversed so far.\\n2. Start BFS traversal from `\"0000\"` by pushing it into the queue and looping till the queue becomes empty.\\n3. At each level of BFS, take the current string and try turning each digit in both forward & backward direction. For eg. we can apply the turning process on `\"0000\"` to get `[\"1000\", \"9000\", \"0100\", \"0900\", \"0010\", \"0090\", \"0001\", \"0009\"]`.\\n4. If any of the strings after applying turning process become equal to *`target`*, return the *`turns`* required till now.\\n5. Else, just push the turned strings into the queue, insert it into *`visited`* set and repeat the same process for all strings in the queue.\\n6. If the queue becomes empty, we have tried all possible paths to reach *`target`* and failed. So return -1.\\n\\n**C++**\\n```\\nint openLock(vector<string>& deadends, string target) {\\n\\tunordered_set<string> dead(begin(deadends), end(deadends)), seen({\"0000\"});\\n\\tif(dead.find(\"0000\") != end(dead)) return -1; // if start string itself is a deadend\\n\\tif(target == \"0000\") return 0; // if start string itself is the target string.\\n\\tqueue<string> q({\"0000\"});\\n\\tint n, minTurns = 0;\\n\\twhile(!q.empty()) {            \\n\\t\\tn = size(q), minTurns++;\\n\\t\\tfor(int i = 0; i < n; i++) { // traversing all nodes on the current level of BFS traversal\\n\\t\\t\\tauto cur_str = q.front(); q.pop();       \\n\\t\\t\\t// Trying forward and backward turn for each digit of current string\\n\\t\\t\\tfor(int j = 0; j < 4; j++) \\n\\t\\t\\t\\tfor(auto adj_str : turn(cur_str, j)) \\n\\t\\t\\t\\t\\tif(seen.find(adj_str) == end(seen) && dead.find(adj_str) == end(dead)) // adjacent (turned) string is not visited earlier, nor a dead end\\n\\t\\t\\t\\t\\t\\tif(adj_str == target) return minTurns;\\n\\t\\t\\t\\t\\t\\telse q.push(adj_str), seen.insert(adj_str);\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n// turns the ith digit of s in forward and backward direction and returns the turned string as vector\\nvector<string> turn(string s, int i) {\\n\\tvector<string> res(2, s);\\n\\tres[0][i] = \\'0\\' + (res[0][i] - \\'0\\' + 1) % 10;        // forward turn\\n\\tres[1][i] = \\'0\\' + (res[1][i] - \\'0\\' - 1 + 10) % 10;   // backward turn\\n\\treturn res;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the number of strings in deadends and `O(N)` is required to insert all the strings into the hashset. The BFS traversal requires `O(1)`. It may be strange but that\\'s how you calculate big O complexity. The time required by our BFS traversal doesn\\'t depend on the input and in the worst case, we end up making 10000 iterations at max. Please let me know if there\\'s any mistake in this analysis\\n\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint openLock(vector<string>& deadends, string target) {\\n\\tunordered_set<string> dead(begin(deadends), end(deadends)), seen({\"0000\"});\\n\\tif(dead.find(\"0000\") != end(dead)) return -1; // if start string itself is a deadend\\n\\tif(target == \"0000\") return 0; // if start string itself is the target string.\\n\\tqueue<string> q({\"0000\"});\\n\\tint n, minTurns = 0;\\n\\twhile(!q.empty()) {            \\n\\t\\tn = size(q), minTurns++;\\n\\t\\tfor(int i = 0; i < n; i++) { // traversing all nodes on the current level of BFS traversal\\n\\t\\t\\tauto cur_str = q.front(); q.pop();       \\n\\t\\t\\t// Trying forward and backward turn for each digit of current string\\n\\t\\t\\tfor(int j = 0; j < 4; j++) \\n\\t\\t\\t\\tfor(auto adj_str : turn(cur_str, j)) \\n\\t\\t\\t\\t\\tif(seen.find(adj_str) == end(seen) && dead.find(adj_str) == end(dead)) // adjacent (turned) string is not visited earlier, nor a dead end\\n\\t\\t\\t\\t\\t\\tif(adj_str == target) return minTurns;\\n\\t\\t\\t\\t\\t\\telse q.push(adj_str), seen.insert(adj_str);\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n// turns the ith digit of s in forward and backward direction and returns the turned string as vector\\nvector<string> turn(string s, int i) {\\n\\tvector<string> res(2, s);\\n\\tres[0][i] = \\'0\\' + (res[0][i] - \\'0\\' + 1) % 10;        // forward turn\\n\\tres[1][i] = \\'0\\' + (res[1][i] - \\'0\\' - 1 + 10) % 10;   // backward turn\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 703224,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        \\n        // BFS because we want to find the minimum numbers of times switching!\\n        \\n        if (target == \"0000\")\\n            return 0;\\n                \\n        Set<String> visited = new HashSet<>(Arrays.asList(deadends)); // don\\'t revisit locations! and let\\'s add all of the deadends to our visited hashset\\n        \\n        if (visited.contains(\"0000\"))\\n            return -1;\\n        \\n        Queue<String> q = new LinkedList<>();\\n        q.offer(\"0000\");\\n        visited.add(\"0000\");\\n        \\n        int cnt = 0;\\n        while (!q.isEmpty()) {\\n            \\n            int len = q.size();\\n                        \\n            while (len > 0) {\\n                String curr = q.poll();\\n                \\n                for (int i = 0; i < 4; i++) {\\n                    // add both up and down!\\n                    char c = curr.charAt(i);\\n                    \\n                    // the - 0 converts the character to an int so math can be performed, once the numbers are added they get converted back to a string! -- clean code inspired by top voted answer\\n                    String up = curr.substring(0, i) + (c == \\'9\\' ? 0 : c - \\'0\\' + 1) + curr.substring(i + 1);\\n                    String dwn = curr.substring(0, i) + (c == \\'0\\' ? 9 : c - \\'0\\' - 1) + curr.substring(i + 1);\\n                                            \\n                    if (up.equals(target) || dwn.equals(target))\\n                        return cnt + 1;\\n                    \\n                    if (!visited.contains(up)) {\\n                        q.offer(up);\\n                        visited.add(up);\\n                    }\\n                    if (!visited.contains(dwn)) {\\n                        q.offer(dwn);\\n                        visited.add(dwn);\\n                    }\\n                }\\n                \\n                len--;\\n            }\\n              \\n            cnt++;\\n        }\\n        \\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public int openLock(String[] deadends, String target) {\\n        \\n        // BFS because we want to find the minimum numbers of times switching!\\n        \\n        if (target == \"0000\")\\n            return 0;\\n                \\n        Set<String> visited = new HashSet<>(Arrays.asList(deadends)); // don\\'t revisit locations! and let\\'s add all of the deadends to our visited hashset\\n        \\n        if (visited.contains(\"0000\"))\\n            return -1;\\n        \\n        Queue<String> q = new LinkedList<>();\\n        q.offer(\"0000\");\\n        visited.add(\"0000\");\\n        \\n        int cnt = 0;\\n        while (!q.isEmpty()) {\\n            \\n            int len = q.size();\\n                        \\n            while (len > 0) {\\n                String curr = q.poll();\\n                \\n                for (int i = 0; i < 4; i++) {\\n                    // add both up and down!\\n                    char c = curr.charAt(i);\\n                    \\n                    // the - 0 converts the character to an int so math can be performed, once the numbers are added they get converted back to a string! -- clean code inspired by top voted answer\\n                    String up = curr.substring(0, i) + (c == \\'9\\' ? 0 : c - \\'0\\' + 1) + curr.substring(i + 1);\\n                    String dwn = curr.substring(0, i) + (c == \\'0\\' ? 9 : c - \\'0\\' - 1) + curr.substring(i + 1);\\n                                            \\n                    if (up.equals(target) || dwn.equals(target))\\n                        return cnt + 1;\\n                    \\n                    if (!visited.contains(up)) {\\n                        q.offer(up);\\n                        visited.add(up);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 310303,
                "title": "heavily-commented-javascript-bfs-solution",
                "content": "```\\n/**\\n * @param {string[]} deadends\\n * @param {string} target\\n * @return {number}\\n */\\nvar openLock = function(deadends, target) {\\n    \\n    // General approach:\\n    // Start at the end, mark that spot to be 0 away from target\\n    // Find all the valid neighbors through bfs, mark those as 1\\n    // Find all _their_ valid neighbors, mark those as ++ etc\\n    // Until we find 0000. Whatever we mark that as is the number. BFS will guarantee it\\'s the shortest path\\n    \\n    let q = [target]; // our BFS Queue\\n    let mem = {};     // to keep track what we already have visited\\n    mem[target] = 0;  // starting distance of the end\\n    \\n    // Helper function that given a position, will generate all the numbers we\\n    // can create in 1 move;\\n    let getNextPositions = function (pos) {\\n        // one above, one below\\n        let dir = [-1, 1];\\n        let arr = pos.split(\\'\\');\\n        let positions = [];\\n        let i, j;\\n        \\n        for (j = 0; j < 2; j++) {\\n            let next = \\'\\';\\n            // for each number in the position\\n            for (i = 0; i < 4; i++) {\\n                // logic is not just +1 -1, have to deal with wrapping around\\n                let n = (10 + parseInt(arr[i], 10) + dir[j]) % 10;\\n                // clone to not ruin our array for the next number\\n                let next = [...arr];\\n                // set our 1 change\\n                next[i] = n;\\n                positions.push(next.join(\\'\\'));\\n            }\\n        }\\n        return positions;\\n    }\\n        \\n    while (q.length) {\\n        // dequeue a position to check out\\n        let pos = q.shift();\\n        \\n        // if it\\'s 0000 we\\'re done. BFS guarantees it\\'s the shortest possible\\n        if (pos === \\'0000\\') {\\n            return mem[pos];\\n        } else {\\n            let next = getNextPositions(pos);\\n            next.forEach(function(n) {\\n                // if we haven\\'t seen n before, and it\\'s not a dead end,\\n                if (mem[n] === undefined && !deadends.includes(n)) {\\n                        // mark the distance and enqueue to check out next\\n                        mem[n] = mem[pos] + 1; \\n                        q.push(n);\\n                }\\n            }) \\n        }  \\n    }\\n    // if we end up here, we couldn\\'t find it\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {string[]} deadends\\n * @param {string} target\\n * @return {number}\\n */\\nvar openLock = function(deadends, target) {\\n    \\n    // General approach:\\n    // Start at the end, mark that spot to be 0 away from target\\n    // Find all the valid neighbors through bfs, mark those as 1\\n    // Find all _their_ valid neighbors, mark those as ++ etc\\n    // Until we find 0000. Whatever we mark that as is the number. BFS will guarantee it\\'s the shortest path\\n    \\n    let q = [target]; // our BFS Queue\\n    let mem = {};     // to keep track what we already have visited\\n    mem[target] = 0;  // starting distance of the end\\n    \\n    // Helper function that given a position, will generate all the numbers we\\n    // can create in 1 move;\\n    let getNextPositions = function (pos) {\\n        // one above, one below\\n        let dir = [-1, 1];\\n        let arr = pos.split(\\'\\');\\n        let positions = [];\\n        let i, j;\\n        \\n        for (j = 0; j < 2; j++) {\\n            let next = \\'\\';\\n            // for each number in the position\\n            for (i = 0; i < 4; i++) {\\n                // logic is not just +1 -1, have to deal with wrapping around\\n                let n = (10 + parseInt(arr[i], 10) + dir[j]) % 10;\\n                // clone to not ruin our array for the next number\\n                let next = [...arr];\\n                // set our 1 change\\n                next[i] = n;\\n                positions.push(next.join(\\'\\'));\\n            }\\n        }\\n        return positions;\\n    }\\n        \\n    while (q.length) {\\n        // dequeue a position to check out\\n        let pos = q.shift();\\n        \\n        // if it\\'s 0000 we\\'re done. BFS guarantees it\\'s the shortest possible\\n        if (pos === \\'0000\\') {\\n            return mem[pos];\\n        } else {\\n            let next = getNextPositions(pos);\\n            next.forEach(function(n) {\\n                // if we haven\\'t seen n before, and it\\'s not a dead end,\\n                if (mem[n] === undefined && !deadends.includes(n)) {\\n                        // mark the distance and enqueue to check out next\\n                        mem[n] = mem[pos] + 1; \\n                        q.push(n);\\n                }\\n            }) \\n        }  \\n    }\\n    // if we end up here, we couldn\\'t find it\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309125,
                "title": "python-bfs-solution-with-comments-beats-92-optimized-using-dictionary",
                "content": "Minor optimizations that improved my runtime:\\ni) Use of dictionary to keep track of the next neighbors. Due to which, we can access the next neighbor easily and eliminate calculations on each step. \\n(ii) Use of deque over list as it provides O(1) time complexity for append and pop operations on both ends. \\n\\n```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        if \"0000\" in deadends: return -1\\n        #All combinations of the neighboring numbers stored in a dictionary\\n        next_num = {str(i):[str((i+1)%10), str((i-1)%10)] for i in range(10)}\\n        #Queue to track the node combination and minimum levels to reach the combination.\\n        queue = collections.deque([(\\'0000\\', 0)])\\n        #Assume that we already visited deadends.\\n        seen = {\\'0000\\'} | set(deadends)\\n        while queue:\\n            cur_node, depth = queue.popleft()\\n            #When the combination matches the target, return the depth\\n            if cur_node == target:\\n                return depth\\n            #For each digit combination\\n            for i in range(len(cur_node)):\\n                #next digit\\n                for n in next_num[cur_node[i]]:\\n                    #insert n in different position to create new combinations\\n                    new_node = cur_node[:i] + n + cur_node[i+1:]\\n                    #Add the combination only when it is not visited yet or if it is not deadend.\\n                    if new_node not in seen:\\n                        seen.add(new_node)\\n                        #Faster way to append\\n                        queue += (new_node, depth + 1),\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        if \"0000\" in deadends: return -1\\n        #All combinations of the neighboring numbers stored in a dictionary\\n        next_num = {str(i):[str((i+1)%10), str((i-1)%10)] for i in range(10)}\\n        #Queue to track the node combination and minimum levels to reach the combination.\\n        queue = collections.deque([(\\'0000\\', 0)])\\n        #Assume that we already visited deadends.\\n        seen = {\\'0000\\'} | set(deadends)\\n        while queue:\\n            cur_node, depth = queue.popleft()\\n            #When the combination matches the target, return the depth\\n            if cur_node == target:\\n                return depth\\n            #For each digit combination\\n            for i in range(len(cur_node)):\\n                #next digit\\n                for n in next_num[cur_node[i]]:\\n                    #insert n in different position to create new combinations\\n                    new_node = cur_node[:i] + n + cur_node[i+1:]\\n                    #Add the combination only when it is not visited yet or if it is not deadend.\\n                    if new_node not in seen:\\n                        seen.add(new_node)\\n                        #Faster way to append\\n                        queue += (new_node, depth + 1),\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250748,
                "title": "c-super-simple-clean-and-concise-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        queue<string> q;\\n        unordered_set<string> ends(deadends.begin(), deadends.end());\\n        int size, turns = 0, a, b;\\n        string curr, tmp;\\n        \\n        q.push(\"0000\");\\n        while (!q.empty()) {\\n            size = q.size();\\n            \\n            while (size) {\\n                size--;\\n                curr = q.front(); q.pop();\\n                if (curr == target) return turns;\\n                if (ends.find(curr) != ends.end()) continue;\\n                ends.insert(curr);\\n                \\n                for (int i = 0; i < 4; i++) {\\n                    tmp = curr;\\n                    a = tmp[i] - \\'0\\' + 1;\\n                    b = tmp[i] - \\'0\\' - 1;\\n                    \\n                    if (b < 0) b += 10;\\n                    a %= 10; b %= 10;\\n                    \\n                    tmp[i] = a + \\'0\\';\\n                    q.push(tmp);\\n                    \\n                    tmp[i] = b + \\'0\\';\\n                    q.push(tmp);\\n                }\\n            }\\n            turns++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        queue<string> q;\\n        unordered_set<string> ends(deadends.begin(), deadends.end());\\n        int size, turns = 0, a, b;\\n        string curr, tmp;\\n        \\n        q.push(\"0000\");\\n        while (!q.empty()) {\\n            size = q.size();\\n            \\n            while (size) {\\n                size--;\\n                curr = q.front(); q.pop();\\n                if (curr == target) return turns;\\n                if (ends.find(curr) != ends.end()) continue;\\n                ends.insert(curr);\\n                \\n                for (int i = 0; i < 4; i++) {\\n                    tmp = curr;\\n                    a = tmp[i] - \\'0\\' + 1;\\n                    b = tmp[i] - \\'0\\' - 1;\\n                    \\n                    if (b < 0) b += 10;\\n                    a %= 10; b %= 10;\\n                    \\n                    tmp[i] = a + \\'0\\';\\n                    q.push(tmp);\\n                    \\n                    tmp[i] = b + \\'0\\';\\n                    q.push(tmp);\\n                }\\n            }\\n            turns++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 908020,
                "title": "java-4ms-beats-100-bidirectional-bfs-with-explanation",
                "content": "**Basic solution:**\\nModel the problem in terms of graph where each state of the wheels represents a vertex and every possible way to change from one state of wheels to another by changing exactly one of the wheels represents an edge. It is easy to see that there are 8 edges per vertex (we can do +1 or -1 on any one of the 4 wheels).\\nOur goal is to find the length of shortest path from source (fixed as \"0000\") vertex to target vertex. Since each edge has a unit cost, we can simply **do a BFS** to find the minimum no of steps.\\nOne more thing, some of the states are deadends which basically means that our path should not go through any of the corresponding vertices. We can easily handle it by using a set and avoid visiting those vertices.\\n\\n**Optimized solution:**\\nAlthough there is nothing wrong with the previous solution and in fact, the worst case time complexities of previous and this solution are same but we can do a couple of optimizations mentioned below that will make this new solution perform much faster in practice.\\n\\n1. Do a bidirectional BFS instead of starting from one end only.\\n\\t* What it entails is that we start searching from both ends and when we explore a node that has already been explored by the other direction, we know that we have found the path. Call direction from src towards dest as **forward** and dest towards src as **backward**. One way could be to alternate turns between these two for doing the search. A better way is to do the search from the direction which has less no of nodes.\\n2.  Use integers instead of strings to represent a node.\\n3.  Deadends need not require a separate set. We can simply put them in the visited set to basically mean that we have already visited them so don\\'t visit again.\\n4.  To test for path we need to check **backward.contains(next)**, one way is to create forward and backward as sets but sets are slower than queues. To be able to create forward and backward as queues, we can have visited array as **int instead of boolean** and have more \"information\" stored in it. This \"information\" is basically that which direction visited a particular element. So if the opposite direction visited that element, we know that we have found a path.\\n5.  Avoid repeated calculation involving * and % (these are costly operations). Create a pow10 array in the beginning instead of generating it when needed because it will be needed **a lot**.\\n6.  Use LinkedList for queues instead of using ArrayDeque. Okay, this is a dirty hack but it reduced my time from 6ms to 4ms (99.96% to 100%).\\n\\n```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        int[] pow10 = {1, 10, 100, 1000};\\n        int[] visit = new int[10000]; // 0: not visited, 1: visited through forward direction, -1: visited through backward direction, 2: deadends\\n        for(String dead: deadends) {\\n            visit[Integer.parseInt(dead)] = 2;\\n        }\\n        int src = 0, dest = Integer.parseInt(target), steps = 0, dir = 1;\\n        if(visit[src] == 2 || visit[dest] == 2) return -1;\\n        if(src == dest) return 0;\\n        Queue<Integer> forward = new LinkedList<>(), backward = new LinkedList<>();\\n        forward.add(src);\\n        visit[src] = 1;\\n        backward.add(dest);\\n        visit[dest] = -1;\\n        while(!forward.isEmpty() && !backward.isEmpty()) {\\n            if(forward.size() > backward.size()) {\\n                Queue<Integer> tmp = forward; forward = backward; backward = tmp;\\n                dir = -dir;\\n            }\\n            steps++;\\n            int size = forward.size();\\n            while(size-- > 0) {\\n                int cur = forward.poll();\\n                for(int p: pow10) {\\n                    int d = (cur / p) % 10;\\n                    for(int i = -1; i <= 1; i += 2) {\\n                        int z = d + i;\\n                        z = z == -1 ? 9 : (z == 10 ? 0 : z);\\n                        int next = cur + (z - d) * p;\\n                        if(visit[next] == -dir) return steps;\\n                        if(visit[next] == 0) {\\n                            forward.add(next);\\n                            visit[next] = dir;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        int[] pow10 = {1, 10, 100, 1000};\\n        int[] visit = new int[10000]; // 0: not visited, 1: visited through forward direction, -1: visited through backward direction, 2: deadends\\n        for(String dead: deadends) {\\n            visit[Integer.parseInt(dead)] = 2;\\n        }\\n        int src = 0, dest = Integer.parseInt(target), steps = 0, dir = 1;\\n        if(visit[src] == 2 || visit[dest] == 2) return -1;\\n        if(src == dest) return 0;\\n        Queue<Integer> forward = new LinkedList<>(), backward = new LinkedList<>();\\n        forward.add(src);\\n        visit[src] = 1;\\n        backward.add(dest);\\n        visit[dest] = -1;\\n        while(!forward.isEmpty() && !backward.isEmpty()) {\\n            if(forward.size() > backward.size()) {\\n                Queue<Integer> tmp = forward; forward = backward; backward = tmp;\\n                dir = -dir;\\n            }\\n            steps++;\\n            int size = forward.size();\\n            while(size-- > 0) {\\n                int cur = forward.poll();\\n                for(int p: pow10) {\\n                    int d = (cur / p) % 10;\\n                    for(int i = -1; i <= 1; i += 2) {\\n                        int z = d + i;\\n                        z = z == -1 ? 9 : (z == 10 ? 0 : z);\\n                        int next = cur + (z - d) * p;\\n                        if(visit[next] == -dir) return steps;\\n                        if(visit[next] == 0) {\\n                            forward.add(next);\\n                            visit[next] = dir;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805222,
                "title": "easy-python-bfs-solution-with-comment",
                "content": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:  \\n        # set is hashtable which makes accessing faster. \\n        deadends = set(deadends)\\n        # Dealing with sepcial conditions\\n        \\n        if \"0000\" in deadends: return -1      \\n        if target == \"0000\": return 0\\n        \\n        # Initialize bfs queue and visited dictionary to avoid going back\\n        queue = collections.deque()\\n        visited = {}\\n        queue.append([\"0000\", 0])\\n        \\n        while len(queue) > 0:   \\n            current, level = queue.popleft()            \\n            new_nums = []       \\n            \\n            # Collect all connected numbers (8 of them)\\n            for i in range(4):\\n                new_nums.append(current[:i] + str((int(current[i]) + 1) % 10) + current[i+1:])                \\n                new_nums.append(current[:i] + str((int(current[i]) - 1) % 10) + current[i+1:])\\n            \\n            # Either append new number to queue with one level deeper or just pass it if visited or deadend\\n            for num in new_nums:\\n                if num in visited or num in deadends:\\n                    continue\\n                visited[num] = True                \\n                if num == target:\\n                    return level + 1\\n                queue.append([num, level + 1])                \\n        return -1       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:  \\n        # set is hashtable which makes accessing faster. \\n        deadends = set(deadends)\\n        # Dealing with sepcial conditions\\n        \\n        if \"0000\" in deadends: return -1      \\n        if target == \"0000\": return 0\\n        \\n        # Initialize bfs queue and visited dictionary to avoid going back\\n        queue = collections.deque()\\n        visited = {}\\n        queue.append([\"0000\", 0])\\n        \\n        while len(queue) > 0:   \\n            current, level = queue.popleft()            \\n            new_nums = []       \\n            \\n            # Collect all connected numbers (8 of them)\\n            for i in range(4):\\n                new_nums.append(current[:i] + str((int(current[i]) + 1) % 10) + current[i+1:])                \\n                new_nums.append(current[:i] + str((int(current[i]) - 1) % 10) + current[i+1:])\\n            \\n            # Either append new number to queue with one level deeper or just pass it if visited or deadend\\n            for num in new_nums:\\n                if num in visited or num in deadends:\\n                    continue\\n                visited[num] = True                \\n                if num == target:\\n                    return level + 1\\n                queue.append([num, level + 1])                \\n        return -1       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 729342,
                "title": "python-straight-forward-bfs",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        deadEndSet = set(deadends)\\n        queue = deque()\\n        queue.append((\\'0000\\', 0))\\n        visited = set(\\'0000\\')\\n\\n        while queue:\\n            curStr, curSteps = queue.popleft()\\n\\n            if curStr == target:\\n                return curSteps\\n\\n            if curStr in deadEndSet:\\n                continue\\n\\n            for i in range(4):\\n                digit = int(curStr[i])\\n                for dir in [1, -1]:\\n                    newDigit = (digit + dir) % 10\\n\\n                    newStr = curStr[:i] + str(newDigit) + curStr[i+1:]\\n\\n                    if newStr not in visited:\\n                        visited.add(newStr)\\n                        queue.append((newStr, curSteps+1))\\n\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        deadEndSet = set(deadends)\\n        queue = deque()\\n        queue.append((\\'0000\\', 0))\\n        visited = set(\\'0000\\')\\n\\n        while queue:\\n            curStr, curSteps = queue.popleft()\\n\\n            if curStr == target:\\n                return curSteps\\n\\n            if curStr in deadEndSet:\\n                continue\\n\\n            for i in range(4):\\n                digit = int(curStr[i])\\n                for dir in [1, -1]:\\n                    newDigit = (digit + dir) % 10\\n\\n                    newStr = curStr[:i] + str(newDigit) + curStr[i+1:]\\n\\n                    if newStr not in visited:\\n                        visited.add(newStr)\\n                        queue.append((newStr, curSteps+1))\\n\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417274,
                "title": "c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int OpenLock(string[] d, string t) \\n    {\\n        var deadEnds = new HashSet<string>(d);\\n        if(deadEnds.Contains(\"0000\") || deadEnds.Contains(t)) \\n            return -1;\\n        \\n        var visited = new HashSet<string>();\\n        var queue = new Queue<string>();\\n        queue.Enqueue(\"0000\");\\n        visited.Add(\"0000\");\\n        int level = 0;\\n        while(queue.Any())\\n        {\\n            int count = queue.Count;\\n            for(int i = 0; i< count; i++)\\n            {\\n                var current = queue.Dequeue();\\n                if(current.Equals(t))\\n                    return level;\\n                foreach(var neighbor in GetNeighbors(current))\\n                {\\n                    if(!visited.Contains(neighbor) && !deadEnds.Contains(neighbor))\\n                    {\\n                        queue.Enqueue(neighbor);\\n                        visited.Add(neighbor);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private List<string> GetNeighbors(string s)\\n    {\\n        var result = new List<string>();\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            var charArray1 = s.ToCharArray();\\n            charArray1[i] = charArray1[i] == \\'9\\' ? \\'0\\' : (char)((int) charArray1[i] + 1);\\n            result.Add(new string(charArray1));\\n            var charArray2 = s.ToCharArray();\\n            charArray2[i] = charArray2[i] == \\'0\\' ? \\'9\\' : (char) ((int)charArray2[i] - 1);\\n            result.Add(new string(charArray2));\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int OpenLock(string[] d, string t) \\n    {\\n        var deadEnds = new HashSet<string>(d);\\n        if(deadEnds.Contains(\"0000\") || deadEnds.Contains(t)) \\n            return -1;\\n        \\n        var visited = new HashSet<string>();\\n        var queue = new Queue<string>();\\n        queue.Enqueue(\"0000\");\\n        visited.Add(\"0000\");\\n        int level = 0;\\n        while(queue.Any())\\n        {\\n            int count = queue.Count;\\n            for(int i = 0; i< count; i++)\\n            {\\n                var current = queue.Dequeue();\\n                if(current.Equals(t))\\n                    return level;\\n                foreach(var neighbor in GetNeighbors(current))\\n                {\\n                    if(!visited.Contains(neighbor) && !deadEnds.Contains(neighbor))\\n                    {\\n                        queue.Enqueue(neighbor);\\n                        visited.Add(neighbor);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private List<string> GetNeighbors(string s)\\n    {\\n        var result = new List<string>();\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            var charArray1 = s.ToCharArray();\\n            charArray1[i] = charArray1[i] == \\'9\\' ? \\'0\\' : (char)((int) charArray1[i] + 1);\\n            result.Add(new string(charArray1));\\n            var charArray2 = s.ToCharArray();\\n            charArray2[i] = charArray2[i] == \\'0\\' ? \\'9\\' : (char) ((int)charArray2[i] - 1);\\n            result.Add(new string(charArray2));\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471606,
                "title": "java-easy-approach-with-explanation-hashmap-bfs-hashset",
                "content": "```\\nclass Solution \\n{\\n    public int openLock(String[] deadends, String target) \\n    {\\n        HashMap<String, Integer> map= new HashMap<>();//deadend -- index\\n        for(int i= 0; i< deadends.length; i++)\\n            map.put(deadends[i], i);\\n        \\n        HashSet<String> visited= new HashSet<>();//visited set tro keep track of the node visited and to prevent cycle \\n        Queue<String> q= new ArrayDeque<>();\\n    \\n        int level= 0;\\n        \\n        q.offer(\"0000\");//adding the starting node to the queue(starting pattern)\\n        while(!q.isEmpty())\\n        {//r m* w a*\\n            int size= q.size();//polling constraint \\n            while(size -- >0)\\n            {\\n                String temp= q.poll();\\n                \\n                if(temp.equals(target))\\n                   return level;//when we reached to nour destination node(lock number)\\n                \\n                if(map.containsKey(temp) == true)\\n                    continue;//wrong path(reached deadend)\\n                \\n                if(visited.contains(temp) == true)\\n                    continue;//cycle\\n                else\\n                    visited.add(temp);//marking the current node as visited, if not visited \\n                \\n                StringBuilder sb= new StringBuilder(temp);//using StringBuilder to modify the current string, since it is mutable\\n                for(int i= 0; i< 4; i++)\\n                {\\n                    char digit= sb.charAt(i);//extracting the current digit \\n                    \\n                    String str1= temp.substring(0, i)+ (digit == \\'9\\' ? 0: (digit-\\'0\\'+1))+ temp.substring(i+1);//clockwise\\n                    \\n                    String str2= temp.substring(0, i)+ (digit == \\'0\\' ? 9: (digit-\\'0\\'-1))+ temp.substring(i+1);//anticlockwise\\n                    \\n                    //adding the valid adjacent pattern pattern \\n                    if(!visited.contains(str1) && !map.containsKey(str1))\\n                        q.offer(str1);\\n                    \\n                    if(!visited.contains(str2) && !map.containsKey(str2))\\n                        q.offer(str2);\\n                }\\n            }\\n            level+= 1;//increasing the current level \\n        }\\n        return -1;//when we cannot reach our destination node \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int openLock(String[] deadends, String target) \\n    {\\n        HashMap<String, Integer> map= new HashMap<>();//deadend -- index\\n        for(int i= 0; i< deadends.length; i++)\\n            map.put(deadends[i], i);\\n        \\n        HashSet<String> visited= new HashSet<>();//visited set tro keep track of the node visited and to prevent cycle \\n        Queue<String> q= new ArrayDeque<>();\\n    \\n        int level= 0;\\n        \\n        q.offer(\"0000\");//adding the starting node to the queue(starting pattern)\\n        while(!q.isEmpty())\\n        {//r m* w a*\\n            int size= q.size();//polling constraint \\n            while(size -- >0)\\n            {\\n                String temp= q.poll();\\n                \\n                if(temp.equals(target))\\n                   return level;//when we reached to nour destination node(lock number)\\n                \\n                if(map.containsKey(temp) == true)\\n                    continue;//wrong path(reached deadend)\\n                \\n                if(visited.contains(temp) == true)\\n                    continue;//cycle\\n                else\\n                    visited.add(temp);//marking the current node as visited, if not visited \\n                \\n                StringBuilder sb= new StringBuilder(temp);//using StringBuilder to modify the current string, since it is mutable\\n                for(int i= 0; i< 4; i++)\\n                {\\n                    char digit= sb.charAt(i);//extracting the current digit \\n                    \\n                    String str1= temp.substring(0, i)+ (digit == \\'9\\' ? 0: (digit-\\'0\\'+1))+ temp.substring(i+1);//clockwise\\n                    \\n                    String str2= temp.substring(0, i)+ (digit == \\'0\\' ? 9: (digit-\\'0\\'-1))+ temp.substring(i+1);//anticlockwise\\n                    \\n                    //adding the valid adjacent pattern pattern \\n                    if(!visited.contains(str1) && !map.containsKey(str1))\\n                        q.offer(str1);\\n                    \\n                    if(!visited.contains(str2) && !map.containsKey(str2))\\n                        q.offer(str2);\\n                }\\n            }\\n            level+= 1;//increasing the current level \\n        }\\n        return -1;//when we cannot reach our destination node \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171405,
                "title": "cannot-understand-the-fastest-py3-solution-in-histogram-until-find-out-it-is-incorrect",
                "content": "The fastest one (36ms) in the Py3 submission is so much faster than BFS. It seems to use a greedy idea and checks if any of the neighbors of ```target``` is reachable. I couldn\\'t figure out why it works until find out it is incorrect.\\n\\nA \"cannot unlock\" test case like\\n[\"1000\",\"0100\",\"0010\",\"0001\",\"9000\",\"0900\",\"0090\",\"0009\"]\\n\"1234\"\\ncan make it wrong\\n",
                "solutionTags": [],
                "code": "```target```",
                "codeTag": "Unknown"
            },
            {
                "id": 1251655,
                "title": "java-clean-concise-optimal-code-breadth-first-search-algorithm",
                "content": "```\\nclass Solution {\\n    \\n    public String plusOne (String str, int index) {\\n        \\n        char[] c = str.toCharArray ();\\n        \\n        if (c[index] == \\'9\\') {\\n            c[index] = \\'0\\';\\n        }\\n        else {\\n            c[index] += 1;\\n        }\\n        \\n        return new String (c);\\n    }\\n    \\n    public String minusOne (String str, int index) {\\n        \\n        char[] c = str.toCharArray ();\\n        \\n        if (c[index] == \\'0\\') {\\n            c[index] = \\'9\\';\\n        }\\n        else {\\n            c[index] -= 1;\\n        }\\n        \\n        return new String (c);\\n    }\\n    \\n    public int openLock(String[] deadends, String target) {\\n        \\n        int minimumTurns = -1;\\n        Set<String> set = new HashSet<> ();\\n        Queue<String> queue = new LinkedList<> ();\\n        \\n        set.add (\"0000\");\\n        queue.offer (\"0000\");\\n        \\n        for (String deadend : deadends) {\\n            if (deadend.equals (\"0000\")) {\\n                return -1;\\n            }\\n            \\n            set.add (deadend);\\n        }\\n        \\n        while (!queue.isEmpty ()) {\\n            ++minimumTurns;\\n            int size = queue.size ();\\n            \\n            while (size-- != 0) {\\n                String str = queue.poll ();\\n                if (str.equals (target)) {\\n                    return minimumTurns;\\n                }\\n                \\n                for (int index = 0; index < 4; index++) {\\n                    String plus = plusOne (str, index);\\n                    String minus = minusOne (str, index);\\n                    \\n                    if (!set.contains (plus)) {\\n                        set.add (plus);\\n                        queue.offer (plus);\\n                    }\\n                    if (!set.contains (minus)) {\\n                        set.add (minus);\\n                        queue.offer (minus);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String plusOne (String str, int index) {\\n        \\n        char[] c = str.toCharArray ();\\n        \\n        if (c[index] == \\'9\\') {\\n            c[index] = \\'0\\';\\n        }\\n        else {\\n            c[index] += 1;\\n        }\\n        \\n        return new String (c);\\n    }\\n    \\n    public String minusOne (String str, int index) {\\n        \\n        char[] c = str.toCharArray ();\\n        \\n        if (c[index] == \\'0\\') {\\n            c[index] = \\'9\\';\\n        }\\n        else {\\n            c[index] -= 1;\\n        }\\n        \\n        return new String (c);\\n    }\\n    \\n    public int openLock(String[] deadends, String target) {\\n        \\n        int minimumTurns = -1;\\n        Set<String> set = new HashSet<> ();\\n        Queue<String> queue = new LinkedList<> ();\\n        \\n        set.add (\"0000\");\\n        queue.offer (\"0000\");\\n        \\n        for (String deadend : deadends) {\\n            if (deadend.equals (\"0000\")) {\\n                return -1;\\n            }\\n            \\n            set.add (deadend);\\n        }\\n        \\n        while (!queue.isEmpty ()) {\\n            ++minimumTurns;\\n            int size = queue.size ();\\n            \\n            while (size-- != 0) {\\n                String str = queue.poll ();\\n                if (str.equals (target)) {\\n                    return minimumTurns;\\n                }\\n                \\n                for (int index = 0; index < 4; index++) {\\n                    String plus = plusOne (str, index);\\n                    String minus = minusOne (str, index);\\n                    \\n                    if (!set.contains (plus)) {\\n                        set.add (plus);\\n                        queue.offer (plus);\\n                    }\\n                    if (!set.contains (minus)) {\\n                        set.add (minus);\\n                        queue.offer (minus);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076496,
                "title": "a-star-algorithm-a",
                "content": "A commonly used solution to this problem is the Breadth-First Search algorithm. BFS evaluates all possible combinations at the same distance from \"0000\" before evaluating any combinations further away, thus guaranteeing that the first path to reach the target will be the shortest.\\n\\nHowever, when we as humans would try to solve this problem, we wouldn\\'t blindly try all combinations that are one turn away, then all combinations two turns away, and so forth. Instead, we can immediately see which weels and how many times need to be turned. In other words, for each state of the lock, we can estimate the number of turns required to reach the target.\\n\\nRemember this:\\n\\n1. When you need to find the shortest path in a grid or a graph, use BFS.\\n2. When you need to find the shortest path and you can provide an estimate of the cost of the remaining path for each state, use A*.\\n\\nWe can also reframe the lock opening problem as follow:\\n\\n1. Find the cost of the shortest path from the source to the target in a four-dimensional grid.\\n2. The movement between states, or cells, costs one and is done by adding +1 or -1 to one of the dimensions.\\n3. Walking past any grid border along one dimension wraps around this dimension.\\n4. We are given a list of states from which all other states are inaccessible.\\n\\nWith this problem definition, it becomes apparent that we should use the A* algorithm and the manhattan distance as the heuristic to find the shortest path on a grid.\\nNot so fast. Manhattan distance won\\'t cut it because we can wrap around the grid\\'s dimensions. So if we walk past 9 in any dimension, we will arrive at 0, and if we walk past 0 we will arrive at 9.\\n\\nRemember that for the A* algorithm to work, the heuristic must never overestimate the distance to the target. Fortunately, we can easily modify the manhattan distance always to give the minimum estimate to the target. For each dimension:\\n\\n1. calculate the distance as usual.\\n2. calculate the distance if we wrap over the border on the left.\\n3. calculate the distance if we wrap over the border on the right.\\n4. select the minimum of the above.\\n\\n```cpp\\nauto heuristic = [&target](const string& state) {\\n    int dist = 0;\\n    for (int i = 0; i < 4; ++i)\\n    {\\n        int d1 = abs(target[i] - state[i]);\\n        int d2 = abs(\\'0\\' - state[i]) + abs(target[i] - \\'9\\') + 1;\\n        int d3 = abs(\\'0\\' - target[i]) + abs(state[i] - \\'9\\') + 1;\\n        dist += std::min(std::min(d1, d2), d3);\\n    }\\n    return dist;\\n};\\n```\\n\\nApart from the slightly modified manhattan distance, this is a classic A* on the grid.\\n\\nPlease upvote this solution, because I haven\\'t seen the A* applied to this problem before!\\n\\n\\nComplete implementation:\\n```cpp\\nstruct State\\n{\\n    string state;\\n    int act_cost = INT_MAX;\\n    int est_cost = INT_MAX;\\n    \\n    int cost() const\\n    {\\n        return act_cost + est_cost;\\n    }\\n};\\n\\nstruct State_Comparator\\n{\\n    bool operator()(const State& l, const State& r)\\n    {\\n        return l.cost() > r.cost() \\n            || l.cost() == r.cost() && l.act_cost >= r.act_cost;\\n    }\\n};\\n\\nclass Solution\\n{\\npublic:\\n    int openLock(const vector<string>& deadends, const string& target)\\n    {\\n        const string start = \"0000\";\\n        if (target == start)\\n        {\\n            return 0;\\n        }\\n        priority_queue<State, vector<State>, State_Comparator> q;\\n        unordered_set<string> seen(begin(deadends), end(deadends));\\n        if (seen.count(start))\\n        {\\n            return -1;\\n        }\\n        int ds[] = {1, -1};\\n        \\n        auto heuristic = [&target](const string& state) {\\n            int dist = 0;\\n            for (int i = 0; i < 4; ++i)\\n            {\\n                int d1 = abs(target[i] - state[i]);\\n                int d2 = abs(\\'0\\' - state[i]) + abs(target[i] - \\'9\\') + 1;\\n                int d3 = abs(\\'0\\' - target[i]) + abs(state[i] - \\'9\\') + 1;\\n                dist += std::min(std::min(d1, d2), d3);\\n            }\\n            return dist;\\n        };\\n\\n        q.push(State{\\n            .state = start,\\n            .act_cost = 0,\\n            .est_cost = heuristic(start),\\n        });\\n        seen.insert(start);\\n        \\n        while (!q.empty())\\n        {\\n            State state = q.top();\\n            q.pop();\\n\\n            for (int i = 0; i < 4; ++i)\\n            {\\n                for (int d : ds)\\n                {\\n                    string nstate = state.state;\\n                    nstate[i] = (10 + (nstate[i] - \\'0\\') + d) % 10 + \\'0\\';\\n                    if (nstate == target)\\n                    {\\n                        return state.act_cost + 1;\\n                    }\\n                    auto [iter, inserted] = seen.insert(nstate);\\n                    if (inserted)\\n                    {\\n                        q.push(State {\\n                            .state = nstate,\\n                            .act_cost = state.act_cost + 1,\\n                            .est_cost = heuristic(nstate),\\n                        });\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nauto heuristic = [&target](const string& state) {\\n    int dist = 0;\\n    for (int i = 0; i < 4; ++i)\\n    {\\n        int d1 = abs(target[i] - state[i]);\\n        int d2 = abs(\\'0\\' - state[i]) + abs(target[i] - \\'9\\') + 1;\\n        int d3 = abs(\\'0\\' - target[i]) + abs(state[i] - \\'9\\') + 1;\\n        dist += std::min(std::min(d1, d2), d3);\\n    }\\n    return dist;\\n};\\n```\n```cpp\\nstruct State\\n{\\n    string state;\\n    int act_cost = INT_MAX;\\n    int est_cost = INT_MAX;\\n    \\n    int cost() const\\n    {\\n        return act_cost + est_cost;\\n    }\\n};\\n\\nstruct State_Comparator\\n{\\n    bool operator()(const State& l, const State& r)\\n    {\\n        return l.cost() > r.cost() \\n            || l.cost() == r.cost() && l.act_cost >= r.act_cost;\\n    }\\n};\\n\\nclass Solution\\n{\\npublic:\\n    int openLock(const vector<string>& deadends, const string& target)\\n    {\\n        const string start = \"0000\";\\n        if (target == start)\\n        {\\n            return 0;\\n        }\\n        priority_queue<State, vector<State>, State_Comparator> q;\\n        unordered_set<string> seen(begin(deadends), end(deadends));\\n        if (seen.count(start))\\n        {\\n            return -1;\\n        }\\n        int ds[] = {1, -1};\\n        \\n        auto heuristic = [&target](const string& state) {\\n            int dist = 0;\\n            for (int i = 0; i < 4; ++i)\\n            {\\n                int d1 = abs(target[i] - state[i]);\\n                int d2 = abs(\\'0\\' - state[i]) + abs(target[i] - \\'9\\') + 1;\\n                int d3 = abs(\\'0\\' - target[i]) + abs(state[i] - \\'9\\') + 1;\\n                dist += std::min(std::min(d1, d2), d3);\\n            }\\n            return dist;\\n        };\\n\\n        q.push(State{\\n            .state = start,\\n            .act_cost = 0,\\n            .est_cost = heuristic(start),\\n        });\\n        seen.insert(start);\\n        \\n        while (!q.empty())\\n        {\\n            State state = q.top();\\n            q.pop();\\n\\n            for (int i = 0; i < 4; ++i)\\n            {\\n                for (int d : ds)\\n                {\\n                    string nstate = state.state;\\n                    nstate[i] = (10 + (nstate[i] - \\'0\\') + d) % 10 + \\'0\\';\\n                    if (nstate == target)\\n                    {\\n                        return state.act_cost + 1;\\n                    }\\n                    auto [iter, inserted] = seen.insert(nstate);\\n                    if (inserted)\\n                    {\\n                        q.push(State {\\n                            .state = nstate,\\n                            .act_cost = state.act_cost + 1,\\n                            .est_cost = heuristic(nstate),\\n                        });\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821105,
                "title": "python3-bfs-solution-open-the-lock",
                "content": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        def neighbors(s):\\n            nei = []\\n            for i, c in enumerate(s):\\n                for d in [1, -1]:\\n                    nei.append(s[:i] + str((int(c)+d) % 10) + s[i+1:])\\n            return nei    \\n        deadends = set(deadends)\\n        if \\'0000\\' in deadends: return -1\\n        if \\'0000\\' == target: return 0\\n        q = deque([\\'0000\\'])\\n        dist = {\\'0000\\': 0}\\n        while q:\\n            num = q.popleft()\\n            d = dist[num] + 1\\n            for nei in neighbors(num):\\n                if nei not in dist and nei not in deadends:\\n                    if nei == target:\\n                        return  d\\n                    q.append(nei)\\n                    dist[nei] = d\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        def neighbors(s):\\n            nei = []\\n            for i, c in enumerate(s):\\n                for d in [1, -1]:\\n                    nei.append(s[:i] + str((int(c)+d) % 10) + s[i+1:])\\n            return nei    \\n        deadends = set(deadends)\\n        if \\'0000\\' in deadends: return -1\\n        if \\'0000\\' == target: return 0\\n        q = deque([\\'0000\\'])\\n        dist = {\\'0000\\': 0}\\n        while q:\\n            num = q.popleft()\\n            d = dist[num] + 1\\n            for nei in neighbors(num):\\n                if nei not in dist and nei not in deadends:\\n                    if nei == target:\\n                        return  d\\n                    q.append(nei)\\n                    dist[nei] = d\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157086,
                "title": "my-accepted-bfs-java-solution",
                "content": "```\\npublic int openLock(String[] deadends, String target) {\\n    Set<String> visited = new HashSet<>();\\n\\n    Set<String> deadSet = new HashSet<>(Arrays.asList(deadends));\\n    \\n    Queue<String> queue = new LinkedList<>();\\n    \\n    int level = 0;\\n    \\n    queue.offer(\"0000\");\\n\\n    while (!queue.isEmpty()) {\\n      int size = queue.size();\\n\\n      for (int i = 0; i < size; i++) {\\n        String s = queue.poll();\\n\\n        if (visited.contains(s)) continue;\\n\\n        if (deadSet.contains(s)) continue;\\n\\n        if (s.equals(target)) return level;\\n\\n        visited.add(s);\\n\\n        char[] cArr = s.toCharArray();\\n\\n        for (int j = 0; j < cArr.length; j++) {\\n          char tmp = cArr[j];\\n\\n          if (cArr[j] < \\'9\\')\\n            cArr[j]++;\\n          else\\n            cArr[j] = \\'0\\';\\n\\n          queue.offer(new String(cArr));\\n          \\n          cArr[j] = tmp;\\n\\n          if (cArr[j] > \\'0\\')\\n            cArr[j]--;\\n          else\\n            cArr[j] = \\'9\\';\\n            \\n          queue.offer(new String(cArr));\\n            \\n          cArr[j] = tmp;\\n        \\n        }\\n        \\n      }\\n\\n      level++;\\n    }\\n\\n\\n    return -1;\\n}\\n```\\n\\nPlease leave a comment if you find anything unclear :)",
                "solutionTags": [],
                "code": "```\\npublic int openLock(String[] deadends, String target) {\\n    Set<String> visited = new HashSet<>();\\n\\n    Set<String> deadSet = new HashSet<>(Arrays.asList(deadends));\\n    \\n    Queue<String> queue = new LinkedList<>();\\n    \\n    int level = 0;\\n    \\n    queue.offer(\"0000\");\\n\\n    while (!queue.isEmpty()) {\\n      int size = queue.size();\\n\\n      for (int i = 0; i < size; i++) {\\n        String s = queue.poll();\\n\\n        if (visited.contains(s)) continue;\\n\\n        if (deadSet.contains(s)) continue;\\n\\n        if (s.equals(target)) return level;\\n\\n        visited.add(s);\\n\\n        char[] cArr = s.toCharArray();\\n\\n        for (int j = 0; j < cArr.length; j++) {\\n          char tmp = cArr[j];\\n\\n          if (cArr[j] < \\'9\\')\\n            cArr[j]++;\\n          else\\n            cArr[j] = \\'0\\';\\n\\n          queue.offer(new String(cArr));\\n          \\n          cArr[j] = tmp;\\n\\n          if (cArr[j] > \\'0\\')\\n            cArr[j]--;\\n          else\\n            cArr[j] = \\'9\\';\\n            \\n          queue.offer(new String(cArr));\\n            \\n          cArr[j] = tmp;\\n        \\n        }\\n        \\n      }\\n\\n      level++;\\n    }\\n\\n\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1558750,
                "title": "c-bfs-beats-100-time-and-99-5-space-with-thinking-process-and-explanation",
                "content": "this is apparently a BFS problem, where `|V| = 10000` and `|E| = 8 * |V|`.\\nall following implementations have the same time/space **complexity**, but **differ in runtime and actual used space**.\\nI improved runtime from 372 ms to **12 ms (beats 100%)**, and memory usage from 36.5 MB to **10.2 MB (beats 99.5%)**. I will explain my thought behind each improvement below.\\n\\n**Version 1**. `queue<string>` + `set<string>`: 372 ms, 36.5 MB\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        // BFS\\n        // |V| = 10000, |E| = 8 * 10000\\n        \\n        set<string> vis;\\n        for (auto& d : deadends) vis.insert(d);\\n        if (vis.count(\"0000\")) return -1;\\n        vis.insert(\"0000\");\\n        \\n        queue<string> q;\\n        q.push(\"0000\");\\n        \\n        int dist = -1;\\n        while (!q.empty()) {\\n            dist++;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                string& curr = q.front();\\n                if (curr == target) return dist;\\n                \\n                relax(curr, vis, q);\\n                \\n                q.pop();\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    void relax(string& curr, set<string>& vis, queue<string>& q) {\\n        for (int i = 0; i < 4; i++) {\\n            char ori = curr[i];\\n            if (curr[i] == \\'0\\') curr[i] = \\'9\\';\\n            else curr[i] --;\\n            if (!vis.count(curr)) {\\n                vis.insert(curr);\\n                q.push(curr);\\n            }\\n            curr[i] = ori;\\n            \\n            if (curr[i] == \\'9\\') curr[i] = \\'0\\';\\n            else curr[i] ++;\\n            if (!vis.count(curr)) {\\n                vis.insert(curr);\\n                q.push(curr);\\n            }\\n            curr[i] = ori;\\n        }\\n    }\\n};\\n```\\n\\nwe know that the TC of most operations on `set` in C++ are `O(lg n)`, so my first improvement is simply replacing `set` with `unordered_set`.\\n\\n**Version 2**. `queue<string>` + `unordered_set<string>`: 128 ms, 34.7 MB\\nsimply replacing `set` with `unordered_set` in this problem results 3x fast in runtime\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        // BFS\\n        // |V| = 10000, |E| = 8 * 10000\\n        \\n        unordered_set<string> vis;\\n        for (auto& d : deadends) vis.insert(d);\\n        if (vis.count(\"0000\")) return -1;\\n        vis.insert(\"0000\");\\n        \\n        queue<string> q;\\n        q.push(\"0000\");\\n        \\n        int dist = -1;\\n        while (!q.empty()) {\\n            dist++;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                string& curr = q.front();\\n                if (curr == target) return dist;\\n                \\n                relax(curr, vis, q);\\n                \\n                q.pop();\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    void relax(string& curr, unordered_set<string>& vis, queue<string>& q) {\\n        for (int i = 0; i < 4; i++) {\\n            char ori = curr[i];\\n            if (curr[i] == \\'0\\') curr[i] = \\'9\\';\\n            else curr[i] --;\\n            if (!vis.count(curr)) {\\n                vis.insert(curr);\\n                q.push(curr);\\n            }\\n            curr[i] = ori;\\n            \\n            if (curr[i] == \\'9\\') curr[i] = \\'0\\';\\n            else curr[i] ++;\\n            if (!vis.count(curr)) {\\n                vis.insert(curr);\\n                q.push(curr);\\n            }\\n            curr[i] = ori;\\n        }\\n    }\\n};\\n```\\n\\nSince the lock has only 4 digits, if we view the password as an `int`, it surely fits in the range `[0, 10000)`. So my next improvement is to make `vis` a boolean array.\\n\\n**Version 3**. `queue<string>` + `bool[]`: 56 ms, 16.9 MB\\nthe improvement in both time and space are huge.\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        // BFS\\n        // |V| = 10000, |E| = 8 * 10000\\n        \\n        bool vis[10000] = {0};\\n        for (auto& d : deadends) vis[stoi(d)] = true;\\n        if (vis[0]) return -1;\\n        vis[0] = true;\\n        \\n        queue<string> q;\\n        q.push(\"0000\");\\n        \\n        int dist = -1;\\n        while (!q.empty()) {\\n            dist++;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                string& curr = q.front();\\n                if (curr == target) return dist;\\n                \\n                relax(curr, vis, q);\\n                \\n                q.pop();\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    void relax(string& curr, bool vis[], queue<string>& q) {\\n        for (int i = 0; i < 4; i++) {\\n            char ori = curr[i];\\n            if (curr[i] == \\'0\\') curr[i] = \\'9\\';\\n            else curr[i] --;\\n            int hash = stoi(curr);\\n            if (!vis[hash]) {\\n                vis[hash] = true;\\n                q.push(curr);\\n            }\\n            curr[i] = ori;\\n            \\n            if (curr[i] == \\'9\\') curr[i] = \\'0\\';\\n            else curr[i] ++;\\n            hash = stoi(curr);\\n            if (!vis[hash]) {\\n                vis[hash] = true;\\n                q.push(curr);\\n            }\\n            curr[i] = ori;\\n        }\\n    }\\n};\\n```\\n\\nwhat if we do the same trick on our queue?\\n\\n**Version 4**. `queue<int>` + `bool[]`: **12 ms**, **10.2 MB**\\nanother huge improvement.\\nyou should beware that the implementation of `relaxInt()` is a little bit more complicated than before. Basically it examine the current password (may have leading zeros) on its four digits.\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        // BFS\\n        // |V| = 10000, |E| = 8 * 10000\\n        \\n        bool vis[10000] = {0};\\n        for (auto& d : deadends) vis[stoi(d)] = true;\\n        if (vis[0]) return -1;\\n        vis[0] = true;\\n        \\n        queue<int> q;\\n        q.push(0);\\n        \\n        int tgt = stoi(target);\\n        \\n        int dist = -1;\\n        while (!q.empty()) {\\n            dist++;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                int curr = q.front();\\n                if (curr == tgt) return dist;\\n                \\n                relaxInt(curr, vis, q);\\n                \\n                q.pop();\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    void relaxInt(int curr, bool vis[], queue<int>& q) {\\n        int tmp = curr;\\n        int digit = curr;\\n        int pow10 = 1;\\n        for (int i = 0; i < 4; i++) {\\n            int ori = digit % 10;\\n            digit /= 10;\\n            \\n            if (ori == 0) tmp += 9 * pow10;\\n            else tmp -= 1 * pow10;\\n            if (!vis[tmp]) {\\n                vis[tmp] = true;\\n                q.push(tmp);\\n            }\\n            tmp = curr;\\n            \\n            if (ori == 9) tmp -= 9 * pow10;\\n            else tmp += 1 * pow10;\\n            if (!vis[tmp]) {\\n                vis[tmp] = true;\\n                q.push(tmp);\\n            }\\n            tmp = curr;\\n            \\n            pow10 *= 10;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        // BFS\\n        // |V| = 10000, |E| = 8 * 10000\\n        \\n        set<string> vis;\\n        for (auto& d : deadends) vis.insert(d);\\n        if (vis.count(\"0000\")) return -1;\\n        vis.insert(\"0000\");\\n        \\n        queue<string> q;\\n        q.push(\"0000\");\\n        \\n        int dist = -1;\\n        while (!q.empty()) {\\n            dist++;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                string& curr = q.front();\\n                if (curr == target) return dist;\\n                \\n                relax(curr, vis, q);\\n                \\n                q.pop();\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    void relax(string& curr, set<string>& vis, queue<string>& q) {\\n        for (int i = 0; i < 4; i++) {\\n            char ori = curr[i];\\n            if (curr[i] == \\'0\\') curr[i] = \\'9\\';\\n            else curr[i] --;\\n            if (!vis.count(curr)) {\\n                vis.insert(curr);\\n                q.push(curr);\\n            }\\n            curr[i] = ori;\\n            \\n            if (curr[i] == \\'9\\') curr[i] = \\'0\\';\\n            else curr[i] ++;\\n            if (!vis.count(curr)) {\\n                vis.insert(curr);\\n                q.push(curr);\\n            }\\n            curr[i] = ori;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        // BFS\\n        // |V| = 10000, |E| = 8 * 10000\\n        \\n        unordered_set<string> vis;\\n        for (auto& d : deadends) vis.insert(d);\\n        if (vis.count(\"0000\")) return -1;\\n        vis.insert(\"0000\");\\n        \\n        queue<string> q;\\n        q.push(\"0000\");\\n        \\n        int dist = -1;\\n        while (!q.empty()) {\\n            dist++;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                string& curr = q.front();\\n                if (curr == target) return dist;\\n                \\n                relax(curr, vis, q);\\n                \\n                q.pop();\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    void relax(string& curr, unordered_set<string>& vis, queue<string>& q) {\\n        for (int i = 0; i < 4; i++) {\\n            char ori = curr[i];\\n            if (curr[i] == \\'0\\') curr[i] = \\'9\\';\\n            else curr[i] --;\\n            if (!vis.count(curr)) {\\n                vis.insert(curr);\\n                q.push(curr);\\n            }\\n            curr[i] = ori;\\n            \\n            if (curr[i] == \\'9\\') curr[i] = \\'0\\';\\n            else curr[i] ++;\\n            if (!vis.count(curr)) {\\n                vis.insert(curr);\\n                q.push(curr);\\n            }\\n            curr[i] = ori;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        // BFS\\n        // |V| = 10000, |E| = 8 * 10000\\n        \\n        bool vis[10000] = {0};\\n        for (auto& d : deadends) vis[stoi(d)] = true;\\n        if (vis[0]) return -1;\\n        vis[0] = true;\\n        \\n        queue<string> q;\\n        q.push(\"0000\");\\n        \\n        int dist = -1;\\n        while (!q.empty()) {\\n            dist++;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                string& curr = q.front();\\n                if (curr == target) return dist;\\n                \\n                relax(curr, vis, q);\\n                \\n                q.pop();\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    void relax(string& curr, bool vis[], queue<string>& q) {\\n        for (int i = 0; i < 4; i++) {\\n            char ori = curr[i];\\n            if (curr[i] == \\'0\\') curr[i] = \\'9\\';\\n            else curr[i] --;\\n            int hash = stoi(curr);\\n            if (!vis[hash]) {\\n                vis[hash] = true;\\n                q.push(curr);\\n            }\\n            curr[i] = ori;\\n            \\n            if (curr[i] == \\'9\\') curr[i] = \\'0\\';\\n            else curr[i] ++;\\n            hash = stoi(curr);\\n            if (!vis[hash]) {\\n                vis[hash] = true;\\n                q.push(curr);\\n            }\\n            curr[i] = ori;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        // BFS\\n        // |V| = 10000, |E| = 8 * 10000\\n        \\n        bool vis[10000] = {0};\\n        for (auto& d : deadends) vis[stoi(d)] = true;\\n        if (vis[0]) return -1;\\n        vis[0] = true;\\n        \\n        queue<int> q;\\n        q.push(0);\\n        \\n        int tgt = stoi(target);\\n        \\n        int dist = -1;\\n        while (!q.empty()) {\\n            dist++;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                int curr = q.front();\\n                if (curr == tgt) return dist;\\n                \\n                relaxInt(curr, vis, q);\\n                \\n                q.pop();\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    void relaxInt(int curr, bool vis[], queue<int>& q) {\\n        int tmp = curr;\\n        int digit = curr;\\n        int pow10 = 1;\\n        for (int i = 0; i < 4; i++) {\\n            int ori = digit % 10;\\n            digit /= 10;\\n            \\n            if (ori == 0) tmp += 9 * pow10;\\n            else tmp -= 1 * pow10;\\n            if (!vis[tmp]) {\\n                vis[tmp] = true;\\n                q.push(tmp);\\n            }\\n            tmp = curr;\\n            \\n            if (ori == 9) tmp -= 9 * pow10;\\n            else tmp += 1 * pow10;\\n            if (!vis[tmp]) {\\n                vis[tmp] = true;\\n                q.push(tmp);\\n            }\\n            tmp = curr;\\n            \\n            pow10 *= 10;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790176,
                "title": "python-3-bfs-explanation",
                "content": "* We can think of this problem as a network where we are always starting from node `\\'0000\\'` and want to reach the `target` node.\\n* All nodes are connected by the rule: We can only increment or decrement one of the four values in one \\'operation\\'.\\n\\t* So node `\\'0000\\'`\\'s neighbours (or `nextCombinations`) are the list: `[\\'1000\\', \\'9000\\', \\'0100\\', \\'0900\\', \\'0010\\', \\'0090\\', \\'0001\\', \\'0009\\']`.\\n* In a search problem like this, we can traverse the search space using BFS.\\n* Let\\'s split this problem up into two parts:\\n\\n## Getting the neighbours of the current \\'node\\'\\n* Think of each combination of four numbers as a node in a network.\\n* To get the neighbours for every node, we need to iterate over the `combination` string and do the following:\\n* Increment and decrement each of the four values by one in the `combination` string.\\n* E.g. If `combination = \\'0937\\'` then its `nextCombinations` (i.e. all the possible `combination`s we can make from this combination) are: `[\\'1937\\', \\'9937\\', \\'0037\\', \\'0837\\', \\'0947\\', \\'0927\\', \\'0938\\', \\'0936\\']`.\\n\\n## Performing the BFS\\n* Keep track of the `deadends` and `seen` nodes as `Set`s for constant time lookups.\\n* Build a `deque` for constant time `leftpop`s and `append`s.\\n* The `queue` will keep track of **both** the combination and the depth, or rather, \\'number of rotations of the combination lock\\', to reach the current node.\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    \\n    def getNextCombinations(self, combination: str) -> List[str]:\\n        nextCombinations = []\\n        \\n        for i, value in enumerate(combination):\\n            for valueDifference in (-1, 1):\\n                rotatedValue = (int(value) + valueDifference) % 10\\n                \\n                nextCombinations.append(combination[:i] + str(rotatedValue) + combination[i + 1:])\\n            \\n        return nextCombinations\\n    \\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        deadEnds = set(deadends)\\n        queue = deque([(\\'0000\\', 0)])\\n        seen = {\\'0000\\'}\\n        \\n\\t\\t# Keep searching while there are still valid paths.\\n        while queue:\\n            combination, depth = queue.popleft()\\n            \\n\\t\\t\\t# We\\'ve found our target.\\n            if combination == target:\\n                return depth\\n            \\n\\t\\t\\t# We\\'ve hit a dead end and terminate searching from this node.\\n            if combination in deadEnds:\\n                continue\\n                \\n\\t\\t\\t# Get the nodes connected to the current node.\\n            for nextCombination in self.getNextCombinations(combination):\\n\\t\\t\\t\\t# If we\\'ve not visited the node before, then add it to the queue to perform BFS on again.\\n                if nextCombination not in seen:\\n                    seen.add(nextCombination)\\n                    queue.append((nextCombination, depth + 1))\\n                    \\n\\t\\t# We searched all valid routes but could not get to the target.\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    \\n    def getNextCombinations(self, combination: str) -> List[str]:\\n        nextCombinations = []\\n        \\n        for i, value in enumerate(combination):\\n            for valueDifference in (-1, 1):\\n                rotatedValue = (int(value) + valueDifference) % 10\\n                \\n                nextCombinations.append(combination[:i] + str(rotatedValue) + combination[i + 1:])\\n            \\n        return nextCombinations\\n    \\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        deadEnds = set(deadends)\\n        queue = deque([(\\'0000\\', 0)])\\n        seen = {\\'0000\\'}\\n        \\n\\t\\t# Keep searching while there are still valid paths.\\n        while queue:\\n            combination, depth = queue.popleft()\\n            \\n\\t\\t\\t# We\\'ve found our target.\\n            if combination == target:\\n                return depth\\n            \\n\\t\\t\\t# We\\'ve hit a dead end and terminate searching from this node.\\n            if combination in deadEnds:\\n                continue\\n                \\n\\t\\t\\t# Get the nodes connected to the current node.\\n            for nextCombination in self.getNextCombinations(combination):\\n\\t\\t\\t\\t# If we\\'ve not visited the node before, then add it to the queue to perform BFS on again.\\n                if nextCombination not in seen:\\n                    seen.add(nextCombination)\\n                    queue.append((nextCombination, depth + 1))\\n                    \\n\\t\\t# We searched all valid routes but could not get to the target.\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552332,
                "title": "c-bfs",
                "content": "Just like other BFS solutions, but manipulating numbers instead of strings for the performance.\\n```cpp\\nint openLock(vector<string>& deadends, string target) {\\n    bool dp[10000] = {};\\n    for (auto &de : deadends)\\n        dp[stoi(de)] = true;\\n    if (dp[0])\\n        return -1;\\n    int res = 0, t = stoi(target);\\n    vector<int> q{0};\\n    while (!q.empty()) {\\n        vector<int> q1;\\n        for (auto dd : q) {\\n            if (dd == t)\\n                return res;\\n            for (auto p = 1; p < 10000; p *= 10) {\\n                auto d = dd / p % 10;\\n                for (auto dir = -1; dir <= 1; dir += 2) {\\n                    auto new_dd = dd - d * p + (10 + d + dir) % 10 * p;\\n                    if (!dp[new_dd]) {\\n                        dp[new_dd] = true;\\n                        q1.push_back(new_dd);\\n                    }\\n                }\\n            }\\n        }\\n        ++res;\\n        swap(q, q1);\\n    }\\n    return -1;\\n}\\n```\\nIf you want to know the path, we need to store distance for each combination from `0000`, and then do the backtracking. The following sample code outputs the path:\\n```cpp\\nint openLock(vector<string>& deadends, string target) {\\n    int dp[10000] = {};\\n    for (auto &de : deadends)\\n        dp[stoi(de)] = INT_MAX;\\n    if (dp[0])\\n        return -1;\\n    int res = 1, t = stoi(target);\\n    vector<int> q{0};\\n    while (!q.empty()) {\\n        vector<int> q1;\\n        for (auto dd : q) {\\n            if (dd == t) {\\n                for (int step = dp[dd]; step > 0; --step) {\\n                    for (auto p = 1; p < 10000 && dp[dd] == step; p *= 10) {\\n                        auto d = dd / p % 10;\\n                        for (auto dir = -1; dir <= 1; dir += 2) {\\n                            auto new_dd = dd - d * p + (10 + d + dir) % 10 * p;\\n                            if (dp[new_dd] == step - 1) {\\n                                dd = new_dd;\\n                                cout << setfill(\\'0\\') << setw(4) << dd << endl;\\n                                break;\\n                            }\\n                        }\\n                    }                    \\n                }\\n                return res - 1;\\n            }\\n            for (auto p = 1; p < 10000; p *= 10) {\\n                auto d = dd / p % 10;\\n                for (auto dir = -1; dir <= 1; dir += 2) {\\n                    auto new_dd = dd - d * p + (10 + d + dir) % 10 * p;\\n                    if (dp[new_dd] == 0) {\\n                        dp[new_dd] = res;\\n                        q1.push_back(new_dd);\\n                    }\\n                }\\n            }\\n        }\\n        ++res;\\n        swap(q, q1);\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint openLock(vector<string>& deadends, string target) {\\n    bool dp[10000] = {};\\n    for (auto &de : deadends)\\n        dp[stoi(de)] = true;\\n    if (dp[0])\\n        return -1;\\n    int res = 0, t = stoi(target);\\n    vector<int> q{0};\\n    while (!q.empty()) {\\n        vector<int> q1;\\n        for (auto dd : q) {\\n            if (dd == t)\\n                return res;\\n            for (auto p = 1; p < 10000; p *= 10) {\\n                auto d = dd / p % 10;\\n                for (auto dir = -1; dir <= 1; dir += 2) {\\n                    auto new_dd = dd - d * p + (10 + d + dir) % 10 * p;\\n                    if (!dp[new_dd]) {\\n                        dp[new_dd] = true;\\n                        q1.push_back(new_dd);\\n                    }\\n                }\\n            }\\n        }\\n        ++res;\\n        swap(q, q1);\\n    }\\n    return -1;\\n}\\n```\n```cpp\\nint openLock(vector<string>& deadends, string target) {\\n    int dp[10000] = {};\\n    for (auto &de : deadends)\\n        dp[stoi(de)] = INT_MAX;\\n    if (dp[0])\\n        return -1;\\n    int res = 1, t = stoi(target);\\n    vector<int> q{0};\\n    while (!q.empty()) {\\n        vector<int> q1;\\n        for (auto dd : q) {\\n            if (dd == t) {\\n                for (int step = dp[dd]; step > 0; --step) {\\n                    for (auto p = 1; p < 10000 && dp[dd] == step; p *= 10) {\\n                        auto d = dd / p % 10;\\n                        for (auto dir = -1; dir <= 1; dir += 2) {\\n                            auto new_dd = dd - d * p + (10 + d + dir) % 10 * p;\\n                            if (dp[new_dd] == step - 1) {\\n                                dd = new_dd;\\n                                cout << setfill(\\'0\\') << setw(4) << dd << endl;\\n                                break;\\n                            }\\n                        }\\n                    }                    \\n                }\\n                return res - 1;\\n            }\\n            for (auto p = 1; p < 10000; p *= 10) {\\n                auto d = dd / p % 10;\\n                for (auto dir = -1; dir <= 1; dir += 2) {\\n                    auto new_dd = dd - d * p + (10 + d + dir) % 10 * p;\\n                    if (dp[new_dd] == 0) {\\n                        dp[new_dd] = res;\\n                        q1.push_back(new_dd);\\n                    }\\n                }\\n            }\\n        }\\n        ++res;\\n        swap(q, q1);\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2932467,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        vector<vector<int>> g = {\\n            {9, 1}, {0, 2}, {1, 3}, {2, 4}, {3, 5}, {4, 6}, {5, 7}, {6, 8}, {7, 9}, {8, 0}\\n        };\\n        unordered_map<string, int> mp, vis;\\n        for(auto x: deadends) mp[x] = 1;\\n        string start = \"0000\";\\n        if(mp[start]) return -1;\\n        queue<string> q;\\n        q.push(start);\\n        vis[start] = 1;\\n        int ans = 0;\\n        while(!q.empty()) {\\n            int len = q.size();\\n            while(len--) {\\n                string u = q.front();\\n                q.pop();\\n                if(u == target) {\\n                    return ans;\\n                }\\n                for(int i=0; i<4; i++) {\\n                    for(auto c: g[u[i] - \\'0\\']) {\\n                        string v = u;\\n                        v[i] = c + \\'0\\';\\n                        if(!vis[v] and !mp[v]) {\\n                            q.push(v);\\n                            vis[v] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        vector<vector<int>> g = {\\n            {9, 1}, {0, 2}, {1, 3}, {2, 4}, {3, 5}, {4, 6}, {5, 7}, {6, 8}, {7, 9}, {8, 0}\\n        };\\n        unordered_map<string, int> mp, vis;\\n        for(auto x: deadends) mp[x] = 1;\\n        string start = \"0000\";\\n        if(mp[start]) return -1;\\n        queue<string> q;\\n        q.push(start);\\n        vis[start] = 1;\\n        int ans = 0;\\n        while(!q.empty()) {\\n            int len = q.size();\\n            while(len--) {\\n                string u = q.front();\\n                q.pop();\\n                if(u == target) {\\n                    return ans;\\n                }\\n                for(int i=0; i<4; i++) {\\n                    for(auto c: g[u[i] - \\'0\\']) {\\n                        string v = u;\\n                        v[i] = c + \\'0\\';\\n                        if(!vis[v] and !mp[v]) {\\n                            q.push(v);\\n                            vis[v] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255272,
                "title": "easy-to-understand-java-solution-explanation-with-comments-with-bfs",
                "content": "```\\nclass Solution {\\n    \\n    public int openLock(String[] deadends, String target) {\\n        \\n        \\n        String start = \"0000\";  // lock starts at 0000\\n        \\n        /*  We will use set to store the deadends.\\n            We can check if any possibility is a deadend or not. */\\n        \\n        Set<String> dead = new HashSet<>();\\n        for (String str : deadends) {\\n            dead.add(str);\\n        } \\n        \\n        /* Base Cases */\\n        \\n        if (dead.contains(start)) {\\n            return -1;   // If start point is itself a dead end, it is not possible.\\n        }\\n        \\n        if (target.equals(start)) {\\n            return 0;   // If start point is itself the target, moves required are 0\\n        }\\n        \\n        /* Actual Implementation */\\n        \\n        Set<String> visited = new HashSet<>();  // for tracking the visited permutations\\n        Queue<String> q = new LinkedList<>();   // for tracking non-visited && non-deadends permutations\\n        \\n        q.add(start);  // Initialize queue with start {0000}\\n        \\n        \\n        /* Loop moves will be incremented after all permutations of queue size are done.\\n            \\n            eg: move = 0  : queue = {0000}                     q.size() = 1\\n                move = 1  : queue = {0001, 0010, ,0900, 9000}  q.size() <= 8  \\n                move = 2  : queue = {0002, 0020, ,0901, 8000}  q.size() <= 8*8 (some moves may be deadlock or visited)\\n                move = 3  : queue = {0012, 0030, ,0911, 8100}  q.size() <= 8*8*8   ... and so on\\n                \\n                So, at any point, (moves = diff. of digits from start)\\n                eg: 0000  -> {0012, 0030, ,0911, 8100} => move = 3\\n        */\\n\\n        for (int moves = 1; !q.isEmpty(); moves++) {\\n            \\n            /* Check for all elements in the queue having 1 digit difference than previous\\n               (all others are done in previous loop) */\\n            \\n            for (int n = q.size(); n > 0; n--) {\\n                \\n                // Fetch curr element in queue, and check for its 8 possible moves\\n                String curr = q.poll();\\n                \\n                /*  Consider 8 possible moves from the curr position\\n        \\n                    Eg: From { 0 0 0 0}\\n                    Below are the 8 possible moves =>\\n            \\n                    0001  0010  0100  1000   (scroll the lock number downwards for each pos)\\n                    0009  0090  0900  9000   (scroll the lock number upwards for each pos)\\n        \\n                */\\n                \\n                for (int i=0; i<4; i++) {\\n                    \\n                    // Moves from scrolling the lock down and up\\n                    char[] down = curr.toCharArray();\\n                    char[] up = curr.toCharArray();\\n                    \\n                    down[i] = (char) ((down[i] - \\'0\\' + 1) % 10 + \\'0\\');\\n                    up[i] = (char) ((up[i] - \\'0\\' + 9) % 10 + \\'0\\');\\n                    \\n                    String downStr = new String(down);\\n                    String upStr = new String(up);\\n                    \\n                    /* Check scenarios for the updated permutation moves of string */\\n                    \\n                    if (target.equals(downStr) || target.equals(upStr)) {\\n                        return moves;  // reached till the target, return curr no. of moves\\n                    }\\n                    \\n                    // If identified permutation NOT visited and NOT deadEnd, add in queue for further research\\n                    \\n                    if (!dead.contains(downStr) && !visited.contains(downStr)) {\\n                        q.add(downStr);\\n                    }\\n                    visited.add(downStr);  // mark the permutation as visited now.\\n                    \\n                    if (!dead.contains(upStr) && !visited.contains(upStr)) {\\n                        q.add(upStr);\\n                    }\\n                    visited.add(upStr);  // mark the permutation as visited now.\\n                    \\n                }\\n                \\n                \\n            }\\n            \\n            \\n        }\\n\\n        return -1;\\n        \\n    }\\n}\\n```\\n\\n**Please Upvote if you find it helpful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int openLock(String[] deadends, String target) {\\n        \\n        \\n        String start = \"0000\";  // lock starts at 0000\\n        \\n        /*  We will use set to store the deadends.\\n            We can check if any possibility is a deadend or not. */\\n        \\n        Set<String> dead = new HashSet<>();\\n        for (String str : deadends) {\\n            dead.add(str);\\n        } \\n        \\n        /* Base Cases */\\n        \\n        if (dead.contains(start)) {\\n            return -1;   // If start point is itself a dead end, it is not possible.\\n        }\\n        \\n        if (target.equals(start)) {\\n            return 0;   // If start point is itself the target, moves required are 0\\n        }\\n        \\n        /* Actual Implementation */\\n        \\n        Set<String> visited = new HashSet<>();  // for tracking the visited permutations\\n        Queue<String> q = new LinkedList<>();   // for tracking non-visited && non-deadends permutations\\n        \\n        q.add(start);  // Initialize queue with start {0000}\\n        \\n        \\n        /* Loop moves will be incremented after all permutations of queue size are done.\\n            \\n            eg: move = 0  : queue = {0000}                     q.size() = 1\\n                move = 1  : queue = {0001, 0010, ,0900, 9000}  q.size() <= 8  \\n                move = 2  : queue = {0002, 0020, ,0901, 8000}  q.size() <= 8*8 (some moves may be deadlock or visited)\\n                move = 3  : queue = {0012, 0030, ,0911, 8100}  q.size() <= 8*8*8   ... and so on\\n                \\n                So, at any point, (moves = diff. of digits from start)\\n                eg: 0000  -> {0012, 0030, ,0911, 8100} => move = 3\\n        */\\n\\n        for (int moves = 1; !q.isEmpty(); moves++) {\\n            \\n            /* Check for all elements in the queue having 1 digit difference than previous\\n               (all others are done in previous loop) */\\n            \\n            for (int n = q.size(); n > 0; n--) {\\n                \\n                // Fetch curr element in queue, and check for its 8 possible moves\\n                String curr = q.poll();\\n                \\n                /*  Consider 8 possible moves from the curr position\\n        \\n                    Eg: From { 0 0 0 0}\\n                    Below are the 8 possible moves =>\\n            \\n                    0001  0010  0100  1000   (scroll the lock number downwards for each pos)\\n                    0009  0090  0900  9000   (scroll the lock number upwards for each pos)\\n        \\n                */\\n                \\n                for (int i=0; i<4; i++) {\\n                    \\n                    // Moves from scrolling the lock down and up\\n                    char[] down = curr.toCharArray();\\n                    char[] up = curr.toCharArray();\\n                    \\n                    down[i] = (char) ((down[i] - \\'0\\' + 1) % 10 + \\'0\\');\\n                    up[i] = (char) ((up[i] - \\'0\\' + 9) % 10 + \\'0\\');\\n                    \\n                    String downStr = new String(down);\\n                    String upStr = new String(up);\\n                    \\n                    /* Check scenarios for the updated permutation moves of string */\\n                    \\n                    if (target.equals(downStr) || target.equals(upStr)) {\\n                        return moves;  // reached till the target, return curr no. of moves\\n                    }\\n                    \\n                    // If identified permutation NOT visited and NOT deadEnd, add in queue for further research\\n                    \\n                    if (!dead.contains(downStr) && !visited.contains(downStr)) {\\n                        q.add(downStr);\\n                    }\\n                    visited.add(downStr);  // mark the permutation as visited now.\\n                    \\n                    if (!dead.contains(upStr) && !visited.contains(upStr)) {\\n                        q.add(upStr);\\n                    }\\n                    visited.add(upStr);  // mark the permutation as visited now.\\n                    \\n                }\\n                \\n                \\n            }\\n            \\n            \\n        }\\n\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753247,
                "title": "python-bfs-concise-easy-to-read",
                "content": "```\\ndef openLock(self, deadends: List[str], target: str) -> int:\\n        def neighbors(s):\\n            for i in range(4):\\n                for n in (1, -1):\\n                    yield s[:i] + str((int(s[i]) + n) % 10) + s[i + 1:]\\n            \\n        de = set(deadends)\\n        if \\'0000\\' in de: return -1\\n        \\n        q = deque([(\\'0000\\', 0)])\\n        vis = set()\\n        \\n        while q:\\n            s, d = q.popleft()\\n            if s == target: return d\\n            \\n            for nei in neighbors(s):\\n                if nei not in vis and nei not in de:\\n                    vis.add(nei)\\n                    q.append((nei, d + 1))\\n                        \\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef openLock(self, deadends: List[str], target: str) -> int:\\n        def neighbors(s):\\n            for i in range(4):\\n                for n in (1, -1):\\n                    yield s[:i] + str((int(s[i]) + n) % 10) + s[i + 1:]\\n            \\n        de = set(deadends)\\n        if \\'0000\\' in de: return -1\\n        \\n        q = deque([(\\'0000\\', 0)])\\n        vis = set()\\n        \\n        while q:\\n            s, d = q.popleft()\\n            if s == target: return d\\n            \\n            for nei in neighbors(s):\\n                if nei not in vis and nei not in de:\\n                    vis.add(nei)\\n                    q.append((nei, d + 1))\\n                        \\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 603062,
                "title": "python-oop-bidirectional-search-98-time",
                "content": "```\\nnxt = {str(i):str( (i+1) % 10) for i in range(10)}\\nprev = {str( (i+1) % 10):str(i) for i in range(10)}\\n\\ndef neighbours( n: str ):\\n    for i in range(len(n)):\\n        yield f\"{n[:i]}{nxt[n[i]]}{n[i+1:]}\"\\n        yield f\"{n[:i]}{prev[n[i]]}{n[i+1:]}\"\\n\\n        \\nclass Search:\\n    def __init__(self, comb, deadends):\\n        self.d = 0\\n        self.combs = {comb}\\n        self.seen = set(deadends)\\n        \\n    def expand(self):\\n        new_circle = set()\\n        self.d += 1\\n        for c in self.combs:\\n            self.seen.add(c)\\n            for n in neighbours(c):\\n                if n not in self.seen:\\n                    new_circle.add(n)\\n                        \\n        self.combs = new_circle\\n        \\n        \\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        START = \\'0000\\'\\n        if target == START: return 0\\n        if START in deadends: return -1\\n        \\n        s1 = Search(START, deadends)\\n        s2 = Search(target, deadends)\\n        while s1.combs and s2.combs:\\n            s1.expand()\\n            if s1.combs & s2.combs:\\n                return s1.d + s2.d\\n            s2.expand()\\n            if s1.combs & s2.combs:\\n                return s1.d + s2.d\\n                        \\n        return -1\\n```\\n            \\n",
                "solutionTags": [],
                "code": "```\\nnxt = {str(i):str( (i+1) % 10) for i in range(10)}\\nprev = {str( (i+1) % 10):str(i) for i in range(10)}\\n\\ndef neighbours( n: str ):\\n    for i in range(len(n)):\\n        yield f\"{n[:i]}{nxt[n[i]]}{n[i+1:]}\"\\n        yield f\"{n[:i]}{prev[n[i]]}{n[i+1:]}\"\\n\\n        \\nclass Search:\\n    def __init__(self, comb, deadends):\\n        self.d = 0\\n        self.combs = {comb}\\n        self.seen = set(deadends)\\n        \\n    def expand(self):\\n        new_circle = set()\\n        self.d += 1\\n        for c in self.combs:\\n            self.seen.add(c)\\n            for n in neighbours(c):\\n                if n not in self.seen:\\n                    new_circle.add(n)\\n                        \\n        self.combs = new_circle\\n        \\n        \\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        START = \\'0000\\'\\n        if target == START: return 0\\n        if START in deadends: return -1\\n        \\n        s1 = Search(START, deadends)\\n        s2 = Search(target, deadends)\\n        while s1.combs and s2.combs:\\n            s1.expand()\\n            if s1.combs & s2.combs:\\n                return s1.d + s2.d\\n            s2.expand()\\n            if s1.combs & s2.combs:\\n                return s1.d + s2.d\\n                        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597403,
                "title": "readable-java-solution-bfs",
                "content": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> deadSet = new HashSet<>();\\n        for(String str : deadends) deadSet.add(str);\\n        Set<String> visited = new HashSet<>();\\n        \\n        Queue<String> que = new LinkedList<>();\\n        que.add(\"0000\");\\n        int dep = 0;\\n        while(!que.isEmpty()) {\\n            int queSize = que.size();\\n            for(int i = 0; i < queSize; i++) {\\n                String cur = que.poll();\\n                if(deadSet.contains(cur) || visited.contains(cur)) continue;\\n                if(cur.equals(target)) return dep;\\n                for(int j = 0; j < 4; j++) {\\n                    int next = (cur.charAt(j) - \\'0\\' + 1) % 10;\\n                    int prev = (10 + cur.charAt(j) - \\'0\\' - 1) % 10;\\n                    que.offer(cur.substring(0,j) + next + cur.substring(j + 1));\\n                    que.offer(cur.substring(0,j) + prev + cur.substring(j + 1));\\n                }\\n                visited.add(cur);\\n            }\\n            dep++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nUse BFS to generate all the wheels permutation in inner for loop and add them all to the queue. Outer loop keeps track and increment the BFS depth. BFS depth is the answer to this problem.",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> deadSet = new HashSet<>();\\n        for(String str : deadends) deadSet.add(str);\\n        Set<String> visited = new HashSet<>();\\n        \\n        Queue<String> que = new LinkedList<>();\\n        que.add(\"0000\");\\n        int dep = 0;\\n        while(!que.isEmpty()) {\\n            int queSize = que.size();\\n            for(int i = 0; i < queSize; i++) {\\n                String cur = que.poll();\\n                if(deadSet.contains(cur) || visited.contains(cur)) continue;\\n                if(cur.equals(target)) return dep;\\n                for(int j = 0; j < 4; j++) {\\n                    int next = (cur.charAt(j) - \\'0\\' + 1) % 10;\\n                    int prev = (10 + cur.charAt(j) - \\'0\\' - 1) % 10;\\n                    que.offer(cur.substring(0,j) + next + cur.substring(j + 1));\\n                    que.offer(cur.substring(0,j) + prev + cur.substring(j + 1));\\n                }\\n                visited.add(cur);\\n            }\\n            dep++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583391,
                "title": "clean-python-bfs",
                "content": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        if target == \\'0000\\':\\n            return 0\\n        \\n        visited = set(deadends)\\n        \\n        steps = 0\\n        queue = deque()\\n        queue.append(\"0000\")\\n        \\n        while queue:\\n            for _ in range(len(queue)):\\n                nums = queue.popleft()\\n                if nums == target:\\n                    return steps\\n                \\n                if nums in visited:\\n                    continue\\n                visited.add(nums)\\n                \\n                for idx in range(4):\\n                    num = int(nums[idx])\\n                    next_num = (num + 10 + 1) % 10\\n                    prev_num = (num + 10 - 1) % 10\\n                    \\n                    queue.append(nums[:idx] + str(prev_num) + nums[idx + 1:])\\n                    queue.append(nums[:idx] + str(next_num) + nums[idx + 1:])\\n            steps += 1\\n            \\n        return -1\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        if target == \\'0000\\':\\n            return 0\\n        \\n        visited = set(deadends)\\n        \\n        steps = 0\\n        queue = deque()\\n        queue.append(\"0000\")\\n        \\n        while queue:\\n            for _ in range(len(queue)):\\n                nums = queue.popleft()\\n                if nums == target:\\n                    return steps\\n                \\n                if nums in visited:\\n                    continue\\n                visited.add(nums)\\n                \\n                for idx in range(4):\\n                    num = int(nums[idx])\\n                    next_num = (num + 10 + 1) % 10\\n                    prev_num = (num + 10 - 1) % 10\\n                    \\n                    queue.append(nums[:idx] + str(prev_num) + nums[idx + 1:])\\n                    queue.append(nums[:idx] + str(next_num) + nums[idx + 1:])\\n            steps += 1\\n            \\n        return -1\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1097592,
                "title": "cleanest-most-concise-c-solution-bfs-unordered-set",
                "content": "```\\nint openLock(vector<string>& deadends, string target) {\\n        \\n        queue<string> q; q.push(\"0000\");\\n        unordered_set<string> vis(deadends.begin(), deadends.end());\\n        int lvl = 0;\\n        \\n        while(!q.empty()) {\\n            \\n            int sz = q.size();\\n            while(sz--) {\\n                \\n                string s = q.front(); q.pop();\\n                if(s == target) return lvl;\\n                if(vis.count(s)) continue;\\n                vis.insert(s);\\n                \\n                for(int j = 0 ; j < 4 ; j++) {\\n                    \\n                    string t = s;\\n                    int n1 = t[j] - \\'0\\' + 1;\\n                    int n2 = t[j] - \\'0\\' - 1;\\n                    \\n                    if(n2 < 0) n2 = n2 + 10;\\n                    n1 = n1%10, n2 = n2%10;\\n                    \\n                    t[j] = n1 + \\'0\\', q.push(t);\\n                    t[j] = n2 + \\'0\\', q.push(t);\\n                    \\n                }\\n            }\\n            lvl++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint openLock(vector<string>& deadends, string target) {\\n        \\n        queue<string> q; q.push(\"0000\");\\n        unordered_set<string> vis(deadends.begin(), deadends.end());\\n        int lvl = 0;\\n        \\n        while(!q.empty()) {\\n            \\n            int sz = q.size();\\n            while(sz--) {\\n                \\n                string s = q.front(); q.pop();\\n                if(s == target) return lvl;\\n                if(vis.count(s)) continue;\\n                vis.insert(s);\\n                \\n                for(int j = 0 ; j < 4 ; j++) {\\n                    \\n                    string t = s;\\n                    int n1 = t[j] - \\'0\\' + 1;\\n                    int n2 = t[j] - \\'0\\' - 1;\\n                    \\n                    if(n2 < 0) n2 = n2 + 10;\\n                    n1 = n1%10, n2 = n2%10;\\n                    \\n                    t[j] = n1 + \\'0\\', q.push(t);\\n                    t[j] = n2 + \\'0\\', q.push(t);\\n                    \\n                }\\n            }\\n            lvl++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 880951,
                "title": "c-bfs-explanation-with-paint-d-pictures",
                "content": "**BFS Solution**\\n\\nSince there is no brute force solution, my initial solution is basically trying each lock state one by one by using the BFS algorithm and then checking if we are able to reach the target state. There is also one case that we should take care of: if the newly explored state is in the deadends states, then we can\\u2019t go over that state. You can also think of these states as a graph node, this problem is very similar to shortest path problem, finding a target node in a graph where the graph has some dead-end nodes basically if we can reach out to the target node by counting the steps we can find the answer. We can find each state by adding and subtracting \\u201C1\\u201D to each digit of the current state from left to right (It does not matter where we start from). Please see the following image to understand how we explore new states;\\n\\n![image](https://assets.leetcode.com/users/images/34621845-1d47-4ad5-a2d3-87f25500b5e7_1602354020.2690804.png)\\n\\nWe can even shrink the space of the problem to a lock in front of you with 1 circular wheel, just to understand the process easily. Let\\'s assume that we have the lock that has only one digit just for now;\\n\\n![image](https://assets.leetcode.com/users/images/7103423f-648c-4ce0-bb17-cd3d71606620_1602354910.327869.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string> &deadends, string target) {\\n        unordered_set<string> deadendsSet(deadends.begin(), deadends.end());\\n        unordered_set<string> visited;\\n        int result = 0;\\n        if (deadendsSet.find(\"0000\") != deadendsSet.end()) {\\n            return -1;\\n        }\\n        queue<string> wheelQueue;\\n        wheelQueue.push(\"0000\");\\n        visited.insert(\"0000\");\\n        while (!wheelQueue.empty()) {\\n            int levelSize = wheelQueue.size();\\n            while (levelSize--) {\\n                string up, down, currentWheel = wheelQueue.front();\\n                wheelQueue.pop();\\n                if (currentWheel == target) {\\n                    return result;\\n                }\\n                for (int i = 0; i < 4; i++) {\\n                    down = up = currentWheel;\\n                    char upCh = up[i], downCh = down[i];\\n                    up[i] = (upCh == \\'9\\' ? \\'0\\' : upCh + 1);\\n                    down[i] = (downCh == \\'0\\' ? \\'9\\' : downCh - 1);\\n                    if (visited.find(up) == visited.end() && deadendsSet.find(up) == deadendsSet.end()) {\\n                        wheelQueue.push(up);\\n                        visited.insert(up);\\n                    }\\n                    if (visited.find(down) == visited.end() && deadendsSet.find(down) == deadendsSet.end()) {\\n                        wheelQueue.push(down);\\n                        visited.insert(down);\\n                    }\\n                }\\n            }\\n            result++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string> &deadends, string target) {\\n        unordered_set<string> deadendsSet(deadends.begin(), deadends.end());\\n        unordered_set<string> visited;\\n        int result = 0;\\n        if (deadendsSet.find(\"0000\") != deadendsSet.end()) {\\n            return -1;\\n        }\\n        queue<string> wheelQueue;\\n        wheelQueue.push(\"0000\");\\n        visited.insert(\"0000\");\\n        while (!wheelQueue.empty()) {\\n            int levelSize = wheelQueue.size();\\n            while (levelSize--) {\\n                string up, down, currentWheel = wheelQueue.front();\\n                wheelQueue.pop();\\n                if (currentWheel == target) {\\n                    return result;\\n                }\\n                for (int i = 0; i < 4; i++) {\\n                    down = up = currentWheel;\\n                    char upCh = up[i], downCh = down[i];\\n                    up[i] = (upCh == \\'9\\' ? \\'0\\' : upCh + 1);\\n                    down[i] = (downCh == \\'0\\' ? \\'9\\' : downCh - 1);\\n                    if (visited.find(up) == visited.end() && deadendsSet.find(up) == deadendsSet.end()) {\\n                        wheelQueue.push(up);\\n                        visited.insert(up);\\n                    }\\n                    if (visited.find(down) == visited.end() && deadendsSet.find(down) == deadendsSet.end()) {\\n                        wheelQueue.push(down);\\n                        visited.insert(down);\\n                    }\\n                }\\n            }\\n            result++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495635,
                "title": "python-simple-bfs",
                "content": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        dead_set = set(deadends)\\n        queue = collections.deque()\\n        queue.append((\\'0000\\', 0))\\n        visited = set(\\'0000\\')\\n        \\n        while queue:\\n            string, step = queue.popleft()\\n            \\n            if string in dead_set:\\n                continue\\n            if string == target:\\n                return step\\n            \\n            for i in range(len(string)):\\n                num = int(string[i])\\n                for dx in (-1, 1):\\n                    num_new = (num + dx) % 10\\n                    string_new = string[:i] + str(num_new) + string[i+1:]\\n                    if string_new not in visited:\\n                        queue.append((string_new, step+1))\\n                        visited.add(string_new)\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        dead_set = set(deadends)\\n        queue = collections.deque()\\n        queue.append((\\'0000\\', 0))\\n        visited = set(\\'0000\\')\\n        \\n        while queue:\\n            string, step = queue.popleft()\\n            \\n            if string in dead_set:\\n                continue\\n            if string == target:\\n                return step\\n            \\n            for i in range(len(string)):\\n                num = int(string[i])\\n                for dx in (-1, 1):\\n                    num_new = (num + dx) % 10\\n                    string_new = string[:i] + str(num_new) + string[i+1:]\\n                    if string_new not in visited:\\n                        queue.append((string_new, step+1))\\n                        visited.add(string_new)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240641,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        int i,j,n,ans=0;\\n        \\n        set<string> s(deadends.begin(),deadends.end());\\n        if(s.find(\"0000\")!=s.end()) return -1;\\n       \\n        queue<string> q;\\n        q.push(\"0000\");\\n        while(!q.empty())\\n        {\\n            n=q.size();\\n            for(i=0;i<n;i++)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                if(temp==target) return ans;\\n                for(j=0;j<4;j++)\\n                {\\n                        string fwd,bwd;\\n                        fwd= temp.substr(0,j)+to_string\\n                        (temp[j]==\\'0\\'?9:temp[j]-\\'0\\'-1)+temp.substr(j+1);\\n                        bwd= temp.substr(0,j)+to_string\\n                        (temp[j] ==\\'9\\'?0:temp[j]-\\'0\\'+ 1)+temp.substr(j+1);\\n                        if(!s.count(fwd)) s.insert(fwd),q.push(fwd);\\n                        if(!s.count(bwd)) s.insert(bwd),q.push(bwd);                            \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;   \\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        int i,j,n,ans=0;\\n        \\n        set<string> s(deadends.begin(),deadends.end());\\n        if(s.find(\"0000\")!=s.end()) return -1;\\n       \\n        queue<string> q;\\n        q.push(\"0000\");\\n        while(!q.empty())\\n        {\\n            n=q.size();\\n            for(i=0;i<n;i++)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                if(temp==target) return ans;\\n                for(j=0;j<4;j++)\\n                {\\n                        string fwd,bwd;\\n                        fwd= temp.substr(0,j)+to_string\\n                        (temp[j]==\\'0\\'?9:temp[j]-\\'0\\'-1)+temp.substr(j+1);\\n                        bwd= temp.substr(0,j)+to_string\\n                        (temp[j] ==\\'9\\'?0:temp[j]-\\'0\\'+ 1)+temp.substr(j+1);\\n                        if(!s.count(fwd)) s.insert(fwd),q.push(fwd);\\n                        if(!s.count(bwd)) s.insert(bwd),q.push(bwd);                            \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;   \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906693,
                "title": "c-bfs-approach-simple-clean-concise-code",
                "content": "**C++ Approach :**\\n```\\n\\tint openLock(vector<string>& deadends, string target) \\n    {\\n        unordered_map<string,int> m;\\n        for(auto p:deadends)\\n            m[p]++;\\n        \\n        if(m.find(\"0000\")!=m.end()) \\n            return -1;\\n        \\n        queue<string> q;\\n        q.push(\"0000\");\\n        unordered_map<string,int> vis;\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                string temp=q.front();\\n                q.pop();\\n                \\n                if(target==temp && m.find(temp)==m.end())\\n                    return ans;\\n                \\n                for(int j=0;j<4;j++) \\n                {\\n                    for(int diff:{1,9}) \\n                    {\\n                        string s=temp;\\n                        s[j]=(s[j]-\\'0\\'+diff)%10+\\'0\\';\\n                        \\n                        if (m.find(s)==m.end() && vis.find(s)==m.end()) \\n                            q.push(s);\\n                        \\n                        vis[s]++;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n\\tint openLock(vector<string>& deadends, string target) \\n    {\\n        unordered_map<string,int> m;\\n        for(auto p:deadends)\\n            m[p]++;\\n        \\n        if(m.find(\"0000\")!=m.end()) \\n            return -1;\\n        \\n        queue<string> q;\\n        q.push(\"0000\");\\n        unordered_map<string,int> vis;\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                string temp=q.front();\\n                q.pop();\\n                \\n                if(target==temp && m.find(temp)==m.end())\\n                    return ans;\\n                \\n                for(int j=0;j<4;j++) \\n                {\\n                    for(int diff:{1,9}) \\n                    {\\n                        string s=temp;\\n                        s[j]=(s[j]-\\'0\\'+diff)%10+\\'0\\';\\n                        \\n                        if (m.find(s)==m.end() && vis.find(s)==m.end()) \\n                            q.push(s);\\n                        \\n                        vis[s]++;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1853659,
                "title": "c-bfs-solution-simple-commented",
                "content": "```\\nint openLock(vector<string>& deadends, string target) {\\n\\t//list of deadends\\n\\tunordered_set<string> st{deadends.begin(),deadends.end()};\\n\\t//base cases when begin is a deadend or target is a deadend\\n\\tif(st.count(\"0000\") or st.count(target)) return -1;\\n\\t//start itself is target\\n\\tif(target==\"0000\") return 0;\\n\\t//BFS\\n\\tqueue<string> Q;\\n\\tQ.push(\"0000\");\\n\\tint steps=0,s;\\n\\tstring cur,s1,s2;\\n\\twhile(!Q.empty()){\\n\\t\\ts=Q.size();\\n\\t\\twhile(s--){\\n\\t\\t\\tcur=Q.front();\\n\\t\\t\\tQ.pop();\\n\\t\\t\\tfor(int i=0;i<4;i++){\\n\\t\\t\\t\\t//s1 -- > cur with one step clockwise \\n\\t\\t\\t\\t//s2 -- > cur with one step anti clockwise\\n\\t\\t\\t\\ts1=s2=cur;\\n\\t\\t\\t\\ts1[i]=\\'0\\'+(cur[i]-\\'0\\'+1)%10;\\n\\t\\t\\t\\ts2[i]=\\'0\\'+(cur[i]-\\'0\\'+9)%10;\\n\\t\\t\\t\\t//if s1 or s2 is target return steps\\n\\t\\t\\t\\tif(s1==target or s2==target) return steps+1;\\n\\t\\t\\t\\t//else push s1 and s2 into queue and list of deadends \\n\\t\\t\\t\\t//if they are not present in dead ends already\\n\\t\\t\\t\\tif(!st.count(s1)){\\n\\t\\t\\t\\t\\tQ.push(s1);\\n\\t\\t\\t\\t\\tst.insert(s1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!st.count(s2)){\\n\\t\\t\\t\\t\\tQ.push(s2);\\n\\t\\t\\t\\t\\tst.insert(s2);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsteps++;\\n\\t}\\n\\treturn -1;\\n}\\n```\\n\\n**Please Upvote : )**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nint openLock(vector<string>& deadends, string target) {\\n\\t//list of deadends\\n\\tunordered_set<string> st{deadends.begin(),deadends.end()};\\n\\t//base cases when begin is a deadend or target is a deadend\\n\\tif(st.count(\"0000\") or st.count(target)) return -1;\\n\\t//start itself is target\\n\\tif(target==\"0000\") return 0;\\n\\t//BFS\\n\\tqueue<string> Q;\\n\\tQ.push(\"0000\");\\n\\tint steps=0,s;\\n\\tstring cur,s1,s2;\\n\\twhile(!Q.empty()){\\n\\t\\ts=Q.size();\\n\\t\\twhile(s--){\\n\\t\\t\\tcur=Q.front();\\n\\t\\t\\tQ.pop();\\n\\t\\t\\tfor(int i=0;i<4;i++){\\n\\t\\t\\t\\t//s1 -- > cur with one step clockwise \\n\\t\\t\\t\\t//s2 -- > cur with one step anti clockwise\\n\\t\\t\\t\\ts1=s2=cur;\\n\\t\\t\\t\\ts1[i]=\\'0\\'+(cur[i]-\\'0\\'+1)%10;\\n\\t\\t\\t\\ts2[i]=\\'0\\'+(cur[i]-\\'0\\'+9)%10;\\n\\t\\t\\t\\t//if s1 or s2 is target return steps\\n\\t\\t\\t\\tif(s1==target or s2==target) return steps+1;\\n\\t\\t\\t\\t//else push s1 and s2 into queue and list of deadends \\n\\t\\t\\t\\t//if they are not present in dead ends already\\n\\t\\t\\t\\tif(!st.count(s1)){\\n\\t\\t\\t\\t\\tQ.push(s1);\\n\\t\\t\\t\\t\\tst.insert(s1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!st.count(s2)){\\n\\t\\t\\t\\t\\tQ.push(s2);\\n\\t\\t\\t\\t\\tst.insert(s2);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsteps++;\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539134,
                "title": "kotlin-bfs-readable-data-class-extensions",
                "content": "Data class to represent lock code:\\n```\\nprivate data class LockCode(val first: Int, val second: Int, val third: Int, val forth: Int) {\\n    override fun toString(): String {\\n        return \"$first$second$third$forth\"\\n    }\\n}\\n```\\nEach lock we can change by 1, increasing till 9 or decreasing to 0:\\n```\\nfun Int.next(): Int = if (this == 9) 0 else (this + 1)\\nfun Int.prev(): Int = if (this == 0) 9 else (this - 1)\\n```\\n\\nTo generate all possile single lock changes we need: \\n(increment each by 1) + (decrement each by 1) => total 8 variants\\n```\\nprivate fun LockCode.generateNextLevel(): List<LockCode> =\\n        listOf(\\n                copy(first = first.next()),\\n                copy(second = second.next()),\\n                copy(third = third.next()),\\n                copy(forth = forth.next()),\\n                copy(first = first.prev()),\\n                copy(second = second.prev()),\\n                copy(third = third.prev()),\\n                copy(forth = forth.prev())\\n        )\\n```\\nAnd finally the solution is simple BFS with level counter, where we skip deadends and already seen codes:\\n```\\nfun openLock(deadends: Array<String>, target: String): Int {\\n    var count = 0\\n    val notValid = deadends.toSet()\\n\\n    val queue: Queue<LockCode> = LinkedList()\\n    queue.offer(LockCode(0, 0, 0, 0))\\n\\n    val used = mutableSetOf<LockCode>()\\n\\n    while (queue.isNotEmpty()) {\\n        repeat(queue.size) {\\n            val newCode = queue.poll()\\n            if (newCode.toString() == target) {\\n                return count\\n            }\\n            if (newCode.toString() !in notValid) {\\n                val next = newCode.generateNextLevel()\\n                next.forEach { code ->\\n                    if (code.toString() == target) {\\n                        return count + 1\\n                    }\\n\\n                    if (code.toString() !in notValid && used.add(code)) {\\n                        queue.add(code)\\n                    }\\n                }\\n            }\\n        }\\n        count++\\n    }\\n\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Breadth-First Search"
                ],
                "code": "```\\nprivate data class LockCode(val first: Int, val second: Int, val third: Int, val forth: Int) {\\n    override fun toString(): String {\\n        return \"$first$second$third$forth\"\\n    }\\n}\\n```\n```\\nfun Int.next(): Int = if (this == 9) 0 else (this + 1)\\nfun Int.prev(): Int = if (this == 0) 9 else (this - 1)\\n```\n```\\nprivate fun LockCode.generateNextLevel(): List<LockCode> =\\n        listOf(\\n                copy(first = first.next()),\\n                copy(second = second.next()),\\n                copy(third = third.next()),\\n                copy(forth = forth.next()),\\n                copy(first = first.prev()),\\n                copy(second = second.prev()),\\n                copy(third = third.prev()),\\n                copy(forth = forth.prev())\\n        )\\n```\n```\\nfun openLock(deadends: Array<String>, target: String): Int {\\n    var count = 0\\n    val notValid = deadends.toSet()\\n\\n    val queue: Queue<LockCode> = LinkedList()\\n    queue.offer(LockCode(0, 0, 0, 0))\\n\\n    val used = mutableSetOf<LockCode>()\\n\\n    while (queue.isNotEmpty()) {\\n        repeat(queue.size) {\\n            val newCode = queue.poll()\\n            if (newCode.toString() == target) {\\n                return count\\n            }\\n            if (newCode.toString() !in notValid) {\\n                val next = newCode.generateNextLevel()\\n                next.forEach { code ->\\n                    if (code.toString() == target) {\\n                        return count + 1\\n                    }\\n\\n                    if (code.toString() !in notValid && used.add(code)) {\\n                        queue.add(code)\\n                    }\\n                }\\n            }\\n        }\\n        count++\\n    }\\n\\n    return -1\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332065,
                "title": "c-bfs-easy-approach",
                "content": "```\\nint openLock(vector<string>& deadends, string target) {\\n        constexpr int NUM = 10;\\n        unordered_set<string> deads(deadends.begin(), deadends.end());\\n        unordered_set<string> visited;\\n        if(deads.count(\"0000\") || deads.count(target)) return -1;\\n        queue<string> q;\\n        q.push(\"0000\");\\n        visited.insert(\"0000\");\\n        int step = 0;\\n        while(!q.empty()) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                string cur = q.front();\\n                q.pop();\\n                if(cur == target) return step;\\n                for(int pos = 0; pos < cur.size(); pos++) {\\n                    for(int op = -1; op <= 1; op += 2) {\\n                        int num = ((cur[pos] - \\'0\\') + op + NUM) % NUM;\\n                        string next_cur = cur;\\n                        next_cur[pos] = num + \\'0\\';\\n                        if(visited.count(next_cur) || deads.count(next_cur)) continue;\\n                        q.push(next_cur);\\n                        visited.insert(next_cur);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint openLock(vector<string>& deadends, string target) {\\n        constexpr int NUM = 10;\\n        unordered_set<string> deads(deadends.begin(), deadends.end());\\n        unordered_set<string> visited;\\n        if(deads.count(\"0000\") || deads.count(target)) return -1;\\n        queue<string> q;\\n        q.push(\"0000\");\\n        visited.insert(\"0000\");\\n        int step = 0;\\n        while(!q.empty()) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                string cur = q.front();\\n                q.pop();\\n                if(cur == target) return step;\\n                for(int pos = 0; pos < cur.size(); pos++) {\\n                    for(int op = -1; op <= 1; op += 2) {\\n                        int num = ((cur[pos] - \\'0\\') + op + NUM) % NUM;\\n                        string next_cur = cur;\\n                        next_cur[pos] = num + \\'0\\';\\n                        if(visited.count(next_cur) || deads.count(next_cur)) continue;\\n                        q.push(next_cur);\\n                        visited.insert(next_cur);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1250991,
                "title": "rust-bfs",
                "content": "We convert the locks into `u16`s as they\\'re easier to work with.\\n\\n```rust\\nuse std::collections::{HashSet, VecDeque};\\n\\nimpl Solution {\\n    pub fn open_lock(deadends: Vec<String>, target: String) -> i32 {\\n        let mut ignore: HashSet<_> = deadends.iter().map(|s| s.parse().unwrap()).collect();\\n        let (target, mut queue, mut moves) = (target.parse::<u16>().unwrap(), VecDeque::new(), 0);\\n        queue.push_back(0000);\\n        while !queue.is_empty() {\\n            for _ in 0..queue.len() {\\n                let lock = queue.pop_front().unwrap();\\n                if lock == target {\\n                    return moves;\\n                } else if ignore.insert(lock) {\\n                    for i in &[1000, 0100, 0010, 0001] {\\n                        let wheel = (lock / i) % 10;\\n                        queue.push_back((lock - i * wheel) + (i * ((wheel + 1) % 10))); // +1\\n                        queue.push_back((lock - i * wheel) + (i * ((wheel + 9) % 10))); // -1\\n                    }\\n                }\\n            }\\n            moves += 1;\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Breadth-First Search"
                ],
                "code": "```rust\\nuse std::collections::{HashSet, VecDeque};\\n\\nimpl Solution {\\n    pub fn open_lock(deadends: Vec<String>, target: String) -> i32 {\\n        let mut ignore: HashSet<_> = deadends.iter().map(|s| s.parse().unwrap()).collect();\\n        let (target, mut queue, mut moves) = (target.parse::<u16>().unwrap(), VecDeque::new(), 0);\\n        queue.push_back(0000);\\n        while !queue.is_empty() {\\n            for _ in 0..queue.len() {\\n                let lock = queue.pop_front().unwrap();\\n                if lock == target {\\n                    return moves;\\n                } else if ignore.insert(lock) {\\n                    for i in &[1000, 0100, 0010, 0001] {\\n                        let wheel = (lock / i) % 10;\\n                        queue.push_back((lock - i * wheel) + (i * ((wheel + 1) % 10))); // +1\\n                        queue.push_back((lock - i * wheel) + (i * ((wheel + 9) % 10))); // -1\\n                    }\\n                }\\n            }\\n            moves += 1;\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1094192,
                "title": "java-don-t-use-hashset-and-contains-beats-95",
                "content": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        int ans=-1;\\n        boolean[] visited = new boolean[10000];\\n        for(String s : deadends){\\n            int d = Integer.parseInt(s);\\n            visited[d] = true;\\n        }\\n        int t = Integer.parseInt(target);\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0000);\\n        while(q.size()>0){\\n            int l= q.size();\\n            ans++;\\n            for(int i=0;i<l;i++){\\n                int d = q.poll();\\n                if(visited[d]==true) continue;\\n                if(d==t) return ans;\\n                visited[d] = true;\\n                int d4 = d%10; d=d/10;\\n                int d3 = d%10; d=d/10;\\n                int d2 = d%10; d=d/10;\\n                int d1 = d%10;\\n                \\n                int nd4 = d1*1000 + d2*100 + d3*10 + (d4+1)%10;\\n                int nd3 = d1*1000 + d2*100 + ((d3+1)%10)*10 +d4;\\n                int nd2 = d1*1000 + ((d2+1)%10)*100 + d3*10 + d4;\\n                int nd1 = ((d1+1)%10)*1000 + d2*100 + d3*10 + d4;\\n                if(visited[nd4]==false) q.add(nd4);\\n                if(visited[nd3]==false) q.add(nd3);\\n                if(visited[nd2]==false) q.add(nd2);\\n                if(visited[nd1]==false) q.add(nd1);\\n                \\n                int dd4 = (d4-1)%10;\\n                if(dd4 < 0) dd4 = 10 + dd4;\\n                int nnd4 = d1*1000 + d2*100 + d3*10 + dd4;\\n                \\n                int dd3 = ((d3-1)%10)*10;\\n                if(dd3 < 0) dd3 = 100 + dd3;\\n                int nnd3 = d1*1000 + d2*100 + dd3 +d4;\\n                \\n                int dd2 = ((d2-1)%10)*100;\\n                if(dd2 < 0) dd2 = 1000 + dd2;\\n                int nnd2 = d1*1000 + dd2 + d3*10 + d4;\\n                \\n                int dd1 = ((d1-1)%10)*1000;\\n                if(dd1 < 0) dd1 = 10000 + dd1;\\n                int nnd1 = dd1 + d2*100 + d3*10 + d4;\\n                \\n                if(visited[nnd4]==false) q.add(nnd4);\\n                if(visited[nnd3]==false) q.add(nnd3);\\n                if(visited[nnd2]==false) q.add(nnd2);\\n                if(visited[nnd1]==false) q.add(nnd1);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        int ans=-1;\\n        boolean[] visited = new boolean[10000];\\n        for(String s : deadends){\\n            int d = Integer.parseInt(s);\\n            visited[d] = true;\\n        }\\n        int t = Integer.parseInt(target);\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0000);\\n        while(q.size()>0){\\n            int l= q.size();\\n            ans++;\\n            for(int i=0;i<l;i++){\\n                int d = q.poll();\\n                if(visited[d]==true) continue;\\n                if(d==t) return ans;\\n                visited[d] = true;\\n                int d4 = d%10; d=d/10;\\n                int d3 = d%10; d=d/10;\\n                int d2 = d%10; d=d/10;\\n                int d1 = d%10;\\n                \\n                int nd4 = d1*1000 + d2*100 + d3*10 + (d4+1)%10;\\n                int nd3 = d1*1000 + d2*100 + ((d3+1)%10)*10 +d4;\\n                int nd2 = d1*1000 + ((d2+1)%10)*100 + d3*10 + d4;\\n                int nd1 = ((d1+1)%10)*1000 + d2*100 + d3*10 + d4;\\n                if(visited[nd4]==false) q.add(nd4);\\n                if(visited[nd3]==false) q.add(nd3);\\n                if(visited[nd2]==false) q.add(nd2);\\n                if(visited[nd1]==false) q.add(nd1);\\n                \\n                int dd4 = (d4-1)%10;\\n                if(dd4 < 0) dd4 = 10 + dd4;\\n                int nnd4 = d1*1000 + d2*100 + d3*10 + dd4;\\n                \\n                int dd3 = ((d3-1)%10)*10;\\n                if(dd3 < 0) dd3 = 100 + dd3;\\n                int nnd3 = d1*1000 + d2*100 + dd3 +d4;\\n                \\n                int dd2 = ((d2-1)%10)*100;\\n                if(dd2 < 0) dd2 = 1000 + dd2;\\n                int nnd2 = d1*1000 + dd2 + d3*10 + d4;\\n                \\n                int dd1 = ((d1-1)%10)*1000;\\n                if(dd1 < 0) dd1 = 10000 + dd1;\\n                int nnd1 = dd1 + d2*100 + d3*10 + d4;\\n                \\n                if(visited[nnd4]==false) q.add(nnd4);\\n                if(visited[nnd3]==false) q.add(nnd3);\\n                if(visited[nnd2]==false) q.add(nnd2);\\n                if(visited[nnd1]==false) q.add(nnd1);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081215,
                "title": "c-bfs-to-solve-the-shortest-path-problem",
                "content": "```\\npublic class Solution {\\n    public int OpenLock(string[] deadends, string target) {\\n        var deads = new HashSet<string>(deadends);\\n        if (deadends.Contains(\"0000\") || deadends.Contains(target)) return -1;\\n        \\n        var directions = new int[] { 1, -1 };\\n        int steps = 0;\\n        var q = new Queue<string>();\\n        q.Enqueue(\"0000\");\\n        var visited = new HashSet<string>();\\n        visited.Add(\"0000\");\\n        \\n        while (q.Count > 0) {\\n            var size = q.Count;\\n            \\n            for (int i=0; i<size; i++) {\\n                var node = q.Dequeue();\\n                if (node == target) return steps;\\n                var digitArr = node.ToCharArray();\\n                for (int k=0; k<4; k++) {\\n                    var tmp = digitArr[k];\\n                    int digit = digitArr[k] - \\'0\\';\\n                    foreach (var dir in directions) {\\n                        var newdigit = digit + dir;\\n                        if (newdigit == 10) newdigit = 0;\\n                        if (newdigit == -1) newdigit = 9;\\n                        digitArr[k] = (char)(newdigit + \\'0\\');\\n                        var news = new string(digitArr);\\n                        if (!deads.Contains(news) && !visited.Contains(news)) {\\n                            q.Enqueue(news);\\n                            visited.Add(news);\\n                        }\\n                    }\\n                    digitArr[k] = tmp;\\n                }\\n                \\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int OpenLock(string[] deadends, string target) {\\n        var deads = new HashSet<string>(deadends);\\n        if (deadends.Contains(\"0000\") || deadends.Contains(target)) return -1;\\n        \\n        var directions = new int[] { 1, -1 };\\n        int steps = 0;\\n        var q = new Queue<string>();\\n        q.Enqueue(\"0000\");\\n        var visited = new HashSet<string>();\\n        visited.Add(\"0000\");\\n        \\n        while (q.Count > 0) {\\n            var size = q.Count;\\n            \\n            for (int i=0; i<size; i++) {\\n                var node = q.Dequeue();\\n                if (node == target) return steps;\\n                var digitArr = node.ToCharArray();\\n                for (int k=0; k<4; k++) {\\n                    var tmp = digitArr[k];\\n                    int digit = digitArr[k] - \\'0\\';\\n                    foreach (var dir in directions) {\\n                        var newdigit = digit + dir;\\n                        if (newdigit == 10) newdigit = 0;\\n                        if (newdigit == -1) newdigit = 9;\\n                        digitArr[k] = (char)(newdigit + \\'0\\');\\n                        var news = new string(digitArr);\\n                        if (!deads.Contains(news) && !visited.Contains(news)) {\\n                            q.Enqueue(news);\\n                            visited.Add(news);\\n                        }\\n                    }\\n                    digitArr[k] = tmp;\\n                }\\n                \\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870846,
                "title": "javascript-bfs",
                "content": "Slightly modified solution from [@adriansky\\'s original post](https://leetcode.com/problems/open-the-lock/discuss/730358/Simple-and-readable-BFS-solution-in-JavaScript-%2B-Explanation).\\n```\\nvar openLock = function(deadends, target) {\\n  const dead = new Set(deadends)\\n  let turns = 0\\n  let queue = [\\'0000\\']\\n  const seen = new Set([\\'0000\\'])\\n  while(queue.length){\\n    const next = []\\n    for(let comb of queue){\\n      if(comb === target) return turns\\n      if(dead.has(comb)) continue\\n      for(let c of getCombinations(comb)){\\n        if(seen.has(c)) continue\\n        seen.add(c)\\n        next.push(c)\\n      }      \\n    }\\n    turns++\\n    queue = next\\n  }  \\n  return -1\\n};\\n\\nfunction getCombinations(comb, ans=[]){\\n  for(let i=0;i<comb.length;i++){\\n    ans.push(comb.slice(0,i) + ((+comb[i]+1)%10) + comb.slice(i+1))\\n    ans.push(comb.slice(0,i) + ((+comb[i]+9)%10) + comb.slice(i+1))\\n  }\\n  return ans\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar openLock = function(deadends, target) {\\n  const dead = new Set(deadends)\\n  let turns = 0\\n  let queue = [\\'0000\\']\\n  const seen = new Set([\\'0000\\'])\\n  while(queue.length){\\n    const next = []\\n    for(let comb of queue){\\n      if(comb === target) return turns\\n      if(dead.has(comb)) continue\\n      for(let c of getCombinations(comb)){\\n        if(seen.has(c)) continue\\n        seen.add(c)\\n        next.push(c)\\n      }      \\n    }\\n    turns++\\n    queue = next\\n  }  \\n  return -1\\n};\\n\\nfunction getCombinations(comb, ans=[]){\\n  for(let i=0;i<comb.length;i++){\\n    ans.push(comb.slice(0,i) + ((+comb[i]+1)%10) + comb.slice(i+1))\\n    ans.push(comb.slice(0,i) + ((+comb[i]+9)%10) + comb.slice(i+1))\\n  }\\n  return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 702332,
                "title": "python-216-ms-95-bfs-with-optimizations-detailed-explanation",
                "content": "The straight-forward BFS approach is described well in other posts, so I will just highlight the optimizations that were used in this approach. Although, if you would like me explain anything in more detail drop a comment below.  Hope this helps!\\n\\n<h2><b><u>Optimizations</b></u>:</h2>\\n\\n**1. Perform two BFS.  One starting from ```\\'0000\\'``` and the other starting from ```target```.**\\n\\nThis is the optimization that has the biggest impact (aside from optimization #4).  This is because when you perform BFS approach starting from only one end (```\\'0000\\'``` or ```target```) then your search path looks like this (without considering ```deadends```)\\n\\n```\\nq = [\\'0000\\'] #level 0 ; length = 1\\nq = [\\'0001\\', \\'0010\\', \\'0100\\', \\'1000\\', \\'0009\\', \\'0090\\', \\'0900\\', \\'9000\\'] #level 1 ; length = 8\\nq = [\\'0002\\', \\'0020\\', \\'0200\\', \\'2000\\', \\'0008\\', \\'0080\\', \\'0800\\', \\'8000\\',\\n     \\'0011\\', \\'0101\\', \\'1001\\', \\'0110\\', \\'1010\\', \\'1100\\', \\'0019\\', ......] #level 2 ; length = 56\\nq = [...] #level 3; length = 224\\nq = [...] #level 4; length = 616\\nq = [...] #level 5; length = 1344 ; these lengths will be longer if optimization #3 is ignored\\n```\\n\\nthe queue gets longer and longer with each level.  **If we only search outward from one end of our path, then ```q``` might be extremely long by the time ```target``` shows up in ```q```.**\\n\\nIn this approach we use two queues.  One that starts its search at ```\\'0000\\'``` (call this ```q[0]```) and another that starts its search at ```target``` (call this ```q[1]```).  We never use both queues at the same time, instead we **pick the shorter of the two queues to check.**  \\n\\nThis adds a new challenge to the BFS approach.  We need to make sure we are not revisiting combinations that have already been visited, but at the same time check if ```q[0]``` has found a combination that was visited by ```q[1]``` or vice versa.  In other words, **we can\\'t just use a single ```set``` to keep track of visited combinations.**  \\n\\nInstead we have two dictionaries (```visited[0]``` and ```visited[1]```).  ```visited[0]``` keeps track of the combinations visited in ```q[0]``` as a ```key``` and stores the distance to the combination as the value.  ```visited[1]``` stores the same information but stemming from the target.  For example if ```target = \\'0202\\'``` our visited dictionaries will look like this:\\n\\n```python\\nvisited[0] = {\\'0000\\' : 0, \\'0001\\' : 1, \\'0010\\' : 1, \\'9000\\': 1, ... \\'0101\\': 2}\\nvisited[1] = {\\'0202\\' : 0, \\'0102\\' : 1, \\'0302\\' : 1, \\'9202\\': 1, ..., \\'0101\\': 2}\\n```\\n\\nnow instead of looking for a path from ```\\'0000\\'``` to target, we are looking for a path from ```\\'0000\\'``` to ```\\'XXXX\\'``` and a second path from ```target``` to ```\\'XXXX\\'```.  In the example above ```\\'XXXX\\' = \\'0101\\'``` and **our shortest path is the sum of these two paths ```visited[0][\\'0101\\'] + visited[1][\\'0101\\'] = 2 + 2 = 4```.**  Note, we do not have to know or guess ```\\'XXXX\\'```, we simply check ```visited[1]``` for every combination we see in ```q[0]``` and vice-versa.  \\n\\n**In this specific example,** we can see that by using BFS from both ```\\'0000\\'``` **and** ```target```, we find the solution after reaching level 2 in both searches.  This at most totals to ```2 * (1 + 8 + 56) = 130``` combinations checked.  On the other hand performing BFS from only ```\\'0000\\'``` **or** ```target``` we would find our solution in level 4 which at most totals to ```1 + 8 + 56 + 244 + 616 = 925``` combinations checked.  \\n\\n**2. Stop when either q[0] or q[1] is empty.**\\n\\nThe only reason that ```q[0]``` or ```q[1]``` would become empty is if the ```deadends``` block all paths between ```\\'0000\\'``` and ```target```.  This is an optimization because if all paths are blocked, it is likely that the ```deadends``` are clustered around either the ```target``` or ```\\'0000\\'```.  As is the case in this example:\\n\\n```python\\ndeadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"]\\ntarget = \"8888\"\\n```\\n\\n```q[1]``` would quickly run out of possible nodes to explore and we would ```return -1``` right away.  \\n\\n**3. If you went from \\'0010\\' to \\'0020\\' do not recreate the string for \\'0010\\' when considering the next combination.**\\n\\nThis is a quite small optimization which admittedly may not be worth its weight when considering the reduction in readability.  \\n\\nEach time a new combination is added to ```q[0]``` or to ```q[1]```, we include with the combination the distance to the cobmination (for use in optimization #2) and a tuple consisting of the index of the digit that was changed and whether it was increased or decreased.  For example:\\n\\n```python\\n`0000` --> tuple((`0001`, 1, tuple((3, 1))\\n```\\n\\n```\\'0001\\'``` is the new combination, ```1``` tells us that it took one move to get to this combination, and ```tuple((3,1))``` tells us that index 3 was increased by 1 to get to this combination.  \\n\\nNow when we see ```\\'0001\\'``` in our queue, we will not recreate the string ```\\'0000\\'``` because we know we got to ```\\'0001\\'``` by increasing the third digit by 1.  \\n\\nIf you leave this optimization out, all that will change is that ```\\'0000\\'``` will be created, added to the queue, and then skipped because it is marked as a visited combination.  (Same result, just a few more steps.)\\n\\n**4. Use hashtables to store deadends and visited combinations.**\\n\\nThis is a big optimization, but it is no different than the standard BFS approach so I put it here at the end.  Sets and dictionaries both use hashtables as their underlying datastructure which allows for O(1) lookup times.  We store ```deadends``` in a ```set``` and visited in two dictionaries.  If ```deadends``` and ```visited``` remain short then this is a small optimization.  However when there are many combinations stored in ```deadends``` or ```visited``` you will likely get TLE if using a ```list```.  \\n\\n<b><u>Annotated code</b></u>:\\n```python\\nfrom collections import deque\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        #handle corner cases (start at target) and (start in deadend position)\\n        if target == \\'0000\\': return 0 \\n        if \\'0000\\' in deadends: return -1 \\n        \\n        \\n        #options p: increases number by 1 ; options_n: decreases number by 1\\n        options_p = dict(zip([str(i) for i in range(0,10)],[str((i+1)%10) for i in range(0,10)]))\\n        options_n = dict(zip([str(i) for i in range(0,10)],[str((i-1)%10) for i in range(0,10)]))\\n\\n        dead = set(deadends)\\n        \\n        #combos visited from \\'0000\\' to target, and combos visited from target to \\'0000\\'\\n        visited = [{},{}] \\n        \\n        #queue (q) for combinations to be visited next.  q[0] from \\n        #combo, moves made, plus or minus 1 to get to combo\\n        q = [deque([(\\'0000\\',0,tuple((0,0)))]),deque([(target,0,tuple((0,0)))])] \\n        \\n        #progress in the forward and reverse direction\\n        progress = 1 \\n        while q[0] and q[1]:\\n            \\n            #choose d (direction) as the shorter of the two queues\\n            d = 0 if len(q[0]) <= len(q[1]) else 1\\n            \\n            length = len(q[d])\\n            \\n            for _ in range(length):\\n                \\n                combo, dist, path = q[d].popleft()\\n                \\n                #skip combination if it is a deadend\\n                if combo in dead: \\n                    continue\\n                    \\n                 #do not revisit the same combination twice unless it was arrived at from different directions\\n                if combo in visited[d]:\\n                    continue\\n                    \\n                #if this combination was found from the other direction add the two distances (this is our answer)\\n                if combo in visited[1 - d]: \\n                    return visited[1 - d][combo] + dist\\n                \\n                #store visited combination in appropriate dict visited[0] for \\'0000\\' -> target ; visited[1] for target -> \\'0000\\' \\n                visited[d][combo] = dist \\n                \\n                for i in range(4):\\n                    \\n                    #increase each number by 1 (if we did not get here by decreasing it by 1)\\n                    #    i.e. \\'0000\\' -> \\'0001\\' do not go back to \\'0000\\' but \\'1001\\', \\'0101\\', \\'0011\\' are all okay\\n                    for num in options_n[combo[i]]: \\n                        if path != tuple((i,1)):\\n                            q[d].append((combo[:i]+num+combo[i+1:],dist+1, tuple((i,-1))))\\n\\n                    #decrease each number by 1 (if we did not get here by increasing it by 1)\\n                    for num in options_p[combo[i]]: \\n                        if path != tuple((i,-1)):\\n                            q[d].append((combo[:i]+num+combo[i+1:],dist+1, tuple((i,1))))\\n                        \\n        else:\\n            return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\'0000\\'```\n```target```\n```\\'0000\\'```\n```target```\n```deadends```\n```\\nq = [\\'0000\\'] #level 0 ; length = 1\\nq = [\\'0001\\', \\'0010\\', \\'0100\\', \\'1000\\', \\'0009\\', \\'0090\\', \\'0900\\', \\'9000\\'] #level 1 ; length = 8\\nq = [\\'0002\\', \\'0020\\', \\'0200\\', \\'2000\\', \\'0008\\', \\'0080\\', \\'0800\\', \\'8000\\',\\n     \\'0011\\', \\'0101\\', \\'1001\\', \\'0110\\', \\'1010\\', \\'1100\\', \\'0019\\', ......] #level 2 ; length = 56\\nq = [...] #level 3; length = 224\\nq = [...] #level 4; length = 616\\nq = [...] #level 5; length = 1344 ; these lengths will be longer if optimization #3 is ignored\\n```\n```q```\n```target```\n```q```\n```\\'0000\\'```\n```q[0]```\n```target```\n```q[1]```\n```q[0]```\n```q[1]```\n```set```\n```visited[0]```\n```visited[1]```\n```visited[0]```\n```q[0]```\n```key```\n```visited[1]```\n```target = \\'0202\\'```\n```python\\nvisited[0] = {\\'0000\\' : 0, \\'0001\\' : 1, \\'0010\\' : 1, \\'9000\\': 1, ... \\'0101\\': 2}\\nvisited[1] = {\\'0202\\' : 0, \\'0102\\' : 1, \\'0302\\' : 1, \\'9202\\': 1, ..., \\'0101\\': 2}\\n```\n```\\'0000\\'```\n```\\'0000\\'```\n```\\'XXXX\\'```\n```target```\n```\\'XXXX\\'```\n```\\'XXXX\\' = \\'0101\\'```\n```visited[0][\\'0101\\'] + visited[1][\\'0101\\'] = 2 + 2 = 4```\n```\\'XXXX\\'```\n```visited[1]```\n```q[0]```\n```\\'0000\\'```\n```target```\n```2 * (1 + 8 + 56) = 130```\n```\\'0000\\'```\n```target```\n```1 + 8 + 56 + 244 + 616 = 925```\n```q[0]```\n```q[1]```\n```deadends```\n```\\'0000\\'```\n```target```\n```deadends```\n```target```\n```\\'0000\\'```\n```python\\ndeadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"]\\ntarget = \"8888\"\\n```\n```q[1]```\n```return -1```\n```q[0]```\n```q[1]```\n```python\\n`0000` --> tuple((`0001`, 1, tuple((3, 1))\\n```\n```\\'0001\\'```\n```1```\n```tuple((3,1))```\n```\\'0001\\'```\n```\\'0000\\'```\n```\\'0001\\'```\n```\\'0000\\'```\n```deadends```\n```set```\n```deadends```\n```visited```\n```deadends```\n```visited```\n```list```\n```python\\nfrom collections import deque\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        #handle corner cases (start at target) and (start in deadend position)\\n        if target == \\'0000\\': return 0 \\n        if \\'0000\\' in deadends: return -1 \\n        \\n        \\n        #options p: increases number by 1 ; options_n: decreases number by 1\\n        options_p = dict(zip([str(i) for i in range(0,10)],[str((i+1)%10) for i in range(0,10)]))\\n        options_n = dict(zip([str(i) for i in range(0,10)],[str((i-1)%10) for i in range(0,10)]))\\n\\n        dead = set(deadends)\\n        \\n        #combos visited from \\'0000\\' to target, and combos visited from target to \\'0000\\'\\n        visited = [{},{}] \\n        \\n        #queue (q) for combinations to be visited next.  q[0] from \\n        #combo, moves made, plus or minus 1 to get to combo\\n        q = [deque([(\\'0000\\',0,tuple((0,0)))]),deque([(target,0,tuple((0,0)))])] \\n        \\n        #progress in the forward and reverse direction\\n        progress = 1 \\n        while q[0] and q[1]:\\n            \\n            #choose d (direction) as the shorter of the two queues\\n            d = 0 if len(q[0]) <= len(q[1]) else 1\\n            \\n            length = len(q[d])\\n            \\n            for _ in range(length):\\n                \\n                combo, dist, path = q[d].popleft()\\n                \\n                #skip combination if it is a deadend\\n                if combo in dead: \\n                    continue\\n                    \\n                 #do not revisit the same combination twice unless it was arrived at from different directions\\n                if combo in visited[d]:\\n                    continue\\n                    \\n                #if this combination was found from the other direction add the two distances (this is our answer)\\n                if combo in visited[1 - d]: \\n                    return visited[1 - d][combo] + dist\\n                \\n                #store visited combination in appropriate dict visited[0] for \\'0000\\' -> target ; visited[1] for target -> \\'0000\\' \\n                visited[d][combo] = dist \\n                \\n                for i in range(4):\\n                    \\n                    #increase each number by 1 (if we did not get here by decreasing it by 1)\\n                    #    i.e. \\'0000\\' -> \\'0001\\' do not go back to \\'0000\\' but \\'1001\\', \\'0101\\', \\'0011\\' are all okay\\n                    for num in options_n[combo[i]]: \\n                        if path != tuple((i,1)):\\n                            q[d].append((combo[:i]+num+combo[i+1:],dist+1, tuple((i,-1))))\\n\\n                    #decrease each number by 1 (if we did not get here by increasing it by 1)\\n                    for num in options_p[combo[i]]: \\n                        if path != tuple((i,-1)):\\n                            q[d].append((combo[:i]+num+combo[i+1:],dist+1, tuple((i,1))))\\n                        \\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383353,
                "title": "easy-peasy-python-bfs-not-need-of-seen-set",
                "content": "\\tdef openLock(self, deadends: List[str], target: str) -> int:\\n        # we can put the seen key in dead\\n        # both works as the same\\n        dead = set(deadends)\\n        if \"0000\" in dead:\\n            return -1\\n        q = [(\"0000\", 0)]\\n        dead.add(\"0000\")\\n        while len(q) > 0:\\n            key, dis = q.pop(0)\\n            if key == target:\\n                return dis\\n            \\n            neigh = self.getNeigh(key, dead, dis+1)\\n            if len(neigh) > 0:\\n                q.extend(neigh)\\n        \\n        return -1\\n    \\n    \\n    def getNeigh(self, state, dead, dis):\\n        output = []\\n        for i in range(4):\\n            num = int(state[i])\\n            for a in ((num-1), (num+1)):\\n                tmp = state[:i] + str(a%10) + state[i+1:]\\n                if tmp not in dead:\\n                    output.append((tmp, dis))\\n                    dead.add(tmp)\\n                \\n        return output",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\tdef openLock(self, deadends: List[str], target: str) -> int:\\n        # we can put the seen key in dead\\n        # both works as the same\\n        dead = set(deadends)\\n        if \"0000\" in dead:\\n            return -1\\n        q = [(\"0000\", 0)]\\n        dead.add(\"0000\")\\n        while len(q) > 0:\\n            key, dis = q.pop(0)\\n            if key == target:\\n                return dis\\n            \\n            neigh = self.getNeigh(key, dead, dis+1)\\n            if len(neigh) > 0:\\n                q.extend(neigh)\\n        \\n        return -1\\n    \\n    \\n    def getNeigh(self, state, dead, dis):\\n        output = []\\n        for i in range(4):\\n            num = int(state[i])\\n            for a in ((num-1), (num+1)):\\n                tmp = state[:i] + str(a%10) + state[i+1:]\\n                if tmp not in dead:\\n                    output.append((tmp, dis))\\n                    dead.add(tmp)\\n                \\n        return output",
                "codeTag": "Python3"
            },
            {
                "id": 176631,
                "title": "java-bfs-easy-to-understand",
                "content": "For each digit on the lock, we turn one up or turn one down\\n\\n\\n```\\npublic int openLock(String[] deadends, String target) {\\n        Set<String> seen = new HashSet<>();\\n        Set<String> dead = new HashSet<>();\\n        for(String deadend : deadends){\\n            dead.add(deadend);\\n        }\\n        \\n        if(dead.contains(\"0000\")){\\n            return -1;\\n        }\\n        \\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(\"0000\");\\n        seen.add(\"0000\");\\n        int distance = 0;\\n        \\n        while(queue.size() != 0){\\n           \\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                String now = queue.poll();\\n                if(now.equals(target)){\\n                    return distance;\\n                }\\n                for(int j = 0; j < now.length(); j++){\\n                    int ch = now.charAt(j)-\\'0\\';\\n                    int add = (ch+1) % 10;\\n                    String temp = now.substring(0, j) + add + now.substring(j+1);\\n                    if(!seen.contains(temp) && !dead.contains(temp)){\\n                        queue.add(temp);\\n                        seen.add(temp);\\n                    }\\n                    \\n                    int minus = (ch+9) % 10;\\n                    String temp2 = now.substring(0, j) + minus + now.substring(j+1);\\n                    if(!seen.contains(temp2) && !dead.contains(temp2)){\\n                        queue.add(temp2);\\n                        seen.add(temp2);\\n                    }\\n                    \\n                }\\n                \\n            }\\n            distance++;\\n        }\\n        \\n        return -1;\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\npublic int openLock(String[] deadends, String target) {\\n        Set<String> seen = new HashSet<>();\\n        Set<String> dead = new HashSet<>();\\n        for(String deadend : deadends){\\n            dead.add(deadend);\\n        }\\n        \\n        if(dead.contains(\"0000\")){\\n            return -1;\\n        }\\n        \\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(\"0000\");\\n        seen.add(\"0000\");\\n        int distance = 0;\\n        \\n        while(queue.size() != 0){\\n           \\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                String now = queue.poll();\\n                if(now.equals(target)){\\n                    return distance;\\n                }\\n                for(int j = 0; j < now.length(); j++){\\n                    int ch = now.charAt(j)-\\'0\\';\\n                    int add = (ch+1) % 10;\\n                    String temp = now.substring(0, j) + add + now.substring(j+1);\\n                    if(!seen.contains(temp) && !dead.contains(temp)){\\n                        queue.add(temp);\\n                        seen.add(temp);\\n                    }\\n                    \\n                    int minus = (ch+9) % 10;\\n                    String temp2 = now.substring(0, j) + minus + now.substring(j+1);\\n                    if(!seen.contains(temp2) && !dead.contains(temp2)){\\n                        queue.add(temp2);\\n                        seen.add(temp2);\\n                    }\\n                    \\n                }\\n                \\n            }\\n            distance++;\\n        }\\n        \\n        return -1;\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 141266,
                "title": "a-short-and-fast-c-solution-using-bfs",
                "content": "```\\nint openLock(vector<string>& deadends, string target) {\\n    bool v[10000] = {0};\\n    for (auto &s : deadends)\\n        v[stoi(s)] = true;\\n    int t = stoi(target);\\n\\n    queue<int> q;\\n    q.push(0);\\n\\n    int res = 0;\\n    while (!q.empty()) {\\n        int n = q.size();\\n        for (int i = 0; i < n; i++) {\\n            auto s = q.front();\\n            if (s == t)\\n                return res;\\n            q.pop();\\n            if (v[s])\\n                continue;\\n            v[s] = true;\\n            for (int j = 1; j <= 1000; j *= 10) {\\n                q.push(s + ((s / j + 1) % 10 - s / j % 10) * j);\\n                q.push(s + ((s / j + 9) % 10 - s / j % 10) * j);\\n            }\\n        }\\n        res++;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint openLock(vector<string>& deadends, string target) {\\n    bool v[10000] = {0};\\n    for (auto &s : deadends)\\n        v[stoi(s)] = true;\\n    int t = stoi(target);\\n\\n    queue<int> q;\\n    q.push(0);\\n\\n    int res = 0;\\n    while (!q.empty()) {\\n        int n = q.size();\\n        for (int i = 0; i < n; i++) {\\n            auto s = q.front();\\n            if (s == t)\\n                return res;\\n            q.pop();\\n            if (v[s])\\n                continue;\\n            v[s] = true;\\n            for (int j = 1; j <= 1000; j *= 10) {\\n                q.push(s + ((s / j + 1) % 10 - s / j % 10) * j);\\n                q.push(s + ((s / j + 9) % 10 - s / j % 10) * j);\\n            }\\n        }\\n        res++;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765343,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> deadSet(deadends.begin(), deadends.end());\\n        if (deadSet.count(\"0000\")) return -1;\\n        queue<string> q({\"0000\"});\\n        for (int steps = 0; !q.empty(); ++steps) {\\n            for (int i = q.size(); i > 0; --i) {\\n                auto curr = q.front(); q.pop();\\n                if (curr == target) return steps;\\n                for (auto nei : neighbors(curr)) {\\n                    if (deadSet.count(nei)) continue;\\n                    deadSet.insert(nei); // Marked as visited\\n                    q.push(nei);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    vector<string> neighbors(const string& code) {\\n        vector<string> result;\\n        for (int i = 0; i < 4; i++) {\\n            for (int diff = -1; diff <= 1; diff += 2) {\\n                string nei = code;\\n                nei[i] = (nei[i] - \\'0\\' + diff + 10) % 10 + \\'0\\';\\n                result.push_back(nei);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> deadSet(deadends.begin(), deadends.end());\\n        if (deadSet.count(\"0000\")) return -1;\\n        queue<string> q({\"0000\"});\\n        for (int steps = 0; !q.empty(); ++steps) {\\n            for (int i = q.size(); i > 0; --i) {\\n                auto curr = q.front(); q.pop();\\n                if (curr == target) return steps;\\n                for (auto nei : neighbors(curr)) {\\n                    if (deadSet.count(nei)) continue;\\n                    deadSet.insert(nei); // Marked as visited\\n                    q.push(nei);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    vector<string> neighbors(const string& code) {\\n        vector<string> result;\\n        for (int i = 0; i < 4; i++) {\\n            for (int diff = -1; diff <= 1; diff += 2) {\\n                string nei = code;\\n                nei[i] = (nei[i] - \\'0\\' + diff + 10) % 10 + \\'0\\';\\n                result.push_back(nei);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600415,
                "title": "foolproof-java-solution-for-beginner",
                "content": "```JAVA\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> deadendSet = new HashSet<>();\\n        Set<String> visited = new HashSet<>();\\n        Queue<String> queue = new LinkedList<>();\\n        \\n        for(String tmp : deadends) deadendSet.add(tmp);\\n        \\n        String start = \"0000\";\\n        int step = 0;\\n        queue.offer(start);\\n        visited.add(\"0000\");\\n        \\n        while(!queue.isEmpty()){\\n            int sz = queue.size();\\n            for(int i = 0; i < sz; i++){\\n                String tmp = queue.poll();\\n                \\n                if(deadendSet.contains(tmp)) continue;\\n                if(tmp.equals(target)) return step;\\n                \\n                for(int j = 0; j < 4; j++){\\n                    String plus = plusOne(tmp, j);\\n                    String minus = minusOne(tmp, j);\\n                    \\n                    if(!visited.contains(plus)){\\n                        queue.offer(plus);\\n                        visited.add(plus);\\n                    }\\n                    \\n                    if(!visited.contains(minus)){\\n                        queue.offer(minus);\\n                        visited.add(minus);\\n                    }\\n                }   \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n    \\n    private String plusOne(String str, int index){\\n        char[] array = str.toCharArray();\\n        if(array[index] == \\'9\\'){\\n            array[index] = \\'0\\';\\n        }else{\\n            array[index] += 1;\\n        }\\n        \\n        return new String(array);\\n    }\\n    \\n    private String minusOne(String str, int index){\\n        char[] array = str.toCharArray();\\n        if(array[index] == \\'0\\'){\\n            array[index] = \\'9\\';\\n        }else{\\n            array[index] -= 1;\\n        }\\n        \\n        return new String(array);\\n    }\\n}",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> deadendSet = new HashSet<>();\\n        Set<String> visited = new HashSet<>();\\n        Queue<String> queue = new LinkedList<>();\\n        \\n        for(String tmp : deadends) deadendSet.add(tmp);\\n        \\n        String start = \"0000\";\\n        int step = 0;\\n        queue.offer(start);\\n        visited.add(\"0000\");\\n        \\n        while(!queue.isEmpty()){\\n            int sz = queue.size();\\n            for(int i = 0; i < sz; i++){\\n                String tmp = queue.poll();\\n                \\n                if(deadendSet.contains(tmp)) continue;\\n                if(tmp.equals(target)) return step;\\n                \\n                for(int j = 0; j < 4; j++){\\n                    String plus = plusOne(tmp, j);\\n                    String minus = minusOne(tmp, j);\\n                    \\n                    if(!visited.contains(plus)){\\n                        queue.offer(plus);\\n                        visited.add(plus);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2106499,
                "title": "python-without-strings-memory-less-than-100",
                "content": "Actually, it is not necessary to use strings in this problem. Since the constraints are low, we can use numbers from 0 to 9999 inclusive. Here is my code:\\n```\\nclass Solution:\\n    def openLock(self, deadends: list[str], target: str) -> int:\\n        target, turns = int(target), [0] * 10000\\n        for el in deadends:\\n            turns[int(el)] = -1\\n        dq = deque([0] * (turns[0] + 1))\\n\\n        while dq:\\n            cur = dq.popleft()\\n            if cur == target:\\n                return turns[cur]\\n\\n            for x in (10, 100, 1000, 10000):\\n                for k in (1, 9):\\n                    nxt = cur // x * x + (cur + k * x // 10) % x\\n                    if not turns[nxt]:\\n                        dq.append(nxt)\\n                        turns[nxt] = turns[cur] + 1\\n\\n        return -1\\n```\\n\\nLet me explain how I calculate the `nxt` variable. Suppose `cur=2099`.\\n\\n**x=10, k=1:**\\n1) `cur // x * x = 2099 // 10 * 10 = 209 * 10 = 2090`. Here, we effectively turn last `N` digits into zeros, where `N` is the number of zeros in `x`.\\n2) `(cur + k * x // 10) % x = (2099 + 1 * 10 // 10) % 10 = 2100 % 10 = 0`. Here, we update the last `N` digits to the next state.\\n3) `nxt = 2090 + 0 = 2090`. Thus, we have `2099 -> 2090`\\n\\n**x=10, k=9:**\\n1) `cur // x * x = 2099 // 10 * 10 = 209 * 10 = 2090`\\n2) `(cur + k * x // 10) % x = (2099 + 9 * 10 // 10) % 10 = 2108 % 10 = 8`.\\n3) `nxt = 2090 + 8 = 2098`. Thus, we have `2099 -> 2098`\\n\\n**x=100, k=1:**\\n1) `cur // x * x = 2099 // 100 * 100 = 20 * 100 = 2000`.\\n2) `(cur + k * x // 10) % x = (2099 + 1 * 100 // 10) % 100 = 2109 % 100 = 9`.\\n3) `nxt = 2000 + 9 = 2009`. Thus, we have `2099 -> 2009`\\n\\n**x=100, k=9:**\\n1) `cur // x * x = 2099 // 100 * 100 = 20 * 100 = 2000`\\n2) `(cur + k * x // 10) % x = (2099 + 9 * 100 // 10) % 100 = 2189 % 100 = 89`.\\n3) `nxt = 2000 + 89 = 2089`. Thus, we have `2099 -> 2089`\\n\\n**x=1000, k=1:**\\n1) `cur // x * x = 2099 // 1000 * 1000 = 2 * 1000 = 2000`.\\n2) `(cur + k * x // 10) % x = (2099 + 1 * 1000 // 10) % 1000 = 2199 % 1000 = 199`.\\n3) `nxt = 2000 + 199 = 2199`. Thus, we have `2099 -> 2199`\\n\\n**x=1000, k=9:**\\n1) `cur // x * x = 2099 // 1000 * 1000 = 2 * 1000 = 2000`\\n2) `(cur + k * x // 10) % x = (2099 + 9 * 1000 // 10) % 1000 = 2999 % 1000 = 999`.\\n3) `nxt = 2000 + 999 = 2999`. Thus, we have `2099 -> 2999`\\n\\nI think you got the idea behind these calculations. Other than that, my solution is a plain BFS algo. Hopefully, it is clear \\uD83D\\uDE09",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def openLock(self, deadends: list[str], target: str) -> int:\\n        target, turns = int(target), [0] * 10000\\n        for el in deadends:\\n            turns[int(el)] = -1\\n        dq = deque([0] * (turns[0] + 1))\\n\\n        while dq:\\n            cur = dq.popleft()\\n            if cur == target:\\n                return turns[cur]\\n\\n            for x in (10, 100, 1000, 10000):\\n                for k in (1, 9):\\n                    nxt = cur // x * x + (cur + k * x // 10) % x\\n                    if not turns[nxt]:\\n                        dq.append(nxt)\\n                        turns[nxt] = turns[cur] + 1\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286684,
                "title": "bfs-cpp-solution",
                "content": "```\\nunordered_map<string,bool> convertToMap(vector<string>&vec){\\n    unordered_map<string,bool> deadEnds;\\n    for( int i=0;i<vec.size();i++){\\n        deadEnds[vec[i]]=true;\\n    }\\n    return deadEnds;\\n}\\n\\n\\n\\nint open(vector<string>&deadends, string target){\\n    unordered_map<string,bool> deadEnds = convertToMap(deadends);\\n    \\n    unordered_map<string,bool> visited;\\n    queue<pair<string,int>> stats;\\n    // insert the first state\\n    if (!deadEnds[\"0000\"])\\n   { stats.push({\"0000\",0});\\n    visited[\"0000\"]=true;}\\n    \\n    \\n    while(!stats.empty()){\\n        pair<string,int> p;\\n        string str;\\n        \\n        p = stats.front();\\n        stats.pop();\\n        \\n        str= p.first; \\n        \\n        if (str == target){\\n            return p.second;\\n        }\\n            \\n        int ring =4;\\n        while(ring--){\\n            char c = str[ring],b,a;\\n            \\n            b= (10 + (c-\\'0\\')-1)%10 +\\'0\\';\\n            a= (10 + (c-\\'0\\')+1)%10 + \\'0\\';\\n             \\n            str[ring]=a;\\n            if( !visited[str] && !deadEnds[str]){\\n                stats.push({str,p.second+1});\\n                visited[str]=true;\\n            }\\n            \\n            str[ring]=b;\\n            if( !visited[str] && !deadEnds[str]){\\n                stats.push({str,p.second+1});\\n                 visited[str]=true;\\n            }\\n            \\n            str[ring]=c;\\n        }\\n    }\\n    \\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        return open(deadends, target);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nunordered_map<string,bool> convertToMap(vector<string>&vec){\\n    unordered_map<string,bool> deadEnds;\\n    for( int i=0;i<vec.size();i++){\\n        deadEnds[vec[i]]=true;\\n    }\\n    return deadEnds;\\n}\\n\\n\\n\\nint open(vector<string>&deadends, string target){\\n    unordered_map<string,bool> deadEnds = convertToMap(deadends);\\n    \\n    unordered_map<string,bool> visited;\\n    queue<pair<string,int>> stats;\\n    // insert the first state\\n    if (!deadEnds[\"0000\"])\\n   { stats.push({\"0000\",0});\\n    visited[\"0000\"]=true;}\\n    \\n    \\n    while(!stats.empty()){\\n        pair<string,int> p;\\n        string str;\\n        \\n        p = stats.front();\\n        stats.pop();\\n        \\n        str= p.first; \\n        \\n        if (str == target){\\n            return p.second;\\n        }\\n            \\n        int ring =4;\\n        while(ring--){\\n            char c = str[ring],b,a;\\n            \\n            b= (10 + (c-\\'0\\')-1)%10 +\\'0\\';\\n            a= (10 + (c-\\'0\\')+1)%10 + \\'0\\';\\n             \\n            str[ring]=a;\\n            if( !visited[str] && !deadEnds[str]){\\n                stats.push({str,p.second+1});\\n                visited[str]=true;\\n            }\\n            \\n            str[ring]=b;\\n            if( !visited[str] && !deadEnds[str]){\\n                stats.push({str,p.second+1});\\n                 visited[str]=true;\\n            }\\n            \\n            str[ring]=c;\\n        }\\n    }\\n    \\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        return open(deadends, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251560,
                "title": "simple-bfs-c-solution-with-algorithm-explanation",
                "content": "We have a starting point and an ending point given in the form of string, the question asks us to get from start to end point in minimum number of turns. This makes me think that it\\'s a BFS problem. \\n\\nThe starting point is \"0000\". \\n\\n**What are the neighbors for a current string we are looking at?**\\n\\nWe can only change one character at a time, we can either add 1 to it or subtract 1 from it, which will be counted as a single move (and thus this will be a neighbor of current string that we can potentially explore). We can make a check for the rollback thing, basically if after subtracting, you get a negative number, convert that to 9. Then we should explore all the neighbors obtained this way. Do this for each character in the current string and keep on pushing the neighbors into the queue.\\n\\nI think figuring out neighbors like this is the only trickiest part in the problem. Rest is standard BFS.\\n\\n1. Create a visited set to avoid processing the strings that were already processed before.\\n2. Increment the number of turns each time when you finish processing strings on a particular level of queue.\\n3. Before you start processing a popped string from queue, add a check: if it\\'s a deadend, just continue. If you hit the target, return the turns made so far (since we are going level by level, turns will be the minimum number of turns required to reach the target).\\n\\n**C++ implementation**:\\n\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> st(deadends.begin(), deadends.end()); // convert the vector into set for faster search\\n        int turns = 0;\\n        \\n        string start = \"0000\";\\n        \\n        queue<string> q;\\n        q.push(start);\\n        unordered_set<string> seen;\\n\\t\\tseen.insert(start);\\n        \\n        while (!q.empty()) {\\n            int sz = q.size();\\n            while (sz--) {\\n                string curr = q.front();\\n                q.pop();\\n                if (curr == target) return turns;\\n                if (st.count(curr)) continue;\\n                for (char& c : curr) {\\n                    int temp = c - \\'0\\';\\n                    int nextInt = (temp + 1) % 10;\\n                    int prevInt = (temp - 1) % 10;\\n                    if (prevInt < 0) prevInt = 9;\\n                    c = nextInt + \\'0\\';\\n                    if (!seen.count(curr)) {\\n                        seen.insert(curr);\\n                        q.push(curr); \\n                    }\\n                    c = prevInt + \\'0\\';\\n                    if (!seen.count(curr)) {\\n                        seen.insert(curr);\\n                        q.push(curr);\\n                    }\\n                    c = temp + \\'0\\'; // reverting it back to the original character before moving onto next character\\n                }\\n            }\\n            turns++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> st(deadends.begin(), deadends.end()); // convert the vector into set for faster search\\n        int turns = 0;\\n        \\n        string start = \"0000\";\\n        \\n        queue<string> q;\\n        q.push(start);\\n        unordered_set<string> seen;\\n\\t\\tseen.insert(start);\\n        \\n        while (!q.empty()) {\\n            int sz = q.size();\\n            while (sz--) {\\n                string curr = q.front();\\n                q.pop();\\n                if (curr == target) return turns;\\n                if (st.count(curr)) continue;\\n                for (char& c : curr) {\\n                    int temp = c - \\'0\\';\\n                    int nextInt = (temp + 1) % 10;\\n                    int prevInt = (temp - 1) % 10;\\n                    if (prevInt < 0) prevInt = 9;\\n                    c = nextInt + \\'0\\';\\n                    if (!seen.count(curr)) {\\n                        seen.insert(curr);\\n                        q.push(curr); \\n                    }\\n                    c = prevInt + \\'0\\';\\n                    if (!seen.count(curr)) {\\n                        seen.insert(curr);\\n                        q.push(curr);\\n                    }\\n                    c = temp + \\'0\\'; // reverting it back to the original character before moving onto next character\\n                }\\n            }\\n            turns++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251501,
                "title": "python-bi-directional-a-star-bfs-99-7-52ms-14-3mb",
                "content": "Idea is to do Bi-Directional BFS between source `\"0000\"` and `target`. \\n\\n>Anytime with BFS, if you can caculate closeness of current point to the target, replacing `queue` with `priority-queue` (sorted based on closeness), we can implement A-star search algorithm.\\n\\nThis provides us to explore closest paths first compared to going through each level one by one.\\n\\nThis also garentees shortest path, because every step is of unit distance.\\n\\nAdapting the idea of Bi-Directional search, we can spin up A-Start search from both `start` and `end`, then return the steps count, when both meets. \\n\\nFrom `start` target will be `end`, i.e closeness of each point in `start_queue` is calculated w.r.t `end`.\\nFrom `end` target will be `start`,  i.e closeness of each point in `end_queue` is calculated w.r.t `start`.\\n\\nWe maintain `start_visited` and `end_visited` hash_maps to keep track of visited nodes and also steps count took to reach them.\\n\\n- Time: O(E) where `E` is the number of edges possible in the search space.\\n- Extra Spce: O(V) where `V` is the number of intermediates nodes.\\n\\n```python\\nclass Solution:\\n    def openLock(self, deadends: List[str], end: str) -> int:\\n        if end in deadends or \"0000\" in deadends:\\n            return -1\\n        if end == \"0000\":\\n            return 0\\n        start, end, deadends = 0, int(end), {int(deadend) for deadend in deadends}\\n\\n        def distance(cur: int, target: int) -> int:\\n            diff = 0\\n            for _ in range(4):\\n                a, b = cur % 10, target % 10\\n                d = abs(a - b)\\n                diff += min(d, 10 - d)\\n                cur, target = cur // 10, target // 10\\n            return diff\\n\\n\\t\\tdef turn_knob(cur: int, idx: int) -> Tuple[int, int]:\\n\\t\\t\\tindex = 10 ** idx\\n\\t\\t\\tdigit = cur // index % 10\\n\\t\\t\\tup = cur - 9 * index if digit == 9 else cur + index\\n\\t\\t\\tdown = cur - index if digit else cur + 9 * index\\n\\t\\t\\treturn up, down\\n\\n        def process(\\n            this_q: List[int], this_v: Dict[int, int], other_v: Dict[int, int], target: int\\n        ) -> int:\\n            _, cur = heappop(this_q)\\n            step = this_v[cur]\\n            for i in range(4):\\n                up, down = turn_knob(cur, i)\\n                if up in other_v:\\n                    return step + other_v[up] + 1\\n                if down in other_v:\\n                    return step + other_v[down] + 1\\n                if up not in deadends and up not in this_v:\\n                    this_v[up] = step + 1\\n                    this_q.append((distance(up, target), up))\\n                if down not in deadends and down not in this_v:\\n                    this_v[down] = step + 1\\n                    this_q.append((distance(down, target), down))\\n            heapify(this_q)\\n            return None\\n\\n        s_q, s_v = [(distance(start, end), start)], {start: 0}\\n        e_q, e_v = [(distance(end, start), end)], {end: 0}\\n        while s_q and e_q:\\n            s = process(s_q, s_v, e_v, end)\\n            if s: return s\\n            e = process(e_q, e_v, s_v, start)\\n            if e: return e\\n        return -1\\n```\\n\\n**Time: 52ms == 99.76%\\nSpace: 14.5MB == 98.98%**",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def openLock(self, deadends: List[str], end: str) -> int:\\n        if end in deadends or \"0000\" in deadends:\\n            return -1\\n        if end == \"0000\":\\n            return 0\\n        start, end, deadends = 0, int(end), {int(deadend) for deadend in deadends}\\n\\n        def distance(cur: int, target: int) -> int:\\n            diff = 0\\n            for _ in range(4):\\n                a, b = cur % 10, target % 10\\n                d = abs(a - b)\\n                diff += min(d, 10 - d)\\n                cur, target = cur // 10, target // 10\\n            return diff\\n\\n\\t\\tdef turn_knob(cur: int, idx: int) -> Tuple[int, int]:\\n\\t\\t\\tindex = 10 ** idx\\n\\t\\t\\tdigit = cur // index % 10\\n\\t\\t\\tup = cur - 9 * index if digit == 9 else cur + index\\n\\t\\t\\tdown = cur - index if digit else cur + 9 * index\\n\\t\\t\\treturn up, down\\n\\n        def process(\\n            this_q: List[int], this_v: Dict[int, int], other_v: Dict[int, int], target: int\\n        ) -> int:\\n            _, cur = heappop(this_q)\\n            step = this_v[cur]\\n            for i in range(4):\\n                up, down = turn_knob(cur, i)\\n                if up in other_v:\\n                    return step + other_v[up] + 1\\n                if down in other_v:\\n                    return step + other_v[down] + 1\\n                if up not in deadends and up not in this_v:\\n                    this_v[up] = step + 1\\n                    this_q.append((distance(up, target), up))\\n                if down not in deadends and down not in this_v:\\n                    this_v[down] = step + 1\\n                    this_q.append((distance(down, target), down))\\n            heapify(this_q)\\n            return None\\n\\n        s_q, s_v = [(distance(start, end), start)], {start: 0}\\n        e_q, e_v = [(distance(end, start), end)], {end: 0}\\n        while s_q and e_q:\\n            s = process(s_q, s_v, e_v, end)\\n            if s: return s\\n            e = process(e_q, e_v, s_v, start)\\n            if e: return e\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251315,
                "title": "very-simple-bfs-solution-using-c-clean-and-readable",
                "content": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> dead(deadends.begin(),deadends.end());\\n        \\n        if(dead.count(\"0000\")) return -1;\\n        \\n        unordered_set<string>vis;\\n        queue<string>q;\\n        \\n        vis.insert(\"0000\");\\n        q.push(\"0000\");\\n        \\n        int level=0;\\n        \\n        while(!q.empty()){\\n            \\n            int sz=q.size();\\n            \\n            for(int i=0;i<sz;i++){\\n                string st=q.front();\\n                q.pop();\\n                \\n                if(st==target) return level;\\n                \\n                for(int i=0;i<4;i++){\\n                    \\n                    string increement=st;\\n                    increement[i]=(increement[i]-\\'0\\'==9) ? \\'0\\' : increement[i]-\\'0\\'+1+\\'0\\';\\n                    \\n                    string decreement=st;\\n                    decreement[i]=(decreement[i]-\\'0\\'==0) ? \\'9\\' : decreement[i]-\\'0\\'-1+\\'0\\';\\n                    \\n                   \\n                    if(!vis.count(increement) && !dead.count(increement)){\\n                        q.push(increement);\\n                        vis.insert(increement);\\n                    }\\n                    \\n                    if(!vis.count(decreement) && !dead.count(decreement)){\\n                        q.push(decreement);\\n                        vis.insert(decreement);\\n                    }\\n                    \\n                    \\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> dead(deadends.begin(),deadends.end());\\n        \\n        if(dead.count(\"0000\")) return -1;\\n        \\n        unordered_set<string>vis;\\n        queue<string>q;\\n        \\n        vis.insert(\"0000\");\\n        q.push(\"0000\");\\n        \\n        int level=0;\\n        \\n        while(!q.empty()){\\n            \\n            int sz=q.size();\\n            \\n            for(int i=0;i<sz;i++){\\n                string st=q.front();\\n                q.pop();\\n                \\n                if(st==target) return level;\\n                \\n                for(int i=0;i<4;i++){\\n                    \\n                    string increement=st;\\n                    increement[i]=(increement[i]-\\'0\\'==9) ? \\'0\\' : increement[i]-\\'0\\'+1+\\'0\\';\\n                    \\n                    string decreement=st;\\n                    decreement[i]=(decreement[i]-\\'0\\'==0) ? \\'9\\' : decreement[i]-\\'0\\'-1+\\'0\\';\\n                    \\n                   \\n                    if(!vis.count(increement) && !dead.count(increement)){\\n                        q.push(increement);\\n                        vis.insert(increement);\\n                    }\\n                    \\n                    if(!vis.count(decreement) && !dead.count(decreement)){\\n                        q.push(decreement);\\n                        vis.insert(decreement);\\n                    }\\n                    \\n                    \\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250730,
                "title": "open-the-lock-java-modified-djikstra-s-algorithm-with-explanation",
                "content": "By framing this problem as finding the shortest path in a graph of lock combinations, we can use Djikstra\\'s algorithm. \\n\\nThe traditional algorithm calculates path lengths in a breadth-first-search and needs to check if the current calculated path length to a node is less than that from another path and overwrite if necessary. However, since all step distances are the same here (1 turn of the lock number) we can make use of a number of shortcuts:\\n\\n1. The first path length calculated for each node in the bfs will already be the shortest, so if we encounter it again we can skip it altogether.\\n2. We can make this a greedy algorithm and return the path length as soon as the target node is reached.\\n\\n```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        int[] v = new int[10000];\\n        for (String p : deadends) v[Integer.parseInt(p)] = -1;\\n        if (v[0] == -1) return -1; // optional, there were some examples where start was a deadend\\n\\t\\tint tar = Integer.parseInt(target);\\n\\t\\tQueue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        while (!q.isEmpty()) {\\n            int t = q.poll();\\n            if (t == tar) return v[tar]; // 2. greedy return\\n            int nextLen = v[t] + 1;\\n            for (int c = 1; c <= 1000; c *= 10) { // loop to +/- on all 4 coordinates\\n                int a = (t%(c*10))/c == 9 ? t - 9*c : t+c; // calculating higher coordinate, preventing carry over\\n                if (v[a] == 0) { // 1. only do stuff for unvisited nodes\\n\\t\\t\\t\\t\\tv[a] = nextLen; \\n\\t\\t\\t\\t\\tq.add(a); \\n\\t\\t\\t\\t}\\n                a = (t%(c*10))/c == 0 ? t + 9*c : t-c;  // calculating lower coordinate, preventing carry over\\n                if (v[a] == 0) { // 1. only do stuff for unvisited nodes\\n\\t\\t\\t\\t\\tv[a] = nextLen; \\n\\t\\t\\t\\t\\tq.add(a); \\n\\t\\t\\t\\t}\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        int[] v = new int[10000];\\n        for (String p : deadends) v[Integer.parseInt(p)] = -1;\\n        if (v[0] == -1) return -1; // optional, there were some examples where start was a deadend\\n\\t\\tint tar = Integer.parseInt(target);\\n\\t\\tQueue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        while (!q.isEmpty()) {\\n            int t = q.poll();\\n            if (t == tar) return v[tar]; // 2. greedy return\\n            int nextLen = v[t] + 1;\\n            for (int c = 1; c <= 1000; c *= 10) { // loop to +/- on all 4 coordinates\\n                int a = (t%(c*10))/c == 9 ? t - 9*c : t+c; // calculating higher coordinate, preventing carry over\\n                if (v[a] == 0) { // 1. only do stuff for unvisited nodes\\n\\t\\t\\t\\t\\tv[a] = nextLen; \\n\\t\\t\\t\\t\\tq.add(a); \\n\\t\\t\\t\\t}\\n                a = (t%(c*10))/c == 0 ? t + 9*c : t-c;  // calculating lower coordinate, preventing carry over\\n                if (v[a] == 0) { // 1. only do stuff for unvisited nodes\\n\\t\\t\\t\\t\\tv[a] = nextLen; \\n\\t\\t\\t\\t\\tq.add(a); \\n\\t\\t\\t\\t}\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212634,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int OpenLock(string[] deadends, string target) {\\n        \\n        if(target == null || target == \"\")\\n            return -1;\\n        \\n        HashSet<string> set = new HashSet<string>(deadends);\\n        if(set.Contains(\"0000\"))\\n            return -1;\\n        \\n        HashSet<string> visited =  new HashSet<string>();\\n        Queue<string> queue = new Queue<string>();\\n        queue.Enqueue(\"0000\");\\n        visited.Add(\"0000\");\\n        int cnt = 0;\\n        \\n        while(queue.Count > 0)\\n        {        \\n            int size = queue.Count;\\n            for(int i = 0; i<size; i++)\\n            {      \\n                string curr = queue.Dequeue();                 \\n                if(curr == target)\\n                    return cnt;\\n                                              \\n                for(int j = 0; j < 4; j++)\\n                {  \\n                    char[] arr = curr.ToCharArray();                        \\n                    char c = arr[j];     \\n                    //arr[j] = arr[j] == \\'9\\'? \\'0\\' : Convert.ToChar(arr[j] + 1);\\n                    arr[j] = Convert.ToChar((arr[j] -\\'0\\' + 1 + 10) % 10 + \\'0\\');\\n                    string pwd = new string(arr);    \\n                    if(set.Contains(pwd))\\n                        continue;              \\n                    if(!visited.Contains(pwd))\\n                    {\\n                        queue.Enqueue(pwd);\\n                        visited.Add(pwd);\\n                    }\\n\\n                    arr[j] = c;\\n                    arr[j] = Convert.ToChar((arr[j] -\\'0\\' - 1 + 10) % 10 + \\'0\\');\\n                    pwd = new string(arr); \\n                    if(set.Contains(pwd))\\n                        continue;               \\n                    if(!visited.Contains(pwd))\\n                    {\\n                        queue.Enqueue(pwd);\\n                        visited.Add(pwd);\\n                    }\\n                }                \\n            }\\n            cnt++;\\n        }   \\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int OpenLock(string[] deadends, string target) {\\n        \\n        if(target == null || target == \"\")\\n            return -1;\\n        \\n        HashSet<string> set = new HashSet<string>(deadends);\\n        if(set.Contains(\"0000\"))\\n            return -1;\\n        \\n        HashSet<string> visited =  new HashSet<string>();\\n        Queue<string> queue = new Queue<string>();\\n        queue.Enqueue(\"0000\");\\n        visited.Add(\"0000\");\\n        int cnt = 0;\\n        \\n        while(queue.Count > 0)\\n        {        \\n            int size = queue.Count;\\n            for(int i = 0; i<size; i++)\\n            {      \\n                string curr = queue.Dequeue();                 \\n                if(curr == target)\\n                    return cnt;\\n                                              \\n                for(int j = 0; j < 4; j++)\\n                {  \\n                    char[] arr = curr.ToCharArray();                        \\n                    char c = arr[j];     \\n                    //arr[j] = arr[j] == \\'9\\'? \\'0\\' : Convert.ToChar(arr[j] + 1);\\n                    arr[j] = Convert.ToChar((arr[j] -\\'0\\' + 1 + 10) % 10 + \\'0\\');\\n                    string pwd = new string(arr);    \\n                    if(set.Contains(pwd))\\n                        continue;              \\n                    if(!visited.Contains(pwd))\\n                    {\\n                        queue.Enqueue(pwd);\\n                        visited.Add(pwd);\\n                    }\\n\\n                    arr[j] = c;\\n                    arr[j] = Convert.ToChar((arr[j] -\\'0\\' - 1 + 10) % 10 + \\'0\\');\\n                    pwd = new string(arr); \\n                    if(set.Contains(pwd))\\n                        continue;               \\n                    if(!visited.Contains(pwd))\\n                    {\\n                        queue.Enqueue(pwd);\\n                        visited.Add(pwd);\\n                    }\\n                }                \\n            }\\n            cnt++;\\n        }   \\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1196469,
                "title": "java-easy-bfs-with-loads-of-explanation-in-comments",
                "content": "Hey wait! Before you check out the code. If you view this and you like it or found it helpful please give it a like. I\\'m trying to get my metrics up. Thanks!\\n```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        // we need a set to add our deadends to so we can see if our current combo that we would check\\n        // is a deadend and therefore not try to move in any direction as if we had hit that deadend\\n        Set<String> deads = new HashSet();\\n        for (String deadend: deadends) deads.add(deadend);\\n        \\n        // need a seen set so we make sure we\\'re not constantly adding the same combos to our queue\\n        Set<String> seen = new HashSet();\\n        \\n        // need a queue to store our combos so we can BFS through all possibilities\\n        Queue<String> combos = new LinkedList<>();\\n        // we start from 0000 and nulls represent a new level for us\\n        combos.add(\"0000\");\\n        combos.add(null);\\n        \\n        // must keep track of potential # of spins (levels || nulls)\\n        int spins = 0;\\n\\n        // keep going while you have posibilities        \\n        while (!combos.isEmpty()) {\\n            // our possible combination derives from where we could have spun our lock last turn\\n            String combo = combos.poll();\\n            // if the combination is null that means we\\'ve hit a new level\\n            if (combo == null) {\\n                // if there are more attempts in the queue we need to add a new level\\n                if (combos.peek() != null) {\\n                    // so we increase the number of spins to reach this point and add a level\\n                    spins++;\\n                    combos.add(null);\\n                }\\n            } else if (combo.equals(target)) {\\n                // if we find our target return how many spins it took to get there\\n                return spins;\\n            } else if (!deads.contains(combo)) {\\n                // if our combo is not a deadspin that means we can queue up to our next 8 possible combinations\\n                \\n                // this represents our 4 locks\\n                for (int i = 0; i < 4; i++) {\\n                    // this represents the directions we could spin each lock\\n                    for (int j = -1; j <= 1; j+=2) {\\n                        // now we get the value of the lock we\\'re changing\\n                        int lock = combo.charAt(i) - \\'0\\';\\n                        // find out what the value would be after our spin\\n                        int changedValue = (lock + j + 10) % 10;\\n                        // create the new combo by replacing the old lock\\n                        String newCombo = combo.substring(0, i) + (\"\" + changedValue) + combo.substring(i+1, 4);\\n                        // if this is a combo we\\'ve yet to see before\\n                        if (!seen.contains(newCombo)) {\\n                            // then add it to the possible combos\\n                            // and to the seen set so we don\\'t repeat it in the future.\\n                            combos.add(newCombo);\\n                            seen.add(newCombo);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        // we need a set to add our deadends to so we can see if our current combo that we would check\\n        // is a deadend and therefore not try to move in any direction as if we had hit that deadend\\n        Set<String> deads = new HashSet();\\n        for (String deadend: deadends) deads.add(deadend);\\n        \\n        // need a seen set so we make sure we\\'re not constantly adding the same combos to our queue\\n        Set<String> seen = new HashSet();\\n        \\n        // need a queue to store our combos so we can BFS through all possibilities\\n        Queue<String> combos = new LinkedList<>();\\n        // we start from 0000 and nulls represent a new level for us\\n        combos.add(\"0000\");\\n        combos.add(null);\\n        \\n        // must keep track of potential # of spins (levels || nulls)\\n        int spins = 0;\\n\\n        // keep going while you have posibilities        \\n        while (!combos.isEmpty()) {\\n            // our possible combination derives from where we could have spun our lock last turn\\n            String combo = combos.poll();\\n            // if the combination is null that means we\\'ve hit a new level\\n            if (combo == null) {\\n                // if there are more attempts in the queue we need to add a new level\\n                if (combos.peek() != null) {\\n                    // so we increase the number of spins to reach this point and add a level\\n                    spins++;\\n                    combos.add(null);\\n                }\\n            } else if (combo.equals(target)) {\\n                // if we find our target return how many spins it took to get there\\n                return spins;\\n            } else if (!deads.contains(combo)) {\\n                // if our combo is not a deadspin that means we can queue up to our next 8 possible combinations\\n                \\n                // this represents our 4 locks\\n                for (int i = 0; i < 4; i++) {\\n                    // this represents the directions we could spin each lock\\n                    for (int j = -1; j <= 1; j+=2) {\\n                        // now we get the value of the lock we\\'re changing\\n                        int lock = combo.charAt(i) - \\'0\\';\\n                        // find out what the value would be after our spin\\n                        int changedValue = (lock + j + 10) % 10;\\n                        // create the new combo by replacing the old lock\\n                        String newCombo = combo.substring(0, i) + (\"\" + changedValue) + combo.substring(i+1, 4);\\n                        // if this is a combo we\\'ve yet to see before\\n                        if (!seen.contains(newCombo)) {\\n                            // then add it to the possible combos\\n                            // and to the seen set so we don\\'t repeat it in the future.\\n                            combos.add(newCombo);\\n                            seen.add(newCombo);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153814,
                "title": "c-bfs-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> us;\\n        unordered_set<string> us1;\\n        for(int i=0;i<deadends.size();i++)\\n        {\\n            us.insert(deadends[i]);\\n        }\\n        queue<string> q;\\n        if(us.find(\"0000\")==us.end())\\n        {\\n            q.push(\"0000\");\\n            us1.insert(\"0000\");\\n        }\\n        int level=0;\\n        char change[10]={\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\',\\'0\\'};\\n        char revcha[10]={\\'9\\',\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\'};\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                string s=q.front();\\n                if(s==target)\\n                {\\n                    return level;\\n                }\\n                q.pop();\\n                string a,b;\\n                for(int j=3;j>=0;j--)\\n                {\\n                    a=s;b=s;\\n                    a[j]=change[s[j]-\\'0\\'];\\n                    b[j]=revcha[s[j]-\\'0\\'];\\n                    if(us.find(a)==us.end() && us1.find(a)==us1.end())\\n                    {\\n                        q.push(a);\\n                        us1.insert(a);\\n                    }\\n                    if(us.find(b)==us.end() && us1.find(b)==us1.end())\\n                    {\\n                        q.push(b);\\n                        us1.insert(b);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> us;\\n        unordered_set<string> us1;\\n        for(int i=0;i<deadends.size();i++)\\n        {\\n            us.insert(deadends[i]);\\n        }\\n        queue<string> q;\\n        if(us.find(\"0000\")==us.end())\\n        {\\n            q.push(\"0000\");\\n            us1.insert(\"0000\");\\n        }\\n        int level=0;\\n        char change[10]={\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\',\\'0\\'};\\n        char revcha[10]={\\'9\\',\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\'};\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                string s=q.front();\\n                if(s==target)\\n                {\\n                    return level;\\n                }\\n                q.pop();\\n                string a,b;\\n                for(int j=3;j>=0;j--)\\n                {\\n                    a=s;b=s;\\n                    a[j]=change[s[j]-\\'0\\'];\\n                    b[j]=revcha[s[j]-\\'0\\'];\\n                    if(us.find(a)==us.end() && us1.find(a)==us1.end())\\n                    {\\n                        q.push(a);\\n                        us1.insert(a);\\n                    }\\n                    if(us.find(b)==us.end() && us1.find(b)==us1.end())\\n                    {\\n                        q.push(b);\\n                        us1.insert(b);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117121,
                "title": "javascript-simple-bfs-approach",
                "content": "```javascript\\nvar openLock = function(deadends, target) {\\n    const blocked = new Set(deadends);\\n    const visited = new Set();\\n    \\n    if(blocked.has(\\'0000\\')) return -1;\\n    visited.add(\\'0000\\');\\n    \\n    let queue = [\\'0000\\'];\\n    let dist = 0;\\n    \\n    while(queue.length) {\\n        const nextQueue = []\\n        \\n        for(let comb of queue) {\\n            if(comb === target) return dist;\\n\\n            for(let i = 0; i < comb.length; i++) {\\n                const up = (+comb[i] + 1) % 10;\\n                const down = (+comb[i] + 9) % 10;\\n                \\n                const nextUp = comb.slice(0, i) + up + comb.slice(i+1);\\n                const nextDown = comb.slice(0, i) + down + comb.slice(i+1);\\n                \\n                if(!visited.has(nextUp) && !blocked.has(nextUp)) {\\n                    nextQueue.push(nextUp);\\n                    visited.add(nextUp);\\n                }\\n                if(!visited.has(nextDown) && !blocked.has(nextDown)) {\\n                    nextQueue.push(nextDown);\\n                    visited.add(nextDown)\\n                }\\n            }\\n        }\\n        dist++;\\n        queue = nextQueue;\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\nvar openLock = function(deadends, target) {\\n    const blocked = new Set(deadends);\\n    const visited = new Set();\\n    \\n    if(blocked.has(\\'0000\\')) return -1;\\n    visited.add(\\'0000\\');\\n    \\n    let queue = [\\'0000\\'];\\n    let dist = 0;\\n    \\n    while(queue.length) {\\n        const nextQueue = []\\n        \\n        for(let comb of queue) {\\n            if(comb === target) return dist;\\n\\n            for(let i = 0; i < comb.length; i++) {\\n                const up = (+comb[i] + 1) % 10;\\n                const down = (+comb[i] + 9) % 10;\\n                \\n                const nextUp = comb.slice(0, i) + up + comb.slice(i+1);\\n                const nextDown = comb.slice(0, i) + down + comb.slice(i+1);\\n                \\n                if(!visited.has(nextUp) && !blocked.has(nextUp)) {\\n                    nextQueue.push(nextUp);\\n                    visited.add(nextUp);\\n                }\\n                if(!visited.has(nextDown) && !blocked.has(nextDown)) {\\n                    nextQueue.push(nextDown);\\n                    visited.add(nextDown)\\n                }\\n            }\\n        }\\n        dist++;\\n        queue = nextQueue;\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 917930,
                "title": "c-simple-and-easy-to-understand-bfs-approach",
                "content": "Using BFS approach similar to rotten oranges.\\n\\nIf you face any problem , feel free to ask in comments.\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        queue<string> q; \\n        \\n        unordered_map<string,bool> visited;\\n        int ans=0;\\n        for(int i=0;i<deadends.size();i++){\\n            visited[deadends[i]]=true;\\n        }\\n        if(!visited[\"0000\"])\\n            q.push(\"0000\");\\n        while(!q.empty()){\\n            int qsize=q.size();\\n            ans++;\\n            while(qsize--){\\n                string top=q.front();\\n                q.pop();\\n            \\n                if(top==target)\\n                    return ans-1;\\n                for(int i=0;i<4;i++){\\n                    if(top[i]==\\'0\\'){\\n                        top[i]=\\'9\\';\\n                        if(visited[top]==false){\\n                            q.push(top);\\n                            visited[top]=true;\\n                        }   \\n                        top[i]=\\'0\\';\\n                    }\\n                    else{\\n                        top[i]--;\\n                        if(visited[top]==false){\\n                            q.push(top);\\n                            visited[top]=true;\\n                        }\\n                        top[i]++;\\n                    }\\n                }\\n                \\n                for(int i=0;i<4;i++){\\n                    if(top[i]==\\'9\\'){\\n                        top[i]=\\'0\\';\\n                        if(visited[top]==false){\\n                            q.push(top);\\n                            visited[top]=true;\\n                        }\\n                        top[i]=\\'9\\';\\n                    }\\n                    else{\\n                        top[i]++;\\n                        if(visited[top]==false){\\n                            q.push(top);\\n                            visited[top]=true;\\n                        }\\n                        top[i]--;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        queue<string> q; \\n        \\n        unordered_map<string,bool> visited;\\n        int ans=0;\\n        for(int i=0;i<deadends.size();i++){\\n            visited[deadends[i]]=true;\\n        }\\n        if(!visited[\"0000\"])\\n            q.push(\"0000\");\\n        while(!q.empty()){\\n            int qsize=q.size();\\n            ans++;\\n            while(qsize--){\\n                string top=q.front();\\n                q.pop();\\n            \\n                if(top==target)\\n                    return ans-1;\\n                for(int i=0;i<4;i++){\\n                    if(top[i]==\\'0\\'){\\n                        top[i]=\\'9\\';\\n                        if(visited[top]==false){\\n                            q.push(top);\\n                            visited[top]=true;\\n                        }   \\n                        top[i]=\\'0\\';\\n                    }\\n                    else{\\n                        top[i]--;\\n                        if(visited[top]==false){\\n                            q.push(top);\\n                            visited[top]=true;\\n                        }\\n                        top[i]++;\\n                    }\\n                }\\n                \\n                for(int i=0;i<4;i++){\\n                    if(top[i]==\\'9\\'){\\n                        top[i]=\\'0\\';\\n                        if(visited[top]==false){\\n                            q.push(top);\\n                            visited[top]=true;\\n                        }\\n                        top[i]=\\'9\\';\\n                    }\\n                    else{\\n                        top[i]++;\\n                        if(visited[top]==false){\\n                            q.push(top);\\n                            visited[top]=true;\\n                        }\\n                        top[i]--;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693149,
                "title": "python-a-dijkstra-i-e-weighted-graph-priority-queue",
                "content": "We can treat this problem as a graph problem in finding the smallest path from source node to target node. We first let each pattern, i.e. 0000 or 1234, being a node and the distance between nodes like 1234 and 2234 is one. Thus, while traversing through each node from the source, we calculate, for the neighbor nodes, what\\'s their weighting distance (A*) to the target node and push the neighbor nodes into a min heap. Then, at each iteration, we only pop out the nodes that are closest to the target node.\\n\\nTime complexity: O(ElogE + EN(logE+N)) ~ O(ElogE), where E = A^N, A = 10, and N =4. \\nSpace complexity: O(E)\\n\\n**Python**\\n```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        # E = A^10, N = 4, A = 10\\n        def _distance(pattern1:str, pattern2:str):\\n            distance = 0\\n            for ch1, ch2 in zip(pattern1, pattern2):\\n                d1 = abs(int(ch1) - int(ch2))\\n                d2 = abs(10 - d1)\\n                distance += min(d1, d2)\\n            return distance\\n        \\n        def _next_patterns(pattern):\\n            tmp = pattern\\n            output = []\\n            for i, ch in enumerate(pattern):\\n                # Forward\\n                rep = \\'0\\' if ch == \\'9\\' else chr(ord(ch) + 1)\\n                output.append(tmp[:i] + rep + tmp[i+1:])\\n                # backward\\n                rep = \\'9\\' if ch == \\'0\\' else chr(ord(ch) - 1)\\n                output.append(tmp[:i] + rep + tmp[i+1:])\\n            return output\\n        \\n        from heapq import heappush, heappop\\n        heap = [(0, 0, target)] # distance, step, pattern\\n        visited = set(deadends)\\n        \\n        while heap:\\n            _, step, cur_pattern = heappop(heap)\\n            if cur_pattern == \"0000\":\\n                return step\\n\\n            for next_pattern in _next_patterns(cur_pattern):\\n                if next_pattern not in visited:\\n                    visited.add(next_pattern)\\n                    heappush(heap, (step + 1 + _distance(next_pattern, \"0000\"),\\n                                    step + 1, next_pattern))\\n        return -1\\n```            \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        # E = A^10, N = 4, A = 10\\n        def _distance(pattern1:str, pattern2:str):\\n            distance = 0\\n            for ch1, ch2 in zip(pattern1, pattern2):\\n                d1 = abs(int(ch1) - int(ch2))\\n                d2 = abs(10 - d1)\\n                distance += min(d1, d2)\\n            return distance\\n        \\n        def _next_patterns(pattern):\\n            tmp = pattern\\n            output = []\\n            for i, ch in enumerate(pattern):\\n                # Forward\\n                rep = \\'0\\' if ch == \\'9\\' else chr(ord(ch) + 1)\\n                output.append(tmp[:i] + rep + tmp[i+1:])\\n                # backward\\n                rep = \\'9\\' if ch == \\'0\\' else chr(ord(ch) - 1)\\n                output.append(tmp[:i] + rep + tmp[i+1:])\\n            return output\\n        \\n        from heapq import heappush, heappop\\n        heap = [(0, 0, target)] # distance, step, pattern\\n        visited = set(deadends)\\n        \\n        while heap:\\n            _, step, cur_pattern = heappop(heap)\\n            if cur_pattern == \"0000\":\\n                return step\\n\\n            for next_pattern in _next_patterns(cur_pattern):\\n                if next_pattern not in visited:\\n                    visited.add(next_pattern)\\n                    heappush(heap, (step + 1 + _distance(next_pattern, \"0000\"),\\n                                    step + 1, next_pattern))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609147,
                "title": "c-readable-solution",
                "content": "```\\n    public int OpenLock(string[] dead, string target) {\\n        const string start = \"0000\";\\n        var deadEnds = dead.ToHashSet();\\n        if (!deadEnds.Add(start) && start != target) return -1;\\n        var queue = new Queue<string>(new[] {start});\\n\\n        for (var step = 0; queue.Count > 0; step++)\\n        for (var thisStepStates = queue.Count; thisStepStates > 0; thisStepStates--) {\\n            var state = queue.Dequeue();\\n            if (state == target) return step;\\n            foreach (var nextState in GetNextStates(state))\\n                if (deadEnds.Add(nextState)) queue.Enqueue(nextState);\\n        }\\n        return -1;\\n    }\\n\\n    private static IEnumerable<string> GetNextStates(string state) {\\n        for (var wheel = 0; wheel < 4; wheel++) {\\n            yield return MoveUp(state, wheel);\\n            yield return MoveDown(state, wheel);\\n        }\\n    }\\n\\n    private static string MoveUp(string state, int wheel) {\\n        var builder = new StringBuilder(state);\\n        builder[wheel] = Inc(builder[wheel]);\\n        return builder.ToString();\\n    }\\n\\n    private static string MoveDown(string state, int wheel) {\\n        var builder = new StringBuilder(state);\\n        builder[wheel] = Dec(builder[wheel]);\\n        return builder.ToString();\\n    }\\n\\n    private static char Inc(char value) => (char) ((value - \\'0\\' + 1) % 10 + \\'0\\');\\n    private static char Dec(char value) => (char) ((value - \\'0\\' + 9) % 10 + \\'0\\');\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n    public int OpenLock(string[] dead, string target) {\\n        const string start = \"0000\";\\n        var deadEnds = dead.ToHashSet();\\n        if (!deadEnds.Add(start) && start != target) return -1;\\n        var queue = new Queue<string>(new[] {start});\\n\\n        for (var step = 0; queue.Count > 0; step++)\\n        for (var thisStepStates = queue.Count; thisStepStates > 0; thisStepStates--) {\\n            var state = queue.Dequeue();\\n            if (state == target) return step;\\n            foreach (var nextState in GetNextStates(state))\\n                if (deadEnds.Add(nextState)) queue.Enqueue(nextState);\\n        }\\n        return -1;\\n    }\\n\\n    private static IEnumerable<string> GetNextStates(string state) {\\n        for (var wheel = 0; wheel < 4; wheel++) {\\n            yield return MoveUp(state, wheel);\\n            yield return MoveDown(state, wheel);\\n        }\\n    }\\n\\n    private static string MoveUp(string state, int wheel) {\\n        var builder = new StringBuilder(state);\\n        builder[wheel] = Inc(builder[wheel]);\\n        return builder.ToString();\\n    }\\n\\n    private static string MoveDown(string state, int wheel) {\\n        var builder = new StringBuilder(state);\\n        builder[wheel] = Dec(builder[wheel]);\\n        return builder.ToString();\\n    }\\n\\n    private static char Inc(char value) => (char) ((value - \\'0\\' + 1) % 10 + \\'0\\');\\n    private static char Dec(char value) => (char) ((value - \\'0\\' + 9) % 10 + \\'0\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506796,
                "title": "c-bfs-solution",
                "content": "```\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> dl;\\n        for(auto & e : deadends) dl.insert(e);\\n        if(dl.find(\"0000\") != dl.end()) return -1;\\n        \\n        queue<string> q;\\n        q.push(\"0000\");\\n        dl.insert(\"0000\");\\n        \\n        int step = 0;\\n        while(!q.empty()) {\\n            for(int sz = q.size(); sz > 0; sz--) {\\n                string cur = q.front();\\n                q.pop();\\n                \\n                if(cur == target) return step;\\n                \\n                for(int i = 0; i < 4; i++) {\\n                    char oc = cur[i];\\n                    int orig = oc - \\'0\\';\\n                    for(int j = -1; j <= 1; j++) {\\n                        if(j == 0) continue;\\n                        int nxt = (orig + j + 10)%10;\\n                        char nc = nxt + \\'0\\';\\n                        cur[i] = nc;\\n                        \\n                        if(dl.find(cur) == dl.end()) {\\n                            dl.insert(cur);\\n                            q.push(cur);\\n                        }\\n                    }\\n                    cur[i] = oc;\\n                }\\n            }\\n            step++;\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> dl;\\n        for(auto & e : deadends) dl.insert(e);\\n        if(dl.find(\"0000\") != dl.end()) return -1;\\n        \\n        queue<string> q;\\n        q.push(\"0000\");\\n        dl.insert(\"0000\");\\n        \\n        int step = 0;\\n        while(!q.empty()) {\\n            for(int sz = q.size(); sz > 0; sz--) {\\n                string cur = q.front();\\n                q.pop();\\n                \\n                if(cur == target) return step;\\n                \\n                for(int i = 0; i < 4; i++) {\\n                    char oc = cur[i];\\n                    int orig = oc - \\'0\\';\\n                    for(int j = -1; j <= 1; j++) {\\n                        if(j == 0) continue;\\n                        int nxt = (orig + j + 10)%10;\\n                        char nc = nxt + \\'0\\';\\n                        cur[i] = nc;\\n                        \\n                        if(dl.find(cur) == dl.end()) {\\n                            dl.insert(cur);\\n                            q.push(cur);\\n                        }\\n                    }\\n                    cur[i] = oc;\\n                }\\n            }\\n            step++;\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506382,
                "title": "java-solution-using-trivial-bfs-with-runtime-85-ms",
                "content": "```\\nclass Solution {\\n    static Set<String> dSet;\\n\\n    public int openLock(String[] deadends, String target) {\\n        dSet = new HashSet<>(Arrays.asList(deadends));\\n        if (dSet.contains(\"0000\")) return -1;\\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(\"0000\");\\n        int res = 0;\\n        Set<String> visited = new HashSet<>();\\n        visited.add(\"0000\");\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                String tmp = queue.poll();\\n                if (tmp.equals(target)) return res;\\n                for (String neighbor : getNeighbors(tmp)) {\\n                    if (visited.contains(neighbor)) continue;\\n                    queue.add(neighbor);\\n                    visited.add(neighbor);\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n\\n    public static List<String> getNeighbors(String s) {\\n        List<String> res = new ArrayList<>();\\n        char[] arr = s.toCharArray();\\n        for (int i = 0; i < 4; i++) {\\n            char c = arr[i];\\n            //increase\\n            if (c == \\'9\\') arr[i] = \\'0\\';\\n            else arr[i] = (char) (c + 1);\\n            String tmp = new String(arr);\\n            if (!dSet.contains(tmp))\\n                res.add(tmp);\\n            //decrease\\n            if (c == \\'0\\') arr[i] = \\'9\\';\\n            else arr[i] = (char) (c - 1);\\n            tmp = new String(arr);\\n            if (!dSet.contains(tmp))\\n                res.add(tmp);\\n            //reverse\\n            arr[i] = c;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static Set<String> dSet;\\n\\n    public int openLock(String[] deadends, String target) {\\n        dSet = new HashSet<>(Arrays.asList(deadends));\\n        if (dSet.contains(\"0000\")) return -1;\\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(\"0000\");\\n        int res = 0;\\n        Set<String> visited = new HashSet<>();\\n        visited.add(\"0000\");\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                String tmp = queue.poll();\\n                if (tmp.equals(target)) return res;\\n                for (String neighbor : getNeighbors(tmp)) {\\n                    if (visited.contains(neighbor)) continue;\\n                    queue.add(neighbor);\\n                    visited.add(neighbor);\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n\\n    public static List<String> getNeighbors(String s) {\\n        List<String> res = new ArrayList<>();\\n        char[] arr = s.toCharArray();\\n        for (int i = 0; i < 4; i++) {\\n            char c = arr[i];\\n            //increase\\n            if (c == \\'9\\') arr[i] = \\'0\\';\\n            else arr[i] = (char) (c + 1);\\n            String tmp = new String(arr);\\n            if (!dSet.contains(tmp))\\n                res.add(tmp);\\n            //decrease\\n            if (c == \\'0\\') arr[i] = \\'9\\';\\n            else arr[i] = (char) (c - 1);\\n            tmp = new String(arr);\\n            if (!dSet.contains(tmp))\\n                res.add(tmp);\\n            //reverse\\n            arr[i] = c;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474813,
                "title": "bi-directional-bfs-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    const vector<char> next = {\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\', \\'0\\'};\\n    const vector<char> prev = {\\'9\\', \\'0\\', \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\'};\\n    \\n    bool bfsStep(queue<string>& q, unordered_set<string>& visited, int& depth, const unordered_set<string>& otherVisited) {\\n        int qSize = q.size();\\n            \\n        for (int i = 0; i < qSize; ++i) {\\n            auto front = q.front(); q.pop();\\n\\n            if (otherVisited.find(front) != otherVisited.end()) {\\n                return true;\\n            }\\n\\n            string child = front;\\n            for (int c = 0; c < child.length(); ++c) {\\n                child[c] = next[child[c] - \\'0\\'];\\n                if (visited.find(child) == visited.end()) {\\n                    q.push(child);\\n                    visited.insert(child);\\n                }\\n                child = front;\\n\\n                child[c] = prev[child[c] - \\'0\\'];\\n                if (visited.find(child) == visited.end()) {\\n                    q.push(child);\\n                    visited.insert(child);\\n                }\\n                child = front;\\n            }\\n        }\\n\\n        ++depth;\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    int openLock(vector<string>& deadends, const string& target) {\\n        unordered_set<string> visitedS;\\n        for (const auto& d : deadends) {\\n            \\n            // Edge case where the dead end is the start or end of the journey\\n            // In this case there is no possible solution\\n            if (d == \"0000\" || d == target)\\n                return -1;\\n            \\n            visitedS.insert(d);\\n        }\\n        auto visitedF = visitedS;\\n        \\n        queue<string> qS;\\n        qS.push(target);\\n        visitedS.insert(target);\\n        \\n        queue<string> qF;\\n        qF.push(\"0000\");\\n        visitedF.insert(\"0000\");\\n        \\n        int depthS = 0; int depthF = 0;\\n        while (!qS.empty() && !qF.empty()) {\\n            bool foundS = bfsStep(qS, visitedS, depthS, visitedF);\\n            bool foundF = bfsStep(qF, visitedF, depthF, visitedS);\\n            \\n            if (foundS || foundF) {\\n                return depthS + depthF;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    const vector<char> next = {\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\', \\'0\\'};\\n    const vector<char> prev = {\\'9\\', \\'0\\', \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\'};\\n    \\n    bool bfsStep(queue<string>& q, unordered_set<string>& visited, int& depth, const unordered_set<string>& otherVisited) {\\n        int qSize = q.size();\\n            \\n        for (int i = 0; i < qSize; ++i) {\\n            auto front = q.front(); q.pop();\\n\\n            if (otherVisited.find(front) != otherVisited.end()) {\\n                return true;\\n            }\\n\\n            string child = front;\\n            for (int c = 0; c < child.length(); ++c) {\\n                child[c] = next[child[c] - \\'0\\'];\\n                if (visited.find(child) == visited.end()) {\\n                    q.push(child);\\n                    visited.insert(child);\\n                }\\n                child = front;\\n\\n                child[c] = prev[child[c] - \\'0\\'];\\n                if (visited.find(child) == visited.end()) {\\n                    q.push(child);\\n                    visited.insert(child);\\n                }\\n                child = front;\\n            }\\n        }\\n\\n        ++depth;\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    int openLock(vector<string>& deadends, const string& target) {\\n        unordered_set<string> visitedS;\\n        for (const auto& d : deadends) {\\n            \\n            // Edge case where the dead end is the start or end of the journey\\n            // In this case there is no possible solution\\n            if (d == \"0000\" || d == target)\\n                return -1;\\n            \\n            visitedS.insert(d);\\n        }\\n        auto visitedF = visitedS;\\n        \\n        queue<string> qS;\\n        qS.push(target);\\n        visitedS.insert(target);\\n        \\n        queue<string> qF;\\n        qF.push(\"0000\");\\n        visitedF.insert(\"0000\");\\n        \\n        int depthS = 0; int depthF = 0;\\n        while (!qS.empty() && !qF.empty()) {\\n            bool foundS = bfsStep(qS, visitedS, depthS, visitedF);\\n            bool foundF = bfsStep(qF, visitedF, depthF, visitedS);\\n            \\n            if (foundS || foundF) {\\n                return depthS + depthF;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317301,
                "title": "best-of-the-bestest",
                "content": "\\tclass Solution {\\n    char digits[] = {\\'0\\', \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\'};\\n    private List<String> getNeighbors(String src) {\\n        List<String> neighbors = new ArrayList<>();\\n        \\n        for(int i=0; i<4; i++) {\\n            int idx = src.charAt(i) - \\'0\\'; \\n            String next1 = src.substring(0, i) + digits[(idx+1)%10] + src.substring(i+1);\\n            String next2 = src.substring(0, i) + digits[(idx+9)%10] + src.substring(i+1);\\n            neighbors.add(next1);\\n            neighbors.add(next2);\\n        }\\n        return neighbors;\\n    }\\n    \\n    \\n    public int openLock(String[] deadends, String target) {\\n        Queue<String> queue = new LinkedList<String>();\\n        String src = \"0000\";\\n        HashSet<String> deadendsSet = new HashSet<String>(Arrays.asList(deadends));\\n        HashSet<String> seen = new HashSet<String>();\\n        queue.add(src);\\n        seen.add(src);\\n        int count = 0;\\n            \\n        while(!queue.isEmpty()) {\\n            int n = queue.size();\\n            while(n-- > 0) {\\n                String next = queue.remove();\\n                if(target.equals(next)) {\\n                    return count;\\n                }\\n                if(!deadendsSet.contains(next)) {\\n                    List<String> neighbors = getNeighbors(next);\\n\\n                    for(String neighbor : neighbors) {\\n                        if(!seen.contains(neighbor)) {\\n                            queue.add(neighbor);\\n                            seen.add(neighbor);\\n                        }\\n                    }    \\n                }\\n            }\\n            count++;    \\n        }\\n    \\n        return -1;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    char digits[] = {\\'0\\', \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\'}",
                "codeTag": "Java"
            },
            {
                "id": 130735,
                "title": "python-open-the-damn-lock",
                "content": "```\\nclass Solution(object):\\n    def openLock(self, deadends, target):\\n        \"\"\"\\n        :type deadends: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"        \\n        curr_states = [(0, \"0000\")]\\n        visited = set()\\n        # searching in sets is faster\\n        visited.add(\"0000\")\\n        # searching in sets is faster than lists\\n        # this made the solution acceptable !\\n        dead_ends = set(deadends)\\n        while curr_states:\\n            depth, curr_state = curr_states.pop(0)\\n            # search exactly once in dead_ends\\n            # not twice after generating new_state_fwd/bck\\n            if curr_state in dead_ends: continue\\n            for i in xrange(4):\\n                lock_state = int(curr_state[i])\\n                new_state_fwd = curr_state[:i] + str((lock_state+1)%10) + curr_state[i+1:]\\n                if lock_state != 0:\\n                    new_state_bck = curr_state[:i] + str(lock_state-1) + curr_state[i+1:]\\n                else:\\n                    new_state_bck = curr_state[:i] + \"9\" + curr_state[i+1:]\\n                \\n                if new_state_fwd == target or new_state_bck == target:\\n                    return depth + 1\\n                \\n                if new_state_fwd not in visited:\\n                    visited.add(new_state_fwd)\\n                    curr_states.append((depth+1, new_state_fwd))\\n                \\n                if new_state_bck not in visited:\\n                    visited.add(new_state_bck)\\n                    curr_states.append((depth+1, new_state_bck))\\n        \\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def openLock(self, deadends, target):\\n        \"\"\"\\n        :type deadends: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"        \\n        curr_states = [(0, \"0000\")]\\n        visited = set()\\n        # searching in sets is faster\\n        visited.add(\"0000\")\\n        # searching in sets is faster than lists\\n        # this made the solution acceptable !\\n        dead_ends = set(deadends)\\n        while curr_states:\\n            depth, curr_state = curr_states.pop(0)\\n            # search exactly once in dead_ends\\n            # not twice after generating new_state_fwd/bck\\n            if curr_state in dead_ends: continue\\n            for i in xrange(4):\\n                lock_state = int(curr_state[i])\\n                new_state_fwd = curr_state[:i] + str((lock_state+1)%10) + curr_state[i+1:]\\n                if lock_state != 0:\\n                    new_state_bck = curr_state[:i] + str(lock_state-1) + curr_state[i+1:]\\n                else:\\n                    new_state_bck = curr_state[:i] + \"9\" + curr_state[i+1:]\\n                \\n                if new_state_fwd == target or new_state_bck == target:\\n                    return depth + 1\\n                \\n                if new_state_fwd not in visited:\\n                    visited.add(new_state_fwd)\\n                    curr_states.append((depth+1, new_state_fwd))\\n                \\n                if new_state_bck not in visited:\\n                    visited.add(new_state_bck)\\n                    curr_states.append((depth+1, new_state_bck))\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112946,
                "title": "54ms-java-2-end-bfs-solution",
                "content": "```\\npublic int openLock(String[] deadends, String target) {\\n    if (target.equals(\"0000\")) return 0;\\n    int res = 0;\\n    Set<String> visited = new HashSet<>(), tset = new HashSet<>(), zset = new HashSet<>();\\n    visited.addAll(Arrays.asList(deadends));\\n    if (visited.contains(\"0000\")) return -1;\\n    zset.add(\"0000\");\\n    tset.add(target);\\n    while (zset.size() > 0 && tset.size() > 0) {\\n        Set<String> set = zset.size() > tset.size() ? tset : zset;\\n        Set<String> other = zset.size() > tset.size() ? zset : tset;\\n        Set<String> next = new HashSet<>();\\n        res++;\\n        for (String s: set) {\\n            visited.add(s);\\n            char[] sa = s.toCharArray();\\n            // four digit\\n            for (int i = 0; i < 4; i++) {\\n                // increase\\n                if (sa[i]++ == '9') sa[i] = '0';\\n                String t = new String(sa);\\n                if (other.contains(t)) return res;\\n                if (!visited.contains(t)) next.add(t);\\n                if (sa[i]-- == '0') sa[i] = '9';\\n                // decrease\\n                if (sa[i]-- == '0') sa[i] = '9';\\n                t = new String(sa);\\n                if (other.contains(t)) return res;\\n                if (!visited.contains(t)) next.add(t);\\n                if (sa[i]++ == '9') sa[i] = '0';\\n            }\\n        }\\n        if (zset.size() > tset.size()) tset = next;\\n        else zset = next;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int openLock(String[] deadends, String target) {\\n    if (target.equals(\"0000\")) return 0;\\n    int res = 0;\\n    Set<String> visited = new HashSet<>(), tset = new HashSet<>(), zset = new HashSet<>();\\n    visited.addAll(Arrays.asList(deadends));\\n    if (visited.contains(\"0000\")) return -1;\\n    zset.add(\"0000\");\\n    tset.add(target);\\n    while (zset.size() > 0 && tset.size() > 0) {\\n        Set<String> set = zset.size() > tset.size() ? tset : zset;\\n        Set<String> other = zset.size() > tset.size() ? zset : tset;\\n        Set<String> next = new HashSet<>();\\n        res++;\\n        for (String s: set) {\\n            visited.add(s);\\n            char[] sa = s.toCharArray();\\n            // four digit\\n            for (int i = 0; i < 4; i++) {\\n                // increase\\n                if (sa[i]++ == '9') sa[i] = '0';\\n                String t = new String(sa);\\n                if (other.contains(t)) return res;\\n                if (!visited.contains(t)) next.add(t);\\n                if (sa[i]-- == '0') sa[i] = '9';\\n                // decrease\\n                if (sa[i]-- == '0') sa[i] = '9';\\n                t = new String(sa);\\n                if (other.contains(t)) return res;\\n                if (!visited.contains(t)) next.add(t);\\n                if (sa[i]++ == '9') sa[i] = '0';\\n            }\\n        }\\n        if (zset.size() > tset.size()) tset = next;\\n        else zset = next;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3969245,
                "title": "simple-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        queue = deque()\\n        queue.append(\"0000\")\\n        visited = set(\"0000\")\\n        steps = 0\\n        if \"0000\" in deadends:\\n            return -1\\n        if target == \"0000\":\\n            return steps\\n        while (size:=len(queue)) != 0:\\n            steps += 1\\n            for i in range(size):\\n                curr = queue.popleft()\\n                for wheel in range(4):\\n                    for move in (1,-1):\\n                        new_combo = curr[:wheel] + str((ord(curr[wheel]) - ord(\\'0\\') + move) % 10)  + curr[wheel+1:]\\n                        if new_combo == target:\\n                            return steps\\n                        if new_combo in visited or new_combo in deadends:\\n                            continue\\n                        else:\\n                            visited.add(new_combo)\\n                            queue.append(new_combo)\\n        return -1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        queue = deque()\\n        queue.append(\"0000\")\\n        visited = set(\"0000\")\\n        steps = 0\\n        if \"0000\" in deadends:\\n            return -1\\n        if target == \"0000\":\\n            return steps\\n        while (size:=len(queue)) != 0:\\n            steps += 1\\n            for i in range(size):\\n                curr = queue.popleft()\\n                for wheel in range(4):\\n                    for move in (1,-1):\\n                        new_combo = curr[:wheel] + str((ord(curr[wheel]) - ord(\\'0\\') + move) % 10)  + curr[wheel+1:]\\n                        if new_combo == target:\\n                            return steps\\n                        if new_combo in visited or new_combo in deadends:\\n                            continue\\n                        else:\\n                            visited.add(new_combo)\\n                            queue.append(new_combo)\\n        return -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868797,
                "title": "bfs-solution-c-beats-98",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target1) {\\n        vector<int> visited(10000,0);\\n        for(int i=0;i<deadends.size();i++)\\n        {   \\n            int cur=stoi(deadends[i]);\\n            if(cur==0) return -1;\\n            visited[cur]=-1;\\n        }\\n        queue<int> q;\\n        int target=stoi(target1);\\n        if(target==0) return 0;\\n        q.push(0);\\n        visited[0]=1;\\n        int ans=0;\\n        while(!q.empty())\\n        {   \\n            ans++;\\n            int n=q.size();\\n            while(n--)\\n            {\\n                int x=q.front();\\n                q.pop();\\n                int y=x;\\n                for(int i=0;i<4;i++)\\n                {   \\n                    int z1=x;\\n                    int z2=x;\\n                    int z=y%10;\\n                    y=y/10;\\n                    int zp,zn;\\n                    zp=z+1;\\n                    zn=z-1;\\n                    if(z==0) zn=9;\\n                    if(z==9) zp=0;\\n                    z1=z1-z*pow(10,i);\\n                    z2=z2-z*pow(10,i);\\n                    z1+=zp*pow(10,i);\\n                    z2+=zn*pow(10,i);\\n                    if(z1==target||z2==target) return ans;\\n                    if(visited[z1]==0)\\n                    {\\n                        q.push(z1);\\n                        visited[z1]=1;\\n                    }\\n                    if(visited[z2]==0)\\n                    {\\n                        q.push(z2);\\n                        visited[z2]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target1) {\\n        vector<int> visited(10000,0);\\n        for(int i=0;i<deadends.size();i++)\\n        {   \\n            int cur=stoi(deadends[i]);\\n            if(cur==0) return -1;\\n            visited[cur]=-1;\\n        }\\n        queue<int> q;\\n        int target=stoi(target1);\\n        if(target==0) return 0;\\n        q.push(0);\\n        visited[0]=1;\\n        int ans=0;\\n        while(!q.empty())\\n        {   \\n            ans++;\\n            int n=q.size();\\n            while(n--)\\n            {\\n                int x=q.front();\\n                q.pop();\\n                int y=x;\\n                for(int i=0;i<4;i++)\\n                {   \\n                    int z1=x;\\n                    int z2=x;\\n                    int z=y%10;\\n                    y=y/10;\\n                    int zp,zn;\\n                    zp=z+1;\\n                    zn=z-1;\\n                    if(z==0) zn=9;\\n                    if(z==9) zp=0;\\n                    z1=z1-z*pow(10,i);\\n                    z2=z2-z*pow(10,i);\\n                    z1+=zp*pow(10,i);\\n                    z2+=zn*pow(10,i);\\n                    if(z1==target||z2==target) return ans;\\n                    if(visited[z1]==0)\\n                    {\\n                        q.push(z1);\\n                        visited[z1]=1;\\n                    }\\n                    if(visited[z2]==0)\\n                    {\\n                        q.push(z2);\\n                        visited[z2]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597536,
                "title": "c-small-code-easy-to-read-solution",
                "content": "\\n# Desc\\nCreate an unordered_map called visited to keep track of the combinations that have been visited. Initialize all combinations in visited with a value of true using the deadends input.\\n\\nCheck if the starting combination \"0000\" is present in visited. If it is, that means it is a deadend, and we return -1.\\n\\nInitialize a variable ans to 0, which will represent the minimum number of moves needed to reach the target combination.\\n\\nCreate a queue called q and push the starting combination \"0000\" into it.\\n\\nPerform a breadth-first search (BFS) traversal using the queue q to explore all possible combinations.\\n\\nIn each iteration of the BFS loop:\\n\\nGet the current combination from the front of the queue.\\nIf the current combination is equal to the target combination, we have found the target, so we return the value of ans.\\nGenerate the eight neighboring combinations by incrementing or decrementing each digit of the current combination.\\nFor each neighboring combination, check if it has not been visited before. If it is a new combination, mark it as visited by updating visited and enqueue it into q for further exploration.\\nRepeat this process for all combinations in the current level of the BFS traversal.\\nIf we exhaust all possible combinations without finding the target, we return -1 to indicate that the target cannot be reached.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_map<string , bool>visited;\\n        for(string it : deadends){\\n            visited[it] = true;\\n        }\\n        if(visited[\"0000\"] == true)\\n            return -1;\\n        int ans = 0;\\n        queue<string>q;\\n        q.push(\"0000\");\\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i = 0 ; i < n ; i ++){ \\n                string temp = q.front();\\n                q.pop();\\n                if(temp == target) return ans;   \\n                \\n                for(int j = 0 ; j < 4 ; j ++){\\n                    string fwd = temp , bwd = temp;\\n\\n                    fwd[j] < \\'9\\' ? fwd[j]++ : fwd[j] = \\'0\\';\\n                  \\n                    bwd[j] > \\'0\\' ? bwd[j]-- : bwd[j] = \\'9\\';\\n\\n                    if(!visited[fwd]) {\\n                        visited[fwd] = true;\\n                        q.push(fwd);\\n                    }\\n                    if(!visited[bwd]) {\\n                        visited[bwd] = true;\\n                        q.push(bwd);\\n                    } \\n                }\\n\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_map<string , bool>visited;\\n        for(string it : deadends){\\n            visited[it] = true;\\n        }\\n        if(visited[\"0000\"] == true)\\n            return -1;\\n        int ans = 0;\\n        queue<string>q;\\n        q.push(\"0000\");\\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i = 0 ; i < n ; i ++){ \\n                string temp = q.front();\\n                q.pop();\\n                if(temp == target) return ans;   \\n                \\n                for(int j = 0 ; j < 4 ; j ++){\\n                    string fwd = temp , bwd = temp;\\n\\n                    fwd[j] < \\'9\\' ? fwd[j]++ : fwd[j] = \\'0\\';\\n                  \\n                    bwd[j] > \\'0\\' ? bwd[j]-- : bwd[j] = \\'9\\';\\n\\n                    if(!visited[fwd]) {\\n                        visited[fwd] = true;\\n                        q.push(fwd);\\n                    }\\n                    if(!visited[bwd]) {\\n                        visited[bwd] = true;\\n                        q.push(bwd);\\n                    } \\n                }\\n\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514166,
                "title": "c-time-o-n-space-o-n-queue-and-bfs",
                "content": "# Intuition\\nUse the BFS algorithm to visit the neightbour codes, checking if they are already visited or in the deadends, and keeping track of the steps to go to one code from \"0000\".\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst we create a function to get the neightbours of a code, this is needed because the digits are in a wheel from 0-9, and once it reaches 9 it goes to 0, and in the other way around.\\n\\nThe main program goes like this:\\n1. Create a queue to store a code and the number of steps to reach it.\\n2. Create a hashset to store the visited nodes, including the deadends.\\n3. Start from the \"0000\", and loop until there are no more codes in the queue.\\n4. In the loop, dequeue the current code, and check if is the target, if it is, return the number of steps.\\n5. If not, get the neightbours, check if they are not already visited, and add it to the visited nodes and the queue, then repeat.\\n6. If the loops ends return -1.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int OpenLock(string[] deadends, string target)\\n    {\\n        if (deadends.Contains(\"0000\")) return -1;\\n\\n        Queue<(string[] code, int steps)> queue = new Queue<(string[] code, int steps)>();\\n        HashSet<string> visited = new HashSet<string>();\\n\\n        foreach (string deadend in deadends) visited.Add(deadend);\\n\\n        queue.Enqueue((new string[]{\"0\", \"0\", \"0\", \"0\"}, 0));\\n        visited.Add(\"0000\");\\n\\n        string[] current;\\n        int steps;\\n\\n        while(queue.Count > 0)\\n        {\\n            (current, steps) = queue.Dequeue();\\n\\n            if (string.Join(\"\", current) == target) return steps;\\n\\n            foreach (string[] code in GetNeightbours(current))\\n            {\\n                if (visited.Contains(string.Join(\"\", code))) continue;\\n                visited.Add(string.Join(\"\", code));\\n                queue.Enqueue((code, steps + 1));\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private List<string[]> GetNeightbours(string[] code)\\n    {\\n        List<string[]> neightbours = new List<string[]>(8);\\n        int digit;\\n        string[] neightbour;\\n\\n        for (int i = 0; i < 4; i++)\\n        {\\n            digit = int.Parse(code[i]);\\n\\n            neightbour = (string[])code.Clone();\\n            neightbour[i] = digit + 1 == 10 ? \"0\" : (digit + 1).ToString();\\n            neightbours.Add((string[])neightbour.Clone());\\n\\n            neightbour = (string[])code.Clone();\\n            neightbour[i] = digit - 1 == -1 ? \"9\" : (digit - 1).ToString();\\n            neightbours.Add((string[])neightbour.Clone());\\n        }\\n\\n        return neightbours;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Queue"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int OpenLock(string[] deadends, string target)\\n    {\\n        if (deadends.Contains(\"0000\")) return -1;\\n\\n        Queue<(string[] code, int steps)> queue = new Queue<(string[] code, int steps)>();\\n        HashSet<string> visited = new HashSet<string>();\\n\\n        foreach (string deadend in deadends) visited.Add(deadend);\\n\\n        queue.Enqueue((new string[]{\"0\", \"0\", \"0\", \"0\"}, 0));\\n        visited.Add(\"0000\");\\n\\n        string[] current;\\n        int steps;\\n\\n        while(queue.Count > 0)\\n        {\\n            (current, steps) = queue.Dequeue();\\n\\n            if (string.Join(\"\", current) == target) return steps;\\n\\n            foreach (string[] code in GetNeightbours(current))\\n            {\\n                if (visited.Contains(string.Join(\"\", code))) continue;\\n                visited.Add(string.Join(\"\", code));\\n                queue.Enqueue((code, steps + 1));\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private List<string[]> GetNeightbours(string[] code)\\n    {\\n        List<string[]> neightbours = new List<string[]>(8);\\n        int digit;\\n        string[] neightbour;\\n\\n        for (int i = 0; i < 4; i++)\\n        {\\n            digit = int.Parse(code[i]);\\n\\n            neightbour = (string[])code.Clone();\\n            neightbour[i] = digit + 1 == 10 ? \"0\" : (digit + 1).ToString();\\n            neightbours.Add((string[])neightbour.Clone());\\n\\n            neightbour = (string[])code.Clone();\\n            neightbour[i] = digit - 1 == -1 ? \"9\" : (digit - 1).ToString();\\n            neightbours.Add((string[])neightbour.Clone());\\n        }\\n\\n        return neightbours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459784,
                "title": "bfs-java-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String>set=new HashSet<>();\\n        for(int i=0;i<deadends.length;i++){\\n            set.add(deadends[i]);\\n        }\\n\\n        Set<String> visited=new HashSet<>();\\n\\n        Queue<String>q=new LinkedList<>();\\n        q.add(\"0000\");\\n        visited.add(\"0000\");\\n        int steps=0;\\n\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            for(int j = 0; j < size; j++)\\n            {\\n                String current = q.poll();\\n                \\n                if(current.equals(target)) return steps;\\n                \\n                StringBuilder sb = new StringBuilder(current);\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    char c = sb.charAt(i);\\n                    String s1 = sb.substring(0, i) + (c == \\'9\\' ? 0 : c - \\'0\\' + 1) + sb.substring(i + 1);\\n                    String s2 = sb.substring(0, i) + (c == \\'0\\' ? 9 : c - \\'0\\' - 1) + sb.substring(i + 1);\\n                    \\n                    if(!visited.contains(s1) && !set.contains(current))\\n                    {\\n                        visited.add(s1);\\n                        q.offer(s1);\\n                    }\\n                    if(!visited.contains(s2) && !set.contains(current))\\n                    {\\n                        visited.add(s2);\\n                        q.offer(s2);\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String>set=new HashSet<>();\\n        for(int i=0;i<deadends.length;i++){\\n            set.add(deadends[i]);\\n        }\\n\\n        Set<String> visited=new HashSet<>();\\n\\n        Queue<String>q=new LinkedList<>();\\n        q.add(\"0000\");\\n        visited.add(\"0000\");\\n        int steps=0;\\n\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            for(int j = 0; j < size; j++)\\n            {\\n                String current = q.poll();\\n                \\n                if(current.equals(target)) return steps;\\n                \\n                StringBuilder sb = new StringBuilder(current);\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    char c = sb.charAt(i);\\n                    String s1 = sb.substring(0, i) + (c == \\'9\\' ? 0 : c - \\'0\\' + 1) + sb.substring(i + 1);\\n                    String s2 = sb.substring(0, i) + (c == \\'0\\' ? 9 : c - \\'0\\' - 1) + sb.substring(i + 1);\\n                    \\n                    if(!visited.contains(s1) && !set.contains(current))\\n                    {\\n                        visited.add(s1);\\n                        q.offer(s1);\\n                    }\\n                    if(!visited.contains(s2) && !set.contains(current))\\n                    {\\n                        visited.add(s2);\\n                        q.offer(s2);\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453188,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        int res = 0, trg = stoi(target);\\n        vector<bool> visited_s(10000, false), visited_e(10000, false);\\n        for (auto &s : deadends) {\\n            int n = stoi(s);\\n            visited_s[n] = visited_e[n] = true;            \\n        }\\n        if (visited_s[0]) return -1;\\n        if (trg == 0) return res;\\n        queue<int> q_s({0}), q_e({trg});\\n        visited_s[0] = true; visited_e[trg] = true;\\n        \\n        while (!q_s.empty() && !q_e.empty()) {\\n            if (q_e.size() < q_s.size()) {\\n                swap(q_s, q_e);\\n                swap(visited_s, visited_e);\\n            }\\n            int fringe = q_s.size();   \\n            res++;\\n            while(fringe--) {\\n                int pass = q_s.front();\\n                q_s.pop();\\n                int n = pass;\\n                for (int i = 0; i < 4; i++) {\\n                    int diff = pow(10, i);\\n                    int d = n % 10;\\n                    n /= 10;\\n                    int inc = pass + (d == 9 ? -9 * diff : diff);\\n                    if (!visited_s[inc]) {\\n                        if (visited_e[inc]) return res;\\n                        visited_s[inc] = true;\\n                        q_s.push(inc);\\n                    }\\n                    int dec = pass + (d == 0 ? 9 * diff : -diff);\\n                    if (!visited_s[dec]) {\\n                        if (visited_e[dec]) return res;\\n                        visited_s[dec] = true;\\n                        q_s.push(dec);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        if target == \\'0000\\':\\n            return 0\\n        if \\'0000\\' in deadends:\\n            return -1\\n\\n        start = {\\'0000\\'}\\n        end = {target}\\n        stop = set(deadends)\\n\\n        neighbors = {str(i): (str((i - 1) % 10), str((i + 1) % 10)) for i in range(10)}\\n        steps = 0\\n        while start and end:\\n            steps += 1\\n            if len(start) > len(end):\\n                start, end, = end, start\\n            temp = set()\\n            for lock in start:\\n                stop.add(lock)\\n                for i in range(4):\\n                    for n in neighbors[lock[i]]:\\n                        new_lock = lock[:i] + n + lock[i+1:]\\n                        if new_lock in end:\\n                            return steps\\n                        if new_lock in stop:\\n                            continue     \\n                        temp.add(new_lock)\\n            start = temp\\n\\n        return -1\\n```\\n\\n```Java []\\nclass Solution {\\n    private static final int RESULT_SIZE = 1;\\n    private static final int RESULT_MARKER = -1;\\n    private static final int MARKER_IDX = 0;\\n    private static final int BLOCKED = 10001;\\n    private static final int[] DIVISORS = new int[] {1000, 100, 10, 1};\\n    \\n    public int openLock(String[] deadends, String target) {\\n        if (target.equals(\"0000\")) {\\n            return 0;\\n        }\\n        int[] map = new int[10000];\\n        Set<Integer> deadendsSet = new HashSet<>();\\n        for (int i = 0; i < deadends.length; i++) {\\n            map[convertLockToInt(deadends[i])] = BLOCKED;\\n        }\\n        if (map[0] == BLOCKED) {\\n            return -1;\\n        }\\n        int targetInt = convertLockToInt(target);\\n        map[0] = 1;\\n        map[targetInt] = -1;\\n        \\n        List<Integer> fromStart = new ArrayList<>();\\n        fromStart.add(0);\\n        \\n        List<Integer> fromTarget = new ArrayList<>();\\n        fromTarget.add(targetInt);\\n        \\n        int distance = 1;\\n        while (!fromStart.isEmpty() && !fromTarget.isEmpty()) {\\n            fromStart = getNextLayer(map, fromStart, 1);\\n            if (fromStart.size() == RESULT_SIZE && fromStart.get(MARKER_IDX) == RESULT_MARKER) {\\n                return distance;\\n            } \\n            distance += 1;\\n            fromTarget = getNextLayer(map, fromTarget, -1);\\n            if (fromTarget.size() == RESULT_SIZE && fromTarget.get(MARKER_IDX) == RESULT_MARKER) {\\n                return distance;\\n            } \\n            distance += 1;\\n        }\\n        return -1;\\n    }\\n    private List<Integer> getNextLayer(int[] map, List<Integer> layer, int direction) {\\n        List<Integer> nextLayer = new ArrayList();\\n            for (int lock : layer) {\\n                for (int place = 0; place < 4; place++) {\\n                    for (int rotations = -1; rotations <= 1; rotations += 2) {\\n                        int rotatedLock = rotateLock(lock, place, rotations);\\n                        int rotatedLockMarker = map[rotatedLock];\\n                        if (rotatedLockMarker == BLOCKED ||\\n                            (direction > 0 && rotatedLockMarker > 0) || \\n                            (direction < 0 && rotatedLockMarker < 0)) {\\n                            continue;\\n                        }\\n                        if ((direction > 0 && rotatedLockMarker < 0) ||\\n                           (direction < 0 && rotatedLockMarker > 0)) {\\n                            nextLayer.clear();\\n                            nextLayer.add(-1);\\n                            return nextLayer;\\n                        }\\n                        map[rotatedLock] = direction;\\n                        nextLayer.add(rotatedLock);\\n                    }\\n                }\\n            }\\n        return nextLayer;\\n    }\\n    private int rotateLock(int lock, int place, int rotations) {\\n        int curr = (lock / DIVISORS[place]) % 10;\\n        int next = (curr + rotations + 10) % 10;\\n        return lock + (DIVISORS[place] * (next - curr));\\n    }\\n    private int convertLockToInt(String lock) {\\n        int num = 0;\\n        for (int i = 0; i < lock.length(); i++) {\\n            num *= 10;\\n            num += lock.charAt(i) - \\'0\\';\\n        }\\n        return num;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        int res = 0, trg = stoi(target);\\n        vector<bool> visited_s(10000, false), visited_e(10000, false);\\n        for (auto &s : deadends) {\\n            int n = stoi(s);\\n            visited_s[n] = visited_e[n] = true;            \\n        }\\n        if (visited_s[0]) return -1;\\n        if (trg == 0) return res;\\n        queue<int> q_s({0}), q_e({trg});\\n        visited_s[0] = true; visited_e[trg] = true;\\n        \\n        while (!q_s.empty() && !q_e.empty()) {\\n            if (q_e.size() < q_s.size()) {\\n                swap(q_s, q_e);\\n                swap(visited_s, visited_e);\\n            }\\n            int fringe = q_s.size();   \\n            res++;\\n            while(fringe--) {\\n                int pass = q_s.front();\\n                q_s.pop();\\n                int n = pass;\\n                for (int i = 0; i < 4; i++) {\\n                    int diff = pow(10, i);\\n                    int d = n % 10;\\n                    n /= 10;\\n                    int inc = pass + (d == 9 ? -9 * diff : diff);\\n                    if (!visited_s[inc]) {\\n                        if (visited_e[inc]) return res;\\n                        visited_s[inc] = true;\\n                        q_s.push(inc);\\n                    }\\n                    int dec = pass + (d == 0 ? 9 * diff : -diff);\\n                    if (!visited_s[dec]) {\\n                        if (visited_e[dec]) return res;\\n                        visited_s[dec] = true;\\n                        q_s.push(dec);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        if target == \\'0000\\':\\n            return 0\\n        if \\'0000\\' in deadends:\\n            return -1\\n\\n        start = {\\'0000\\'}\\n        end = {target}\\n        stop = set(deadends)\\n\\n        neighbors = {str(i): (str((i - 1) % 10), str((i + 1) % 10)) for i in range(10)}\\n        steps = 0\\n        while start and end:\\n            steps += 1\\n            if len(start) > len(end):\\n                start, end, = end, start\\n            temp = set()\\n            for lock in start:\\n                stop.add(lock)\\n                for i in range(4):\\n                    for n in neighbors[lock[i]]:\\n                        new_lock = lock[:i] + n + lock[i+1:]\\n                        if new_lock in end:\\n                            return steps\\n                        if new_lock in stop:\\n                            continue     \\n                        temp.add(new_lock)\\n            start = temp\\n\\n        return -1\\n```\n```Java []\\nclass Solution {\\n    private static final int RESULT_SIZE = 1;\\n    private static final int RESULT_MARKER = -1;\\n    private static final int MARKER_IDX = 0;\\n    private static final int BLOCKED = 10001;\\n    private static final int[] DIVISORS = new int[] {1000, 100, 10, 1};\\n    \\n    public int openLock(String[] deadends, String target) {\\n        if (target.equals(\"0000\")) {\\n            return 0;\\n        }\\n        int[] map = new int[10000];\\n        Set<Integer> deadendsSet = new HashSet<>();\\n        for (int i = 0; i < deadends.length; i++) {\\n            map[convertLockToInt(deadends[i])] = BLOCKED;\\n        }\\n        if (map[0] == BLOCKED) {\\n            return -1;\\n        }\\n        int targetInt = convertLockToInt(target);\\n        map[0] = 1;\\n        map[targetInt] = -1;\\n        \\n        List<Integer> fromStart = new ArrayList<>();\\n        fromStart.add(0);\\n        \\n        List<Integer> fromTarget = new ArrayList<>();\\n        fromTarget.add(targetInt);\\n        \\n        int distance = 1;\\n        while (!fromStart.isEmpty() && !fromTarget.isEmpty()) {\\n            fromStart = getNextLayer(map, fromStart, 1);\\n            if (fromStart.size() == RESULT_SIZE && fromStart.get(MARKER_IDX) == RESULT_MARKER) {\\n                return distance;\\n            } \\n            distance += 1;\\n            fromTarget = getNextLayer(map, fromTarget, -1);\\n            if (fromTarget.size() == RESULT_SIZE && fromTarget.get(MARKER_IDX) == RESULT_MARKER) {\\n                return distance;\\n            } \\n            distance += 1;\\n        }\\n        return -1;\\n    }\\n    private List<Integer> getNextLayer(int[] map, List<Integer> layer, int direction) {\\n        List<Integer> nextLayer = new ArrayList();\\n            for (int lock : layer) {\\n                for (int place = 0; place < 4; place++) {\\n                    for (int rotations = -1; rotations <= 1; rotations += 2) {\\n                        int rotatedLock = rotateLock(lock, place, rotations);\\n                        int rotatedLockMarker = map[rotatedLock];\\n                        if (rotatedLockMarker == BLOCKED ||\\n                            (direction > 0 && rotatedLockMarker > 0) || \\n                            (direction < 0 && rotatedLockMarker < 0)) {\\n                            continue;\\n                        }\\n                        if ((direction > 0 && rotatedLockMarker < 0) ||\\n                           (direction < 0 && rotatedLockMarker > 0)) {\\n                            nextLayer.clear();\\n                            nextLayer.add(-1);\\n                            return nextLayer;\\n                        }\\n                        map[rotatedLock] = direction;\\n                        nextLayer.add(rotatedLock);\\n                    }\\n                }\\n            }\\n        return nextLayer;\\n    }\\n    private int rotateLock(int lock, int place, int rotations) {\\n        int curr = (lock / DIVISORS[place]) % 10;\\n        int next = (curr + rotations + 10) % 10;\\n        return lock + (DIVISORS[place] * (next - curr));\\n    }\\n    private int convertLockToInt(String lock) {\\n        int num = 0;\\n        for (int i = 0; i < lock.length(); i++) {\\n            num *= 10;\\n            num += lock.charAt(i) - \\'0\\';\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246565,
                "title": "c-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> dead(begin(deadends), end(deadends));\\n        string temp, tempp;\\n        \\n        if(dead.count(\"0000\")) return -1;\\n        if(target== \"0000\") return 0;\\n        \\n        int ans=0, sz;\\n        queue<string> q;\\n        q.push(\"0000\");\\n        \\n        while(!q.empty()){\\n            ans++;\\n            sz= q.size();    \\n            for(int k=0;k<sz;k++){\\n                tempp= q.front(),q.pop();\\n                for(int i=0;i<4;i++){\\n                    temp= tempp;\\n                    temp[i]= (temp[i]==\\'9\\') ? \\'0\\' : ++temp[i];\\n                    if(temp== target) return ans;\\n                    if(dead.count(temp)==0){\\n                        q.push(temp);\\n                        dead.insert(temp);\\n                    }\\n                    \\n                    temp= tempp;\\n                    temp[i]= temp[i]==\\'0\\' ? \\'9\\' : --temp[i];\\n                    if(temp== target) return ans;\\n                    if(dead.count(temp)==0){\\n                        q.push(temp);\\n                        dead.insert(temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> dead(begin(deadends), end(deadends));\\n        string temp, tempp;\\n        \\n        if(dead.count(\"0000\")) return -1;\\n        if(target== \"0000\") return 0;\\n        \\n        int ans=0, sz;\\n        queue<string> q;\\n        q.push(\"0000\");\\n        \\n        while(!q.empty()){\\n            ans++;\\n            sz= q.size();    \\n            for(int k=0;k<sz;k++){\\n                tempp= q.front(),q.pop();\\n                for(int i=0;i<4;i++){\\n                    temp= tempp;\\n                    temp[i]= (temp[i]==\\'9\\') ? \\'0\\' : ++temp[i];\\n                    if(temp== target) return ans;\\n                    if(dead.count(temp)==0){\\n                        q.push(temp);\\n                        dead.insert(temp);\\n                    }\\n                    \\n                    temp= tempp;\\n                    temp[i]= temp[i]==\\'0\\' ? \\'9\\' : --temp[i];\\n                    if(temp== target) return ans;\\n                    if(dead.count(temp)==0){\\n                        q.push(temp);\\n                        dead.insert(temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778343,
                "title": "simple-bfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> st(deadends.begin(), deadends.end()), seen;\\n        queue<pair<string, int>> q;\\n        q.push({\"0000\", 0});\\n        seen.insert(\"0000\");\\n\\n        while(q.size()) {\\n            string s = q.front().first;\\n            int d = q.front().second; q.pop();\\n\\n            if(s == target) return d;\\n            if(st.find(s) != st.end()) continue;\\n            \\n            for(int i=0; i<4; i++) {\\n                string t = s, u = s;\\n                t[i] < \\'9\\' ? t[i]++ : t[i] = \\'0\\';\\n                if(seen.find(t) == seen.end()) q.push({t, d + 1}), seen.insert(t);\\n\\n                u[i] > \\'0\\' ? u[i]-- : u[i] = \\'9\\';\\n                if(seen.find(u) == seen.end()) q.push({u, d + 1}), seen.insert(u);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> st(deadends.begin(), deadends.end()), seen;\\n        queue<pair<string, int>> q;\\n        q.push({\"0000\", 0});\\n        seen.insert(\"0000\");\\n\\n        while(q.size()) {\\n            string s = q.front().first;\\n            int d = q.front().second; q.pop();\\n\\n            if(s == target) return d;\\n            if(st.find(s) != st.end()) continue;\\n            \\n            for(int i=0; i<4; i++) {\\n                string t = s, u = s;\\n                t[i] < \\'9\\' ? t[i]++ : t[i] = \\'0\\';\\n                if(seen.find(t) == seen.end()) q.push({t, d + 1}), seen.insert(t);\\n\\n                u[i] > \\'0\\' ? u[i]-- : u[i] = \\'9\\';\\n                if(seen.find(u) == seen.end()) q.push({u, d + 1}), seen.insert(u);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549617,
                "title": "java-clean-and-fast-solution-100",
                "content": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Queue<String> que = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        Collections.addAll(visited,deadends);\\n        int level =0;\\n        que.offer(\"0000\");\\n        if(visited.contains(\"0000\")) return -1;\\n        else visited.add(\"0000\");\\n        while (!que.isEmpty()){\\n            int size = que.size();\\n            while (size>0){\\n                String poped = que.poll();\\n                if(poped.equals(target))\\n                    return level;\\n                for (String child : children(poped))\\n                    if(!visited.contains(child)){\\n                        que.offer(child);\\n                        visited.add(child);\\n                    }\\n                size--;\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n    public List<String> children(String s){\\n        List<String> res = new ArrayList<>();\\n        for (int i=0;i<4;i++){\\n            String digit = String.valueOf((s.charAt(i)-\\'0\\'+1)%10);\\n            String assemble = s.substring(0,i)+digit+s.substring(i+1);\\n            res.add(assemble);\\n            digit = String.valueOf((s.charAt(i)-\\'0\\'-1+10)%10);\\n            assemble = s.substring(0,i)+digit+s.substring(i+1);\\n            res.add(assemble);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Queue<String> que = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        Collections.addAll(visited,deadends);\\n        int level =0;\\n        que.offer(\"0000\");\\n        if(visited.contains(\"0000\")) return -1;\\n        else visited.add(\"0000\");\\n        while (!que.isEmpty()){\\n            int size = que.size();\\n            while (size>0){\\n                String poped = que.poll();\\n                if(poped.equals(target))\\n                    return level;\\n                for (String child : children(poped))\\n                    if(!visited.contains(child)){\\n                        que.offer(child);\\n                        visited.add(child);\\n                    }\\n                size--;\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n    public List<String> children(String s){\\n        List<String> res = new ArrayList<>();\\n        for (int i=0;i<4;i++){\\n            String digit = String.valueOf((s.charAt(i)-\\'0\\'+1)%10);\\n            String assemble = s.substring(0,i)+digit+s.substring(i+1);\\n            res.add(assemble);\\n            digit = String.valueOf((s.charAt(i)-\\'0\\'-1+10)%10);\\n            assemble = s.substring(0,i)+digit+s.substring(i+1);\\n            res.add(assemble);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530871,
                "title": "bfs-python-time-o-v-e-space-o-v",
                "content": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        \\n        def findNeighbours(code):\\n            res = []\\n            for i in range(4):\\n                updatedDigit = str((int(code[i]) + 1) % 10)\\n                res.append(code[:i] + updatedDigit + code[i + 1:])\\n                \\n                updatedDigit = str((int(code[i]) - 1) % 10)\\n                res.append(code[:i] + updatedDigit + code[i + 1:])\\n            return res\\n            \\n        visited = set(deadends)\\n        if \\'0000\\' in visited:\\n            return -1\\n        q = deque([(\\'0000\\', 0)])\\n        while q:\\n            code, moves = q.popleft()\\n            if code == target:\\n                return moves\\n            for neigh in findNeighbours(code):\\n                if neigh not in visited:\\n                    q.append((neigh, moves + 1))\\n                    visited.add(neigh)\\n        return -1\\n    # Time: O(V + E) where V is 10,000 and E is 8 * V = 80,000\\n    # Space: O(V)\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        \\n        def findNeighbours(code):\\n            res = []\\n            for i in range(4):\\n                updatedDigit = str((int(code[i]) + 1) % 10)\\n                res.append(code[:i] + updatedDigit + code[i + 1:])\\n                \\n                updatedDigit = str((int(code[i]) - 1) % 10)\\n                res.append(code[:i] + updatedDigit + code[i + 1:])\\n            return res\\n            \\n        visited = set(deadends)\\n        if \\'0000\\' in visited:\\n            return -1\\n        q = deque([(\\'0000\\', 0)])\\n        while q:\\n            code, moves = q.popleft()\\n            if code == target:\\n                return moves\\n            for neigh in findNeighbours(code):\\n                if neigh not in visited:\\n                    q.append((neigh, moves + 1))\\n                    visited.add(neigh)\\n        return -1\\n    # Time: O(V + E) where V is 10,000 and E is 8 * V = 80,000\\n    # Space: O(V)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330976,
                "title": "c-bfs-90-faster-concise-and-neat-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        if(target == \"0000\") return 0;\\n        unordered_map<string,int> vis;\\n        for(auto c : deadends) vis[c] = 1;\\n        \\n        queue<pair<string,int>> q;\\n        if(vis[\"0000\"]) return -1;\\n        q.push({\"0000\",0});\\n        vis[\"0000\"] = 1;\\n        while(!q.empty()){\\n            auto [code,k] = q.front();\\n            q.pop();\\n            for(int i = 0 ; i < 4 ; i++){\\n                char dec = code[i] == \\'0\\' ? \\'9\\' : code[i] - 1;\\n                char inc = code[i] == \\'9\\' ? \\'0\\' : code[i] + 1;\\n                string temp = code, temp2 = code;\\n                temp[i] = dec;\\n                temp2[i] = inc;\\n                if(temp == target || temp2 == target) return k+1;\\n                if(!vis[temp]){\\n                    q.push({temp,k+1});\\n                    vis[temp] = 1;\\n                }\\n                if(!vis[temp2]) {\\n                    q.push({temp2,k+1});\\n                    vis[temp2] = 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        if(target == \"0000\") return 0;\\n        unordered_map<string,int> vis;\\n        for(auto c : deadends) vis[c] = 1;\\n        \\n        queue<pair<string,int>> q;\\n        if(vis[\"0000\"]) return -1;\\n        q.push({\"0000\",0});\\n        vis[\"0000\"] = 1;\\n        while(!q.empty()){\\n            auto [code,k] = q.front();\\n            q.pop();\\n            for(int i = 0 ; i < 4 ; i++){\\n                char dec = code[i] == \\'0\\' ? \\'9\\' : code[i] - 1;\\n                char inc = code[i] == \\'9\\' ? \\'0\\' : code[i] + 1;\\n                string temp = code, temp2 = code;\\n                temp[i] = dec;\\n                temp2[i] = inc;\\n                if(temp == target || temp2 == target) return k+1;\\n                if(!vis[temp]){\\n                    q.push({temp,k+1});\\n                    vis[temp] = 1;\\n                }\\n                if(!vis[temp2]) {\\n                    q.push({temp2,k+1});\\n                    vis[temp2] = 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312524,
                "title": "c-bfs-solution-memoization",
                "content": "This is a simple bfs solution in which we are considering all possible cases. We are given that at one time we can only turn one wheel one slot. \\n* Create a hash map to store the deadends, so that we can check in O(1) time if while traversal, we might not have reached a deadend. \\n* Create a adjacency list, which has the adjacent nodes. Like for 1 we have 0 and 2, for 0 we have 9 and 1, for 9 we have 8 and 0, etc.\\n* Create a queue and insert \"0000\" to it as we have to start our traversal from \"0000\" and reach to our target.\\n* Keep a count variable to keep a track of the minimum total number of turns required. As they are asking the minimum number of turns, we can think in this way to do bfs here.\\n* Then we can traverse till the size of queue in one iteration, as the queue right now contains all the possible ways, one of them will have the minimum path to our target.\\n* Check all possible ways, i.e changing each character to it\\'s each neighbor present in the adjacency list. But before pushing it into queue, we have to check if it is not a deadend or it has not been visited earlier and can be a possible path till our target.\\n* If does apply to the above conditions, then push it into the queue, and also in the hash map. This is basically a memoization step, in which we are considering that it has already been visited earlier and a possible path from it might be in the progress in the queue, so no need to push it again in the queue, it will just lead to time limit exceeded.\\n* Increment count after each iteration till the present size of the queue.\\n* While removing the front element from the queue each time, if it is equal to our target string, then just return count, meaning we got our path to our target, and it will be minimum.\\n* If the queue becomes empty and we come out of the loop, it means we were not able to reach our target, simply return -1 in that case.\\n* Note one case, in which the starting string as \"0000\" is a deadend, simply return -1 as it will be impossible to move ahead of that and ever reach our target.\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string &s, unordered_map<string,int>&mp){\\n        if(mp.find(s) == mp.end()) return true;\\n        return false;\\n    }\\n    int openLock(vector<string>& deadends, string target) {\\n        vector<int>adj[10];\\n        for(int i=1; i<=8; i++){\\n            adj[i].push_back(i-1);\\n            adj[i].push_back(i+1);\\n        }\\n        adj[0].push_back(1);\\n        adj[0].push_back(9);\\n        adj[9].push_back(0);\\n        adj[9].push_back(8);\\n        unordered_map<string,int>mp;\\n        for(int i=0; i<deadends.size(); i++){\\n            mp[deadends[i]] = 1;\\n        }\\n        if(mp.find(\"0000\") != mp.end()) return -1;\\n        queue<string>q;\\n        mp[\"0000\"] = 1;\\n        q.push(\"0000\");\\n        int count = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int z=0; z<size; z++){\\n                string top = q.front();\\n                q.pop();\\n                if(top == target) return count;\\n                for(int i=0; i<top.size(); i++){\\n                    for(auto p: adj[top[i]-\\'0\\']){\\n                        string temp = top;\\n                        char k = p + \\'0\\';\\n                        temp[i] = k;\\n                        if(isValid(temp,mp)){\\n                            q.push(temp);\\n                            mp[temp] = 1;\\n                        }\\n                    }\\n                }   \\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Memoization",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string &s, unordered_map<string,int>&mp){\\n        if(mp.find(s) == mp.end()) return true;\\n        return false;\\n    }\\n    int openLock(vector<string>& deadends, string target) {\\n        vector<int>adj[10];\\n        for(int i=1; i<=8; i++){\\n            adj[i].push_back(i-1);\\n            adj[i].push_back(i+1);\\n        }\\n        adj[0].push_back(1);\\n        adj[0].push_back(9);\\n        adj[9].push_back(0);\\n        adj[9].push_back(8);\\n        unordered_map<string,int>mp;\\n        for(int i=0; i<deadends.size(); i++){\\n            mp[deadends[i]] = 1;\\n        }\\n        if(mp.find(\"0000\") != mp.end()) return -1;\\n        queue<string>q;\\n        mp[\"0000\"] = 1;\\n        q.push(\"0000\");\\n        int count = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int z=0; z<size; z++){\\n                string top = q.front();\\n                q.pop();\\n                if(top == target) return count;\\n                for(int i=0; i<top.size(); i++){\\n                    for(auto p: adj[top[i]-\\'0\\']){\\n                        string temp = top;\\n                        char k = p + \\'0\\';\\n                        temp[i] = k;\\n                        if(isValid(temp,mp)){\\n                            q.push(temp);\\n                            mp[temp] = 1;\\n                        }\\n                    }\\n                }   \\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270195,
                "title": "superrr-easy-c-bfs-based-code-explained-with-approach",
                "content": "**Approach:**\\nFor now lets forget about deadends first, we start from \"0000\" configuration what we plan to do is we scroll the lock one time and put the next configuration in the queue, i.e for \"0000\" we need to push \"1000\",\"9000\",\"0100\", \"0900\",\"0010\",\"0090\",\"0001\",\"0009\" . Also we need to avoid looping back to same transition for this purpose the `unordered_set<string>` will help us as a kind of visited nodes.\\nHope you get the basic intuition , i have commented the code which explains the code easily.\\n```\\nclass Solution {\\npublic:\\n\\t//function to return the prev and next character when the lock is scrolled\\n\\t//char[0]-->prev   char[1]-->next\\n    vector<char> roll(char ch)\\n    {\\n        if(ch==\\'0\\')\\n            return {\\'9\\',\\'1\\'};\\n        else if(ch==\\'9\\')\\n            return {\\'8\\',\\'0\\'};\\n        char temp=ch;\\n        ch--;\\n        temp++;\\n        return {ch,temp};\\n    }\\n\\t\\n    int openLock(vector<string>& deadends, string target) {\\n        set<string> st; // works as a visited array which stores all the strings which we have stored till now.\\n        queue<string> q;\\n        int ans=0; //count the min number of steps\\n\\t\\t// if initial state is deadend then return -1;\\n        if(find(deadends.begin(),deadends.end(),\"0000\")!=deadends.end())\\n            return -1;\\n        q.push(\"0000\");\\n        st.insert(\"0000\");\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                string curr=q.front();\\n                q.pop();\\n                if(curr==target)\\n                    return ans;\\n\\t\\t\\t\\t//traversing for each wheel\\n                for(int i=0;i<4;i++)\\n                {\\n\\t\\t\\t\\t\\t//store the initial original character.\\n\\t\\t\\t\\t\\t//if  eg. curr==0000\\n                    char original=curr[i]; //eg, for i=0 original=0\\n                    auto vals=roll(original);\\n                    for(int j=0;j<2;j++)\\n                    {\\n                        curr[i]=vals[j]; //eg, for j=0 curr=9000 and for j=1 curr=1000\\n\\t\\t\\t\\t\\t\\t//check if the combination after scroll is valid i.e. is not visited earlier and is not a deadend\\n                        if(st.find(curr)==st.end() && find(deadends.begin(),deadends.end(),curr)==deadends.end())\\n                        {\\n                            st.insert(curr);\\n                            q.push(curr);\\n                        }\\n                    }\\n\\t\\t\\t\\t\\t//replace the original string\\n                    curr[i]=original; //eg, curr becomes 0000 so that we can replace for i=1,2,3 and so on.......\\n\\t\\t\\t\\t\\t\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t//function to return the prev and next character when the lock is scrolled\\n\\t//char[0]-->prev   char[1]-->next\\n    vector<char> roll(char ch)\\n    {\\n        if(ch==\\'0\\')\\n            return {\\'9\\',\\'1\\'};\\n        else if(ch==\\'9\\')\\n            return {\\'8\\',\\'0\\'};\\n        char temp=ch;\\n        ch--;\\n        temp++;\\n        return {ch,temp};\\n    }\\n\\t\\n    int openLock(vector<string>& deadends, string target) {\\n        set<string> st; // works as a visited array which stores all the strings which we have stored till now.\\n        queue<string> q;\\n        int ans=0; //count the min number of steps\\n\\t\\t// if initial state is deadend then return -1;\\n        if(find(deadends.begin(),deadends.end(),\"0000\")!=deadends.end())\\n            return -1;\\n        q.push(\"0000\");\\n        st.insert(\"0000\");\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                string curr=q.front();\\n                q.pop();\\n                if(curr==target)\\n                    return ans;\\n\\t\\t\\t\\t//traversing for each wheel\\n                for(int i=0;i<4;i++)\\n                {\\n\\t\\t\\t\\t\\t//store the initial original character.\\n\\t\\t\\t\\t\\t//if  eg. curr==0000\\n                    char original=curr[i]; //eg, for i=0 original=0\\n                    auto vals=roll(original);\\n                    for(int j=0;j<2;j++)\\n                    {\\n                        curr[i]=vals[j]; //eg, for j=0 curr=9000 and for j=1 curr=1000\\n\\t\\t\\t\\t\\t\\t//check if the combination after scroll is valid i.e. is not visited earlier and is not a deadend\\n                        if(st.find(curr)==st.end() && find(deadends.begin(),deadends.end(),curr)==deadends.end())\\n                        {\\n                            st.insert(curr);\\n                            q.push(curr);\\n                        }\\n                    }\\n\\t\\t\\t\\t\\t//replace the original string\\n                    curr[i]=original; //eg, curr becomes 0000 so that we can replace for i=1,2,3 and so on.......\\n\\t\\t\\t\\t\\t\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185662,
                "title": "c-bfs-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    \\n    // need to return the 8 possible moves\\n    // basic string manipulation\\n    vector<string> next(string s){\\n        vector<string> res;\\n        for(int i=0;i<4;i++){\\n            string temp = s;\\n            int c = s[i]-\\'0\\';\\n            c+=1;\\n            c%=10;\\n            temp[i] = char(48+c);\\n            res.push_back(temp);\\n            c = s[i]-\\'0\\';\\n            c-=1;\\n            c+=10;\\n            c%=10;\\n            temp[i] = char(48+c);\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n    \\n    // bfs can be used as every move costs the same\\n    \\n    int openLock(vector<string>& deadends, string target) {\\n        \\n        // storing deadends in a set\\n        unordered_set<string> st;\\n        for(auto s:deadends) st.insert(s);\\n        \\n        // if 0000 is in deadend no need to go further\\n        if(st.find(\"0000\") != st.end()){\\n            return -1;\\n        }\\n        queue<string> q;\\n        unordered_map<string,int> dist;\\n        // distance of initial string is set as 0\\n        dist[\"0000\"] = 0;\\n        q.push(\"0000\");\\n        \\n        while(!q.empty()){\\n            string s = q.front();\\n            q.pop();\\n            vector<string> moves = next(s);\\n            for(string t:moves){\\n                // cant go to this string as its in deadend\\n                if(st.find(t) != st.end()) continue;\\n                // we have to go to strings that we have not already visited/seen\\n                if(dist.find(t) == dist.end()){\\n                    dist[t] = 1+dist[s];\\n                    q.push(t);\\n                }\\n                if(t == target) return dist[t];\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    // need to return the 8 possible moves\\n    // basic string manipulation\\n    vector<string> next(string s){\\n        vector<string> res;\\n        for(int i=0;i<4;i++){\\n            string temp = s;\\n            int c = s[i]-\\'0\\';\\n            c+=1;\\n            c%=10;\\n            temp[i] = char(48+c);\\n            res.push_back(temp);\\n            c = s[i]-\\'0\\';\\n            c-=1;\\n            c+=10;\\n            c%=10;\\n            temp[i] = char(48+c);\\n            res.push_back(temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2133350,
                "title": "python-solution",
                "content": "```\\n# T: O((N^2 * A^N + D), S:O(A^N+D)\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        \\n        def step_up(curr,i):\\n            # [\\'0\\', \\'0\\', \\'0\\', \\'0\\']\\n            splitArray = list(curr)\\n            number = int(splitArray[i])\\n            number += 1\\n            if number == 10:\\n                number = 0\\n            splitArray[i]= str(number)\\n            return \\'\\'.join(splitArray)\\n        \\n        def step_down(curr,i):\\n            # [\\'0\\', \\'0\\', \\'0\\', \\'0\\']\\n            splitArray = list(curr)\\n            number = int(splitArray[i])\\n            number -= 1\\n            if number == -1:\\n                number = 9\\n            splitArray[i]= str(number)\\n            return \\'\\'.join(splitArray)\\n        \\n            \\n        start = \\'0000\\'\\n        count = 0\\n        # 1. [0000]->[1000,9000]\\n        # 2. [1000,9000] -> [2000,0000, 0000,8000]\\n        # 3. [2000,0000, 0000,8000] -> [3000,1000,1000,9000,1000,9000,9000,7000]\\n        visited = set()\\n        if start in deadends:\\n            return -1\\n        visited.add(start)\\n        for i in range(len(deadends)):\\n            visited.add(deadends[i])\\n        queue = [start]\\n        while len(queue) != 0:\\n            now_size = len(queue)\\n            for i in range(now_size):\\n                pop_value= queue.pop(0)\\n                if pop_value == target:\\n                    return count\\n                \\n                for i in [0,1,2,3]:\\n                    up_result = step_up(pop_value, i)\\n                    if up_result not in visited:\\n                        queue.append(up_result)\\n                        visited.add(up_result)\\n                    down_result = step_down(pop_value, i)\\n                    if down_result not in visited:\\n                        queue.append(down_result)\\n                        visited.add(down_result)\\n            count += 1\\n        return -1\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# T: O((N^2 * A^N + D), S:O(A^N+D)\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        \\n        def step_up(curr,i):\\n            # [\\'0\\', \\'0\\', \\'0\\', \\'0\\']\\n            splitArray = list(curr)\\n            number = int(splitArray[i])\\n            number += 1\\n            if number == 10:\\n                number = 0\\n            splitArray[i]= str(number)\\n            return \\'\\'.join(splitArray)\\n        \\n        def step_down(curr,i):\\n            # [\\'0\\', \\'0\\', \\'0\\', \\'0\\']\\n            splitArray = list(curr)\\n            number = int(splitArray[i])\\n            number -= 1\\n            if number == -1:\\n                number = 9\\n            splitArray[i]= str(number)\\n            return \\'\\'.join(splitArray)\\n        \\n            \\n        start = \\'0000\\'\\n        count = 0\\n        # 1. [0000]->[1000,9000]\\n        # 2. [1000,9000] -> [2000,0000, 0000,8000]\\n        # 3. [2000,0000, 0000,8000] -> [3000,1000,1000,9000,1000,9000,9000,7000]\\n        visited = set()\\n        if start in deadends:\\n            return -1\\n        visited.add(start)\\n        for i in range(len(deadends)):\\n            visited.add(deadends[i])\\n        queue = [start]\\n        while len(queue) != 0:\\n            now_size = len(queue)\\n            for i in range(now_size):\\n                pop_value= queue.pop(0)\\n                if pop_value == target:\\n                    return count\\n                \\n                for i in [0,1,2,3]:\\n                    up_result = step_up(pop_value, i)\\n                    if up_result not in visited:\\n                        queue.append(up_result)\\n                        visited.add(up_result)\\n                    down_result = step_down(pop_value, i)\\n                    if down_result not in visited:\\n                        queue.append(down_result)\\n                        visited.add(down_result)\\n            count += 1\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125797,
                "title": "c-easy-and-simple-bfs-1000ms-36-5-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        int i,j,n,ans=0;\\n        \\n        set<string> s(deadends.begin(),deadends.end());\\n        if(s.find(\"0000\")!=s.end()) return -1;\\n       \\n        queue<string> q;\\n        q.push(\"0000\");\\n        while(!q.empty())\\n        {\\n            n=q.size();\\n            for(i=0;i<n;i++)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                if(temp==target) return ans;\\n                for(j=0;j<4;j++)\\n                {\\n                        string fwd,bwd;\\n                        fwd= temp.substr(0,j)+to_string(temp[j]==\\'0\\'?9:temp[j]-\\'0\\'-1)+temp.substr(j+1);\\n                        bwd= temp.substr(0,j)+to_string(temp[j] ==\\'9\\'?0:temp[j]-\\'0\\'+ 1)+temp.substr(j+1);\\n                        if(!s.count(fwd)) s.insert(fwd),q.push(fwd);\\n                        if(!s.count(bwd)) s.insert(bwd),q.push(bwd);                             \\n                }\\n                \\n            }\\n            ans++;\\n        }\\n        \\n        return -1;   \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        int i,j,n,ans=0;\\n        \\n        set<string> s(deadends.begin(),deadends.end());\\n        if(s.find(\"0000\")!=s.end()) return -1;\\n       \\n        queue<string> q;\\n        q.push(\"0000\");\\n        while(!q.empty())\\n        {\\n            n=q.size();\\n            for(i=0;i<n;i++)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                if(temp==target) return ans;\\n                for(j=0;j<4;j++)\\n                {\\n                        string fwd,bwd;\\n                        fwd= temp.substr(0,j)+to_string(temp[j]==\\'0\\'?9:temp[j]-\\'0\\'-1)+temp.substr(j+1);\\n                        bwd= temp.substr(0,j)+to_string(temp[j] ==\\'9\\'?0:temp[j]-\\'0\\'+ 1)+temp.substr(j+1);\\n                        if(!s.count(fwd)) s.insert(fwd),q.push(fwd);\\n                        if(!s.count(bwd)) s.insert(bwd),q.push(bwd);                             \\n                }\\n                \\n            }\\n            ans++;\\n        }\\n        \\n        return -1;   \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092969,
                "title": "c-bfs-simple-solution",
                "content": "BFS template. Can be used in many questions including binary tree level order traverse and word ladder.\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        deque<string> q;\\n        unordered_set<string> visited;\\n        q.push_back(\"0000\");\\n        visited.insert(\"0000\");\\n        unordered_set<string> obs(deadends.begin(), deadends.end());\\n        if (obs.count(\"0000\")) return -1;\\n        int cnt = 0;\\n        while (!q.empty()) {\\n            int s = q.size();\\n            for (int k = 0; k < s; ++k) {\\n                auto t = q.front(); q.pop_front();\\n                if (t.compare(target) == 0) {\\n                    return cnt;\\n                }\\n                for (int i = 0; i < t.size(); ++i) {\\n                    for (int j = 0; j < move.size(); ++j) {\\n                        int digit = (t[i] - \\'0\\' + move[j] + 10) % 10;\\n                        string new_t = t;\\n                        new_t[i] = digit + \\'0\\';\\n                        if (visited.count(new_t) || obs.count(new_t)) {\\n                            continue;\\n                        }\\n                        q.push_back(new_t);\\n                        visited.insert(new_t);\\n                    }\\n                }\\n            }\\n            ++cnt;\\n        }\\n        return -1;\\n    }\\n    \\n    vector<int> move{1, -1};\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        deque<string> q;\\n        unordered_set<string> visited;\\n        q.push_back(\"0000\");\\n        visited.insert(\"0000\");\\n        unordered_set<string> obs(deadends.begin(), deadends.end());\\n        if (obs.count(\"0000\")) return -1;\\n        int cnt = 0;\\n        while (!q.empty()) {\\n            int s = q.size();\\n            for (int k = 0; k < s; ++k) {\\n                auto t = q.front(); q.pop_front();\\n                if (t.compare(target) == 0) {\\n                    return cnt;\\n                }\\n                for (int i = 0; i < t.size(); ++i) {\\n                    for (int j = 0; j < move.size(); ++j) {\\n                        int digit = (t[i] - \\'0\\' + move[j] + 10) % 10;\\n                        string new_t = t;\\n                        new_t[i] = digit + \\'0\\';\\n                        if (visited.count(new_t) || obs.count(new_t)) {\\n                            continue;\\n                        }\\n                        q.push_back(new_t);\\n                        visited.insert(new_t);\\n                    }\\n                }\\n            }\\n            ++cnt;\\n        }\\n        return -1;\\n    }\\n    \\n    vector<int> move{1, -1};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045567,
                "title": "c-easy-to-understand-bidirectional-bfs-79-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        const string start = \"0000\";\\n        unordered_set<string> dead(deadends.begin(), deadends.end());\\n        queue<string> q1{{start}}, q2{{target}};\\n        unordered_set<string> s1{start}, s2{target};\\n        int res1 = 0, res2 = 0;\\n        \\n        if (dead.count(start))\\n            return -1;\\n        if (target.compare(start) == 0)\\n            return 0;\\n        while (!q1.empty()) {\\n            res1++;\\n            int size = q1.size();\\n            while (size--) {\\n                string cur = q1.front();\\n                q1.pop();\\n                for (string s : transform(cur)) {\\n                    if (s2.count(s)) {\\n                        return res1 + res2;\\n                    }\\n                    if (!dead.count(s) && !s1.count(s)) {\\n                        q1.push(s);\\n                        s1.insert(s);\\n                    }\\n                }\\n            }\\n            swap(q1, q2);\\n            swap(s1, s2);\\n            swap(res1, res2);\\n        }\\n        return -1;\\n    }\\nprivate:\\n    vector<string> transform(string original) {\\n        vector<string> strings;\\n        for (int i = 0; i < original.length(); ++i) {\\n            char c = original[i];\\n            original[i] = move(c, 1);\\n            strings.push_back(original);\\n            original[i] = move(c, 0);\\n            strings.push_back(original);\\n            original[i] = c;\\n        }\\n        return strings;\\n    }\\n    char move(char c, bool forward) {\\n        if (forward) {\\n            if (c == \\'9\\') {\\n                return \\'0\\';\\n            } else {\\n                return c + 1;\\n            }\\n        } else {\\n            if (c == \\'0\\') {\\n                return \\'9\\';\\n            } else {\\n                return c - 1;\\n            }\\n        }\\n    }\\n};\\n```\\nplease upvote it",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        const string start = \"0000\";\\n        unordered_set<string> dead(deadends.begin(), deadends.end());\\n        queue<string> q1{{start}}, q2{{target}};\\n        unordered_set<string> s1{start}, s2{target};\\n        int res1 = 0, res2 = 0;\\n        \\n        if (dead.count(start))\\n            return -1;\\n        if (target.compare(start) == 0)\\n            return 0;\\n        while (!q1.empty()) {\\n            res1++;\\n            int size = q1.size();\\n            while (size--) {\\n                string cur = q1.front();\\n                q1.pop();\\n                for (string s : transform(cur)) {\\n                    if (s2.count(s)) {\\n                        return res1 + res2;\\n                    }\\n                    if (!dead.count(s) && !s1.count(s)) {\\n                        q1.push(s);\\n                        s1.insert(s);\\n                    }\\n                }\\n            }\\n            swap(q1, q2);\\n            swap(s1, s2);\\n            swap(res1, res2);\\n        }\\n        return -1;\\n    }\\nprivate:\\n    vector<string> transform(string original) {\\n        vector<string> strings;\\n        for (int i = 0; i < original.length(); ++i) {\\n            char c = original[i];\\n            original[i] = move(c, 1);\\n            strings.push_back(original);\\n            original[i] = move(c, 0);\\n            strings.push_back(original);\\n            original[i] = c;\\n        }\\n        return strings;\\n    }\\n    char move(char c, bool forward) {\\n        if (forward) {\\n            if (c == \\'9\\') {\\n                return \\'0\\';\\n            } else {\\n                return c + 1;\\n            }\\n        } else {\\n            if (c == \\'0\\') {\\n                return \\'9\\';\\n            } else {\\n                return c - 1;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001382,
                "title": "can-t-be-more-simpler-clearer-cpp-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    string moveUp(string cur, int location)\\n    {\\n        if(cur[location] == \\'9\\')\\n            cur[location] = \\'0\\';\\n        else\\n            cur[location] += 1;\\n        \\n        return cur;\\n    }\\n    \\n    string moveDown(string cur, int location)\\n    {\\n        if(cur[location] == \\'0\\')\\n            cur[location] = \\'9\\';\\n        else\\n            cur[location] -= 1;\\n        \\n        return cur;\\n    }\\n    \\n    int openLock(vector<string>& deadends, string target) {\\n        queue<string> q;\\n        set<string> visited;\\n        int steps = 0;\\n            \\n        q.push(\"0000\");\\n        visited.insert(\"0000\");\\n        \\n        while(!q.empty())\\n        {\\n            int len = q.size();\\n            \\n            for(int i = 0; i < len; i++)\\n            {\\n                string cur = q.front();\\n                q.pop();\\n                \\n                if(find(deadends.begin(), deadends.end(), cur) != deadends.end())\\n                    continue;\\n                \\n                if(cur ==  target)\\n                    return steps;\\n                \\n                for(int j = 0; j < 4; j++)\\n                {\\n                    string up = moveUp(cur, j);\\n                    if(visited.find(up) == visited.end())\\n                    {\\n                        q.push(up);\\n                        visited.insert(up);\\n                    }\\n                    \\n                    string down = moveDown(cur, j);\\n                    if(visited.find(down) == visited.end())\\n                    {\\n                        q.push(down);\\n                        visited.insert(down);\\n                    }\\n                }\\n            }\\n            \\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string moveUp(string cur, int location)\\n    {\\n        if(cur[location] == \\'9\\')\\n            cur[location] = \\'0\\';\\n        else\\n            cur[location] += 1;\\n        \\n        return cur;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1965333,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> set = new HashSet();\\n        Set<String> locked = new HashSet();\\n        for(String s: deadends)\\n            locked.add(s);\\n        \\n        Queue<String> q = new LinkedList();\\n        int moves = 0;\\n        q.offer(\"0000\");\\n        set.add(\"0000\");\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            for(int j = 0; j < size; j++)\\n            {\\n                String current = q.poll();\\n                \\n                if(current.equals(target)) return moves;\\n                \\n                StringBuilder sb = new StringBuilder(current);\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    char c = sb.charAt(i);\\n                    String s1 = sb.substring(0, i) + (c == \\'9\\' ? 0 : c - \\'0\\' + 1) + sb.substring(i + 1);\\n                    String s2 = sb.substring(0, i) + (c == \\'0\\' ? 9 : c - \\'0\\' - 1) + sb.substring(i + 1);\\n                    \\n                    if(!set.contains(s1) && !locked.contains(current))\\n                    {\\n                        set.add(s1);\\n                        q.offer(s1);\\n                    }\\n                    if(!set.contains(s2) && !locked.contains(current))\\n                    {\\n                        set.add(s2);\\n                        q.offer(s2);\\n                    }\\n                }\\n            }\\n            moves++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> set = new HashSet();\\n        Set<String> locked = new HashSet();\\n        for(String s: deadends)\\n            locked.add(s);\\n        \\n        Queue<String> q = new LinkedList();\\n        int moves = 0;\\n        q.offer(\"0000\");\\n        set.add(\"0000\");\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            for(int j = 0; j < size; j++)\\n            {\\n                String current = q.poll();\\n                \\n                if(current.equals(target)) return moves;\\n                \\n                StringBuilder sb = new StringBuilder(current);\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    char c = sb.charAt(i);\\n                    String s1 = sb.substring(0, i) + (c == \\'9\\' ? 0 : c - \\'0\\' + 1) + sb.substring(i + 1);\\n                    String s2 = sb.substring(0, i) + (c == \\'0\\' ? 9 : c - \\'0\\' - 1) + sb.substring(i + 1);\\n                    \\n                    if(!set.contains(s1) && !locked.contains(current))\\n                    {\\n                        set.add(s1);\\n                        q.offer(s1);\\n                    }\\n                    if(!set.contains(s2) && !locked.contains(current))\\n                    {\\n                        set.add(s2);\\n                        q.offer(s2);\\n                    }\\n                }\\n            }\\n            moves++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891281,
                "title": "dfs-dp-c-82ms",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 10e7;\\n    int dp[10][10][10][10];\\n    bool dead[10][10][10][10];\\n    \\n    int openLock(vector<string>& deadends, string target) {\\n        if(target == \"0000\") return 0;\\n        for(int a=0; a<10; a++)\\n            for(int b=0; b<10; b++)\\n                for(int c=0; c<10; c++)\\n                    for(int d=0; d<10; d++)\\n                        dead[a][b][c][d] = false;\\n        \\n        for(int a=0; a<10; a++)\\n            for(int b=0; b<10; b++)\\n                for(int c=0; c<10; c++)\\n                    for(int d=0; d<10; d++)\\n                        dp[a][b][c][d] = INF;\\n            \\n    \\n        for(int i=0; i<deadends.size(); i++)\\n            dead[deadends[i][0]-\\'0\\'][deadends[i][1]-\\'0\\'][deadends[i][2]-\\'0\\'][deadends[i][3]-\\'0\\'] = true;\\n        \\n        dp[0][0][0][0] = 0;\\n        dfs(0, 0, 0, 0);\\n        int realans = dp[target[0]-\\'0\\'][target[1]-\\'0\\'][target[2]-\\'0\\'][target[3]-\\'0\\'];\\n        return (realans < 0 || realans >= INF) ? -1 : realans;\\n    }\\n    \\n    void dfs(int a, int b, int c, int d){\\n        if(dead[a][b][c][d]) return;\\n\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[(a+1)%10][b][c][d]);\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[(a+9)%10][b][c][d]);\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[a][(b+1)%10][c][d]);\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[a][(b+9)%10][c][d]);\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[a][b][(c+1)%10][d]);\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[a][b][(c+9)%10][d]);\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[a][b][c][(d+1)%10]);\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[a][b][c][(d+9)%10]);\\n        \\n\\n        if(dp[(a+1)%10][b][c][d] > dp[a][b][c][d] + 1) {\\n            dfs((a+1)%10, b, c, d);\\n        }\\n        if(dp[(a+9)%10][b][c][d] > dp[a][b][c][d] + 1) {\\n            dfs((a+9)%10, b, c, d);\\n        }\\n        \\n        if(dp[a][(b+1)%10][c][d] > dp[a][b][c][d] + 1) {\\n            dfs(a, (b+1)%10, c, d);\\n        }\\n        if(dp[a][(b+9)%10][c][d] > dp[a][b][c][d] + 1) {\\n            dfs(a, (b+9)%10, c, d);\\n        }\\n        \\n        if(dp[a][b][(c+1)%10][d] > dp[a][b][c][d] + 1) {\\n            dfs(a, b, (c+1)%10, d);\\n        }\\n        if(dp[a][b][(c+9)%10][d] > dp[a][b][c][d] + 1) {\\n            dfs(a, b, (c+9)%10, d);\\n        }\\n        \\n        if(dp[a][b][c][(d+1)%10] > dp[a][b][c][d] + 1) {\\n            dfs(a, b, c, (d+1)%10);\\n        }\\n        if(dp[a][b][c][(d+9)%10] > dp[a][b][c][d] + 1) {\\n            dfs(a, b, c, (d+9)%10);\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 10e7;\\n    int dp[10][10][10][10];\\n    bool dead[10][10][10][10];\\n    \\n    int openLock(vector<string>& deadends, string target) {\\n        if(target == \"0000\") return 0;\\n        for(int a=0; a<10; a++)\\n            for(int b=0; b<10; b++)\\n                for(int c=0; c<10; c++)\\n                    for(int d=0; d<10; d++)\\n                        dead[a][b][c][d] = false;\\n        \\n        for(int a=0; a<10; a++)\\n            for(int b=0; b<10; b++)\\n                for(int c=0; c<10; c++)\\n                    for(int d=0; d<10; d++)\\n                        dp[a][b][c][d] = INF;\\n            \\n    \\n        for(int i=0; i<deadends.size(); i++)\\n            dead[deadends[i][0]-\\'0\\'][deadends[i][1]-\\'0\\'][deadends[i][2]-\\'0\\'][deadends[i][3]-\\'0\\'] = true;\\n        \\n        dp[0][0][0][0] = 0;\\n        dfs(0, 0, 0, 0);\\n        int realans = dp[target[0]-\\'0\\'][target[1]-\\'0\\'][target[2]-\\'0\\'][target[3]-\\'0\\'];\\n        return (realans < 0 || realans >= INF) ? -1 : realans;\\n    }\\n    \\n    void dfs(int a, int b, int c, int d){\\n        if(dead[a][b][c][d]) return;\\n\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[(a+1)%10][b][c][d]);\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[(a+9)%10][b][c][d]);\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[a][(b+1)%10][c][d]);\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[a][(b+9)%10][c][d]);\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[a][b][(c+1)%10][d]);\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[a][b][(c+9)%10][d]);\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[a][b][c][(d+1)%10]);\\n        dp[a][b][c][d] = min(dp[a][b][c][d], 1 + dp[a][b][c][(d+9)%10]);\\n        \\n\\n        if(dp[(a+1)%10][b][c][d] > dp[a][b][c][d] + 1) {\\n            dfs((a+1)%10, b, c, d);\\n        }\\n        if(dp[(a+9)%10][b][c][d] > dp[a][b][c][d] + 1) {\\n            dfs((a+9)%10, b, c, d);\\n        }\\n        \\n        if(dp[a][(b+1)%10][c][d] > dp[a][b][c][d] + 1) {\\n            dfs(a, (b+1)%10, c, d);\\n        }\\n        if(dp[a][(b+9)%10][c][d] > dp[a][b][c][d] + 1) {\\n            dfs(a, (b+9)%10, c, d);\\n        }\\n        \\n        if(dp[a][b][(c+1)%10][d] > dp[a][b][c][d] + 1) {\\n            dfs(a, b, (c+1)%10, d);\\n        }\\n        if(dp[a][b][(c+9)%10][d] > dp[a][b][c][d] + 1) {\\n            dfs(a, b, (c+9)%10, d);\\n        }\\n        \\n        if(dp[a][b][c][(d+1)%10] > dp[a][b][c][d] + 1) {\\n            dfs(a, b, c, (d+1)%10);\\n        }\\n        if(dp[a][b][c][(d+9)%10] > dp[a][b][c][d] + 1) {\\n            dfs(a, b, c, (d+9)%10);\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832090,
                "title": "solution-swift-open-the-lock-test-cases",
                "content": "```swift\\nclass Solution {\\n    func openLock(_ deadends: [String], _ target: String) -> Int {\\n        let ddends = deadends.map { $0.compactMap { Int(\"\\\\($0)\") }}\\n        let trgInt = target.compactMap { Int(\"\\\\($0)\") }\\n        \\n        var queue = [[0,0,0,0]], vzitd = Set(queue)\\n        var turns = 0\\n        \\n        while !queue.isEmpty {\\n            for _ in 0..<queue.count {\\n                let cur = queue.removeFirst()\\n                if ddends.contains(cur) { continue }\\n                if cur == trgInt { return turns }\\n                for i in 0...3 {\\n                    for d in stride(from: -1, through: 1, by: 2) {\\n                        var nbr: [Int] = cur\\n                        nbr[i] = ((nbr[i] + d) + 10) % 10\\n                        if !vzitd.contains(nbr) && !ddends.contains(nbr) {\\n                            queue.append(nbr)\\n                            vzitd.insert(nbr)\\n                        }\\n                    }\\n                }\\n            }\\n            turns += 1\\n        }\\n        return -1\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 34.202 (34.205) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /*\\n        A sequence of valid moves would be\\n            \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\".\\n        Note that a sequence like\\n            \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid,\\n        because the wheels of the lock become stuck after the display becomes the dead end \"0102\".\\n    */\\n    func test0() {\\n        let value = solution.openLock([\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], \"0202\")\\n        XCTAssertEqual(value, 6)\\n    }\\n    \\n    // We can turn the last wheel in reverse to move from \"0000\" -> \"0009\".\\n    func test1() {\\n        let value = solution.openLock([\"8888\"], \"0009\")\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    // We cannot reach the target without getting stuck.\\n    func test2() {\\n        let value = solution.openLock([\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], \"8888\")\\n        XCTAssertEqual(value, -1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift",
                    "Queue"
                ],
                "code": "```swift\\nclass Solution {\\n    func openLock(_ deadends: [String], _ target: String) -> Int {\\n        let ddends = deadends.map { $0.compactMap { Int(\"\\\\($0)\") }}\\n        let trgInt = target.compactMap { Int(\"\\\\($0)\") }\\n        \\n        var queue = [[0,0,0,0]], vzitd = Set(queue)\\n        var turns = 0\\n        \\n        while !queue.isEmpty {\\n            for _ in 0..<queue.count {\\n                let cur = queue.removeFirst()\\n                if ddends.contains(cur) { continue }\\n                if cur == trgInt { return turns }\\n                for i in 0...3 {\\n                    for d in stride(from: -1, through: 1, by: 2) {\\n                        var nbr: [Int] = cur\\n                        nbr[i] = ((nbr[i] + d) + 10) % 10\\n                        if !vzitd.contains(nbr) && !ddends.contains(nbr) {\\n                            queue.append(nbr)\\n                            vzitd.insert(nbr)\\n                        }\\n                    }\\n                }\\n            }\\n            turns += 1\\n        }\\n        return -1\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /*\\n        A sequence of valid moves would be\\n            \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\".\\n        Note that a sequence like\\n            \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid,\\n        because the wheels of the lock become stuck after the display becomes the dead end \"0102\".\\n    */\\n    func test0() {\\n        let value = solution.openLock([\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], \"0202\")\\n        XCTAssertEqual(value, 6)\\n    }\\n    \\n    // We can turn the last wheel in reverse to move from \"0000\" -> \"0009\".\\n    func test1() {\\n        let value = solution.openLock([\"8888\"], \"0009\")\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    // We cannot reach the target without getting stuck.\\n    func test2() {\\n        let value = solution.openLock([\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], \"8888\")\\n        XCTAssertEqual(value, -1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742778,
                "title": "javascript-bfs",
                "content": "```\\n// calculate prev & next number - iterations of m (= 10)\\nconst fix = (n, m) => {\\n    return ((n % m) + m) % m;\\n};\\n\\n/**\\n * @param {string[]} deadends\\n * @param {string} target\\n * @return {number}\\n */\\nvar openLock = function(deadends, target) {\\n    \\n    const queue = [\\'0000\\'];\\n    let distance = 0;\\n    \\n    // create a map of visited + deadends\\n    const map = {};\\n    for(let i=0; i<deadends.length; i++){\\n        map[deadends[i]] = true;\\n    }\\n    \\n    // BFS ---------\\n    while(queue.length > 0){\\n        \\n        let queueLength = queue.length;\\n        \\n        while(queueLength--){\\n            const node = queue.shift();\\n            \\n            // the target is found\\n            if(node === target) return distance;\\n            \\n            // if deadend or visited\\n            if(map[node]) continue;\\n            \\n            // mark as visited\\n            map[node] = true;\\n            \\n            // for each wheel\\n            for(let i=0; i<4; i++){\\n                \\n                // -1 = backwards, 1 = forwards\\n                for(let direction of [-1, 1]){\\n                    \\n                    // generate the relevant string\\n                    const num = fix(Number(node[i]) + direction, 10);\\n                    const prefix = node.substring(0, i);\\n                    const suffix = node.substring(i + 1, 4);\\n                    const updated = `${prefix}${num}${suffix}`;\\n                    \\n                    queue.push(updated);\\n                }\\n            }\\n        }\\n        \\n        distance++;\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n// calculate prev & next number - iterations of m (= 10)\\nconst fix = (n, m) => {\\n    return ((n % m) + m) % m;\\n};\\n\\n/**\\n * @param {string[]} deadends\\n * @param {string} target\\n * @return {number}\\n */\\nvar openLock = function(deadends, target) {\\n    \\n    const queue = [\\'0000\\'];\\n    let distance = 0;\\n    \\n    // create a map of visited + deadends\\n    const map = {};\\n    for(let i=0; i<deadends.length; i++){\\n        map[deadends[i]] = true;\\n    }\\n    \\n    // BFS ---------\\n    while(queue.length > 0){\\n        \\n        let queueLength = queue.length;\\n        \\n        while(queueLength--){\\n            const node = queue.shift();\\n            \\n            // the target is found\\n            if(node === target) return distance;\\n            \\n            // if deadend or visited\\n            if(map[node]) continue;\\n            \\n            // mark as visited\\n            map[node] = true;\\n            \\n            // for each wheel\\n            for(let i=0; i<4; i++){\\n                \\n                // -1 = backwards, 1 = forwards\\n                for(let direction of [-1, 1]){\\n                    \\n                    // generate the relevant string\\n                    const num = fix(Number(node[i]) + direction, 10);\\n                    const prefix = node.substring(0, i);\\n                    const suffix = node.substring(i + 1, 4);\\n                    const updated = `${prefix}${num}${suffix}`;\\n                    \\n                    queue.push(updated);\\n                }\\n            }\\n        }\\n        \\n        distance++;\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1362838,
                "title": "python-bfs-the-most-standard-answer-template-for-bfs",
                "content": "```\\nfrom collections import deque\\nimport string\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        \\n        # avoid TLE\\n        wordList_new = set(wordList)\\n        \\n        # define the queue\\n        queue = deque()\\n        \\n        # put the 1st string into the queue\\n        queue.append(beginWord)\\n        \\n        # create a set to record the visited string\\n        visited = set()\\n        \\n        # put the begingWord into the visited\\n        visited.update(queue)\\n        \\n        # make a count to record the final result\\n        result = 0\\n        \\n        # BFS\\n        while queue:\\n            \\n            # here we write result + 1 here\\n            # because if we write in the end, the number will be left 1 \\n            result += 1\\n            \\n            # take out the 1st element in the queue\\n            for _ in range(len(queue)):\\n                pop = queue.popleft()\\n                \\n                # judge first, if this pop is the endWord\\n                if pop == endWord:\\n                    return result\\n                \\n                # now, it seems no other to continue\\n                # let us find the neighbor safely\\n                for i in range(len(beginWord)):\\n                    for alphabet in string.ascii_lowercase:\\n                        neighbor = pop[:i] + alphabet + pop[i+1:]\\n                        \\n                        # judge if this neighbor in wordList_new and in visited\\n                        if neighbor in wordList_new and neighbor not in visited:\\n                            \\n                            # put the neighbor into the queue\\n                            queue.append(neighbor)\\n                            \\n                            # put this neighbor into the visited set\\n                            visited.add(neighbor)\\n                            \\n        # if the whole traversal we still can not find the endWord\\n        # This means the sequence does not exist, we return 0\\n        return 0     \\n```\\n\\nThe similar question is open the lock. The difference between this 2 problems is the way to find the neighbor. The core thinking is the same. In that question, we find the neighbor like 0 -> 9, 1; in this question, we find a -> z, b.",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nimport string\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        \\n        # avoid TLE\\n        wordList_new = set(wordList)\\n        \\n        # define the queue\\n        queue = deque()\\n        \\n        # put the 1st string into the queue\\n        queue.append(beginWord)\\n        \\n        # create a set to record the visited string\\n        visited = set()\\n        \\n        # put the begingWord into the visited\\n        visited.update(queue)\\n        \\n        # make a count to record the final result\\n        result = 0\\n        \\n        # BFS\\n        while queue:\\n            \\n            # here we write result + 1 here\\n            # because if we write in the end, the number will be left 1 \\n            result += 1\\n            \\n            # take out the 1st element in the queue\\n            for _ in range(len(queue)):\\n                pop = queue.popleft()\\n                \\n                # judge first, if this pop is the endWord\\n                if pop == endWord:\\n                    return result\\n                \\n                # now, it seems no other to continue\\n                # let us find the neighbor safely\\n                for i in range(len(beginWord)):\\n                    for alphabet in string.ascii_lowercase:\\n                        neighbor = pop[:i] + alphabet + pop[i+1:]\\n                        \\n                        # judge if this neighbor in wordList_new and in visited\\n                        if neighbor in wordList_new and neighbor not in visited:\\n                            \\n                            # put the neighbor into the queue\\n                            queue.append(neighbor)\\n                            \\n                            # put this neighbor into the visited set\\n                            visited.add(neighbor)\\n                            \\n        # if the whole traversal we still can not find the endWord\\n        # This means the sequence does not exist, we return 0\\n        return 0     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252005,
                "title": "ruby-bfs",
                "content": "```\\n# @param {String[]} deadends\\n# @param {String} target\\n# @return {Integer}\\ndef open_lock(deadends, target)\\n  dead_set = Set.new(deadends)\\n  queue = [[\\'0000\\', 0]]\\n  visited = Set.new([\\'0000\\'])\\n\\n  until queue.empty?\\n    string, steps = queue.shift\\n    if string == target\\n      return steps\\n    elsif dead_set.include?(string)\\n      next\\n    end\\n\\n    4.times do |i|\\n      digit = string[i].to_i\\n      [-1, 1].each do |move|\\n        new_digit = (digit + move) % 10\\n        new_string = string[0...i] + new_digit.to_s + string[i+1..-1]\\n        unless visited.include?(new_string)\\n          visited << new_string\\n          queue << [new_string, steps+1]\\n        end\\n      end\\n    end\\n  end\\n  \\n  -1\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Breadth-First Search"
                ],
                "code": "```\\n# @param {String[]} deadends\\n# @param {String} target\\n# @return {Integer}\\ndef open_lock(deadends, target)\\n  dead_set = Set.new(deadends)\\n  queue = [[\\'0000\\', 0]]\\n  visited = Set.new([\\'0000\\'])\\n\\n  until queue.empty?\\n    string, steps = queue.shift\\n    if string == target\\n      return steps\\n    elsif dead_set.include?(string)\\n      next\\n    end\\n\\n    4.times do |i|\\n      digit = string[i].to_i\\n      [-1, 1].each do |move|\\n        new_digit = (digit + move) % 10\\n        new_string = string[0...i] + new_digit.to_s + string[i+1..-1]\\n        unless visited.include?(new_string)\\n          visited << new_string\\n          queue << [new_string, steps+1]\\n        end\\n      end\\n    end\\n  end\\n  \\n  -1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1251244,
                "title": "c-similar-to-word-ladder-question",
                "content": "[CLICK TO SEE SIMILAR Qn : WORD LADDER](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Graph/Word_Ladder.cpp)\\n```\\n/*\\n    Also popular as  : Minimum rotations to unlock a circular lock\\n    Similar Question : Word Ladder ( Microsoft, Amazon )\\n\\t\\n*/\\n\\nclass Solution {\\npublic:\\n    void fillNeighbors(queue<string>& que, string& curr, set<string>& dead) {\\n        for(int i = 0; i<4; i++) {\\n            char ch  = curr[i];\\n\\n            char dec = ch==\\'0\\' ? \\'9\\' : ch-1;\\n            char inc = ch==\\'9\\' ? \\'0\\' : ch+1;\\n\\n            curr[i]  = dec;\\n            if(!dead.count(curr) && !dead.count(curr)) {\\n                dead.insert(curr);\\n                que.push(curr);\\n            }\\n\\n            curr[i] = inc;\\n            if(!dead.count(curr) && !dead.count(curr)) {\\n                dead.insert(curr);\\n                que.push(curr);\\n            }\\n\\n            curr[i] = ch;\\n        }\\n    }\\n    int openLock(vector<string>& deadends, string target) {\\n        set<string> dead(begin(deadends), end(deadends));\\n        \\n        string start = \"0000\";        \\n        if(dead.count(start))\\n            return -1;\\n        \\n        queue<string> que;\\n        que.push(start);\\n        \\n        int level = 0;\\n        while(!que.empty()) {\\n            int n = que.size();\\n            \\n            while(n--) {\\n                string curr = que.front();\\n                que.pop();\\n                if(curr == target)\\n                    return level;\\n                \\n                fillNeighbors(que, curr, dead);\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Also popular as  : Minimum rotations to unlock a circular lock\\n    Similar Question : Word Ladder ( Microsoft, Amazon )\\n\\t\\n*/\\n\\nclass Solution {\\npublic:\\n    void fillNeighbors(queue<string>& que, string& curr, set<string>& dead) {\\n        for(int i = 0; i<4; i++) {\\n            char ch  = curr[i];\\n\\n            char dec = ch==\\'0\\' ? \\'9\\' : ch-1;\\n            char inc = ch==\\'9\\' ? \\'0\\' : ch+1;\\n\\n            curr[i]  = dec;\\n            if(!dead.count(curr) && !dead.count(curr)) {\\n                dead.insert(curr);\\n                que.push(curr);\\n            }\\n\\n            curr[i] = inc;\\n            if(!dead.count(curr) && !dead.count(curr)) {\\n                dead.insert(curr);\\n                que.push(curr);\\n            }\\n\\n            curr[i] = ch;\\n        }\\n    }\\n    int openLock(vector<string>& deadends, string target) {\\n        set<string> dead(begin(deadends), end(deadends));\\n        \\n        string start = \"0000\";        \\n        if(dead.count(start))\\n            return -1;\\n        \\n        queue<string> que;\\n        que.push(start);\\n        \\n        int level = 0;\\n        while(!que.empty()) {\\n            int n = que.size();\\n            \\n            while(n--) {\\n                string curr = que.front();\\n                que.pop();\\n                if(curr == target)\\n                    return level;\\n                \\n                fillNeighbors(que, curr, dead);\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251112,
                "title": "easy-c-solution-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        \\n        //we push all the deadends into the hashset so it would be easy to find\\n        unordered_set<string> deadEnds(deadends.begin(),deadends.end());\\n        \\n        \\n        //we check if the \"0000\" itself is a dead end\\n        if(deadEnds.count(\"0000\"))\\n            return -1;\\n        \\n        //visited stores the patteres which have already tried\\n        unordered_set<string> visited; \\n        visited.insert(\"0000\");\\n        \\n        //we use queue to implement BFS \\n        queue<string> q;\\n        q.push(\"0000\");\\n        int level=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size)\\n            {\\n                //get the next pattern and previous pattern for every character in the front of the string\\n                \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0//example 1000 - {2000,0000} for 1st wheel\\n                string front=q.front();\\n                q.pop();\\n                if(front==target)\\n                    return level;\\n                for(int i=0;i<4;i++)\\n                {\\n                    string s1=front;\\n                    s1[i]=(s1[i]-\\'0\\'==9) ? \\'0\\' : s1[i]-\\'0\\'+1+\\'0\\'; //increment value in that wheel\\n                    //decrement the value in string\\n                    string s2=front;\\n                    s2[i]=(s2[i]-\\'0\\'==0) ? \\'9\\' : s2[i]-\\'0\\'-1+\\'0\\';\\n                    \\n                    if(!visited.count(s1) && !deadEnds.count(s1))\\n                    {\\n                        q.push(s1);\\n                        visited.insert(s1);\\n                    }\\n                    if(!visited.count(s2) && !deadEnds.count(s2))\\n                    {\\n                        q.push(s2);\\n                        visited.insert(s2); //since we have visited\\n                    }\\n                }\\n                size--;\\n                \\n            }\\n            level++;\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```\\n\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        \\n        //we push all the deadends into the hashset so it would be easy to find\\n        unordered_set<string> deadEnds(deadends.begin(),deadends.end());\\n        \\n        \\n        //we check if the \"0000\" itself is a dead end\\n        if(deadEnds.count(\"0000\"))\\n            return -1;\\n        \\n        //visited stores the patteres which have already tried\\n        unordered_set<string> visited; \\n        visited.insert(\"0000\");\\n        \\n        //we use queue to implement BFS \\n        queue<string> q;\\n        q.push(\"0000\");\\n        int level=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size)\\n            {\\n                //get the next pattern and previous pattern for every character in the front of the string\\n                \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0//example 1000 - {2000,0000} for 1st wheel\\n                string front=q.front();\\n                q.pop();\\n                if(front==target)\\n                    return level;\\n                for(int i=0;i<4;i++)\\n                {\\n                    string s1=front;\\n                    s1[i]=(s1[i]-\\'0\\'==9) ? \\'0\\' : s1[i]-\\'0\\'+1+\\'0\\'; //increment value in that wheel\\n                    //decrement the value in string\\n                    string s2=front;\\n                    s2[i]=(s2[i]-\\'0\\'==0) ? \\'9\\' : s2[i]-\\'0\\'-1+\\'0\\';\\n                    \\n                    if(!visited.count(s1) && !deadEnds.count(s1))\\n                    {\\n                        q.push(s1);\\n                        visited.insert(s1);\\n                    }\\n                    if(!visited.count(s2) && !deadEnds.count(s2))\\n                    {\\n                        q.push(s2);\\n                        visited.insert(s2); //since we have visited\\n                    }\\n                }\\n                size--;\\n                \\n            }\\n            level++;\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227206,
                "title": "rust-bi-directional-bfs-8ms-2-2m-100",
                "content": "```rust\\npub fn open_lock(deadends: Vec<String>, target: String) -> i32 {\\n    use std::collections::{HashSet, VecDeque};\\n    let target: u32 = target.parse().unwrap();\\n    let mut deadends: HashSet<u32> = deadends.into_iter().map(|x| x.parse().unwrap()).collect();\\n    let mut s1: HashSet<u32> = HashSet::new();\\n    let mut s2: HashSet<u32> = HashSet::new();\\n    let mut q1 = VecDeque::new();\\n    let mut q2 = VecDeque::new();\\n    q1.push_back(0);\\n    q2.push_back(target);\\n    let mut steps = 0;\\n    while !q1.is_empty() {\\n        for i in (0..q1.len()) {\\n            let curr = q1.pop_front().unwrap();\\n            if s2.contains(&curr) {\\n                return steps - 1;\\n            }\\n            if deadends.contains(&curr) || !s1.insert(curr) {\\n                continue;\\n            }\\n            for i in [1, 10, 100, 1000] {\\n                let old = curr / i % 10;\\n                q1.push_back(curr - old * i + ((old + 1) % 10) * i);\\n                q1.push_back(curr - old * i + ((old + 9) % 10) * i);\\n            }\\n        }\\n        steps += 1;\\n        std::mem::swap(&mut s1, &mut s2);\\n        std::mem::swap(&mut q1, &mut q2);\\n    }\\n    -1\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn open_lock(deadends: Vec<String>, target: String) -> i32 {\\n    use std::collections::{HashSet, VecDeque};\\n    let target: u32 = target.parse().unwrap();\\n    let mut deadends: HashSet<u32> = deadends.into_iter().map(|x| x.parse().unwrap()).collect();\\n    let mut s1: HashSet<u32> = HashSet::new();\\n    let mut s2: HashSet<u32> = HashSet::new();\\n    let mut q1 = VecDeque::new();\\n    let mut q2 = VecDeque::new();\\n    q1.push_back(0);\\n    q2.push_back(target);\\n    let mut steps = 0;\\n    while !q1.is_empty() {\\n        for i in (0..q1.len()) {\\n            let curr = q1.pop_front().unwrap();\\n            if s2.contains(&curr) {\\n                return steps - 1;\\n            }\\n            if deadends.contains(&curr) || !s1.insert(curr) {\\n                continue;\\n            }\\n            for i in [1, 10, 100, 1000] {\\n                let old = curr / i % 10;\\n                q1.push_back(curr - old * i + ((old + 1) % 10) * i);\\n                q1.push_back(curr - old * i + ((old + 9) % 10) * i);\\n            }\\n        }\\n        steps += 1;\\n        std::mem::swap(&mut s1, &mut s2);\\n        std::mem::swap(&mut q1, &mut q2);\\n    }\\n    -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1137906,
                "title": "java-bfs",
                "content": "\\tclass Solution {\\n\\t\\tpublic int openLock(String[] deadends, String target) {\\n\\n\\t\\t\\tString source = \"0000\";\\n\\t\\t\\tHashSet<String> dead = new HashSet<>();\\n\\t\\t\\tLinkedList<Pair<String, Integer>> queue = new LinkedList<>();\\n\\t\\t\\tHashSet<String> seen = new HashSet<>();\\n\\n\\t\\t\\tfor(String str : deadends) {\\n\\t\\t\\t\\tdead.add(str);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (dead.contains(source)) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tqueue.offer(new Pair(source, 0));\\n\\t\\t\\tseen.add(source);\\n\\n\\t\\t\\twhile (queue.size() > 0) {\\n\\n\\t\\t\\t\\tPair<String,Integer> kv = queue.poll();\\n\\t\\t\\t\\tString value = kv.getKey();\\n\\t\\t\\t\\tint steps = kv.getValue();\\n\\n\\n\\t\\t\\t\\t// check if value is target, if not add values adjacent values in direction of target\\n\\t\\t\\t\\tif (value.equals(target)) return steps;\\n\\n\\n\\t\\t\\t\\tsteps++;\\n\\n\\n\\t\\t\\t\\tfor(int i = 0; i < value.length(); ++i) {\\n\\t\\t\\t\\t\\tStringBuilder sb = new StringBuilder(value);\\n\\n\\t\\t\\t\\t\\tchar c = value.charAt(i);\\n\\n\\t\\t\\t\\t\\t// check if char is a wrap around\\n\\t\\t\\t\\t\\tif (c == \\'0\\') {\\n\\t\\t\\t\\t\\t\\tsb.setCharAt(i, \\'9\\');\\n\\t\\t\\t\\t\\t\\taddToQueue(queue, dead, sb, steps, seen);\\n\\t\\t\\t\\t\\t\\tsb.setCharAt(i, \\'1\\');\\n\\t\\t\\t\\t\\t\\taddToQueue(queue, dead, sb, steps, seen);\\n\\t\\t\\t\\t\\t} else if (c == \\'9\\') {\\n\\t\\t\\t\\t\\t\\tsb.setCharAt(i, \\'0\\');\\n\\t\\t\\t\\t\\t\\taddToQueue(queue, dead, sb, steps, seen);\\n\\t\\t\\t\\t\\t\\tsb.setCharAt(i, \\'8\\');\\n\\t\\t\\t\\t\\t\\taddToQueue(queue, dead, sb, steps, seen);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t\\tsb.setCharAt(i, c);\\n\\t\\t\\t\\t\\t\\taddToQueue(queue, dead, sb, steps, seen);\\n\\t\\t\\t\\t\\t\\tc-=2;\\n\\t\\t\\t\\t\\t\\tsb.setCharAt(i, c);\\n\\t\\t\\t\\t\\t\\taddToQueue(queue, dead, sb, steps, seen);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn -1;\\n\\n\\t\\t}\\n\\n\\n\\t\\tpublic void addToQueue(LinkedList<Pair<String,Integer>> queue, HashSet<String> dead, StringBuilder sb, int steps, HashSet<String> seen) {\\n\\t\\t\\tString s = sb.toString();\\n\\t\\t\\tif (!dead.contains(s) && !seen.contains(s)) {\\n\\t\\t\\t\\tqueue.offer(new Pair(s, steps));\\n\\t\\t\\t\\tseen.add(s);\\n\\t\\t\\t}\\n\\t\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int openLock(String[] deadends, String target) {\\n\\n\\t\\t\\tString source = \"0000\";\\n\\t\\t\\tHashSet<String> dead = new HashSet<>();\\n\\t\\t\\tLinkedList<Pair<String, Integer>> queue = new LinkedList<>();\\n\\t\\t\\tHashSet<String> seen = new HashSet<>();\\n\\n\\t\\t\\tfor(String str : deadends) {\\n\\t\\t\\t\\tdead.add(str);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1031276,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        \\n        queue<string> q;\\n        unordered_set<string> dead(deadends.begin(), deadends.end());\\n        unordered_set<string> seen;\\n        \\n        if(dead.count(\"0000\"))\\n            return -1;\\n        seen.insert(\"0000\");\\n        q.push(\"0000\");\\n        int res = -1;\\n        while(!q.empty()) {\\n            \\n            int size = q.size();\\n            res++;\\n            for(int j = 0; j < size; j++) {\\n                string cur = q.front();\\n                q.pop();\\n                \\n                if(cur == target)\\n                    return res;\\n                for(int i = 0; i < cur.length(); i++) {\\n                    auto up = cur;\\n                    auto down = cur;\\n\\n                    up[i] = up[i] == \\'9\\' ? \\'0\\' : up[i] + 1;\\n                    down[i] = down[i] == \\'0\\' ? \\'9\\' : down[i] - 1;\\n                    \\n                    if(!dead.count(up) && !seen.count(up)) {\\n                        q.push(up);\\n                        seen.insert(up);\\n                    }\\n                    if(!dead.count(down) && !seen.count(down)) {\\n                        q.push(down);\\n                        seen.insert(down);\\n                    }\\n                }\\n\\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        \\n        queue<string> q;\\n        unordered_set<string> dead(deadends.begin(), deadends.end());\\n        unordered_set<string> seen;\\n        \\n        if(dead.count(\"0000\"))\\n            return -1;\\n        seen.insert(\"0000\");\\n        q.push(\"0000\");\\n        int res = -1;\\n        while(!q.empty()) {\\n            \\n            int size = q.size();\\n            res++;\\n            for(int j = 0; j < size; j++) {\\n                string cur = q.front();\\n                q.pop();\\n                \\n                if(cur == target)\\n                    return res;\\n                for(int i = 0; i < cur.length(); i++) {\\n                    auto up = cur;\\n                    auto down = cur;\\n\\n                    up[i] = up[i] == \\'9\\' ? \\'0\\' : up[i] + 1;\\n                    down[i] = down[i] == \\'0\\' ? \\'9\\' : down[i] - 1;\\n                    \\n                    if(!dead.count(up) && !seen.count(up)) {\\n                        q.push(up);\\n                        seen.insert(up);\\n                    }\\n                    if(!dead.count(down) && !seen.count(down)) {\\n                        q.push(down);\\n                        seen.insert(down);\\n                    }\\n                }\\n\\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959589,
                "title": "go-bfs",
                "content": "```\\nfunc openLock(deadends []string, target string) int {   \\n    dead := make(map[int]struct{})\\n    for _, v := range deadends {\\n        n, _ := strconv.Atoi(v)\\n        dead[n] = struct{}{}\\n    }\\n    \\n    tar, _ := strconv.Atoi(target)\\n    \\n    offset := []func(int)int{}\\n    \\n    a := 1\\n    for i := 0; i < 4; i++ {\\n        b := a\\n        f1 := func(j int) int {\\n            if j / b % 10 == 9 {\\n                return j - b * 9\\n            } else {\\n                return j + b\\n            }\\n        }\\n        f2 := func(j int) int {\\n            if j / b % 10 == 0 {\\n                return j + b * 9\\n            } else {\\n                return j - b\\n            }\\n        }\\n        offset = append(offset, f1)\\n        offset = append(offset, f2)\\n        a *= 10\\n    }\\n    \\n    set := make(map[int]struct{})\\n    queue := []int{0}\\n    set[0] = struct{}{}\\n    res := 0\\n    for len(queue) > 0 {\\n        l := len(queue)\\n        for i := 0; i < l; i++ {\\n            if _, ok := dead[queue[i]]; ok {\\n                continue\\n            }\\n            if queue[i] == tar {\\n                return res\\n            }\\n            for _, f := range offset {\\n                newnum := f(queue[i])\\n                if _, ok := set[newnum]; ok {\\n                    continue\\n                }\\n                queue = append(queue, newnum)\\n                set[newnum] = struct{}{}\\n            }\\n        }\\n        queue = queue[l:]\\n        res++\\n    }\\n    \\n    return -1\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc openLock(deadends []string, target string) int {   \\n    dead := make(map[int]struct{})\\n    for _, v := range deadends {\\n        n, _ := strconv.Atoi(v)\\n        dead[n] = struct{}{}\\n    }\\n    \\n    tar, _ := strconv.Atoi(target)\\n    \\n    offset := []func(int)int{}\\n    \\n    a := 1\\n    for i := 0; i < 4; i++ {\\n        b := a\\n        f1 := func(j int) int {\\n            if j / b % 10 == 9 {\\n                return j - b * 9\\n            } else {\\n                return j + b\\n            }\\n        }\\n        f2 := func(j int) int {\\n            if j / b % 10 == 0 {\\n                return j + b * 9\\n            } else {\\n                return j - b\\n            }\\n        }\\n        offset = append(offset, f1)\\n        offset = append(offset, f2)\\n        a *= 10\\n    }\\n    \\n    set := make(map[int]struct{})\\n    queue := []int{0}\\n    set[0] = struct{}{}\\n    res := 0\\n    for len(queue) > 0 {\\n        l := len(queue)\\n        for i := 0; i < l; i++ {\\n            if _, ok := dead[queue[i]]; ok {\\n                continue\\n            }\\n            if queue[i] == tar {\\n                return res\\n            }\\n            for _, f := range offset {\\n                newnum := f(queue[i])\\n                if _, ok := set[newnum]; ok {\\n                    continue\\n                }\\n                queue = append(queue, newnum)\\n                set[newnum] = struct{}{}\\n            }\\n        }\\n        queue = queue[l:]\\n        res++\\n    }\\n    \\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 916895,
                "title": "python3-bfs-dijkstra",
                "content": "Approach 1 - BFS (576ms, 69.33%)\\nDo a BFS search and return the steps when `target` is reached. \\n\\n```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        ans = 0\\n        queue = [\"0000\"]\\n        deadends = set(deadends)\\n        while queue: \\n            newq = []\\n            for n in queue: \\n                if n not in deadends: \\n                    deadends.add(n)\\n                    if n == target: return ans \\n                    for i in range(4): \\n                        for chg in (-1, 1): \\n                            nn = n[:i] + str((int(n[i]) + chg) % 10) + n[i+1:]\\n                            newq.append(nn)\\n            queue = newq\\n            ans += 1\\n        return -1 \\n```\\n\\n```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        deadends = set(deadends)\\n        if \"0000\" not in deadends: \\n            ans = 0\\n            queue = [\"0000\"]\\n            deadends.add(\"0000\")\\n            while queue: \\n                newq = []\\n                for n in queue: \\n                    if n == target: return ans \\n                    for i in range(4): \\n                        for chg in (-1, 1): \\n                            nn = n[:i] + str((int(n[i]) + chg) % 10) + n[i+1:]\\n                            if nn not in deadends: \\n                                newq.append(nn)\\n                                deadends.add(nn)\\n                queue = newq\\n                ans += 1\\n        return -1 \\n```\\n\\nDijkstra\\'s algo (652ms, 52.60%) \\nThis is a minimum distance problem for which Dijkstra\\'s algo is a perfect fit. \\n```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        deadends = set(deadends)\\n        if \"0000\" not in deadends: \\n            deadends.add(\"0000\")\\n            pq = [(0, \"0000\")]\\n            \\n            while pq: \\n                k, n = heappop(pq)\\n                if n == target: return k \\n                for i in range(4): \\n                    for chg in (-1, 1): \\n                        nn = n[:i] + str((int(n[i]) + chg) % 10) + n[i+1:]\\n                        if nn not in deadends: \\n                            deadends.add(nn)\\n                            heappush(pq, (k+1, nn))\\n        return -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        ans = 0\\n        queue = [\"0000\"]\\n        deadends = set(deadends)\\n        while queue: \\n            newq = []\\n            for n in queue: \\n                if n not in deadends: \\n                    deadends.add(n)\\n                    if n == target: return ans \\n                    for i in range(4): \\n                        for chg in (-1, 1): \\n                            nn = n[:i] + str((int(n[i]) + chg) % 10) + n[i+1:]\\n                            newq.append(nn)\\n            queue = newq\\n            ans += 1\\n        return -1 \\n```\n```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        deadends = set(deadends)\\n        if \"0000\" not in deadends: \\n            ans = 0\\n            queue = [\"0000\"]\\n            deadends.add(\"0000\")\\n            while queue: \\n                newq = []\\n                for n in queue: \\n                    if n == target: return ans \\n                    for i in range(4): \\n                        for chg in (-1, 1): \\n                            nn = n[:i] + str((int(n[i]) + chg) % 10) + n[i+1:]\\n                            if nn not in deadends: \\n                                newq.append(nn)\\n                                deadends.add(nn)\\n                queue = newq\\n                ans += 1\\n        return -1 \\n```\n```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        deadends = set(deadends)\\n        if \"0000\" not in deadends: \\n            deadends.add(\"0000\")\\n            pq = [(0, \"0000\")]\\n            \\n            while pq: \\n                k, n = heappop(pq)\\n                if n == target: return k \\n                for i in range(4): \\n                    for chg in (-1, 1): \\n                        nn = n[:i] + str((int(n[i]) + chg) % 10) + n[i+1:]\\n                        if nn not in deadends: \\n                            deadends.add(nn)\\n                            heappush(pq, (k+1, nn))\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 856673,
                "title": "easy-to-understand-java-solution-using-single-bfs",
                "content": "Algorithm\\n* We start with `0000` as our start point.\\n* In each step we generate a list of possible moves (max 8 distinct possibilities can be added per move)\\n\\t* max 4 possibilities in the forward direction\\n\\t* max 4 possibilities in the reverse direction\\n* We also keep track of options we have already seen before to avoid redundant calls.\\n\\n**Note:** *String manipulation and generationg takes most of the runtime, which can be significantly optimized using an integer variant.*\\n\\n```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        \\n        Set<String> set = new HashSet<>();\\n        for(String end : deadends) {\\n            set.add(end);\\n        }\\n        if(set.contains(\"0000\")) return -1;\\n        \\n        Queue<String> q = new LinkedList<>();\\n        q.offer(\"0000\"); // start with \"0000\"\\n        int step = 0;\\n        \\n        Set<String> visited = new HashSet<>();\\n        \\n        while(!q.isEmpty()) {\\n            step += 1; // increment number of steps needed\\n            int size = q.size();\\n            for(int i=0; i<size; i++) {\\n                String curr = q.poll();\\n                if(curr.equals(target)) return step-1; // ignore the increment added for \"0000\"\\n                if(!visited.contains(curr)) {\\n                    visited.add(curr); // add in visited set to avoid explored paths\\n                    List<String> nextMoves = generateMoves(curr, set);\\n                    for(String move : nextMoves) {\\n                        q.offer(move);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1; // failed to reach target\\n    }\\n    \\n    public List<String> generateMoves(String s, Set<String> set) {\\n        List<String> res = new ArrayList<>();\\n        char[] a = s.toCharArray();\\n        \\n        for(int i=0; i<4; i++) {\\n            char c = a[i];\\n            \\n            // generate forward move\\n            a[i] = c == \\'9\\' ? \\'0\\' : (char)(c + 1);\\n            String forwardStr = new String(a);\\n            // generate backward move\\n            a[i] = c == \\'0\\' ? \\'9\\' : (char)(c - 1);\\n            String backwardStr = new String(a);\\n            a[i] = c;\\n            \\n            if(!set.contains(backwardStr)) res.add(backwardStr);\\n            if(!set.contains(forwardStr)) res.add(forwardStr);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nHappy Coding !! :)",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        \\n        Set<String> set = new HashSet<>();\\n        for(String end : deadends) {\\n            set.add(end);\\n        }\\n        if(set.contains(\"0000\")) return -1;\\n        \\n        Queue<String> q = new LinkedList<>();\\n        q.offer(\"0000\"); // start with \"0000\"\\n        int step = 0;\\n        \\n        Set<String> visited = new HashSet<>();\\n        \\n        while(!q.isEmpty()) {\\n            step += 1; // increment number of steps needed\\n            int size = q.size();\\n            for(int i=0; i<size; i++) {\\n                String curr = q.poll();\\n                if(curr.equals(target)) return step-1; // ignore the increment added for \"0000\"\\n                if(!visited.contains(curr)) {\\n                    visited.add(curr); // add in visited set to avoid explored paths\\n                    List<String> nextMoves = generateMoves(curr, set);\\n                    for(String move : nextMoves) {\\n                        q.offer(move);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1; // failed to reach target\\n    }\\n    \\n    public List<String> generateMoves(String s, Set<String> set) {\\n        List<String> res = new ArrayList<>();\\n        char[] a = s.toCharArray();\\n        \\n        for(int i=0; i<4; i++) {\\n            char c = a[i];\\n            \\n            // generate forward move\\n            a[i] = c == \\'9\\' ? \\'0\\' : (char)(c + 1);\\n            String forwardStr = new String(a);\\n            // generate backward move\\n            a[i] = c == \\'0\\' ? \\'9\\' : (char)(c - 1);\\n            String backwardStr = new String(a);\\n            a[i] = c;\\n            \\n            if(!set.contains(backwardStr)) res.add(backwardStr);\\n            if(!set.contains(forwardStr)) res.add(forwardStr);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791846,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def combinations(self, start):\\n        ans = []\\n        states = [-1,1]\\n        \\n        for i,j in enumerate(start):\\n            for diff in states:\\n                val = (int(j) + diff) % 10\\n                ans.append(start[:i] + str(val) + start[i+1:])\\n        \\n        return ans\\n    \\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        deadends = set(deadends)\\n        start = \\'0000\\'\\n        q = deque()\\n        q.append((start, 0))\\n        vis = set()\\n        vis.add(start)\\n        \\n        while q:\\n            comb, level = q.popleft()\\n            \\n            if comb == target:\\n                return level\\n            \\n            if comb in deadends:\\n                continue\\n            \\n            for newComb in self.combinations(comb):\\n                if newComb not in vis:\\n                    vis.add(newComb)\\n                    q.append((newComb, level+1))\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def combinations(self, start):\\n        ans = []\\n        states = [-1,1]\\n        \\n        for i,j in enumerate(start):\\n            for diff in states:\\n                val = (int(j) + diff) % 10\\n                ans.append(start[:i] + str(val) + start[i+1:])\\n        \\n        return ans\\n    \\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        deadends = set(deadends)\\n        start = \\'0000\\'\\n        q = deque()\\n        q.append((start, 0))\\n        vis = set()\\n        vis.add(start)\\n        \\n        while q:\\n            comb, level = q.popleft()\\n            \\n            if comb == target:\\n                return level\\n            \\n            if comb in deadends:\\n                continue\\n            \\n            for newComb in self.combinations(comb):\\n                if newComb not in vis:\\n                    vis.add(newComb)\\n                    q.append((newComb, level+1))\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 758520,
                "title": "bfs-clean",
                "content": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> deadendsSet = new HashSet<>(Arrays.asList(deadends));\\n        \\n        Queue<String> q = new ArrayDeque<>();\\n        \\n        Set<String> seen = new HashSet<>();\\n        \\n        if (!deadendsSet.contains(\"0000\")) {\\n            q.offer(\"0000\");    \\n            seen.add(\"0000\");\\n        }\\n        \\n        int layer = 0;\\n        \\n        while (!q.isEmpty()) { \\n            int size = q.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                String cur = q.poll();\\n            \\n                if (cur.equals(target)) {\\n                    return layer;\\n                }\\n                \\n                for (String adj: getAdj(cur)) {\\n                    if (!deadendsSet.contains(adj) && !seen.contains(adj)) {\\n                        q.offer(adj);\\n                        seen.add(adj);\\n                    }\\n                }\\n            }\\n            \\n            layer++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    List<String> getAdj(String cur) {\\n        List<String> r = new ArrayList<>();\\n        \\n        // rotate left or right\\n        for (int i = 0; i < cur.length(); i++) {\\n            int wheelValue = Character.getNumericValue(cur.charAt(i));\\n            \\n            r.add(buildNextWheel(wheelValue + 1 > 9 ? 0 : wheelValue + 1, cur, i));\\n            \\n            r.add(buildNextWheel(wheelValue - 1 < 0 ? 9 : wheelValue - 1, cur, i));\\n        }\\n        \\n        return r;\\n    }\\n    \\n    String buildNextWheel(int wheelValue, String cur, int i) {\\n        StringBuilder sb = new StringBuilder(cur);\\n        sb.setCharAt(i, (char)(wheelValue + \\'0\\'));\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> deadendsSet = new HashSet<>(Arrays.asList(deadends));\\n        \\n        Queue<String> q = new ArrayDeque<>();\\n        \\n        Set<String> seen = new HashSet<>();\\n        \\n        if (!deadendsSet.contains(\"0000\")) {\\n            q.offer(\"0000\");    \\n            seen.add(\"0000\");\\n        }\\n        \\n        int layer = 0;\\n        \\n        while (!q.isEmpty()) { \\n            int size = q.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                String cur = q.poll();\\n            \\n                if (cur.equals(target)) {\\n                    return layer;\\n                }\\n                \\n                for (String adj: getAdj(cur)) {\\n                    if (!deadendsSet.contains(adj) && !seen.contains(adj)) {\\n                        q.offer(adj);\\n                        seen.add(adj);\\n                    }\\n                }\\n            }\\n            \\n            layer++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    List<String> getAdj(String cur) {\\n        List<String> r = new ArrayList<>();\\n        \\n        // rotate left or right\\n        for (int i = 0; i < cur.length(); i++) {\\n            int wheelValue = Character.getNumericValue(cur.charAt(i));\\n            \\n            r.add(buildNextWheel(wheelValue + 1 > 9 ? 0 : wheelValue + 1, cur, i));\\n            \\n            r.add(buildNextWheel(wheelValue - 1 < 0 ? 9 : wheelValue - 1, cur, i));\\n        }\\n        \\n        return r;\\n    }\\n    \\n    String buildNextWheel(int wheelValue, String cur, int i) {\\n        StringBuilder sb = new StringBuilder(cur);\\n        sb.setCharAt(i, (char)(wheelValue + \\'0\\'));\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737776,
                "title": "c-solution-easy-to-understnad",
                "content": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        vector<bool> visited(10000,false);\\n        for(string deadend: deadends) {\\n            int index = stoi(deadend);\\n            visited[index] = true;\\n        }\\n        int key = stoi(target);\\n        if(visited[key] || visited[0]) return -1;\\n        queue<int> Q;\\n        Q.push(0);\\n        int count = 0;\\n        while(!Q.empty()) {\\n            int size = Q.size();\\n            for(int i=0; i<size; i++) {\\n                int value = Q.front();\\n                Q.pop();\\n                if(value == key) return count;\\n                if(visited[value]) continue;\\n                visited[value] = true;\\n                for(int j=1; j<=1000; j *=10) {\\n                    Q.push(value + ((value / j + 1) % 10 - value / j % 10) * j);\\n                    Q.push(value + ((value / j + 9) % 10 - value / j % 10) * j);\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        vector<bool> visited(10000,false);\\n        for(string deadend: deadends) {\\n            int index = stoi(deadend);\\n            visited[index] = true;\\n        }\\n        int key = stoi(target);\\n        if(visited[key] || visited[0]) return -1;\\n        queue<int> Q;\\n        Q.push(0);\\n        int count = 0;\\n        while(!Q.empty()) {\\n            int size = Q.size();\\n            for(int i=0; i<size; i++) {\\n                int value = Q.front();\\n                Q.pop();\\n                if(value == key) return count;\\n                if(visited[value]) continue;\\n                visited[value] = true;\\n                for(int j=1; j<=1000; j *=10) {\\n                    Q.push(value + ((value / j + 1) % 10 - value / j % 10) * j);\\n                    Q.push(value + ((value / j + 9) % 10 - value / j % 10) * j);\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730995,
                "title": "clean-java-bfs-open-the-lock",
                "content": "```\\nprivate static int openLock(String[] dead, String target) {\\n        Set<String> deadends = new HashSet<>(Arrays.asList(dead));\\n\\n        if (deadends.contains(\"0000\"))\\n            return -1;\\n\\n        Queue<String> q = new ArrayDeque<>();\\n        q.offer(\"0000\");\\n\\n        Set<String> seen = new HashSet<>();\\n        int depth = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int n = 0; n < size; n++) {\\n                String node = q.poll();\\n\\n                if (node.equals(target)) {\\n                    return depth;\\n                }\\n\\n                for (int i = 0; i < 4; i++) {\\n                    for (int d = -1; d <= 1; d += 2) {\\n                        int y = ((node.charAt(i) - \\'0\\') + d + 10) % 10;\\n                        String neighbour = node.substring(0, i) + (\"\" + y) + node.substring(i + 1);\\n                        System.out.println(\"Neighbour : \" + neighbour);\\n\\n                        if (!seen.contains(neighbour) && !deadends.contains(neighbour)) {\\n                            q.add(neighbour);\\n                        }\\n                        seen.add(neighbour);\\n                    }\\n                }\\n            }\\n            depth++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate static int openLock(String[] dead, String target) {\\n        Set<String> deadends = new HashSet<>(Arrays.asList(dead));\\n\\n        if (deadends.contains(\"0000\"))\\n            return -1;\\n\\n        Queue<String> q = new ArrayDeque<>();\\n        q.offer(\"0000\");\\n\\n        Set<String> seen = new HashSet<>();\\n        int depth = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int n = 0; n < size; n++) {\\n                String node = q.poll();\\n\\n                if (node.equals(target)) {\\n                    return depth;\\n                }\\n\\n                for (int i = 0; i < 4; i++) {\\n                    for (int d = -1; d <= 1; d += 2) {\\n                        int y = ((node.charAt(i) - \\'0\\') + d + 10) % 10;\\n                        String neighbour = node.substring(0, i) + (\"\" + y) + node.substring(i + 1);\\n                        System.out.println(\"Neighbour : \" + neighbour);\\n\\n                        if (!seen.contains(neighbour) && !deadends.contains(neighbour)) {\\n                            q.add(neighbour);\\n                        }\\n                        seen.add(neighbour);\\n                    }\\n                }\\n            }\\n            depth++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699977,
                "title": "rust-bfs-24ms",
                "content": "```Rust\\nuse std::collections::{HashSet, VecDeque};\\nuse std::iter::FromIterator;\\n\\n\\nimpl Solution {\\n    pub fn open_lock(deadends: Vec<String>, target: String) -> i32 {\\n        let target = target.parse::<u32>().unwrap();\\n        let mut visited = HashSet::<u32>::from_iter(deadends.iter().map(|x| x.parse::<u32>().unwrap()));\\n\\n        let mut q = VecDeque::from(vec![0u32]);\\n\\n        let mut step = 0;\\n        while !q.is_empty() {\\n            for _ in 0..q.len() {\\n                let x = q.pop_front().unwrap();\\n                if visited.contains(&x) { continue; }\\n                if x == target {\\n                    return step;\\n                }\\n                for n in &[1, 10, 100, 1000] {\\n                    let cur = x / n % 10;\\n                    q.push_back(x - cur * n + (cur + 11) % 10 * n);\\n                    q.push_back(x - cur * n + (cur + 9) % 10 * n);\\n                }\\n                visited.insert(x);\\n            }\\n            step += 1;\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nuse std::collections::{HashSet, VecDeque};\\nuse std::iter::FromIterator;\\n\\n\\nimpl Solution {\\n    pub fn open_lock(deadends: Vec<String>, target: String) -> i32 {\\n        let target = target.parse::<u32>().unwrap();\\n        let mut visited = HashSet::<u32>::from_iter(deadends.iter().map(|x| x.parse::<u32>().unwrap()));\\n\\n        let mut q = VecDeque::from(vec![0u32]);\\n\\n        let mut step = 0;\\n        while !q.is_empty() {\\n            for _ in 0..q.len() {\\n                let x = q.pop_front().unwrap();\\n                if visited.contains(&x) { continue; }\\n                if x == target {\\n                    return step;\\n                }\\n                for n in &[1, 10, 100, 1000] {\\n                    let cur = x / n % 10;\\n                    q.push_back(x - cur * n + (cur + 11) % 10 * n);\\n                    q.push_back(x - cur * n + (cur + 9) % 10 * n);\\n                }\\n                visited.insert(x);\\n            }\\n            step += 1;\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 650034,
                "title": "java-bfs-clean-code",
                "content": "```java\\n/**\\n* Time Complexity: where N is the length of lock (4 in our case):\\n*\\n* O(N) for enumerating neighbors,\\n* O(digits^N) (10^4 in this case neighbors for each node)\\n* O(D) for initializing deadends set\\n* So time complexity is O(N*digits^N + D)\\n*\\n* Space complexity: O(digits^N + D) or the queue and the set dead\\n*/\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        HashSet<String> deadEndsSet = new HashSet<>();\\n        for (String deadend: deadends)\\n            deadEndsSet.add(deadend);\\n        \\n        if (deadEndsSet.contains(\"0000\"))\\n            return -1;\\n        \\n        HashSet<String> visited = new HashSet<>();\\n        Deque<String> queue = new LinkedList<>();\\n        \\n        queue.addLast(\"0000\");\\n        queue.addLast(null);\\n        visited.add(\"0000\");\\n        \\n        int level = 0;\\n        while (!queue.isEmpty()) {\\n            String currentCombination = queue.pollFirst();\\n            if (currentCombination == null) {\\n                level++;\\n\\t\\t\\t\\t// This is important to check \\n                if (queue.peek() != null)\\n                    queue.addLast(null);\\n                continue;\\n            }\\n            \\n            for (int pos = 0; pos < 4; pos++) {\\n                String forwardComb = generateNextNumber(currentCombination, pos, true);\\n                String backwardComb = generateNextNumber(currentCombination, pos, false);\\n                // System.out.println(currentCombination + \" -> \" + forwardComb);\\n                // System.out.println(currentCombination + \" -> \" + backwardComb);\\n                if(forwardComb.equals(target) || backwardComb.equals(target)) {\\n                    return level + 1;\\n                }\\n\\n                if (!deadEndsSet.contains(forwardComb) && !visited.contains(forwardComb)) {\\n                    visited.add(forwardComb);\\n                    queue.addLast(forwardComb);\\n                } \\n                \\n                if (!deadEndsSet.contains(backwardComb) && !visited.contains(backwardComb)) {\\n                    visited.add(backwardComb);\\n                    queue.addLast(backwardComb);\\n                } \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private String generateNextNumber(String number, int position, boolean forwardRotation) {\\n        char[] numberArr = number.toCharArray();\\n        if ((numberArr[position] - \\'0\\') == 0 && !forwardRotation) {\\n            numberArr[position] = \\'9\\';\\n        } else if ((numberArr[position] - \\'0\\') == 9 && forwardRotation) {\\n            numberArr[position] = \\'0\\';\\n        } else {\\n            if (forwardRotation)\\n                numberArr[position] = (char) (((numberArr[position] - \\'0\\') + 1) + \\'0\\');\\n            else \\n                numberArr[position] = (char) (((numberArr[position] - \\'0\\') - 1) + \\'0\\');    \\n        }\\n        \\n        return new String(numberArr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n* Time Complexity: where N is the length of lock (4 in our case):\\n*\\n* O(N) for enumerating neighbors,\\n* O(digits^N) (10^4 in this case neighbors for each node)\\n* O(D) for initializing deadends set\\n* So time complexity is O(N*digits^N + D)\\n*\\n* Space complexity: O(digits^N + D) or the queue and the set dead\\n*/\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        HashSet<String> deadEndsSet = new HashSet<>();\\n        for (String deadend: deadends)\\n            deadEndsSet.add(deadend);\\n        \\n        if (deadEndsSet.contains(\"0000\"))\\n            return -1;\\n        \\n        HashSet<String> visited = new HashSet<>();\\n        Deque<String> queue = new LinkedList<>();\\n        \\n        queue.addLast(\"0000\");\\n        queue.addLast(null);\\n        visited.add(\"0000\");\\n        \\n        int level = 0;\\n        while (!queue.isEmpty()) {\\n            String currentCombination = queue.pollFirst();\\n            if (currentCombination == null) {\\n                level++;\\n\\t\\t\\t\\t// This is important to check \\n                if (queue.peek() != null)\\n                    queue.addLast(null);\\n                continue;\\n            }\\n            \\n            for (int pos = 0; pos < 4; pos++) {\\n                String forwardComb = generateNextNumber(currentCombination, pos, true);\\n                String backwardComb = generateNextNumber(currentCombination, pos, false);\\n                // System.out.println(currentCombination + \" -> \" + forwardComb);\\n                // System.out.println(currentCombination + \" -> \" + backwardComb);\\n                if(forwardComb.equals(target) || backwardComb.equals(target)) {\\n                    return level + 1;\\n                }\\n\\n                if (!deadEndsSet.contains(forwardComb) && !visited.contains(forwardComb)) {\\n                    visited.add(forwardComb);\\n                    queue.addLast(forwardComb);\\n                } \\n                \\n                if (!deadEndsSet.contains(backwardComb) && !visited.contains(backwardComb)) {\\n                    visited.add(backwardComb);\\n                    queue.addLast(backwardComb);\\n                } \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private String generateNextNumber(String number, int position, boolean forwardRotation) {\\n        char[] numberArr = number.toCharArray();\\n        if ((numberArr[position] - \\'0\\') == 0 && !forwardRotation) {\\n            numberArr[position] = \\'9\\';\\n        } else if ((numberArr[position] - \\'0\\') == 9 && forwardRotation) {\\n            numberArr[position] = \\'0\\';\\n        } else {\\n            if (forwardRotation)\\n                numberArr[position] = (char) (((numberArr[position] - \\'0\\') + 1) + \\'0\\');\\n            else \\n                numberArr[position] = (char) (((numberArr[position] - \\'0\\') - 1) + \\'0\\');    \\n        }\\n        \\n        return new String(numberArr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623281,
                "title": "slow-but-easy-bfs-code",
                "content": "This code can be made very fast by working with numbers instead of strings very easily, it\\'s late and I had to do 1 problem for the day and this version is much easier than figuring that out which does not seem that much harder honestly use a vector of size 10,000 and mark dead ends as visited and mark things as you visit them into visited and go on from there after initally converting target to a number as well and that should make the code run 3-4 times faster, I might try it if I get the time.\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> visited;\\n    void queueNext(string &s, queue<string> &q) {\\n        for(int i = 0; i < 4; i++) {\\n            char cur = s[i];\\n            string s1 = s.substr(0, i) + to_string(cur == \\'9\\' ? 0: cur - \\'0\\' + 1) + s.substr(i+1);\\n            string s2 = s.substr(0, i) + to_string(cur == \\'0\\' ? 9: cur - \\'0\\' - 1) + s.substr(i+1);\\n            if(!visited.count(s1)) {\\n                q.push(s1);\\n                visited.insert(s1);\\n            }\\n            if(!visited.count(s2)) {\\n                q.push(s2);\\n                visited.insert(s2);\\n            }                \\n        }\\n    }\\n    \\n    int openLock(vector<string>& deadends, string target) {\\n        for(const auto &s: deadends)\\n            visited.insert(s);\\n        queue<string> q;\\n        if(!visited.count(\"0000\"))\\n            q.push(\"0000\");\\n        visited.insert(\"0000\");\\n        \\n        int lvl(0);\\n        while(!q.empty()) {\\n            int size = q.size();\\n            while(size--) {\\n                string cur = q.front();\\n                q.pop();\\n                if(cur == target)\\n                    return lvl;\\n                queueNext(cur, q);\\n            }\\n            lvl++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> visited;\\n    void queueNext(string &s, queue<string> &q) {\\n        for(int i = 0; i < 4; i++) {\\n            char cur = s[i];\\n            string s1 = s.substr(0, i) + to_string(cur == \\'9\\' ? 0: cur - \\'0\\' + 1) + s.substr(i+1);\\n            string s2 = s.substr(0, i) + to_string(cur == \\'0\\' ? 9: cur - \\'0\\' - 1) + s.substr(i+1);\\n            if(!visited.count(s1)) {\\n                q.push(s1);\\n                visited.insert(s1);\\n            }\\n            if(!visited.count(s2)) {\\n                q.push(s2);\\n                visited.insert(s2);\\n            }                \\n        }\\n    }\\n    \\n    int openLock(vector<string>& deadends, string target) {\\n        for(const auto &s: deadends)\\n            visited.insert(s);\\n        queue<string> q;\\n        if(!visited.count(\"0000\"))\\n            q.push(\"0000\");\\n        visited.insert(\"0000\");\\n        \\n        int lvl(0);\\n        while(!q.empty()) {\\n            int size = q.size();\\n            while(size--) {\\n                string cur = q.front();\\n                q.pop();\\n                if(cur == target)\\n                    return lvl;\\n                queueNext(cur, q);\\n            }\\n            lvl++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558612,
                "title": "simple-and-easy-to-understand-java-bfs-solution-with-explanation",
                "content": "This is essentially using BFS to find shortest path from ``\"0000\"`` to ``target``. Each turn has cost of 1. Note here we can actually use a single HashSet to contain visited and deadends.\\n\\n```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> set = new HashSet<>(Arrays.asList(deadends));\\n        if (!set.add(\"0000\")) return -1;\\n        \\n        Queue<String> queue = new LinkedList<>();\\n        queue.offer(\"0000\");\\n        int turns = 0;\\n        while (!queue.isEmpty()) {\\n            int len = queue.size();\\n            for (int i = 0; i < len; i++) {\\n                String current = queue.poll();\\n                if (current.equals(target)) return turns;\\n                fillNext(current, queue, set);\\n            }\\n            turns++;\\n        }\\n        return -1;\\n    }\\n    \\n    private void fillNext(String current, Queue<String> queue, Set<String> set) {\\n        char[] ca = current.toCharArray();\\n        for (int i = 0; i < 4; i++) {\\n            char c = ca[i];\\n            if (c == \\'9\\') {\\n                ca[i] = \\'0\\';\\n                String right = String.valueOf(ca);\\n                if(set.add(right)) queue.offer(right);\\n                ca[i] = \\'8\\';\\n                String left = String.valueOf(ca);\\n                if(set.add(left)) queue.offer(left);\\n            } else if (c == \\'0\\') {\\n                ca[i] = \\'1\\';\\n                String right = String.valueOf(ca);\\n                if(set.add(right)) queue.offer(right);\\n                ca[i] = \\'9\\';\\n                String left = String.valueOf(ca);\\n                if(set.add(left)) queue.offer(left);\\n            } else {\\n                ca[i] += 1;\\n                String right = String.valueOf(ca);\\n                if(set.add(right)) queue.offer(right);\\n                ca[i] -= 2;\\n                String left = String.valueOf(ca);\\n                if(set.add(left)) queue.offer(left);\\n            }\\n            ca[i] = c;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> set = new HashSet<>(Arrays.asList(deadends));\\n        if (!set.add(\"0000\")) return -1;\\n        \\n        Queue<String> queue = new LinkedList<>();\\n        queue.offer(\"0000\");\\n        int turns = 0;\\n        while (!queue.isEmpty()) {\\n            int len = queue.size();\\n            for (int i = 0; i < len; i++) {\\n                String current = queue.poll();\\n                if (current.equals(target)) return turns;\\n                fillNext(current, queue, set);\\n            }\\n            turns++;\\n        }\\n        return -1;\\n    }\\n    \\n    private void fillNext(String current, Queue<String> queue, Set<String> set) {\\n        char[] ca = current.toCharArray();\\n        for (int i = 0; i < 4; i++) {\\n            char c = ca[i];\\n            if (c == \\'9\\') {\\n                ca[i] = \\'0\\';\\n                String right = String.valueOf(ca);\\n                if(set.add(right)) queue.offer(right);\\n                ca[i] = \\'8\\';\\n                String left = String.valueOf(ca);\\n                if(set.add(left)) queue.offer(left);\\n            } else if (c == \\'0\\') {\\n                ca[i] = \\'1\\';\\n                String right = String.valueOf(ca);\\n                if(set.add(right)) queue.offer(right);\\n                ca[i] = \\'9\\';\\n                String left = String.valueOf(ca);\\n                if(set.add(left)) queue.offer(left);\\n            } else {\\n                ca[i] += 1;\\n                String right = String.valueOf(ca);\\n                if(set.add(right)) queue.offer(right);\\n                ca[i] -= 2;\\n                String left = String.valueOf(ca);\\n                if(set.add(left)) queue.offer(left);\\n            }\\n            ca[i] = c;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 555850,
                "title": "python-2-way-bfs-98",
                "content": "class Solution:\\n    \\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        \\n        dead_set = set(deadends)\\n        if \"0000\" in dead_set or target in dead_set:\\n            return -1\\n        \\n        qF = collections.deque([])\\n        qB = collections.deque([])\\n        stepF = 0\\n        stepB = 0\\n        visitedF = set()\\n        visitedB = set()\\n        qF.append(\"0000\")\\n        qB.append(target)\\n        visitedF.add(\"0000\")\\n        visitedB.add(target)\\n        \\n        while qF and qB:\\n            sizeF = len(qF)\\n            for _ in range(sizeF):\\n                curF = qF.popleft()\\n                for next_str in self.get_next(curF):\\n                    if next_str in visitedF or next_str in dead_set: continue\\n                    if next_str in visitedB: return stepF + stepB + 1\\n                    qF.append(next_str)\\n                    visitedF.add(next_str)\\n            stepF +=1\\n            \\n            sizeB = len(qB)\\n            for _ in range(sizeB):\\n                curB = qB.popleft()\\n                for next_str in self.get_next(curB):\\n                    if next_str in visitedB or next_str in dead_set: continue\\n                    if next_str in visitedF: return stepF + stepB + 1\\n                    qB.append(next_str)\\n                    visitedB.add(next_str)\\n            stepB +=1\\n        \\n        return -1\\n    \\n    def get_next(self, s):\\n        res = []\\n        for i,c in enumerate(s):\\n            num = int(c)\\n            res.append(s[:i] + str((num-1)%10) + s[i+1:])\\n            res.append(s[:i] + str((num+1)%10) + s[i+1:])\\n        return res\\n    ****",
                "solutionTags": [],
                "code": "class Solution:\\n    \\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        \\n        dead_set = set(deadends)\\n        if \"0000\" in dead_set or target in dead_set:\\n            return -1\\n        \\n        qF = collections.deque([])\\n        qB = collections.deque([])\\n        stepF = 0\\n        stepB = 0\\n        visitedF = set()\\n        visitedB = set()\\n        qF.append(\"0000\")\\n        qB.append(target)\\n        visitedF.add(\"0000\")\\n        visitedB.add(target)\\n        \\n        while qF and qB:\\n            sizeF = len(qF)\\n            for _ in range(sizeF):\\n                curF = qF.popleft()\\n                for next_str in self.get_next(curF):\\n                    if next_str in visitedF or next_str in dead_set: continue\\n                    if next_str in visitedB: return stepF + stepB + 1\\n                    qF.append(next_str)\\n                    visitedF.add(next_str)\\n            stepF +=1\\n            \\n            sizeB = len(qB)\\n            for _ in range(sizeB):\\n                curB = qB.popleft()\\n                for next_str in self.get_next(curB):\\n                    if next_str in visitedB or next_str in dead_set: continue\\n                    if next_str in visitedF: return stepF + stepB + 1\\n                    qB.append(next_str)\\n                    visitedB.add(next_str)\\n            stepB +=1\\n        \\n        return -1\\n    \\n    def get_next(self, s):\\n        res = []\\n        for i,c in enumerate(s):\\n            num = int(c)\\n            res.append(s[:i] + str((num-1)%10) + s[i+1:])\\n            res.append(s[:i] + str((num+1)%10) + s[i+1:])\\n        return res\\n    ****",
                "codeTag": "Java"
            },
            {
                "id": 523236,
                "title": "python3-bfs-accepted",
                "content": "For those of you who are getting time-exceeded error, just implement the collections of traveled nodes and deadend using set(). \\nI learned from this question that set() is much faster then list() for membership testing since it implements hash table.\\n```\\nclass Solution:\\n    \\n    def openLock(self, deadends, target) -> int:\\n       \\n        if \\'0000\\' in deadends:\\n            return -1\\n        if target == \\'0000\\':\\n            return 0\\n        #initializing        \\n        self.queue = list()\\n        self.tried = set(target)\\n        self.deadends = set(deadends)\\n        \\n        self.queue.append((target,0))\\n        while self.queue:            \\n            comb, step = self.queue.pop(0)\\n            if comb == \\'0000\\':\\n                return step\\n            for newcomb in self.take_a_step(comb):              \\n                self.queue.append((newcomb,step+1))                             \\n        return -1\\n                \\n    def take_a_step(self, comb):\\n        res = []\\n        for i in range(len(comb)):\\n            for step in [-1,1]:\\n                new = comb[:i] + str((int(comb[i]) + step)%10) + comb[i+1:]\\n                if new not in self.tried and new not in self.deadends:\\n                    self.tried.add(new)\\n                    res.append(new)\\n        return res\\n```        \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def openLock(self, deadends, target) -> int:\\n       \\n        if \\'0000\\' in deadends:\\n            return -1\\n        if target == \\'0000\\':\\n            return 0\\n        #initializing        \\n        self.queue = list()\\n        self.tried = set(target)\\n        self.deadends = set(deadends)\\n        \\n        self.queue.append((target,0))\\n        while self.queue:            \\n            comb, step = self.queue.pop(0)\\n            if comb == \\'0000\\':\\n                return step\\n            for newcomb in self.take_a_step(comb):              \\n                self.queue.append((newcomb,step+1))                             \\n        return -1\\n                \\n    def take_a_step(self, comb):\\n        res = []\\n        for i in range(len(comb)):\\n            for step in [-1,1]:\\n                new = comb[:i] + str((int(comb[i]) + step)%10) + comb[i+1:]\\n                if new not in self.tried and new not in self.deadends:\\n                    self.tried.add(new)\\n                    res.append(new)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 516077,
                "title": "bfs-solution-in-swift",
                "content": "```swift\\n/// - Approach: BFS\\nclass Solution {\\n    func openLock(_ deadends: [String], _ target: String) -> Int {\\n        guard !deadends.contains(\"0000\") else { return -1 }\\n        let deadends: Set<[Int]> = Set(deadends.map { Array($0).compactMap { Int(\"\\\\($0)\") } })\\n        let target: [Int] = Array(target).compactMap { Int(\"\\\\($0)\") }\\n        var turns: Int = 0\\n        var queue: [[Int]] = []\\n        var visited: Set<[Int]> = Set()\\n\\n        queue.append([0, 0, 0, 0])\\n        visited.insert([0, 0, 0, 0])        \\n        \\n        while !queue.isEmpty {\\n            for _ in 0..<queue.count {\\n                let cur = queue.removeFirst()\\n\\n                if cur == target {\\n                    return turns\\n                }\\n\\n                for i in 0...3 {\\n                    for d in stride(from: -1, through: 1, by: 2) {\\n                        var neighbor = cur\\n                        neighbor[i] = ((neighbor[i] + d) + 10) % 10\\n\\n                        if !visited.contains(neighbor) && !deadends.contains(neighbor) {\\n                            queue.append(neighbor)\\n                            visited.insert(neighbor)\\n                        }\\n                    }\\n                }\\n            }\\n            turns += 1\\n        }\\n        return -1\\n    }\\n}\\n```\\n*Updated*\\nRemove redudant code, thanks to [@aetsyss](https://leetcode.com/aetsyss/) pointed out.\\n\\n",
                "solutionTags": [],
                "code": "```swift\\n/// - Approach: BFS\\nclass Solution {\\n    func openLock(_ deadends: [String], _ target: String) -> Int {\\n        guard !deadends.contains(\"0000\") else { return -1 }\\n        let deadends: Set<[Int]> = Set(deadends.map { Array($0).compactMap { Int(\"\\\\($0)\") } })\\n        let target: [Int] = Array(target).compactMap { Int(\"\\\\($0)\") }\\n        var turns: Int = 0\\n        var queue: [[Int]] = []\\n        var visited: Set<[Int]> = Set()\\n\\n        queue.append([0, 0, 0, 0])\\n        visited.insert([0, 0, 0, 0])        \\n        \\n        while !queue.isEmpty {\\n            for _ in 0..<queue.count {\\n                let cur = queue.removeFirst()\\n\\n                if cur == target {\\n                    return turns\\n                }\\n\\n                for i in 0...3 {\\n                    for d in stride(from: -1, through: 1, by: 2) {\\n                        var neighbor = cur\\n                        neighbor[i] = ((neighbor[i] + d) + 10) % 10\\n\\n                        if !visited.contains(neighbor) && !deadends.contains(neighbor) {\\n                            queue.append(neighbor)\\n                            visited.insert(neighbor)\\n                        }\\n                    }\\n                }\\n            }\\n            turns += 1\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504604,
                "title": "clear-java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> visited = new HashSet<>();\\n        Set<String> deadSet = new HashSet<>(Arrays.asList(deadends)); \\n        if (deadSet.contains(\"0000\")) return -1;\\n        int len = 0;\\n\\n        Deque<String> queue = new LinkedList<>();\\n        visited.add(\"0000\");\\n        queue.offer(\"0000\");\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                String cur = queue.poll();\\n                for (String next : getNextLevel(cur)) {\\n                    if (!visited.contains(next) && !deadSet.contains(next)) {\\n                        if (next.equals(target)) return len + 1;\\n                        visited.add(next);\\n                        queue.offer(next);\\n                    }\\n                }\\n            }\\n            len++;\\n        }\\n        return -1;\\n\\n    }\\n    \\n    private List<String> getNextLevel(String s) {\\n\\t\\tList<String> res = new ArrayList<>();\\n\\t\\tchar[] ca = s.toCharArray();\\n\\t\\tfor (int i = 0; i < 4; i++) {\\n\\t\\t\\tchar c = ca[i];\\n\\t\\t\\tca[i] = c == \\'9\\' ? \\'0\\' : (char) (c + 1);\\n\\t\\t\\tres.add(new String(ca));\\n\\t\\t\\tca[i] = c; // restore ca\\n\\t\\t\\tca[i] = c == \\'0\\' ? \\'9\\' : (char) (c - 1);\\n\\t\\t\\tres.add(new String(ca));\\n\\t\\t\\tca[i] = c; // restore ca\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> visited = new HashSet<>();\\n        Set<String> deadSet = new HashSet<>(Arrays.asList(deadends)); \\n        if (deadSet.contains(\"0000\")) return -1;\\n        int len = 0;\\n\\n        Deque<String> queue = new LinkedList<>();\\n        visited.add(\"0000\");\\n        queue.offer(\"0000\");\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                String cur = queue.poll();\\n                for (String next : getNextLevel(cur)) {\\n                    if (!visited.contains(next) && !deadSet.contains(next)) {\\n                        if (next.equals(target)) return len + 1;\\n                        visited.add(next);\\n                        queue.offer(next);\\n                    }\\n                }\\n            }\\n            len++;\\n        }\\n        return -1;\\n\\n    }\\n    \\n    private List<String> getNextLevel(String s) {\\n\\t\\tList<String> res = new ArrayList<>();\\n\\t\\tchar[] ca = s.toCharArray();\\n\\t\\tfor (int i = 0; i < 4; i++) {\\n\\t\\t\\tchar c = ca[i];\\n\\t\\t\\tca[i] = c == \\'9\\' ? \\'0\\' : (char) (c + 1);\\n\\t\\t\\tres.add(new String(ca));\\n\\t\\t\\tca[i] = c; // restore ca\\n\\t\\t\\tca[i] = c == \\'0\\' ? \\'9\\' : (char) (c - 1);\\n\\t\\t\\tres.add(new String(ca));\\n\\t\\t\\tca[i] = c; // restore ca\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489612,
                "title": "c-bi-directional-bfs-runtime-better-than-77-of-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    // returns a vector containing all the possible combination from a string\\n    vector<string> gen(string s)\\n    {\\n        vector<string> t;\\n        for(int i=0;i<4;i++)\\n        {\\n            string temp = s;\\n            temp[i] = (s[i]-\\'0\\' + 1) % 10 + \\'0\\';\\n            t.push_back(temp);\\n            temp[i] = (s[i]-\\'0\\' -1 + 10) % 10 + \\'0\\';\\n            t.push_back(temp);                  \\n        }\\n        return t;\\n    }\\n    // return distance if we have a common element in map\\n    int fn(map<string,int> &m, map<string,int> &n)\\n    {\\n        for(auto x : m)\\n        {\\n            if(n.find(x.first)!=n.end()){\\n                return m[x.first] + n[x.first];}\\n        }\\n        return -1;\\n    }\\n\\t//performing Bfs for one complete level\\n    void bidirBfs(queue<pair<string,int>> &q, map<string,int> &m, unordered_set<string> &dds)\\n    {\\n        auto temp = q.front();\\n        q.pop();\\n        while(temp.first!=\"-\")\\n        {\\n            vector<string> fo = gen(temp.first);\\n            for(auto x : fo)\\n            {\\n                if(dds.find(x)!=dds.end())\\n                    continue;\\n                if(m.find(x)==m.end())\\n                {\\n                    q.push({x,temp.second+1});\\n                    m[x] = temp.second+1;\\n                }\\n            }\\n            temp = q.front(); q.pop();\\n        }\\n        if(!q.empty())\\n        {\\n            q.push({\"-\",-1});\\n        }\\n    }\\n    int openLock(vector<string>& deadends, string target) {\\n        // set to know if a combination is deadend or not\\n        unordered_set<string> dds(deadends.begin(),deadends.end());\\n        if(dds.find(\"0000\")!=dds.end()) return -1;\\n        \\n        // two maps to store combination that we made already with their distance from source\\n        map<string,int> smap,tmap;\\n        smap[\"0000\"] = 0; tmap[target] = 0;\\n        \\n        // queue to perform BFS\\n        queue<pair<string,int>> sq,tq;\\n        sq.push({\"0000\",0}); sq.push({\"-\",-1}); // queue for source\\n        tq.push({target,0}); tq.push({\"-\",-1}); // queue for target\\n        \\n        // performing bidirectional Bfs from both ends\\n        while(!sq.empty() && !tq.empty())\\n        {\\n            bidirBfs(sq,smap,dds);//search from source\\n            bidirBfs(tq,tmap,dds);//search from target\\n            // then checking if we reached a common point\\n            int ans = fn(smap,tmap);\\n            if(ans!=-1) return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // returns a vector containing all the possible combination from a string\\n    vector<string> gen(string s)\\n    {\\n        vector<string> t;\\n        for(int i=0;i<4;i++)\\n        {\\n            string temp = s;\\n            temp[i] = (s[i]-\\'0\\' + 1) % 10 + \\'0\\';\\n            t.push_back(temp);\\n            temp[i] = (s[i]-\\'0\\' -1 + 10) % 10 + \\'0\\';\\n            t.push_back(temp);                  \\n        }\\n        return t;\\n    }\\n    // return distance if we have a common element in map\\n    int fn(map<string,int> &m, map<string,int> &n)\\n    {\\n        for(auto x : m)\\n        {\\n            if(n.find(x.first)!=n.end()){\\n                return m[x.first] + n[x.first];}\\n        }\\n        return -1;\\n    }\\n\\t//performing Bfs for one complete level\\n    void bidirBfs(queue<pair<string,int>> &q, map<string,int> &m, unordered_set<string> &dds)\\n    {\\n        auto temp = q.front();\\n        q.pop();\\n        while(temp.first!=\"-\")\\n        {\\n            vector<string> fo = gen(temp.first);\\n            for(auto x : fo)\\n            {\\n                if(dds.find(x)!=dds.end())\\n                    continue;\\n                if(m.find(x)==m.end())\\n                {\\n                    q.push({x,temp.second+1});\\n                    m[x] = temp.second+1;\\n                }\\n            }\\n            temp = q.front(); q.pop();\\n        }\\n        if(!q.empty())\\n        {\\n            q.push({\"-\",-1});\\n        }\\n    }\\n    int openLock(vector<string>& deadends, string target) {\\n        // set to know if a combination is deadend or not\\n        unordered_set<string> dds(deadends.begin(),deadends.end());\\n        if(dds.find(\"0000\")!=dds.end()) return -1;\\n        \\n        // two maps to store combination that we made already with their distance from source\\n        map<string,int> smap,tmap;\\n        smap[\"0000\"] = 0; tmap[target] = 0;\\n        \\n        // queue to perform BFS\\n        queue<pair<string,int>> sq,tq;\\n        sq.push({\"0000\",0}); sq.push({\"-\",-1}); // queue for source\\n        tq.push({target,0}); tq.push({\"-\",-1}); // queue for target\\n        \\n        // performing bidirectional Bfs from both ends\\n        while(!sq.empty() && !tq.empty())\\n        {\\n            bidirBfs(sq,smap,dds);//search from source\\n            bidirBfs(tq,tmap,dds);//search from target\\n            // then checking if we reached a common point\\n            int ans = fn(smap,tmap);\\n            if(ans!=-1) return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481943,
                "title": "c-bfs",
                "content": "```\\n  //BFS \\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> deads(deadends.begin(), deadends.end());\\n        if (deads.count(\"0000\") || deads.find(target) != deads.end() ) return -1;\\n        if (target == \"0000\") return 0;\\n        unordered_set<string> visited;\\n        queue<string> que;\\n        que.push(\"0000\");\\n        visited.insert(\"0000\");\\n        for (int level = 1; !que.empty(); level++) {        //For each Level\\n            for (int n = que.size(); n > 0; n--) {  //queue size at each level\\n                string s = que.front(); que.pop();\\n                for (int i = 0; i < 4; i++) {       //For all 4 wheels\\n                    string s1 = s, s2 = s;\\n                    s1[i] = (s[i] - \\'0\\' + 1) % 10 + \\'0\\';\\n                    s2[i] = (s[i] - \\'0\\' - 1 + 10) % 10 + \\'0\\';\\n                    if(!visited.count(s1) && !deads.count(s1)) {\\n                        que.push(s1);\\n                        visited.insert(s1);\\n                    }\\n                    if(!visited.count(s2) && !deads.count(s2)) {\\n                        que.push(s2);\\n                        visited.insert(s2);\\n                    } \\n                    if (s1 == target || s2 == target) \\n                        return level;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n  //BFS \\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> deads(deadends.begin(), deadends.end());\\n        if (deads.count(\"0000\") || deads.find(target) != deads.end() ) return -1;\\n        if (target == \"0000\") return 0;\\n        unordered_set<string> visited;\\n        queue<string> que;\\n        que.push(\"0000\");\\n        visited.insert(\"0000\");\\n        for (int level = 1; !que.empty(); level++) {        //For each Level\\n            for (int n = que.size(); n > 0; n--) {  //queue size at each level\\n                string s = que.front(); que.pop();\\n                for (int i = 0; i < 4; i++) {       //For all 4 wheels\\n                    string s1 = s, s2 = s;\\n                    s1[i] = (s[i] - \\'0\\' + 1) % 10 + \\'0\\';\\n                    s2[i] = (s[i] - \\'0\\' - 1 + 10) % 10 + \\'0\\';\\n                    if(!visited.count(s1) && !deads.count(s1)) {\\n                        que.push(s1);\\n                        visited.insert(s1);\\n                    }\\n                    if(!visited.count(s2) && !deads.count(s2)) {\\n                        que.push(s2);\\n                        visited.insert(s2);\\n                    } \\n                    if (s1 == target || s2 == target) \\n                        return level;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 339892,
                "title": "2-clean-python-solution-a-bfs",
                "content": "# A*\\nIn priority queue, we not only take `steps` in to consideration but also `distance`\\nAnd the rest is just like dijkstra.\\n```\\nimport heapq\\nclass Solution(object):\\n    def openLock(self, deadends, target):\\n        def getNeighbor(node):\\n            opt = []\\n            for i in xrange(len(node)):\\n                if node[i]==0:\\n                    opt.append(tuple(node[:i]+(1,)+node[i+1:]))\\n                    opt.append(tuple(node[:i]+(9,)+node[i+1:]))\\n                elif node[i]==9:\\n                    opt.append(tuple(node[:i]+(0,)+node[i+1:]))\\n                    opt.append(tuple(node[:i]+(8,)+node[i+1:]))\\n                else:\\n                    opt.append(tuple(node[:i]+(node[i]+1,)+node[i+1:]))\\n                    opt.append(tuple(node[:i]+(node[i]-1,)+node[i+1:]))\\n            return opt\\n\\n        def getDistance(node):\\n            distance = 0\\n            for i in xrange(len(node)):\\n                d = abs(int(node[i])-int(target[i]))\\n                d2 = abs(10-d)\\n                distance+=min(d, d2)\\n            return distance\\n\\n        def tupify(node):\\n            return tuple(map(int, node))\\n\\n        target = tupify(target)\\n        visited = set([tupify(node) for node in deadends])\\n        pq = [(0, 0, tupify(\\'0000\\'))]\\n\\n        while pq:\\n            _, steps, node = heapq.heappop(pq)\\n            if node==target: return steps\\n            if node in visited: continue\\n            visited.add(node)\\n            for nei in getNeighbor(node):\\n                heapq.heappush(pq, (steps+1+getDistance(nei), steps+1, nei))\\n        return -1\\n```\\n\\n\\n# BFS\\n```\\nclass Solution:\\n    def openLock(self, deadends, target):\\n        def getNeighbor(node):\\n            opt = []\\n            for i in xrange(len(node)):\\n                add_one = delta[node[i]][0]\\n                minus_one = delta[node[i]][1]\\n                opt.append(node[:i]+add_one+node[i+1:])\\n                opt.append(node[:i]+minus_one+node[i + 1:])\\n            return opt\\n\\n        delta = {str(i): [str((i+1)%10), str((i-1)%10)] for i in xrange(10)}\\n        visited = set(deadends)\\n        q = collections.deque([(\\'0000\\', 0)])\\n        steps = 0\\n\\n        while q:\\n            node, steps = q.popleft()\\n            if node==target: return steps\\n            if node in visited: continue\\n            visited.add(node)\\n            for nei in getNeighbor(node):\\n                q.append((nei, steps+1))\\n\\n        return -1\\n```\\n\\n# More Resource\\nI really take time tried to make the best solution or explaination. \\nBecause I wanted to help others like me. \\nIf you like my answer, a star on [GitHub](https://github.com/wuduhren/leetcode-python) means a lot to me. \\nhttps://github.com/wuduhren/leetcode-python",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution(object):\\n    def openLock(self, deadends, target):\\n        def getNeighbor(node):\\n            opt = []\\n            for i in xrange(len(node)):\\n                if node[i]==0:\\n                    opt.append(tuple(node[:i]+(1,)+node[i+1:]))\\n                    opt.append(tuple(node[:i]+(9,)+node[i+1:]))\\n                elif node[i]==9:\\n                    opt.append(tuple(node[:i]+(0,)+node[i+1:]))\\n                    opt.append(tuple(node[:i]+(8,)+node[i+1:]))\\n                else:\\n                    opt.append(tuple(node[:i]+(node[i]+1,)+node[i+1:]))\\n                    opt.append(tuple(node[:i]+(node[i]-1,)+node[i+1:]))\\n            return opt\\n\\n        def getDistance(node):\\n            distance = 0\\n            for i in xrange(len(node)):\\n                d = abs(int(node[i])-int(target[i]))\\n                d2 = abs(10-d)\\n                distance+=min(d, d2)\\n            return distance\\n\\n        def tupify(node):\\n            return tuple(map(int, node))\\n\\n        target = tupify(target)\\n        visited = set([tupify(node) for node in deadends])\\n        pq = [(0, 0, tupify(\\'0000\\'))]\\n\\n        while pq:\\n            _, steps, node = heapq.heappop(pq)\\n            if node==target: return steps\\n            if node in visited: continue\\n            visited.add(node)\\n            for nei in getNeighbor(node):\\n                heapq.heappush(pq, (steps+1+getDistance(nei), steps+1, nei))\\n        return -1\\n```\n```\\nclass Solution:\\n    def openLock(self, deadends, target):\\n        def getNeighbor(node):\\n            opt = []\\n            for i in xrange(len(node)):\\n                add_one = delta[node[i]][0]\\n                minus_one = delta[node[i]][1]\\n                opt.append(node[:i]+add_one+node[i+1:])\\n                opt.append(node[:i]+minus_one+node[i + 1:])\\n            return opt\\n\\n        delta = {str(i): [str((i+1)%10), str((i-1)%10)] for i in xrange(10)}\\n        visited = set(deadends)\\n        q = collections.deque([(\\'0000\\', 0)])\\n        steps = 0\\n\\n        while q:\\n            node, steps = q.popleft()\\n            if node==target: return steps\\n            if node in visited: continue\\n            visited.add(node)\\n            for nei in getNeighbor(node):\\n                q.append((nei, steps+1))\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305535,
                "title": "java-bfs-solution-with-comments-64ms-39-4mb",
                "content": "```\\n\\n    public int openLock(String[] deadends, String target) {\\n        \\n        //*** Add deadends to HashSet for quick search\\n        Set<String> hsDeadends = new HashSet<>();\\n        for(String s : deadends)\\n            hsDeadends.add(s);\\n        \\n        //*** Add a \\u201Cvisited\\u201D HashSet to avoid checking already viewed strings\\n        Set<String> visited = new HashSet<>();\\n        LinkedList<String> queue = new LinkedList<>();\\n        queue.add(\"0000\");\\n        visited.add(\"0000\");\\n        if(\"0000\".equals(target))\\n            return 0;\\n        if(hsDeadends.contains(\"0000\"))\\n            return -1;\\n        \\n        int rowSize = 0;\\n        int count = 0;\\n        while(!queue.isEmpty()){\\n            count++;\\n            \\n            //*** The size of the first step (all possible options in this step)\\n            rowSize = queue.size();\\n            for(int i=0; i<rowSize; i++){\\n                String s = queue.pollFirst();\\n                List<String> lValues = getPossibilities(s, hsDeadends, visited);\\n                \\n                //*** Add all possible versions for this string to queue\\n                for(String value : lValues){\\n                    queue.add(value);\\n                    if(value.equals(target))\\n                        return count;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    //*** Return all possible versions for string\\n    private List<String> getPossibilities(String s, Set<String> hsDeadends, Set<String> visited){\\n        List<String> lRes = new ArrayList<>();\\n        char[] arr = s.toCharArray();\\n        for(int p = 0; p < 4; p++){\\n            // Subtract 1\\n            char[] arr1 = arr.clone();\\n            arr1[p] = arr1[p] == \\'0\\' ? \\'9\\' : (char)((int)arr1[p] - 1);\\n            String s1 = new String(arr1);\\n            if(!hsDeadends.contains(s1) && visited.add(s1))\\n                lRes.add(s1);\\n            \\n            // Add 1\\n            if(arr[p] < \\'9\\'){\\n                arr1 = arr.clone();\\n                arr1[p] = (char)((int)arr1[p] + 1);\\n                s1 = new String(arr1);\\n                if(!hsDeadends.contains(s1) && visited.add(s1))\\n                    lRes.add(s1);\\n            }\\n        }\\n        return lRes;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public int openLock(String[] deadends, String target) {\\n        \\n        //*** Add deadends to HashSet for quick search\\n        Set<String> hsDeadends = new HashSet<>();\\n        for(String s : deadends)\\n            hsDeadends.add(s);\\n        \\n        //*** Add a \\u201Cvisited\\u201D HashSet to avoid checking already viewed strings\\n        Set<String> visited = new HashSet<>();\\n        LinkedList<String> queue = new LinkedList<>();\\n        queue.add(\"0000\");\\n        visited.add(\"0000\");\\n        if(\"0000\".equals(target))\\n            return 0;\\n        if(hsDeadends.contains(\"0000\"))\\n            return -1;\\n        \\n        int rowSize = 0;\\n        int count = 0;\\n        while(!queue.isEmpty()){\\n            count++;\\n            \\n            //*** The size of the first step (all possible options in this step)\\n            rowSize = queue.size();\\n            for(int i=0; i<rowSize; i++){\\n                String s = queue.pollFirst();\\n                List<String> lValues = getPossibilities(s, hsDeadends, visited);\\n                \\n                //*** Add all possible versions for this string to queue\\n                for(String value : lValues){\\n                    queue.add(value);\\n                    if(value.equals(target))\\n                        return count;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    //*** Return all possible versions for string\\n    private List<String> getPossibilities(String s, Set<String> hsDeadends, Set<String> visited){\\n        List<String> lRes = new ArrayList<>();\\n        char[] arr = s.toCharArray();\\n        for(int p = 0; p < 4; p++){\\n            // Subtract 1\\n            char[] arr1 = arr.clone();\\n            arr1[p] = arr1[p] == \\'0\\' ? \\'9\\' : (char)((int)arr1[p] - 1);\\n            String s1 = new String(arr1);\\n            if(!hsDeadends.contains(s1) && visited.add(s1))\\n                lRes.add(s1);\\n            \\n            // Add 1\\n            if(arr[p] < \\'9\\'){\\n                arr1 = arr.clone();\\n                arr1[p] = (char)((int)arr1[p] + 1);\\n                s1 = new String(arr1);\\n                if(!hsDeadends.contains(s1) && visited.add(s1))\\n                    lRes.add(s1);\\n            }\\n        }\\n        return lRes;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 289707,
                "title": "java-20ms-bidirectional-bfs-solution-which-beats-97-with-explanation",
                "content": "This problem is similar to [127. Word Ladder](https://leetcode.com/problems/word-ladder/) ([My solution](https://leetcode.com/problems/word-ladder/discuss/281178/java-9ms-bidirection-bfs-solution-which-beats-100-with-detailed-explanation)). Such problems can be taken as maze problem and be solved in bidirectional bfs. \\n\\nThe key steps are marked as comments in the following code:\\n\\n```\\npublic int openLock(String[] deadends, String target) {\\n    Set<String> deadSet = new HashSet<String>();\\n    for(int i = 0; i < deadends.length; i++)\\n        deadSet.add(deadends[i]);\\n\\t\\n\\t// Use set instead of queue to accelerate search\\n    Set<String> beginSet = new HashSet<String>();\\n    Set<String> endSet = new HashSet<String>();\\n    beginSet.add(\"0000\");\\n    endSet.add(target);\\n\\t// Search from begin and end simultaneously\\n    return deadSet.contains(\"0000\") || deadSet.contains(target) ? -1 : traverse(beginSet, endSet, deadSet);\\n}\\n\\npublic int traverse(Set<String> beginSet, Set<String> endSet, Set<String> deadSet) {\\n    Set<String> newSet = new HashSet<String>();\\n    for(String current: beginSet) {\\n        StringBuilder sb = new StringBuilder(current);\\n        for(int i = 0; i < 4; i++) {\\n            char originalChar = current.charAt(i);\\n            sb.setCharAt(i, (char)((originalChar - \\'0\\' + 1) % 10 + \\'0\\'));\\n            if( endSet.contains(sb.toString()) )\\n                return 1;\\n            if( !deadSet.contains(sb.toString()) ) {\\n                newSet.add(sb.toString());\\n                deadSet.add(sb.toString()); // the searched elements are taken as deadend\\n            }\\n\\n            sb.setCharAt(i, (char)((originalChar - \\'0\\' + 9) % 10 + \\'0\\'));\\n            if( endSet.contains(sb.toString()) )\\n                return 1;\\n            if( !deadSet.contains(sb.toString())) {\\n                newSet.add(sb.toString());\\n                deadSet.add(sb.toString());\\n            }\\n\\n            sb.setCharAt(i, originalChar);\\n        }\\n    }\\n    if( newSet.size() == 0 )\\n        return -1;\\n    beginSet = newSet;\\n\\t// Each time search from the set with less elements \\n    int result = beginSet.size() > endSet.size() ? \\n            traverse(endSet, beginSet, deadSet) : traverse(beginSet, endSet, deadSet);\\n    return result == -1 ? -1 : result + 1;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic int openLock(String[] deadends, String target) {\\n    Set<String> deadSet = new HashSet<String>();\\n    for(int i = 0; i < deadends.length; i++)\\n        deadSet.add(deadends[i]);\\n\\t\\n\\t// Use set instead of queue to accelerate search\\n    Set<String> beginSet = new HashSet<String>();\\n    Set<String> endSet = new HashSet<String>();\\n    beginSet.add(\"0000\");\\n    endSet.add(target);\\n\\t// Search from begin and end simultaneously\\n    return deadSet.contains(\"0000\") || deadSet.contains(target) ? -1 : traverse(beginSet, endSet, deadSet);\\n}\\n\\npublic int traverse(Set<String> beginSet, Set<String> endSet, Set<String> deadSet) {\\n    Set<String> newSet = new HashSet<String>();\\n    for(String current: beginSet) {\\n        StringBuilder sb = new StringBuilder(current);\\n        for(int i = 0; i < 4; i++) {\\n            char originalChar = current.charAt(i);\\n            sb.setCharAt(i, (char)((originalChar - \\'0\\' + 1) % 10 + \\'0\\'));\\n            if( endSet.contains(sb.toString()) )\\n                return 1;\\n            if( !deadSet.contains(sb.toString()) ) {\\n                newSet.add(sb.toString());\\n                deadSet.add(sb.toString()); // the searched elements are taken as deadend\\n            }\\n\\n            sb.setCharAt(i, (char)((originalChar - \\'0\\' + 9) % 10 + \\'0\\'));\\n            if( endSet.contains(sb.toString()) )\\n                return 1;\\n            if( !deadSet.contains(sb.toString())) {\\n                newSet.add(sb.toString());\\n                deadSet.add(sb.toString());\\n            }\\n\\n            sb.setCharAt(i, originalChar);\\n        }\\n    }\\n    if( newSet.size() == 0 )\\n        return -1;\\n    beginSet = newSet;\\n\\t// Each time search from the set with less elements \\n    int result = beginSet.size() > endSet.size() ? \\n            traverse(endSet, beginSet, deadSet) : traverse(beginSet, endSet, deadSet);\\n    return result == -1 ? -1 : result + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275545,
                "title": "python-a-clear-bfs-solution-with-zero-efforts-to-read",
                "content": "\\n\\n```python\\n\\nclass Solution:\\n    def openLock(self, deadends, target):\\n        from collections import deque\\n        #declare \\n        queue = deque()\\n        visited = set()\\n        root = \\'0000\\'\\n        #initiate \\n        step = -1\\n        deads = set(deadends)\\n        queue.append(root)\\n        visited.add(root)\\n        \\n        if root in deads: return -1 #fast fail\\n\\n        while queue: \\n            step += 1  \\n            size = len(queue)  \\n          \\n            for i in range(size):\\n                cur = queue.popleft()\\n                #logging.debug(f\"cur: {cur}, step: {step}\")\\n                if cur == target: return step \\n                #collect the next node.\\n                #stretch and add next to queue\\n                for i in range(0, 4):\\n                    for j in [-1, 1]: \\n                        nxt = cur[:i] + str((int(cur[i]) + j + 10) % 10) + cur[i+1:]\\n                        if (nxt not in deads) and  (nxt not in visited): \\n                            queue.append(nxt)\\n                            visited.add(nxt)\\n        return -1 #failure case \\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution:\\n    def openLock(self, deadends, target):\\n        from collections import deque\\n        #declare \\n        queue = deque()\\n        visited = set()\\n        root = \\'0000\\'\\n        #initiate \\n        step = -1\\n        deads = set(deadends)\\n        queue.append(root)\\n        visited.add(root)\\n        \\n        if root in deads: return -1 #fast fail\\n\\n        while queue: \\n            step += 1  \\n            size = len(queue)  \\n          \\n            for i in range(size):\\n                cur = queue.popleft()\\n                #logging.debug(f\"cur: {cur}",
                "codeTag": "Java"
            },
            {
                "id": 238190,
                "title": "javascript-es6-bfs-simple-and-easy-to-understand",
                "content": "```JavaScript\\n/**\\n * @param {string[]} deadends\\n * @param {string} target\\n * @return {number}\\n */\\n\\n\\nfunction convertDigit(digit) {\\n  let plusOne = digit + 1;\\n  let minusOne = digit - 1;\\n  if (plusOne === 10) plusOne = 0;\\n  if (minusOne === -1) minusOne = 9;\\n  return [plusOne,minusOne];\\n} \\n\\nfunction neighbour(target) {\\n  const neighbours = [];\\n  for (let i = 0; i < target.length; i++) {\\n    const [plusOne, minusOne] = convertDigit(Number(target[i]));\\n    neighbours.push(`${target.substring(0,i)}${plusOne}${target.substring(i+1,target.length)}`);\\n    neighbours.push(`${target.substring(0,i)}${minusOne}${target.substring(i+1,target.length)}`);\\n  }\\n  return neighbours;\\n}\\n\\nfunction openLock(deadends, target) {\\n    const visited = new Set();\\n    for (let i = 0; i < deadends.length;i++) {\\n      visited.add(deadends[i]);\\n    }\\n  const queue = [];\\n  let steps = -1;\\n  if (!visited.has(\"0000\")) {\\n    queue.push(\"0000\");\\n    visited.add(\"0000\");\\n  } \\n    while(queue.length) {\\n      steps += 1;\\n      const length = queue.length;\\n      for (let i = 0; i < length; i++) {\\n        const current = queue.shift();\\n        if ( current=== target) return steps;\\n        const neighbours = neighbour(current);\\n        for (let n of neighbours) {\\n          if (!visited.has(n)) queue.push(n);\\n          visited.add(n);\\n        }\\n      }\\n    }\\n  return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```JavaScript\\n/**\\n * @param {string[]} deadends\\n * @param {string} target\\n * @return {number}\\n */\\n\\n\\nfunction convertDigit(digit) {\\n  let plusOne = digit + 1;\\n  let minusOne = digit - 1;\\n  if (plusOne === 10) plusOne = 0;\\n  if (minusOne === -1) minusOne = 9;\\n  return [plusOne,minusOne];\\n} \\n\\nfunction neighbour(target) {\\n  const neighbours = [];\\n  for (let i = 0; i < target.length; i++) {\\n    const [plusOne, minusOne] = convertDigit(Number(target[i]));\\n    neighbours.push(`${target.substring(0,i)}${plusOne}${target.substring(i+1,target.length)}`);\\n    neighbours.push(`${target.substring(0,i)}${minusOne}${target.substring(i+1,target.length)}`);\\n  }\\n  return neighbours;\\n}\\n\\nfunction openLock(deadends, target) {\\n    const visited = new Set();\\n    for (let i = 0; i < deadends.length;i++) {\\n      visited.add(deadends[i]);\\n    }\\n  const queue = [];\\n  let steps = -1;\\n  if (!visited.has(\"0000\")) {\\n    queue.push(\"0000\");\\n    visited.add(\"0000\");\\n  } \\n    while(queue.length) {\\n      steps += 1;\\n      const length = queue.length;\\n      for (let i = 0; i < length; i++) {\\n        const current = queue.shift();\\n        if ( current=== target) return steps;\\n        const neighbours = neighbour(current);\\n        for (let n of neighbours) {\\n          if (!visited.has(n)) queue.push(n);\\n          visited.add(n);\\n        }\\n      }\\n    }\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 220870,
                "title": "c-bfs-this-question-equal-to-graph-question",
                "content": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> sets;\\n        for(auto i : deadends)\\n        {\\n            sets.insert(i);\\n        }\\n        string begin = \"0000\";\\n        if(sets.count(begin))\\n        {\\n            return -1;\\n        }\\n        // \\u8FD9\\u4E00\\u9898\\u5176\\u5B9E\\u8BF4\\u96BE\\u4E0D\\u96BE,\\u8BF4\\u7B80\\u5355\\u4E5F\\u4E0D\\u7B80\\u5355,\\u6838\\u5FC3\\u601D\\u60F3\\u662F,\\u5982\\u4F55\\u5904\\u7406\\u8FD9\\u4E2A\\u95EE\\u9898,\\u8FD9\\u4E2A\\u76F8\\u5F53\\u4E8E\\u662F\\u56FE\\u8BBA\\u7684\\u95EE\\u9898,\\u5C31\\u662F\\u8FF7\\u5BAB\\u95EE\\u9898,\\u6211\\u7ED9\\u4E86\\u4F60\\n        //\\u969C\\u788D\\u7269,\\u5982\\u4F55\\u5904\\u7406\\u8FD9\\u4E2A\\u95EE\\u9898,\\u89E3\\u51B3\\u4E3B\\u8981\\u7684\\u6838\\u5FC3\\u601D\\u60F3,\\u5176\\u5B9E\\u8FD9\\u4E2A\\u53EF\\u4EE5\\u770B\\u505A\\u8FD9\\u4E2A\\u5730\\u56FE\\u662F\\u4E00\\u6761\\u7EBF,\\u6211\\u4EEC\\u53EF\\u4EE5\\u5728\\u8FD9\\u4E2A\\u7EBF\\u4E0A\\u8D70\\u4E00\\u6B65,\\u8FD9\\u4E2A\\u7EBF\\u957F\\u603B\\u5171\\u662F\\u56DB\\u4E2A\\n        queue<pair<string,int>> q;\\n        q.push(pair<string,int>(begin,0));\\n        while(!q.empty())\\n        {\\n            auto t = q.front();\\n            if(t.first == target)\\n            {\\n               return t.second;\\n            }\\n            q.pop();\\n            for(int i = 0;i<t.first.size();i++)\\n            {\\n                for(int j = -1;j<=1;j+=2)\\n                {\\n                    string temp = t.first;\\n                    if(j == -1 && temp[i] ==\\'0\\')\\n                    {\\n                        temp[i] = \\'9\\';\\n                    }\\n                    else if(j==1 && temp[i] == \\'9\\')\\n                    {\\n                        temp[i] = \\'0\\';\\n                    }\\n                    else\\n                    {\\n                        temp[i] = temp[i]+j;\\n                    }\\n                    //\\u5904\\u7406\\u6570\\u636E\\n                    if(sets.count(temp))\\n                    {\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        q.push(pair<string,int>(temp,t.second+1));\\n                        sets.insert(temp);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> sets;\\n        for(auto i : deadends)\\n        {\\n            sets.insert(i);\\n        }\\n        string begin = \"0000\";\\n        if(sets.count(begin))\\n        {\\n            return -1;\\n        }\\n        // \\u8FD9\\u4E00\\u9898\\u5176\\u5B9E\\u8BF4\\u96BE\\u4E0D\\u96BE,\\u8BF4\\u7B80\\u5355\\u4E5F\\u4E0D\\u7B80\\u5355,\\u6838\\u5FC3\\u601D\\u60F3\\u662F,\\u5982\\u4F55\\u5904\\u7406\\u8FD9\\u4E2A\\u95EE\\u9898,\\u8FD9\\u4E2A\\u76F8\\u5F53\\u4E8E\\u662F\\u56FE\\u8BBA\\u7684\\u95EE\\u9898,\\u5C31\\u662F\\u8FF7\\u5BAB\\u95EE\\u9898,\\u6211\\u7ED9\\u4E86\\u4F60\\n        //\\u969C\\u788D\\u7269,\\u5982\\u4F55\\u5904\\u7406\\u8FD9\\u4E2A\\u95EE\\u9898,\\u89E3\\u51B3\\u4E3B\\u8981\\u7684\\u6838\\u5FC3\\u601D\\u60F3,\\u5176\\u5B9E\\u8FD9\\u4E2A\\u53EF\\u4EE5\\u770B\\u505A\\u8FD9\\u4E2A\\u5730\\u56FE\\u662F\\u4E00\\u6761\\u7EBF,\\u6211\\u4EEC\\u53EF\\u4EE5\\u5728\\u8FD9\\u4E2A\\u7EBF\\u4E0A\\u8D70\\u4E00\\u6B65,\\u8FD9\\u4E2A\\u7EBF\\u957F\\u603B\\u5171\\u662F\\u56DB\\u4E2A\\n        queue<pair<string,int>> q;\\n        q.push(pair<string,int>(begin,0));\\n        while(!q.empty())\\n        {\\n            auto t = q.front();\\n            if(t.first == target)\\n            {\\n               return t.second;\\n            }\\n            q.pop();\\n            for(int i = 0;i<t.first.size();i++)\\n            {\\n                for(int j = -1;j<=1;j+=2)\\n                {\\n                    string temp = t.first;\\n                    if(j == -1 && temp[i] ==\\'0\\')\\n                    {\\n                        temp[i] = \\'9\\';\\n                    }\\n                    else if(j==1 && temp[i] == \\'9\\')\\n                    {\\n                        temp[i] = \\'0\\';\\n                    }\\n                    else\\n                    {\\n                        temp[i] = temp[i]+j;\\n                    }\\n                    //\\u5904\\u7406\\u6570\\u636E\\n                    if(sets.count(temp))\\n                    {\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        q.push(pair<string,int>(temp,t.second+1));\\n                        sets.insert(temp);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126476,
                "title": "java-neat-bfs-solution",
                "content": "```\\n    public int openLock(String[] d, String t) {\\n        Set<String> set = new HashSet<>(Arrays.asList(d));\\n        Queue<String> q = new LinkedList<>();\\n        \\n        String cur = \"0000\", next = null;\\n        if(!set.contains(cur)) {\\n            q.offer(cur);\\n            set.add(cur);\\n        }\\n        \\n        int size = 0, step = 0;\\n        while(!q.isEmpty()) {\\n            size = q.size();\\n            for(int i=0; i<size; i++) {\\n                cur = q.poll();\\n                for(int j=0; j<4; j++) {\\n                    char c = cur.charAt(j);\\n                    int n = c-\\'0\\';\\n                    int[] pool = {(n+1)%10, (n-1+10)%10};\\n                    \\n                    for(int o : pool) {\\n                        next = cur.substring(0, j)+o+cur.substring(j+1, 4);\\n                        if(next.equals(t)) return step+1;\\n                        if(!set.contains(next)) {\\n                            q.offer(next);\\n                            set.add(next);\\n                        }\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int openLock(String[] d, String t) {\\n        Set<String> set = new HashSet<>(Arrays.asList(d));\\n        Queue<String> q = new LinkedList<>();\\n        \\n        String cur = \"0000\", next = null;\\n        if(!set.contains(cur)) {\\n            q.offer(cur);\\n            set.add(cur);\\n        }\\n        \\n        int size = 0, step = 0;\\n        while(!q.isEmpty()) {\\n            size = q.size();\\n            for(int i=0; i<size; i++) {\\n                cur = q.poll();\\n                for(int j=0; j<4; j++) {\\n                    char c = cur.charAt(j);\\n                    int n = c-\\'0\\';\\n                    int[] pool = {(n+1)%10, (n-1+10)%10};\\n                    \\n                    for(int o : pool) {\\n                        next = cur.substring(0, j)+o+cur.substring(j+1, 4);\\n                        if(next.equals(t)) return step+1;\\n                        if(!set.contains(next)) {\\n                            q.offer(next);\\n                            set.add(next);\\n                        }\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 112952,
                "title": "30ms-bfs-solution-in-java",
                "content": "    public int openLock(String[] deadends, String target) {\\n        boolean[] dead = new boolean[10000];\\n        for(String d : deadends)\\n            dead[Integer.parseInt(d)] = true;\\n        if (dead[0]) return -1;\\n        dead[0] = true;\\n        \\n        int t = Integer.parseInt(target), ans = 0;\\n        LinkedList<Integer> list = new LinkedList<>();\\n        list.add(0);\\n        while(list.size() > 0) {\\n            int n = list.size();\\n            for(int i = 0; i < n; i++) {\\n                int cur = list.pollFirst();\\n                if (cur == t) return ans;\\n                for(int m = 1; m <= 1000; m *= 10) {\\n                    int x = (cur % (m* 10)) / m;\\n                    int y = x == 9 ? cur - (m*9) : cur + m;\\n                    if (!dead[y]) {list.offerLast(y); dead[y] = true;}\\n                    y = x == 0 ? cur + (m*9) : cur - m;\\n                    if (!dead[y]) {list.offerLast(y); dead[y] = true;}\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "    public int openLock(String[] deadends, String target) {\\n        boolean[] dead = new boolean[10000];\\n        for(String d : deadends)\\n            dead[Integer.parseInt(d)] = true;\\n        if (dead[0]) return -1;\\n        dead[0] = true;\\n        \\n        int t = Integer.parseInt(target), ans = 0;\\n        LinkedList<Integer> list = new LinkedList<>();\\n        list.add(0);\\n        while(list.size() > 0) {\\n            int n = list.size();\\n            for(int i = 0; i < n; i++) {\\n                int cur = list.pollFirst();\\n                if (cur == t) return ans;\\n                for(int m = 1; m <= 1000; m *= 10) {\\n                    int x = (cur % (m* 10)) / m;\\n                    int y = x == 9 ? cur - (m*9) : cur + m;\\n                    if (!dead[y]) {list.offerLast(y); dead[y] = true;}\\n                    y = x == 0 ? cur + (m*9) : cur - m;\\n                    if (!dead[y]) {list.offerLast(y); dead[y] = true;}\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 110249,
                "title": "ac-java-solution-using-2-end-bfs",
                "content": "Each time we work with a smaller-sized set by checking the set from \"0000\" end and from target end (to save time).\\nAt any instance, if either set is empty, it means we hit a dead end. So return -1.\\nIf we match a password from the other end, we find the solution. So return counter at that moment.\\nNote: if you have encountered the 38/40 wrong answer problem, just check whether \"0000\" is in your deadends. This should solve the problem. \\n```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> dds = new HashSet<>();\\n        for (int i = 0; i < deadends.length; i++) dds.add(deadends[i]);\\n        if (dds.contains(\"0000\")) return -1;\\n        Set<String> start = new HashSet<>();\\n        start.add(\"0000\");\\n        Set<String> end = new HashSet<>();\\n        end.add(target);\\n        Set<String> visited = new HashSet<>();\\n        visited.add(\"0000\");\\n        visited.add(target);\\n        int counter = 0;\\n        while (!start.isEmpty() && !end.isEmpty()) {\\n            counter++;\\n            if (start.size() > end.size()) {\\n                Set<String> temp = start;\\n                start = end; \\n                end = temp;\\n            }\\n            Set<String> temp_start = new HashSet<>();\\n            for (String s : start) {\\n                for (int i = 0; i < 4; i++) {\\n                    char[] s1_arr = s.toCharArray();\\n                    char[] s2_arr = s.toCharArray();\\n                    s1_arr[i]++;\\n                    s2_arr[i]--;\\n                    if (s1_arr[i] > '9') s1_arr[i] -= 10;\\n                    if (s2_arr[i] < '0') s2_arr[i] += 10;\\n                    String s1 = String.valueOf(s1_arr);\\n                    String s2 = String.valueOf(s2_arr);\\n                    if (end.contains(s1) || end.contains(s2)) return counter;\\n                    if (!dds.contains(s1) && !visited.contains(s1)) {\\n                        visited.add(s1);\\n                        temp_start.add(s1);\\n                    }\\n                    if (!dds.contains(s2) && !visited.contains(s2)) {\\n                        visited.add(s2);\\n                        temp_start.add(s2);\\n                    }\\n                }\\n            }\\n            start = temp_start;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        Set<String> dds = new HashSet<>();\\n        for (int i = 0; i < deadends.length; i++) dds.add(deadends[i]);\\n        if (dds.contains(\"0000\")) return -1;\\n        Set<String> start = new HashSet<>();\\n        start.add(\"0000\");\\n        Set<String> end = new HashSet<>();\\n        end.add(target);\\n        Set<String> visited = new HashSet<>();\\n        visited.add(\"0000\");\\n        visited.add(target);\\n        int counter = 0;\\n        while (!start.isEmpty() && !end.isEmpty()) {\\n            counter++;\\n            if (start.size() > end.size()) {\\n                Set<String> temp = start;\\n                start = end; \\n                end = temp;\\n            }\\n            Set<String> temp_start = new HashSet<>();\\n            for (String s : start) {\\n                for (int i = 0; i < 4; i++) {\\n                    char[] s1_arr = s.toCharArray();\\n                    char[] s2_arr = s.toCharArray();\\n                    s1_arr[i]++;\\n                    s2_arr[i]--;\\n                    if (s1_arr[i] > '9') s1_arr[i] -= 10;\\n                    if (s2_arr[i] < '0') s2_arr[i] += 10;\\n                    String s1 = String.valueOf(s1_arr);\\n                    String s2 = String.valueOf(s2_arr);\\n                    if (end.contains(s1) || end.contains(s2)) return counter;\\n                    if (!dds.contains(s1) && !visited.contains(s1)) {\\n                        visited.add(s1);\\n                        temp_start.add(s1);\\n                    }\\n                    if (!dds.contains(s2) && !visited.contains(s2)) {\\n                        visited.add(s2);\\n                        temp_start.add(s2);\\n                    }\\n                }\\n            }\\n            start = temp_start;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792794,
                "title": "succicnt-explanation-bfs",
                "content": "```\\nLet\\'s say target = \\'7120\\'\\n\\nAs the target starts with \\'7\\', obviously we have to go by \\n   \\'9000\\' --> \\'8000\\' --> \\'7000\\' --> \\'7100\\' --> \\'7110\\' --> \\'7120\\' --> \\'7120\\'\\nBut what if all of those string are already in \"deadends\"? Then maybe the shortest way from\\n\\'1000\\' .....\\n\\nSo we\\'ve to check every possible combination level by level which is BFS.\\n\\n                    \\'0000\\'\\n                \\n\\'1000\\'      \\'0100\\'      \\'0010\\'       \\'0001\\' [YOU CAN GET THESE BY FLIPPING ONCE FROM \\'0000\\']\\n\\nI can put 1 in any of these way. This is forward but in backward there might be short path,\\nso we also need to go backward also.\\n\\n\\'9000\\'      \\'0900\\'      \\'0090\\'       \\'0009\\' [YOU CAN GET THESE BY FLIPPING ONCE FROM \\'0000\\']\\n\\n\\n                From    \\'1000\\' the below 4 type string we can get :\\n\\n2000         1100        1010         1001  [YOU CAN GET THESE BY FLIPPING TWICE FROM \\'0000\\']\\n             |__________________________|\\n                    |--- Some combinations with only 1\\n\\nThis way from 0100, 0010 and 0001 we will find some string with 1s.\\nYou can clearly see we will have all type of combinations slowly LEVEL BY LEVEL.\\n\\nHERE IN THIS BFS EACH \\'LEVEL\\' REPRESENTING WHATEVER STRING WE CAN GET IN THIS LEVEL BY \\nTURNING ONE CHARACTER INTO ANOTHER \\'IS THE MINIMUM TURNS REQUIRED TO GET THOSE STRINGS\\' and \\nif any of these string == target, we return the level.\\n----\\n \\n```\\n```CPP []\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) \\n    {\\n        if(target == \"0000\") return 0;\\n        unordered_set<string> visited(begin(deadends), end(deadends));\\n        if(visited.count(\"0000\")) return -1;\\n        \\n        queue<string> q(deque<string> {\"0000\"});\\n        string main, cur, prev;\\n\\n        for(int size = 1, level = 1; !q.empty(); size = q.size(), level++)\\n        {\\n            while(size--) \\n            {\\n                main = cur = prev = q.front(); q.pop();\\n                for(int i=0; i<4; i++)\\n                {\\n                    cur[i] += (cur[i] == \\'9\\'? -9 : 1);\\n                    if(cur == target) return level;\\n                    if(!visited.count(cur)) q.push(cur), visited.insert(cur);\\n\\n                    prev[i] -= (prev[i] == \\'0\\'? -9 : 1);\\n                    if(prev == target) return level;\\n                    if(!visited.count(prev)) q.push(prev), visited.insert(prev);\\n\\n                    cur = prev = main;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        if target == \\'0000\\': return 0\\n        visited = set(deadends)\\n        if \\'0000\\' in visited: return -1\\n        q, level = deque([\\'0000\\']), 1\\n\\n        while q:\\n            for _ in range(len(q)):\\n\\n                main = q.popleft()\\n                for i in range(4):\\n                    nextt = main[:i] + (\\'0\\' if main[i] == \\'9\\' else str(int(main[i]) + 1)) + main[i+1:]\\n                    if nextt == target: return level\\n                    if nextt not in visited :\\n                        q.append(nextt)\\n                        visited.add(nextt)\\n                    \\n                    prev = main[:i] + (\\'9\\' if main[i] == \\'0\\' else str(int(main[i]) - 1)) + main[i+1:]\\n                    if prev == target: return level\\n                    if prev not in visited :\\n                        q.append(prev)\\n                        visited.add(prev)\\n\\n            level += 1\\n\\n        return -1\\n```\\n<!-- ```\\nTime  complexity :\\nSpace complexity :\\n``` -->",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nLet\\'s say target = \\'7120\\'\\n\\nAs the target starts with \\'7\\', obviously we have to go by \\n   \\'9000\\' --> \\'8000\\' --> \\'7000\\' --> \\'7100\\' --> \\'7110\\' --> \\'7120\\' --> \\'7120\\'\\nBut what if all of those string are already in \"deadends\"? Then maybe the shortest way from\\n\\'1000\\' .....\\n\\nSo we\\'ve to check every possible combination level by level which is BFS.\\n\\n                    \\'0000\\'\\n                \\n\\'1000\\'      \\'0100\\'      \\'0010\\'       \\'0001\\' [YOU CAN GET THESE BY FLIPPING ONCE FROM \\'0000\\']\\n\\nI can put 1 in any of these way. This is forward but in backward there might be short path,\\nso we also need to go backward also.\\n\\n\\'9000\\'      \\'0900\\'      \\'0090\\'       \\'0009\\' [YOU CAN GET THESE BY FLIPPING ONCE FROM \\'0000\\']\\n\\n\\n                From    \\'1000\\' the below 4 type string we can get :\\n\\n2000         1100        1010         1001  [YOU CAN GET THESE BY FLIPPING TWICE FROM \\'0000\\']\\n             |__________________________|\\n                    |--- Some combinations with only 1\\n\\nThis way from 0100, 0010 and 0001 we will find some string with 1s.\\nYou can clearly see we will have all type of combinations slowly LEVEL BY LEVEL.\\n\\nHERE IN THIS BFS EACH \\'LEVEL\\' REPRESENTING WHATEVER STRING WE CAN GET IN THIS LEVEL BY \\nTURNING ONE CHARACTER INTO ANOTHER \\'IS THE MINIMUM TURNS REQUIRED TO GET THOSE STRINGS\\' and \\nif any of these string == target, we return the level.\\n----\\n \\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) \\n    {\\n        if(target == \"0000\") return 0;\\n        unordered_set<string> visited(begin(deadends), end(deadends));\\n        if(visited.count(\"0000\")) return -1;\\n        \\n        queue<string> q(deque<string> {\"0000\"});\\n        string main, cur, prev;\\n\\n        for(int size = 1, level = 1; !q.empty(); size = q.size(), level++)\\n        {\\n            while(size--) \\n            {\\n                main = cur = prev = q.front(); q.pop();\\n                for(int i=0; i<4; i++)\\n                {\\n                    cur[i] += (cur[i] == \\'9\\'? -9 : 1);\\n                    if(cur == target) return level;\\n                    if(!visited.count(cur)) q.push(cur), visited.insert(cur);\\n\\n                    prev[i] -= (prev[i] == \\'0\\'? -9 : 1);\\n                    if(prev == target) return level;\\n                    if(!visited.count(prev)) q.push(prev), visited.insert(prev);\\n\\n                    cur = prev = main;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        if target == \\'0000\\': return 0\\n        visited = set(deadends)\\n        if \\'0000\\' in visited: return -1\\n        q, level = deque([\\'0000\\']), 1\\n\\n        while q:\\n            for _ in range(len(q)):\\n\\n                main = q.popleft()\\n                for i in range(4):\\n                    nextt = main[:i] + (\\'0\\' if main[i] == \\'9\\' else str(int(main[i]) + 1)) + main[i+1:]\\n                    if nextt == target: return level\\n                    if nextt not in visited :\\n                        q.append(nextt)\\n                        visited.add(nextt)\\n                    \\n                    prev = main[:i] + (\\'9\\' if main[i] == \\'0\\' else str(int(main[i]) - 1)) + main[i+1:]\\n                    if prev == target: return level\\n                    if prev not in visited :\\n                        q.append(prev)\\n                        visited.add(prev)\\n\\n            level += 1\\n\\n        return -1\\n```\n```\\nTime  complexity :\\nSpace complexity :\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750751,
                "title": "bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by defining the openLock function, which takes in two parameters: deadends (a list of dead-end combinations) and target (the target combination to unlock the lock).\\n\\nWe set the initial state of the lock to \\'0000\\' and check if it is in the deadends list. If it is, we know that the lock cannot be opened, so we return -1.\\n\\nWe convert the deadends list to a set for faster lookup later on. We also initialize a queue (implemented as a deque) to store the lock combinations to be processed, and a set called visited to keep track of the combinations we have already visited.\\n\\nWe start a while loop that continues until the queue is empty. Inside the loop, we pop the first combination from the queue and store it in variables current and turns (representing the current combination and the number of turns taken to reach it).\\n\\nWe check if the current combination is equal to the target. If it is, we have successfully unlocked the lock, so we return the number of turns taken.\\n\\nIf the current combination is not the target, we generate all possible next combinations by rotating each wheel (digit) in both directions (adding or subtracting 1). We use nested loops to iterate over each digit and direction.\\n\\nFor each new combination, we check if it has already been visited or if it is a dead-end combination. If it is neither, we add it to the visited set and enqueue it into the queue along with the updated number of turns.\\n\\nIf the target combination cannot be reached, the queue will eventually become empty. In this case, we return -1 to indicate that it is impossible to unlock the lock.\\n\\nThe code is followed by an example usage, where we define a list of dead-end combinations deadends and a target combination target. We call the openLock function with these inputs and print the result.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        start = \\'0000\\'\\n        if start in deadends:\\n            return -1\\n        \\n        deadends = set(deadends)\\n        queue = deque([(start, 0)])\\n        visited = set([start])\\n        \\n        while queue:\\n            current, turns = queue.popleft()\\n            \\n            if current == target:\\n                return turns\\n            \\n            for i in range(4):\\n                for move in [-1, 1]:\\n                    new_digit = str((int(current[i]) + move) % 10)\\n                    new_code = current[:i] + new_digit + current[i+1:]\\n                    \\n                    if new_code not in visited and new_code not in deadends:\\n                        visited.add(new_code)\\n                        queue.append((new_code, turns + 1))\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        start = \\'0000\\'\\n        if start in deadends:\\n            return -1\\n        \\n        deadends = set(deadends)\\n        queue = deque([(start, 0)])\\n        visited = set([start])\\n        \\n        while queue:\\n            current, turns = queue.popleft()\\n            \\n            if current == target:\\n                return turns\\n            \\n            for i in range(4):\\n                for move in [-1, 1]:\\n                    new_digit = str((int(current[i]) + move) % 10)\\n                    new_code = current[:i] + new_digit + current[i+1:]\\n                    \\n                    if new_code not in visited and new_code not in deadends:\\n                        visited.add(new_code)\\n                        queue.append((new_code, turns + 1))\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548750,
                "title": "pure-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& dead, string target) \\n    {\\n        int res = 0; \\n        unordered_set<string> s(dead.begin(),dead.end());\\n        queue<pair<string,int>>q;\\n        if(s.find(\"0000\")!=s.end())\\n        return -1;\\n        q.push({\"0000\",0});\\n        s.insert(\"0000\");\\n        \\n        while(q.size())\\n        {\\n            string curr = q.front().first;\\n            int step = q.front().second;\\n            if(curr==target)\\n            return step;\\n            q.pop(); \\n\\n            for(int i = 0; i<4;i++)\\n            {\\n                string up = curr, down = curr;\\n                char u =  up[i], d = down[i];\\n                if(u==\\'9\\')\\n                up[i] = \\'0\\';\\n                else up[i] = u +1 ; \\n                if(d==\\'0\\')\\n                down[i] =\\'9\\';\\n                else down[i] = d-1;\\n                if(s.find(up)==s.end())\\n                {\\n                    q.push({up,step+1});\\n                    s.insert(up);\\n                }\\n                if(s.find(down)==s.end())\\n                {\\n                    q.push({down,step+1});\\n                    s.insert(down);\\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& dead, string target) \\n    {\\n        int res = 0; \\n        unordered_set<string> s(dead.begin(),dead.end());\\n        queue<pair<string,int>>q;\\n        if(s.find(\"0000\")!=s.end())\\n        return -1;\\n        q.push({\"0000\",0});\\n        s.insert(\"0000\");\\n        \\n        while(q.size())\\n        {\\n            string curr = q.front().first;\\n            int step = q.front().second;\\n            if(curr==target)\\n            return step;\\n            q.pop(); \\n\\n            for(int i = 0; i<4;i++)\\n            {\\n                string up = curr, down = curr;\\n                char u =  up[i], d = down[i];\\n                if(u==\\'9\\')\\n                up[i] = \\'0\\';\\n                else up[i] = u +1 ; \\n                if(d==\\'0\\')\\n                down[i] =\\'9\\';\\n                else down[i] = d-1;\\n                if(s.find(up)==s.end())\\n                {\\n                    q.push({up,step+1});\\n                    s.insert(up);\\n                }\\n                if(s.find(down)==s.end())\\n                {\\n                    q.push({down,step+1});\\n                    s.insert(down);\\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510767,
                "title": "python-3-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        start = \\'0000\\'\\n        q = deque([start])\\n        deadends = set(deadends)\\n        visited = {start}\\n        step = 0\\n\\n        while q:\\n            for i in range(len(q)):\\n                code = q.popleft()\\n                # print(f\"code: {code}\")\\n\\n                if code in deadends:\\n                    continue\\n                if code == target:\\n                    return step\\n\\n                next_codes = []\\n                # calculate the branches\\n                # (add 1 and subtract 1 for each digit of the code)\\n                for i in range(len(code)):\\n                    num = int(code[i])\\n                    # wrap-around modular\\n                    next_num_plus = (num + 1) % 10\\n                    next_num_minus = (num - 1) % 10\\n                    next_codes += [code[:i] + str(next_num_plus) + code[i+1:],\\n                                   code[:i] + str(next_num_minus) + code[i+1:]]\\n\\n                for next_code in next_codes:\\n                    if next_code not in visited:\\n                        q.append(next_code)\\n                        visited.add(next_code)\\n            step += 1    \\n        return -1\\n    \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        start = \\'0000\\'\\n        q = deque([start])\\n        deadends = set(deadends)\\n        visited = {start}\\n        step = 0\\n\\n        while q:\\n            for i in range(len(q)):\\n                code = q.popleft()\\n                # print(f\"code: {code}\")\\n\\n                if code in deadends:\\n                    continue\\n                if code == target:\\n                    return step\\n\\n                next_codes = []\\n                # calculate the branches\\n                # (add 1 and subtract 1 for each digit of the code)\\n                for i in range(len(code)):\\n                    num = int(code[i])\\n                    # wrap-around modular\\n                    next_num_plus = (num + 1) % 10\\n                    next_num_minus = (num - 1) % 10\\n                    next_codes += [code[:i] + str(next_num_plus) + code[i+1:],\\n                                   code[:i] + str(next_num_minus) + code[i+1:]]\\n\\n                for next_code in next_codes:\\n                    if next_code not in visited:\\n                        q.append(next_code)\\n                        visited.add(next_code)\\n            step += 1    \\n        return -1\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302669,
                "title": "swift-easy-bfs-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func openLock(_ deadends: [String], _ target: String) -> Int {\\n        var visited = Set(deadends)\\n        var queue = [(String, Int)]()\\n        var queueStart = 0\\n        \\n        let zeroAscii = Character(\"0\").asciiValue!\\n        let code = \"0000\"\\n        if !visited.contains(code) {\\n            queue.append((code, 0))\\n            visited.insert(code)\\n        }\\n        while queueStart != queue.count {\\n            let (currentCode, currentDeapth) = queue[queueStart]\\n            if currentCode == target {\\n                return currentDeapth\\n            }\\n            queueStart += 1\\n            \\n            let currentCodeArray = Array(currentCode)\\n            for (i, char) in currentCodeArray.enumerated() {\\n                let digit = char.asciiValue! - zeroAscii\\n                let nextDigit = (digit + 1) % 10\\n                let prevDigit = digit > 0 ? digit - 1 : 9\\n                for digit in [nextDigit, prevDigit] {\\n                    let nextDigitChar = Character(UnicodeScalar(digit + zeroAscii))\\n                    var nextCodeArray = currentCodeArray\\n                    nextCodeArray[i] = nextDigitChar\\n                    let nextCode = String(nextCodeArray)\\n                    if !visited.contains(nextCode) {\\n                        visited.insert(nextCode)\\n                        queue.append((nextCode, currentDeapth+1))\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func openLock(_ deadends: [String], _ target: String) -> Int {\\n        var visited = Set(deadends)\\n        var queue = [(String, Int)]()\\n        var queueStart = 0\\n        \\n        let zeroAscii = Character(\"0\").asciiValue!\\n        let code = \"0000\"\\n        if !visited.contains(code) {\\n            queue.append((code, 0))\\n            visited.insert(code)\\n        }\\n        while queueStart != queue.count {\\n            let (currentCode, currentDeapth) = queue[queueStart]\\n            if currentCode == target {\\n                return currentDeapth\\n            }\\n            queueStart += 1\\n            \\n            let currentCodeArray = Array(currentCode)\\n            for (i, char) in currentCodeArray.enumerated() {\\n                let digit = char.asciiValue! - zeroAscii\\n                let nextDigit = (digit + 1) % 10\\n                let prevDigit = digit > 0 ? digit - 1 : 9\\n                for digit in [nextDigit, prevDigit] {\\n                    let nextDigitChar = Character(UnicodeScalar(digit + zeroAscii))\\n                    var nextCodeArray = currentCodeArray\\n                    nextCodeArray[i] = nextDigitChar\\n                    let nextCode = String(nextCodeArray)\\n                    if !visited.contains(nextCode) {\\n                        visited.insert(nextCode)\\n                        queue.append((nextCode, currentDeapth+1))\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134334,
                "title": "java-two-bfs",
                "content": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        // add the string of end ends to the dead_ends hashset\\n        HashSet<String>dead_ends = new HashSet(Arrays.asList(deadends));\\n        \\n        HashSet<String> visited = new HashSet();\\n        visited.add(\"0000\");\\n        \\n        Queue<String> queue = new LinkedList();\\n        queue.offer(\"0000\");\\n        \\n        int level = 0;\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size>0){\\n                String lock_position = queue.poll();\\n                if(dead_ends.contains(lock_position)){\\n                    size--;\\n                    continue;\\n                }\\n                \\n                if(lock_position.equals(target)){\\n                    return level;\\n                    \\n                }\\n                \\n                StringBuilder sb = new StringBuilder(lock_position);\\n                \\n                for(int i = 0; i < 4; i++){\\n                    char current_position = sb.charAt(i);\\n                    String s1 = sb.substring(0, i) + (current_position == \\'9\\' ? 0 : current_position - \\'0\\' + 1) + sb.substring(i+1);\\n                    String s2 = sb.substring(0, i) + (current_position == \\'0\\' ? 9 : current_position - \\'0\\' - 1) + sb.substring(i+1);\\n                    \\n                    if(!visited.contains(s1) && !dead_ends.contains(s1)){\\n                        queue.offer(s1);\\n                        visited.add(s1);\\n                    }\\n                    \\n                    if(!visited.contains(s2) && !dead_ends.contains(s2)){\\n                        queue.offer(s2);\\n                        visited.add(s2);\\n                    }\\n                }\\n                size--;\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        // add the string of end ends to the dead_ends hashset\\n        HashSet<String>dead_ends = new HashSet(Arrays.asList(deadends));\\n        \\n        HashSet<String> visited = new HashSet();\\n        visited.add(\"0000\");\\n        \\n        Queue<String> queue = new LinkedList();\\n        queue.offer(\"0000\");\\n        \\n        int level = 0;\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size>0){\\n                String lock_position = queue.poll();\\n                if(dead_ends.contains(lock_position)){\\n                    size--;\\n                    continue;\\n                }\\n                \\n                if(lock_position.equals(target)){\\n                    return level;\\n                    \\n                }\\n                \\n                StringBuilder sb = new StringBuilder(lock_position);\\n                \\n                for(int i = 0; i < 4; i++){\\n                    char current_position = sb.charAt(i);\\n                    String s1 = sb.substring(0, i) + (current_position == \\'9\\' ? 0 : current_position - \\'0\\' + 1) + sb.substring(i+1);\\n                    String s2 = sb.substring(0, i) + (current_position == \\'0\\' ? 9 : current_position - \\'0\\' - 1) + sb.substring(i+1);\\n                    \\n                    if(!visited.contains(s1) && !dead_ends.contains(s1)){\\n                        queue.offer(s1);\\n                        visited.add(s1);\\n                    }\\n                    \\n                    if(!visited.contains(s2) && !dead_ends.contains(s2)){\\n                        queue.offer(s2);\\n                        visited.add(s2);\\n                    }\\n                }\\n                size--;\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090596,
                "title": "java-solution-28-ms-beats-96",
                "content": "# Code\\n```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        int[] pow10 = {1, 10, 100, 1000};\\n        int[] visit = new int[10000]; // 0: not visited, 1: visited through forward direction, -1: visited through backward direction, 2: deadends\\n        for(String dead: deadends) {\\n            visit[Integer.parseInt(dead)] = 2;\\n        }\\n        int src = 0, dest = Integer.parseInt(target), steps = 0, dir = 1;\\n        if(visit[src] == 2 || visit[dest] == 2) return -1;\\n        if(src == dest) return 0;\\n        Queue<Integer> forward = new LinkedList<>(), backward = new LinkedList<>();\\n        forward.add(src);\\n        visit[src] = 1;\\n        backward.add(dest);\\n        visit[dest] = -1;\\n        while(!forward.isEmpty() && !backward.isEmpty()) {\\n            if(forward.size() > backward.size()) {\\n                Queue<Integer> tmp = forward; forward = backward; backward = tmp;\\n                dir = -dir;\\n            }\\n            steps++;\\n            int size = forward.size();\\n            while(size-- > 0) {\\n                int cur = forward.poll();\\n                for(int p: pow10) {\\n                    int d = (cur / p) % 10;\\n                    for(int i = -1; i <= 1; i += 2) {\\n                        int z = d + i;\\n                        z = z == -1 ? 9 : (z == 10 ? 0 : z);\\n                        int next = cur + (z - d) * p;\\n                        if(visit[next] == -dir) return steps;\\n                        if(visit[next] == 0) {\\n                            forward.add(next);\\n                            visit[next] = dir;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int openLock(String[] deadends, String target) {\\n        int[] pow10 = {1, 10, 100, 1000};\\n        int[] visit = new int[10000]; // 0: not visited, 1: visited through forward direction, -1: visited through backward direction, 2: deadends\\n        for(String dead: deadends) {\\n            visit[Integer.parseInt(dead)] = 2;\\n        }\\n        int src = 0, dest = Integer.parseInt(target), steps = 0, dir = 1;\\n        if(visit[src] == 2 || visit[dest] == 2) return -1;\\n        if(src == dest) return 0;\\n        Queue<Integer> forward = new LinkedList<>(), backward = new LinkedList<>();\\n        forward.add(src);\\n        visit[src] = 1;\\n        backward.add(dest);\\n        visit[dest] = -1;\\n        while(!forward.isEmpty() && !backward.isEmpty()) {\\n            if(forward.size() > backward.size()) {\\n                Queue<Integer> tmp = forward; forward = backward; backward = tmp;\\n                dir = -dir;\\n            }\\n            steps++;\\n            int size = forward.size();\\n            while(size-- > 0) {\\n                int cur = forward.poll();\\n                for(int p: pow10) {\\n                    int d = (cur / p) % 10;\\n                    for(int i = -1; i <= 1; i += 2) {\\n                        int z = d + i;\\n                        z = z == -1 ? 9 : (z == 10 ? 0 : z);\\n                        int next = cur + (z - d) * p;\\n                        if(visit[next] == -dir) return steps;\\n                        if(visit[next] == 0) {\\n                            forward.add(next);\\n                            visit[next] = dir;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065418,
                "title": "c-accurate-solution-beats-85",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int openLock(const vector<string>& deadends, const string& target) {\\n        unordered_set<string> deads(deadends.begin(), deadends.end()), visited{\"0000\"};\\n        if (deads.find(\"0000\") != deads.end()) return -1;\\n        queue<string> q;\\n        q.push(\"0000\");\\n        int count = 0, s;\\n        string tmp;\\n\\n        while (q.empty() == false)\\n        {\\n            s = q.size();\\n\\n            while (s--)\\n            {\\n                tmp = q.front();\\n                q.pop();\\n\\n                if (tmp == target)\\n                    return count;\\n                \\n                for (char& c : tmp)\\n                {\\n                    c = Inc(c);\\n\\n                    if (deads.find(tmp) == deads.end() && visited.find(tmp) == visited.end())\\n                        q.push(tmp), visited.insert(tmp);\\n\\n                    c = Dec(Dec(c)); \\n\\n                    if (deads.find(tmp) == deads.end() && visited.find(tmp) == visited.end())\\n                        q.push(tmp), visited.insert(tmp);\\n\\n                    c = Inc(c); // Return to inital value\\n                }\\n            }\\n\\n            ++count;\\n        }\\n\\n        return -1;\\n    }\\n\\nprivate:\\n    inline char Inc(char c) { return c == \\'9\\' ? \\'0\\' : c + 1;  }\\n    inline char Dec(char c) { return c == \\'0\\' ? \\'9\\' : c - 1; }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(const vector<string>& deadends, const string& target) {\\n        unordered_set<string> deads(deadends.begin(), deadends.end()), visited{\"0000\"};\\n        if (deads.find(\"0000\") != deads.end()) return -1;\\n        queue<string> q;\\n        q.push(\"0000\");\\n        int count = 0, s;\\n        string tmp;\\n\\n        while (q.empty() == false)\\n        {\\n            s = q.size();\\n\\n            while (s--)\\n            {\\n                tmp = q.front();\\n                q.pop();\\n\\n                if (tmp == target)\\n                    return count;\\n                \\n                for (char& c : tmp)\\n                {\\n                    c = Inc(c);\\n\\n                    if (deads.find(tmp) == deads.end() && visited.find(tmp) == visited.end())\\n                        q.push(tmp), visited.insert(tmp);\\n\\n                    c = Dec(Dec(c)); \\n\\n                    if (deads.find(tmp) == deads.end() && visited.find(tmp) == visited.end())\\n                        q.push(tmp), visited.insert(tmp);\\n\\n                    c = Inc(c); // Return to inital value\\n                }\\n            }\\n\\n            ++count;\\n        }\\n\\n        return -1;\\n    }\\n\\nprivate:\\n    inline char Inc(char c) { return c == \\'9\\' ? \\'0\\' : c + 1;  }\\n    inline char Dec(char c) { return c == \\'0\\' ? \\'9\\' : c - 1; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555351,
                "title": "bfs-a-simple-and-short-solution",
                "content": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        deq = collections.deque()\\n        visited = set()\\n        count = 0\\n        deq.append(\\'0000\\')\\n        visited.add(\\'0000\\')\\n        deadends = set(deadends)\\n\\n        if \\'0000\\' in deadends:\\n            return -1\\n\\n        while deq:\\n            for _ in range(len(deq)):\\n                cur_state = deq.popleft()\\n                if cur_state == target:\\n                    return count\\n                for ind, pos in enumerate(cur_state):\\n                    new_state1 = (f\\'{cur_state[:ind]}{(int(pos) + 1) % 10}\\'\\n                                  f\\'{cur_state[ind + 1:]}\\')\\n                    new_state2 = (f\\'{cur_state[:ind]}{(int(pos) - 1) % 10}\\'\\n                                  f\\'{cur_state[ind + 1:]}\\')\\n                    if new_state1 not in visited and new_state1 not in deadends:\\n                        visited.add(new_state1)\\n                        deq.append(new_state1)\\n                    if new_state2 not in visited and new_state2 not in deadends:\\n                        visited.add(new_state2)\\n                        deq.append(new_state2)\\n            count += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def openLock(self, deadends: List[str], target: str) -> int:\\n        deq = collections.deque()\\n        visited = set()\\n        count = 0\\n        deq.append(\\'0000\\')\\n        visited.add(\\'0000\\')\\n        deadends = set(deadends)\\n\\n        if \\'0000\\' in deadends:\\n            return -1\\n\\n        while deq:\\n            for _ in range(len(deq)):\\n                cur_state = deq.popleft()\\n                if cur_state == target:\\n                    return count\\n                for ind, pos in enumerate(cur_state):\\n                    new_state1 = (f\\'{cur_state[:ind]}{(int(pos) + 1) % 10}\\'\\n                                  f\\'{cur_state[ind + 1:]}\\')\\n                    new_state2 = (f\\'{cur_state[:ind]}{(int(pos) - 1) % 10}\\'\\n                                  f\\'{cur_state[ind + 1:]}\\')\\n                    if new_state1 not in visited and new_state1 not in deadends:\\n                        visited.add(new_state1)\\n                        deq.append(new_state1)\\n                    if new_state2 not in visited and new_state2 not in deadends:\\n                        visited.add(new_state2)\\n                        deq.append(new_state2)\\n            count += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541305,
                "title": "c-bfs-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string turnUp(string str,int i)\\n    {\\n        string ans= str;\\n        if(ans[i]==\\'9\\')\\n            ans[i]=\\'0\\';\\n        else\\n            ans[i]+=1;\\n        return ans;\\n    }\\n    string turnDown(string str, int i)\\n    {\\n        string ans= str;\\n        if(ans[i]==\\'0\\')\\n            ans[i]=\\'9\\';\\n        else\\n            ans[i]-=1;\\n        return ans;\\n    }\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> visited;\\n        queue<string>q;\\n        \\n        for(string str: deadends)\\n            visited.insert(str);\\n        q.push(\"0000\");\\n        int count=0;\\n        while(q.empty()==false)\\n        {\\n            int n= q.size();\\n            \\n            \\n            for(int i=0;i<n;i++)\\n            {\\n               string curr= q.front();\\n                q.pop();\\n                \\n                if(curr==target)\\n                    return count;\\n                if(visited.find(curr)!=visited.end())\\n                    continue;\\n                visited.insert(curr);\\n                for(int i=0;i<4;i++)\\n                {\\n                    string turnup= turnUp(curr,i);\\n                     string turndown= turnDown(curr,i);\\n                    if(visited.find(turnup)==visited.end())\\n                        q.push(turnup);\\n                    if(visited.find(turndown)==visited.end())\\n                        q.push(turndown);\\n                }\\n                \\n            }\\n            count++;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};****\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string turnUp(string str,int i)\\n    {\\n        string ans= str;\\n        if(ans[i]==\\'9\\')\\n            ans[i]=\\'0\\';\\n        else\\n            ans[i]+=1;\\n        return ans;\\n    }\\n    string turnDown(string str, int i)\\n    {\\n        string ans= str;\\n        if(ans[i]==\\'0\\')\\n            ans[i]=\\'9\\';\\n        else\\n            ans[i]-=1;\\n        return ans;\\n    }\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> visited;\\n        queue<string>q;\\n        \\n        for(string str: deadends)\\n            visited.insert(str);\\n        q.push(\"0000\");\\n        int count=0;\\n        while(q.empty()==false)\\n        {\\n            int n= q.size();\\n            \\n            \\n            for(int i=0;i<n;i++)\\n            {\\n               string curr= q.front();\\n                q.pop();\\n                \\n                if(curr==target)\\n                    return count;\\n                if(visited.find(curr)!=visited.end())\\n                    continue;\\n                visited.insert(curr);\\n                for(int i=0;i<4;i++)\\n                {\\n                    string turnup= turnUp(curr,i);\\n                     string turndown= turnDown(curr,i);\\n                    if(visited.find(turnup)==visited.end())\\n                        q.push(turnup);\\n                    if(visited.find(turndown)==visited.end())\\n                        q.push(turndown);\\n                }\\n                \\n            }\\n            count++;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482532,
                "title": "c-multidirectional-bfs-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n       map<char, char> f, b;\\n        for(int i=0; i<9; i++)\\n        {\\n             f[\\'0\\' + i] = \\'0\\' + i + 1;\\n             b[\\'9\\' - i] = \\'9\\' - i - 1;\\n        }\\n        \\n        f[\\'9\\'] = \\'0\\';\\n        b[\\'0\\'] = \\'9\\';\\n        \\n        set<string> st;\\n        string s = \"0000\";\\n        for(auto &t : deadends)\\n        {\\n            if(t == s) return -1;\\n            st.insert(t);\\n        }\\n        queue<string> q;\\n        q.push(s);\\n        st.insert(s);\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                string t = q.front();\\n                q.pop();\\n                if(t==target) return ans;\\n                for(int i=0; i<4; i++)\\n                {\\n                    char c = t[i];\\n                    \\n                    t[i] = f[c];\\n                    if(st.find(t)==st.end())\\n                    {\\n                        q.push(t);\\n                        st.insert(t);\\n                    }\\n                    \\n                    t[i] = b[c];\\n                    if(st.find(t)==st.end())\\n                    {\\n                        q.push(t);\\n                        st.insert(t);\\n                    }\\n                    \\n                    t[i] = c;\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n       map<char, char> f, b;\\n        for(int i=0; i<9; i++)\\n        {\\n             f[\\'0\\' + i] = \\'0\\' + i + 1;\\n             b[\\'9\\' - i] = \\'9\\' - i - 1;\\n        }\\n        \\n        f[\\'9\\'] = \\'0\\';\\n        b[\\'0\\'] = \\'9\\';\\n        \\n        set<string> st;\\n        string s = \"0000\";\\n        for(auto &t : deadends)\\n        {\\n            if(t == s) return -1;\\n            st.insert(t);\\n        }\\n        queue<string> q;\\n        q.push(s);\\n        st.insert(s);\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                string t = q.front();\\n                q.pop();\\n                if(t==target) return ans;\\n                for(int i=0; i<4; i++)\\n                {\\n                    char c = t[i];\\n                    \\n                    t[i] = f[c];\\n                    if(st.find(t)==st.end())\\n                    {\\n                        q.push(t);\\n                        st.insert(t);\\n                    }\\n                    \\n                    t[i] = b[c];\\n                    if(st.find(t)==st.end())\\n                    {\\n                        q.push(t);\\n                        st.insert(t);\\n                    }\\n                    \\n                    t[i] = c;\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477483,
                "title": "java-bfs-use-integer-instead-of-string",
                "content": "Each state of lock use like integer index.\\n\\n```\\nclass Solution {\\n    private final static int N = 10000; \\n    private boolean[] visited;\\n    private int target;\\n    \\n    public int openLock(String[] deadends, String target) {\\n        visited = new boolean[N];\\n        this.target = Integer.parseInt(target);\\n        if (this.target == 0) return 0;\\n        \\n        for (String end : deadends) {\\n            int index = Integer.parseInt(end);\\n            visited[index] = true;\\n        }\\n        \\n        int count = 0;\\n        List<Integer> current = new ArrayList<>();\\n        if (visited[0]) return -1;\\n        current.add(0);\\n        visited[0] = true; \\n        while (!current.isEmpty()) {\\n            current = bfsStep(current);\\n            ++count;\\n        }\\n        \\n        return visited[this.target] ? count : -1;\\n    }\\n    \\n    private List<Integer> bfsStep(List<Integer> current) {\\n        List<Integer> next = new ArrayList<>();\\n        for (Integer v : current) {\\n            List<Integer> neigbours = getNeigbours(v);\\n            for (Integer u : neigbours) {\\n                if (u.intValue() == target) {\\n                    visited[u] = true;\\n                    next.clear();\\n                    return next;\\n                }\\n                \\n                if (!visited[u]) {\\n                    visited[u] = true;\\n                    next.add(u);\\n                }\\n            }\\n        }\\n        \\n        return next;\\n    }\\n    \\n    \\n    private List<Integer> getNeigbours(final int v) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for (int i = 1; i < N; i = i*10) {\\n            int d = (v/i)%10;\\n            int next = (d == 9) ? 0 : d + 1;\\n            int prev = (d == 0) ? 9 : d - 1;\\n            list.add(v - d*i + next*i);\\n            list.add(v - d*i + prev*i); \\n        }    \\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private final static int N = 10000; \\n    private boolean[] visited;\\n    private int target;\\n    \\n    public int openLock(String[] deadends, String target) {\\n        visited = new boolean[N];\\n        this.target = Integer.parseInt(target);\\n        if (this.target == 0) return 0;\\n        \\n        for (String end : deadends) {\\n            int index = Integer.parseInt(end);\\n            visited[index] = true;\\n        }\\n        \\n        int count = 0;\\n        List<Integer> current = new ArrayList<>();\\n        if (visited[0]) return -1;\\n        current.add(0);\\n        visited[0] = true; \\n        while (!current.isEmpty()) {\\n            current = bfsStep(current);\\n            ++count;\\n        }\\n        \\n        return visited[this.target] ? count : -1;\\n    }\\n    \\n    private List<Integer> bfsStep(List<Integer> current) {\\n        List<Integer> next = new ArrayList<>();\\n        for (Integer v : current) {\\n            List<Integer> neigbours = getNeigbours(v);\\n            for (Integer u : neigbours) {\\n                if (u.intValue() == target) {\\n                    visited[u] = true;\\n                    next.clear();\\n                    return next;\\n                }\\n                \\n                if (!visited[u]) {\\n                    visited[u] = true;\\n                    next.add(u);\\n                }\\n            }\\n        }\\n        \\n        return next;\\n    }\\n    \\n    \\n    private List<Integer> getNeigbours(final int v) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for (int i = 1; i < N; i = i*10) {\\n            int d = (v/i)%10;\\n            int next = (d == 9) ? 0 : d + 1;\\n            int prev = (d == 0) ? 9 : d - 1;\\n            list.add(v - d*i + next*i);\\n            list.add(v - d*i + prev*i); \\n        }    \\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466386,
                "title": "python-bfs-without-extra-unnecessary-loops",
                "content": "```\\n def openLock(self, deadends: List[str], target: str) -> int:\\n        \\n        def nextnodes(node):\\n            nodelist = []\\n            for i in range(4):\\n                if node[i] == \\'0\\':\\n                    nodelist.append(node[:i] + \\'9\\' + node[i+1:])\\n                    nodelist.append(node[:i] + \\'1\\' + node[i+1:])\\n                elif node[i] == \\'9\\':\\n                    nodelist.append(node[:i] + \\'0\\' + node[i+1:])\\n                    nodelist.append(node[:i] + \\'8\\' + node[i+1:])\\n                else:\\n                    nodelist.append(node[:i] + str(int(node[i])+1) + node[i+1:])\\n                    nodelist.append(node[:i] + str(int(node[i])-1) + node[i+1:])\\n\\n            return nodelist\\n                    \\n                \\n        if \\'0000\\' in deadends or target in deadends:\\n            return -1\\n        \\n        if target == \\'0000\\':\\n            return 0\\n        \\n        Q = [(\\'0000\\', 0)]\\n        visited = set()\\n        visited.add(\\'0000\\')\\n        while len(Q) > 0:\\n            node, level = Q.pop(0)           \\n            for i in nextnodes(node):\\n                if i == target:\\n                    return level+1                    \\n                elif i not in visited and i not in deadends:\\n                    Q.append((i, level+1))\\n                    visited.add(i)\\n                    \\n        return -1\\n",
                "solutionTags": [],
                "code": "```\\n def openLock(self, deadends: List[str], target: str) -> int:\\n        \\n        def nextnodes(node):\\n            nodelist = []\\n            for i in range(4):\\n                if node[i] == \\'0\\':\\n                    nodelist.append(node[:i] + \\'9\\' + node[i+1:])\\n                    nodelist.append(node[:i] + \\'1\\' + node[i+1:])\\n                elif node[i] == \\'9\\':\\n                    nodelist.append(node[:i] + \\'0\\' + node[i+1:])\\n                    nodelist.append(node[:i] + \\'8\\' + node[i+1:])\\n                else:\\n                    nodelist.append(node[:i] + str(int(node[i])+1) + node[i+1:])\\n                    nodelist.append(node[:i] + str(int(node[i])-1) + node[i+1:])\\n\\n            return nodelist\\n                    \\n                \\n        if \\'0000\\' in deadends or target in deadends:\\n            return -1\\n        \\n        if target == \\'0000\\':\\n            return 0\\n        \\n        Q = [(\\'0000\\', 0)]\\n        visited = set()\\n        visited.add(\\'0000\\')\\n        while len(Q) > 0:\\n            node, level = Q.pop(0)           \\n            for i in nextnodes(node):\\n                if i == target:\\n                    return level+1                    \\n                elif i not in visited and i not in deadends:\\n                    Q.append((i, level+1))\\n                    visited.add(i)\\n                    \\n        return -1\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2432954,
                "title": "explained-c-solution",
                "content": "```\\n/*explantion:\\n\\n-> queue is used to store string and moves needed to reach that combination.\\n-> we use set to save the deadends and visited string\\n-> if strings created after modifications are present in deadends are ignored and not saved in queue\\n-> if the newly created string is the target then it took (move + 1) moves to reach there.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n            int openLock(vector<string>& deadends, string target) {\\n            queue<pair<string,int>>q;\\n            unordered_set<string>s,visited;\\n            for(auto it:deadends) s.insert(it);\\n            if(s.find(\"0000\") != s.end() || s.find(target) != s.end()) return -1;\\n            q.push({\"0000\",0});\\n            if(\"0000\" == target) return 0;\\n\\n            while(!q.empty()){\\n              auto [num,move] = q.front(); q.pop();  \\n\\n              for(int i = 0; i < 4; ++i){\\n                  char temp = num[i];\\n                  int curr = num[i] - \\'0\\';\\n                  int next = (curr + 1)%10; //handles increment range [0-9] in ith pos\\n                  num[i] = next + \\'0\\';\\n                  if(target == num) return move + 1;\\n\\n                  if(s.find(num) == s.end() && visited.find(num) == visited.end())\\n                      {\\n                        q.push({num,move+1});\\n                        visited.insert(num);\\n                      }\\n\\n                  next = (curr -1 + 10)%10; //handles decrement range [0-9] in ith pos\\n                  num[i] = next + \\'0\\';\\n                  if(target == num) return move + 1;\\n\\n                  if(s.find(num) == s.end() && visited.find(num) == visited.end())\\n                      {\\n                        q.push({num,move+1});\\n                        visited.insert(num);\\n                      }\\n\\n                  num[i] = curr + \\'0\\';       \\n              }\\n            }\\n        return -1;\\n    }\\n};\\n```\\n//if liked please upvote :)",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/*explantion:\\n\\n-> queue is used to store string and moves needed to reach that combination.\\n-> we use set to save the deadends and visited string\\n-> if strings created after modifications are present in deadends are ignored and not saved in queue\\n-> if the newly created string is the target then it took (move + 1) moves to reach there.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n            int openLock(vector<string>& deadends, string target) {\\n            queue<pair<string,int>>q;\\n            unordered_set<string>s,visited;\\n            for(auto it:deadends) s.insert(it);\\n            if(s.find(\"0000\") != s.end() || s.find(target) != s.end()) return -1;\\n            q.push({\"0000\",0});\\n            if(\"0000\" == target) return 0;\\n\\n            while(!q.empty()){\\n              auto [num,move] = q.front(); q.pop();  \\n\\n              for(int i = 0; i < 4; ++i){\\n                  char temp = num[i];\\n                  int curr = num[i] - \\'0\\';\\n                  int next = (curr + 1)%10; //handles increment range [0-9] in ith pos\\n                  num[i] = next + \\'0\\';\\n                  if(target == num) return move + 1;\\n\\n                  if(s.find(num) == s.end() && visited.find(num) == visited.end())\\n                      {\\n                        q.push({num,move+1});\\n                        visited.insert(num);\\n                      }\\n\\n                  next = (curr -1 + 10)%10; //handles decrement range [0-9] in ith pos\\n                  num[i] = next + \\'0\\';\\n                  if(target == num) return move + 1;\\n\\n                  if(s.find(num) == s.end() && visited.find(num) == visited.end())\\n                      {\\n                        q.push({num,move+1});\\n                        visited.insert(num);\\n                      }\\n\\n                  num[i] = curr + \\'0\\';       \\n              }\\n            }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311941,
                "title": "c-fastest-solution-using-bfs-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n      \\n      unordered_map<string,int>check;\\n        for(auto x:deadends){\\n            check[x]++;\\n        }\\n        unordered_map<string,int>dp;\\n        dp[\"0000\"]=0;\\n        queue<string>q;\\n        q.push(\"0000\");\\n        if(check.count(\"0000\"))return -1;\\n        while(!q.empty()){\\n            string f=q.front();\\n            string temp=f;\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                //first optin increment\\n                int r=(int)(temp[i]-\\'0\\');\\n                int nx=(r+1)%10;\\n                temp[i]=nx+\\'0\\';\\n                if(check.find(temp)==check.end()){\\n                    if(dp.find(temp)==dp.end() or dp[temp]>dp[f]+1){\\n                        dp[temp]=dp[f]+1;\\n                        q.push(temp);\\n                    }\\n                }\\n              \\n                nx=(r+9)%10;\\n                temp[i]=nx+\\'0\\';\\n                   if(check.find(temp)==check.end()){\\n                    if(dp.find(temp)==dp.end() or dp[temp]>dp[f]+1){\\n                        dp[temp]=dp[f]+1;\\n                        q.push(temp);\\n                    }\\n                }\\n                temp[i]=r+\\'0\\';\\n                \\n                \\n            }\\n        }\\n        if(dp.find(target)==dp.end())return -1;\\n        return dp[target];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n      \\n      unordered_map<string,int>check;\\n        for(auto x:deadends){\\n            check[x]++;\\n        }\\n        unordered_map<string,int>dp;\\n        dp[\"0000\"]=0;\\n        queue<string>q;\\n        q.push(\"0000\");\\n        if(check.count(\"0000\"))return -1;\\n        while(!q.empty()){\\n            string f=q.front();\\n            string temp=f;\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                //first optin increment\\n                int r=(int)(temp[i]-\\'0\\');\\n                int nx=(r+1)%10;\\n                temp[i]=nx+\\'0\\';\\n                if(check.find(temp)==check.end()){\\n                    if(dp.find(temp)==dp.end() or dp[temp]>dp[f]+1){\\n                        dp[temp]=dp[f]+1;\\n                        q.push(temp);\\n                    }\\n                }\\n              \\n                nx=(r+9)%10;\\n                temp[i]=nx+\\'0\\';\\n                   if(check.find(temp)==check.end()){\\n                    if(dp.find(temp)==dp.end() or dp[temp]>dp[f]+1){\\n                        dp[temp]=dp[f]+1;\\n                        q.push(temp);\\n                    }\\n                }\\n                temp[i]=r+\\'0\\';\\n                \\n                \\n            }\\n        }\\n        if(dp.find(target)==dp.end())return -1;\\n        return dp[target];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305538,
                "title": "c-bfs",
                "content": "Use BFS to do the problem: basic preparations: a set for recording and checking the deadends in O(1) time, a set recording and checking the visited string to avoid cycle, a queue for storing each step\\'s potential choices. Initial set-up: push the starting string \"0000\" to queue. Processing: while q is not empty, get the current size of the q, loop the first sz elements of q, check the current element is valid or equal to target, then check its children(up and down by one) and push them to q.\\n\\n```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> st;\\n        for (auto deadend : deadends) {\\n            st.insert(deadend);\\n        }\\n        string init = \"0000\";\\n        queue<string> q;\\n        unordered_set<string> visited;\\n        q.push(init);\\n        string temp, temp2;\\n        int sz;\\n        int steps = 0;\\n        while (!q.empty()) {\\n            sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                temp = q.front();\\n                q.pop();\\n                if (temp == target) {\\n                    return steps;\\n                }\\n                if (st.count(temp)) {\\n                    continue;\\n                }\\n                for (int j = 0; j < 4; j++) {\\n                    temp2 = switchUp(temp, j);\\n                    if (!visited.count(temp2)) {\\n                        q.push(temp2);\\n                        visited.insert(temp2);\\n                    }\\n                    temp2 = switchDown(temp, j);\\n                    if (!visited.count(temp2)) {\\n                        q.push(temp2);\\n                        visited.insert(temp2);\\n                    }\\n                }\\n            } \\n            steps++;\\n        }\\n        return -1;\\n    }\\n    string switchUp(string s, int i) {\\n        if (s[i] == \\'9\\') {\\n            s[i] = \\'0\\';\\n        }\\n        else {\\n            s[i]++;\\n        }\\n        return s;\\n    }\\n    string switchDown(string s, int i) {\\n        if (s[i] == \\'0\\') {\\n            s[i] = \\'9\\';\\n        }\\n        else {\\n            s[i]--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int openLock(vector<string>& deadends, string target) {\\n        unordered_set<string> st;\\n        for (auto deadend : deadends) {\\n            st.insert(deadend);\\n        }\\n        string init = \"0000\";\\n        queue<string> q;\\n        unordered_set<string> visited;\\n        q.push(init);\\n        string temp, temp2;\\n        int sz;\\n        int steps = 0;\\n        while (!q.empty()) {\\n            sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                temp = q.front();\\n                q.pop();\\n                if (temp == target) {\\n                    return steps;\\n                }\\n                if (st.count(temp)) {\\n                    continue;\\n                }\\n                for (int j = 0; j < 4; j++) {\\n                    temp2 = switchUp(temp, j);\\n                    if (!visited.count(temp2)) {\\n                        q.push(temp2);\\n                        visited.insert(temp2);\\n                    }\\n                    temp2 = switchDown(temp, j);\\n                    if (!visited.count(temp2)) {\\n                        q.push(temp2);\\n                        visited.insert(temp2);\\n                    }\\n                }\\n            } \\n            steps++;\\n        }\\n        return -1;\\n    }\\n    string switchUp(string s, int i) {\\n        if (s[i] == \\'9\\') {\\n            s[i] = \\'0\\';\\n        }\\n        else {\\n            s[i]++;\\n        }\\n        return s;\\n    }\\n    string switchDown(string s, int i) {\\n        if (s[i] == \\'0\\') {\\n            s[i] = \\'9\\';\\n        }\\n        else {\\n            s[i]--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288529,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n         vector<string>distinct(string &s){\\n             vector<string>ans;\\n             for(char &c:s){\\n          char o=c;\\n              int y=c-\\'0\\';\\n                int z=(y+1)%10;/// c=(char)c;\\n                 c=z+\\'0\\';\\n               \\n            ans.push_back(s);\\n                 z=(10+y-1)%10;\\n                 c=z+\\'0\\';\\n                 ans.push_back(s);\\n                 c= o;\\n             }\\n             return ans;\\n         }\\n    int openLock(vector<string>& deadends, string target) {\\n        for(string s:deadends){\\n            if(s==\"0000\"){\\n                \\n                return -1;\\n            }\\n        }\\n        map<string ,vector<string>>mp;\\n        string start=\"0000\";\\n    mp[\"0000\"]=distinct(start);\\n        for(auto i:mp){\\n         for(string s:i.second){\\n             cout<<s<<endl;\\n         }\\n            \\n        }\\n      \\n        queue<string>q;\\n        q.push(start);\\n        map<string,bool>vis;\\n        for(string s:deadends)vis[s]=true;\\n        vis[start]=true;\\n        int count=0;\\n        while(!q.empty()){\\n            \\n            int size=q.size();\\n            \\n            while(size--){\\n                string curr=q.front();\\n                q.pop();\\n                mp[curr]=distinct(curr);\\n                if(curr==target){\\n                    return count;\\n                }\\n              \\n                for(string c:mp[curr]){\\n                    if(!vis[c]){\\n                        q.push(c);\\n                        vis[c]=true;\\n                    }\\n       \\n                }\\n\\n            }                             \\n                    count++;\\n        }\\n        \\n   \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n         vector<string>distinct(string &s){\\n             vector<string>ans;\\n             for(char &c:s){\\n          char o=c;\\n              int y=c-\\'0\\';\\n                int z=(y+1)%10;/// c=(char)c;\\n                 c=z+\\'0\\';\\n               \\n            ans.push_back(s);\\n                 z=(10+y-1)%10;\\n                 c=z+\\'0\\';\\n                 ans.push_back(s);\\n                 c= o;\\n             }\\n             return ans;\\n         }\\n    int openLock(vector<string>& deadends, string target) {\\n        for(string s:deadends){\\n            if(s==\"0000\"){\\n                \\n                return -1;\\n            }\\n        }\\n        map<string ,vector<string>>mp;\\n        string start=\"0000\";\\n    mp[\"0000\"]=distinct(start);\\n        for(auto i:mp){\\n         for(string s:i.second){\\n             cout<<s<<endl;\\n         }\\n            \\n        }\\n      \\n        queue<string>q;\\n        q.push(start);\\n        map<string,bool>vis;\\n        for(string s:deadends)vis[s]=true;\\n        vis[start]=true;\\n        int count=0;\\n        while(!q.empty()){\\n            \\n            int size=q.size();\\n            \\n            while(size--){\\n                string curr=q.front();\\n                q.pop();\\n                mp[curr]=distinct(curr);\\n                if(curr==target){\\n                    return count;\\n                }\\n              \\n                for(string c:mp[curr]){\\n                    if(!vis[c]){\\n                        q.push(c);\\n                        vis[c]=true;\\n                    }\\n       \\n                }\\n\\n            }                             \\n                    count++;\\n        }\\n        \\n   \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1565063,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1568419,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1921086,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1828448,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1705905,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1795550,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1698247,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1574510,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1573146,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1571822,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1565063,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1568419,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1921086,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1828448,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1705905,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1795550,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1698247,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1574510,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1573146,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            },
            {
                "id": 1571822,
                "content": [
                    {
                        "username": "vigjadel",
                        "content": "Can we apply DFS to this problem ?"
                    },
                    {
                        "username": "tr1ten",
                        "content": "possible but not feasible..."
                    },
                    {
                        "username": "belinskyi",
                        "content": "No, as we need to find the smallest number or rotations. With DFS you\\'ll need to evaluate all possible combinations and select the lowest one. With BFS you stop checking combinations as soon as you find a valid combination."
                    },
                    {
                        "username": "poetic-foool",
                        "content": "I thoroughly enjoyed doing this problem. I rate it highest problem in BFS so far! You will gain much more insight in bfs after doing this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Can you share your insight please?"
                    },
                    {
                        "username": "neo9729",
                        "content": "Agreed, looked like a lot at first, if you just do it with intuition it works, I solved it by reducing the problem to two digit lock 00"
                    },
                    {
                        "username": "narendranaidu",
                        "content": "What is the insight?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for similar problem to practice, **#433 Minimum Genetic Mutations** is a good one. I solved it before seeing this one, and it's basically the same idea."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Sneaky Sneaky\\n```\\n[\"0000\"]\\n\"8888\"\\n```"
                    },
                    {
                        "username": "code__HARD",
                        "content": "before that 45/48 TC passed. After noticing Accepted.\\uD83D\\uDC68"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@georgezakharov](/georgezakharov) maybe reduce your wrong submissions?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "What this tip is about?"
                    },
                    {
                        "username": "minniekabra",
                        "content": "If you're finding this problem difficult, then try to first solve a simpler problem - a single digit lock (and with no deadends initially)"
                    },
                    {
                        "username": "neo9729",
                        "content": "Try to draw the tree for iteration with 2 digits first - 00"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I got Time Limit Exceeded for the final (48/48) testcase. It reports \\n```\\nLast Executed Input\\n48 / 48 testcases passed\\ndeadends =\\n```\\nWhich is an invalid input. Im guessing its just not showing up right, but there is no target, and deadends must contain at least one value per the instructions. Thanks Leetcode"
                    },
                    {
                        "username": "neerajsomani4",
                        "content": "Can someone explain the time and space complexity of this problem. Why no one mentioning it in there solution. If its already explained somewhere, please share the link. Thanks"
                    },
                    {
                        "username": "upatel231a",
                        "content": "According to my code, I created a map to find deadends effectively so it will take O(D) time and space. For the combination there are N choices and P places which is N^P and in each choice we generate 2P additional neighbors so overall time complexity would be O(N^P * 2P) and space will be O(N^P). Therefor overall time complexity will be O(D + (N^P * P)) And space complexity will be O(D + N^P). "
                    },
                    {
                        "username": "WHCer",
                        "content": "The 40ms solution only consider one step block. They return 8 for the following test case while it should be -1.\\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9887\",\"9889\",\"9878\",\"9898\",\"9788\",\"9988\",\"0888\"]\\n\"8888\""
                    },
                    {
                        "username": "qiuyanzhang",
                        "content": "I got the below error during the contest. \\n\\nInput:\\n[\"1002\",\"1220\",\"0122\",\"0112\",\"0121\"]\\n\"1200\"\\nOutput:\\n3\\nExpected:\\n3\\n\\nwhy?"
                    }
                ]
            }
        ]
    }
]