[
    {
        "title": "Minimum Distance to the Target Element",
        "question_content": "Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that&nbsp;abs(x)&nbsp;is the absolute value of x.\nReturn abs(i - start).\nIt is guaranteed that target exists in nums.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3,4,5], target = 5, start = 3\nOutput: 1\nExplanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.\n\nExample 2:\n\nInput: nums = [1], target = 1, start = 0\nOutput: 0\nExplanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.\n\nExample 3:\n\nInput: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0\nOutput: 0\nExplanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1000\n\t1 <= nums[i] <= 104\n\t0 <= start < nums.length\n\ttarget is in nums.",
        "solutions": [
            {
                "id": 1186927,
                "title": "c-one-pass-optimization",
                "content": "As an optional optimization, we exit early if `res` cannot be improved anymore.\\n\\n\\n```cpp\\nint getMinDistance(vector<int>& nums, int target, int start) {\\n    int res = INT_MAX;\\n    for (int i = 0; i < nums.size() && res > abs(start - i); ++i)\\n        if (nums[i] == target)\\n            res = abs(start - i);\\n    return res;\\n}\\n```\\nAnother optimization is to initiate the search from the `start` position. It is potentially faster when the `target` is close to the `start`.\\n```cpp\\nint getMinDistance(vector<int>& nums, int t, int start) {\\n    int i = 0, sz = nums.size();\\n    while (nums[max(0, start - i)] != t && nums[min(start + i, sz - 1)] != t)\\n        ++i;\\n    return i;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint getMinDistance(vector<int>& nums, int target, int start) {\\n    int res = INT_MAX;\\n    for (int i = 0; i < nums.size() && res > abs(start - i); ++i)\\n        if (nums[i] == target)\\n            res = abs(start - i);\\n    return res;\\n}\\n```\n```cpp\\nint getMinDistance(vector<int>& nums, int t, int start) {\\n    int i = 0, sz = nums.size();\\n    while (nums[max(0, start - i)] != t && nums[min(start + i, sz - 1)] != t)\\n        ++i;\\n    return i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186947,
                "title": "clean-python-3-o-answer",
                "content": "Will be faster if `target` is cloese to `start`.\\n\\nTime: `O(answer)`, degrade to `O(N)` if target is in the head or tail of the given array.\\nSpace: `O(1)`\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        l = r = start\\n        while l >= 0 or r < len(nums):\\n            if l >= 0 and nums[l] == target: return start - l\\n            if r < len(nums) and nums[r] == target: return r - start\\n            l -= 1\\n            r += 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        l = r = start\\n        while l >= 0 or r < len(nums):\\n            if l >= 0 and nums[l] == target: return start - l\\n            if r < len(nums) and nums[r] == target: return r - start\\n            l -= 1\\n            r += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186832,
                "title": "python-1-line-solution",
                "content": "# **Explanation**\\nIterate all values and check if it equals to target.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n\\n**Python**\\n```py\\n    def getMinDistance(self, A, target, start):\\n        return min(abs(i - start) for i, a in enumerate(A) if a == target)\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def getMinDistance(self, A, target, start):\\n        return min(abs(i - start) for i, a in enumerate(A) if a == target)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1186862,
                "title": "python3-linear-sweep",
                "content": "\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        ans = inf\\n        for i, x in enumerate(nums): \\n            if x == target: \\n                ans = min(ans, abs(i - start))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        ans = inf\\n        for i, x in enumerate(nums): \\n            if x == target: \\n                ans = min(ans, abs(i - start))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186825,
                "title": "c-java-self-explanatory",
                "content": "# c++\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                ans=min(ans,abs(i-start));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# java\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                ans = Math.min(ans, Math.abs(i - start));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                ans=min(ans,abs(i-start));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                ans = Math.min(ans, Math.abs(i - start));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186979,
                "title": "c-sequential-scan-two-pointer-approach",
                "content": "There are two ways to solve this problem.\\n\\n1. Doing a sequential traversal of array and updating the min(abs(start-i), min) whenever nums[i] == target.\\n2. Second is to use two pointers,  have two pointers starting from start and let them move in opposite directions. Whenever we reach the target, this is closest to start.\\n\\nCode for 2nd approach:\\n\\n```\\nint getMinDistance(vector<int>& nums, int target, int start) {\\n        int i = start, j = start;\\n        \\n        while(i >= 0 or j <= nums.size()-1) {\\n            if(i >= 0 and nums[i] == target) break;\\n            if(j <= nums.size() - 1 and nums[j] == target) break;\\n            \\n            j++;\\n            i--;\\n        }\\n        \\n        if(i >= 0 and nums[i] == target) {\\n            return abs(start - i);\\n        }\\n        \\n        return abs(start - j);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint getMinDistance(vector<int>& nums, int target, int start) {\\n        int i = start, j = start;\\n        \\n        while(i >= 0 or j <= nums.size()-1) {\\n            if(i >= 0 and nums[i] == target) break;\\n            if(j <= nums.size() - 1 and nums[j] == target) break;\\n            \\n            j++;\\n            i--;\\n        }\\n        \\n        if(i >= 0 and nums[i] == target) {\\n            return abs(start - i);\\n        }\\n        \\n        return abs(start - j);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187372,
                "title": "java-array-beats-100-0ms-t-c-o-n-s-c-o-1",
                "content": "\\n    // O(nums.length) O(1)\\n\\tpublic int getMinDistance(int[] nums, int target, int start) {\\n\\n\\t\\tint min = Integer.MAX_VALUE, len = nums.length;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] == target) {\\n\\t\\t\\t\\tif (Math.abs(i - start) < min)\\n\\t\\t\\t\\t\\tmin = Math.abs(i - start);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(nums.length) O(1)\\n\\tpublic int getMinDistance(int[] nums, int target, int start) {\\n\\n\\t\\tint min = Integer.MAX_VALUE, len = nums.length;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] == target) {\\n\\t\\t\\t\\tif (Math.abs(i - start) < min)\\n\\t\\t\\t\\t\\tmin = Math.abs(i - start);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1188573,
                "title": "java-o-n-solution-using-stream",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        return IntStream.range(0, nums.length)\\n            .filter(i -> nums[i] == target)\\n            .map(i -> Math.abs(i - start))\\n            .min()\\n            .getAsInt();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        return IntStream.range(0, nums.length)\\n            .filter(i -> nums[i] == target)\\n            .map(i -> Math.abs(i - start))\\n            .min()\\n            .getAsInt();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186919,
                "title": "python-easy-to-undersand",
                "content": "Just in case, this code may be explained well for beginners.\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        a = []\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                 a.append(abs(start-i))\\n        return min(a)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        a = []\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                 a.append(abs(start-i))\\n        return min(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262476,
                "title": "c-one-pass-4-lines-of-code-only",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target) ans=min(ans,abs(start-i));\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target) ans=min(ans,abs(start-i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2965311,
                "title": "java-easy-solution-3-line-code",
                "content": "please upvote, if you like it.Thak you\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] array, int target, int start) {\\n        int store = Integer.MAX_VALUE, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < array.length; i++) {\\n            if (array[i] == target) store = i;\\n            min = Math.min(min, Math.abs(store - start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] array, int target, int start) {\\n        int store = Integer.MAX_VALUE, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < array.length; i++) {\\n            if (array[i] == target) store = i;\\n            min = Math.min(min, Math.abs(store - start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204659,
                "title": "python3-simple-solution-beats-90-users",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target:return 0\\n        i, j = start-1, start+1\\n        while j < len(nums) or i > -1:\\n            if i > -1:\\n                if nums[i] == target:\\n                    return start-i\\n                i -= 1\\n            if j < len(nums):\\n                if nums[j] == target:\\n                    return j-start\\n                j += 1\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target:return 0\\n        i, j = start-1, start+1\\n        while j < len(nums) or i > -1:\\n            if i > -1:\\n                if nums[i] == target:\\n                    return start-i\\n                i -= 1\\n            if j < len(nums):\\n                if nums[j] == target:\\n                    return j-start\\n                j += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186800,
                "title": "python-2-simple-solutions-faster-than-100",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res.append(abs(i - start))\\n        return min(res)\\n```\\n\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = sys.maxsize\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res = min(res,(abs(i - start)))\\n        return res\\n```\\n\\n![image](https://assets.leetcode.com/users/images/407ccaaa-0b71-4b0f-a453-34a0a54e68bb_1619928523.5857952.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res.append(abs(i - start))\\n        return min(res)\\n```\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = sys.maxsize\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res = min(res,(abs(i - start)))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669607,
                "title": "100-beats-best-java-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n     int n = nums.length;\\n     int min = Integer.MAX_VALUE;\\n     for(int i=0;i<n;i++){\\n         if(nums[i]==target){\\n          if(Math.abs(i-start)<min){\\n              min = Math.abs(i-start);\\n          }   \\n         }\\n     }\\n     return min;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n     int n = nums.length;\\n     int min = Integer.MAX_VALUE;\\n     for(int i=0;i<n;i++){\\n         if(nums[i]==target){\\n          if(Math.abs(i-start)<min){\\n              min = Math.abs(i-start);\\n          }   \\n         }\\n     }\\n     return min;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914715,
                "title": "java-easy-peasy-solution",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                min = Math.min(min, Math.abs(i - start));\\n            }\\n        }\\n\\n        return min;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                min = Math.min(min, Math.abs(i - start));\\n            }\\n        }\\n\\n        return min;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825709,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int sum=nums.length-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n              sum=Math.min(sum,Math.abs(i-start));  \\n            }\\n        }\\n        return sum;\\n    }}\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int sum=nums.length-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n              sum=Math.min(sum,Math.abs(i-start));  \\n            }\\n        }\\n        return sum;\\n    }}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2705184,
                "title": "o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Number.POSITIVE_INFINITY;\\n    for(let i =0;i<nums.length;i++){\\n        if(nums[i]==target){\\n            min = Math.min(min,Math.abs(i-start))\\n        }\\n    }\\n   return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Number.POSITIVE_INFINITY;\\n    for(let i =0;i<nums.length;i++){\\n        if(nums[i]==target){\\n            min = Math.min(min,Math.abs(i-start))\\n        }\\n    }\\n   return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589037,
                "title": "with-explanation-comments-time-8-ms-63-78-space-9-5-mb-96-11",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        \\n        //initialize a variable with the largest possible value\\n        int res=INT_MAX;\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size();i++){\\n            //check if the current value equals to the target one\\n            if(nums[i]==target)\\n                //if yes-> compare and save the minumum valid number reached in the loop\\n                res=min(res, abs(i-start));\\n                \\n        }\\n        \\n        //return the min absolute value of the two variables\\n        return res;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        \\n        //initialize a variable with the largest possible value\\n        int res=INT_MAX;\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size();i++){\\n            //check if the current value equals to the target one\\n            if(nums[i]==target)\\n                //if yes-> compare and save the minumum valid number reached in the loop\\n                res=min(res, abs(i-start));\\n                \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1290930,
                "title": "python-for-beginners",
                "content": "\\t\\tclass Solution:\\n\\t\\t\\tdef getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n\\t\\t\\t\\treturn min(abs(i-start) for i,j in enumerate(nums) if nums[i]==target)",
                "solutionTags": [],
                "code": "\\t\\tclass Solution:\\n\\t\\t\\tdef getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n\\t\\t\\t\\treturn min(abs(i-start) for i,j in enumerate(nums) if nums[i]==target)",
                "codeTag": "Java"
            },
            {
                "id": 1200271,
                "title": "python-with-early-exit",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target: return 0\\n        left, right = start-1, start+1\\n        N = len(nums)\\n        while True:\\n            if left >=0 and nums[left] == target:\\n                return start - left\\n            if right < N and nums[right] == target:\\n                return right - start\\n            left -= 1\\n            right += 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target: return 0\\n        left, right = start-1, start+1\\n        N = len(nums)\\n        while True:\\n            if left >=0 and nums[left] == target:\\n                return start - left\\n            if right < N and nums[right] == target:\\n                return right - start\\n            left -= 1\\n            right += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188277,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let mut min_dist = std::i32::MAX;\\n        for (i, val) in nums.iter().enumerate() {\\n            if *val == target {\\n                min_dist = min_dist.min((i as i32 - start).abs());\\n                if min_dist == 0 {\\n                    break;\\n                }\\n            }\\n        }\\n        min_dist\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Enumeration"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let mut min_dist = std::i32::MAX;\\n        for (i, val) in nums.iter().enumerate() {\\n            if *val == target {\\n                min_dist = min_dist.min((i as i32 - start).abs());\\n                if min_dist == 0 {\\n                    break;\\n                }\\n            }\\n        }\\n        min_dist\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3653440,
                "title": "java-easy-solution-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere i have used basic concept.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++) {\\n           if(nums[i]==target){\\n               int ans=Math.abs(i-start);\\n               min=Math.min(ans,min);\\n           }\\n       }\\n       return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++) {\\n           if(nums[i]==target){\\n               int ans=Math.abs(i-start);\\n               min=Math.min(ans,min);\\n           }\\n       }\\n       return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596152,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        curVal=len(nums)\\n        for i in range(start,len(nums)):\\n            if nums[i]==target:\\n                curVal=min(curVal,abs(i-start))\\n                break\\n        j=start\\n        while(j>=0):\\n            if nums[j]==target:\\n                curVal=min(curVal,abs(j-start))\\n                break\\n            j-=1\\n        return curVal\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        curVal=len(nums)\\n        for i in range(start,len(nums)):\\n            if nums[i]==target:\\n                curVal=min(curVal,abs(i-start))\\n                break\\n        j=start\\n        while(j>=0):\\n            if nums[j]==target:\\n                curVal=min(curVal,abs(j-start))\\n                break\\n            j-=1\\n        return curVal\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516534,
                "title": "easy-c-solution-in-o-n-time-complexity",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the index of \\'target\\', then find the minimum value if target - start.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& a, int target, int start) {\\n        int e1 = -1;\\n        int dist = INT_MAX;\\n        \\n        for(int i = 0; i < a.size(); i++)\\n        {\\n            if(a[i] == target)\\n                e1 = i;    \\n            if(e1 != -1)\\n                if(abs(e1-start) < dist)\\n                    dist = abs(e1-start);\\n        }\\n        if(dist == INT_MAX)\\n            return -1;\\n        return dist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& a, int target, int start) {\\n        int e1 = -1;\\n        int dist = INT_MAX;\\n        \\n        for(int i = 0; i < a.size(); i++)\\n        {\\n            if(a[i] == target)\\n                e1 = i;    \\n            if(e1 != -1)\\n                if(abs(e1-start) < dist)\\n                    dist = abs(e1-start);\\n        }\\n        if(dist == INT_MAX)\\n            return -1;\\n        return dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413116,
                "title": "minimum-distance-to-the-target-element-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int i, min=INT_MAX;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==target && abs(i-start)<min)\\n            {\\n                min = abs(i-start);\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int i, min=INT_MAX;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==target && abs(i-start)<min)\\n            {\\n                min = abs(i-start);\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223288,
                "title": "java-runtime-0-ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int index = nums.length;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                index = Math.min(index,Math.abs(i-start));\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int index = nums.length;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                index = Math.min(index,Math.abs(i-start));\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972643,
                "title": "fast-easy-js-solution",
                "content": "```\\nvar getMinDistance = function(nums, target, start) {\\n  let dif;\\n\\n  nums\\n    .map((num) => (num == target ? num : null))\\n    .forEach((el, i) => {\\n      if (el !== null) {\\n        const currDif = Math.abs(i - start);\\n\\n        if (dif == undefined) {\\n          dif = currDif;\\n        } else if (currDif < dif) {\\n          dif = currDif;\\n        }\\n      }\\n    });\\n\\n  return dif;  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinDistance = function(nums, target, start) {\\n  let dif;\\n\\n  nums\\n    .map((num) => (num == target ? num : null))\\n    .forEach((el, i) => {\\n      if (el !== null) {\\n        const currDif = Math.abs(i - start);\\n\\n        if (dif == undefined) {\\n          dif = currDif;\\n        } else if (currDif < dif) {\\n          dif = currDif;\\n        }\\n      }\\n    });\\n\\n  return dif;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2823504,
                "title": "easy-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n   let left = 0;\\n   let right = 0;\\n   for(let i = start; i>=0; i--){\\n     if(nums[i]===target){\\n       left  = Math.abs(i-start);\\n       break\\n     } else{\\n       left = nums.length;\\n     }\\n   }\\n    for(let i = start; i<nums.length; i++){\\n     if(nums[i]===target){\\n       right  = Math.abs(i-start);\\n       break\\n     } else{\\n       right = nums.length;\\n     }\\n   }  \\n   return left>right ? right : left;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n   let left = 0;\\n   let right = 0;\\n   for(let i = start; i>=0; i--){\\n     if(nums[i]===target){\\n       left  = Math.abs(i-start);\\n       break\\n     } else{\\n       left = nums.length;\\n     }\\n   }\\n    for(let i = start; i<nums.length; i++){\\n     if(nums[i]===target){\\n       right  = Math.abs(i-start);\\n       break\\n     } else{\\n       right = nums.length;\\n     }\\n   }  \\n   return left>right ? right : left;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2821922,
                "title": "java-beats-100-simple-easy",
                "content": "\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int minDistance = Integer.MAX_VALUE;\\n        for(int i=start; i>=0; i--){\\n            if(nums[i] == target){\\n                minDistance = start - i;\\n                break;\\n            }\\n        }\\n        for(int i=start+1; i<nums.length; i++){\\n            if(nums[i] == target){\\n                minDistance = Math.min(minDistance, i-start);\\n                break;\\n            }\\n        }\\n        return minDistance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int minDistance = Integer.MAX_VALUE;\\n        for(int i=start; i>=0; i--){\\n            if(nums[i] == target){\\n                minDistance = start - i;\\n                break;\\n            }\\n        }\\n        for(int i=start+1; i<nums.length; i++){\\n            if(nums[i] == target){\\n                minDistance = Math.min(minDistance, i-start);\\n                break;\\n            }\\n        }\\n        return minDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626508,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int t=start;\\n        int ans;\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                ans=Math.abs(i-t);\\n                if(ans<min){\\n                    min=ans;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int t=start;\\n        int ans;\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                ans=Math.abs(i-t);\\n                if(ans<min){\\n                    min=ans;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551734,
                "title": "short-javascript-solution",
                "content": "```\\nvar getMinDistance = function (nums, target, start) {\\n    let min = Infinity\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === target && Math.abs(i - start) < min) {\\n            min = Math.abs(i - start)\\n        }\\n    }\\n\\t\\n    return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinDistance = function (nums, target, start) {\\n    let min = Infinity\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === target && Math.abs(i - start) < min) {\\n            min = Math.abs(i - start)\\n        }\\n    }\\n\\t\\n    return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2521585,
                "title": "python-minimum-distance-to-the-target-element-easy-understanding",
                "content": "```\\nclass Solution(object):\\n    def getMinDistance(self, nums, target, start):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :type start: int\\n        :rtype: int\\n        \"\"\"\\n        index = 0\\n        result = []\\n        while index < len(nums):\\n            if nums[index] == target:\\n                result.append(abs(index - start))\\n            index += 1\\n        \\n        return min(result)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getMinDistance(self, nums, target, start):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :type start: int\\n        :rtype: int\\n        \"\"\"\\n        index = 0\\n        result = []\\n        while index < len(nums):\\n            if nums[index] == target:\\n                result.append(abs(index - start))\\n            index += 1\\n        \\n        return min(result)",
                "codeTag": "Java"
            },
            {
                "id": 2215549,
                "title": "c-2-lines-of-code-short-clean",
                "content": "![image](https://assets.leetcode.com/users/images/d3cf85cf-076a-4762-9722-d583db8daaae_1656541049.452096.png)\\n\\n**T->O(N) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint getMinDistance(vector<int>& nums, int t, int s) {\\n\\t\\t\\tint ans=INT_MAX;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i]==t) ans=min(ans,abs(i-s));\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint getMinDistance(vector<int>& nums, int t, int s) {\\n\\t\\t\\tint ans=INT_MAX;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i]==t) ans=min(ans,abs(i-s));\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1938581,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=1001;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n                min=Math.min(Math.abs(i-start),min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=1001;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n                min=Math.min(Math.abs(i-start),min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831075,
                "title": "o-n-java-simple-beats-100",
                "content": "We will do a two pointer approach, where the `left` and `right` pointer will be initialized to `start` index and we will move our two pointers in opposite direction to find the `target` as soon as we found the target we will just return the required result.\\n\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int left = start;\\n        int right = start;\\n        \\n        while(left >= 0 || right < nums.length){\\n            if(left >= 0 && nums[left] == target)\\n                return Math.abs(left - start);\\n            \\n            if(right < nums.length && nums[right] == target)\\n                return Math.abs(right - start);\\n            \\n            left--;\\n            right++;\\n        }\\n    \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int left = start;\\n        int right = start;\\n        \\n        while(left >= 0 || right < nums.length){\\n            if(left >= 0 && nums[left] == target)\\n                return Math.abs(left - start);\\n            \\n            if(right < nums.length && nums[right] == target)\\n                return Math.abs(right - start);\\n            \\n            left--;\\n            right++;\\n        }\\n    \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1813450,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        \\n        int i=0;\\n        int result=INT_MAX;\\n        \\n        while(i<nums.size())\\n        {\\n            if(nums[i]==target)\\n            {\\n                result=min(result,abs(i-start));\\n                \\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        \\n        int i=0;\\n        int result=INT_MAX;\\n        \\n        while(i<nums.size())\\n        {\\n            if(nums[i]==target)\\n            {\\n                result=min(result,abs(i-start));\\n                \\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772913,
                "title": "easy-solution",
                "content": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n  int res = INT_MAX;\\n    for (int i = 0; i < nums.size() && res > abs(start - i); ++i)\\n        if (nums[i] == target)\\n            res = abs(start - i);\\n    return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n  int res = INT_MAX;\\n    for (int i = 0; i < nums.size() && res > abs(start - i); ++i)\\n        if (nums[i] == target)\\n            res = abs(start - i);\\n    return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1687685,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        if (target == nums[start]) return 0;\\n        int minDis = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target)\\n                minDis = Math.min(minDis, Math.abs(i - start));\\n        }\\n        return minDis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        if (target == nums[start]) return 0;\\n        int minDis = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target)\\n                minDis = Math.min(minDis, Math.abs(i - start));\\n        }\\n        return minDis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637535,
                "title": "java-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target) ans=Math.min(ans,Math.abs(i-start));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target) ans=Math.min(ans,Math.abs(i-start));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596373,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return functools.reduce(lambda a, b: min(a, abs(b[0] - start)) if (b[1] == target) else a, enumerate(nums), float(\\'inf\\'))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return functools.reduce(lambda a, b: min(a, abs(b[0] - start)) if (b[1] == target) else a, enumerate(nums), float(\\'inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584649,
                "title": "python-sol-faster-than-99",
                "content": "![image](https://assets.leetcode.com/users/images/76662b9f-96ad-4fdd-aa44-c0fa3e4b438b_1637237611.385875.png)\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target:\\n            return 0\\n        i = start\\n        j = start\\n        left = 0\\n        right = 0\\n        \\n        while i < len(nums) or j > 0 :\\n            if nums[i] == target :\\n                \\n                return abs(i - start)\\n            if nums[j] == target:\\n                return abs(start - j)\\n            if i != len(nums) - 1:\\n                i += 1\\n            if j != 0 :\\n                j -= 1\\n        return\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target:\\n            return 0\\n        i = start\\n        j = start\\n        left = 0\\n        right = 0\\n        \\n        while i < len(nums) or j > 0 :\\n            if nums[i] == target :\\n                \\n                return abs(i - start)\\n            if nums[j] == target:\\n                return abs(start - j)\\n            if i != len(nums) - 1:\\n                i += 1\\n            if j != 0 :\\n                j -= 1\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538304,
                "title": "c-o-n-t-c-90-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n          int left=start;\\n           int right=start+1;\\n          while(left>=0){\\n              if(nums[left]==target) break;\\n              left--;\\n          }\\n        while(right<nums.size()){\\n            if(nums[right]==target) break;\\n            right++;\\n        }\\n          if(left<0 && right<nums.size()) return abs(right-start);\\n        else if(left>=0 && right>=nums.size()) return abs(left-start);\\n        return min(abs(left-start),abs(right-start));\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n          int left=start;\\n           int right=start+1;\\n          while(left>=0){\\n              if(nums[left]==target) break;\\n              left--;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1490609,
                "title": "c-easy-solution-using-only-loops-6-line-code",
                "content": "```\\n// PLEASE UPVOTE IF YOU LIKE THE SOLUTION!!\\nclass Solution \\n{\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) \\n    {\\n        vector<int> l;\\n        int k=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n            {\\n                \\n                k=abs(i-start);\\n                l.push_back(k);// PUSH ALL THE VALUE SO THAT WE CAN FIND MINIMUM ONE\\n                \\n            }}\\n        sort(l.begin(),l.end());//SORTING\\n        \\n        return l[0];\\n    }\\n    \\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution \\n{\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) \\n    {\\n        vector<int> l;\\n        int k=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n            {\\n                \\n                k=abs(i-start);\\n                l.push_back(k);// PUSH ALL THE VALUE SO THAT WE CAN FIND MINIMUM ONE\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1459507,
                "title": "c-solution-o-n-time-complexity-and-o-1-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& a, int t, int s) {\\n        int n=a.size();\\n        int c=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==t)\\n            {\\n                if(abs(i-s)<c)\\n                    c=abs(i-s);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& a, int t, int s) {\\n        int n=a.size();\\n        int c=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==t)\\n            {\\n                if(abs(i-s)<c)\\n                    c=abs(i-s);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433500,
                "title": "c-easy-solution-2-pointer-approach",
                "content": "```\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini= INT_MAX;\\n        int st= 0;\\n        int end= nums.size()-1;\\n        \\n        while(st<=end)\\n        {\\n            if(nums[st] == target) {\\n                mini= min(mini, abs(st-start)); \\n                st++;\\n            }\\n            else if(nums[end] == target) {\\n                mini= min(mini, abs(end-start)); \\n                end--;\\n            }\\n            else {\\n                st++;   end--;\\n            }\\n        }\\n        return mini;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini= INT_MAX;\\n        int st= 0;\\n        int end= nums.size()-1;\\n        \\n        while(st<=end)\\n        {\\n            if(nums[st] == target) {\\n                mini= min(mini, abs(st-start)); \\n                st++;\\n            }\\n            else if(nums[end] == target) {\\n                mini= min(mini, abs(end-start)); \\n                end--;\\n            }\\n            else {\\n                st++;   end--;\\n            }\\n        }\\n        return mini;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428868,
                "title": "c-easy-to-understand-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n                mn=min(mn, abs(i-start));\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n                mn=min(mn, abs(i-start));\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397435,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int getMinDistance(int[] n, int t, int s) {\\n        int i,j,c=Integer.MAX_VALUE,k=0;\\n        for(i=s;i<n.length;i++)\\n        {\\n            if(n[i]==t)\\n            {\\n                k=Math.abs(i-s);\\n                c=Math.min(c,k);\\n            }\\n        }\\n        {\\n            for(i=s;i>=0;i--)\\n            {\\n               if(n[i]==t)\\n               {\\n                   k=Math.abs(i-s);\\n                   c=Math.min(c,k);\\n               }\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int getMinDistance(int[] n, int t, int s) {\\n        int i,j,c=Integer.MAX_VALUE,k=0;\\n        for(i=s;i<n.length;i++)\\n        {\\n            if(n[i]==t)\\n            {\\n                k=Math.abs(i-s);\\n                c=Math.min(c,k);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1388775,
                "title": "faster-than-92-05-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn = INT_MAX,n = nums.size();\\n        for(int i = 0 ; i <n;i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                if(mn > abs(i-start))\\n                    mn = abs(i-start);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn = INT_MAX,n = nums.size();\\n        for(int i = 0 ; i <n;i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                if(mn > abs(i-start))\\n                    mn = abs(i-start);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297195,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        l = r = start\\n        while 1:\\n            if l>=0:\\n                if nums[l]==target:\\n                    return start - l\\n                l-=1\\n            if r<len(nums):\\n                if nums[r]==target:\\n                    return r - start\\n                r+=1\\n            \\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        l = r = start\\n        while 1:\\n            if l>=0:\\n                if nums[l]==target:\\n                    return start - l\\n                l-=1\\n            if r<len(nums):\\n                if nums[r]==target:\\n                    return r - start\\n                r+=1\\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294967,
                "title": "simple",
                "content": "guys if you find solution usefull \\ndo upvote\\nand feel free to ask in the comment\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int minn=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n             minn=min(minn,abs(i-start));   \\n            }\\n        return minn;\\n        }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int minn=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n             minn=min(minn,abs(i-start));   \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1283284,
                "title": "optimum-solution-java-version",
                "content": "```java\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int left = start, right = start, leftFirstDiff = Integer.MAX_VALUE, rightFirstDiff =  Integer.MAX_VALUE;\\n        boolean leftContinue= true, rightContinue = true;\\n        while(left >= 0 && leftContinue){\\n            if(nums[left] == target){\\n                leftContinue = false;\\n                leftFirstDiff = Math.abs(left - start);\\n            }\\n            left--;\\n        }\\n        while(right < nums.length && rightContinue){\\n            if(nums[right] == target){\\n                rightContinue = false;\\n                rightFirstDiff = Math.abs(right - start);\\n            }\\n            right++;\\n        }\\n        return Math.min(leftFirstDiff, rightFirstDiff);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int left = start, right = start, leftFirstDiff = Integer.MAX_VALUE, rightFirstDiff =  Integer.MAX_VALUE;\\n        boolean leftContinue= true, rightContinue = true;\\n        while(left >= 0 && leftContinue){\\n            if(nums[left] == target){\\n                leftContinue = false;\\n                leftFirstDiff = Math.abs(left - start);\\n            }\\n            left--;\\n        }\\n        while(right < nums.length && rightContinue){\\n            if(nums[right] == target){\\n                rightContinue = false;\\n                rightFirstDiff = Math.abs(right - start);\\n            }\\n            right++;\\n        }\\n        return Math.min(leftFirstDiff, rightFirstDiff);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277810,
                "title": "runtime-64-ms-faster-than-100-00-of-javascript-online-submissions",
                "content": "#### [](http://)Runtime: 64 ms, faster than 100.00% of JavaScript online submissions for Minimum Distance to the Target Element.\\n```\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Infinity;\\n    for(let i=nums.indexOf(target);i<nums.length;i++){\\n        if(nums[i]===target){\\n            if(Math.abs(i-start)<min) min = Math.abs(i-start);\\n        }\\n    }\\n    return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Infinity;\\n    for(let i=nums.indexOf(target);i<nums.length;i++){\\n        if(nums[i]===target){\\n            if(Math.abs(i-start)<min) min = Math.abs(i-start);\\n        }\\n    }\\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1255146,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(target==nums[i])\\n            {   \\n                min=Math.min(min,Math.abs(i-start));\\n            }  \\n        }   \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(target==nums[i])\\n            {   \\n                min=Math.min(min,Math.abs(i-start));\\n            }  \\n        }   \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242840,
                "title": "two-pointer-approach-cpp-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int i=start,j=start+1;\\n        int ans=INT_MAX;\\n        int n=nums.size();\\n        while(i>=0 || j<n){\\n            if(i>=0){\\n                if(nums[i]==target && ans>abs(i-start)){\\n                    return abs(i-start);\\n                }\\n            }\\n            if(j<n){\\n                if(nums[j]==target && ans>abs(j-start)){\\n                    return abs(j-start);\\n                }\\n            }\\n            i--;j++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int i=start,j=start+1;\\n        int ans=INT_MAX;\\n        int n=nums.size();\\n        while(i>=0 || j<n){\\n            if(i>=0){\\n                if(nums[i]==target && ans>abs(i-start)){\\n                    return abs(i-start);\\n                }\\n            }\\n            if(j<n){\\n                if(nums[j]==target && ans>abs(j-start)){\\n                    return abs(j-start);\\n                }\\n            }\\n            i--;j++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234711,
                "title": "rust-linear-scan-to-high-low-pointers",
                "content": "\\n\\n<b>Problem List</b>\\n#High-LowPointers - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_technique/n_pointers/by_pointer_amount/high_low_pointers.txt)\\n#LinearScan - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_technique/n_pointers/by_pointer_amount/linear_scan)\\n\\nHigh-Low Pointers Approach\\n\\n```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let len_n: i32 = nums.len() as i32;\\n        \\n        let mut lo: i32 = start;\\n        let mut hi: i32 = start;\\n        while lo >= 0 || hi < len_n{\\n            if lo >= 0 {\\n                if nums[lo as usize] == target{\\n                    return start - lo;\\n                }\\n                \\n                lo -= 1;\\n            }\\n            \\n            if hi < len_n{\\n                if nums[hi as usize] == target{\\n                    return hi - start;\\n                }\\n                \\n                hi += 1;\\n            }\\n        }\\n        \\n        unreachable!()\\n    }\\n}\\n```\\n\\nLinear Scan Approach:\\n```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let len_n: i32 = nums.len() as i32;\\n        let mut min_dis: i32 = len_n;\\n        \\n        for (idx, num) in nums.into_iter().enumerate(){\\n            if num == target{\\n                min_dis = std::cmp::min(min_dis,\\n                (start - idx as i32).abs());\\n            }\\n        };\\n        \\n        min_dis\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let len_n: i32 = nums.len() as i32;\\n        \\n        let mut lo: i32 = start;\\n        let mut hi: i32 = start;\\n        while lo >= 0 || hi < len_n{\\n            if lo >= 0 {\\n                if nums[lo as usize] == target{\\n                    return start - lo;\\n                }\\n                \\n                lo -= 1;\\n            }\\n            \\n            if hi < len_n{\\n                if nums[hi as usize] == target{\\n                    return hi - start;\\n                }\\n                \\n                hi += 1;\\n            }\\n        }\\n        \\n        unreachable!()\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let len_n: i32 = nums.len() as i32;\\n        let mut min_dis: i32 = len_n;\\n        \\n        for (idx, num) in nums.into_iter().enumerate(){\\n            if num == target{\\n                min_dis = std::cmp::min(min_dis,\\n                (start - idx as i32).abs());\\n            }\\n        };\\n        \\n        min_dis\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1220487,
                "title": "easy-to-understand-c-code-by-archit-garg",
                "content": "\\n\\nint getMinDistance(int* nums, int numsSize, int target, int start){\\n    int ans=INT_MAX;\\n        for(int i=0;i<numsSize && ans > abs(start-i);++i)\\n        {\\n            if(nums[i]==target)\\n            {\\n                ans= abs(start-i);\\n            }\\n        }\\n    return ans;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\nint getMinDistance(int* nums, int numsSize, int target, int start){\\n    int ans=INT_MAX;\\n        for(int i=0;i<numsSize && ans > abs(start-i);++i)\\n        {\\n            if(nums[i]==target)\\n            {\\n                ans= abs(start-i);\\n            }\\n        }\\n    return ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1218972,
                "title": "java-two-pointer",
                "content": "```\\npublic int getMinDistance(int[] nums, int target, int start) {\\n        \\n        /* Initialise two pointers Left (L) and Right (R) both to begin at start*/\\n        int n = nums.length -1;\\n        int L = start;\\n        int R = start;\\n        \\n        /* We need to find the minimum dist from start either on left or right of start.\\n\\t\\t * Loop to find the if the closest element is target such that the difference of the target \\n\\t\\t * index and start is minimum\\n         */\\n        while( L >= 0 || R <= n){\\n            if(L >= 0 && nums[L] == target) {\\n                return start - L;\\n            } \\n            if(R <= n && nums[R] == target){\\n                return R - start;\\n            }\\n            L--;\\n            R++;\\n        }\\n        \\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getMinDistance(int[] nums, int target, int start) {\\n        \\n        /* Initialise two pointers Left (L) and Right (R) both to begin at start*/\\n        int n = nums.length -1;\\n        int L = start;\\n        int R = start;\\n        \\n        /* We need to find the minimum dist from start either on left or right of start.\\n\\t\\t * Loop to find the if the closest element is target such that the difference of the target \\n\\t\\t * index and start is minimum\\n         */\\n        while( L >= 0 || R <= n){\\n            if(L >= 0 && nums[L] == target) {\\n                return start - L;\\n            } \\n            if(R <= n && nums[R] == target){\\n                return R - start;\\n            }\\n            L--;\\n            R++;\\n        }\\n        \\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1216412,
                "title": "0ms-java-solution",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for (int i = start; i < nums.length; i++){\\n            if (nums[i] == target)\\n                min = Math.min(min, Math.abs(i-start));\\n        }\\n        for (int i = start; i >= 0; i--){\\n            if (nums[i] == target)\\n                min = Math.min(min, Math.abs(i-start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for (int i = start; i < nums.length; i++){\\n            if (nums[i] == target)\\n                min = Math.min(min, Math.abs(i-start));\\n        }\\n        for (int i = start; i >= 0; i--){\\n            if (nums[i] == target)\\n                min = Math.min(min, Math.abs(i-start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214397,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    var min = Infinity;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i] === target){\\n            var diff = Math.abs(i - start);\\n            if(min > diff){\\n                min = diff\\n            }\\n        }\\n    }\\n    return min\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    var min = Infinity;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i] === target){\\n            var diff = Math.abs(i - start);\\n            if(min > diff){\\n                min = diff\\n            }\\n        }\\n    }\\n    return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195213,
                "title": "a-few-solutions",
                "content": "*Kotlin*\\n```\\nclass Solution {\\n    fun getMinDistance(A: IntArray, T: Int, K: Int): Int {\\n        return A.mapIndexed{ i, _ -> if (A[i] == T) Math.abs(i - K) else (1e9 + 7).toInt() }.min()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet getMinDistance = (A, T, K) => Math.min(...A.map((_, i) => A[i] == T ? Math.abs(i - K) : Infinity));\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def getMinDistance(self, A: List[int], T: int, K: int) -> int:\\n        return min(abs(i - K) for i in range(len(A)) if A[i] == T)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int getMinDistance(VI& A, int T, int K, VI B = {}) {\\n        transform(A.begin(), A.end(), back_inserter(B), [&A, T, K, i = -1](auto _) mutable {\\n            return A[++i] == T ? abs(i - K) : int(1e9 + 7);\\n        });\\n        return *min_element(B.begin(), B.end());\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun getMinDistance(A: IntArray, T: Int, K: Int): Int {\\n        return A.mapIndexed{ i, _ -> if (A[i] == T) Math.abs(i - K) else (1e9 + 7).toInt() }.min()!!\\n    }\\n}\\n```\n```\\nlet getMinDistance = (A, T, K) => Math.min(...A.map((_, i) => A[i] == T ? Math.abs(i - K) : Infinity));\\n```\n```\\nclass Solution:\\n    def getMinDistance(self, A: List[int], T: int, K: int) -> int:\\n        return min(abs(i - K) for i in range(len(A)) if A[i] == T)\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int getMinDistance(VI& A, int T, int K, VI B = {}) {\\n        transform(A.begin(), A.end(), back_inserter(B), [&A, T, K, i = -1](auto _) mutable {\\n            return A[++i] == T ? abs(i - K) : int(1e9 + 7);\\n        });\\n        return *min_element(B.begin(), B.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191675,
                "title": "c-4ms-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:  \\n    \\n    vector<int> Ind(vector<int> V, int val){\\n        // O(n) function\\n        vector<int> indi;\\n        \\n        for(int i{0}; i<V.size(); ++i){\\n            if(V[i] == val)\\n                indi.push_back(i);\\n        }\\n        return indi;\\n    }\\n    \\n    \\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans;\\n        vector<int> index = Ind(nums, target);\\n        for(auto &i : index) i = abs(i-start);\\n        ans = *min_element(index.begin(), index.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:  \\n    \\n    vector<int> Ind(vector<int> V, int val){\\n        // O(n) function\\n        vector<int> indi;\\n        \\n        for(int i{0}; i<V.size(); ++i){\\n            if(V[i] == val)\\n                indi.push_back(i);\\n        }\\n        return indi;\\n    }\\n    \\n    \\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans;\\n        vector<int> index = Ind(nums, target);\\n        for(auto &i : index) i = abs(i-start);\\n        ans = *min_element(index.begin(), index.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191643,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return min([abs(i-start) for i in range(len(nums)) if nums[i]==target]) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return min([abs(i-start) for i in range(len(nums)) if nums[i]==target]) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189619,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func getMinDistance(_ nums: [Int], _ target: Int, _ start: Int) -> Int {\\n        let c = nums.count\\n        for i in 0...max(start, c - 1 - start) {\\n            let left = start - i, right = start + i\\n            if left >= 0 && nums[left] == target || right < c && nums[right] == target {\\n                return i\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getMinDistance(_ nums: [Int], _ target: Int, _ start: Int) -> Int {\\n        let c = nums.count\\n        for i in 0...max(start, c - 1 - start) {\\n            let left = start - i, right = start + i\\n            if left >= 0 && nums[left] == target || right < c && nums[right] == target {\\n                return i\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189571,
                "title": "faster-than-100-00",
                "content": "```\\nvar getMinDistance = function(nums, target, start) {\\n  let output = null\\n    for(let i = 0; i < nums.length; i++) {\\n      if(nums[i] === target) {\\n        if(output === null || output > Math.abs(start - i)) { //only storing the **minimized** value\\n          output = Math.abs(start - i)\\n        }\\n      }\\n    }\\n    return output\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinDistance = function(nums, target, start) {\\n  let output = null\\n    for(let i = 0; i < nums.length; i++) {\\n      if(nums[i] === target) {\\n        if(output === null || output > Math.abs(start - i)) { //only storing the **minimized** value\\n          output = Math.abs(start - i)\\n        }\\n      }\\n    }\\n    return output\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1188162,
                "title": "javascript-one-pass",
                "content": "```\\nconst getMinDistance = (nums, target, start) => {\\n    let ans = 1000;\\n    for (let i = 0; i < nums.length; i++)\\n        if (nums[i] == target)\\n            ans = Math.min(ans, Math.abs(i - start));\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst getMinDistance = (nums, target, start) => {\\n    let ans = 1000;\\n    for (let i = 0; i < nums.length; i++)\\n        if (nums[i] == target)\\n            ans = Math.min(ans, Math.abs(i - start));\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187614,
                "title": "go-simple-solution",
                "content": "```\\nfunc getMinDistance(nums []int, target int, start int) int {\\n    ans := 100000\\n    for i, n := range(nums) {\\n        if n == target {\\n            diff := i - start\\n            if diff < 0 {\\n                diff = -diff\\n            }\\n            if diff < ans {\\n                ans = diff\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getMinDistance(nums []int, target int, start int) int {\\n    ans := 100000\\n    for i, n := range(nums) {\\n        if n == target {\\n            diff := i - start\\n            if diff < 0 {\\n                diff = -diff\\n            }\\n            if diff < ans {\\n                ans = diff\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187500,
                "title": "python-3-simple-solution",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        n = len(nums)\\n        f = start\\n        b = start\\n        idx = None\\n        while f < n or b >= 0:\\n            if f < n:\\n                if nums[f] == target:\\n                    idx = f\\n                    break\\n                f += 1\\n            if b >= 0:\\n                if nums[b] == target:\\n                    idx  = b\\n                    break\\n                b -= 1\\n        return abs(idx-start)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        n = len(nums)\\n        f = start\\n        b = start\\n        idx = None\\n        while f < n or b >= 0:\\n            if f < n:\\n                if nums[f] == target:\\n                    idx = f\\n                    break\\n                f += 1\\n            if b >= 0:\\n                if nums[b] == target:\\n                    idx  = b\\n                    break\\n                b -= 1\\n        return abs(idx-start)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186816,
                "title": "very-easy-one-pass-c-with-explanation",
                "content": "Time Complexity - O(N)\\nSpace Complexity - O(1)\\n\\n**Explanation**\\nInitialize ans variable with max value (INT_MAX)\\nIterate all values and check if it equals to target \\nIf it is equal to target update ans with min value between ans and abs(i-start)\\n\\n```\\nclass Solution {\\n   public:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = INT_MAX;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] == target) ans = min(abs(i - start), ans);\\n        return ans;\\n    }\\n};\\n```\\n\\nFeel free to ask any doubts and \\nIf you like the solution and explanation please **upvote** !!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = INT_MAX;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] == target) ans = min(abs(i - start), ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077026,
                "title": "easiest-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++) {\\n           if(nums[i]==target){\\n               int ans=Math.abs(i-start);\\n               min=Math.min(ans,min);\\n           }\\n       }\\n       return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++) {\\n           if(nums[i]==target){\\n               int ans=Math.abs(i-start);\\n               min=Math.min(ans,min);\\n           }\\n       }\\n       return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070431,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        dist = 0\\n        while True:\\n            if start - dist >= 0 and nums[start - dist] == target:\\n                return dist\\n            if start + dist < len(nums) and nums[start + dist] == target:\\n                return dist\\n            dist += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        dist = 0\\n        while True:\\n            if start - dist >= 0 and nums[start - dist] == target:\\n                return dist\\n            if start + dist < len(nums) and nums[start + dist] == target:\\n                return dist\\n            dist += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066542,
                "title": "python3-o-n-time-o-1-space-complexity-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBasic approach of finding min distance \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        min_dis = len(nums)\\n        for i in range(0,len(nums)):\\n            if nums[i] == target:\\n                min_dis = min(abs(i - start), min_dis)\\n        return min_dis\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        min_dis = len(nums)\\n        for i in range(0,len(nums)):\\n            if nums[i] == target:\\n                min_dis = min(abs(i - start), min_dis)\\n        return min_dis\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064536,
                "title": "basic-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int x=0;\\n        int min=32000;\\n        for (int i= 0;i<nums.length;i++){\\n            if (nums[i]==target){\\n                x=Math.abs(i-start);\\n                min=Math.min(x,min);\\n\\n            }\\n            \\n        }\\n     return min;  \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int x=0;\\n        int min=32000;\\n        for (int i= 0;i<nums.length;i++){\\n            if (nums[i]==target){\\n                x=Math.abs(i-start);\\n                min=Math.min(x,min);\\n\\n            }\\n            \\n        }\\n     return min;  \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059139,
                "title": "easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int  i = 0;\\n        while(start+i < nums.length || start-i >= 0){\\n            if(start+i < nums.length && nums[start+i] == target)\\n                return Math.abs(start-(start+i));\\n            if(start-i >= 0 && nums[start-i] == target)\\n                return Math.abs(start-(start-i));\\n            i++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int  i = 0;\\n        while(start+i < nums.length || start-i >= 0){\\n            if(start+i < nums.length && nums[start+i] == target)\\n                return Math.abs(start-(start+i));\\n            if(start-i >= 0 && nums[start-i] == target)\\n                return Math.abs(start-(start-i));\\n            i++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044167,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:    \\n        return min(abs(i-start) for i, n in enumerate(nums) if n == target)         \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:    \\n        return min(abs(i-start) for i, n in enumerate(nums) if n == target)         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040094,
                "title": "simple-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int GetMinDistance(int[] nums, int target, int start) {\\n        \\n        int currentResult = Int32.MaxValue;\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                if(currentResult > Math.Abs(i - start))\\n                    currentResult = Math.Abs(i-start);\\n            }\\n        }\\n        return currentResult;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int GetMinDistance(int[] nums, int target, int start) {\\n        \\n        int currentResult = Int32.MaxValue;\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                if(currentResult > Math.Abs(i - start))\\n                    currentResult = Math.Abs(i-start);\\n            }\\n        }\\n        return currentResult;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030828,
                "title": "easy-understand-solution-swift",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func getMinDistance(_ nums: [Int], _ target: Int, _ start: Int) -> Int {\\n        var result = [Int]()\\n        \\n        for (index, num) in nums.enumerated() {\\n            if num == target {\\n                result.append(abs(index - start))\\n            }\\n        }\\n        \\n        return result.min() ?? 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getMinDistance(_ nums: [Int], _ target: Int, _ start: Int) -> Int {\\n        var result = [Int]()\\n        \\n        for (index, num) in nums.enumerated() {\\n            if num == target {\\n                result.append(abs(index - start))\\n            }\\n        }\\n        \\n        return result.min() ?? 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012972,
                "title": "0ms-beats-100-00-of-users",
                "content": "# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int result = 100000;\\n        int i=0,j=nums.length-1;\\n        while(i<=j){\\n            if(nums[i] == target){\\n                result = Math.min(result, Math.abs(i-start));\\n            }\\n            if(nums[j] == target){\\n                result = Math.min(result, Math.abs(j-start));\\n            }\\n            i++;\\n            j--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int result = 100000;\\n        int i=0,j=nums.length-1;\\n        while(i<=j){\\n            if(nums[i] == target){\\n                result = Math.min(result, Math.abs(i-start));\\n            }\\n            if(nums[j] == target){\\n                result = Math.min(result, Math.abs(j-start));\\n            }\\n            i++;\\n            j--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998759,
                "title": "minimum-distance-to-target-element-python-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        mini = 9999\\n        n = len(nums)\\n        for i in range(0, n):\\n            if nums[i]==target and abs(i-start)<mini:\\n                mini = abs(i-start)\\n        if mini == 9999:\\n            return start\\n        return mini\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        mini = 9999\\n        n = len(nums)\\n        for i in range(0, n):\\n            if nums[i]==target and abs(i-start)<mini:\\n                mini = abs(i-start)\\n        if mini == 9999:\\n            return start\\n        return mini\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989939,
                "title": "easy-java-1ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n                list.add(Math.abs(i-start));\\n        }\\n        return Collections.min(list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n                list.add(Math.abs(i-start));\\n        }\\n        return Collections.min(list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988036,
                "title": "c-bherry-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==target){\\n                mn= min(abs(i - start), mn);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==target){\\n                mn= min(abs(i - start), mn);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986689,
                "title": "beats-100-python-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        listx=  []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                listx.append(i)\\n        return min(abs(i - start) for i in listx)\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        listx=  []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                listx.append(i)\\n        return min(abs(i - start) for i in listx)\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981603,
                "title": "c-simple-and-easy-solution",
                "content": "upvote if you like the solution\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                ans = min(ans , abs(i - start));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                ans = min(ans , abs(i - start));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976916,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-n-worst-case",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        target_i = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                target_i.append(i)\\n        \\n        min_val = float(\\'inf\\')\\n\\n        for i in target_i:\\n            min_val = min(min_val, abs(i-start))\\n\\n        return min_val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        target_i = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                target_i.append(i)\\n        \\n        min_val = float(\\'inf\\')\\n\\n        for i in target_i:\\n            min_val = min(min_val, abs(i-start))\\n\\n        return min_val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976065,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int output = Integer.MAX_VALUE;\\n        if (nums[start] == target) {\\n            return 0;\\n        }\\n        for (int i = start; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                output = Math.abs(i - start);\\n                if (output == 1) {\\n                    return output;\\n                }                \\n                i = nums.length - 1;\\n            }\\n            if (i == nums.length - 1) {\\n                for (int j = 0; j < start; j++) {\\n                    if (nums[j] == target) {\\n                        output = Math.min(output, Math.abs(j - start));\\n                        if (output == 1) {\\n                            return output;\\n                        }\\n                    }                 \\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int output = Integer.MAX_VALUE;\\n        if (nums[start] == target) {\\n            return 0;\\n        }\\n        for (int i = start; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                output = Math.abs(i - start);\\n                if (output == 1) {\\n                    return output;\\n                }                \\n                i = nums.length - 1;\\n            }\\n            if (i == nums.length - 1) {\\n                for (int j = 0; j < start; j++) {\\n                    if (nums[j] == target) {\\n                        output = Math.min(output, Math.abs(j - start));\\n                        if (output == 1) {\\n                            return output;\\n                        }\\n                    }                 \\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975194,
                "title": "easist-way-for-this-problem",
                "content": "```\\nvar getMinDistance = function (nums, target, start) {\\n  let min = nums.length;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === target && Math.abs(i - start) < min) {\\n      min = Math.abs(i - start);\\n    }\\n  }\\n  return min;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar getMinDistance = function (nums, target, start) {\\n  let min = nums.length;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === target && Math.abs(i - start) < min) {\\n      min = Math.abs(i - start);\\n    }\\n  }\\n  return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968037,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int x = 0;\\n        ArrayList<Integer>list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                x = Math.abs(i-start);\\n                list.add(x);\\n            }\\n        }\\n        Collections.sort(list);\\n        return list.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int x = 0;\\n        ArrayList<Integer>list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                x = Math.abs(i-start);\\n                list.add(x);\\n            }\\n        }\\n        Collections.sort(list);\\n        return list.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962480,
                "title": "python-simple-and-faster-98-o-n-space-o-1-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def getMinDistance(self, nums, target, start):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :type start: int\\n        :rtype: int\\n        \"\"\"\\n        res = -1\\n        for j, i in enumerate(nums):\\n            if i != target: continue\\n            temp = abs(j - start)\\n            if res == -1 or (res > -1 and temp < res):\\n                res = temp\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getMinDistance(self, nums, target, start):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :type start: int\\n        :rtype: int\\n        \"\"\"\\n        res = -1\\n        for j, i in enumerate(nums):\\n            if i != target: continue\\n            temp = abs(j - start)\\n            if res == -1 or (res > -1 and temp < res):\\n                res = temp\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942296,
                "title": "simple-3-line-code-tc-o-n-beats-100-00-of-users-with-java",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i] == target) ans = Math.min(Math.abs(i - start), ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i] == target) ans = Math.min(Math.abs(i - start), ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923204,
                "title": "java-solution-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                int abs=Math.abs(i-start);\\n                min=Math.min(min,abs);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                int abs=Math.abs(i-start);\\n                min=Math.min(min,abs);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915781,
                "title": "beats-100-in-runtime-c",
                "content": "# Intuition\\nCheck every elemet from the right of start, find the shortest distance.\\n\\nGo back to start, and do the same thing for elements to the left of start.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$: 1 iteration over the array total\\n\\n- Space complexity:\\n$$O(1)$$ Local variables have a single value, regardless of size\\n\\n# Code\\n```\\npublic class Solution {\\n    public int GetMinDistance(int[] nums, int target, int start) {\\n\\n        int direction = 1;\\n        int shortestRight = int.MaxValue;\\n        int shortestLeft = int.MaxValue;\\n\\n        for(int i = start; i >= 0; i += direction)\\n        {\\n            if(i == nums.Length)\\n            {\\n                i = start;\\n                direction *= -1;\\n                continue;\\n            }\\n\\n            if(nums[i] == target)\\n            {\\n                if(direction > 0)\\n                {\\n                    shortestRight = Math.Abs(i - start);\\n                    direction *= -1;\\n                    i = start;\\n                } \\n                else\\n                {\\n                    shortestLeft = Math.Abs(start - i); \\n                    break;\\n                } \\n            }\\n        }\\n\\n        return Math.Min(shortestRight, shortestLeft);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int GetMinDistance(int[] nums, int target, int start) {\\n\\n        int direction = 1;\\n        int shortestRight = int.MaxValue;\\n        int shortestLeft = int.MaxValue;\\n\\n        for(int i = start; i >= 0; i += direction)\\n        {\\n            if(i == nums.Length)\\n            {\\n                i = start;\\n                direction *= -1;\\n                continue;\\n            }\\n\\n            if(nums[i] == target)\\n            {\\n                if(direction > 0)\\n                {\\n                    shortestRight = Math.Abs(i - start);\\n                    direction *= -1;\\n                    i = start;\\n                } \\n                else\\n                {\\n                    shortestLeft = Math.Abs(start - i); \\n                    break;\\n                } \\n            }\\n        }\\n\\n        return Math.Min(shortestRight, shortestLeft);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909354,
                "title": "getmindistance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse a vector to store all the indexes of occurence of target.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        vector<int> v;\\n       \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target){v.push_back(i);}\\n        }\\n        int min=INT_MAX;\\n        for(auto i:v)\\n        {\\n            if(abs(i-start)<min)min=abs(i-start);\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        vector<int> v;\\n       \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target){v.push_back(i);}\\n        }\\n        int min=INT_MAX;\\n        for(auto i:v)\\n        {\\n            if(abs(i-start)<min)min=abs(i-start);\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885790,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n = nums.length, min = 99000000;\\n\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] == target)\\n                min = Math.min(min, Math.abs(i - start));\\n            \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n = nums.length, min = 99000000;\\n\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] == target)\\n                min = Math.min(min, Math.abs(i - start));\\n            \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884266,
                "title": "minimum-distance-to-the-target-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                min = Math.min(min,Math.abs(i-start));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                min = Math.min(min,Math.abs(i-start));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858173,
                "title": "minimum-distance-to-the-target-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) \\n    {\\n        int n=nums.size();\\n        int res=INT_MAX;\\n        for(int i=0;i<n; i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                int cnt= abs(i-start);\\n                res=min(cnt,res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) \\n    {\\n        int n=nums.size();\\n        int res=INT_MAX;\\n        for(int i=0;i<n; i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                int cnt= abs(i-start);\\n                res=min(cnt,res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850790,
                "title": "js-simple-solution-faster-than-100",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = nums.length\\n\\n    for (let i = 0; i < nums.length; i++) if (nums[i] == target && Math.abs(i - start) < min) min = Math.abs(i - start)\\n\\n    return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = nums.length\\n\\n    for (let i = 0; i < nums.length; i++) if (nums[i] == target && Math.abs(i - start) < min) min = Math.abs(i - start)\\n\\n    return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3849736,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        vector<int> v;\\n        int ans;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == target)ans = abs(i-start);\\n            v.push_back(ans);\\n        }\\n        sort(v.begin(), v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        vector<int> v;\\n        int ans;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == target)ans = abs(i-start);\\n            v.push_back(ans);\\n        }\\n        sort(v.begin(), v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841825,
                "title": "easy-0ms-java-solution-beats-100-easypeasy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n=nums.length;\\n        int i,j;\\n        int a;\\n        int min=Integer.MAX_VALUE;\\n        for(i=0;i<=n-1;i++){\\n            if(nums[i]==target){\\n                a=Math.abs(i-start);\\n                if(a<min){\\n                    min=a;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n=nums.length;\\n        int i,j;\\n        int a;\\n        int min=Integer.MAX_VALUE;\\n        for(i=0;i<=n-1;i++){\\n            if(nums[i]==target){\\n                a=Math.abs(i-start);\\n                if(a<min){\\n                    min=a;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834521,
                "title": "easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == target) {\\n                ans = Math.min(Math.abs(i-start), ans);\\n            }\\n        }\\n        //upvote if helpful\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == target) {\\n                ans = Math.min(Math.abs(i-start), ans);\\n            }\\n        }\\n        //upvote if helpful\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820844,
                "title": "o-n-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: ```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n     int ans = INT_MAX;\\n     for(int i = 0; i < nums.size(); i++){\\n         if(nums[i] == target)\\n            ans = min(ans, abs(i-start));\\n     }\\n\\n\\n     return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```O(n)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n     int ans = INT_MAX;\\n     for(int i = 0; i < nums.size(); i++){\\n         if(nums[i] == target)\\n            ans = min(ans, abs(i-start));\\n     }\\n\\n\\n     return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818638,
                "title": "easy-solution-in-java-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] a, int t ,int s) {\\n         int m=Integer.MAX_VALUE;\\n         int n=a.length;\\n         for(int i=0;i<n;i++) {\\n           if(a[i]==t){\\n               int v=Math.abs(i-s);\\n               if(m>v)\\n               m=v;\\n           }\\n       }\\n       return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] a, int t ,int s) {\\n         int m=Integer.MAX_VALUE;\\n         int n=a.length;\\n         for(int i=0;i<n;i++) {\\n           if(a[i]==t){\\n               int v=Math.abs(i-s);\\n               if(m>v)\\n               m=v;\\n           }\\n       }\\n       return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786167,
                "title": "easiest-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>&n , int t , int s){\\n        int mn=INT_MAX;\\n        for(int i=0; i<n.size(); i++){\\n            if(n[i]==t){\\n                if(mn>abs(i-s)){\\n                    mn=abs(i-s);\\n                }\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>&n , int t , int s){\\n        int mn=INT_MAX;\\n        for(int i=0; i<n.size(); i++){\\n            if(n[i]==t){\\n                if(mn>abs(i-s)){\\n                    mn=abs(i-s);\\n                }\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779411,
                "title": "java-easy-0-ms-fastest-don-t-think-complex",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        if(nums[start]==target) return 0;\\n        else {\\n            int min = nums.length+1;\\n            for(int i=start+1; i<nums.length; i++){\\n                if(nums[i]==target) {\\n                    min = i-start;\\n                    break;\\n                }\\n            }\\n            for(int i=start-1; i>=0; i--) {\\n                if(nums[i]==target) {\\n                    if(start-i < min) {\\n                        return start-i;\\n                    }\\n                }\\n            }\\n            return min;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        if(nums[start]==target) return 0;\\n        else {\\n            int min = nums.length+1;\\n            for(int i=start+1; i<nums.length; i++){\\n                if(nums[i]==target) {\\n                    min = i-start;\\n                    break;\\n                }\\n            }\\n            for(int i=start-1; i>=0; i--) {\\n                if(nums[i]==target) {\\n                    if(start-i < min) {\\n                        return start-i;\\n                    }\\n                }\\n            }\\n            return min;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764340,
                "title": "simple-and-most-basic-solution-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate the minimun distace variable whhich contains the maximum value \\nof integer range.\\ncreate a variable to strore the final result and initial it with 0 then interte from start to end of array and check the fisrt condition of arr[i]==t n then create int dist...so we can ccalculate the result at each iteration.\\nthen compare each dist with minimun value varible and assign the value to ans varible.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] arr, int t, int s) {\\n        int min_dis=Integer.MAX_VALUE;\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==t){\\n                int dis=Math.abs(i-s);\\n                if(dis<min_dis){\\n                    min_dis=dis;\\n                    ans=dis;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] arr, int t, int s) {\\n        int min_dis=Integer.MAX_VALUE;\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==t){\\n                int dis=Math.abs(i-s);\\n                if(dis<min_dis){\\n                    min_dis=dis;\\n                    ans=dis;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760836,
                "title": "very-basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=nums.length;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n                min=Math.min(min,Math.abs(i-start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=nums.length;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n                min=Math.min(min,Math.abs(i-start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760446,
                "title": "easy-javascript-method",
                "content": "# Intuition\\nWe start at \\'start\\' position and we only need to search the left and right sides of it. \\n\\nThere are 3 situations\\n\\nLeft : a-i\\nRight : b+i\\nSelf : i=0\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n\\n    for (let i=0;i<=nums.length;i++){\\n    let a = nums[start-i];// Left\\n    let b = nums[start+i];// Right\\n    if (target == nums[start]) return i; //Self, i=0\\n    if (a==target || b==target) return i; //Left or Right\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n\\n    for (let i=0;i<=nums.length;i++){\\n    let a = nums[start-i];// Left\\n    let b = nums[start+i];// Right\\n    if (target == nums[start]) return i; //Self, i=0\\n    if (a==target || b==target) return i; //Left or Right\\n    }\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3748933,
                "title": "runtime-67-ms-beats-78-61-memory-16-5-mb-beats-66-75",
                "content": "# Intuition\\nThe code aims to find the minimum distance between a target value and a given starting index in a list of numbers.\\n\\n# Approach\\nThe approach used in the code is to iterate through each element in the `nums` list. For each element, it checks if the element is equal to the target value. If it is, the code calculates the absolute difference between the current index and the starting index and appends it to the `value` list. By doing this for all elements in the `nums` list, the code obtains a list of distances from the target value to the starting index. Finally, it returns the minimum value from the `value` list, representing the minimum distance.\\n\\n# Complexity\\n- Time complexity:\\nThe code iterates through each element in the `nums` list and performs a constant-time operation for each element. Therefore, the time complexity of the code is O(n), where n is the length of the `nums` list.\\n\\n- Space complexity:\\nThe code uses an additional list `value` to store the distances. The maximum length of the `value` list is the same as the length of the `nums` list. Therefore, the space complexity of the code is O(n), as it requires additional space proportional to the input size.\\n\\n# Code\\n```python\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        value = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                value.append(abs(i-start))\\n        return min(value)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Intuition\\nThe code aims to find the minimum distance between a target value and a given starting index in a list of numbers.\\n\\n# Approach\\nThe approach used in the code is to iterate through each element in the `nums` list. For each element, it checks if the element is equal to the target value. If it is, the code calculates the absolute difference between the current index and the starting index and appends it to the `value` list. By doing this for all elements in the `nums` list, the code obtains a list of distances from the target value to the starting index. Finally, it returns the minimum value from the `value` list, representing the minimum distance.\\n\\n# Complexity\\n- Time complexity:\\nThe code iterates through each element in the `nums` list and performs a constant-time operation for each element. Therefore, the time complexity of the code is O(n), where n is the length of the `nums` list.\\n\\n- Space complexity:\\nThe code uses an additional list `value` to store the distances. The maximum length of the `value` list is the same as the length of the `nums` list. Therefore, the space complexity of the code is O(n), as it requires additional space proportional to the input size.\\n\\n# Code\\n```python\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        value = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                value.append(abs(i-start))\\n        return min(value)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3743586,
                "title": "easy-solution-o-n-linear-search",
                "content": "#\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target&&mini>abs(i-start))\\n             mini=abs(i-start);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target&&mini>abs(i-start))\\n             mini=abs(i-start);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725514,
                "title": "js-2pointer-beats-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n2-pointer approch\\nstart 2 pointers left and right from start\\nincrease right and decrese left untill target is found\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nworst case senario-O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let left = start\\n    let right = start\\n    while(left>-1 || right<nums.length){\\n        if(nums[left] === target){\\n            return Math.abs(left-start)\\n        }\\n        if(nums[right] === target){\\n            return Math.abs(right-start)\\n        }\\n        left--\\n        right++\\n\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let left = start\\n    let right = start\\n    while(left>-1 || right<nums.length){\\n        if(nums[left] === target){\\n            return Math.abs(left-start)\\n        }\\n        if(nums[right] === target){\\n            return Math.abs(right-start)\\n        }\\n        left--\\n        right++\\n\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3721598,
                "title": "bfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        for i in range(len(nums)):\\n            if start+i < len(nums) and nums[start+i]==target:\\n                return i\\n            if start-i >= 0 and nums[start-i]==target:\\n                return i\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        for i in range(len(nums)):\\n            if start+i < len(nums) and nums[start+i]==target:\\n                return i\\n            if start-i >= 0 and nums[start-i]==target:\\n                return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708501,
                "title": "easy-solution-in-c-beats-93",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int minans=0;\\n        int currans=1111111111;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                currans=min(currans,abs(i-start));\\n                minans=currans;\\n            }\\n        }\\n        return currans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int minans=0;\\n        int currans=1111111111;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                currans=min(currans,abs(i-start));\\n                minans=currans;\\n            }\\n        }\\n        return currans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708057,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans , mini = 1e9;\\n        for (int i=0 ; i<nums.size() ; i++){\\n            if (abs(i-start) < mini && nums[i]==target){\\n                mini = abs(i-start);\\n                ans = mini;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans , mini = 1e9;\\n        for (int i=0 ; i<nums.size() ; i++){\\n            if (abs(i-start) < mini && nums[i]==target){\\n                mini = abs(i-start);\\n                ans = mini;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696847,
                "title": "minimum-distance-to-the-target-element-easy-solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int min=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                if(min>abs(start-i)){\\n                    min=abs(start-i);\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int min=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                if(min>abs(start-i)){\\n                    min=abs(start-i);\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695195,
                "title": "easiest-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                if((int)Math.abs(i-start)<min)min=(int)Math.abs(i-start);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                if((int)Math.abs(i-start)<min)min=(int)Math.abs(i-start);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685262,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def getMinDistance(nums: Array[Int], target: Int, start: Int): Int = {\\n        nums.zipWithIndex.filter(_._1 == target).map(pair => math.abs(pair._2 - start)).min\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def getMinDistance(nums: Array[Int], target: Int, start: Int): Int = {\\n        nums.zipWithIndex.filter(_._1 == target).map(pair => math.abs(pair._2 - start)).min\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3677025,
                "title": "easy-c-solution-beginner-friendly-approach-beats-92-in-both",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = nums.size();\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n                ans = min(abs(i-start), ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = nums.size();\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n                ans = min(abs(i-start), ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654430,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Number.POSITIVE_INFINITY;\\n    for(let i =0; i<nums.length; i++){\\n        if(nums[i] == target){\\n            min = Math.min(min, Math.abs(i-start))\\n        }\\n    }\\n   return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Number.POSITIVE_INFINITY;\\n    for(let i =0; i<nums.length; i++){\\n        if(nums[i] == target){\\n            min = Math.min(min, Math.abs(i-start))\\n        }\\n    }\\n   return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3651434,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int i,j;\\n        i=start-1;\\n        j=start+1;\\n        if(nums[start]==target)return 0;\\n        while(i>=0||j<nums.length){\\n            if(i>=0){\\n                if(nums[i]==target)return start-i;\\n                i--;\\n            }\\n            if(j<nums.length){\\n                if(nums[j]==target)return j-start;\\n                j++;\\n            }\\n        }\\n       return 0; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int i,j;\\n        i=start-1;\\n        j=start+1;\\n        if(nums[start]==target)return 0;\\n        while(i>=0||j<nums.length){\\n            if(i>=0){\\n                if(nums[i]==target)return start-i;\\n                i--;\\n            }\\n            if(j<nums.length){\\n                if(nums[j]==target)return j-start;\\n                j++;\\n            }\\n        }\\n       return 0; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635641,
                "title": "java-solution-easy-understanding-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i<nums.length; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                int diff = Math.abs(i - start);\\n                min = Math.min(diff, min);\\n            }\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i<nums.length; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                int diff = Math.abs(i - start);\\n                min = Math.min(diff, min);\\n            }\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625410,
                "title": "100-faster-and-less-memory-im-lazy-so-i-write-what-i-want-w-o-thinking",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        if nums[start as usize] == target {return 0}\\n        let mut left: i32 = start-1;\\n        let mut right: i32 = start + 1;\\n        let mut left_found: i32 = -1;\\n        let mut right_found: i32 = -1;\\n        while left >= 0 || right < nums.len() as i32 {\\n            if left_found != -1 && right_found != -1 {\\n                break;\\n            }\\n            if left >= 0 {\\n                if nums[left as usize] == target && left_found == -1{\\n                    left_found = left;\\n                }\\n                left -= 1;\\n            }\\n            if right < nums.len() as i32 {\\n                if nums[right as usize] == target && right_found == -1{\\n                    right_found = right;\\n                }\\n                right += 1;\\n            }\\n        }\\n        // println!(\"{} {}\", left_found, right_found);\\n        if left_found != -1 && right_found != -1 {\\n            let left_start: i32 = i32::abs(start-left_found);\\n            let right_start: i32 = i32::abs(start-right_found);\\n            if left_start < right_start {\\n                return left_start;\\n            }\\n            return right_start;\\n        }\\n        if left_found != -1 {\\n            return i32::abs(start-left_found);\\n        }\\n        i32::abs(start-right_found)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        if nums[start as usize] == target {return 0}\\n        let mut left: i32 = start-1;\\n        let mut right: i32 = start + 1;\\n        let mut left_found: i32 = -1;\\n        let mut right_found: i32 = -1;\\n        while left >= 0 || right < nums.len() as i32 {\\n            if left_found != -1 && right_found != -1 {\\n                break;\\n            }\\n            if left >= 0 {\\n                if nums[left as usize] == target && left_found == -1{\\n                    left_found = left;\\n                }\\n                left -= 1;\\n            }\\n            if right < nums.len() as i32 {\\n                if nums[right as usize] == target && right_found == -1{\\n                    right_found = right;\\n                }\\n                right += 1;\\n            }\\n        }\\n        // println!(\"{} {}\", left_found, right_found);\\n        if left_found != -1 && right_found != -1 {\\n            let left_start: i32 = i32::abs(start-left_found);\\n            let right_start: i32 = i32::abs(start-right_found);\\n            if left_start < right_start {\\n                return left_start;\\n            }\\n            return right_start;\\n        }\\n        if left_found != -1 {\\n            return i32::abs(start-left_found);\\n        }\\n        i32::abs(start-right_found)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3615602,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int Leftindex = 0, rightIndex = Integer.MAX_VALUE;\\n        for(int i = start; i < nums.length; i++){\\n            if(nums[i] == target){\\n                Leftindex = i;\\n                break;\\n            }\\n        }\\n\\n        for(int i = start; i >= 0; i--){\\n            if(nums[i] == target){\\n                rightIndex = i;\\n                break;\\n            }\\n        }\\n        return Math.min(Math.abs(Leftindex - start), Math.abs(rightIndex - start));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int Leftindex = 0, rightIndex = Integer.MAX_VALUE;\\n        for(int i = start; i < nums.length; i++){\\n            if(nums[i] == target){\\n                Leftindex = i;\\n                break;\\n            }\\n        }\\n\\n        for(int i = start; i >= 0; i--){\\n            if(nums[i] == target){\\n                rightIndex = i;\\n                break;\\n            }\\n        }\\n        return Math.min(Math.abs(Leftindex - start), Math.abs(rightIndex - start));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606023,
                "title": "c-tc-o-n-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n       \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                mini=min(mini,abs(i-start));\\n               \\n            }\\n        }\\n        return mini;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n       \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                mini=min(mini,abs(i-start));\\n               \\n            }\\n        }\\n        return mini;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600839,
                "title": "simple-approach-easy-to-understand-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int Ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                Ans=min(Ans,abs(i-start));\\n            }\\n        }\\n    return Ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int Ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                Ans=min(Ans,abs(i-start));\\n            }\\n        }\\n    return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596582,
                "title": "easiest-c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n       for(int i=0;i<=start;i++)\\n       {\\n           if(nums[i]==target)\\n              mini=min(mini,abs(i-start));\\n       } \\n       for(int i=start+1;i<nums.size();i++)\\n       {\\n           if(nums[i]==target)\\n              mini=min(mini,abs(i-start));\\n       } \\n       return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n       for(int i=0;i<=start;i++)\\n       {\\n           if(nums[i]==target)\\n              mini=min(mini,abs(i-start));\\n       } \\n       for(int i=start+1;i<nums.size();i++)\\n       {\\n           if(nums[i]==target)\\n              mini=min(mini,abs(i-start));\\n       } \\n       return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591976,
                "title": "python-simple-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        idx = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                idx.append(i)\\n        return min(abs(i - start) for i in idx)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        idx = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                idx.append(i)\\n        return min(abs(i - start) for i in idx)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565334,
                "title": "java-easy",
                "content": "# Intuition\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int toReturn = 0;\\n        int currentMin = 1000;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == target) {\\n                toReturn = Math.abs(i - start);\\n                System.out.println(toReturn);\\n                if(toReturn < currentMin) currentMin = toReturn;\\n            }\\n        }\\n        return currentMin;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int toReturn = 0;\\n        int currentMin = 1000;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == target) {\\n                toReturn = Math.abs(i - start);\\n                System.out.println(toReturn);\\n                if(toReturn < currentMin) currentMin = toReturn;\\n            }\\n        }\\n        return currentMin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533784,
                "title": "minimum-distance-solution",
                "content": "# Intuition\\nThis is an very simple question that involves iterating through the given list.\\n\\n# Approach\\nHere is a brief pseudocode:\\n<ul>\\n<li>Iterate over the list one element at a time</li>\\n<li>If the element is equal to target, subtract it and store the result.</li>\\n<li>Check the result with the previous results and see if the new result is smaller.</li>\\n<li>update the result and return it</li>\\n</ul>\\n\\n# Complexity\\n- Time complexity:\\n  This is a very easy question with a very basic approach. However, it took me 30 minutes because i couldn\\'t understand the question. Then after debugging i finally understood the question. So on average this should take about 1 minute to do, maybe less\\n\\n- Space complexity:\\n  I tried making the program use as much less memory as possible but it still takes a lot.\\n\\n# Code\\n```\\n#include<limits>\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int> &a, int target, int start)\\n    {\\n        int i = 0;\\n        int prev = std::numeric_limits<int>::max();\\n        for (int x : a)\\n        {\\n            if (x == target)\\n            {\\n                int  p = std::abs(i -start);\\n                if (p < prev)\\n                {\\n                    prev = p;\\n                }\\n            }\\n            i++;\\n        }\\n        if (prev == std::numeric_limits<int>::max())\\n        {\\n            // nothing found\\n            return 0;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n#include<limits>\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int> &a, int target, int start)\\n    {\\n        int i = 0;\\n        int prev = std::numeric_limits<int>::max();\\n        for (int x : a)\\n        {\\n            if (x == target)\\n            {\\n                int  p = std::abs(i -start);\\n                if (p < prev)\\n                {\\n                    prev = p;\\n                }\\n            }\\n            i++;\\n        }\\n        if (prev == std::numeric_limits<int>::max())\\n        {\\n            // nothing found\\n            return 0;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3520788,
                "title": "go-runtime-0-ms-memory-3-2-mb",
                "content": "# Code\\n```\\nfunc getMinDistance(nums []int, target int, start int) int {\\n\\tmin := math.MaxInt\\n\\tfor i, v := range nums {\\n\\t\\tif v == target {\\n\\t\\t\\tdiff := abs(i - start)\\n\\t\\t\\tif min > diff {\\n\\t\\t\\t\\tmin = diff\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn min\\n}\\n\\n// HELPERS ---------------------------------------\\nfunc abs(val int) int {\\n\\tif val < 0 {\\n\\t\\treturn -val\\n\\t}\\n\\treturn val\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getMinDistance(nums []int, target int, start int) int {\\n\\tmin := math.MaxInt\\n\\tfor i, v := range nums {\\n\\t\\tif v == target {\\n\\t\\t\\tdiff := abs(i - start)\\n\\t\\t\\tif min > diff {\\n\\t\\t\\t\\tmin = diff\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn min\\n}\\n\\n// HELPERS ---------------------------------------\\nfunc abs(val int) int {\\n\\tif val < 0 {\\n\\t\\treturn -val\\n\\t}\\n\\treturn val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516788,
                "title": "minimum-distance-java-solution-0ms-beats-100-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have given the target element and the element from which we have to start. \\nWe iterate through the array , check where our target value lies and calculate the minimum distance.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Declared two variables max and min which are initially initialised as the Integer.MAX_VALUE;\\n- Then we iterate through the array,  and whenever we encounter our target element we store it\\'s index to the max variable.\\n- Now to calculate the minimum distance between the index, we use the Math.min() function where the parameters are the min value itself alongwith the positive difference between the max variable value and the start value.\\n- We then return the min value.\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int max = Integer.MAX_VALUE; \\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] == target){\\n                max = i;\\n\\n                min = Math.min(min , Math.abs(max - start));\\n            }\\n        }   \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int max = Integer.MAX_VALUE; \\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] == target){\\n                max = i;\\n\\n                min = Math.min(min , Math.abs(max - start));\\n            }\\n        }   \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506789,
                "title": "straightforward-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = float(\"inf\")\\n        for i, n in enumerate(nums):\\n            if n == target:\\n                res = min(res, abs(i-start))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = float(\"inf\")\\n        for i, n in enumerate(nums):\\n            if n == target:\\n                res = min(res, abs(i-start))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502241,
                "title": "100-easy-solution-using-java",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int m=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++){\\n           if(nums[i]==target){\\n             m=Math.min(m,Math.abs(i-start));  \\n           }\\n          \\n       } \\n       return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int m=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++){\\n           if(nums[i]==target){\\n             m=Math.min(m,Math.abs(i-start));  \\n           }\\n          \\n       } \\n       return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497874,
                "title": "getmindistance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n//    let index=0;\\n   let indices = [];\\n    if(nums.length >=1 && nums.length <= 1000 && start >=0 && start< nums.length && nums.includes(target)){\\n        nums.filter(function(ele, index) {\\n if(ele == target){\\n   indices.push(Math.abs(index-start))\\n }\\n});\\nreturn Math.min(...indices)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n//    let index=0;\\n   let indices = [];\\n    if(nums.length >=1 && nums.length <= 1000 && start >=0 && start< nums.length && nums.includes(target)){\\n        nums.filter(function(ele, index) {\\n if(ele == target){\\n   indices.push(Math.abs(index-start))\\n }\\n});\\nreturn Math.min(...indices)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496479,
                "title": "easy-java-solution",
                "content": "`Please upvote if it helps you. Happy Coding!`\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                min = Math.min(min, Math.abs(i-start));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                min = Math.min(min, Math.abs(i-start));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494169,
                "title": "0ms-100-beats-clean-java-solution-beconsistent",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n              if(Math.abs(i-start)<min)\\n              min=Math.abs(i-start);\\n            }\\n        }\\n   return min;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n              if(Math.abs(i-start)<min)\\n              min=Math.abs(i-start);\\n            }\\n        }\\n   return min;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484215,
                "title": "minimum-distance-to-the-target-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        ans = math.inf\\n        for i, num in enumerate(nums):\\n            if num == target:\\n                ans = min(ans, abs(i - start))\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        ans = math.inf\\n        for i, num in enumerate(nums):\\n            if num == target:\\n                ans = min(ans, abs(i - start))\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483739,
                "title": "minimum-distance-to-the-target-element-easy-solution-with-few-lines-of-code",
                "content": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int smallval= INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target && abs(i-start)<smallval)\\n            {\\n               smallval = abs(i-start);\\n            }\\n              \\n\\n        }\\n        return smallval;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int smallval= INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target && abs(i-start)<smallval)\\n            {\\n               smallval = abs(i-start);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3478521,
                "title": "with-math-library-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n  let array = [];\\n    for ( let i = 0; i < nums.length; i++){\\n      if(nums[i] === target){\\n       array.push(Math.abs(i - start));\\n      }\\n    }\\n    return Math.min(...array)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n  let array = [];\\n    for ( let i = 0; i < nums.length; i++){\\n      if(nums[i] === target){\\n       array.push(Math.abs(i - start));\\n      }\\n    }\\n    return Math.min(...array)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3472603,
                "title": "java-expand-from-start-to-both-side-of-array-easy-to-understand-t-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n = nums.length;\\n        int i = start;\\n        int j = start;\\n        int minDist = Integer.MAX_VALUE;\\n        while(i >= 0){\\n            if(nums[i] == target) {\\n                minDist = Math.min(minDist, Math.abs(i - start));\\n                break;\\n            }\\n            i--;\\n        }\\n\\n        while(j < n){\\n            if(nums[j] == target) {\\n                minDist = Math.min(minDist, Math.abs(j - start));\\n                break;\\n            }\\n            j++;\\n        }\\n        return minDist;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n = nums.length;\\n        int i = start;\\n        int j = start;\\n        int minDist = Integer.MAX_VALUE;\\n        while(i >= 0){\\n            if(nums[i] == target) {\\n                minDist = Math.min(minDist, Math.abs(i - start));\\n                break;\\n            }\\n            i--;\\n        }\\n\\n        while(j < n){\\n            if(nums[j] == target) {\\n                minDist = Math.min(minDist, Math.abs(j - start));\\n                break;\\n            }\\n            j++;\\n        }\\n        return minDist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470428,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        mini=float(\"inf\")\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                mini=min(mini,abs(i-start))\\n        return mini\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        mini=float(\"inf\")\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                mini=min(mini,abs(i-start))\\n        return mini\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460686,
                "title": "100-java-solutions",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        boolean alreadyOccurred = false;\\n        for(int i=0; i<nums.length; i++ ){\\n            if(nums[i] == target){\\n                ans = alreadyOccurred ? Math.min(ans,Math.abs(i-start)) : Math.abs(i-start);\\n                alreadyOccurred = true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        boolean alreadyOccurred = false;\\n        for(int i=0; i<nums.length; i++ ){\\n            if(nums[i] == target){\\n                ans = alreadyOccurred ? Math.min(ans,Math.abs(i-start)) : Math.abs(i-start);\\n                alreadyOccurred = true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457502,
                "title": "minimum-distance-javascript-o-n-51-ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/1a408052-67c1-4cfb-b5f7-87ac9f96447f_1682515561.8084388.png)\\n\\n```\\nvar getMinDistance = function(nums, target, start) {    \\n    right = (10 ** 4), left  = - (10 ** 4)\\n\\n    for (let i = start; i < nums.length; i++) {\\n        if (nums[i] == target) {\\n            right = i\\n            break\\n        }\\n    }\\n\\n    for (let i = start; i >= 0; i--) {\\n        if (nums[i] == target) {\\n            left = i\\n            break\\n        }\\n    }\\n\\n    return Math.min(start - left, right - start)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinDistance = function(nums, target, start) {    \\n    right = (10 ** 4), left  = - (10 ** 4)\\n\\n    for (let i = start; i < nums.length; i++) {\\n        if (nums[i] == target) {\\n            right = i\\n            break\\n        }\\n    }\\n\\n    for (let i = start; i >= 0; i--) {\\n        if (nums[i] == target) {\\n            left = i\\n            break\\n        }\\n    }\\n\\n    return Math.min(start - left, right - start)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3456482,
                "title": "python-basic-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        a = []\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                a.append(abs(i-start))\\n        return min(a)        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        a = []\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                a.append(abs(i-start))\\n        return min(a)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448304,
                "title": "rust-functional-style-iterators",
                "content": "# Intuition\\nBasic implementation of the problem. Technically there are ways that you could reduce the number of iterations necessary by starting from the middle, but in practice iteration is just faster.\\n\\n# Approach\\niter(), well, iterates over the vector. Note that this is read-only so it\\'s actually iterating over &i32 instead of i32.\\n\\nenumerate() turns an iterator of &i32 into an iterator of (usize, &i32) where the first term is the zero-indexed position. **Note**: we have to enumerate before filtering so our index is relative to its original position.\\n\\nfilter() removes any irrelevant elements from the iterator.\\n\\nmap() throws out the &i32 term (we\\'re done with it after the filter), and converts from i: usize into the absolute value distance measure as an i32.\\n\\nAfter the map, we now have an iterator of distances to \"start\". We use min() to collapse the iterator into Option<i32>; note that it is an option because Rust thinks the iterator might be empty (i.e. no elements match target).\\n\\nBut we\\'re told this is impossible, so we can just unwrap() and call it a day.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n), we do one pass over nums.\\n\\n- Space complexity:\\nO(1), the iterator struct takes up a finite amount of space and there are no heap allocations.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        nums\\n        .iter()\\n        .enumerate()\\n        .filter(|(_, &num)| num == target)\\n        .map(|(i, _)| ((i as i32) - start).abs())\\n        .min()\\n        .unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        nums\\n        .iter()\\n        .enumerate()\\n        .filter(|(_, &num)| num == target)\\n        .map(|(i, _)| ((i as i32) - start).abs())\\n        .min()\\n        .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3436903,
                "title": "java-simple-solution-bruteforce-find-minimum",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int minAbsolute = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                minAbsolute = Math.min(minAbsolute, Math.abs(i - start));\\n            }\\n        }\\n\\n        return minAbsolute;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int minAbsolute = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                minAbsolute = Math.min(minAbsolute, Math.abs(i - start));\\n            }\\n        }\\n\\n        return minAbsolute;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412410,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) where n is the length of nums\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) where n is the length of nums\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res.append(abs(i -start))\\n\\n        return min(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res.append(abs(i -start))\\n\\n        return min(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402810,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                ans = Math.min(ans, Math.abs(i-start));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                ans = Math.min(ans, Math.abs(i-start));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396909,
                "title": "3-line-easy-java-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int res = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++)\\n            if(nums[i] == target)\\n               res = Math.min(res,  Math.abs(i - start));\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int res = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++)\\n            if(nums[i] == target)\\n               res = Math.min(res,  Math.abs(i - start));\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382703,
                "title": "c-bfs-from-start",
                "content": "No error checking since constraints say target must exist in vector.\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int l = start, r = start;\\n        while (true){\\n            if (l > -1 && nums[l] == target) return start - l;\\n            if (r < nums.size() && nums[r] == target) return r - start;\\n            --l, ++r;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int l = start, r = start;\\n        while (true){\\n            if (l > -1 && nums[l] == target) return start - l;\\n            if (r < nums.size() && nums[r] == target) return r - start;\\n            --l, ++r;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368450,
                "title": "solution-to-absolute-value-question-with-proper-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first It was difficult to grasp what the question was trying to ask but i slowly and steadily understood the problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is quite different compared to other solutions. I have initiated with an array in a for loop which stores the absolute values of \"i-start\" ONLY if the current value of vector is equal to the target we need (since there can be multiple values which match the target value but we want one which is CLOSEST to the index of \"start\" to minimize the absolute value). The loop runs and constantly stores the absolute values whenever it encounters one. Next, I have initiated another loop to check for the MINIMUM absolute value out of all absolute values to get a minimized solution.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int len=nums.size();\\n\\n        int x=0;\\n        int arr[len];\\n        for(int i=0; i<len; i++){\\n            if(nums[i]==target){\\n                arr[x]=abs(i-start);\\n                x++;\\n            }\\n        }\\n        int min=arr[0];\\n        for(int i=1; i<x; i++){\\n            if(arr[0]>arr[i]){\\n                min=arr[i];\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int len=nums.size();\\n\\n        int x=0;\\n        int arr[len];\\n        for(int i=0; i<len; i++){\\n            if(nums[i]==target){\\n                arr[x]=abs(i-start);\\n                x++;\\n            }\\n        }\\n        int min=arr[0];\\n        for(int i=1; i<x; i++){\\n            if(arr[0]>arr[i]){\\n                min=arr[i];\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358166,
                "title": "easy-5-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] == target) {\\n            arr.push(Math.abs(i - start));\\n        }\\n    }\\n    return Math.min(...arr);\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] == target) {\\n            arr.push(Math.abs(i - start));\\n        }\\n    }\\n    return Math.min(...arr);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3354553,
                "title": "java-easiest-solution",
                "content": "class Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n\\n        int ans = Integer.MAX_VALUE;\\n        \\n        for (int i = 0 ; i < nums.length ; i++){\\n\\n            if (nums[i] == target){\\n\\n                ans = Math.min(ans, Math.abs(i - start));\\n\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n\\n        int ans = Integer.MAX_VALUE;\\n        \\n        for (int i = 0 ; i < nums.length ; i++){\\n\\n            if (nums[i] == target){\\n\\n                ans = Math.min(ans, Math.abs(i - start));\\n\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1850808,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Easy  problem  using Greedy Method"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nNo special algorithm. Just loop through.\\n\\n# <span style=\\'color:green\\'>Answer</span>\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return min(abs(i - start) for i in range(len(nums)) if nums[i] == target)"
                    }
                ]
            },
            {
                "id": 1799174,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Easy  problem  using Greedy Method"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nNo special algorithm. Just loop through.\\n\\n# <span style=\\'color:green\\'>Answer</span>\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return min(abs(i - start) for i in range(len(nums)) if nums[i] == target)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Splitting a String Into Descending Consecutive Values",
        "question_content": "<p>You are given a string <code>s</code> that consists of only digits.</p>\n\n<p>Check if we can split <code>s</code> into <strong>two or more non-empty substrings</strong> such that the <strong>numerical values</strong> of the substrings are in <strong>descending order</strong> and the <strong>difference</strong> between numerical values of every two <strong>adjacent</strong> <strong>substrings</strong> is equal to <code>1</code>.</p>\n\n<ul>\n\t<li>For example, the string <code>s = &quot;0090089&quot;</code> can be split into <code>[&quot;0090&quot;, &quot;089&quot;]</code> with numerical values <code>[90,89]</code>. The values are in descending order and adjacent values differ by <code>1</code>, so this way is valid.</li>\n\t<li>Another example, the string <code>s = &quot;001&quot;</code> can be split into <code>[&quot;0&quot;, &quot;01&quot;]</code>, <code>[&quot;00&quot;, &quot;1&quot;]</code>, or <code>[&quot;0&quot;, &quot;0&quot;, &quot;1&quot;]</code>. However all the ways are invalid because they have numerical values <code>[0,1]</code>, <code>[0,1]</code>, and <code>[0,0,1]</code> respectively, all of which are not in descending order.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if it is possible to split</em> <code>s</code> <em>as described above</em><em>, or </em><code>false</code><em> otherwise.</em></p>\n\n<p>A <strong>substring</strong> is a contiguous sequence of characters in a string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1234&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no valid way to split s.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;050043&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> s can be split into [&quot;05&quot;, &quot;004&quot;, &quot;3&quot;] with numerical values [5,4,3].\nThe values are in descending order with adjacent values differing by 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;9080701&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no valid way to split s.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> only consists of digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1186814,
                "title": "java-backtracking",
                "content": "Here, we find the first number/prefixes(where previous is null) and then search in remaining string if numbers are in descending order.\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isRemainingValid(s, null);\\n    }\\n    private boolean isRemainingValid(String s, Long previous) {\\n        long current =0;\\n        for(int i=0;i<s.length();i++) {\\n            current = current * 10 + s.charAt(i)-\\'0\\';\\n            if(current >= 10000000000L) return false;   // Avoid overflow\\n            if(previous == null) {\\n                if (isRemainingValid(s.substring(i+1), current)) \\n                    return true;\\n            } else if(current == previous - 1 && (i==s.length()-1 || isRemainingValid(s.substring(i+1), current)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isRemainingValid(s, null);\\n    }\\n    private boolean isRemainingValid(String s, Long previous) {\\n        long current =0;\\n        for(int i=0;i<s.length();i++) {\\n            current = current * 10 + s.charAt(i)-\\'0\\';\\n            if(current >= 10000000000L) return false;   // Avoid overflow\\n            if(previous == null) {\\n                if (isRemainingValid(s.substring(i+1), current)) \\n                    return true;\\n            } else if(current == previous - 1 && (i==s.length()-1 || isRemainingValid(s.substring(i+1), current)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186795,
                "title": "c-backtracking-solution-o-n-2-and-time-complexity-analytics",
                "content": "\\n#### Time complexity\\nO(N ^ 2). even though we use back-tracking here, it is obvious that the upper-bound complexity of this solution is N^2, in the for loop `for(int i = idx; i < s.size(); i++) `, there is only one chance to go into next `dfs` function, so it is linear complexity O(N) for every iteration. so it is O(N ^ 2), if you don\\'t believe this, you can add a counter in the for loop and see what is the value of the counter, it is smaller than(close to) N^2.\\n\\n```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186896,
                "title": "java-brute-force-recursion-step-by-step-with-detailed-explanation",
                "content": "**Please Upvote ! if you found useful, so it helps others to find it. Thank you, I tried to explain in as depth as possible. Enjoy!**\\n\\n**Approach 1: Brute Force**\\n\\nSo my idea was to hop **i** digits at the time, if we reach to the end that means we found our answer. \\n**What do i mean by hop?**\\nEx: \"000908760\" \\n\\ti = 1 -> \"0009\" then \"08\" then \"07\" then \"6\" then \"0\" (It will find single digits) i.e 9..8..6..0\\n\\ti = 2 -> \"00090\" then \"87\" then \"60\" (it will find double digits) i.e 90..87..60\\n\\tSo if we reach till End that means we got our answer and return true\\n\\t\\n**Tricky part of this problem**\\n*   **Zeros:** I considered the number after intial 0\\'s i.e 00007 -> 7\\n*  **Gap of 1:** so to check that convert the number to long and subtract with prev itteration and diff should be 1\\n* \\t**Edge case** 001: We check if prev is Long.max value that means this is the first digit and should not return true even we reach till end\\n* \\t **Edge Case** 1009897: here if our i = 2 10..98..97 if i=3 then i=100..989..7 so using variable \"width\" to check if number is 10..100..10000 or power of 10 next number we search is i width shorter so if we find 100 we are nowlooking for 2 digit number instead of 3\\n\\nUsing long because there\\'s a test case which int cannot parse\\nHope it makes sense comment if you have any question.\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n\\t// we are only making s.length()/2 hops becase we only want min 2 parts of string\\n        for(int i = 1; i <= (s.length() / 2)+1; i++){\\n            int index = 0, width = i; \\n            Long prev = Long.MAX_VALUE;\\n            while(index < s.length()){ \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// checking if 100 then next time find 2 digit number so width-1\\n                long ten = (long)Math.pow ( 10, i-1); \\n                if(i > 1 && prev == ten) width--;\\n\\t\\t\\t\\t\\n                String next = getDigit(index, s, width);\\n                long val = Long.parseLong(next);\\n\\t\\t\\t\\t\\n                if(index != 0 && prev - val != 1) break; // \\n                \\n                index += next.length();\\n\\t\\t\\t\\t// If it is not the first values && we hopped till end then return true;\\n                if(prev != Long.MAX_VALUE && index >= s.length()) return true;\\n                prev = val;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n\\t// This function simply returns the next len digit number starting from i index of string\\n\\t// getDigit(2,\"090087\",1) -> 8\\n    public String getDigit(int i, String s, int len){\\n        int digits = 0;\\n        int j = i;\\n        while(j < s.length() && s.charAt(j) == \\'0\\') j++;\\n        return s.substring(i, Math.min(j+len, s.length()));\\n    }\\n}\\n```\\n\\n\\n**Approach 2 DFS**\\n\\nSimply we start and keep finding the next substring(long) such that curr - next = 1 and the end if we reach to the last index we check if we found atleast 2 long\\nEx: \"9998\" -> 9..99..98\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        if (s == null || s.length()<=1) return false;\\n        return backtrack(0, s, new ArrayList<Long>());\\n    }\\n    \\n    public boolean backtrack(int pos, String s, ArrayList<Long> list) {\\n\\t\\t// Base case where we reach till end of string and we have atleast 2 parts\\n        if (pos >= s.length()) return list.size() >= 2; \\n\\n        long num = 0;\\n        for (int i=pos; i<s.length(); i++) {\\n            num = num*10 + (s.charAt(i)-\\'0\\'); // \"070\" i = 1 -> 0.. i = 2 -> 7.. i =3 -> 70 \\n            if (list.size()==0 || list.get(list.size()-1) - num == 1) { // if it is first digit or difference is +1 valid\\n                \\n                list.add(num);  // add the number and continue to next index\\n                if (backtrack(i+1, s, list)) return true;\\n                list.remove(list.size()-1); // backtrack, done with that itteration coun\\'t find it\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n\\t// we are only making s.length()/2 hops becase we only want min 2 parts of string\\n        for(int i = 1; i <= (s.length() / 2)+1; i++){\\n            int index = 0, width = i; \\n            Long prev = Long.MAX_VALUE;\\n            while(index < s.length()){ \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// checking if 100 then next time find 2 digit number so width-1\\n                long ten = (long)Math.pow ( 10, i-1); \\n                if(i > 1 && prev == ten) width--;\\n\\t\\t\\t\\t\\n                String next = getDigit(index, s, width);\\n                long val = Long.parseLong(next);\\n\\t\\t\\t\\t\\n                if(index != 0 && prev - val != 1) break; // \\n                \\n                index += next.length();\\n\\t\\t\\t\\t// If it is not the first values && we hopped till end then return true;\\n                if(prev != Long.MAX_VALUE && index >= s.length()) return true;\\n                prev = val;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n\\t// This function simply returns the next len digit number starting from i index of string\\n\\t// getDigit(2,\"090087\",1) -> 8\\n    public String getDigit(int i, String s, int len){\\n        int digits = 0;\\n        int j = i;\\n        while(j < s.length() && s.charAt(j) == \\'0\\') j++;\\n        return s.substring(i, Math.min(j+len, s.length()));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        if (s == null || s.length()<=1) return false;\\n        return backtrack(0, s, new ArrayList<Long>());\\n    }\\n    \\n    public boolean backtrack(int pos, String s, ArrayList<Long> list) {\\n\\t\\t// Base case where we reach till end of string and we have atleast 2 parts\\n        if (pos >= s.length()) return list.size() >= 2; \\n\\n        long num = 0;\\n        for (int i=pos; i<s.length(); i++) {\\n            num = num*10 + (s.charAt(i)-\\'0\\'); // \"070\" i = 1 -> 0.. i = 2 -> 7.. i =3 -> 70 \\n            if (list.size()==0 || list.get(list.size()-1) - num == 1) { // if it is first digit or difference is +1 valid\\n                \\n                list.add(num);  // add the number and continue to next index\\n                if (backtrack(i+1, s, list)) return true;\\n                list.remove(list.size()-1); // backtrack, done with that itteration coun\\'t find it\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186963,
                "title": "c-check-all-lengths",
                "content": "> Update: added a shorter solution that avoids copying strings. The original solution (as embarrassing as it is) is below just for the reference.\\n \\nThis problem was hard to implement for me. I got hidden WA, and spent a while chasing it down. Turns out, I had a problem with the \"1000999\" test case when the first number is longer than the half of the string.\\n \\n#### Simplified Solution\\nWell this is way simpler than the original solution, but I could not come up with it during the contest. Still a long road ahead to practice.\\n \\nFew important points:\\n- The very first loop does not go all the way to the end - to make sure we have at least one split.\\n- Limit `num` to avoid overflow.\\n \\n```cpp\\nbool splitString(string &s, int i = 0, long prev = 0) {\\n    long num = 0;\\n    for (int j = i; num < 1e+10 && j < s.size() - (i == 0 ? 1 : 0); ++j) {\\n        num = num * 10 + (s[j] - \\'0\\');\\n        if ((i == 0 || prev - 1 == num) && splitString(s, j + 1, num))\\n            return true;\\n    }\\n    return i == s.size();\\n}\\n```\\n\\n#### Original Solution\\nAnyhow, the idea is to iterate through possible number lengths (from `1` to `nums.size() / 2 + 1`), get the first number, and recursively check if we can find decreasing numbers in the rest of the string.\\n\\nTo make it simple, we first trim leading zeros from our string. We create bunch of copies by using `substr()`, but it\\'s tolerable as our string is limited to 20 characters.\\n\\n```cpp\\nbool check(string s, long num) {\\n    if (s.empty())      \\n        return true;    \\n    int i = 0;\\n    while (i + 1 < s.size() && s[i] == \\'0\\')\\n        ++i;\\n    s = s.substr(i);\\n    auto num_s = to_string(num);\\n    if (s.compare(0, num_s.size(), num_s) == 0)\\n        return check(s.substr(num_s.size()), num - 1);\\n    return false;\\n} \\nbool splitString(string s) {\\n    auto pos = s.find_first_not_of(\\'0\\');\\n    if (pos != string::npos)\\n        s = s.substr(pos);\\n    for (int len = 1; len <= (s.size() + 1) / 2; ++len) {\\n        long num_start = stol(s.substr(0, len));\\n        if (s.size() > 1 && check(s.substr(len), num_start - 1))\\n            return true;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool splitString(string &s, int i = 0, long prev = 0) {\\n    long num = 0;\\n    for (int j = i; num < 1e+10 && j < s.size() - (i == 0 ? 1 : 0); ++j) {\\n        num = num * 10 + (s[j] - \\'0\\');\\n        if ((i == 0 || prev - 1 == num) && splitString(s, j + 1, num))\\n            return true;\\n    }\\n    return i == s.size();\\n}\\n```\n```cpp\\nbool check(string s, long num) {\\n    if (s.empty())      \\n        return true;    \\n    int i = 0;\\n    while (i + 1 < s.size() && s[i] == \\'0\\')\\n        ++i;\\n    s = s.substr(i);\\n    auto num_s = to_string(num);\\n    if (s.compare(0, num_s.size(), num_s) == 0)\\n        return check(s.substr(num_s.size()), num - 1);\\n    return false;\\n} \\nbool splitString(string s) {\\n    auto pos = s.find_first_not_of(\\'0\\');\\n    if (pos != string::npos)\\n        s = s.substr(pos);\\n    for (int len = 1; len <= (s.size() + 1) / 2; ++len) {\\n        long num_start = stol(s.substr(0, len));\\n        if (s.size() > 1 && check(s.substr(len), num_start - 1))\\n            return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186813,
                "title": "c-python-recursive-backtracking-solution-explained-w-comments",
                "content": "\\u2714\\uFE0F ***Solution***\\n\\nWe need to iterate over all possible substrings for each splits. \\n\\nIf a split gives value equal to **`previous split - 1`**, then continue trying to split for remaining index. Otherwise, try increasing the length of split and check again.\\n\\nIf you reach the last index and there are more than 1 splits, return true. Otherwise return false.\\n\\n**C++**\\n\\nFor C++, you need to handle overflows . For this purpose, I have use *`try...catch`* block in the below solution -\\n\\n```\\nbool splitString(string s) {\\n\\treturn solve(s, 0, 1, -1);\\n}\\nbool solve(string& s, int i, int len, long prev, int splits = 0) {\\n\\t// If we reach the end of string and have made splits >= 2, return true\\n\\tif(i == size(s) && splits >= 2) return true;\\n\\twhile(i + len <= size(s)) {\\n\\t\\ttry{\\n\\t\\t\\tauto cur = stoll(s.substr(i, len++));         // convert s[i] to s[i + len] into number\\n\\t\\t\\tif(prev != -1 && cur != prev - 1) continue;   // and check if it is equal to prev - 1 (ignore for first call)\\n\\t\\t\\t// if the above condition satisfies, just  recurse for the remaining indices\\n\\t\\t\\tif(solve(s, i + len - 1, 1, cur, splits + 1)) return true;    \\n\\t\\t} catch(...) { continue; } // handling overflows\\n\\t}\\n\\treturn false;        \\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef splitString(self, s: str) -> bool:\\n\\tdef solve(s, i, length, prev, splits):\\n\\t\\t# At last, if you reach the end and have made splits >= 2, we are sure that a split as per requirement is possible\\n\\t\\tif i == len(s) and splits >= 2: \\n\\t\\t\\treturn True\\n\\t\\twhile i + length <= len(s):\\n\\t\\t\\tcur = int(s[i:i+length])   # convert s[i:i + length] to integer\\n\\t\\t\\tlength += 1\\n\\t\\t\\t# if above converted integer is not equal to prev - 1, try increasing the length\\n\\t\\t\\tif prev != -1 and cur != prev - 1: continue \\n\\t\\t\\t# if it is equal to prev - 1, recurse and make splits for remaining index\\n\\t\\t\\tif solve(s, i + length - 1, 1, cur, splits + 1):\\n\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\treturn solve(s, 0, 1, -1, 0)\\n```\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nbool splitString(string s) {\\n\\treturn solve(s, 0, 1, -1);\\n}\\nbool solve(string& s, int i, int len, long prev, int splits = 0) {\\n\\t// If we reach the end of string and have made splits >= 2, return true\\n\\tif(i == size(s) && splits >= 2) return true;\\n\\twhile(i + len <= size(s)) {\\n\\t\\ttry{\\n\\t\\t\\tauto cur = stoll(s.substr(i, len++));         // convert s[i] to s[i + len] into number\\n\\t\\t\\tif(prev != -1 && cur != prev - 1) continue;   // and check if it is equal to prev - 1 (ignore for first call)\\n\\t\\t\\t// if the above condition satisfies, just  recurse for the remaining indices\\n\\t\\t\\tif(solve(s, i + len - 1, 1, cur, splits + 1)) return true;    \\n\\t\\t} catch(...) { continue; } // handling overflows\\n\\t}\\n\\treturn false;        \\n}\\n```\n```\\ndef splitString(self, s: str) -> bool:\\n\\tdef solve(s, i, length, prev, splits):\\n\\t\\t# At last, if you reach the end and have made splits >= 2, we are sure that a split as per requirement is possible\\n\\t\\tif i == len(s) and splits >= 2: \\n\\t\\t\\treturn True\\n\\t\\twhile i + length <= len(s):\\n\\t\\t\\tcur = int(s[i:i+length])   # convert s[i:i + length] to integer\\n\\t\\t\\tlength += 1\\n\\t\\t\\t# if above converted integer is not equal to prev - 1, try increasing the length\\n\\t\\t\\tif prev != -1 and cur != prev - 1: continue \\n\\t\\t\\t# if it is equal to prev - 1, recurse and make splits for remaining index\\n\\t\\t\\tif solve(s, i + length - 1, 1, cur, splits + 1):\\n\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\treturn solve(s, 0, 1, -1, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1186831,
                "title": "c-simple-recursive-solution",
                "content": "Transfer to long long int and compare\\n\\n```cpp\\nclass Solution {\\n    bool helper(string s, long long int tar) {\\n        if (stoull(s) == tar) return true;\\n        for (int i = 1; i < s.size(); ++i) {\\n            if (stoull(s.substr(0, i)) != tar)    continue;\\n            if (helper(s.substr(i, s.size()-i), tar-1))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        for (int i = 1; i < s.size(); ++i) {\\n            long long int tar = stoull(s.substr(0, i));\\n            if (helper(s.substr(i, s.size()-i), tar-1))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\n    bool helper(string s, long long int tar) {\\n        if (stoull(s) == tar) return true;\\n        for (int i = 1; i < s.size(); ++i) {\\n            if (stoull(s.substr(0, i)) != tar)    continue;\\n            if (helper(s.substr(i, s.size()-i), tar-1))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        for (int i = 1; i < s.size(); ++i) {\\n            long long int tar = stoull(s.substr(0, i));\\n            if (helper(s.substr(i, s.size()-i), tar-1))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186812,
                "title": "java-backtracking-100-runtime",
                "content": "Backtracking problem -\\n\\nHint from the constraints  1 <= s.length <= 20\\n\\nWhen the size is less, we can generate all possible combinations and decide\\n\\n# ** backTrack( String s, int index, long prevNumber, int count )**\\n\\nRecursionVirtualization - \\n\\n![image](https://assets.leetcode.com/users/images/9429e601-cc1f-4b41-8269-b99584f12388_1620252266.1658697.gif)\\n\\nRecursion Tree -\\n\\n![image](https://assets.leetcode.com/users/images/14a7f94d-cc9d-4403-be10-0d5debd30c55_1620252278.9633133.png)\\n\\n\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return backTrack( s , 0, -1, 0 );\\n    }\\n    \\n    public boolean backTrack( String s, int index, long prevNumber, int count )\\n    {\\n        if( index >= s.length() )\\n        {\\n            if( count >= 2) \\n                return true;\\n            return false;\\n        }\\n        \\n        long currNo=0;\\n        for( int i = index; i < s.length() ;i++ )\\n        {\\n            currNo = currNo*10+(s.charAt(i)-\\'0\\');\\n            if( prevNumber == -1 || ( prevNumber - currNo ) == 1 )\\n                if( backTrack( s,i+1,currNo, count+1) )\\n                    return true;\\n        }\\n    return false;\\n    }\\n}\\n```\\nIf we were asked for actual sequence then slight modification to the above code , cList contains the actual sequence \\n```\\n\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return backTrack( s , 0, new LinkedList() );\\n    }\\n    \\n    public boolean backTrack( String s, int index, LinkedList<Long> cList )\\n    {\\n        if( index >= s.length() )\\n        {\\n            if( cList.size() >= 2) \\n                return true;\\n            return false;\\n        }\\n        \\n        long currNo=0;\\n        for( int i = index; i < s.length() ;i++ )\\n        {\\n            long lastNumber = cList.size() > 0 ? cList.getLast() :-1;\\n            currNo = currNo*10+(s.charAt(i)-\\'0\\');\\n            if( lastNumber == -1 || ( lastNumber - currNo ) == 1 )\\n            {\\n                cList.add( currNo);\\n                if( backTrack( s,i+1,cList) )\\n                    return true;\\n                cList.removeLast();\\n            }\\n        }\\n    return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return backTrack( s , 0, -1, 0 );\\n    }\\n    \\n    public boolean backTrack( String s, int index, long prevNumber, int count )\\n    {\\n        if( index >= s.length() )\\n        {\\n            if( count >= 2) \\n                return true;\\n            return false;\\n        }\\n        \\n        long currNo=0;\\n        for( int i = index; i < s.length() ;i++ )\\n        {\\n            currNo = currNo*10+(s.charAt(i)-\\'0\\');\\n            if( prevNumber == -1 || ( prevNumber - currNo ) == 1 )\\n                if( backTrack( s,i+1,currNo, count+1) )\\n                    return true;\\n        }\\n    return false;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return backTrack( s , 0, new LinkedList() );\\n    }\\n    \\n    public boolean backTrack( String s, int index, LinkedList<Long> cList )\\n    {\\n        if( index >= s.length() )\\n        {\\n            if( cList.size() >= 2) \\n                return true;\\n            return false;\\n        }\\n        \\n        long currNo=0;\\n        for( int i = index; i < s.length() ;i++ )\\n        {\\n            long lastNumber = cList.size() > 0 ? cList.getLast() :-1;\\n            currNo = currNo*10+(s.charAt(i)-\\'0\\');\\n            if( lastNumber == -1 || ( lastNumber - currNo ) == 1 )\\n            {\\n                cList.add( currNo);\\n                if( backTrack( s,i+1,cList) )\\n                    return true;\\n                cList.removeLast();\\n            }\\n        }\\n    return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186808,
                "title": "python-backtracking-solution",
                "content": "```\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(s, x):\\n            if x == None:\\n                for i in range(1, len(s)):\\n                    if backtrack(s[i:], int(s[:i])):\\n                        return True\\n                return False\\n            else:\\n                if s == \"\" or int(s) == x - 1:\\n                    return True\\n                for i in range(1, len(s)):\\n                    if int(s[:i]) == x - 1:\\n                        return backtrack(s[i:], x - 1)\\n                return False\\n        \\n        return backtrack(s, None)\\n```",
                "solutionTags": [],
                "code": "```\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(s, x):\\n            if x == None:\\n                for i in range(1, len(s)):\\n                    if backtrack(s[i:], int(s[:i])):\\n                        return True\\n                return False\\n            else:\\n                if s == \"\" or int(s) == x - 1:\\n                    return True\\n                for i in range(1, len(s)):\\n                    if int(s[:i]) == x - 1:\\n                        return backtrack(s[i:], x - 1)\\n                return False\\n        \\n        return backtrack(s, None)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2434966,
                "title": "c-simple-c-code",
                "content": "\\n\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int n;\\n    bool split(int idx, string &s, unsigned long long num)\\n    {\\n        if(idx == n)\\n            return true;\\n        string ans = \"\";\\n        for(int i = idx; i < n; i++)\\n        {\\n            ans += s[i];\\n            unsigned long long val = stoull(ans);\\n            if(val != num-1)\\n                continue;\\n            if(split(i+1, s, val))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        n = s.size();\\n        string ans = \"\";\\n        for(int i = 0; i < n-1; i++)\\n        {\\n            ans += s[i];\\n            unsigned long long num = stoull(ans);\\n            if(split(i+1, s, num))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    bool split(int idx, string &s, unsigned long long num)\\n    {\\n        if(idx == n)\\n            return true;\\n        string ans = \"\";\\n        for(int i = idx; i < n; i++)\\n        {\\n            ans += s[i];\\n            unsigned long long val = stoull(ans);\\n            if(val != num-1)\\n                continue;\\n            if(split(i+1, s, val))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        n = s.size();\\n        string ans = \"\";\\n        for(int i = 0; i < n-1; i++)\\n        {\\n            ans += s[i];\\n            unsigned long long num = stoull(ans);\\n            if(split(i+1, s, num))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188541,
                "title": "simple-python-3",
                "content": "This solution adds a default paramater to the given function to avoid having to define a dfs function inside the existing function.\\n\\n```python\\nclass Solution:\\n    def splitString(self, s: str, last_val: int = None) -> bool:\\n        # Base case, remaining string is a valid solution\\n        if last_val and int(s) == last_val - 1:\\n            return True\\n\\n\\t\\t# Iterate through increasingly larger slices of s\\n        for i in range(1, len(s)):\\n            cur = int(s[:i])\\n\\t\\t\\t# If current slice is equal to last_val - 1, make\\n\\t\\t\\t# recursive call with remaining string and updated last_val\\n            if last_val is None or cur == last_val - 1:\\n                if self.splitString(s[i:], cur):\\n                    return True\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def splitString(self, s: str, last_val: int = None) -> bool:\\n        # Base case, remaining string is a valid solution\\n        if last_val and int(s) == last_val - 1:\\n            return True\\n\\n\\t\\t# Iterate through increasingly larger slices of s\\n        for i in range(1, len(s)):\\n            cur = int(s[:i])\\n\\t\\t\\t# If current slice is equal to last_val - 1, make\\n\\t\\t\\t# recursive call with remaining string and updated last_val\\n            if last_val is None or cur == last_val - 1:\\n                if self.splitString(s[i:], cur):\\n                    return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662405,
                "title": "simple-python-solution-dfs",
                "content": "```\\ndef splitString(self, s):\\n\\n\\tdef dfs(start, last):\\n\\t\\tres = False\\n\\t\\tfor k in range(1, len(s)-last+1):\\n\\t\\t\\tif (int(s[start:last])-int(s[last:last+k])) == 1:\\n\\t\\t\\t\\tif dfs(last, last+k):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tres = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres = False\\n\\t\\treturn res\\n\\n\\tfor i in range(1, len(s)):\\n\\t\\tif dfs(0, i):\\n\\t\\t\\treturn True\\n\\t\\t\\t\\n\\treturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\ndef splitString(self, s):\\n\\n\\tdef dfs(start, last):\\n\\t\\tres = False\\n\\t\\tfor k in range(1, len(s)-last+1):\\n\\t\\t\\tif (int(s[start:last])-int(s[last:last+k])) == 1:\\n\\t\\t\\t\\tif dfs(last, last+k):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tres = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres = False\\n\\t\\treturn res\\n\\n\\tfor i in range(1, len(s)):\\n\\t\\tif dfs(0, i):\\n\\t\\t\\treturn True\\n\\t\\t\\t\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1191740,
                "title": "simple-basic-backtracking-solution-bf-faster-than-70-c-solution-c",
                "content": "\\n\\t  void fun(string &s,int start,vector<vector<string>> &res,vector<string> &cont)\\n    {\\n        //PRUNING\\n         if(cont.size()>0 && cont[0].size()==s.size())return;\\n        if(cont.size()>=2)\\n        {\\n            for(int j=0;j<cont.size()-1;j++)\\n            {\\n                unsigned long long int x1= stoull(cont[j]);\\n               unsigned long long int x2= stoull(cont[j+1]);\\n                if(x1!=x2+1)return;}\\n        }\\n        //base case\\n        if(start==s.size())\\n        {\\n            res.push_back(cont);\\n            return;\\n        }\\n        \\n        //resursive step\\n        for(int i=1;i<=s.size()-start;i++)\\n        {\\n            cont.push_back(s.substr(start,i));\\n            fun(s,start+i,res,cont);\\n            cont.pop_back();\\n        }\\n    }\\n    bool splitString(string s) {\\n        vector<vector<string>> res;\\n        vector<string> cont;\\n        fun(s,0,res,cont);\\n        return res.size()>=1?true:false;\\n    }",
                "solutionTags": [
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "\\n\\t  void fun(string &s,int start,vector<vector<string>> &res,vector<string> &cont)\\n    {\\n        //PRUNING\\n         if(cont.size()>0 && cont[0].size()==s.size())return;\\n        if(cont.size()>=2)\\n        {\\n            for(int j=0;j<cont.size()-1;j++)\\n            {\\n                unsigned long long int x1= stoull(cont[j]);\\n               unsigned long long int x2= stoull(cont[j+1]);\\n                if(x1!=x2+1)return;}\\n        }\\n        //base case\\n        if(start==s.size())\\n        {\\n            res.push_back(cont);\\n            return;\\n        }\\n        \\n        //resursive step\\n        for(int i=1;i<=s.size()-start;i++)\\n        {\\n            cont.push_back(s.substr(start,i));\\n            fun(s,start+i,res,cont);\\n            cont.pop_back();\\n        }\\n    }\\n    bool splitString(string s) {\\n        vector<vector<string>> res;\\n        vector<string> cont;\\n        fun(s,0,res,cont);\\n        return res.size()>=1?true:false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2923088,
                "title": "java-runtime-0-ms-beats-100-easy-to-understand",
                "content": "# please up-vote:)\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long num = 0;\\n        for(int i = 0; i < s.length() - 1; i++){\\n            num = num * 10 + (int)(s.charAt(i) - \\'0\\');\\n            if(canSplitString(s, i+1, num - 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean canSplitString(String s, int index, long nextVal){\\n        if(index == s.length())\\n            return true;\\n        long num = 0;\\n        for(int i = index; i < s.length(); i++){\\n            num = num * 10 + (int)(s.charAt(i) - \\'0\\');\\n            if(num == nextVal) \\n                return canSplitString(s, i+1, nextVal == 0? 0 : nextVal - 1);\\n            if(num > nextVal)\\n                break;\\n        }\\n        return false;\\n    }\\n}\\n```\\nthis line: ```nextVal == 0? 0 : nextVal - 1``` \\nis for handling cases like \"20010000\" with trailing zeros.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long num = 0;\\n        for(int i = 0; i < s.length() - 1; i++){\\n            num = num * 10 + (int)(s.charAt(i) - \\'0\\');\\n            if(canSplitString(s, i+1, num - 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean canSplitString(String s, int index, long nextVal){\\n        if(index == s.length())\\n            return true;\\n        long num = 0;\\n        for(int i = index; i < s.length(); i++){\\n            num = num * 10 + (int)(s.charAt(i) - \\'0\\');\\n            if(num == nextVal) \\n                return canSplitString(s, i+1, nextVal == 0? 0 : nextVal - 1);\\n            if(num > nextVal)\\n                break;\\n        }\\n        return false;\\n    }\\n}\\n```\n```nextVal == 0? 0 : nextVal - 1```",
                "codeTag": "Java"
            },
            {
                "id": 2726640,
                "title": "python-3-9-lines-dfs-slices-t-m-100-74",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        def dfs(s, prev = None):\\n\\n            if int(s) == prev - 1: return True\\n\\n            for i in range(1, len(s)+1):\\n                curr = int(s[:i])\\n                if curr == prev - 1 and dfs(s[i:], curr): return True\\n                \\n            return False\\n        \\n        for i in range(1, len(s)):\\n            if dfs(s[i:], int(s[:i])): return True\\n\\n        return False\\n```\\n[https://leetcode.com/submissions/detail/826781820/](http://)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        def dfs(s, prev = None):\\n\\n            if int(s) == prev - 1: return True\\n\\n            for i in range(1, len(s)+1):\\n                curr = int(s[:i])\\n                if curr == prev - 1 and dfs(s[i:], curr): return True\\n                \\n            return False\\n        \\n        for i in range(1, len(s)):\\n            if dfs(s[i:], int(s[:i])): return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194674,
                "title": "100-faster-cpp-solution-backtracking-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int mx=9999999999; // as max of s.size()==20 so if any number exceeds mx it will not be valid as we will not be able to make two partitions then, according to the situation given. \\n    bool helper(string& s,int i,int j,long long int prev,int n)\\n    {\\n       // if we are at the last index then, we have to just check if the (prev-pres)==1.\\n       // if that condition is true, then it means we got a correct match\\n        if(j==n-1)\\n        {\\n            string str=s.substr(i,j-i+1);\\n            long long int pres=stoll(str);\\n            if(prev-pres==1)\\n                return true;\\n            return false;\\n        }\\n           bool m=false;\\n           string str=s.substr(i,j-i+1);\\n           long long int pres=stoll(str); \\n           if(pres>mx)\\n               return false;\\n            if(prev==-1 || prev-pres==1)\\n                m=m || helper(s,j+1,j+1,pres,n); // in this step we are calling the function  keeping in mind that we have found the integer till this index and freshly calculating the integer from the next index, that\\'s why passed (j+1,j+1) inside the function. \\n            \\n        m=m || helper(s,i,j+1,prev,n);  // in this step we are calling the function keeping in mind that we will extend the integer to the next index and passing the prev val as it is. \\n        \\n        return m; \\n    }\\n    bool splitString(string s) {\\n        int n=s.size();\\n        long long int prev=-1;\\n        return helper(s,0,0,prev,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int mx=9999999999; // as max of s.size()==20 so if any number exceeds mx it will not be valid as we will not be able to make two partitions then, according to the situation given. \\n    bool helper(string& s,int i,int j,long long int prev,int n)\\n    {\\n       // if we are at the last index then, we have to just check if the (prev-pres)==1.\\n       // if that condition is true, then it means we got a correct match\\n        if(j==n-1)\\n        {\\n            string str=s.substr(i,j-i+1);\\n            long long int pres=stoll(str);\\n            if(prev-pres==1)\\n                return true;\\n            return false;\\n        }\\n           bool m=false;\\n           string str=s.substr(i,j-i+1);\\n           long long int pres=stoll(str); \\n           if(pres>mx)\\n               return false;\\n            if(prev==-1 || prev-pres==1)\\n                m=m || helper(s,j+1,j+1,pres,n); // in this step we are calling the function  keeping in mind that we have found the integer till this index and freshly calculating the integer from the next index, that\\'s why passed (j+1,j+1) inside the function. \\n            \\n        m=m || helper(s,i,j+1,prev,n);  // in this step we are calling the function keeping in mind that we will extend the integer to the next index and passing the prev val as it is. \\n        \\n        return m; \\n    }\\n    bool splitString(string s) {\\n        int n=s.size();\\n        long long int prev=-1;\\n        return helper(s,0,0,prev,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194544,
                "title": "c-greedy-method-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Splitting a String Into Descending Consecutive Values.\\nMemory Usage: 5.9 MB, less than 78.87% of C++ online submissions for Splitting a String Into Descending Consecutive Values.\\n\\n```\\nclass Solution {\\n\\tbool dfs(int index, long long firstVal, string& str)\\n\\t{\\n\\t\\tif (index == str.length())\\n\\t\\t\\treturn true;\\n\\n\\t\\tfor (int j = index; j < str.length(); j++) {\\n\\t\\t\\tlong long secondVal = stoll(str.substr(index, j - index + 1));\\n\\n\\t\\t\\t//If current val is 1 less than prev, then proceed for further valuation\\n\\t\\t\\tif (secondVal + 1 == firstVal && dfs(j + 1, secondVal, str))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t//if current val is greater than prev value then no point in proceeding further\\n\\t\\t\\telse if (secondVal > firstVal)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\npublic:\\n\\n\\tbool splitString(string s)\\n\\t{\\n\\t\\t//take out leading zeros\\n\\t\\twhile (s[0] == \\'0\\') {\\n\\t\\t\\ts.erase(0, 1);\\n\\t\\t}\\n\\n\\t\\tint len = s.length();\\n\\n\\t\\t//special case: if len is 1 then it has to be false\\n\\t\\tif (len == 1)\\n\\t\\t\\treturn false;\\n\\n\\t\\t//max length of first number can be half of original string length\\n\\t\\tif (len % 2 == 0)\\n\\t\\t\\tlen = len / 2;\\n\\t\\telse\\n\\t\\t\\tlen = (len / 2) + 1;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tlong long firstVal = stoll(s.substr(0, i + 1));\\n\\t\\t\\tif (dfs(i + 1, firstVal, s))\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\tbool dfs(int index, long long firstVal, string& str)\\n\\t{\\n\\t\\tif (index == str.length())\\n\\t\\t\\treturn true;\\n\\n\\t\\tfor (int j = index; j < str.length(); j++) {\\n\\t\\t\\tlong long secondVal = stoll(str.substr(index, j - index + 1));\\n\\n\\t\\t\\t//If current val is 1 less than prev, then proceed for further valuation\\n\\t\\t\\tif (secondVal + 1 == firstVal && dfs(j + 1, secondVal, str))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t//if current val is greater than prev value then no point in proceeding further\\n\\t\\t\\telse if (secondVal > firstVal)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\npublic:\\n\\n\\tbool splitString(string s)\\n\\t{\\n\\t\\t//take out leading zeros\\n\\t\\twhile (s[0] == \\'0\\') {\\n\\t\\t\\ts.erase(0, 1);\\n\\t\\t}\\n\\n\\t\\tint len = s.length();\\n\\n\\t\\t//special case: if len is 1 then it has to be false\\n\\t\\tif (len == 1)\\n\\t\\t\\treturn false;\\n\\n\\t\\t//max length of first number can be half of original string length\\n\\t\\tif (len % 2 == 0)\\n\\t\\t\\tlen = len / 2;\\n\\t\\telse\\n\\t\\t\\tlen = (len / 2) + 1;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tlong long firstVal = stoll(s.substr(0, i + 1));\\n\\t\\t\\tif (dfs(i + 1, firstVal, s))\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190201,
                "title": "simple-recursion-do-take-care-of-overflow",
                "content": "If you know recursion well then you know how easy it was to come up with simple recursive logic, just one line - \"Make the first number and check and buil on it\"\\nBut were you able to manage the Overflows !?\\n\\n**Hint for recursion :**\\n* start building the very first number from string and check if it is possible to complete the sequence , (make previous number from remaining string)\\n* isPossible function takes few parameters ( string s, currIndex i, targetNumber)\\n* if index has reached the end then return true as we have finished the string successfully\\n* if we have made the number then call for recursion again from next index and targetNumber-1\\n\\n**-> points to remember** \\n1. make sure that you are managing the overflows, if at any point your firstNumber or currNumber becomes greater than 10^11 then return false as maxLength Constraints is given to be 20 characters\\n```\\nbool isPossible(string &s, int index, unsigned long long targetNumber)\\n{\\n    if(index == s.length())            \\n        return 1;\\n    unsigned long long currNumber = 0;\\n    while(index < s.length())\\n    {\\n        currNumber = currNumber*10 + s[index] - \\'0\\';\\n        if(currNumber == targetNumber and isPossible(s , index+1 , targetNumber-1))\\n            return true;\\n        if(currNumber > targetNumber)\\n            return false;\\n        index++;\\n    }\\n    return 0;\\n}\\nbool splitString(string s) \\n{\\n    unsigned long long firstNumber = 0;\\n    for(int index=0; index<s.length()-1 ; index++)\\n    {\\n        firstNumber = firstNumber*10 + (s[index] - \\'0\\');            \\n        if(firstNumber > 1e17+1)\\n            return false;\\n        if(isPossible(s , index+1 , firstNumber-1))\\n            return 1;\\n    }\\n    return 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPossible(string &s, int index, unsigned long long targetNumber)\\n{\\n    if(index == s.length())            \\n        return 1;\\n    unsigned long long currNumber = 0;\\n    while(index < s.length())\\n    {\\n        currNumber = currNumber*10 + s[index] - \\'0\\';\\n        if(currNumber == targetNumber and isPossible(s , index+1 , targetNumber-1))\\n            return true;\\n        if(currNumber > targetNumber)\\n            return false;\\n        index++;\\n    }\\n    return 0;\\n}\\nbool splitString(string s) \\n{\\n    unsigned long long firstNumber = 0;\\n    for(int index=0; index<s.length()-1 ; index++)\\n    {\\n        firstNumber = firstNumber*10 + (s[index] - \\'0\\');            \\n        if(firstNumber > 1e17+1)\\n            return false;\\n        if(isPossible(s , index+1 , firstNumber-1))\\n            return 1;\\n    }\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187660,
                "title": "python-recursive-with-my-intuition",
                "content": "Intuition\\n\\n1.  Given a string \"050043\"\\n2.  Find a 1st possible number (05) with the string \"050043\"\\n3.  Call dfs() function to see if there is a number 5\\n4.  If so, then find the next number \"004\" (which is smaller than 5 by 1) and \"0043\" & continue to call dfs() until the end\\n5.  If 3 and \"3\" are the same and it\\'s the last string, set ans = True\\n* Use the level for edge cases, since 100 => True but 00 => False (maybe it\\'s the last test case)\\n\\nMy approach solved 172 out of 173 test cases and failed for the last one.\\nThe most tricky part of this problem for me was how to handle zeros because they can either (1) form a part of numbers or (2) just sit there as leading or trailing zeros.\\n* (1) 200100 => True [2,1] , 10110099 => True [101,100,99]\\n* (2) 1000 => True [1,0] , 00 => False\\n* (3) 10100010099 => True [101,100,99] (mixed with (1) and (2) cases)\\n\\n```\\n    def splitString(self, s: str) -> bool:\\n\\n        ans = False\\n\\t\\t# recursive call\\n        def dfs(x:int, y:str, level: int):\\n            nonlocal ans\\n\\n            if x < 0 : return\\n            if len(y) == 0 or  (x == int(y) and level > 0):\\n                ans = True\\n\\n            for j in range(1,len(y)):\\n                if x == int(y[:j]):\\n                    dfs(x-1, y[j:], level + 1)\\n\\t\\t\\t\\t\\n\\t\\t# main \\n        for i in range(1,len(s)):\\n            dfs(int(s[:i]),s, 0)\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def splitString(self, s: str) -> bool:\\n\\n        ans = False\\n\\t\\t# recursive call\\n        def dfs(x:int, y:str, level: int):\\n            nonlocal ans\\n\\n            if x < 0 : return\\n            if len(y) == 0 or  (x == int(y) and level > 0):\\n                ans = True\\n\\n            for j in range(1,len(y)):\\n                if x == int(y[:j]):\\n                    dfs(x-1, y[j:], level + 1)\\n\\t\\t\\t\\t\\n\\t\\t# main \\n        for i in range(1,len(s)):\\n            dfs(int(s[:i]),s, 0)\\n\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1786073,
                "title": "backtracking-in-python",
                "content": "Split the input string `s` into possible pieces, and check recursively when it\\'s 1 smaller than the previous value.\\nNote that the string must be split into two or more pieces, so I added an argument `parts` to manage the number of split pieces.\\n\\n```\\nimport math\\n\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def rec(idx, parts, prev_val):\\n            if idx == L:\\n                return parts >= 2\\n            \\n            for i in range(idx, L):\\n                num = int(s[idx : i + 1])\\n                if prev_val == math.inf or num == prev_val - 1:\\n                    if rec(i + 1, parts + 1, num):\\n                        return True\\n            return False\\n        \\n        L = len(s)\\n        return rec(0, 0, math.inf)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def rec(idx, parts, prev_val):\\n            if idx == L:\\n                return parts >= 2\\n            \\n            for i in range(idx, L):\\n                num = int(s[idx : i + 1])\\n                if prev_val == math.inf or num == prev_val - 1:\\n                    if rec(i + 1, parts + 1, num):\\n                        return True\\n            return False\\n        \\n        L = len(s)\\n        return rec(0, 0, math.inf)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720660,
                "title": "java-post-my-one-pass-dfs-solution-with-pruning-0ms-runtime-beat-100",
                "content": "Post my 0ms runtime solution.\\n\\nThe idea is to generate a starting number so that we don\\'t need to backtrack, and the target number can also be used for tree pruning.\\n\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long currNum = 0;\\n        for (int i = 0; i < s.length() - 1; i++) { // must split into at least two numbers, so i < s.length() - 1\\n            currNum = currNum * 10 + (s.charAt(i) - \\'0\\');\\n            if (currNum > 0 && splitStringAfter(s, i + 1, currNum - 1)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean splitStringAfter(String s, int index, long targetNum) {\\n        if (index == s.length()) {\\n            return true;\\n        }\\n        \\n        long currNum = 0;\\n        for (int i = index; i < s.length(); i++) {\\n            currNum = currNum * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\t// If targetNum == 0, we need to check all the remaining characters instead of spliting another number\\n            if (currNum == targetNum && targetNum > 0) {\\n                return splitStringAfter(s, i + 1, currNum - 1);\\n            } else if (currNum > targetNum) { // Stop the loop if the current number is greater than target.\\n                return false;\\n            }\\n        }\\n        return currNum == targetNum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long currNum = 0;\\n        for (int i = 0; i < s.length() - 1; i++) { // must split into at least two numbers, so i < s.length() - 1\\n            currNum = currNum * 10 + (s.charAt(i) - \\'0\\');\\n            if (currNum > 0 && splitStringAfter(s, i + 1, currNum - 1)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean splitStringAfter(String s, int index, long targetNum) {\\n        if (index == s.length()) {\\n            return true;\\n        }\\n        \\n        long currNum = 0;\\n        for (int i = index; i < s.length(); i++) {\\n            currNum = currNum * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\t// If targetNum == 0, we need to check all the remaining characters instead of spliting another number\\n            if (currNum == targetNum && targetNum > 0) {\\n                return splitStringAfter(s, i + 1, currNum - 1);\\n            } else if (currNum > targetNum) { // Stop the loop if the current number is greater than target.\\n                return false;\\n            }\\n        }\\n        return currNum == targetNum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187926,
                "title": "python-beat-100-super-simple",
                "content": "Recursion logic:\\n- if the last number is x, then we need to check if the string contains a number x - 1 after x, if we found a number ,we increment the count and make sure we can at least find 2 substring\\n\\nEdge cases:\\n - numbers with leading zero, need not to count the zeros,  in python, simply do **len(str(num))**\\n```\\n    def splitString(self, s: str) -> bool:\\n        def dfs(last, cur, count):\\n            if cur == len(s) and count > 1:\\n                return True \\n            for j in range(cur, len(s) + 1):\\n                try:\\n                    num = int(s[cur:j])\\n                    if num == last - 1:\\n                        if dfs(num, j, count + 1):\\n                            return True \\n                except:\\n                    pass \\n            return False \\n        for l in range(len(s)):\\n            try:\\n                num = int(s[:l])\\n                if dfs(num, l, 1):\\n                    return True\\n            except:\\n                pass\\n        return False \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    def splitString(self, s: str) -> bool:\\n        def dfs(last, cur, count):\\n            if cur == len(s) and count > 1:\\n                return True \\n            for j in range(cur, len(s) + 1):\\n                try:\\n                    num = int(s[cur:j])\\n                    if num == last - 1:\\n                        if dfs(num, j, count + 1):\\n                            return True \\n                except:\\n                    pass \\n            return False \\n        for l in range(len(s)):\\n            try:\\n                num = int(s[:l])\\n                if dfs(num, l, 1):\\n                    return True\\n            except:\\n                pass\\n        return False \\n                \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1187486,
                "title": "java-recursion-beats-100-0ms-t-c-o-2-n-s-c-o-n",
                "content": "\\n    // O(2^n) O(n)\\n    public boolean splitString(String s) {\\n\\t\\n\\t\\tint len = s.length(), curr = 0;\\n\\t\\tfor (int i = 0; i < len - 1; i++) {\\n\\t\\t\\tcurr = curr * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\tboolean flag = splitStringHelper(s, i + 1, curr, len);\\n\\t\\t\\tif (flag)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n    // O(2^n) O(n)\\n\\tpublic boolean splitStringHelper(String s, int idx, int prev, int len) {\\n\\n\\t\\tif (idx == len)\\n\\t\\t\\treturn true;\\n\\n\\t\\tint curr = 0;\\n\\t\\tfor (int i = idx; i < len; i++) {\\n\\t\\t\\tcurr = curr * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\tif (prev - curr == 1) {\\n\\t\\t\\t\\tboolean flag = splitStringHelper(s, i + 1, curr, len);\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(2^n) O(n)\\n    public boolean splitString(String s) {\\n\\t\\n\\t\\tint len = s.length(), curr = 0;\\n\\t\\tfor (int i = 0; i < len - 1; i++) {\\n\\t\\t\\tcurr = curr * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\tboolean flag = splitStringHelper(s, i + 1, curr, len);\\n\\t\\t\\tif (flag)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n    // O(2^n) O(n)\\n\\tpublic boolean splitStringHelper(String s, int idx, int prev, int len) {\\n\\n\\t\\tif (idx == len)\\n\\t\\t\\treturn true;\\n\\n\\t\\tint curr = 0;\\n\\t\\tfor (int i = idx; i < len; i++) {\\n\\t\\t\\tcurr = curr * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\tif (prev - curr == 1) {\\n\\t\\t\\t\\tboolean flag = splitStringHelper(s, i + 1, curr, len);\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1186878,
                "title": "python-3-backtracking",
                "content": "Split the string at i, progress when the previous num is greater then the current number by 1.\\nUse extra space to store where we are at, so it is easier to end the recursion, backtract if it doesn\\'t work out.\\n\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        for i in range(len(s)-1):\\n            if self.backtrack(s, int(s[:i+1]), i+1, [s[:i+1]]):\\n                return True\\n        \\n        return False\\n        \\n    \\n    def backtrack(self, s, pre, index, cur):\\n        if \"\".join(cur) == s:\\n            return True\\n        \\n        for i in range(index, len(s)):\\n            if pre - 1 == int(s[index:i+1]):\\n                cur.append(s[index:i+1])\\n                if self.backtrack(s, int(s[index:i+1]), i+1, cur):\\n                    return True\\n                cur.pop()\\n        \\n        return False",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "Split the string at i, progress when the previous num is greater then the current number by 1.\\nUse extra space to store where we are at, so it is easier to end the recursion, backtract if it doesn\\'t work out.\\n\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        for i in range(len(s)-1):\\n            if self.backtrack(s, int(s[:i+1]), i+1, [s[:i+1]]):\\n                return True\\n        \\n        return False\\n        \\n    \\n    def backtrack(self, s, pre, index, cur):\\n        if \"\".join(cur) == s:\\n            return True\\n        \\n        for i in range(index, len(s)):\\n            if pre - 1 == int(s[index:i+1]):\\n                cur.append(s[index:i+1])\\n                if self.backtrack(s, int(s[index:i+1]), i+1, cur):\\n                    return True\\n                cur.pop()\\n        \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 3223985,
                "title": "python3-easiest-solution-beats-85-users-simplest-backtracking",
                "content": "```\\n\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(index,prevVal):\\n            if index==len(s):\\n                return True\\n            for j in range(index,len(s)):\\n                val=int(s[index:j+1])\\n                if prevVal-val==1 and dfs(j+1,val):\\n                    return True\\n            return False\\n        for i in range(len(s)-1):\\n            val=int(s[:i+1])\\n            if dfs(i+1,val):\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(index,prevVal):\\n            if index==len(s):\\n                return True\\n            for j in range(index,len(s)):\\n                val=int(s[index:j+1])\\n                if prevVal-val==1 and dfs(j+1,val):\\n                    return True\\n            return False\\n        for i in range(len(s)-1):\\n            val=int(s[:i+1])\\n            if dfs(i+1,val):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256113,
                "title": "c-java-python-easy-and-clean-backtracking",
                "content": "**C++**\\n\\n```cpp\\nclass Solution {\\n public:\\n  bool splitString(string s) {\\n    return isValid(s, 0, -1, 0);\\n  }\\n\\n private:\\n  bool isValid(const string& s, int start, long prev, int segment) {\\n    if (start == s.length() && segment > 1)\\n      return true;\\n\\n    long curr = 0;\\n    for (int i = start; i < s.length(); ++i) {\\n      curr = curr * 10 + s[i] - \\'0\\';\\n      if (curr > 9999999999L)\\n        return false;\\n      if ((prev == -1 || curr == prev - 1) &&\\n          isValid(s, i + 1, curr, segment + 1)) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n};\\n```\\n\\n**Java**\\n\\n```java\\nclass Solution {\\n  public boolean splitString(String s) {\\n    return isValid(s, 0, -1, 0);\\n  }\\n\\n  private boolean isValid(final String s, int start, long prev, int segment) {\\n    if (start == s.length() && segment > 1)\\n      return true;\\n\\n    long curr = 0;\\n    for (int i = start; i < s.length(); ++i) {\\n      curr = curr * 10 + s.charAt(i) - \\'0\\';\\n      if (curr > 9999999999)\\n        return false;\\n      if ((prev == -1 || curr == prev - 1) && isValid(s, i + 1, curr, segment + 1))\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n```\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n  def splitString(self, s: str) -> bool:\\n    def isValid(s: str, start: int, prev: int, segment: int) -> bool:\\n      if start == len(s) and segment > 1:\\n        return True\\n\\n      curr = 0\\n      for i in range(start, len(s)):\\n        curr = curr * 10 + ord(s[i]) - ord(\\'0\\')\\n        if curr > 9999999999:\\n          return False\\n        if (prev == -1 or curr == prev - 1) and isValid(s, i + 1, curr, segment + 1):\\n          return True\\n\\n      return False\\n\\n    return isValid(s, 0, -1, 0)\\n```\\n\\nTime: `O(2^n)`\\nSpace: `O(n)`",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\n public:\\n  bool splitString(string s) {\\n    return isValid(s, 0, -1, 0);\\n  }\\n\\n private:\\n  bool isValid(const string& s, int start, long prev, int segment) {\\n    if (start == s.length() && segment > 1)\\n      return true;\\n\\n    long curr = 0;\\n    for (int i = start; i < s.length(); ++i) {\\n      curr = curr * 10 + s[i] - \\'0\\';\\n      if (curr > 9999999999L)\\n        return false;\\n      if ((prev == -1 || curr == prev - 1) &&\\n          isValid(s, i + 1, curr, segment + 1)) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n};\\n```\n```java\\nclass Solution {\\n  public boolean splitString(String s) {\\n    return isValid(s, 0, -1, 0);\\n  }\\n\\n  private boolean isValid(final String s, int start, long prev, int segment) {\\n    if (start == s.length() && segment > 1)\\n      return true;\\n\\n    long curr = 0;\\n    for (int i = start; i < s.length(); ++i) {\\n      curr = curr * 10 + s.charAt(i) - \\'0\\';\\n      if (curr > 9999999999)\\n        return false;\\n      if ((prev == -1 || curr == prev - 1) && isValid(s, i + 1, curr, segment + 1))\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n```\n```python\\nclass Solution:\\n  def splitString(self, s: str) -> bool:\\n    def isValid(s: str, start: int, prev: int, segment: int) -> bool:\\n      if start == len(s) and segment > 1:\\n        return True\\n\\n      curr = 0\\n      for i in range(start, len(s)):\\n        curr = curr * 10 + ord(s[i]) - ord(\\'0\\')\\n        if curr > 9999999999:\\n          return False\\n        if (prev == -1 or curr == prev - 1) and isValid(s, i + 1, curr, segment + 1):\\n          return True\\n\\n      return False\\n\\n    return isValid(s, 0, -1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227555,
                "title": "java-backtracking-easy-to-understand-4ms",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        for(int i = 1; i <= s.length(); i++){\\n            for(int j = i+1; j <= s.length(); j++){\\n                if(s.substring(0, i).length() > 0 && s.substring(i, j).length() > 0  ) \\n                {\\n                    try{\\n                        long a = Long.parseLong(s.substring(0, i));\\n                        long b = Long.parseLong(s.substring(i, j));\\n                        if(a == b+1 && gg(s.substring(j), b)){\\n                            return true;\\n                        }    \\n                    }\\n                    catch(Exception e){\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    public boolean gg(String s, long prev){\\n        \\n        if(s.length() == 0) return true;\\n        \\n        for(int i = 1; i <= s.length(); i++){\\n            if(s.substring(0, i).length() > 0 ) {\\n                long a = Long.parseLong(s.substring(0, i));\\n                if(prev == a + 1){\\n                    if(gg(s.substring(i), a))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        for(int i = 1; i <= s.length(); i++){\\n            for(int j = i+1; j <= s.length(); j++){\\n                if(s.substring(0, i).length() > 0 && s.substring(i, j).length() > 0  ) \\n                {\\n                    try{\\n                        long a = Long.parseLong(s.substring(0, i));\\n                        long b = Long.parseLong(s.substring(i, j));\\n                        if(a == b+1 && gg(s.substring(j), b)){\\n                            return true;\\n                        }    \\n                    }\\n                    catch(Exception e){\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    public boolean gg(String s, long prev){\\n        \\n        if(s.length() == 0) return true;\\n        \\n        for(int i = 1; i <= s.length(); i++){\\n            if(s.substring(0, i).length() > 0 ) {\\n                long a = Long.parseLong(s.substring(0, i));\\n                if(prev == a + 1){\\n                    if(gg(s.substring(i), a))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202698,
                "title": "c-backtracking-0ms-simple-solution",
                "content": "```\\n bool Word(string s,long long num){\\n        if(s.size()==0){\\n            return true;\\n        }\\n        for(int i=0;i<s.size();i++){\\n            string lfw=s.substr(0,i+1);\\n            string right=s.substr(i+1);\\n            unsigned long long l2=stoull(lfw);\\n            if(num-l2==1 && Word(right,l2) ){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    bool splitString(string s) {\\n       for(int i=0;i<s.size()-1;i++){\\n           string tmp=s.substr(0,i+1);\\n           unsigned long long num=stoull(tmp);\\n           if(Word(s.substr(i+1),num)){\\n               return true;\\n           }\\n       }\\n       \\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool Word(string s,long long num){\\n        if(s.size()==0){\\n            return true;\\n        }\\n        for(int i=0;i<s.size();i++){\\n            string lfw=s.substr(0,i+1);\\n            string right=s.substr(i+1);\\n            unsigned long long l2=stoull(lfw);\\n            if(num-l2==1 && Word(right,l2) ){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    bool splitString(string s) {\\n       for(int i=0;i<s.size()-1;i++){\\n           string tmp=s.substr(0,i+1);\\n           unsigned long long num=stoull(tmp);\\n           if(Word(s.substr(i+1),num)){\\n               return true;\\n           }\\n       }\\n       \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195215,
                "title": "python3-dfs-memo",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str, sentinel = int(1e9 + 7)) -> bool:\\n        N = len(s)\\n        ok = lambda pre, cur: pre == sentinel or pre == 1 + cur  # \\u2705 monotonically decreasing\\n        @cache                                                   # \\uD83E\\uDD14 memo\\n        def go(i = 0, pre = sentinel, steps = -1):\\n            if i == N:\\n                return 0 < steps                                 # \\uD83D\\uDED1 base case\\n            for j in range(i + 1, N + 1):\\n                cur = int(s[i:j])\\n                if ok(pre, cur) and go(j, cur, 1 + steps):       # \\uD83D\\uDE80 recursive case\\n                    return True\\n            return False\\n        return go()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str, sentinel = int(1e9 + 7)) -> bool:\\n        N = len(s)\\n        ok = lambda pre, cur: pre == sentinel or pre == 1 + cur  # \\u2705 monotonically decreasing\\n        @cache                                                   # \\uD83E\\uDD14 memo\\n        def go(i = 0, pre = sentinel, steps = -1):\\n            if i == N:\\n                return 0 < steps                                 # \\uD83D\\uDED1 base case\\n            for j in range(i + 1, N + 1):\\n                cur = int(s[i:j])\\n                if ok(pre, cur) and go(j, cur, 1 + steps):       # \\uD83D\\uDE80 recursive case\\n                    return True\\n            return False\\n        return go()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190158,
                "title": "easy-c-solution",
                "content": "```\\nbool splitString(string s) {\\n        bool ans = false;\\n        for(int i=0;i<s.length()-1;i++){\\n            ans = ans || helper(s.substr(i+1),stoull(s.substr(0,i+1))-1);\\n            if(ans) return ans;\\n        }\\n        return ans;        \\n    }\\n    \\n    bool helper(string s, long long target){\\n        if(s.empty()){\\n            return true;\\n        }\\n        if(target==0){\\n            return stoull(s) == target;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(stoull(s.substr(0,i+1))==target){\\n                return helper(s.substr(i+1),target-1);\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool splitString(string s) {\\n        bool ans = false;\\n        for(int i=0;i<s.length()-1;i++){\\n            ans = ans || helper(s.substr(i+1),stoull(s.substr(0,i+1))-1);\\n            if(ans) return ans;\\n        }\\n        return ans;        \\n    }\\n    \\n    bool helper(string s, long long target){\\n        if(s.empty()){\\n            return true;\\n        }\\n        if(target==0){\\n            return stoull(s) == target;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(stoull(s.substr(0,i+1))==target){\\n                return helper(s.substr(i+1),target-1);\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1188655,
                "title": "backtracking-o-n-2-self-evident",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        //backtracking\\n        return dfs(s,0,0,-1);\\n    }\\n    private boolean dfs(String s, int prev, int i, int lastNum){\\n        int cur=prev*10+s.charAt(i)-\\'0\\';\\n        if (cur==lastNum-1){\\n            if (i+1>=s.length()){\\n                return true;\\n            }\\n            if (dfs(s,0,i+1,cur))\\n                return true;\\n            if (dfs(s,cur,i+1,lastNum))\\n                return true;\\n        } else {\\n            if (i+1>=s.length()){\\n                return false;\\n            }\\n            if (dfs(s,cur,i+1,lastNum))\\n                return true;\\n            if (lastNum==-1 && dfs(s,0,i+1,cur)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        //backtracking\\n        return dfs(s,0,0,-1);\\n    }\\n    private boolean dfs(String s, int prev, int i, int lastNum){\\n        int cur=prev*10+s.charAt(i)-\\'0\\';\\n        if (cur==lastNum-1){\\n            if (i+1>=s.length()){\\n                return true;\\n            }\\n            if (dfs(s,0,i+1,cur))\\n                return true;\\n            if (dfs(s,cur,i+1,lastNum))\\n                return true;\\n        } else {\\n            if (i+1>=s.length()){\\n                return false;\\n            }\\n            if (dfs(s,cur,i+1,lastNum))\\n                return true;\\n            if (lastNum==-1 && dfs(s,0,i+1,cur)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187320,
                "title": "c-recursion-with-condition-of-all-possible-substrings",
                "content": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    bool flag=false;\\n    void secondsubstring(string s, int idx, ll prev)\\n    {\\n        ll x = 0;\\n        if(idx>=s.size() || flag)\\n        {\\n            flag = true;\\n            return;\\n        }\\n        for(int i=idx; i<s.size(); i++)\\n        {\\n            x = x*10 + (s[i]-48);\\n            if(x>=1e11)\\n            {\\n                break;\\n            }\\n            if(x==prev-1)\\n            {\\n                secondsubstring(s, i+1, x);\\n            }\\n        }\\n        return;\\n    }\\n    bool splitString(string s) \\n    {\\n        ll x = 0;\\n        for (int i=0; i<s.size()-1; i++)\\n        {\\n            x = x*10 + (s[i]-48);\\n            if(x>=1e11)\\n            {\\n                break;\\n            }\\n            secondsubstring(s, i+1, x);\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    bool flag=false;\\n    void secondsubstring(string s, int idx, ll prev)\\n    {\\n        ll x = 0;\\n        if(idx>=s.size() || flag)\\n        {\\n            flag = true;\\n            return;\\n        }\\n        for(int i=idx; i<s.size(); i++)\\n        {\\n            x = x*10 + (s[i]-48);\\n            if(x>=1e11)\\n            {\\n                break;\\n            }\\n            if(x==prev-1)\\n            {\\n                secondsubstring(s, i+1, x);\\n            }\\n        }\\n        return;\\n    }\\n    bool splitString(string s) \\n    {\\n        ll x = 0;\\n        for (int i=0; i<s.size()-1; i++)\\n        {\\n            x = x*10 + (s[i]-48);\\n            if(x>=1e11)\\n            {\\n                break;\\n            }\\n            secondsubstring(s, i+1, x);\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186928,
                "title": "c-try-all-splits-that-has-diff-1-with-custom-diff-method",
                "content": "```csharp\\npublic bool SplitString(string s)\\n{\\n\\tbool result = canSplit(\"0\", s, 0, 0);\\n\\treturn result;\\n}\\n\\nprivate bool canSplit(string firstPart, string s, int start, int currentLength)\\n{\\n\\tif (start >= s.Length && currentLength != s.Length)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfor (int length = 1; length <= s.Length - start; length++)\\n\\t{\\n\\t\\tstring nextPart = s.Substring(start, length);\\n\\t\\tif ((start == 0 || hasDiffOne(firstPart, nextPart)) && canSplit(nextPart, s, start + length, length))\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n\\nprivate bool hasDiffOne(string first, string second)\\n{\\n\\tfirst = first.TrimStart(\\'0\\');\\n\\tsecond = second.TrimStart(\\'0\\');\\n\\n\\tif (string.IsNullOrEmpty(first) && string.IsNullOrEmpty(second))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif (string.IsNullOrEmpty(second))\\n\\t{\\n\\t\\treturn first == \"1\";\\n\\t}\\n\\n\\tif (string.IsNullOrEmpty(first))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tbool isLast = first[^1] - \\'0\\' == (second[^1]  - \\'0\\'  + 1) % 10;\\n\\tint carry = (second[^1] - \\'0\\' + 1) >= 10 ? 1 : 0;\\n\\n\\tif (!isLast)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tint i = first.Length - 2, j = second.Length - 2;\\n\\n\\twhile (i >= 0 && j >= 0)\\n\\t{\\n\\t\\tif ((first[i] - \\'0\\') != (second[j] - \\'0\\' + carry) % 10)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tcarry = (second[j] - \\'0\\' + carry) >= 10 ? 1 : 0;\\n\\t\\ti--;\\n\\t\\tj--;\\n\\t}\\n\\n\\tif (carry > 0)\\n\\t{\\n\\t\\treturn j == -1 && i == 0 && first[i] == \\'1\\';\\n\\t}\\n\\n\\treturn i == j;\\n}\\n```\\n\\nHowever, since there is requirement of atleast two string so max valid string length = 10, which easily fit into long and ignore otherwise.\\n\\n```csharp\\npublic bool SplitString(string s)\\n{\\n\\tbool result = canSplit(-1L, s, 0, 0);\\n\\treturn result;\\n}\\n\\nprivate bool canSplit(long firstPart, string s, int start, int currentLength)\\n{\\n\\tif (start >= s.Length && currentLength != s.Length)\\n\\t{\\n\\t\\treturn true;\\n\\t}      \\n\\n\\tfor (int length = 1; length <= s.Length - start; length++)\\n\\t{            \\n\\t\\tlong nextPart = 0L;\\n\\t\\tlong.TryParse(s.Substring(start, length), out nextPart);\\n\\n\\t\\tif ((start == 0 || firstPart - nextPart == 1L) && canSplit(nextPart, s, start + length, length))\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}        \\n\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic bool SplitString(string s)\\n{\\n\\tbool result = canSplit(\"0\", s, 0, 0);\\n\\treturn result;\\n}\\n\\nprivate bool canSplit(string firstPart, string s, int start, int currentLength)\\n{\\n\\tif (start >= s.Length && currentLength != s.Length)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfor (int length = 1; length <= s.Length - start; length++)\\n\\t{\\n\\t\\tstring nextPart = s.Substring(start, length);\\n\\t\\tif ((start == 0 || hasDiffOne(firstPart, nextPart)) && canSplit(nextPart, s, start + length, length))\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n\\nprivate bool hasDiffOne(string first, string second)\\n{\\n\\tfirst = first.TrimStart(\\'0\\');\\n\\tsecond = second.TrimStart(\\'0\\');\\n\\n\\tif (string.IsNullOrEmpty(first) && string.IsNullOrEmpty(second))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif (string.IsNullOrEmpty(second))\\n\\t{\\n\\t\\treturn first == \"1\";\\n\\t}\\n\\n\\tif (string.IsNullOrEmpty(first))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tbool isLast = first[^1] - \\'0\\' == (second[^1]  - \\'0\\'  + 1) % 10;\\n\\tint carry = (second[^1] - \\'0\\' + 1) >= 10 ? 1 : 0;\\n\\n\\tif (!isLast)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tint i = first.Length - 2, j = second.Length - 2;\\n\\n\\twhile (i >= 0 && j >= 0)\\n\\t{\\n\\t\\tif ((first[i] - \\'0\\') != (second[j] - \\'0\\' + carry) % 10)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tcarry = (second[j] - \\'0\\' + carry) >= 10 ? 1 : 0;\\n\\t\\ti--;\\n\\t\\tj--;\\n\\t}\\n\\n\\tif (carry > 0)\\n\\t{\\n\\t\\treturn j == -1 && i == 0 && first[i] == \\'1\\';\\n\\t}\\n\\n\\treturn i == j;\\n}\\n```\n```csharp\\npublic bool SplitString(string s)\\n{\\n\\tbool result = canSplit(-1L, s, 0, 0);\\n\\treturn result;\\n}\\n\\nprivate bool canSplit(long firstPart, string s, int start, int currentLength)\\n{\\n\\tif (start >= s.Length && currentLength != s.Length)\\n\\t{\\n\\t\\treturn true;\\n\\t}      \\n\\n\\tfor (int length = 1; length <= s.Length - start; length++)\\n\\t{            \\n\\t\\tlong nextPart = 0L;\\n\\t\\tlong.TryParse(s.Substring(start, length), out nextPart);\\n\\n\\t\\tif ((start == 0 || firstPart - nextPart == 1L) && canSplit(nextPart, s, start + length, length))\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}        \\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3357528,
                "title": "python-backtracking-solutions-2-branches-vs-n-branches",
                "content": "Solution 1: Path from source to node represents a candidate split of the string. Each node has two branches -- either include the current char in the split or don\\'t include and start a new split. Prune unnecessary paths by checking if the condition of consecutive and descending is maintained. Time complexity -- O(2^N) but in practice much faster due to pruning and early return once we find a valid split.\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(index, path):\\n            # pruning: checks if path breaks consecutive descending order\\n            if len(path) > 2 and int(path[-3]) != int(path[-2]) + 1:\\n                return False\\n\\n            # reaching leaf node means path has satisfied the requirements\\n            if index == len(s):\\n                return len(path) > 1 and int(path[-2]) == int(path[-1]) + 1\\n            \\n            # try to take this digit\\n            path[-1] += s[index]\\n            if dfs(index + 1, path.copy()):\\n                return True\\n            path[-1] = path[-1][:-1] # backtrack step\\n\\n            # try to start a new split \\n            path += s[index]\\n            if dfs(index + 1, path.copy()):\\n                return True\\n            path.pop() # backtrack step\\n\\n            # we cannot reach a leaf starting from this index and path\\n            return False\\n        \\n        if len(s) == 1: return False\\n        return dfs(1, [s[0]])\\n```\\n\\nSolution 2: Each node has `n` branches denoting where to split the string `s[i:]` into two substrings. Time complexity is O(N^N) but in practice much faster due to pruning. \\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, path):\\n            if i == len(s):\\n                return len(path) > 1\\n\\n            for j in range(i, len(s)):\\n                path.append(s[i:j + 1])\\n                if len(path) == 1 or int(path[-2]) == int(path[-1]) + 1:\\n                    if dfs(j + 1, path.copy()):\\n                        return True\\n                path.pop()\\n            \\n            return False\\n\\n        if len(s) == 1: return False\\n        return dfs(0, [])\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(index, path):\\n            # pruning: checks if path breaks consecutive descending order\\n            if len(path) > 2 and int(path[-3]) != int(path[-2]) + 1:\\n                return False\\n\\n            # reaching leaf node means path has satisfied the requirements\\n            if index == len(s):\\n                return len(path) > 1 and int(path[-2]) == int(path[-1]) + 1\\n            \\n            # try to take this digit\\n            path[-1] += s[index]\\n            if dfs(index + 1, path.copy()):\\n                return True\\n            path[-1] = path[-1][:-1] # backtrack step\\n\\n            # try to start a new split \\n            path += s[index]\\n            if dfs(index + 1, path.copy()):\\n                return True\\n            path.pop() # backtrack step\\n\\n            # we cannot reach a leaf starting from this index and path\\n            return False\\n        \\n        if len(s) == 1: return False\\n        return dfs(1, [s[0]])\\n```\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, path):\\n            if i == len(s):\\n                return len(path) > 1\\n\\n            for j in range(i, len(s)):\\n                path.append(s[i:j + 1])\\n                if len(path) == 1 or int(path[-2]) == int(path[-1]) + 1:\\n                    if dfs(j + 1, path.copy()):\\n                        return True\\n                path.pop()\\n            \\n            return False\\n\\n        if len(s) == 1: return False\\n        return dfs(0, [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291155,
                "title": "1849-splitting-a-string-into-descending-consecutive-values",
                "content": "\\tclass Solution:\\n\\t\\tdef splitString(self, s: str) -> bool:\\n\\t\\t\\tself.ans = False\\n\\t\\t\\tself.length = len(s)\\n\\t\\t\\tself.helper([],s,0)\\n\\t\\t\\treturn self.ans\\n\\n\\t\\tdef helper(self,arr,s,ind):    \\n\\t\\t\\tif not self.ans and ind < self.length:\\n\\t\\t\\t\\ttemp = \\'\\'\\n\\t\\t\\t\\tfor i in range(ind,self.length):\\n\\t\\t\\t\\t\\ttemp += s[i]\\n\\t\\t\\t\\t\\tif arr and int(arr[-1]) < int(temp):\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\t\\tif arr and int(arr[-1]) - int(temp) != 1:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tself.helper(arr+[temp],s,i+1)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tif len(arr)>1:\\n\\t\\t\\t\\tself.ans = True",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef splitString(self, s: str) -> bool:\\n\\t\\t\\tself.ans = False\\n\\t\\t\\tself.length = len(s)\\n\\t\\t\\tself.helper([],s,0)\\n\\t\\t\\treturn self.ans\\n\\n\\t\\tdef helper(self,arr,s,ind):    \\n\\t\\t\\tif not self.ans and ind < self.length:\\n\\t\\t\\t\\ttemp = \\'\\'\\n\\t\\t\\t\\tfor i in range(ind,self.length):\\n\\t\\t\\t\\t\\ttemp += s[i]\\n\\t\\t\\t\\t\\tif arr and int(arr[-1]) < int(temp):\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\t\\tif arr and int(arr[-1]) - int(temp) != 1:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tself.helper(arr+[temp],s,i+1)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tif len(arr)>1:\\n\\t\\t\\t\\tself.ans = True",
                "codeTag": "Java"
            },
            {
                "id": 3127835,
                "title": "python-simple-dfs",
                "content": "```python\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        def dfs(i, n, p):\\n            if i == len(s):\\n                return n > 1\\n\\n            r = False\\n            for j in range(i, len(s)):\\n                v = int(s[i:j+1])\\n\\n                if p is None or p - 1 == v:\\n                    if dfs(j + 1,  n + 1, v):\\n                        return True\\n\\n            return False\\n            \\n        return dfs(0, 0, None)\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        def dfs(i, n, p):\\n            if i == len(s):\\n                return n > 1\\n\\n            r = False\\n            for j in range(i, len(s)):\\n                v = int(s[i:j+1])\\n\\n                if p is None or p - 1 == v:\\n                    if dfs(j + 1,  n + 1, v):\\n                        return True\\n\\n            return False\\n            \\n        return dfs(0, 0, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938172,
                "title": "python3-beats-95-87-with-o-n-2-solution",
                "content": "**Intuition**\\n        1.Assume all prefixes(all substrings starting from index 0) as first number\\n        2.Assign the first number as curr and find a number(next substring) greater than by 1 next to it\\n        3.if we can reach the end of the string return True at least theres is one possible case\\n        4.edge case string with a lot of zeros at the ending ... in this case if previous is one return True\\n\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        for i in range(len(s)-1):\\n            curr = int(s[:i+1])\\n            k = j = i+1\\n\\n            while j < len(s):\\n                while j < len(s) and curr - int(s[k:j+1]) > 1:\\n                    j += 1\\n                if curr - int(s[k:j+1]) != 1:\\n                    break\\n                #edge case such as a number with a lot of ending zeros .... 200100,1000\\n                if curr == 1 and int(s[k:len(s)]) == 0:\\n                    j = len(s)\\n                curr = int(s[k:j+1])\\n                j += 1\\n                k = j\\n\\n            else:\\n                return True\\n            \\n        return False\\n        \\n        ```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        for i in range(len(s)-1):\\n            curr = int(s[:i+1])\\n            k = j = i+1\\n\\n            while j < len(s):\\n                while j < len(s) and curr - int(s[k:j+1]) > 1:\\n                    j += 1\\n                if curr - int(s[k:j+1]) != 1:\\n                    break\\n                #edge case such as a number with a lot of ending zeros .... 200100,1000\\n                if curr == 1 and int(s[k:len(s)]) == 0:\\n                    j = len(s)\\n                curr = int(s[k:j+1])\\n                j += 1\\n                k = j\\n\\n            else:\\n                return True\\n            \\n        return False\\n        \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 2728029,
                "title": "runtime-0-ms-faster-than-100-00-c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool splitString(string s) \\n{   \\n    int idx=0;\\n    vector<long long int>v;\\n    return fun(s,idx,v);\\n}\\nlong long int maxval=99999999991;   //9999999998\\nbool fun(string &s,int idx,vector<long long int>&v)\\n{\\n\\tif(idx >= s.length())\\n\\t{\\n\\t\\tif(v.size()>=2)\\n\\t\\t{\\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcout<<v[i]<<\" \";\\n\\t\\t\\t}\\n\\t\\t\\tcout<<endl;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n    long long int num=0;\\n\\tstring str=\"\";\\n\\t\\n\\tfor(int i=idx;i<s.length();i++)\\n\\t{\\n\\t\\tchar ch = s[i];\\n\\t\\t\\n\\t\\tnum = (num*10LL) + (ch-\\'0\\') + 0LL;\\n\\n\\t\\tstr.push_back(ch);\\n\\t\\t\\n\\t\\tif(num >= maxval)\\n\\t\\t{\\n\\t\\t    return false;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(v.size()==0)\\n\\t\\t{\\n\\t\\t\\tv.push_back(num);\\n\\t\\t\\tif(fun(s,i+1,v)==true)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tv.pop_back();   //backtracking\\n\\t\\t}\\n\\t\\telse if(v.size()>0)\\n\\t\\t{\\n\\t\\t\\tlong long int currnum = num;\\n\\t\\t\\tlong long int lastnum = v[v.size()-1];\\n\\t\\t\\t\\n\\t\\t\\tif( (lastnum - currnum)==1 )\\n\\t\\t\\t{\\n\\t\\t\\t   v.push_back(num);\\n\\t\\t\\t   if(fun(s,i+1,v)==true)\\n\\t\\t\\t   {\\n\\t\\t\\t      return true;\\n\\t\\t\\t   }\\n\\t\\t\\t   v.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool splitString(string s) \\n{   \\n    int idx=0;\\n    vector<long long int>v;\\n    return fun(s,idx,v);\\n}\\nlong long int maxval=99999999991;   //9999999998\\nbool fun(string &s,int idx,vector<long long int>&v)\\n{\\n\\tif(idx >= s.length())\\n\\t{\\n\\t\\tif(v.size()>=2)\\n\\t\\t{\\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcout<<v[i]<<\" \";\\n\\t\\t\\t}\\n\\t\\t\\tcout<<endl;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n    long long int num=0;\\n\\tstring str=\"\";\\n\\t\\n\\tfor(int i=idx;i<s.length();i++)\\n\\t{\\n\\t\\tchar ch = s[i];\\n\\t\\t\\n\\t\\tnum = (num*10LL) + (ch-\\'0\\') + 0LL;\\n\\n\\t\\tstr.push_back(ch);\\n\\t\\t\\n\\t\\tif(num >= maxval)\\n\\t\\t{\\n\\t\\t    return false;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(v.size()==0)\\n\\t\\t{\\n\\t\\t\\tv.push_back(num);\\n\\t\\t\\tif(fun(s,i+1,v)==true)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tv.pop_back();   //backtracking\\n\\t\\t}\\n\\t\\telse if(v.size()>0)\\n\\t\\t{\\n\\t\\t\\tlong long int currnum = num;\\n\\t\\t\\tlong long int lastnum = v[v.size()-1];\\n\\t\\t\\t\\n\\t\\t\\tif( (lastnum - currnum)==1 )\\n\\t\\t\\t{\\n\\t\\t\\t   v.push_back(num);\\n\\t\\t\\t   if(fun(s,i+1,v)==true)\\n\\t\\t\\t   {\\n\\t\\t\\t      return true;\\n\\t\\t\\t   }\\n\\t\\t\\t   v.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2639488,
                "title": "simple-backtracking-solution-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool func(string s,unsigned long long prev)\\n    {\\n\\t//If no string left then return true;\\n        if(s==\"\") return true; \\n\\t\\t//That splitting can happen at any position. so we iterate at each position\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\t\\t\\t//if prev value is one more than current left partition then we check recursively for right substring and prev is updated to unsigned long long value of current left string\\n            if(stoull(s.substr(0,i+1))==prev-1) \\n                if(func(s.substr(i+1),prev-1)) \\n                    return true; \\n        }\\n\\t\\t//If nothing works we return false;\\n        return false;\\n    }\\n    bool splitString(string s) {       \\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(func(s.substr(i+1),stoull(s.substr(0,i+1)))) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool func(string s,unsigned long long prev)\\n    {\\n\\t//If no string left then return true;\\n        if(s==\"\") return true; \\n\\t\\t//That splitting can happen at any position. so we iterate at each position\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\t\\t\\t//if prev value is one more than current left partition then we check recursively for right substring and prev is updated to unsigned long long value of current left string\\n            if(stoull(s.substr(0,i+1))==prev-1) \\n                if(func(s.substr(i+1),prev-1)) \\n                    return true; \\n        }\\n\\t\\t//If nothing works we return false;\\n        return false;\\n    }\\n    bool splitString(string s) {       \\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(func(s.substr(i+1),stoull(s.substr(0,i+1)))) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077769,
                "title": "backtracking-explain",
                "content": "# Backtracking\\n\\n> from brute force step by step optimize\\n\\nOne picture is worth a thousand words.\\n\\n![image](https://assets.leetcode.com/users/images/fe3ec39b-79bf-408b-9843-08d513194b0b_1653619479.069864.png)\\n\\n\\n## 1. Solution1 Brute force DFS\\n\\nUse DFS generate all possible split substrings and check to descend.\\n\\n````\\n//\\t\\t\\t\\t\\t 1234\\n//     1,234\\t\\t 12,34\\t\\t123,4\\n// 1,2,34  1,23,4    12,3,4\\n// 1,2,3,4\\n\\n// S1:) TLE 182 / 196 test cases passed.\\nfunc splitString(s string) bool {\\n\\tif len(s) <= 1 {\\n\\t\\treturn false\\n\\t}\\n\\tres := make([][]int, 0)\\n\\tbacktrack(s, 0, &[]int{}, &res)\\n\\tfor _, lst := range res {\\n\\t\\tif isDescending(lst) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc backtrack(s string, start int, tmp *[]int, res *[][]int) {\\n\\tif start == len(s) && len(*tmp) > 1 {\\n\\t\\tlst := make([]int, len(*tmp))\\n\\t\\tcopy(lst, *tmp)\\n\\t\\t*res = append(*res, lst)\\n\\t}\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tx, _ := strconv.Atoi(s[start : i+1])\\n\\t\\t*tmp = append(*tmp, x)\\n\\t\\tbacktrack(s, i+1, tmp, res)\\n\\t\\t*tmp = (*tmp)[:len(*tmp)-1]\\n\\t}\\n}\\n\\nfunc isDescending(lst []int) bool {\\n\\tif len(lst) < 2 {\\n\\t\\treturn false\\n\\t}\\n\\tfor i := 1; i < len(lst); i++ {\\n\\t\\tif lst[i-1]-lst[i] == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t} else {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\n\\n````\\n\\n## 2. Optimize solution 1\\n\\nBecause solution 1 generates all possible substrings, there are many substrings\\nis not descend, so we drop this substring.\\n\\n```\\n// S2:) Optimize S1\\nfunc splitString(s string) bool {\\n\\tif len(s) <= 1 {\\n\\t\\treturn false\\n\\t}\\n\\treturn isDesc(s, 0, &[]int{})\\n}\\n\\n// Backtracking\\nfunc isDesc(s string, start int, tmp *[]int) bool {\\n\\tif start == len(s) {\\n\\t\\treturn len(*tmp) >= 2\\n\\t}\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tcurr, _ := strconv.Atoi(s[start : i+1])\\n\\t\\tif len(*tmp) == 0 || (*tmp)[len(*tmp)-1]-curr == 1 { // prev - curr == 1\\n\\t\\t\\t*tmp = append(*tmp, curr)\\n\\t\\t\\tif isDesc(s, i+1, tmp) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\t*tmp = (*tmp)[:len(*tmp)-1]\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "````\\n//\\t\\t\\t\\t\\t 1234\\n//     1,234\\t\\t 12,34\\t\\t123,4\\n// 1,2,34  1,23,4    12,3,4\\n// 1,2,3,4\\n\\n// S1:) TLE 182 / 196 test cases passed.\\nfunc splitString(s string) bool {\\n\\tif len(s) <= 1 {\\n\\t\\treturn false\\n\\t}\\n\\tres := make([][]int, 0)\\n\\tbacktrack(s, 0, &[]int{}, &res)\\n\\tfor _, lst := range res {\\n\\t\\tif isDescending(lst) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc backtrack(s string, start int, tmp *[]int, res *[][]int) {\\n\\tif start == len(s) && len(*tmp) > 1 {\\n\\t\\tlst := make([]int, len(*tmp))\\n\\t\\tcopy(lst, *tmp)\\n\\t\\t*res = append(*res, lst)\\n\\t}\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tx, _ := strconv.Atoi(s[start : i+1])\\n\\t\\t*tmp = append(*tmp, x)\\n\\t\\tbacktrack(s, i+1, tmp, res)\\n\\t\\t*tmp = (*tmp)[:len(*tmp)-1]\\n\\t}\\n}\\n\\nfunc isDescending(lst []int) bool {\\n\\tif len(lst) < 2 {\\n\\t\\treturn false\\n\\t}\\n\\tfor i := 1; i < len(lst); i++ {\\n\\t\\tif lst[i-1]-lst[i] == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t} else {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\n\\n```\n```\\n// S2:) Optimize S1\\nfunc splitString(s string) bool {\\n\\tif len(s) <= 1 {\\n\\t\\treturn false\\n\\t}\\n\\treturn isDesc(s, 0, &[]int{})\\n}\\n\\n// Backtracking\\nfunc isDesc(s string, start int, tmp *[]int) bool {\\n\\tif start == len(s) {\\n\\t\\treturn len(*tmp) >= 2\\n\\t}\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tcurr, _ := strconv.Atoi(s[start : i+1])\\n\\t\\tif len(*tmp) == 0 || (*tmp)[len(*tmp)-1]-curr == 1 { // prev - curr == 1\\n\\t\\t\\t*tmp = append(*tmp, curr)\\n\\t\\t\\tif isDesc(s, i+1, tmp) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\t*tmp = (*tmp)[:len(*tmp)-1]\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015681,
                "title": "javascript-concise-faster-than-100",
                "content": "Explanantion:\\nCreate a recursive function that accepts the following parameters:\\nprev: the prev number, initialised as null\\ni: the current starting index\\ncount: the count of numbers we identify from the string so far\\n\\nEach recursion, we aim to identify a substring that can be translated to a number that satisfies the criteria (i.e. number === prev-1), if that is possible, we recursively call the function split, until we reach the end of the string. \\n```\\nfunction splitString(s){\\n  \\n  function split(prev,i,count){\\n    if (i === s.length && count >= 2) return true\\n\\n    for (let j=i+1; j<=s.length; j++){\\n      const currNum = parseInt(s.slice(i,j))\\n      if (prev === null && currNum !== 0 || currNum === prev - 1){\\n        if (split(currNum,j,count+1)) return true\\n      }\\n    }\\n    return false\\n  }\\n  return split(null,0,0)\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nfunction splitString(s){\\n  \\n  function split(prev,i,count){\\n    if (i === s.length && count >= 2) return true\\n\\n    for (let j=i+1; j<=s.length; j++){\\n      const currNum = parseInt(s.slice(i,j))\\n      if (prev === null && currNum !== 0 || currNum === prev - 1){\\n        if (split(currNum,j,count+1)) return true\\n      }\\n    }\\n    return false\\n  }\\n  return split(null,0,0)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996679,
                "title": "javascript-backtracking-dfs-very-simple",
                "content": "```\\nvar splitString = function (s) {\\n    const len = s.length;\\n\\n    function dfs(idx, prev) {\\n        if (idx === len) return true;\\n\\n        for (let i = idx; i < len; i++) {\\n            const num = parseInt(s.substring(idx, i + 1));\\n            if (num === prev - 1 && dfs(i + 1, num)) return true;\\n        }\\n        return false;\\n    }\\n\\n    for (let i = 0; i < len - 1; i++) {\\n        const num = parseInt(s.substring(0, i + 1));\\n        if (dfs(i + 1, num)) return true;\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar splitString = function (s) {\\n    const len = s.length;\\n\\n    function dfs(idx, prev) {\\n        if (idx === len) return true;\\n\\n        for (let i = idx; i < len; i++) {\\n            const num = parseInt(s.substring(idx, i + 1));\\n            if (num === prev - 1 && dfs(i + 1, num)) return true;\\n        }\\n        return false;\\n    }\\n\\n    for (let i = 0; i < len - 1; i++) {\\n        const num = parseInt(s.substring(0, i + 1));\\n        if (dfs(i + 1, num)) return true;\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1973743,
                "title": "python-dfs-backtracking-simple-solution",
                "content": "DFS:\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\t\\n        def DFS(index, prev):\\n\\t\\t\\t# base case: no character left to split\\n            if index == n:\\n                return True\\n\\t\\t\\t# split the left substrings\\n            for j in range(index, n):\\n                val = int(s[index:j+1])\\n                if prev - val == 1 and DFS(j+1, val):\\n                    return True\\n\\t\\t\\n\\t\\t# split s to get prev\\n\\t\\tn = len(s)\\n        for i in range(n-1):       # at least two substring\\n            val = int(s[:i+1])\\n            if DFS(i+1, val):\\n                return True\\n        return False \\n```\\n\\nBacktracking:\\n\\n```\\n    def splitString(self, s: str) -> bool:\\n        \\n        def backtrack(i, comb):\\n            if i == len(s) and len(comb) > 1:\\n                return True\\n            for j in range(i, len(s)):\\n                if not comb or comb[-1] - int(s[i:j+1]) == 1:\\n                    comb.append(int(s[i:j+1]))\\n                    if backtrack(j+1, comb):\\n                        return True\\n                    comb.pop()\\n            return False\\n\\n        return backtrack(0, [])\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\t\\n        def DFS(index, prev):\\n\\t\\t\\t# base case: no character left to split\\n            if index == n:\\n                return True\\n\\t\\t\\t# split the left substrings\\n            for j in range(index, n):\\n                val = int(s[index:j+1])\\n                if prev - val == 1 and DFS(j+1, val):\\n                    return True\\n\\t\\t\\n\\t\\t# split s to get prev\\n\\t\\tn = len(s)\\n        for i in range(n-1):       # at least two substring\\n            val = int(s[:i+1])\\n            if DFS(i+1, val):\\n                return True\\n        return False \\n```\n```\\n    def splitString(self, s: str) -> bool:\\n        \\n        def backtrack(i, comb):\\n            if i == len(s) and len(comb) > 1:\\n                return True\\n            for j in range(i, len(s)):\\n                if not comb or comb[-1] - int(s[i:j+1]) == 1:\\n                    comb.append(int(s[i:j+1]))\\n                    if backtrack(j+1, comb):\\n                        return True\\n                    comb.pop()\\n            return False\\n\\n        return backtrack(0, [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926166,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int idx, unsigned long long t, string s){\\n        if(idx == s.size()) return 1;\\n        \\n        for(int j=idx; j<s.size(); j++){\\n            \\n            string suffix = s.substr(idx, j-idx+1);\\n            \\n            unsigned long long val =  stoull(suffix);\\n            \\n            if(val+1 == t and dfs(j+1, val, s)) return 1;\\n            \\n        }\\n        \\n        return 0;\\n    }\\n    \\n    bool splitString(string s) {\\n        \\n        int n = s.size();\\n        \\n        for(int i=0; i<n-1; i++){\\n            string prefix = s.substr(0,i+1);\\n            \\n            unsigned long long val =  stoull(prefix);\\n            \\n            if(dfs(i+1 , val, s)) return 1;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int idx, unsigned long long t, string s){\\n        if(idx == s.size()) return 1;\\n        \\n        for(int j=idx; j<s.size(); j++){\\n            \\n            string suffix = s.substr(idx, j-idx+1);\\n            \\n            unsigned long long val =  stoull(suffix);\\n            \\n            if(val+1 == t and dfs(j+1, val, s)) return 1;\\n            \\n        }\\n        \\n        return 0;\\n    }\\n    \\n    bool splitString(string s) {\\n        \\n        int n = s.size();\\n        \\n        for(int i=0; i<n-1; i++){\\n            string prefix = s.substr(0,i+1);\\n            \\n            unsigned long long val =  stoull(prefix);\\n            \\n            if(dfs(i+1 , val, s)) return 1;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915438,
                "title": "simple-solution-in-java-elegant-and-concise-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return find(0, -1, s);\\n    }\\n    \\n    private boolean find(int index, long prevVal, String s){\\n        \\n        long currVal = 0;\\n        for(int i=index; i<s.length(); i++){\\n            currVal = currVal*10 + (long)(s.charAt(i) - \\'0\\');\\n            if(currVal >= 1_000_000_000_0L) return false; // As the max length is 20\\n            \\n            if(prevVal == -1){\\n                if(find(i+1, currVal, s)) return true;\\n                continue;\\n            }\\n            if(i == s.length() - 1){\\n                return prevVal - currVal == 1;\\n            }\\n            \\n            if(prevVal - currVal == 1){\\n                if(find(i+1, currVal, s)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return find(0, -1, s);\\n    }\\n    \\n    private boolean find(int index, long prevVal, String s){\\n        \\n        long currVal = 0;\\n        for(int i=index; i<s.length(); i++){\\n            currVal = currVal*10 + (long)(s.charAt(i) - \\'0\\');\\n            if(currVal >= 1_000_000_000_0L) return false; // As the max length is 20\\n            \\n            if(prevVal == -1){\\n                if(find(i+1, currVal, s)) return true;\\n                continue;\\n            }\\n            if(i == s.length() - 1){\\n                return prevVal - currVal == 1;\\n            }\\n            \\n            if(prevVal - currVal == 1){\\n                if(find(i+1, currVal, s)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740505,
                "title": "python-clean-recursive-solution",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @lru_cache(None)\\n        def helper(prev, s):\\n            if not s:\\n                return True\\n            \\n            for i in range(1, len(s)+1):\\n                x = int(s[:i])\\n\\n                if prev - x == 1:\\n                    if helper(x, s[i:]):\\n                        return True\\n            \\n            return False\\n        \\n        for i in range(1, len(s)):\\n            if helper(int(s[:i]), s[i:]):\\n                return True\\n        \\n        return False",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @lru_cache(None)\\n        def helper(prev, s):\\n            if not s:\\n                return True\\n            \\n            for i in range(1, len(s)+1):\\n                x = int(s[:i])\\n\\n                if prev - x == 1:\\n                    if helper(x, s[i:]):\\n                        return True\\n            \\n            return False\\n        \\n        for i in range(1, len(s)):\\n            if helper(int(s[:i]), s[i:]):\\n                return True\\n        \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1723386,
                "title": "easy-peasy-backtracking-solution-c",
                "content": "class Solution {\\npublic:\\n    \\n    bool ans=false;\\n    void fun(string s, long long int prev, int count)\\n    {\\n        if(!s.length())\\n        {\\n            if(count>1)\\n                ans=true;\\n            return;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            string str=s.substr(0,i+1);\\n            long long int val=stoll(str);\\n            if(val>99999999999) // According to question, there should be atleast 2 substrings, that means atleast 2 values.\\n                break;          // The max length of string is 20 which means the length of max val of any substring shouldn\\'t be more than 10 \\n            if(prev==-1)\\n            {\\n                fun(s.substr(i+1),val,count+1);\\n            }\\n            else\\n            {\\n                if(val>=prev)\\n                    break;\\n                if((prev-val)==1)\\n                {\\n                    fun(s.substr(i+1),val,count+1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool splitString(string s) { \\n        fun(s,-1,0); // s -> input string \\n        return ans;  // -1 -> previous value of the substring\\n    }                // 0 -> count to track number of substrings included\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool ans=false;\\n    void fun(string s, long long int prev, int count)\\n    {\\n        if(!s.length())\\n        {\\n            if(count>1)\\n                ans=true;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1428460,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    bool find(int index,long long int sum,string &s)\\n    {\\n        if(index>=s.size())\\n        {\\n            return 1;\\n        }\\n        long long int val=0;\\n        for(int i=index;i<s.size();i++)\\n        {\\n            val=val*10+(s[i]-\\'0\\');\\n            if(val>=1e11)\\n            {\\n                return 0;\\n            }\\n            if((sum-val==1)&&find(i+1,val,s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) \\n    {\\n        long long int sum=0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            sum=sum*10+(s[i]-\\'0\\');\\n            if(sum>=1e11)\\n            {\\n                return false;\\n            }\\n            if(find(i+1,sum,s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    bool find(int index,long long int sum,string &s)\\n    {\\n        if(index>=s.size())\\n        {\\n            return 1;\\n        }\\n        long long int val=0;\\n        for(int i=index;i<s.size();i++)\\n        {\\n            val=val*10+(s[i]-\\'0\\');\\n            if(val>=1e11)\\n            {\\n                return 0;\\n            }\\n            if((sum-val==1)&&find(i+1,val,s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) \\n    {\\n        long long int sum=0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            sum=sum*10+(s[i]-\\'0\\');\\n            if(sum>=1e11)\\n            {\\n                return false;\\n            }\\n            if(find(i+1,sum,s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327432,
                "title": "simple-backtracking-solution",
                "content": "```\\nclass Solution {\\n    boolean backtrack(int index, String s, double prev, double diff){\\n        // true if reached end with diff as 1\\n        if (index == s.length() && diff == 1)\\n            return true;\\n        \\n        for (int i = index; i < s.length(); i++){\\n            double tmp = Double.parseDouble(s.substring(index, i+1));\\n            // check if diff is 1 or base case\\n            if (prev == -1 || prev - tmp == 1){\\n                if (backtrack(i+1, s, tmp, prev - tmp))\\n                    return true;\\n            }\\n            // avoid checking if diff is greater than 1\\n            else if (tmp - prev > 1)\\n                break;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean splitString(String s) {\\n        return backtrack(0, s, -1, -1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    boolean backtrack(int index, String s, double prev, double diff){\\n        // true if reached end with diff as 1\\n        if (index == s.length() && diff == 1)\\n            return true;\\n        \\n        for (int i = index; i < s.length(); i++){\\n            double tmp = Double.parseDouble(s.substring(index, i+1));\\n            // check if diff is 1 or base case\\n            if (prev == -1 || prev - tmp == 1){\\n                if (backtrack(i+1, s, tmp, prev - tmp))\\n                    return true;\\n            }\\n            // avoid checking if diff is greater than 1\\n            else if (tmp - prev > 1)\\n                break;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean splitString(String s) {\\n        return backtrack(0, s, -1, -1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218541,
                "title": "c-backtracking-100-faster-small",
                "content": "```\\nclass Solution {\\npublic:\\n    bool helper(string s,unsigned long long prev){\\n      int n= s.size();\\n      if(n == 0){\\n        return true;\\n      }\\n      unsigned long long current = 0;\\n      for(int i=0;i<n;i++){\\n         current = current*10  + (s[i] - \\'0\\') ;\\n       if((i != n-1 && prev == -9999 || prev-current == 1)  && helper(s.substr(i+1,n-(i+1)),current))\\n          return true;\\n      }\\n      return false;\\n    }\\n    bool splitString(string s) {\\n      return helper(s,-9999);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(string s,unsigned long long prev){\\n      int n= s.size();\\n      if(n == 0){\\n        return true;\\n      }\\n      unsigned long long current = 0;\\n      for(int i=0;i<n;i++){\\n         current = current*10  + (s[i] - \\'0\\') ;\\n       if((i != n-1 && prev == -9999 || prev-current == 1)  && helper(s.substr(i+1,n-(i+1)),current))\\n          return true;\\n      }\\n      return false;\\n    }\\n    bool splitString(string s) {\\n      return helper(s,-9999);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203431,
                "title": "python-clean-backtracking-4-liner",
                "content": "```py\\ndef splitString(self, s: str, num=None) -> bool:\\n    if num is None:\\n        return any(self.splitString(s[i:], int(s[:i]) - 1) for i in range(1, len(s)))\\n    else:\\n        return len(s) == 0 or any(self.splitString(s[i:], num - 1) for i in range(1, len(s) + 1) if int(s[:i]) == num)\\n```\\n\\n1. Added extra optional **parameter**, or create another function.\\n2. Split strings into left(**current number**), right (recurse)\\n    a. if num is None (First function call), range(1, len(s)) to guarantees it has at least 2 parts.\\n    b. else, only recurse when **current number** is same as **parameter**. (base is when string is empty)\\n\\t",
                "solutionTags": [],
                "code": "```py\\ndef splitString(self, s: str, num=None) -> bool:\\n    if num is None:\\n        return any(self.splitString(s[i:], int(s[:i]) - 1) for i in range(1, len(s)))\\n    else:\\n        return len(s) == 0 or any(self.splitString(s[i:], num - 1) for i in range(1, len(s) + 1) if int(s[:i]) == num)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1188141,
                "title": "python-100",
                "content": "***Topic::\\nDynamic Programming\\nOwing to a really small string size (20), we split the string into tuples containing the current substring, the ending index(j) and the starting index(i) with a span of j - i + 1.\\nFor example, \"50049048\" is processed into\\n(5, 0, 0), (50, 1, 0), (500, 2, 0), (5004, 3, 0), (50049, 4, 0), (500490, 5, 0), (5004904, 6, 0), (50049048, 7, 0), (0, 0, 1), (00, 1, 1), ...\\nNow all you have to do is to check whether there exits a subsequence (a1, b1, c1),(a2, b2, c2), etc.. that matches the constraints below :: \\ni)    a1 - a2 = a2 - a3 = a3 - a4 = ... = 1 (strictly decreasing)\\nii)   b1 = c2 - 1, b2 = c3 - 1, b3 = c4 - 1, ... (the ending index of a former substring has to be 1 less than the starting index of the next substring)\\niii)  bn = len(s) - 1 (the last substring has to terminate at the very end)\\niv)   n is not equal to 1 (since we want to split s into atleast two such substrings)\\nNow, this problem clearly boils down to a O(n^2) dynamic programming problem, which is nothing but a clever brute force! Do consider upvoting if you like the explanation. Thanks.***\\n```\\nclass Solution:\\n    def solve(self, numbers, number):\\n        dp = []\\n        for i in range(len(numbers)):\\n            dp.append(0) if numbers[i][2] else dp.append(numbers[i][1] + 1)\\n            for j in range(i - 1, -1, -1):\\n                if numbers[j][2] == numbers[i][2]:\\n                    continue\\n                if numbers[i][0] == numbers[j][0] - 1 and numbers[i][2] == (numbers[j][1] + 1):\\n                    dp[i] = max(dp[i], dp[j] + numbers[i][1] - numbers[i][2] + 1)\\n\\n        for i, entry in enumerate(dp):\\n            if numbers[i][2] and entry == len(number):\\n                return True\\n        return False\\n                \\n        \\n    def splitString(self, s: str) -> bool:\\n        start = 0\\n        while start < len(s) and s[start] == \\'0\\':\\n            start += 1\\n        s = s[start:]\\n        numbers_seen_so_far = []\\n        for i in range(len(s)):\\n            for j in range(i + 1, len(s) + 1):\\n                numbers_seen_so_far.append((int(s[i : j]), j - 1, i))\\n\\n        return self.solve(numbers_seen_so_far, s)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self, numbers, number):\\n        dp = []\\n        for i in range(len(numbers)):\\n            dp.append(0) if numbers[i][2] else dp.append(numbers[i][1] + 1)\\n            for j in range(i - 1, -1, -1):\\n                if numbers[j][2] == numbers[i][2]:\\n                    continue\\n                if numbers[i][0] == numbers[j][0] - 1 and numbers[i][2] == (numbers[j][1] + 1):\\n                    dp[i] = max(dp[i], dp[j] + numbers[i][1] - numbers[i][2] + 1)\\n\\n        for i, entry in enumerate(dp):\\n            if numbers[i][2] and entry == len(number):\\n                return True\\n        return False\\n                \\n        \\n    def splitString(self, s: str) -> bool:\\n        start = 0\\n        while start < len(s) and s[start] == \\'0\\':\\n            start += 1\\n        s = s[start:]\\n        numbers_seen_so_far = []\\n        for i in range(len(s)):\\n            for j in range(i + 1, len(s) + 1):\\n                numbers_seen_so_far.append((int(s[i : j]), j - 1, i))\\n\\n        return self.solve(numbers_seen_so_far, s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188042,
                "title": "python3-recursion-solution-for-reference",
                "content": "The question looks like permuations and split problem at first sight but if we dig into details strings is a bad way to deal with the problem since it consumes conversion. If we use the digit conversion method as below, it will help faster. \\n\\n1234 = (10** 3 * 1) + (10 ** 2 * 2) + (10**1 * 3) + (10 ** 0 * 4)) = 1000 + 200 + 30 + 4\\n\\nThe below variant uses recursion and moves forward only when it finds a value just 1 more than the base value. \\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        # convert the string into digits.\\n        s = [int(i) for i in list(s)]\\n        \\n        def r(base, index, nums):\\n\\t\\t\\t## increment power of 10. \\n            d = 0\\n\\t\\t\\t## accumulate the value for 10. \\n            acc = 0\\n            res = False\\n\\t\\t\\t## check the value from reverse from the index -1 where we calculated base.\\n            for x in range(index,-1,-1):\\n                acc += (10**d)*nums[x]\\n\\n                if base + 1 == acc:\\n                    if x-1 >= 0:\\n\\t\\t\\t\\t\\t\\t## collect recursion output\\n                        res = res or r(acc, x-1, s)\\n                    else:\\n                        res = True\\n                d+=1\\n            return res\\n                \\n        d = 0\\n        ans = False\\n        acc = 0\\n        ## same logic as recursion - just driver outside the recusion function. \\n\\t\\t## The logic below could possibly also be included ithe same recursion solution with some effort. \\n        for x in range(len(s)-1,-1,-1):\\n            acc += (10**d)*s[x]\\n            ans = ans or r(acc, x-1, s)\\n            d+=1\\n        return ans\\n```\\n#Runtime: 32 ms, faster than 100.00% of Python3 online submissions for Splitting a String Into Descending Consecutive Values.\\n#Memory Usage: 14.5 MB, less than 100.00% of Python3 online submissions for Splitting a String Into Descending Consecutive Values.",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        # convert the string into digits.\\n        s = [int(i) for i in list(s)]\\n        \\n        def r(base, index, nums):\\n\\t\\t\\t## increment power of 10. \\n            d = 0\\n\\t\\t\\t## accumulate the value for 10. \\n            acc = 0\\n            res = False\\n\\t\\t\\t## check the value from reverse from the index -1 where we calculated base.\\n            for x in range(index,-1,-1):\\n                acc += (10**d)*nums[x]\\n\\n                if base + 1 == acc:\\n                    if x-1 >= 0:\\n\\t\\t\\t\\t\\t\\t## collect recursion output\\n                        res = res or r(acc, x-1, s)\\n                    else:\\n                        res = True\\n                d+=1\\n            return res\\n                \\n        d = 0\\n        ans = False\\n        acc = 0\\n        ## same logic as recursion - just driver outside the recusion function. \\n\\t\\t## The logic below could possibly also be included ithe same recursion solution with some effort. \\n        for x in range(len(s)-1,-1,-1):\\n            acc += (10**d)*s[x]\\n            ans = ans or r(acc, x-1, s)\\n            d+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187861,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(string &s, int idx, long prev, int dep) {\\n        if (idx == s.size() && dep != 1)\\n            return true;\\n        long num = 0;\\n        for (int i = idx; i < s.size() && log10(num) < 10; i++) {\\n            num = 10 * num + s[i] - \\'0\\';\\n            if (prev == -1 || num == prev - 1) {\\n                if (dfs(s, i + 1, num, dep + 1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        return dfs(s, 0, -1, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(string &s, int idx, long prev, int dep) {\\n        if (idx == s.size() && dep != 1)\\n            return true;\\n        long num = 0;\\n        for (int i = idx; i < s.size() && log10(num) < 10; i++) {\\n            num = 10 * num + s[i] - \\'0\\';\\n            if (prev == -1 || num == prev - 1) {\\n                if (dfs(s, i + 1, num, dep + 1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        return dfs(s, 0, -1, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187566,
                "title": "c-very-easy-to-understand-intuitive",
                "content": "```\\nclass Solution {\\n  public:\\n    bool f = false;\\n  void recurse(string & s, int start, vector < string > & v) {\\n    if (start == s.size()) {\\n      if (v.size() > 1) {\\n        bool pos = true;\\n        unsigned long long prev = stoull(v[0]);\\n        for (int i = 1; i < v.size(); i++) {\\n          unsigned long long curr = stoull(v[i]);\\n          if ((prev - curr) != 1) {\\n            pos = false;\\n            break;\\n          }\\n          prev = curr;\\n        }\\n        f |= pos;\\n      }\\n    }\\n\\n    for (int si = 1; si <= s.size() - start; si++) {\\n      v.push_back(s.substr(start, si));\\n      recurse(s, start + si, v);\\n      v.pop_back();\\n    }\\n  }\\n\\n  bool splitString(string s) {\\n    vector < string > v;\\n    recurse(s, 0, v);\\n    return f;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    bool f = false;\\n  void recurse(string & s, int start, vector < string > & v) {\\n    if (start == s.size()) {\\n      if (v.size() > 1) {\\n        bool pos = true;\\n        unsigned long long prev = stoull(v[0]);\\n        for (int i = 1; i < v.size(); i++) {\\n          unsigned long long curr = stoull(v[i]);\\n          if ((prev - curr) != 1) {\\n            pos = false;\\n            break;\\n          }\\n          prev = curr;\\n        }\\n        f |= pos;\\n      }\\n    }\\n\\n    for (int si = 1; si <= s.size() - start; si++) {\\n      v.push_back(s.substr(start, si));\\n      recurse(s, start + si, v);\\n      v.pop_back();\\n    }\\n  }\\n\\n  bool splitString(string s) {\\n    vector < string > v;\\n    recurse(s, 0, v);\\n    return f;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186930,
                "title": "javascript-dp-with-explanation-o-n-2",
                "content": "For example:\\n`dp[i]`  = a set of last values that can be totally split = \\n- at least including one integer value from `s[i] to s[n-1]`\\n- other valid value which has a `j, j>=i+1, that s[i ... j-1] === dp[j] + 1`\\n\\nFinal condition: `dp[0].size>1`, since we want to split at least 2 nums.\\n\\n**For example:**\\n```text\\n050043   |   n = 6\\ndp[5] = {3}\\ndp[4] = {4, 43}\\ndp[3] = {4, 43}\\ndp[2] = {4, 43}\\ndp[1] = {5, 50043}\\ndp[0] = {5, 50043}\\n```\\n**JavaScript code:**\\n\\n```js\\nvar splitString = function(s) {\\n    var n = s.length;\\n    if(n<2)\\n    {\\n        return false;\\n    }\\n    var dp = new Array(n).fill(-1).map(el=>new Set());\\n    dp[n-1].add(parseInt(s[n-1])); \\n    for(var i = n-2; i>=0; i--)\\n    {\\n        for(var j=i+1; j<n;j++)\\n        {\\n            var cur = parseInt(s.slice(i,j));\\n            if(cur===0)\\n            {\\n                continue;\\n            }\\n            if(dp[j].size>=0 && dp[j].has(cur-1))\\n            {\\n                dp[i].add(cur);\\n            }\\n        }\\n        dp[i].add(parseInt(s.slice(i))); // Note: add substring s[i, n-1] after each index\\n    }\\n    return dp[0].size > 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```text\\n050043   |   n = 6\\ndp[5] = {3}\\ndp[4] = {4, 43}\\ndp[3] = {4, 43}\\ndp[2] = {4, 43}\\ndp[1] = {5, 50043}\\ndp[0] = {5, 50043}\\n```\n```js\\nvar splitString = function(s) {\\n    var n = s.length;\\n    if(n<2)\\n    {\\n        return false;\\n    }\\n    var dp = new Array(n).fill(-1).map(el=>new Set());\\n    dp[n-1].add(parseInt(s[n-1])); \\n    for(var i = n-2; i>=0; i--)\\n    {\\n        for(var j=i+1; j<n;j++)\\n        {\\n            var cur = parseInt(s.slice(i,j));\\n            if(cur===0)\\n            {\\n                continue;\\n            }\\n            if(dp[j].size>=0 && dp[j].has(cur-1))\\n            {\\n                dp[i].add(cur);\\n            }\\n        }\\n        dp[i].add(parseInt(s.slice(i))); // Note: add substring s[i, n-1] after each index\\n    }\\n    return dp[0].size > 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186917,
                "title": "c-solution-using-simple-recursion",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    //Max value of long long int . one can get it with use of LONG_MAX\\n    string LMAX=\"9223372036854775807\";\\n    // Converting string to long long int\\n    ll con(string &s){\\n        ll ans;\\n        int i=0;\\n        //For loop to determine index of first non-zero digit\\n        for(;i<(int)s.size();i++){\\n            if(s[i]==\\'0\\'){\\n                continue;\\n            }\\n            else\\n                break;\\n        }\\n        if(i==(int)s.size())\\n            return 0;\\n        string res=s.substr(i);\\n        ll sz=res.size();\\n        //if resultant string contains more than 19 digits: NOT POSSIBLE\\n        if(sz>19)\\n            return -1;\\n        bool f1=false;\\n        // if resultant string contains exactly 19 digits, we need to check whether it is smaller or larger than LONG_MAX\\n        if(sz==19){\\n            for(int i=0;i<sz;i++){\\n                if(res[i]>LMAX[i]){\\n                    if(f1==false){\\n                        return -1;\\n                    }\\n                }\\n                else if(res[i]<LMAX[i]){\\n                    f1=true;\\n                }\\n            }\\n            //If greater than LONG_MAX :-> NOT POSSIBLE\\n            if(!f1)\\n            return -1;\\n        }\\n        //convert string to long long int\\n        ans=stoll(res);\\n        return ans; \\n    }\\n    //ind -> current index, s-> original string, n-> size of string , prev-> previous number\\n    bool find(int ind,string &s,int &n,ll prev){\\n        //If we reach end of the string ,it means we got the answer\\n        if(ind==n){\\n            return true;\\n        }\\n        string z=\"\";\\n        bool res=false;\\n        for(int i=ind;i<n;i++){\\n            z+=s[i];\\n            ll num=con(z);\\n            //Check for descending order and difference of adjacent element should be 1, then only proceed forward\\n            if(prev-num==1){\\n                res=res or find(i+1,s,n,num);\\n            }\\n        }\\n        return res;\\n    }\\n    bool splitString(string s) {\\n        int n=s.size();\\n        bool res=false;\\n        string curr=\"\";\\n        if(n==1)\\n        {\\n            return false;\\n        }\\n        if(n==2){\\n            ll z=s[0]-\\'0\\';\\n            ll y=s[1]-\\'0\\';\\n            if(z-y==1){\\n                return true;\\n            }\\n            return false;\\n        }\\n        //We need to run the loop till n-1 only\\n        for(int i=0;i<n-1;i++){\\n            curr+=s[i];\\n            ll num=con(curr);\\n            res=res or find(i+1,s,n,num);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    //Max value of long long int . one can get it with use of LONG_MAX\\n    string LMAX=\"9223372036854775807\";\\n    // Converting string to long long int\\n    ll con(string &s){\\n        ll ans;\\n        int i=0;\\n        //For loop to determine index of first non-zero digit\\n        for(;i<(int)s.size();i++){\\n            if(s[i]==\\'0\\'){\\n                continue;\\n            }\\n            else\\n                break;\\n        }\\n        if(i==(int)s.size())\\n            return 0;\\n        string res=s.substr(i);\\n        ll sz=res.size();\\n        //if resultant string contains more than 19 digits: NOT POSSIBLE\\n        if(sz>19)\\n            return -1;\\n        bool f1=false;\\n        // if resultant string contains exactly 19 digits, we need to check whether it is smaller or larger than LONG_MAX\\n        if(sz==19){\\n            for(int i=0;i<sz;i++){\\n                if(res[i]>LMAX[i]){\\n                    if(f1==false){\\n                        return -1;\\n                    }\\n                }\\n                else if(res[i]<LMAX[i]){\\n                    f1=true;\\n                }\\n            }\\n            //If greater than LONG_MAX :-> NOT POSSIBLE\\n            if(!f1)\\n            return -1;\\n        }\\n        //convert string to long long int\\n        ans=stoll(res);\\n        return ans; \\n    }\\n    //ind -> current index, s-> original string, n-> size of string , prev-> previous number\\n    bool find(int ind,string &s,int &n,ll prev){\\n        //If we reach end of the string ,it means we got the answer\\n        if(ind==n){\\n            return true;\\n        }\\n        string z=\"\";\\n        bool res=false;\\n        for(int i=ind;i<n;i++){\\n            z+=s[i];\\n            ll num=con(z);\\n            //Check for descending order and difference of adjacent element should be 1, then only proceed forward\\n            if(prev-num==1){\\n                res=res or find(i+1,s,n,num);\\n            }\\n        }\\n        return res;\\n    }\\n    bool splitString(string s) {\\n        int n=s.size();\\n        bool res=false;\\n        string curr=\"\";\\n        if(n==1)\\n        {\\n            return false;\\n        }\\n        if(n==2){\\n            ll z=s[0]-\\'0\\';\\n            ll y=s[1]-\\'0\\';\\n            if(z-y==1){\\n                return true;\\n            }\\n            return false;\\n        }\\n        //We need to run the loop till n-1 only\\n        for(int i=0;i<n-1;i++){\\n            curr+=s[i];\\n            ll num=con(curr);\\n            res=res or find(i+1,s,n,num);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186879,
                "title": "js-easy-recursion",
                "content": "```\\nvar splitString = function(s) {\\n    let ret = false;\\n    \\n    const helper = (pos, count, pre) => {\\n        if (ret) return;\\n        if (pos == s.length && count >= 2) {\\n            ret = true;\\n            return;\\n        }\\n        for (let i = pos+1; i <= s.length; i++) {\\n            let n = parseInt(s.substring(pos, i));\\n            if (pre == n + 1 || count == 0) {\\n                helper(i, count+1, n);\\n            } else if (n > pre){\\n                break;\\n            }\\n        }\\n    }\\n    \\n    helper(0, 0, -1);\\n    return ret;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar splitString = function(s) {\\n    let ret = false;\\n    \\n    const helper = (pos, count, pre) => {\\n        if (ret) return;\\n        if (pos == s.length && count >= 2) {\\n            ret = true;\\n            return;\\n        }\\n        for (let i = pos+1; i <= s.length; i++) {\\n            let n = parseInt(s.substring(pos, i));\\n            if (pre == n + 1 || count == 0) {\\n                helper(i, count+1, n);\\n            } else if (n > pre){\\n                break;\\n            }\\n        }\\n    }\\n    \\n    helper(0, 0, -1);\\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186875,
                "title": "python-3-top-down-dp",
                "content": "Time: `O(N^3)`\\nSpace: `O(N)`\\n```\\nimport functools\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @functools.cache\\n        def dfs(ss: str, target: int) -> bool:\\n            if int(ss) == target: return True\\n            for i in range(1, len(ss)):\\n                curr, nxt = int(ss[:i]), ss[i:]\\n                if target == curr and dfs(nxt, curr - 1): return True\\n            return False\\n\\n        for i in range(1, len(s)):\\n            curr, nxt = int(s[:i]), s[i:]\\n            if dfs(nxt, curr - 1): return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @functools.cache\\n        def dfs(ss: str, target: int) -> bool:\\n            if int(ss) == target: return True\\n            for i in range(1, len(ss)):\\n                curr, nxt = int(ss[:i]), ss[i:]\\n                if target == curr and dfs(nxt, curr - 1): return True\\n            return False\\n\\n        for i in range(1, len(s)):\\n            curr, nxt = int(s[:i]), s[i:]\\n            if dfs(nxt, curr - 1): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186852,
                "title": "python-dfs-backtracking-solution",
                "content": "Python DFS+backtracking solution\\n```\\nclass Solution(object):\\n    def splitString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(index, cur):\\n            \\n            if len(cur) > 1 and int(cur[-2]) - int(cur[-1]) != 1:\\n                return False\\n            if index == len(s):\\n                if len(cur) == 1:\\n                    return False\\n                return True\\n            for i in range(index, len(s)):\\n                cur.append(s[index:i+1])\\n                if dfs(i+1, cur):\\n                    return True\\n                cur.pop()\\n            return False\\n        \\n        return dfs(0, [])\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def splitString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(index, cur):\\n            \\n            if len(cur) > 1 and int(cur[-2]) - int(cur[-1]) != 1:\\n                return False\\n            if index == len(s):\\n                if len(cur) == 1:\\n                    return False\\n                return True\\n            for i in range(index, len(s)):\\n                cur.append(s[index:i+1])\\n                if dfs(i+1, cur):\\n                    return True\\n                cur.pop()\\n            return False\\n        \\n        return dfs(0, [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186788,
                "title": "watch-out-for-trailing-zeros-like-100-no-recursion-o-n-2",
                "content": "\\u201C100\\u201D returns true as it can split into [\\u201C1\\u201D, \\u201C00\\u201D], wasted a lot of time during contest\\u2026\\n\\nIterative\\nFind next correct number, if reach the end of string then return True\\ni.e. 9897\\nthe code will first try 1 digit numbers: 9,8,9 -> wrong\\nthen try 2 digit numbers: 98, 97 -> correct\\n```\\nclass Solution(object):\\n    def splitString(self, s):\\n        # find next starting index if target is found, otherwise return -1\\n        def findIdx(s,startI,target):\\n            step = 1\\n            num = int(s[startI])\\n            while startI + step < len(s) and num < target:\\n                num = num * 10 + int(s[startI+step])\\n                step += 1\\n            if num == target:\\n                return startI + step\\n            return -1\\n        \\n        i = 1 # first i digit of s\\n        while i < len(s):\\n            next =  int(s[:i]) - 1 \\n            if next < 0:\\n                i += 1\\n                continue\\n\\t\\t\\t# finding next correct number until end of string\\n            j = i\\n            while j >= 0 and j < len(s):\\n                nextI = findIdx(s, j, next)\\n                if nextI == len(s): return True\\n                if nextI != -1 and int(s[j:nextI]) == next:\\n                    if next == 0 and all(s[v] == \"0\" for v in range(nextI, len(s))): return True # watch out here\\n                    next = next - 1\\n                j = nextI\\n            i += 1\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def splitString(self, s):\\n        # find next starting index if target is found, otherwise return -1\\n        def findIdx(s,startI,target):\\n            step = 1\\n            num = int(s[startI])\\n            while startI + step < len(s) and num < target:\\n                num = num * 10 + int(s[startI+step])\\n                step += 1\\n            if num == target:\\n                return startI + step\\n            return -1\\n        \\n        i = 1 # first i digit of s\\n        while i < len(s):\\n            next =  int(s[:i]) - 1 \\n            if next < 0:\\n                i += 1\\n                continue\\n\\t\\t\\t# finding next correct number until end of string\\n            j = i\\n            while j >= 0 and j < len(s):\\n                nextI = findIdx(s, j, next)\\n                if nextI == len(s): return True\\n                if nextI != -1 and int(s[j:nextI]) == next:\\n                    if next == 0 and all(s[v] == \"0\" for v in range(nextI, len(s))): return True # watch out here\\n                    next = next - 1\\n                j = nextI\\n            i += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186787,
                "title": "c-recursive-backtracking-faster-than-70-memory-less-than-80",
                "content": "Solved this problem using recursion. \\nThe helper recursive function is helper(input string, current index of the string, the last number that was made).\\nI would check whether the next digits of the number that is going to be created is one integer less than the last number, if so, I would update the last number and continue.\\nThe base conditions would determine the return statements.\\nAlso, used a lot of ```stod``` (string to double) function. Check it out! It is a cool function :P\\n```\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        return helper(s,0,-1);\\n    }\\n    bool helper (string & s , int ind , double last){\\n        // Base return cases\\n        if (ind >=s.size()){\\n            if (last==-1 ||  last==stod(s)){\\n                return false;\\n            }\\n            return true;\\n        }\\n\\t\\t// Check if the number to be created is the first number ever \\n        if (last == -1){\\n            for (int i = 1; i<=s.size()-ind; i++){\\n                if (helper(s,i,stod(s.substr(0,i)))){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\t\\t// Check for the next numbers to be created\\n        for (int i = 1; i<=s.size()-ind; i++){\\n            if ( (double)last - stod(s.substr(ind,i)) == 1){\\n                if (helper(s,ind+i,stod(s.substr(ind,i)))){\\n                    return true;\\n                }\\n            }\\n            if ( (double)last - stod(s.substr(ind,i)) < 1 ){\\n                break;\\n            }\\n        }\\n\\t\\t// If we exit last loop, we should return false since we couldn\\'t create a number!\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "```stod```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068930,
                "title": "easy-explanation-beats-100",
                "content": "start building the current number, and make sure you go ahead in the recursion if and only if you are just 1 smaller than the previous number, and make sure you take atleast 2 step(i.e dividing in atleast 2 numbers).\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return util1(s);\\n    }\\n    public boolean util1(String str) {\\n        return helper(str.toCharArray(), 0, -1,0);\\n    }\\n\\n    public boolean helper(char arr[], int index, long prev, int steps) {\\n        if (index == arr.length) {\\n            if(steps>1){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        long current = 0;\\n        for (int i = index; i < arr.length; i++) {\\n            current = (current * 10) + (arr[i] - 48);\\n            if (current == prev-1 || prev == -1) {\\n                boolean smallAns = helper(arr, i + 1, current,steps+1);\\n                if (smallAns) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\xAF\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return util1(s);\\n    }\\n    public boolean util1(String str) {\\n        return helper(str.toCharArray(), 0, -1,0);\\n    }\\n\\n    public boolean helper(char arr[], int index, long prev, int steps) {\\n        if (index == arr.length) {\\n            if(steps>1){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        long current = 0;\\n        for (int i = index; i < arr.length; i++) {\\n            current = (current * 10) + (arr[i] - 48);\\n            if (current == prev-1 || prev == -1) {\\n                boolean smallAns = helper(arr, i + 1, current,steps+1);\\n                if (smallAns) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990780,
                "title": "easy-solution-using-backtracking",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        def backtrack(index,prev):\\n            if index == len(s):\\n                return True\\n\\n            for j in range(index,len(s)):\\n                val = int(s[index:j+1])\\n                if val + 1 == prev and backtrack(j+1,val):\\n                    return True\\n            return False\\n\\n        for i in range(len(s)-1):\\n            val = int(s[:i+1])\\n            if backtrack(i+1,val) : return True\\n\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        def backtrack(index,prev):\\n            if index == len(s):\\n                return True\\n\\n            for j in range(index,len(s)):\\n                val = int(s[index:j+1])\\n                if val + 1 == prev and backtrack(j+1,val):\\n                    return True\\n            return False\\n\\n        for i in range(len(s)-1):\\n            val = int(s[:i+1])\\n            if backtrack(i+1,val) : return True\\n\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982510,
                "title": "recursive-java-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int count = 0;\\n    public boolean splitString(String s) {\\n        if (s.length() < 2) {\\n            return false;\\n        } else if (s.length() == 2) {\\n            if (Integer.valueOf(s.charAt(0)) - Integer.valueOf(s.charAt(1)) == 1) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        for (int i = 1; i < s.length(); i++) {\\n            double prev = Double.valueOf(s.substring(0, i)); \\n            helper(s, i, prev); \\n        }\\n        return count >= 1;\\n    }\\n\\n    private void helper (String s, int index, double prev) {\\n        if (index == s.length()) {\\n            count++;\\n            return;\\n        }\\n        for (int i = 1; i <= s.length() - index; i++) {\\n            double curr = Double.valueOf(s.substring(index, index + i));\\n            if (prev - curr == 1) {\\n                helper(s, index + i, curr);\\n            } \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public boolean splitString(String s) {\\n        if (s.length() < 2) {\\n            return false;\\n        } else if (s.length() == 2) {\\n            if (Integer.valueOf(s.charAt(0)) - Integer.valueOf(s.charAt(1)) == 1) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        for (int i = 1; i < s.length(); i++) {\\n            double prev = Double.valueOf(s.substring(0, i)); \\n            helper(s, i, prev); \\n        }\\n        return count >= 1;\\n    }\\n\\n    private void helper (String s, int index, double prev) {\\n        if (index == s.length()) {\\n            count++;\\n            return;\\n        }\\n        for (int i = 1; i <= s.length() - index; i++) {\\n            double curr = Double.valueOf(s.substring(index, index + i));\\n            if (prev - curr == 1) {\\n                helper(s, index + i, curr);\\n            } \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962338,
                "title": "python-backtracking-easy-solution",
                "content": "Code should be easy to understand\\n`start` is the starting index of `last`\\nfor example `s = \"050043\"`\\n`start` is 0, `end` is 3, `last = s[start:end+1]`, which is 5\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, start, last):\\n            if i == len(s):\\n                return start != 0 \\n            for j in range(i, len(s)):\\n                num = int(s[i:j + 1])\\n                if last == float(\"inf\") or last - num == 1:\\n                    if dfs(j + 1, i, num):\\n                        return True\\n            return False\\n        return dfs(0, 0, float(\"inf\"))\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, start, last):\\n            if i == len(s):\\n                return start != 0 \\n            for j in range(i, len(s)):\\n                num = int(s[i:j + 1])\\n                if last == float(\"inf\") or last - num == 1:\\n                    if dfs(j + 1, i, num):\\n                        return True\\n            return False\\n        return dfs(0, 0, float(\"inf\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933574,
                "title": "python-95-simple-and-detailed-code-dfs",
                "content": "# Intuition\\nThe main idea of solving this problem is this idea of \"chunking\" your input string into every possible substring all the while keeping track of the remaining part of the string. These chunks of possible solution and remaining will be passed into futher recursive calls.\\n\\nI.E. take the string \"05004\" which should return true.\\nWe want to split this into every possible substring\\nChunk | Remaining\\n0     |  5004\\n05    |  004\\n050   |  04\\n0500  |  4\\n05004 |  _\\n\\nWe then \"bound/bind\" when we make futher recursive calls. In this case, we want each valid substring chunk to have a difference of 1.\\n\\nThus the current \"chunk\" we have becomes the previous value we pass into the recursive call. *This makes more sense when reading the code*\\n# Approach\\n*In-depth comments in the code*\\n\\n# Complexity\\n- Time complexity:\\n    The time complexity is O(2^N), where N is the length of the input string s.\\n\\n    Explanation:\\n\\n    The recursive function dfs(prev, remaining) explores all possible splits of the input string.\\nIn the worst case, each character can be a part of a split or not, leading to 2 possibilities per character.\\nSince you\\'re exploring all possible combinations of splits, the number of recursive calls grows exponentially with the length of the input string.\\n\\n- Space complexity:\\nThe space complexity of your code is O(N), where N is the length of the input string s.\\n\\n    Explanation:\\n\\n    The space used by the recursion stack is directly proportional to the depth of recursion.\\nSince the maximum depth of recursion is determined by the length of the input string, the space complexity is O(N).\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        # This is the dfs code\\n        # We pass in the previous value, and the remaining s\\n        # *Note*: It\\'s worth scrolling to the bottom where the DFS function\\n        # is called to see what the initial values are to have a better understanding\\n        def dfs(prev, remaining):\\n\\n            # if the length of the remaining string is zero we return false\\n            # this makes sure there is at least 2 seperate values as stated by the\\n            # problem: \"two or more non-empty substrings\"\\n            if len(remaining) == 0:\\n                return False\\n\\n            # Next we directly check if the remaining s once converted to a int is \\n            # 1 less then prev. If so we return true.\\n            # We know this to be valid because we only call recursive calls when\\n            # all previous values are descending and a difference of 1\\n            if int(remaining) == prev - 1:\\n                return True\\n\\n            # If we reach this spot then it is time to iterate acorss the remaining\\n            # search space\\n            # We iterate from across the length of the remaining string\\n            for i in range(len(remaining)):\\n\\n                # Create every single \"chunk\" of size i to check\\n                # Convert into an int\\n                chunk = int(remaining[:i+1])\\n\\n                # Grab the remaining part of the string and MAKE SURE TO NAME IT \\n                # DIFFERENTLY. This and chunk will be passed into the recursive call\\n                remaining2 = remaining[i+1:]\\n\\n                # We want to make sure that the \"chunk\" we have satisfies the difference\\n                # condition of 1, otherwise there is no point in making futher recursive\\n                # calls. Also, since we initialize the recursive call below with Infinity\\n                # we make sure to still make calls when there is no \"previous\" value\\n                if chunk == prev - 1 or prev == float(\"inf\"):\\n\\n                    # Make the recursive call using the chunk as the previous value, and \\n                    # passing in the new formed remaining2\\n                    # If the recursive call returns True, we make sure to return from this\\n                    # current recursive call as True\\n                    if dfs(chunk,remaining2):\\n                        return True\\n\\n            # If we reach the end of the function without returning True, then there must\\n            # be no valid splitting, thus return False\\n            return False\\n        \\n        # Make the initial call to the DFS function using Infinity as the prev value, and \\n        # the whole s as the \"remaining\"\\n        return dfs(float(\"inf\"),s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        # This is the dfs code\\n        # We pass in the previous value, and the remaining s\\n        # *Note*: It\\'s worth scrolling to the bottom where the DFS function\\n        # is called to see what the initial values are to have a better understanding\\n        def dfs(prev, remaining):\\n\\n            # if the length of the remaining string is zero we return false\\n            # this makes sure there is at least 2 seperate values as stated by the\\n            # problem: \"two or more non-empty substrings\"\\n            if len(remaining) == 0:\\n                return False\\n\\n            # Next we directly check if the remaining s once converted to a int is \\n            # 1 less then prev. If so we return true.\\n            # We know this to be valid because we only call recursive calls when\\n            # all previous values are descending and a difference of 1\\n            if int(remaining) == prev - 1:\\n                return True\\n\\n            # If we reach this spot then it is time to iterate acorss the remaining\\n            # search space\\n            # We iterate from across the length of the remaining string\\n            for i in range(len(remaining)):\\n\\n                # Create every single \"chunk\" of size i to check\\n                # Convert into an int\\n                chunk = int(remaining[:i+1])\\n\\n                # Grab the remaining part of the string and MAKE SURE TO NAME IT \\n                # DIFFERENTLY. This and chunk will be passed into the recursive call\\n                remaining2 = remaining[i+1:]\\n\\n                # We want to make sure that the \"chunk\" we have satisfies the difference\\n                # condition of 1, otherwise there is no point in making futher recursive\\n                # calls. Also, since we initialize the recursive call below with Infinity\\n                # we make sure to still make calls when there is no \"previous\" value\\n                if chunk == prev - 1 or prev == float(\"inf\"):\\n\\n                    # Make the recursive call using the chunk as the previous value, and \\n                    # passing in the new formed remaining2\\n                    # If the recursive call returns True, we make sure to return from this\\n                    # current recursive call as True\\n                    if dfs(chunk,remaining2):\\n                        return True\\n\\n            # If we reach the end of the function without returning True, then there must\\n            # be no valid splitting, thus return False\\n            return False\\n        \\n        # Make the initial call to the DFS function using Infinity as the prev value, and \\n        # the whole s as the \"remaining\"\\n        return dfs(float(\"inf\"),s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931564,
                "title": "o-n-n-time-o-n-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given a string of digits and need to split it into substrings such that the substrings are in descending order with a difference of 1 between the values that the adjacent substrings represent.\\n\\nUse backtracking to explore all possible splits and check if it is valid. A split is valid if the resulting substring values are in descending order and the difference is 1 i.e substring2 is 1 less than substring1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- define a helper function for backtracking\\nbacktrack(current index, current partitions, previous substring value)\\n    - if the current index is the last, we have considered all digits, and check if we were able to split the string i.e current partitions >= 2\\n    - for each next digit including the current index digit\\n    - get the current substring value\\n    - if the previous substring value is greater or the difference between the previous and current is 1, backtrack to explore whether we can make another split. Return true if we can\\n    - if the loop completes without returning true, we can\\'t make any split, return false\\n- start backtracking from the first digit at index 0 and return the result\\n\\n# Complexity\\n- Time complexity: O(recursion breadth) \\u2192 O(calls at each levele ^ total levels) \\u2192 O(n$^n$) but the program runs much faster due to pruning \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(recursion stack) \\u2192 O(recursion depth/levels) \\u2192 O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n    \\n        def backtrack(i: int, k: int, prev: int) -> bool:\\n            if i == len(s):\\n                return k >= 2\\n            for j in range(i, len(s)):\\n                cur = int(s[i:j + 1])\\n                if prev == math.inf or cur == prev - 1:\\n                    if backtrack(j + 1, k + 1, cur):\\n                        return True\\n            return False\\n        \\n        return backtrack(0, 0, math.inf)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n    \\n        def backtrack(i: int, k: int, prev: int) -> bool:\\n            if i == len(s):\\n                return k >= 2\\n            for j in range(i, len(s)):\\n                cur = int(s[i:j + 1])\\n                if prev == math.inf or cur == prev - 1:\\n                    if backtrack(j + 1, k + 1, cur):\\n                        return True\\n            return False\\n        \\n        return backtrack(0, 0, math.inf)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905802,
                "title": "virendra-keshri-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    bool solve(int index,string &str,long long int val,int parts){\\n        if(index>=str.length()){\\n            if(parts>=2){\\n                return true;\\n            }\\n            return false;\\n        }\\n        long long int val1=0;\\n        for(int i=index;i<str.length();i++){\\n            int k=str[i]-\\'0\\';\\n            if(val1>=INT_MAX){\\n                break;\\n            }\\n            val1=(long long)((long long)(val1*10)+(long long)k);\\n            cout<<val1<<endl;\\n            if(parts==0){\\n                if(solve(i+1,str,val1,parts+1)){\\n                    return 1;\\n                }\\n            }\\n            else if((long long )val-1==(long long)val1){\\n                if(solve(i+1,str,val1,parts+1)){\\n                    return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\npublic:\\n    bool splitString(string s) {\\n   bool ans=solve(0,s,0,0);\\n   return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    bool solve(int index,string &str,long long int val,int parts){\\n        if(index>=str.length()){\\n            if(parts>=2){\\n                return true;\\n            }\\n            return false;\\n        }\\n        long long int val1=0;\\n        for(int i=index;i<str.length();i++){\\n            int k=str[i]-\\'0\\';\\n            if(val1>=INT_MAX){\\n                break;\\n            }\\n            val1=(long long)((long long)(val1*10)+(long long)k);\\n            cout<<val1<<endl;\\n            if(parts==0){\\n                if(solve(i+1,str,val1,parts+1)){\\n                    return 1;\\n                }\\n            }\\n            else if((long long )val-1==(long long)val1){\\n                if(solve(i+1,str,val1,parts+1)){\\n                    return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\npublic:\\n    bool splitString(string s) {\\n   bool ans=solve(0,s,0,0);\\n   return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3751353,
                "title": "using-front-partitioning",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    long StringToInt(String s, int j)\\n    {\\n        long digit = 0;\\n        for(int i = 0 ; i <= j ; i++)\\n            digit = digit * 10 + (int)(s.charAt(i) - \\'0\\');\\n        return digit;\\n    }\\n    boolean find(String s, long preValue, int count)\\n    {\\n        if(s.length() == 0)\\n        {\\n            if(count == 1)\\n                return false;\\n            return true;\\n        }\\n        for(int j = 0 ; j < s.length() ; j++)\\n        {\\n            long currvalue = StringToInt(s, j);\\n            if(preValue == -1 || preValue-currvalue == 1)\\n                if(find(s.substring(j+1), currvalue, count+1))\\n                    return true;\\n            else if(preValue != -1 && preValue-currvalue < 0)    \\n                return false;\\n        }\\n        return false;\\n    }\\n    public boolean splitString(String s) {\\n        return find(s, -1, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long StringToInt(String s, int j)\\n    {\\n        long digit = 0;\\n        for(int i = 0 ; i <= j ; i++)\\n            digit = digit * 10 + (int)(s.charAt(i) - \\'0\\');\\n        return digit;\\n    }\\n    boolean find(String s, long preValue, int count)\\n    {\\n        if(s.length() == 0)\\n        {\\n            if(count == 1)\\n                return false;\\n            return true;\\n        }\\n        for(int j = 0 ; j < s.length() ; j++)\\n        {\\n            long currvalue = StringToInt(s, j);\\n            if(preValue == -1 || preValue-currvalue == 1)\\n                if(find(s.substring(j+1), currvalue, count+1))\\n                    return true;\\n            else if(preValue != -1 && preValue-currvalue < 0)    \\n                return false;\\n        }\\n        return false;\\n    }\\n    public boolean splitString(String s) {\\n        return find(s, -1, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713139,
                "title": "elegant-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool solve(string& s,int n,long int w,int i){\\n        if(i>=n) return true;\\n        bool ans=false;\\n      for(int p=1;p<n-i+1;p++){\\n        string f=s.substr(i,p);\\n        long int d=stoul(f);\\n\\n        if(w-d==1){\\n         ans=ans|solve(s,n,d,i+p);\\n        }\\n      }\\n      return ans;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        int n=s.length();\\n        bool ans;\\n        for(int i=0;i<n-1;i++){\\n            string l=s.substr(0,i+1);\\n           long int w=stoul(l);\\n            ans=ans|solve(s,n,w,i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool solve(string& s,int n,long int w,int i){\\n        if(i>=n) return true;\\n        bool ans=false;\\n      for(int p=1;p<n-i+1;p++){\\n        string f=s.substr(i,p);\\n        long int d=stoul(f);\\n\\n        if(w-d==1){\\n         ans=ans|solve(s,n,d,i+p);\\n        }\\n      }\\n      return ans;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        int n=s.length();\\n        bool ans;\\n        for(int i=0;i<n-1;i++){\\n            string l=s.substr(0,i+1);\\n           long int w=stoul(l);\\n            ans=ans|solve(s,n,w,i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691119,
                "title": "python-backtracking",
                "content": "For the must be split into 2 or more substrings requirement we can just check that the last value is not equal to our full value, this works because even if the substring starts with 0 there are no valid follow up answers. We can just loop over our options and exit early if the value becomes larger than our previous.\\n\\n```py\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        al = int(s)\\n        \\n        \\n        def dfs(i,last):\\n            nonlocal al\\n            if i >= len(s):\\n                return last != al\\n            res = False\\n            for j in range(i, len(s)):\\n                v = int(s[i:j+1])\\n                if v < last:\\n                    if abs(last - v) == 1 or last == float(\\'inf\\'):\\n                        res = res or dfs(j + 1, int(s[i:j+1]))\\n                else:\\n                    break\\n            \\n            return res\\n        \\n        \\n        return dfs(0,float(\\'inf\\'))",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "For the must be split into 2 or more substrings requirement we can just check that the last value is not equal to our full value, this works because even if the substring starts with 0 there are no valid follow up answers. We can just loop over our options and exit early if the value becomes larger than our previous.\\n\\n```py\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        al = int(s)\\n        \\n        \\n        def dfs(i,last):\\n            nonlocal al\\n            if i >= len(s):\\n                return last != al\\n            res = False\\n            for j in range(i, len(s)):\\n                v = int(s[i:j+1])\\n                if v < last:\\n                    if abs(last - v) == 1 or last == float(\\'inf\\'):\\n                        res = res or dfs(j + 1, int(s[i:j+1]))\\n                else:\\n                    break\\n            \\n            return res\\n        \\n        \\n        return dfs(0,float(\\'inf\\'))",
                "codeTag": "Java"
            },
            {
                "id": 3652789,
                "title": "java-easier-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n*2^n)$$\\n\\n- Space complexity: $$O(n*2^n)$$\\n\\n# Code\\n```\\nimport java.math.*;\\nclass Solution {\\n    public boolean splitString(String s) {\\n      // I have used BigInteger over here because the long limit will break when the string length gets bigger\\n        return splitString(new BigInteger(\"-1\"), s, 0);\\n    }\\n\\n    private boolean splitString(BigInteger prevNum, String s, int part) {\\n      if (s.isEmpty() && part > 1) return true;\\n      for (int i = 0; i < s.length(); i++) {\\n        var currentNum = new BigInteger(s.substring(0, i + 1));\\n        if ((part == 0 || prevNum.subtract(currentNum).equals(new BigInteger(\"1\"))) && splitString(currentNum, s.substring(i + 1), part + 1)) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nimport java.math.*;\\nclass Solution {\\n    public boolean splitString(String s) {\\n      // I have used BigInteger over here because the long limit will break when the string length gets bigger\\n        return splitString(new BigInteger(\"-1\"), s, 0);\\n    }\\n\\n    private boolean splitString(BigInteger prevNum, String s, int part) {\\n      if (s.isEmpty() && part > 1) return true;\\n      for (int i = 0; i < s.length(); i++) {\\n        var currentNum = new BigInteger(s.substring(0, i + 1));\\n        if ((part == 0 || prevNum.subtract(currentNum).equals(new BigInteger(\"1\"))) && splitString(currentNum, s.substring(i + 1), part + 1)) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602258,
                "title": "python3-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(currIdx, currVal):\\n            if currIdx == len(s) and currVal != int(s):\\n                return True\\n            for i in range(currIdx, len(s)):\\n                nextVal = int(s[currIdx:i + 1])\\n                if currVal == float(\\'inf\\') or (currVal - nextVal == 1):\\n                    if backtrack(i + 1, nextVal):\\n                        return True\\n            return False\\n\\n        return backtrack(0, float(\\'inf\\'))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(currIdx, currVal):\\n            if currIdx == len(s) and currVal != int(s):\\n                return True\\n            for i in range(currIdx, len(s)):\\n                nextVal = int(s[currIdx:i + 1])\\n                if currVal == float(\\'inf\\') or (currVal - nextVal == 1):\\n                    if backtrack(i + 1, nextVal):\\n                        return True\\n            return False\\n\\n        return backtrack(0, float(\\'inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580108,
                "title": "python-simple-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s):\\n\\n        def backtrack(s,path):\\n            if not s and len(path) >= 2:\\n                res.append(path)\\n\\n            for i in range(1,len(s)+1):\\n                if path and (int(s[:i]) > int(path[-1]) or (int(s[:i]) - int(path[-1]) != -1)):\\n                    continue\\n                backtrack(s[i:],path+[s[:i]])\\n\\n        res = []\\n        backtrack(s,[])\\n        return len(res) > 0\\n                \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s):\\n\\n        def backtrack(s,path):\\n            if not s and len(path) >= 2:\\n                res.append(path)\\n\\n            for i in range(1,len(s)+1):\\n                if path and (int(s[:i]) > int(path[-1]) or (int(s[:i]) - int(path[-1]) != -1)):\\n                    continue\\n                backtrack(s[i:],path+[s[:i]])\\n\\n        res = []\\n        backtrack(s,[])\\n        return len(res) > 0\\n                \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490389,
                "title": "c-recursive-solution-o-n-2",
                "content": "```\\n    bool CanSplit(string_view s, uint64_t prev)\\n    {\\n        if (s.empty()) return true;\\n        if (prev == 0) return false;\\n        if (prev == 1) return s.find_first_not_of(\\'0\\') == string_view::npos;\\n\\n        uint64_t curr{ 0 };\\n        while (!s.empty() && curr < prev - 1)\\n        {        \\n            curr = curr * 10 + (s[0] - \\'0\\');\\n            s.remove_prefix(1);            \\n        }\\n\\n        return curr == prev - 1? CanSplit(s, curr) : false;\\n    }\\n\\n    bool splitString(string_view s) \\n    {\\n        uint64_t curr{ 0 };\\n        while (s.size() > 1)\\n        {\\n            curr = curr * 10 + (s[0] - \\'0\\');\\n            s.remove_prefix(1);\\n\\n            if (CanSplit(s, curr)) return true;\\n        }\\n\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    bool CanSplit(string_view s, uint64_t prev)\\n    {\\n        if (s.empty()) return true;\\n        if (prev == 0) return false;\\n        if (prev == 1) return s.find_first_not_of(\\'0\\') == string_view::npos;\\n\\n        uint64_t curr{ 0 };\\n        while (!s.empty() && curr < prev - 1)\\n        {        \\n            curr = curr * 10 + (s[0] - \\'0\\');\\n            s.remove_prefix(1);            \\n        }\\n\\n        return curr == prev - 1? CanSplit(s, curr) : false;\\n    }\\n\\n    bool splitString(string_view s) \\n    {\\n        uint64_t curr{ 0 };\\n        while (s.size() > 1)\\n        {\\n            curr = curr * 10 + (s[0] - \\'0\\');\\n            s.remove_prefix(1);\\n\\n            if (CanSplit(s, curr)) return true;\\n        }\\n\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3410090,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Check if every digit segments are in decreasing order and differ by one\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBacktracking\\n# Complexity\\n- Time complexity: O(n^2)/n! (?)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(prevSum,i,segmentCount):\\n            if i==len(s) and segmentCount > 1:\\n                return True\\n            \\n            currSum=0\\n            for j in range(i,len(s)):\\n                currSum=currSum*10+ord(s[j])-ord(\\'0\\')\\n                if (prevSum==-1 or currSum==prevSum-1) and \\\\\\n                    backtrack(currSum,j+1,segmentCount+1):\\n                    return True\\n            return False\\n        return backtrack(-1,0,0)\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(prevSum,i,segmentCount):\\n            if i==len(s) and segmentCount > 1:\\n                return True\\n            \\n            currSum=0\\n            for j in range(i,len(s)):\\n                currSum=currSum*10+ord(s[j])-ord(\\'0\\')\\n                if (prevSum==-1 or currSum==prevSum-1) and \\\\\\n                    backtrack(currSum,j+1,segmentCount+1):\\n                    return True\\n            return False\\n        return backtrack(-1,0,0)\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403221,
                "title": "splitting-a-string-into-descending-consecutive-values-leetcode-java-solution-by-priyanka",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nRecusive, Backtracking approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public Boolean dfs(List<Long> list,String str,int start){\\n        if(start == str.length()){\\n            return list.size()>=2;\\n        }\\n        long num=0;\\n        for(int i= start;i<str.length();i++){\\n            num=num*10+str.charAt(i)-\\'0\\';\\n            if(list.size() == 0 || list.get(list.size()-1) - num == 1){\\n                list.add(num);\\n                if(dfs(list,str,i+1)) return true;\\n                list.remove(list.size() - 1); \\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean splitString(String s) {\\n        return dfs(new ArrayList<>(),s,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public Boolean dfs(List<Long> list,String str,int start){\\n        if(start == str.length()){\\n            return list.size()>=2;\\n        }\\n        long num=0;\\n        for(int i= start;i<str.length();i++){\\n            num=num*10+str.charAt(i)-\\'0\\';\\n            if(list.size() == 0 || list.get(list.size()-1) - num == 1){\\n                list.add(num);\\n                if(dfs(list,str,i+1)) return true;\\n                list.remove(list.size() - 1); \\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean splitString(String s) {\\n        return dfs(new ArrayList<>(),s,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396087,
                "title": "c-recursive-brute-force-string-subtraction-and-comparison-code-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    string Trimmer(string &str){  // to remove trailing zeros\\n        int i=0;\\n        while(i<str.size() && str[i]==\\'0\\'){\\n            i++;\\n        }\\n        return str.substr(i);\\n    }\\n    \\n    bool isSmaller(string str1, string str2){\\n        str1=Trimmer(str1);\\n        str2=Trimmer(str2);\\n        \\n        int n1=str1.size();\\n        int n2=str2.size();\\n \\n        if(n1<n2){\\n            return true;\\n        }\\n        if(n2<n1){\\n            return false;\\n        } \\n        \\n        for(int i=0;i<n1;i++){\\n            if(str1[i]<str2[i]){\\n                return true;\\n            }\\n            if(str1[i]>str2[i]){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n \\n    string findDiff(string str1, string str2){\\n        if(isSmaller(str1,str2)==true){\\n            return \"-1\";\\n        }\\n        \\n        str1=Trimmer(str1);\\n        str2=Trimmer(str2);\\n\\n        string str=\"\";\\n \\n        int n1=str1.size();\\n        int n2=str2.size();\\n \\n        reverse(str1.begin(),str1.end());\\n        reverse(str2.begin(),str2.end());\\n \\n        int carry=0;\\n        for(int i=0;i<n2;i++){\\n            int sub=(str1[i]-\\'0\\')-(str2[i]-\\'0\\')-carry;\\n            if(sub<0){\\n                sub=sub+10;\\n                carry=1;\\n            }\\n            else{\\n                carry=0;\\n            }\\n            str.push_back(sub + \\'0\\');\\n        }\\n        \\n        for(int i=n2;i<n1;i++){\\n            int sub=(str1[i]-\\'0\\')-carry;\\n            if(sub<0){\\n                sub=sub+10;\\n                carry=1;\\n            }\\n            else{\\n                carry=0;\\n            }\\n            str.push_back(sub+\\'0\\');\\n        }\\n\\n        reverse(str.begin(),str.end());\\n\\n        return Trimmer(str);\\n    }\\n    \\n    bool helper(string &s, int curr, string prevNum){\\n        if(curr==s.size()){\\n            return true;\\n        }\\n        string currNum=\"\";\\n        for(int i=curr;i<s.size();i++){\\n            currNum+=s[i];\\n            if(findDiff(prevNum,currNum)==\"1\" && helper(s,i+1,currNum)==true){\\n                return true;\\n            }\\n        }\\n        return false;\\n    } \\n    \\n    bool splitString(string s) {\\n        string num=\"\";\\n        for(int i=0;i<s.size()-1;i++){\\n            num+=s[i];\\n            if(helper(s,i+1,num)==true){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string Trimmer(string &str){  // to remove trailing zeros\\n        int i=0;\\n        while(i<str.size() && str[i]==\\'0\\'){\\n            i++;\\n        }\\n        return str.substr(i);\\n    }\\n    \\n    bool isSmaller(string str1, string str2){\\n        str1=Trimmer(str1);\\n        str2=Trimmer(str2);\\n        \\n        int n1=str1.size();\\n        int n2=str2.size();\\n \\n        if(n1<n2){\\n            return true;\\n        }\\n        if(n2<n1){\\n            return false;\\n        } \\n        \\n        for(int i=0;i<n1;i++){\\n            if(str1[i]<str2[i]){\\n                return true;\\n            }\\n            if(str1[i]>str2[i]){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n \\n    string findDiff(string str1, string str2){\\n        if(isSmaller(str1,str2)==true){\\n            return \"-1\";\\n        }\\n        \\n        str1=Trimmer(str1);\\n        str2=Trimmer(str2);\\n\\n        string str=\"\";\\n \\n        int n1=str1.size();\\n        int n2=str2.size();\\n \\n        reverse(str1.begin(),str1.end());\\n        reverse(str2.begin(),str2.end());\\n \\n        int carry=0;\\n        for(int i=0;i<n2;i++){\\n            int sub=(str1[i]-\\'0\\')-(str2[i]-\\'0\\')-carry;\\n            if(sub<0){\\n                sub=sub+10;\\n                carry=1;\\n            }\\n            else{\\n                carry=0;\\n            }\\n            str.push_back(sub + \\'0\\');\\n        }\\n        \\n        for(int i=n2;i<n1;i++){\\n            int sub=(str1[i]-\\'0\\')-carry;\\n            if(sub<0){\\n                sub=sub+10;\\n                carry=1;\\n            }\\n            else{\\n                carry=0;\\n            }\\n            str.push_back(sub+\\'0\\');\\n        }\\n\\n        reverse(str.begin(),str.end());\\n\\n        return Trimmer(str);\\n    }\\n    \\n    bool helper(string &s, int curr, string prevNum){\\n        if(curr==s.size()){\\n            return true;\\n        }\\n        string currNum=\"\";\\n        for(int i=curr;i<s.size();i++){\\n            currNum+=s[i];\\n            if(findDiff(prevNum,currNum)==\"1\" && helper(s,i+1,currNum)==true){\\n                return true;\\n            }\\n        }\\n        return false;\\n    } \\n    \\n    bool splitString(string s) {\\n        string num=\"\";\\n        for(int i=0;i<s.size()-1;i++){\\n            num+=s[i];\\n            if(helper(s,i+1,num)==true){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387724,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool rec(int ind,string &s,vector<long long>&temp)\\n    {\\n        if (ind==s.size()){ \\n            if (temp.size()>1)\\n            return true;\\n            return false;\\n            }\\n        long long val=0;\\n        for (int i=ind;i<s.size();i++)\\n        {\\n            val=val*10 + (long long)(s[i]-\\'0\\');\\n            if (val>1e13 || (temp.size()>1 && val>=temp.back())) return false;\\n            if (temp.size()==0 || temp.back()-val==1)\\n            {\\n                temp.push_back(val);\\n                if (rec(i+1,s,temp)) return true;\\n                temp.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) \\n    {\\n        vector<long long>temp;\\n        return rec(0,s,temp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool rec(int ind,string &s,vector<long long>&temp)\\n    {\\n        if (ind==s.size()){ \\n            if (temp.size()>1)\\n            return true;\\n            return false;\\n            }\\n        long long val=0;\\n        for (int i=ind;i<s.size();i++)\\n        {\\n            val=val*10 + (long long)(s[i]-\\'0\\');\\n            if (val>1e13 || (temp.size()>1 && val>=temp.back())) return false;\\n            if (temp.size()==0 || temp.back()-val==1)\\n            {\\n                temp.push_back(val);\\n                if (rec(i+1,s,temp)) return true;\\n                temp.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) \\n    {\\n        vector<long long>temp;\\n        return rec(0,s,temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383493,
                "title": "0ms-c-backtracking",
                "content": "\\n```\\nclass Solution {\\n    unordered_map<string , bool> m;\\npublic:\\n    Solution():m{}{}\\n    bool dfs(int index , string& s ,unsigned long long  prevN ,string prevS){\\n        if(index == s.size()){\\n            //cout << prevN << \" \" << s  << endl ;\\n         \\n            if( prevS == s ) return false;\\n            return true;\\n        }\\n        //if(s.size() - index <= index) return false ;\\n        //if(m.find(s) != m.end()) return m[s];\\n        string st{}; int sze = s.size(); bool flag{false};\\n        for(int i = index ; i < sze ; i++){\\n            st+= s[i];\\n            if(st.size() <=19)\\n            if(( prevN == INT_MIN || (prevN > stoull(st,nullptr , 10) && (prevN - stoull(st,nullptr , 10) ) == 1) ))    \\n                 flag = flag || dfs(i + 1 , s , stoull(st,nullptr , 10)  , st);  \\n \\n     \\n        }\\n        return flag ; \\n\\n    }\\n    bool splitString(string s) {\\n        return dfs(0 , s , INT_MIN , \"\");\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<string , bool> m;\\npublic:\\n    Solution():m{}{}\\n    bool dfs(int index , string& s ,unsigned long long  prevN ,string prevS){\\n        if(index == s.size()){\\n            //cout << prevN << \" \" << s  << endl ;\\n         \\n            if( prevS == s ) return false;\\n            return true;\\n        }\\n        //if(s.size() - index <= index) return false ;\\n        //if(m.find(s) != m.end()) return m[s];\\n        string st{}; int sze = s.size(); bool flag{false};\\n        for(int i = index ; i < sze ; i++){\\n            st+= s[i];\\n            if(st.size() <=19)\\n            if(( prevN == INT_MIN || (prevN > stoull(st,nullptr , 10) && (prevN - stoull(st,nullptr , 10) ) == 1) ))    \\n                 flag = flag || dfs(i + 1 , s , stoull(st,nullptr , 10)  , st);  \\n \\n     \\n        }\\n        return flag ; \\n\\n    }\\n    bool splitString(string s) {\\n        return dfs(0 , s , INT_MIN , \"\");\\n    }\\n}; \\n```",
                "codeTag": "C++"
            },
            {
                "id": 3365569,
                "title": "python-backtracking-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nenumerate all of possible way to split string.\\ntrack stores numbers we have splited from string.\\ndfs(i) split string from position i to the end.\\nif pisition i is at the end and size of track > 1, return True\\nif pisition i is at the end and size of track == 1, return False\\n\\nwe can split string[i:] at the postion j >= i, seperated string is s[i: j+1], and turn into integer.\\nif track is empty, put integer into track, go to dfs(j+1), notice that poping track with backtrack\\nif integer == last number of track -1, go to dfs(j+1), notice that poping track with backtrack\\n\\nif there has no valid way to split string, return False\\n\\ntc is O(n^2), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        track = []\\n        def dfs(i):\\n            if i == len(s):\\n                if len(track) > 1: return True\\n                return False\\n\\n            for j in range(i, len(s)):\\n                num = int(s[i: j+1])\\n                if len(track) == 0 or (track[-1] - 1 == num):\\n                    track.append(num)\\n                    if dfs(j+1): return True\\n                    track.pop()\\n            return False\\n\\n        return dfs(0)   \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```python\\n\\'\\'\\'\\nenumerate all of possible way to split string.\\ntrack stores numbers we have splited from string.\\ndfs(i) split string from position i to the end.\\nif pisition i is at the end and size of track > 1, return True\\nif pisition i is at the end and size of track == 1, return False\\n\\nwe can split string[i:] at the postion j >= i, seperated string is s[i: j+1], and turn into integer.\\nif track is empty, put integer into track, go to dfs(j+1), notice that poping track with backtrack\\nif integer == last number of track -1, go to dfs(j+1), notice that poping track with backtrack\\n\\nif there has no valid way to split string, return False\\n\\ntc is O(n^2), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        track = []\\n        def dfs(i):\\n            if i == len(s):\\n                if len(track) > 1: return True\\n                return False\\n\\n            for j in range(i, len(s)):\\n                num = int(s[i: j+1])\\n                if len(track) == 0 or (track[-1] - 1 == num):\\n                    track.append(num)\\n                    if dfs(j+1): return True\\n                    track.pop()\\n            return False\\n\\n        return dfs(0)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304423,
                "title": "c-solution-fast-solution-easy-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public bool SplitString(string s) {\\n\\n        bool solve(int idx,long prev){\\n            if(idx >= s.Length) return true;\\n            for(int i = 1;i <= s.Length - idx;i++){\\n                string val = s.Substring(idx,i).TrimStart(\\'0\\');\\n                if(val.Length > 11)break;\\n                long cur = (val.Length == 0)? 0 : Int64.Parse(val);\\n                if(cur + 1 == prev && solve(idx + i,cur)) return true;        \\n            }\\n            return false;\\n        }\\n\\n        s = s.TrimStart(\\'0\\');\\n        for(int i = 1;i < s.Length;i++){\\n            string s2 = s.Substring(0,i);\\n            if(s2.Length > 11)break;\\n            if(solve(i,Int64.Parse(s2))) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Backtracking"
                ],
                "code": "```\\npublic class Solution {\\n    public bool SplitString(string s) {\\n\\n        bool solve(int idx,long prev){\\n            if(idx >= s.Length) return true;\\n            for(int i = 1;i <= s.Length - idx;i++){\\n                string val = s.Substring(idx,i).TrimStart(\\'0\\');\\n                if(val.Length > 11)break;\\n                long cur = (val.Length == 0)? 0 : Int64.Parse(val);\\n                if(cur + 1 == prev && solve(idx + i,cur)) return true;        \\n            }\\n            return false;\\n        }\\n\\n        s = s.TrimStart(\\'0\\');\\n        for(int i = 1;i < s.Length;i++){\\n            string s2 = s.Substring(0,i);\\n            if(s2.Length > 11)break;\\n            if(solve(i,Int64.Parse(s2))) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207625,
                "title": "typescript-recursion",
                "content": "# Code\\n```\\nfunction splitString(s) {\\n    return recSplitStr(\\'\\', s) ? true : false;\\n};\\n\\nfunction recSplitStr(p, up) {\\n    debugger;\\n    if (up == \\'\\') {\\n        return true;\\n    }\\n    if (p != \"\" && +p == 0 && +up == 0) {\\n        return true;\\n    }\\n    let flag = false;\\n    for (let i = 0; i < ((p == \"\") ? up.length - 1 : up.length); i++) {\\n        let pNew = up.substring(0, i + 1)\\n        let upNew = up.substring(i + 1, up.length)\\n\\n        if (+pNew != 0 && p == \"\") {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        }\\n        if (+p == 1 && +pNew == 0) {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        } \\n        else if (+pNew != 0 && (+p - +pNew == 1)) {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        }\\n    }\\n    return flag;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction splitString(s) {\\n    return recSplitStr(\\'\\', s) ? true : false;\\n};\\n\\nfunction recSplitStr(p, up) {\\n    debugger;\\n    if (up == \\'\\') {\\n        return true;\\n    }\\n    if (p != \"\" && +p == 0 && +up == 0) {\\n        return true;\\n    }\\n    let flag = false;\\n    for (let i = 0; i < ((p == \"\") ? up.length - 1 : up.length); i++) {\\n        let pNew = up.substring(0, i + 1)\\n        let upNew = up.substring(i + 1, up.length)\\n\\n        if (+pNew != 0 && p == \"\") {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        }\\n        if (+p == 1 && +pNew == 0) {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        } \\n        else if (+pNew != 0 && (+p - +pNew == 1)) {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        }\\n    }\\n    return flag;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3182788,
                "title": "c",
                "content": "```\\nusing ll = long long ;\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        for(int len = 1; len < s.size(); len++)\\n        {\\n            ll num = stoll(s.substr(0, len) ) ;\\n            if(num >= 1e10)\\n                break ;\\n            if(dfs(s, len, num-1))\\n                return true ;\\n        }   \\n        return false ;\\n    }\\n    \\n    bool dfs(string&s, int cur, ll num)\\n    {\\n        if(cur == s.size())\\n            return true ;\\n        for(int len = 1; cur+len <= s.size(); len++)\\n        {\\n            ll num2 = stoll(s.substr(cur, len)) ;\\n            if(num2 > num)\\n                break ;\\n            if( num2 == num && dfs(s, cur+len, num2-1))  \\n                return true ;\\n        }\\n        return false ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nusing ll = long long ;\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        for(int len = 1; len < s.size(); len++)\\n        {\\n            ll num = stoll(s.substr(0, len) ) ;\\n            if(num >= 1e10)\\n                break ;\\n            if(dfs(s, len, num-1))\\n                return true ;\\n        }   \\n        return false ;\\n    }\\n    \\n    bool dfs(string&s, int cur, ll num)\\n    {\\n        if(cur == s.size())\\n            return true ;\\n        for(int len = 1; cur+len <= s.size(); len++)\\n        {\\n            ll num2 = stoll(s.substr(cur, len)) ;\\n            if(num2 > num)\\n                break ;\\n            if( num2 == num && dfs(s, cur+len, num2-1))  \\n                return true ;\\n        }\\n        return false ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166077,
                "title": "79-ms",
                "content": "```ruby\\ndef split_string s\\n    return false if (x = s[/0*\\\\d/].size) == (z = s.size)\\n    f = -> i, t do\\n        !!(y = s[i..][/0*#{t}/]&.size) &&\\n            ((i += y) == z || f.(i, t - 1))\\n    end\\n    (x...z).any? { f.call _1, s[0, _1].to_i - 1 }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef split_string s\\n    return false if (x = s[/0*\\\\d/].size) == (z = s.size)\\n    f = -> i, t do\\n        !!(y = s[i..][/0*#{t}/]&.size) &&\\n            ((i += y) == z || f.(i, t - 1))\\n    end\\n    (x...z).any? { f.call _1, s[0, _1].to_i - 1 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3161849,
                "title": "python-backtracking-solution",
                "content": "\\n```\\nclass Solution(object):\\n    def splitString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def backtrack(stack, substr):\\n\\t\\t\\t# Made it to the end of s\\n            if not substr:\\n                return True\\n\\t\\t\\t\\n\\t\\t\\t# Try all substrings of length 1 to len(substr) for a valid decreasing substring\\n            for i in range(1, len(substr)+1):\\n\\t\\t\\t\\n\\t\\t\\t\\t# Push to stack if no initial value or current substring is one less than previously seen substring\\n                if not stack or int(substr[:i]) == stack[-1] - 1:\\n                    stack.append(int(substr[:i]))\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# Made it to the end of s and s can be split into at least two substrings\\n                    if backtrack(stack, substr[i:]) and len(stack) > 1:\\n                        return True\\n                    stack.pop()\\n\\n            return False\\n\\n        return backtrack([], s)\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def splitString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def backtrack(stack, substr):\\n\\t\\t\\t# Made it to the end of s\\n            if not substr:\\n                return True\\n\\t\\t\\t\\n\\t\\t\\t# Try all substrings of length 1 to len(substr) for a valid decreasing substring\\n            for i in range(1, len(substr)+1):\\n\\t\\t\\t\\n\\t\\t\\t\\t# Push to stack if no initial value or current substring is one less than previously seen substring\\n                if not stack or int(substr[:i]) == stack[-1] - 1:\\n                    stack.append(int(substr[:i]))\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# Made it to the end of s and s can be split into at least two substrings\\n                    if backtrack(stack, substr[i:]) and len(stack) > 1:\\n                        return True\\n                    stack.pop()\\n\\n            return False\\n\\n        return backtrack([], s)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3161164,
                "title": "backtracking-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    using ull = unsigned long long;\\n\\n    bool solve(vector<ull>& path, string& s, int i) {\\n        if(i == s.size()) return true;\\n\\n        ull num = 0;\\n\\n        for(int j=i; j<s.size()-1+(not path.empty()); j++) {\\n            num = 10*num + (s[j]-\\'0\\');\\n\\n            if(path.empty() or path.back()-num == 1) {\\n                path.push_back(num);\\n\\n                if(solve(path, s, j+1)) return true;\\n\\n                path.pop_back();\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool splitString(string s) {\\n        vector<ull> path;\\n        return solve(path, s, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ull = unsigned long long;\\n\\n    bool solve(vector<ull>& path, string& s, int i) {\\n        if(i == s.size()) return true;\\n\\n        ull num = 0;\\n\\n        for(int j=i; j<s.size()-1+(not path.empty()); j++) {\\n            num = 10*num + (s[j]-\\'0\\');\\n\\n            if(path.empty() or path.back()-num == 1) {\\n                path.push_back(num);\\n\\n                if(solve(path, s, j+1)) return true;\\n\\n                path.pop_back();\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool splitString(string s) {\\n        vector<ull> path;\\n        return solve(path, s, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148183,
                "title": "slow-scala-dfs-with-foldleft-and-memoizations",
                "content": "# Code\\n```\\nobject Solution {\\n  import math.BigInt\\n  def splitString(s: String): Boolean = {\\n    val cache = collection.mutable.Map.empty[Seq[Char],Seq[Seq[Seq[Char]]]]\\n    val cache2 = collection.mutable.Map.empty[(Seq[Char],Seq[Char]),Boolean]\\n    val cache3 = collection.mutable.Map.empty[Seq[Char],BigInt]\\n    def dropZeros(seq: Seq[Char]): Seq[Char] =\\n      if(seq.size <=1) seq\\n      else if (seq.head == \\'0\\') dropZeros(seq.tail)\\n      else seq\\n    def impl(seq:Seq[Char]): Seq[Seq[Seq[Char]]] = {\\n      if(seq.isEmpty) Seq()\\n      else if(cache.contains(seq)) cache(seq)\\n       else {\\n        val rc = List(List(seq)) ++ (1 until (seq.size)).to(List).flatMap{case i =>\\n          lazy val (d0,t0) = seq.splitAt(i)\\n          lazy val (d,t) = (dropZeros(d0),dropZeros(t0))\\n          impl(t).map(d +: _)\\n        }\\n        cache += (seq -> rc)\\n        rc\\n      }\\n    }\\n    def toBigInt(s: Seq[Char]): BigInt = {\\n      if(cache3.contains(s)) cache3(s) else {\\n        lazy val t = s.dropWhile(_ == \\'0\\')\\n        val rc = if(t.isEmpty) BigInt(0) else BigInt(s.mkString)\\n        cache3 += (s -> rc)\\n        rc\\n      }\\n    }\\n    def compare2(a: Seq[Char], b: Seq[Char]): Boolean = {\\n      if(cache2.contains(a,b)) cache2(a,b) else {\\n        val rc = toBigInt(a) - toBigInt(b) == BigInt(1)\\n        cache2 += ((a,b) -> rc)\\n        rc\\n      }\\n    }\\n    def check(seq: Seq[Seq[Char]]): Boolean = \\n      (seq.size > 1) && seq.sliding(2,1).forall{l => compare2(l(0),l(1)) }\\n    lazy val y0 = dropZeros(s) //s.dropWhile(_ == \\'0\\')\\n    if(y0.size<2) false else { \\n      impl(y0).exists(check)\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  import math.BigInt\\n  def splitString(s: String): Boolean = {\\n    val cache = collection.mutable.Map.empty[Seq[Char],Seq[Seq[Seq[Char]]]]\\n    val cache2 = collection.mutable.Map.empty[(Seq[Char],Seq[Char]),Boolean]\\n    val cache3 = collection.mutable.Map.empty[Seq[Char],BigInt]\\n    def dropZeros(seq: Seq[Char]): Seq[Char] =\\n      if(seq.size <=1) seq\\n      else if (seq.head == \\'0\\') dropZeros(seq.tail)\\n      else seq\\n    def impl(seq:Seq[Char]): Seq[Seq[Seq[Char]]] = {\\n      if(seq.isEmpty) Seq()\\n      else if(cache.contains(seq)) cache(seq)\\n       else {\\n        val rc = List(List(seq)) ++ (1 until (seq.size)).to(List).flatMap{case i =>\\n          lazy val (d0,t0) = seq.splitAt(i)\\n          lazy val (d,t) = (dropZeros(d0),dropZeros(t0))\\n          impl(t).map(d +: _)\\n        }\\n        cache += (seq -> rc)\\n        rc\\n      }\\n    }\\n    def toBigInt(s: Seq[Char]): BigInt = {\\n      if(cache3.contains(s)) cache3(s) else {\\n        lazy val t = s.dropWhile(_ == \\'0\\')\\n        val rc = if(t.isEmpty) BigInt(0) else BigInt(s.mkString)\\n        cache3 += (s -> rc)\\n        rc\\n      }\\n    }\\n    def compare2(a: Seq[Char], b: Seq[Char]): Boolean = {\\n      if(cache2.contains(a,b)) cache2(a,b) else {\\n        val rc = toBigInt(a) - toBigInt(b) == BigInt(1)\\n        cache2 += ((a,b) -> rc)\\n        rc\\n      }\\n    }\\n    def check(seq: Seq[Seq[Char]]): Boolean = \\n      (seq.size > 1) && seq.sliding(2,1).forall{l => compare2(l(0),l(1)) }\\n    lazy val y0 = dropZeros(s) //s.dropWhile(_ == \\'0\\')\\n    if(y0.size<2) false else { \\n      impl(y0).exists(check)\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3109263,
                "title": "go-beats-100-runtime-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$ (n=s.length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"strconv\"\\n)\\n\\nfunc valid(s string, t string) bool {\\n\\tsi, _ := strconv.Atoi(s)\\n\\tti, _ := strconv.Atoi(t)\\n\\treturn si-ti == 1\\n}\\n\\nfunc splitString(s string) bool {\\n\\tvar dfs func(i int, prev string, cnt int) bool\\n\\tdfs = func(i int, prev string, cnt int) bool {\\n\\n\\t\\tif i == len(s) && cnt > 1 {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tfor j := i; j < len(s); j++ {\\n\\t\\t\\tif prev == \"\" || valid(prev, s[i:j+1]) {\\n\\t\\t\\t\\tif dfs(j+1, s[i:j+1], i+1) {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\treturn dfs(0, \"\", 0)\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"strconv\"\\n)\\n\\nfunc valid(s string, t string) bool {\\n\\tsi, _ := strconv.Atoi(s)\\n\\tti, _ := strconv.Atoi(t)\\n\\treturn si-ti == 1\\n}\\n\\nfunc splitString(s string) bool {\\n\\tvar dfs func(i int, prev string, cnt int) bool\\n\\tdfs = func(i int, prev string, cnt int) bool {\\n\\n\\t\\tif i == len(s) && cnt > 1 {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tfor j := i; j < len(s); j++ {\\n\\t\\t\\tif prev == \"\" || valid(prev, s[i:j+1]) {\\n\\t\\t\\t\\tif dfs(j+1, s[i:j+1], i+1) {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\treturn dfs(0, \"\", 0)\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3103709,
                "title": "c-concise-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> v;\\n    bool ans = false;\\n    void solve(const string& s, int i = 0) {\\n        if (s.size() == i and v.size() > 1) {\\n            ans = true;\\n        }\\n        for (unsigned long long c = 0; i < s.size() and !ans; i++) {\\n            c = c * 10 + (s[i] - \\'0\\');\\n            if (v.empty() or v.back() - 1 == c) {\\n                v.push_back(c);\\n                solve(s, i + 1);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    bool splitString(string s) {\\n        solve(s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> v;\\n    bool ans = false;\\n    void solve(const string& s, int i = 0) {\\n        if (s.size() == i and v.size() > 1) {\\n            ans = true;\\n        }\\n        for (unsigned long long c = 0; i < s.size() and !ans; i++) {\\n            c = c * 10 + (s[i] - \\'0\\');\\n            if (v.empty() or v.back() - 1 == c) {\\n                v.push_back(c);\\n                solve(s, i + 1);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    bool splitString(string s) {\\n        solve(s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103473,
                "title": "java-easy-updated-top-voted-solution-beats-100",
                "content": "I could not finish my code and looked discussion. I saw @vikrant_pc \\' s java solution which was top voted. I changed it a little bit to make it faster and easier to understand. Hope this helps somebody else!\\n\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isRemainingValid(s, -1); // input is positive so we can use negative temp value as previous\\n    }\\n    private boolean isRemainingValid(String s, double previous) {\\n\\t   // \"21474836482147483647\" max true input so double should be enough\\n        double current =0;\\n        for(int i=0;i<s.length();i++) {\\n            current = current * 10 + s.charAt(i)-\\'0\\';\\n            if(previous != -1 && previous < current) return false; // prev always should be bigger, since decreasing expected\\n            if(previous == -1) {\\n                if (isRemainingValid(s.substring(i+1), current)) \\n                    return true;\\n            } else if(current == previous - 1 && (i==s.length()-1 || isRemainingValid(s.substring(i+1), current)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n`if(previous != null && previous < current) return false;`  this avoids a lot of unnecessary conditions. Like if current =10 and prev = 5 , there is no way you can return true because eventually we want it to be decreasing.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isRemainingValid(s, -1); // input is positive so we can use negative temp value as previous\\n    }\\n    private boolean isRemainingValid(String s, double previous) {\\n\\t   // \"21474836482147483647\" max true input so double should be enough\\n        double current =0;\\n        for(int i=0;i<s.length();i++) {\\n            current = current * 10 + s.charAt(i)-\\'0\\';\\n            if(previous != -1 && previous < current) return false; // prev always should be bigger, since decreasing expected\\n            if(previous == -1) {\\n                if (isRemainingValid(s.substring(i+1), current)) \\n                    return true;\\n            } else if(current == previous - 1 && (i==s.length()-1 || isRemainingValid(s.substring(i+1), current)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099338,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(string s, int index, long long int prev){\\n        if(index == s.length()) return true;\\n        for(int i = index ;  i < s.length() ; i++){\\n            long long int val = stoull(s.substr(index,i-index+1));\\n            if((val+1 == prev) && dfs(s,i+1,val)) return true;\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        int index = 0;\\n        // As we need two splits every time so not going upto one less than length\\n        for(int i = 0 ; i < s.length()-1;i++){\\n            long long int val = stoull(s.substr(index,i-index+1));\\n            if(dfs(s,i+1,val)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(string s, int index, long long int prev){\\n        if(index == s.length()) return true;\\n        for(int i = index ;  i < s.length() ; i++){\\n            long long int val = stoull(s.substr(index,i-index+1));\\n            if((val+1 == prev) && dfs(s,i+1,val)) return true;\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        int index = 0;\\n        // As we need two splits every time so not going upto one less than length\\n        for(int i = 0 ; i < s.length()-1;i++){\\n            long long int val = stoull(s.substr(index,i-index+1));\\n            if(dfs(s,i+1,val)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084934,
                "title": "on-time-on-space-0ms-my-fastest-solution-explained",
                "content": "\\n```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084556,
                "title": "easy-to-understand-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    \\n    def helper(self,s,prev,idx):\\n        \\n        if(idx == len(s) and prev != s ):\\n            \\n            \\n            return True \\n        \\n        c = \"\"\\n    \\n        for i in range(idx,len(s)):\\n            \\n            c += s[i]\\n            \\n            if(prev != \"\"):\\n                \\n                if(int(prev) - int(c) == 1 ):\\n            \\n                    if(self.helper(s,c,i+1)): \\n                        \\n                        return True \\n                    \\n            else:\\n                \\n                if(self.helper(s,c,i+1)):\\n                    \\n                    return True \\n                \\n        \\n        return False \\n        \\n        \\n    \\n    def splitString(self, s: str) -> bool:\\n        \\n        return self.helper(s,\"\",0)\\n        \\n    \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def helper(self,s,prev,idx):\\n        \\n        if(idx == len(s) and prev != s ):\\n            \\n            \\n            return True \\n        \\n        c = \"\"\\n    \\n        for i in range(idx,len(s)):\\n            \\n            c += s[i]\\n            \\n            if(prev != \"\"):\\n                \\n                if(int(prev) - int(c) == 1 ):\\n            \\n                    if(self.helper(s,c,i+1)): \\n                        \\n                        return True \\n                    \\n            else:\\n                \\n                if(self.helper(s,c,i+1)):\\n                    \\n                    return True \\n                \\n        \\n        return False \\n        \\n        \\n    \\n    def splitString(self, s: str) -> bool:\\n        \\n        return self.helper(s,\"\",0)\\n        \\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074532,
                "title": "python-short-dfs-solution",
                "content": "```\\ndef splitString(self, s: str) -> bool:\\n\\tdef dfs(p, idx):\\n\\t\\tif idx==len(s):\\n\\t\\t\\treturn True\\n\\t\\tfor i in range(idx, len(s)):\\n\\t\\t\\tif p-1==int(s[idx:i+1]) and dfs(int(s[idx:i+1]), i+1):\\n\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\treturn any(dfs(int(s[:i+1]), i+1) for i in range(len(s)-1))\\n```",
                "solutionTags": [],
                "code": "```\\ndef splitString(self, s: str) -> bool:\\n\\tdef dfs(p, idx):\\n\\t\\tif idx==len(s):\\n\\t\\t\\treturn True\\n\\t\\tfor i in range(idx, len(s)):\\n\\t\\t\\tif p-1==int(s[idx:i+1]) and dfs(int(s[idx:i+1]), i+1):\\n\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\treturn any(dfs(int(s[:i+1]), i+1) for i in range(len(s)-1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3026296,
                "title": "java-dfs-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        \\n     for(int i = 0; i < s.length()-1; i++){ // needs to be split to atleast two partions so iterating up until len - 1\\n         Double  val = Double.parseDouble(s.substring(0, i+1));\\n\\n        if(dfs(i+1, s, val)) // for each partition size check the other remaining string with varying partition\\n            return true;\\n     }\\n     return false;\\n    }\\n\\n    public boolean dfs(int index, String s, Double prev){\\n\\n        if(index == s.length())\\n            return true;\\n\\n        for(int j = index ;j < s.length(); j++) {\\n             Double  val = Double.parseDouble(s.substring(index, j+1));\\n             if(prev == val+1 && dfs(j+1, s, val) ){\\n                 return true;\\n             }\\n        }\\n    return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        \\n     for(int i = 0; i < s.length()-1; i++){ // needs to be split to atleast two partions so iterating up until len - 1\\n         Double  val = Double.parseDouble(s.substring(0, i+1));\\n\\n        if(dfs(i+1, s, val)) // for each partition size check the other remaining string with varying partition\\n            return true;\\n     }\\n     return false;\\n    }\\n\\n    public boolean dfs(int index, String s, Double prev){\\n\\n        if(index == s.length())\\n            return true;\\n\\n        for(int j = index ;j < s.length(); j++) {\\n             Double  val = Double.parseDouble(s.substring(index, j+1));\\n             if(prev == val+1 && dfs(j+1, s, val) ){\\n                 return true;\\n             }\\n        }\\n    return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960365,
                "title": "python-top-down-dp-o-n-3",
                "content": "\\n# Code\\n```\\nfrom functools import cache\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @cache\\n        def dfs(prev, s):\\n            if not s: return True\\n            res = False\\n            for i in range(len(s)):\\n                cur = int(s[:i+1])\\n                if prev - 1 == cur:\\n                    res = res or dfs(cur, s[i+1:])\\n            return res\\n        for i in range(len(s)-1):\\n            if dfs(int(s[:i+1]), s[i+1:]): return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import cache\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @cache\\n        def dfs(prev, s):\\n            if not s: return True\\n            res = False\\n            for i in range(len(s)):\\n                cur = int(s[:i+1])\\n                if prev - 1 == cur:\\n                    res = res or dfs(cur, s[i+1:])\\n            return res\\n        for i in range(len(s)-1):\\n            if dfs(int(s[:i+1]), s[i+1:]): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958847,
                "title": "hardcoded",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHardcode\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHardcoded, but be ware of the cringe edgecases.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) as the size of string is 20 at max\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        string head = \"\";\\n        int n = s.size();\\n        bool mt = false;\\n        int l = 0;\\n        for(int i = 0; i < n; i++){\\n            head = head+s[i];\\n            if(s[i] != \\'0\\') mt = true;\\n            if(mt) l++;\\n            if(2*l - 1> n) break;\\n            long long x = stoll(head);\\n            long long y = 0;\\n            long long c = x;\\n            for(int j = i+1; j < n; j++){\\n                y = y*10+s[j]-\\'0\\';\\n                if(y == c-1){\\n                    c = y;\\n                    if(c == 0) c = 1;\\n                    y = 0;\\n                    if(j == n-1) return true;\\n                }\\n                if(y >= c) break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        string head = \"\";\\n        int n = s.size();\\n        bool mt = false;\\n        int l = 0;\\n        for(int i = 0; i < n; i++){\\n            head = head+s[i];\\n            if(s[i] != \\'0\\') mt = true;\\n            if(mt) l++;\\n            if(2*l - 1> n) break;\\n            long long x = stoll(head);\\n            long long y = 0;\\n            long long c = x;\\n            for(int j = i+1; j < n; j++){\\n                y = y*10+s[j]-\\'0\\';\\n                if(y == c-1){\\n                    c = y;\\n                    if(c == 0) c = 1;\\n                    y = 0;\\n                    if(j == n-1) return true;\\n                }\\n                if(y >= c) break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932480,
                "title": "java-rec-big-integer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.*;\\n\\nclass Solution {\\n    public boolean splitString(String s) {\\n\\t\\treturn f(0, new BigInteger(\"0\"),0, s);\\n\\t}\\n\\n\\tboolean f(int i, BigInteger prev,int size , String s) {\\n\\t\\tif (i == s.length())\\n\\t\\t\\treturn size >= 2;\\n\\t\\tfor (int j = i; j < s.length(); j++) {\\n\\t\\t\\tBigInteger temp = new BigInteger(s.substring(i, j + 1));\\n\\t\\t\\tif (i == 0 || prev.subtract(temp).equals(new BigInteger(\"1\"))) \\n\\t\\t\\t\\tif (f(j + 1, temp,size + 1, s))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.*;\\n\\nclass Solution {\\n    public boolean splitString(String s) {\\n\\t\\treturn f(0, new BigInteger(\"0\"),0, s);\\n\\t}\\n\\n\\tboolean f(int i, BigInteger prev,int size , String s) {\\n\\t\\tif (i == s.length())\\n\\t\\t\\treturn size >= 2;\\n\\t\\tfor (int j = i; j < s.length(); j++) {\\n\\t\\t\\tBigInteger temp = new BigInteger(s.substring(i, j + 1));\\n\\t\\t\\tif (i == 0 || prev.subtract(temp).equals(new BigInteger(\"1\"))) \\n\\t\\t\\t\\tif (f(j + 1, temp,size + 1, s))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898689,
                "title": "c-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867636,
                "title": "c-backtracking-palindromic-partitioning-follow-up",
                "content": "```\\nvoid fun(string &s,int ind,vector<vector<string>> &res,vector<string> &cont)\\n{\\n    \\n    if(cont.size()>0 && cont[0].size()==s.size())return;\\n    if(cont.size()>=2)\\n    {\\n        for(int j=0;j<cont.size()-1;j++)\\n        {\\n            unsigned long long int x1= stoull(cont[j]);\\n           unsigned long long int x2= stoull(cont[j+1]);\\n            if(x1!=x2+1)return;}\\n    }\\n    if(ind==s.size())\\n    {\\n        res.push_back(cont);\\n        return;\\n    }\\n\\n    for(int i=ind;i<s.size();i++)\\n        {\\n            \\n                cont.push_back(s.substr(ind,i-ind+1));\\n                fun(s,i+1,res,cont);\\n                cont.pop_back();\\n            \\n        }    \\n}\\nbool splitString(string s) {\\n    vector<vector<string>> res;\\n    vector<string> cont;\\n    fun(s,0,res,cont);\\n    return res.size()>=1?true:false;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvoid fun(string &s,int ind,vector<vector<string>> &res,vector<string> &cont)\\n{\\n    \\n    if(cont.size()>0 && cont[0].size()==s.size())return;\\n    if(cont.size()>=2)\\n    {\\n        for(int j=0;j<cont.size()-1;j++)\\n        {\\n            unsigned long long int x1= stoull(cont[j]);\\n           unsigned long long int x2= stoull(cont[j+1]);\\n            if(x1!=x2+1)return;}\\n    }\\n    if(ind==s.size())\\n    {\\n        res.push_back(cont);\\n        return;\\n    }\\n\\n    for(int i=ind;i<s.size();i++)\\n        {\\n            \\n                cont.push_back(s.substr(ind,i-ind+1));\\n                fun(s,i+1,res,cont);\\n                cont.pop_back();\\n            \\n        }    \\n}\\nbool splitString(string s) {\\n    vector<vector<string>> res;\\n    vector<string> cont;\\n    fun(s,0,res,cont);\\n    return res.size()>=1?true:false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2812513,
                "title": "python-backtracking",
                "content": "\\n    def splitString(self, s: str) -> bool:\\n        \\n        def backtrack(idx, preVal):\\n            if idx == len(s):\\n                return True\\n            \\n            for j in range(idx, len(s)):\\n                val = int(s[idx:j+1])\\n                if val+1 == preVal and backtrack(j+1, val): # as descending. so val +1 compare with pre val\\n                    return True\\n            return False\\n        \\n        for i in range(len(s)-1):\\n            val = int(s[:i+1])\\n            if backtrack(i+1, val):\\n                return True\\n        return False",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "\\n    def splitString(self, s: str) -> bool:\\n        \\n        def backtrack(idx, preVal):\\n            if idx == len(s):\\n                return True\\n            \\n            for j in range(idx, len(s)):\\n                val = int(s[idx:j+1])\\n                if val+1 == preVal and backtrack(j+1, val): # as descending. so val +1 compare with pre val\\n                    return True\\n            return False\\n        \\n        for i in range(len(s)-1):\\n            val = int(s[:i+1])\\n            if backtrack(i+1, val):\\n                return True\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 2736181,
                "title": "greedy-intuition-c-explained-in-hindi",
                "content": "```\\n vector<long long> curr;\\n    bool solve(string s,int start)\\n    {\\n        //base case --> if curr vector size > 2 then we have splitted correctly\\n        if(start>=s.size())\\n            return curr.size()>=2;\\n        \\n        for(int i=start;i<s.size();i++)\\n        {\\n            long long val=stoll(s.substr(start,i-start+1));\\n            \\n            //Step 1 --> If ek number hi 1e11 ka hai to iske agla number b 1e11 ka hi hoga as (difference bw the 2 numbers should be 1 and s.size()<=20 constraints)\\n            \\n            if(val>1e11)\\n                return false;\\n            \\n            // Step 2 -> If curr vector me kuch hai to bakc() se chota hona chiye current value (WE HAVE TO FORM DECREASING)  \\n            \\n            //IMPORTANT --> If previous wali ek bdi nahi hai to koi aur ho skti bdi aage return false thodi krdege aage dhundo koi\\n            \\n            if(curr.size()>0 and curr.back()-val!=1)\\n                continue;    \\n            \\n            curr.push_back(val);  //push into vector\\n            \\n            if(solve(s,i+1))  // recursively solve\\n                return true;\\n            \\n            curr.pop_back();  //backtracking step\\n        }\\n        return false;  //kahi bhi ans nahi mila\\n    }\\n    \\n    bool splitString(string s) {\\n        \\n        return solve(s,0);\\n    }",
                "solutionTags": [],
                "code": "```\\n vector<long long> curr;\\n    bool solve(string s,int start)\\n    {\\n        //base case --> if curr vector size > 2 then we have splitted correctly\\n        if(start>=s.size())\\n            return curr.size()>=2;\\n        \\n        for(int i=start;i<s.size();i++)\\n        {\\n            long long val=stoll(s.substr(start,i-start+1));\\n            \\n            //Step 1 --> If ek number hi 1e11 ka hai to iske agla number b 1e11 ka hi hoga as (difference bw the 2 numbers should be 1 and s.size()<=20 constraints)\\n            \\n            if(val>1e11)\\n                return false;\\n            \\n            // Step 2 -> If curr vector me kuch hai to bakc() se chota hona chiye current value (WE HAVE TO FORM DECREASING)  \\n            \\n            //IMPORTANT --> If previous wali ek bdi nahi hai to koi aur ho skti bdi aage return false thodi krdege aage dhundo koi\\n            \\n            if(curr.size()>0 and curr.back()-val!=1)\\n                continue;    \\n            \\n            curr.push_back(val);  //push into vector\\n            \\n            if(solve(s,i+1))  // recursively solve\\n                return true;\\n            \\n            curr.pop_back();  //backtracking step\\n        }\\n        return false;  //kahi bhi ans nahi mila\\n    }\\n    \\n    bool splitString(string s) {\\n        \\n        return solve(s,0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2730767,
                "title": "strip-zeros-to-make-your-life-easy-python",
                "content": "After stripping zeros you can use `startsWith` check to see if string starts with a number you need\\n\\n```\\n    def splitString(self, s: str) -> bool:\\n        def solve(i, num):\\n            if i == len(s): return True\\n            if num == 0: return \"0\"*(len(s) - i) == s[i:]\\n            \\n            # strip zeros\\n            while i < len(s) and s[i] == \\'0\\': i += 1 \\n                \\n            numStr = str(num)\\n            if not s.startswith(numStr, i): return False\\n            return solve(i + len(numStr), num - 1)\\n        \\n        for i in range(1, len(s)):\\n            if solve(i, int(s[:i]) - 1): return True\\n        \\n        return False",
                "solutionTags": [],
                "code": "After stripping zeros you can use `startsWith` check to see if string starts with a number you need\\n\\n```\\n    def splitString(self, s: str) -> bool:\\n        def solve(i, num):\\n            if i == len(s): return True\\n            if num == 0: return \"0\"*(len(s) - i) == s[i:]\\n            \\n            # strip zeros\\n            while i < len(s) and s[i] == \\'0\\': i += 1 \\n                \\n            numStr = str(num)\\n            if not s.startswith(numStr, i): return False\\n            return solve(i + len(numStr), num - 1)\\n        \\n        for i in range(1, len(s)):\\n            if solve(i, int(s[:i]) - 1): return True\\n        \\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 2704048,
                "title": "js-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function(s) {\\n    if (parseInt(s, 10) < 10) return false\\n\\n    const stripFirstZeroes = str => {\\n        while (str[0] === \\'0\\' && str.length > 1) {\\n            str = str.substring(1)\\n        }\\n        return str\\n    }\\n\\n    s = stripFirstZeroes(s)\\n\\n    const checkNumValid = (num, str) => {\\n        if (str.length === 0) return true\\n\\n        str = stripFirstZeroes(str)\\n\\n        if (num === 1) return str === \\'0\\'\\n\\n        var nextNum = num - 1\\n        if (str.startsWith(nextNum.toString())) {\\n            return checkNumValid(nextNum, str.replace(nextNum.toString(), \\'\\'))\\n        }\\n\\n        return false\\n    }\\n\\n    let firstNum = \\'\\'\\n    for (var i = 0; i < Math.ceil(s.length / 2); i++) {\\n        firstNum += s[i]\\n        if (checkNumValid(parseInt(firstNum, 10), s.replace(firstNum, \\'\\'))) {\\n            return true\\n        }\\n    }\\n\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function(s) {\\n    if (parseInt(s, 10) < 10) return false\\n\\n    const stripFirstZeroes = str => {\\n        while (str[0] === \\'0\\' && str.length > 1) {\\n            str = str.substring(1)\\n        }\\n        return str\\n    }\\n\\n    s = stripFirstZeroes(s)\\n\\n    const checkNumValid = (num, str) => {\\n        if (str.length === 0) return true\\n\\n        str = stripFirstZeroes(str)\\n\\n        if (num === 1) return str === \\'0\\'\\n\\n        var nextNum = num - 1\\n        if (str.startsWith(nextNum.toString())) {\\n            return checkNumValid(nextNum, str.replace(nextNum.toString(), \\'\\'))\\n        }\\n\\n        return false\\n    }\\n\\n    let firstNum = \\'\\'\\n    for (var i = 0; i < Math.ceil(s.length / 2); i++) {\\n        firstNum += s[i]\\n        if (checkNumValid(parseInt(firstNum, 10), s.replace(firstNum, \\'\\'))) {\\n            return true\\n        }\\n    }\\n\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2681403,
                "title": "python-backtracking-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @cache\\n        def backtrack(remaining: str, prev: int) -> bool:\\n            if remaining == \\'\\':\\n                return True\\n            for i in range(len(remaining)):\\n                if int(remaining[:i + 1]) == prev - 1:\\n                    if backtrack(remaining[i + 1:], prev - 1):\\n                        return True\\n            return False\\n        \\n        for i in range(len(s) - 1):\\n            if backtrack(s[i + 1:], int(s[:i + 1])):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @cache\\n        def backtrack(remaining: str, prev: int) -> bool:\\n            if remaining == \\'\\':\\n                return True\\n            for i in range(len(remaining)):\\n                if int(remaining[:i + 1]) == prev - 1:\\n                    if backtrack(remaining[i + 1:], prev - 1):\\n                        return True\\n            return False\\n        \\n        for i in range(len(s) - 1):\\n            if backtrack(s[i + 1:], int(s[:i + 1])):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660476,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    \\n    def helper(self,s,idx,idx2,prev):\\n        \\n        if(idx == len(s) and idx2 == 1):\\n            \\n            return True \\n        \\n        c = \"\"\\n        for i in range(idx,len(s)):\\n            \\n            c += s[i]\\n            \\n            if(idx != 0 ):\\n                \\n                val = int(prev) - int(c)\\n                \\n                \\n                \\n                if(val == 1):\\n                    \\n                    if(self.helper(s,i+1,val,c)):\\n                        \\n                        return True \\n                \\n            else:\\n                \\n                if(self.helper(s,i+1,0,c)):\\n                    \\n                    return True \\n        \\n        \\n        return False \\n            \\n            \\n    \\n    def splitString(self, s: str) -> bool:\\n        \\n        \\n        return self.helper(s,0,0,\"\")\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def helper(self,s,idx,idx2,prev):\\n        \\n        if(idx == len(s) and idx2 == 1):\\n            \\n            return True \\n        \\n        c = \"\"\\n        for i in range(idx,len(s)):\\n            \\n            c += s[i]\\n            \\n            if(idx != 0 ):\\n                \\n                val = int(prev) - int(c)\\n                \\n                \\n                \\n                if(val == 1):\\n                    \\n                    if(self.helper(s,i+1,val,c)):\\n                        \\n                        return True \\n                \\n            else:\\n                \\n                if(self.helper(s,i+1,0,c)):\\n                    \\n                    return True \\n        \\n        \\n        return False \\n            \\n            \\n    \\n    def splitString(self, s: str) -> bool:\\n        \\n        \\n        return self.helper(s,0,0,\"\")\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634916,
                "title": "c-backtracking",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool splitString(string s) {\\n\\t\\t\\tint n=s.length();\\n\\t\\t\\tint c=0;\\n\\t\\t\\tfunction<bool(long,int)> recur=[&](long val,int x){\\n\\t\\t\\t\\tif(x==n) {\\n\\t\\t\\t\\t\\treturn c>1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstring str=\"\";\\n\\t\\t\\t\\tbool res=false;\\n\\t\\t\\t\\twhile(x<n-1&&s[x]==\\'0\\'&&s[x+1]==\\'0\\') x++;\\n\\t\\t\\t\\tfor(int i=x;i<min(x+10,n);i++) {\\n\\t\\t\\t\\t\\tstr+=s[i];\\n\\t\\t\\t\\t\\tif(val==LONG_MAX||val-stol(str)==1) {\\n\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t\\tres=res||recur(stol(str),i+1);\\n\\t\\t\\t\\t\\t\\tc--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t};\\n\\t\\t\\treturn recur(LONG_MAX,0);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool splitString(string s) {\\n\\t\\t\\tint n=s.length();\\n\\t\\t\\tint c=0;\\n\\t\\t\\tfunction<bool(long,int)> recur=[&](long val,int x){\\n\\t\\t\\t\\tif(x==n) {\\n\\t\\t\\t\\t\\treturn c>1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2632013,
                "title": "clear-python-dfs-with-comments",
                "content": "```python\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        \"\"\"\\n        Time = O(2^N)\\n        Space = O(N) space from stack\\n        \\n        \"\"\"\\n        def dfs(index: int, last: int) -> bool:\\n            if index == len(s):\\n                return True\\n            \\n\\t\\t\\t# j: [index, len(s)-1]\\n            for j in range(index, len(s)):\\n\\t\\t\\t\\t# cur: [index, index] ~ [index, len(s)-1]\\n                cur = int(s[index:j + 1])\\n\\t\\t\\t\\t# last: [...,index-1]\\n\\t\\t\\t\\t# cur: [index+1, j]\\n\\t\\t\\t\\t# last = cur -> next: [j+1,...)\\n\\t\\t\\t\\t# DFS condition: cur = last - 1 && dfs(j+1, cur) == true\\n                if cur == last - 1 and dfs(j + 1, cur):\\n                    return True\\n            return False\\n        \\n        for i in range(len(s) - 1):\\n            last = int(s[:i+1])\\n            if dfs(i + 1, last):\\n                return True\\n        return False\\n\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        \"\"\"\\n        Time = O(2^N)\\n        Space = O(N) space from stack\\n        \\n        \"\"\"\\n        def dfs(index: int, last: int) -> bool:\\n            if index == len(s):\\n                return True\\n            \\n\\t\\t\\t# j: [index, len(s)-1]\\n            for j in range(index, len(s)):\\n\\t\\t\\t\\t# cur: [index, index] ~ [index, len(s)-1]\\n                cur = int(s[index:j + 1])\\n\\t\\t\\t\\t# last: [...,index-1]\\n\\t\\t\\t\\t# cur: [index+1, j]\\n\\t\\t\\t\\t# last = cur -> next: [j+1,...)\\n\\t\\t\\t\\t# DFS condition: cur = last - 1 && dfs(j+1, cur) == true\\n                if cur == last - 1 and dfs(j + 1, cur):\\n                    return True\\n            return False\\n        \\n        for i in range(len(s) - 1):\\n            last = int(s[:i+1])\\n            if dfs(i + 1, last):\\n                return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619890,
                "title": "simple-backtracking-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool helper(string a, string b){\\n        if(stoull(a)-stoull(b)==1) return true;\\n        for(int i=1; i<b.length(); i++){\\n            string x=b.substr(0, i);\\n            string y=b.substr(i, b.length()-i);\\n            if(stoull(b.substr(0, i)) != stoull(a)-1) continue;\\n            if(helper(x, y)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        for(int i=1; i<s.length(); i++){\\n            string a=s.substr(0, i);\\n            string b=s.substr(i, s.length()-i);\\n            if(helper(a, b))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(string a, string b){\\n        if(stoull(a)-stoull(b)==1) return true;\\n        for(int i=1; i<b.length(); i++){\\n            string x=b.substr(0, i);\\n            string y=b.substr(i, b.length()-i);\\n            if(stoull(b.substr(0, i)) != stoull(a)-1) continue;\\n            if(helper(x, y)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        for(int i=1; i<s.length(); i++){\\n            string a=s.substr(0, i);\\n            string b=s.substr(i, s.length()-i);\\n            if(helper(a, b))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573352,
                "title": "golang-simple-backtracking-solution",
                "content": "```go\\nfunc splitString(s string) bool {\\n  return backtrack(s, 0, -1)\\n}\\n\\nfunc backtrack(s string, pos int, prev int) bool {\\n  if len(s) == pos {\\n    return true\\n  }\\n  var x int\\n  // We want at least two non-empty substrings, so if we\\'re\\n  // starting from position 0, we don\\'t want to go till the end.\\n  end := len(s)\\n  if pos == 0 {\\n    end = len(s)-1\\n  }\\n  for i := pos; i < end; i++ {\\n    x = x * 10 + int(s[i]-\\'0\\')\\n    if prev != -1 && x != prev-1 {\\n      continue\\n    }\\n    if backtrack(s, i+1, x) {\\n      return true\\n    }\\n  }\\n  return false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```go\\nfunc splitString(s string) bool {\\n  return backtrack(s, 0, -1)\\n}\\n\\nfunc backtrack(s string, pos int, prev int) bool {\\n  if len(s) == pos {\\n    return true\\n  }\\n  var x int\\n  // We want at least two non-empty substrings, so if we\\'re\\n  // starting from position 0, we don\\'t want to go till the end.\\n  end := len(s)\\n  if pos == 0 {\\n    end = len(s)-1\\n  }\\n  for i := pos; i < end; i++ {\\n    x = x * 10 + int(s[i]-\\'0\\')\\n    if prev != -1 && x != prev-1 {\\n      continue\\n    }\\n    if backtrack(s, i+1, x) {\\n      return true\\n    }\\n  }\\n  return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569971,
                "title": "simple-java-backtracking-solution",
                "content": "```\\n/**\\n * time complexity : O(N^2)\\n * space complexity: O(N)\\n */\\n\\nclass Solution {\\n\\tprivate String s;\\n\\n\\tpublic boolean splitString(String s) {\\n\\t\\tthis.s = s;\\n\\t\\treturn backTrack(-1l, 0);\\n\\t}\\n\\n\\tprivate boolean backTrack(long last, int j) {\\n\\n\\t\\tif (j == s.length()) // found it\\n\\t\\t\\treturn true;\\n\\n\\t\\tlong cur = 0l;\\n\\n\\t\\tfor (int i = j; i < s.length(); i++) {\\n\\n\\t\\t\\tcur = cur * 10 + (s.charAt(i) - \\'0\\'); // add current char\\n\\n\\t\\t\\tif (cur > 10000000000L || last == -1 && i + 1 == s.length()) // will make overflow || found only one substring\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tif ((last == -1 || last - cur == 1) && backTrack(cur, i + 1)) // first substring || difference between last,cur numbers is 1\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n}",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\tprivate String s;\\n\\n\\tpublic boolean splitString(String s) {\\n\\t\\tthis.s = s;\\n\\t\\treturn backTrack(-1l, 0);\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2556816,
                "title": "c-recoursion",
                "content": "```\\npublic class Solution {\\n    \\n    bool Solve(string s, long prev){\\n        if (s.Length <= 0)\\n            return true;\\n\\n        for (long i = 0, current = 0; i < s.Length && current < long.MaxValue / 10; ++i){\\n            current = current * 10 + (s[(int)i] - \\'0\\');\\n            \\n            if ((i != s.Length - 1 && prev == -1 || prev - current == 1) && \\n\\t\\t\\t     Solve(s.Substring((int)i + 1), current))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public bool SplitString(string s) => Solve(s, -1);\\n        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    bool Solve(string s, long prev){\\n        if (s.Length <= 0)\\n            return true;\\n\\n        for (long i = 0, current = 0; i < s.Length && current < long.MaxValue / 10; ++i){\\n            current = current * 10 + (s[(int)i] - \\'0\\');\\n            \\n            if ((i != s.Length - 1 && prev == -1 || prev - current == 1) && \\n\\t\\t\\t     Solve(s.Substring((int)i + 1), current))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public bool SplitString(string s) => Solve(s, -1);\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507858,
                "title": "rust-recursion",
                "content": "```\\nimpl Solution {\\n    fn c_to_i(ch: char) -> i128 {\\n        match ch {\\n            \\'0\\' => 0,\\n            \\'1\\' => 1,\\n            \\'2\\' => 2,\\n            \\'3\\' => 3,\\n            \\'4\\' => 4,\\n            \\'5\\' => 5,\\n            \\'6\\' => 6,\\n            \\'7\\' => 7,\\n            \\'8\\' => 8,\\n            \\'9\\' => 9,\\n            _ => panic!(\"Invalid character in ctoi\")\\n        }\\n    }\\n\\n    fn str_to_i(str: &str) -> i128 {\\n        let mut num: i128 = 0;\\n        for ch in str.chars() {\\n            num = num * 10 + Self::c_to_i(ch);\\n        }\\n        return num;\\n    }\\n\\n    fn rec(str: &str, start: usize, end: usize, prev_num: i128) -> bool {\\n        let len = str.len();\\n        if end >= len {\\n            return false;\\n        }\\n\\n        let num = Solution::str_to_i(&str[start..=end]);\\n        if start != 0 && prev_num - num != 1 {\\n            return false;\\n        }\\n        if end == len - 1 {\\n            return true;\\n        }\\n\\n        for i in 0..(len - end) {\\n            let ret = Solution::rec(str, end + 1, end + 1 + i, num);\\n            if ret {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    pub fn split_string(s: String) -> bool {\\n        let len = s.len();\\n        for i in 0..(len - 1) {\\n            let ret = Solution::rec(&s, 0, i, -1);\\n            if ret {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```\\nimpl Solution {\\n    fn c_to_i(ch: char) -> i128 {\\n        match ch {\\n            \\'0\\' => 0,\\n            \\'1\\' => 1,\\n            \\'2\\' => 2,\\n            \\'3\\' => 3,\\n            \\'4\\' => 4,\\n            \\'5\\' => 5,\\n            \\'6\\' => 6,\\n            \\'7\\' => 7,\\n            \\'8\\' => 8,\\n            \\'9\\' => 9,\\n            _ => panic!(\"Invalid character in ctoi\")\\n        }\\n    }\\n\\n    fn str_to_i(str: &str) -> i128 {\\n        let mut num: i128 = 0;\\n        for ch in str.chars() {\\n            num = num * 10 + Self::c_to_i(ch);\\n        }\\n        return num;\\n    }\\n\\n    fn rec(str: &str, start: usize, end: usize, prev_num: i128) -> bool {\\n        let len = str.len();\\n        if end >= len {\\n            return false;\\n        }\\n\\n        let num = Solution::str_to_i(&str[start..=end]);\\n        if start != 0 && prev_num - num != 1 {\\n            return false;\\n        }\\n        if end == len - 1 {\\n            return true;\\n        }\\n\\n        for i in 0..(len - end) {\\n            let ret = Solution::rec(str, end + 1, end + 1 + i, num);\\n            if ret {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    pub fn split_string(s: String) -> bool {\\n        let len = s.len();\\n        for i in 0..(len - 1) {\\n            let ret = Solution::rec(&s, 0, i, -1);\\n            if ret {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457579,
                "title": "c-solution-backtracking",
                "content": "```\\n#define MAX_SPLIT_VAL   10000000000         // at least 2 splits should be there and per split cannot have value greater than 10 digits\\nbool backtrack(char *s, int len, int idx, long preVal) {\\n    \\n    // success: end of the string which means we have found all\\n    // valid splits previously\\n    if(idx >= len) return true;\\n    \\n    char sPart[21] = {\\'\\\\0\\'};\\n    for(int i = idx; i < len; i++) {\\n        strncpy(sPart, s+idx, i - idx + 1);\\n        long long cVal = atol(sPart);\\n        if(cVal >= MAX_SPLIT_VAL) return false;\\n        \\n        // the previous value should be 1 greater than current value\\n        // and further splits after current should follow same condition\\n        if(preVal == cVal + 1 && backtrack(s, len, i+1, cVal))\\n            return true;\\n    }\\n    return false;\\n}\\n\\nbool splitString(char * s){\\n    int len = strlen(s);\\n    \\n    if(1 == len) return false;\\n    \\n    char split[21] = {\\'\\\\0\\'}, *ptr;\\n    // check single, double, triple digits\\n    for(int i = 0; i < len-1; i++) {\\n        strncpy(split, s, i+1);\\n        long long val = atol(split);\\n        if(val >= MAX_SPLIT_VAL) return false;\\n        // printf(\"split string is %s val is %ld\\\\n\", split, val);\\n        if(backtrack(s, len, i+1, val)) return true;\\n    }\\n    return false;\\n}\\n```\\n\\n**Time:** O(N^2), \\n**Space:** O(N) for recursion call stack",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n#define MAX_SPLIT_VAL   10000000000         // at least 2 splits should be there and per split cannot have value greater than 10 digits\\nbool backtrack(char *s, int len, int idx, long preVal) {\\n    \\n    // success: end of the string which means we have found all\\n    // valid splits previously\\n    if(idx >= len) return true;\\n    \\n    char sPart[21] = {\\'\\\\0\\'};\\n    for(int i = idx; i < len; i++) {\\n        strncpy(sPart, s+idx, i - idx + 1);\\n        long long cVal = atol(sPart);\\n        if(cVal >= MAX_SPLIT_VAL) return false;\\n        \\n        // the previous value should be 1 greater than current value\\n        // and further splits after current should follow same condition\\n        if(preVal == cVal + 1 && backtrack(s, len, i+1, cVal))\\n            return true;\\n    }\\n    return false;\\n}\\n\\nbool splitString(char * s){\\n    int len = strlen(s);\\n    \\n    if(1 == len) return false;\\n    \\n    char split[21] = {\\'\\\\0\\'}, *ptr;\\n    // check single, double, triple digits\\n    for(int i = 0; i < len-1; i++) {\\n        strncpy(split, s, i+1);\\n        long long val = atol(split);\\n        if(val >= MAX_SPLIT_VAL) return false;\\n        // printf(\"split string is %s val is %ld\\\\n\", split, val);\\n        if(backtrack(s, len, i+1, val)) return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2442835,
                "title": "java-recursion-and-backtracking-explained-tc-sc-explained",
                "content": "// This is a classic recursion question\\n// Each time we FORM a number and then RECURSIVELY check if the \"remianing substring\" and this \"number\" satisfies ALL the rules, otherwise keep appending the  rest of the chars from string to this number\\n\\n// TC : O(N^2); N = s.length()\\n// SC : O(N); recursion stack\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isPossible(s, null);\\n    }\\n    \\n    // Long and not long in parameter because \\'long\\' cannot take \\'null\\' but \\'Long\\' can\\n    private boolean isPossible(String s, Long previousNum) {\\n        long currentNum = 0;\\n        \\n        // ALWAYS starting making num for o idx only because each time the string \\'s\\' has changed to s.substring(i + 1)\\n        for(int i = 0; i < s.length(); i++) {\\n            currentNum = currentNum * 10 + s.charAt(i) - \\'0\\'; // form the number\\n            if(currentNum >= 10000000000L) { // longer than long range; avoids overflow\\n                return false;\\n            }\\n            \\n            if(previousNum == null) { // no previous num exists, meaning making the fresh current num\\n                if(isPossible(s.substring(i + 1), currentNum)) { // recursively check if the remaining substring and current num satisifes the rules\\n                    return true;\\n                }\\n            } // if there exists a number FORMED previously then check if the current num and previous num have a diff of 1 with (previous num > current num) AND\\n            // if either we have reached the end to string \\'s\\' OR\\n            // the remaining substring ALSO satisfies the rules,\\n            // then return TRUE otherwise keep forming number and checking ALL the rules\\n            else if (currentNum == previousNum - 1 && (i == s.length() - 1 || isPossible(s.substring(i + 1), currentNum))) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isPossible(s, null);\\n    }\\n    \\n    // Long and not long in parameter because \\'long\\' cannot take \\'null\\' but \\'Long\\' can\\n    private boolean isPossible(String s, Long previousNum) {\\n        long currentNum = 0;\\n        \\n        // ALWAYS starting making num for o idx only because each time the string \\'s\\' has changed to s.substring(i + 1)\\n        for(int i = 0; i < s.length(); i++) {\\n            currentNum = currentNum * 10 + s.charAt(i) - \\'0\\'; // form the number\\n            if(currentNum >= 10000000000L) { // longer than long range; avoids overflow\\n                return false;\\n            }\\n            \\n            if(previousNum == null) { // no previous num exists, meaning making the fresh current num\\n                if(isPossible(s.substring(i + 1), currentNum)) { // recursively check if the remaining substring and current num satisifes the rules\\n                    return true;\\n                }\\n            } // if there exists a number FORMED previously then check if the current num and previous num have a diff of 1 with (previous num > current num) AND\\n            // if either we have reached the end to string \\'s\\' OR\\n            // the remaining substring ALSO satisfies the rules,\\n            // then return TRUE otherwise keep forming number and checking ALL the rules\\n            else if (currentNum == previousNum - 1 && (i == s.length() - 1 || isPossible(s.substring(i + 1), currentNum))) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424344,
                "title": "python-backtrack-clean",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, last_value):\\n            if i == len(s):\\n                return last_value != int(s)\\n            \\n            for j in range(i, len(s)):\\n                if (last_value is None or last_value - int(s[i:j + 1]) == 1) and dfs(j + 1, int(s[i:j + 1])):\\n                    return True\\n            return False\\n        return dfs(0, None)",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, last_value):\\n            if i == len(s):\\n                return last_value != int(s)\\n            \\n            for j in range(i, len(s)):\\n                if (last_value is None or last_value - int(s[i:j + 1]) == 1) and dfs(j + 1, int(s[i:j + 1])):\\n                    return True\\n            return False\\n        return dfs(0, None)",
                "codeTag": "Java"
            },
            {
                "id": 2419111,
                "title": "ruby-backtracing",
                "content": "```\\n# @param {String} s\\n# @return {Boolean}\\ndef split_string(s)\\n    @path = []\\n    @result = []\\n    @string = s\\n    dfs(0)\\n    return !@result.empty?\\nend\\n\\ndef dfs(i)\\n    if i == @string.length && @path.length > 1\\n       @result << @path[0..-1] \\n       return \\n    end\\n    j = i\\n    while(j < @string.length)\\n       @path << @string[i..j]\\n       if condition \\n         dfs(j+1) \\n       end\\n       @path.pop \\n       j = j + 1 \\n    end\\nend\\n\\ndef condition\\n   @path.length == 1 || (@path[-1].to_i + 1 == @path[-2].to_i)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} s\\n# @return {Boolean}\\ndef split_string(s)\\n    @path = []\\n    @result = []\\n    @string = s\\n    dfs(0)\\n    return !@result.empty?\\nend\\n\\ndef dfs(i)\\n    if i == @string.length && @path.length > 1\\n       @result << @path[0..-1] \\n       return \\n    end\\n    j = i\\n    while(j < @string.length)\\n       @path << @string[i..j]\\n       if condition \\n         dfs(j+1) \\n       end\\n       @path.pop \\n       j = j + 1 \\n    end\\nend\\n\\ndef condition\\n   @path.length == 1 || (@path[-1].to_i + 1 == @path[-2].to_i)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2384619,
                "title": "typescript-100",
                "content": "```\\nfunction splitString(s: string): boolean {\\n    \\n    let n = s.length;\\n    \\n    function isValid(i, last) {\\n        if(i>=n) {\\n            return true;\\n        }\\n        \\n        for(let j= 1; j<=n; j++) {\\n            let val = +s.substr(i,j);\\n            if(val == last -1 && isValid(i+j, val)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    for(let i=1; i<n; i++) {\\n        if(isValid(i, +s.substr(0,i))) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/660dedc7-e7f9-4bad-bcf3-7b4d5724fb63_1659729260.4821222.png)\\n",
                "solutionTags": [],
                "code": "```\\nfunction splitString(s: string): boolean {\\n    \\n    let n = s.length;\\n    \\n    function isValid(i, last) {\\n        if(i>=n) {\\n            return true;\\n        }\\n        \\n        for(let j= 1; j<=n; j++) {\\n            let val = +s.substr(i,j);\\n            if(val == last -1 && isValid(i+j, val)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    for(let i=1; i<n; i++) {\\n        if(isValid(i, +s.substr(0,i))) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2370716,
                "title": "python-3-dfs-short-and-concise",
                "content": "choose the first No. and corrensponding to that do the DFS\\n\\n\\tclass Solution:\\n\\t\\tdef splitString(self, s: str) -> bool:\\n\\t\\t\\tn=len(s)\\n\\t\\t\\tdef solve(i,last):\\n\\t\\t\\t\\tif i==n:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tfor j in range(i+1,n+1):\\n\\t\\t\\t\\t\\tk=int(s[i:j])\\n\\t\\t\\t\\t\\tif last-k==1 and solve(j,k):\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tfor i in range(1,n):\\n\\t\\t\\t\\tif solve(i,int(s[:i])):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "choose the first No. and corrensponding to that do the DFS\\n\\n\\tclass Solution:\\n\\t\\tdef splitString(self, s: str) -> bool:\\n\\t\\t\\tn=len(s)\\n\\t\\t\\tdef solve(i,last):\\n\\t\\t\\t\\tif i==n:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tfor j in range(i+1,n+1):\\n\\t\\t\\t\\t\\tk=int(s[i:j])\\n\\t\\t\\t\\t\\tif last-k==1 and solve(j,k):\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tfor i in range(1,n):\\n\\t\\t\\t\\tif solve(i,int(s[:i])):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False",
                "codeTag": "Java"
            },
            {
                "id": 2353252,
                "title": "c-recursive-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool flag=false;\\n    \\n    void func(string &s,int idx,int ct,long long prev){\\n        if (idx>=s.length()){\\n            if (ct<=1){\\n                return;\\n            }\\n\\n            flag=true;\\n            return;\\n        }\\n        \\n        string str;\\n        for (int i=idx; i<s.length(); i++){\\n            str+=s[i];\\n            if (str.length()>18){\\n                reverse(str.begin(),str.end());\\n                while (str.back()==\\'0\\'){\\n                    str.pop_back();\\n                }\\n                reverse(str.begin(),str.end());\\n                \\n                if (str.length()>18){\\n                   continue;\\n                }\\n            }\\n                \\n            long long val=stoll(str);\\n            \\n            if (prev==-1 || prev-val==1){\\n                func(s,i+1,ct+1,val);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool splitString(string s) {\\n       func(s,0,0,-1);\\n     return flag;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool flag=false;\\n    \\n    void func(string &s,int idx,int ct,long long prev){\\n        if (idx>=s.length()){\\n            if (ct<=1){\\n                return;\\n            }\\n\\n            flag=true;\\n            return;\\n        }\\n        \\n        string str;\\n        for (int i=idx; i<s.length(); i++){\\n            str+=s[i];\\n            if (str.length()>18){\\n                reverse(str.begin(),str.end());\\n                while (str.back()==\\'0\\'){\\n                    str.pop_back();\\n                }\\n                reverse(str.begin(),str.end());\\n                \\n                if (str.length()>18){\\n                   continue;\\n                }\\n            }\\n                \\n            long long val=stoll(str);\\n            \\n            if (prev==-1 || prev-val==1){\\n                func(s,i+1,ct+1,val);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool splitString(string s) {\\n       func(s,0,0,-1);\\n     return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353193,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool helper(string s,long long int prev){\\n        if(s.size()==0){\\n            return true;\\n        }\\n        long long int curr=0;\\n        for(int i=0;i<s.size();i++){\\n            if(curr>=1e17){\\n                break;\\n            }\\n            curr=curr*(long long)10+(s[i]-\\'0\\');\\n            if((i!=s.size()-1&&prev==-1||prev-curr==1)&&helper(s.substr(i+1),curr)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        return helper(s,-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(string s,long long int prev){\\n        if(s.size()==0){\\n            return true;\\n        }\\n        long long int curr=0;\\n        for(int i=0;i<s.size();i++){\\n            if(curr>=1e17){\\n                break;\\n            }\\n            curr=curr*(long long)10+(s[i]-\\'0\\');\\n            if((i!=s.size()-1&&prev==-1||prev-curr==1)&&helper(s.substr(i+1),curr)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        return helper(s,-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305778,
                "title": "elegant-c-faster-than-100",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    typedef long long ll;\\n    bool cansplit(int sidx, ll prev, string &s)\\n    {\\n        if (sidx >= s.size())\\n            return true;\\n\\n        ll num = 0;\\n\\n        for (int i = sidx; i < s.size(); i++)\\n        {\\n            if (sidx == 0 && i + 1 == s.size())\\n                break;\\n\\n                if(num>=1e17)\\n                    break;\\n                    \\n            num = num * (ll)10 +   (s[i] - \\'0\\');\\n\\n            if (prev == -1 || prev - num == 1)\\n            {\\n\\n                if (cansplit(i + 1, num, s))\\n                    return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool splitString(string s)\\n    {\\n        return cansplit(0, -1, s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    typedef long long ll;\\n    bool cansplit(int sidx, ll prev, string &s)\\n    {\\n        if (sidx >= s.size())\\n            return true;\\n\\n        ll num = 0;\\n\\n        for (int i = sidx; i < s.size(); i++)\\n        {\\n            if (sidx == 0 && i + 1 == s.size())\\n                break;\\n\\n                if(num>=1e17)\\n                    break;\\n                    \\n            num = num * (ll)10 +   (s[i] - \\'0\\');\\n\\n            if (prev == -1 || prev - num == 1)\\n            {\\n\\n                if (cansplit(i + 1, num, s))\\n                    return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool splitString(string s)\\n    {\\n        return cansplit(0, -1, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305679,
                "title": "java-backtracking-with-try-catch-for-parselong-d",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        \\n        for(int i=0; i<s.length()-1; i++){\\n            \\n            \\n            if(backtrack(s,i+1,s.substring(0,i+1))){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    boolean backtrack(String s, int i, String prev){\\n        \\n        if(i == s.length()){\\n            return true;\\n        }\\n        \\n        if(prev.length() >= 20){\\n            return false;\\n        }\\n        \\n        long prevVal;\\n        \\n        try{\\n            prevVal = Long.parseLong(prev);\\n        }catch(NumberFormatException e){\\n            return false;\\n        }\\n        \\n        \\n        for(int j=i; j<s.length(); j++){\\n            \\n            String curr = s.substring(i,j+1);\\n            Long val;\\n            \\n            try{\\n                val = Long.parseLong(curr);\\n            }catch(NumberFormatException e){\\n                continue;\\n            }\\n             \\n            \\n            if(val + 1 == prevVal && backtrack(s,j+1,curr)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        \\n        for(int i=0; i<s.length()-1; i++){\\n            \\n            \\n            if(backtrack(s,i+1,s.substring(0,i+1))){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    boolean backtrack(String s, int i, String prev){\\n        \\n        if(i == s.length()){\\n            return true;\\n        }\\n        \\n        if(prev.length() >= 20){\\n            return false;\\n        }\\n        \\n        long prevVal;\\n        \\n        try{\\n            prevVal = Long.parseLong(prev);\\n        }catch(NumberFormatException e){\\n            return false;\\n        }\\n        \\n        \\n        for(int j=i; j<s.length(); j++){\\n            \\n            String curr = s.substring(i,j+1);\\n            Long val;\\n            \\n            try{\\n                val = Long.parseLong(curr);\\n            }catch(NumberFormatException e){\\n                continue;\\n            }\\n             \\n            \\n            if(val + 1 == prevVal && backtrack(s,j+1,curr)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299660,
                "title": "backtracking-python-easy",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        tmp = []\\n        def isValid(tmp):\\n            for i in range(1, len(tmp)):\\n                if tmp[i]  != tmp[i-1] - 1: # 2 != 1 -1\\n                    return False\\n            return True\\n        def helper(i):\\n            if i >= len(s):\\n                if isValid(tmp):\\n                    return True\\n                return False\\n            for j in range(1, len(s)):\\n                if len(tmp) >= 2:\\n                    if tmp[-1] + 1 != tmp[-2]:\\n                        return False\\n                tmp.append(int(s[i: i+j]))\\n                if helper(i+j):\\n                    return True\\n                tmp.pop()\\n            return False        \\n\\n        return helper(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        tmp = []\\n        def isValid(tmp):\\n            for i in range(1, len(tmp)):\\n                if tmp[i]  != tmp[i-1] - 1: # 2 != 1 -1\\n                    return False\\n            return True\\n        def helper(i):\\n            if i >= len(s):\\n                if isValid(tmp):\\n                    return True\\n                return False\\n            for j in range(1, len(s)):\\n                if len(tmp) >= 2:\\n                    if tmp[-1] + 1 != tmp[-2]:\\n                        return False\\n                tmp.append(int(s[i: i+j]))\\n                if helper(i+j):\\n                    return True\\n                tmp.pop()\\n            return False        \\n\\n        return helper(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279891,
                "title": "javascript-fast-simple-memory-efficient-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function (s, previous) {\\n    if (s.length === 1) return false;\\n\\n    for (let i = 1; i < s.length; i++) {\\n        const first = Number(s.substring(0, i));\\n\\n        if (first === previous - 1 || previous === undefined) {\\n\\n            for (let j = i + 1; j <= s.length; j++) {\\n                const second = Number(s.substring(i, j));\\n\\n                if (second === first - 1) {\\n                    if (j === s.length || Number(s.substring(j)) === second - 1) return true;\\n                    else {\\n                        const found = splitString(s.substring(j), second);\\n                        if (found) return true;\\n                    }\\n                }\\n            }\\n        }\\n        // if no such substring found return false\\n        if (i === s.length - 1) return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function (s, previous) {\\n    if (s.length === 1) return false;\\n\\n    for (let i = 1; i < s.length; i++) {\\n        const first = Number(s.substring(0, i));\\n\\n        if (first === previous - 1 || previous === undefined) {\\n\\n            for (let j = i + 1; j <= s.length; j++) {\\n                const second = Number(s.substring(i, j));\\n\\n                if (second === first - 1) {\\n                    if (j === s.length || Number(s.substring(j)) === second - 1) return true;\\n                    else {\\n                        const found = splitString(s.substring(j), second);\\n                        if (found) return true;\\n                    }\\n                }\\n            }\\n        }\\n        // if no such substring found return false\\n        if (i === s.length - 1) return false\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2211155,
                "title": "c-backtracking-4ms",
                "content": "```\\nbool recurse(string s, int i, long long prev, long long curr) {\\n    if (i>=s.size()) {\\n        return curr <= prev && prev-curr==1;\\n    }\\n    if (curr<=prev && curr*10+s[i]-48 <= prev) {\\n        if (recurse(s, i+1, prev, curr*10+s[i]-48)){\\n            return true;\\n        }\\n    }\\n    if (s[i]-48 <= curr && prev-curr == 1) {\\n        return recurse(s, i+1, curr, s[i]-48);\\n    }\\n    return false;\\n}\\n\\nbool splitString(string s) {\\n    long long n=s.size();\\n    if (n<2) {\\n        return false;\\n    }\\n    if (n==2) {\\n        return s[0]-s[1]==1;\\n    }\\n    long long prev=0;\\n    for (int i=0;i<n-1;i++) {\\n        if (i==n-2 && prev>100) {\\n            return false;\\n        }\\n        prev = prev*10+s[i]-48;\\n        if (recurse(s, i+2, prev, s[i+1]-48)) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nbool recurse(string s, int i, long long prev, long long curr) {\\n    if (i>=s.size()) {\\n        return curr <= prev && prev-curr==1;\\n    }\\n    if (curr<=prev && curr*10+s[i]-48 <= prev) {\\n        if (recurse(s, i+1, prev, curr*10+s[i]-48)){\\n            return true;\\n        }\\n    }\\n    if (s[i]-48 <= curr && prev-curr == 1) {\\n        return recurse(s, i+1, curr, s[i]-48);\\n    }\\n    return false;\\n}\\n\\nbool splitString(string s) {\\n    long long n=s.size();\\n    if (n<2) {\\n        return false;\\n    }\\n    if (n==2) {\\n        return s[0]-s[1]==1;\\n    }\\n    long long prev=0;\\n    for (int i=0;i<n-1;i++) {\\n        if (i==n-2 && prev>100) {\\n            return false;\\n        }\\n        prev = prev*10+s[i]-48;\\n        if (recurse(s, i+2, prev, s[i+1]-48)) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152720,
                "title": "backtracking-solution-for-java-with-comments",
                "content": "```\\n\\t/*\\n        Returns true if \\'s\\' from index \\'start\\' can be split\\n    */\\n    public boolean backtrack(String s, int start, long previous) {\\n        if (start == s.length()) { // Base Case: If we reach end of string, then we found a valid split\\n            return true;\\n        }\\n        \\n        StringBuilder current = new StringBuilder();\\n        int end = s.length() - 1;\\n        if (previous == -1) // This is needed to ensure that there will always be at two substrings in the split\\n            end -= 1;\\n        \\n        long val = 0;\\n        for (int i = start; i <= end; i++) {\\n            current.append(s.charAt(i)); // Try s[:i], s[:i+1], s[:i+2]....\\n            \\n            val = val*10 + (s.charAt(i) - \\'0\\');\\n            \\n            // If s[:i] == previous-1, and s[i+1:] can be split up, then return true\\n            if ((previous-val == 1 || previous == -1) && backtrack(s, i+1, val)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n\\t/*\\n        Returns true if \\'s\\' from index \\'start\\' can be split\\n    */\\n    public boolean backtrack(String s, int start, long previous) {\\n        if (start == s.length()) { // Base Case: If we reach end of string, then we found a valid split\\n            return true;\\n        }\\n        \\n        StringBuilder current = new StringBuilder();\\n        int end = s.length() - 1;\\n        if (previous == -1) // This is needed to ensure that there will always be at two substrings in the split\\n            end -= 1;\\n        \\n        long val = 0;\\n        for (int i = start; i <= end; i++) {\\n            current.append(s.charAt(i)); // Try s[:i], s[:i+1], s[:i+2]....\\n            \\n            val = val*10 + (s.charAt(i) - \\'0\\');\\n            \\n            // If s[:i] == previous-1, and s[i+1:] can be split up, then return true\\n            if ((previous-val == 1 || previous == -1) && backtrack(s, i+1, val)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112950,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn split_string(s: String) -> bool {\\n        if s.len() == 0 || Self::parse_int(&s) == 0 {\\n            return false;\\n        }\\n        for i in 0..s.len() {\\n            let prev = Self::parse_int(&s[(s.len() - i - 1)..s.len()]);\\n            if Self::helper(&s[..(s.len() - i - 1)], prev) {\\n                return true;\\n            }\\n        }\\n        false\\n    }\\n\\n    fn helper(s: &str, prev: i128) -> bool {\\n        if s.len() == 0 {\\n            return false;\\n        }\\n        for i in 0..s.len() {\\n            let current = Self::parse_int(&s[(s.len() - i - 1)..s.len()]);\\n            if current - prev == 1 {\\n                let sl = &s[..(s.len()) - i - 1];\\n                if sl.len() == 0 || Self::helper(sl, current) {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n\\n    fn parse_int(s: &str) -> i128 {\\n        s.parse::<i128>().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn split_string(s: String) -> bool {\\n        if s.len() == 0 || Self::parse_int(&s) == 0 {\\n            return false;\\n        }\\n        for i in 0..s.len() {\\n            let prev = Self::parse_int(&s[(s.len() - i - 1)..s.len()]);\\n            if Self::helper(&s[..(s.len() - i - 1)], prev) {\\n                return true;\\n            }\\n        }\\n        false\\n    }\\n\\n    fn helper(s: &str, prev: i128) -> bool {\\n        if s.len() == 0 {\\n            return false;\\n        }\\n        for i in 0..s.len() {\\n            let current = Self::parse_int(&s[(s.len() - i - 1)..s.len()]);\\n            if current - prev == 1 {\\n                let sl = &s[..(s.len()) - i - 1];\\n                if sl.len() == 0 || Self::helper(sl, current) {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n\\n    fn parse_int(s: &str) -> i128 {\\n        s.parse::<i128>().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2071939,
                "title": "javascript-backtracking",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function(s) {\\n    \\n    const backtracking = (index, prevStringValue) => {\\n        if(index === s.length) {\\n            return true;\\n        }\\n        for(let i = index; i < s.length; i++) {    \\n            const currStringValue = s.slice(index ,i + 1);\\n            \\n            if(parseInt(prevStringValue, 10) === parseInt(currStringValue, 10) + 1) {\\n                if(backtracking(i + 1, currStringValue)) {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    // we need to have at least two values to compare, so we start with the for outside the backtracking function\\n    for (let i = 1; i <= s.length - 1; i++) {\\n        const currStringValue = s.slice(0, i);\\n        if (backtracking(i, currStringValue)) {\\n            return true;\\n        }\\n    }\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function(s) {\\n    \\n    const backtracking = (index, prevStringValue) => {\\n        if(index === s.length) {\\n            return true;\\n        }\\n        for(let i = index; i < s.length; i++) {    \\n            const currStringValue = s.slice(index ,i + 1);\\n            \\n            if(parseInt(prevStringValue, 10) === parseInt(currStringValue, 10) + 1) {\\n                if(backtracking(i + 1, currStringValue)) {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    // we need to have at least two values to compare, so we start with the for outside the backtracking function\\n    for (let i = 1; i <= s.length - 1; i++) {\\n        const currStringValue = s.slice(0, i);\\n        if (backtracking(i, currStringValue)) {\\n            return true;\\n        }\\n    }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2035755,
                "title": "java-backtracking-with-binary-search",
                "content": "```\\nclass Solution {\\n    char[] sc;\\n    public boolean splitString(String s) {\\n        sc = s.toCharArray();\\n        for (int i = 0; i < sc.length -1 ; i++) {\\n            if (dfs(i+1, toLong(0, i))) return true;\\n        }\\n        return false;\\n    }\\n    \\n    boolean dfs(int start, long prev) {\\n        if (start == sc.length) return true;\\n        int low = start;\\n        int high = sc.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low)/2;\\n            long curr = toLong(start, mid);\\n            if (curr + 1 == prev) {\\n                if (dfs(mid+1, curr)) return true;\\n                low++;\\n            } else if (curr > prev) {\\n                high = mid -1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    long toLong(int start, int end) {\\n        long curr = 0;\\n        while (start <= end) {\\n            curr = curr*10 + Character.getNumericValue(sc[start++]);\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    char[] sc;\\n    public boolean splitString(String s) {\\n        sc = s.toCharArray();\\n        for (int i = 0; i < sc.length -1 ; i++) {\\n            if (dfs(i+1, toLong(0, i))) return true;\\n        }\\n        return false;\\n    }\\n    \\n    boolean dfs(int start, long prev) {\\n        if (start == sc.length) return true;\\n        int low = start;\\n        int high = sc.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low)/2;\\n            long curr = toLong(start, mid);\\n            if (curr + 1 == prev) {\\n                if (dfs(mid+1, curr)) return true;\\n                low++;\\n            } else if (curr > prev) {\\n                high = mid -1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    long toLong(int start, int end) {\\n        long curr = 0;\\n        while (start <= end) {\\n            curr = curr*10 + Character.getNumericValue(sc[start++]);\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010385,
                "title": "go-backtracking-solution",
                "content": "This question is similar to https://leetcode.com/problems/palindrome-partitioning/\\n\\nAt each iteration, we check if the comb is valid, and recursively call the next index if it is.\\n\\nAt the base case, we set result to true if length is more than 1.\\n\\n```\\nfunc splitString(s string) bool {\\n    n := len(s)\\n    \\n    res := false\\n    \\n    var iter func(start int, comb []string)\\n    iter = func(start int, comb []string) {\\n        if start == n {\\n            if len(comb) > 1 {\\n                res = true            \\n            }\\n            return\\n        }\\n        \\n        for i := start; i < n; i++ {\\n            comb = append(comb, s[start:i+1])\\n            \\n            if isValid(comb) {\\n                iter(i+1, comb)\\n            }\\n            \\n            comb = comb[:len(comb)-1]\\n        }\\n    }\\n    \\n    iter(0, nil)\\n    \\n    return res\\n}\\n\\nfunc isValid(comb []string) bool {\\n    n := len(comb)\\n    \\n    if n >= 2 {\\n        first, _ := strconv.Atoi(comb[n-2])\\n        second, _ := strconv.Atoi(comb[n-1])\\n        return first - second == 1\\n    }\\n    \\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc splitString(s string) bool {\\n    n := len(s)\\n    \\n    res := false\\n    \\n    var iter func(start int, comb []string)\\n    iter = func(start int, comb []string) {\\n        if start == n {\\n            if len(comb) > 1 {\\n                res = true            \\n            }\\n            return\\n        }\\n        \\n        for i := start; i < n; i++ {\\n            comb = append(comb, s[start:i+1])\\n            \\n            if isValid(comb) {\\n                iter(i+1, comb)\\n            }\\n            \\n            comb = comb[:len(comb)-1]\\n        }\\n    }\\n    \\n    iter(0, nil)\\n    \\n    return res\\n}\\n\\nfunc isValid(comb []string) bool {\\n    n := len(comb)\\n    \\n    if n >= 2 {\\n        first, _ := strconv.Atoi(comb[n-2])\\n        second, _ := strconv.Atoi(comb[n-1])\\n        return first - second == 1\\n    }\\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2003042,
                "title": "java-short-backtracking",
                "content": "We check all possible combinations and backtrack whenever the current combo couldn\\'t be valid.\\n\\nDue to max length being 20, it technically can overflow at length 19 and produce incorrect result when comparing to the string at length 20, but it passes the test cases still without the check.\\n```Java\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return solve(0, -1, s, 0);\\n    }\\n\\n    private boolean solve(int i, long prev, String s, int k){\\n        if (i == s.length())\\n            return k >= 2; // We need at least 2 groups.\\n        long cur = 0;\\n        for (int j = i; j < s.length(); j++){\\n            // if ((Long.MAX_VALUE - (s.charAt(j) - \\'0\\'))/10 < cur)\\n            //     return false;\\n            cur = cur * 10 + s.charAt(j) - \\'0\\';\\n            if ((prev == -1 || prev - cur == 1) && solve(j + 1, cur, s, k + 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return solve(0, -1, s, 0);\\n    }\\n\\n    private boolean solve(int i, long prev, String s, int k){\\n        if (i == s.length())\\n            return k >= 2; // We need at least 2 groups.\\n        long cur = 0;\\n        for (int j = i; j < s.length(); j++){\\n            // if ((Long.MAX_VALUE - (s.charAt(j) - \\'0\\'))/10 < cur)\\n            //     return false;\\n            cur = cur * 10 + s.charAt(j) - \\'0\\';\\n            if ((prev == -1 || prev - cur == 1) && solve(j + 1, cur, s, k + 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921014,
                "title": "c-recursive-with-pruning-faster-that-100",
                "content": "```\\npublic class Solution {\\n    public bool SplitString(string s)\\n    {\\n        long first = 0;\\n        for (int i = 0; i < s.Length - 1; i++)\\n        {\\n            first *= 10;\\n            first += s[i] - \\'0\\';\\n            \\n            if (CanSplit(i + 1, first)) return true;\\n        }\\n        \\n        return false;\\n\\n        bool CanSplit(int start, long previous)\\n        {\\n            if (start == s.Length) return true;\\n\\n            long current = 0;             \\n            for (int i = start; i < s.Length; i++)\\n            {\\n                current *= 10;\\n                current += s[i] - \\'0\\';\\n                \\n                if (current >= previous) break;\\n                \\n                if (previous - current != 1) continue;\\n                \\n                if (CanSplit(i + 1, current)) return true;\\n            }\\n\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool SplitString(string s)\\n    {\\n        long first = 0;\\n        for (int i = 0; i < s.Length - 1; i++)\\n        {\\n            first *= 10;\\n            first += s[i] - \\'0\\';\\n            \\n            if (CanSplit(i + 1, first)) return true;\\n        }\\n        \\n        return false;\\n\\n        bool CanSplit(int start, long previous)\\n        {\\n            if (start == s.Length) return true;\\n\\n            long current = 0;             \\n            for (int i = start; i < s.Length; i++)\\n            {\\n                current *= 10;\\n                current += s[i] - \\'0\\';\\n                \\n                if (current >= previous) break;\\n                \\n                if (previous - current != 1) continue;\\n                \\n                if (CanSplit(i + 1, current)) return true;\\n            }\\n\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918162,
                "title": "python-backtracking-best-solution",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        return self.help(s, 0, None)\\n    \\n    def help(self, s, i, last):\\n        if i == len(s):\\n            return True\\n        \\n        for j in range(i + 1, len(s) + 1 if last != None else len(s)):\\n            intVal = int(s[i:j])\\n            \\n            if (last == None or intVal == last - 1) and self.help(s, j, intVal):\\n                return True\\n                \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        return self.help(s, 0, None)\\n    \\n    def help(self, s, i, last):\\n        if i == len(s):\\n            return True\\n        \\n        for j in range(i + 1, len(s) + 1 if last != None else len(s)):\\n            intVal = int(s[i:j])\\n            \\n            if (last == None or intVal == last - 1) and self.help(s, j, intVal):\\n                return True\\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898913,
                "title": "javascript-solution-backtracking",
                "content": "I forgoed using the parseInt() method to trim off the leading zero and converting the string to an actual integer.\\n\\n```\\nvar splitString = function(s) {\\n    const n = s.length;\\n    \\n    let i = 0;\\n    \\n    while (i < n) {\\n        if (s.charAt(i) === \"0\") ++i;\\n        else break;\\n    }\\n    \\n    if (i === n) return false;\\n    \\n    const start = i;\\n    \\n    for (let i = start; i < n - 1; ++i) {\\n        const substr = s.substring(start, i + 1);\\n        const prevNum = subtractOne(substr);\\n        const restStr = s.substring(i + 1);\\n       \\n        if (checkRest(restStr, prevNum)) return true;\\n    }\\n    \\n    return false;\\n\\n    \\n    function checkRest(str, prevNum) {\\n        const n = str.length;\\n        \\n        if (n === 0) return true;\\n        \\n        for (let i = 0; i < n; ++i) {\\n            const currNum = str.substring(0, i + 1);\\n            \\n            if (areSame(prevNum, currNum)) {\\n                if (isZero(currNum) && i < n - 1) continue;\\n                \\n                const nextNum = subtractOne(currNum);\\n                const restStr = str.substring(i + 1);\\n                \\n                if (checkRest(restStr, nextNum)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n      \\n    function subtractOne(substr) {\\n        const digits = substr.split(\"\");\\n        \\n        let i = digits.length - 1;\\n        \\n        while (i >= 0) {\\n            const dig = digits[i];\\n            \\n            if (dig === \"0\") {\\n                digits[i] = \"9\";\\n            }\\n            else {\\n                digits[i] = parseInt(digits[i]) - 1;\\n                break;\\n            }\\n            i--;\\n        }\\n        \\n        let res = \"\";\\n        \\n        i = 0;\\n        \\n        while (i < n) {\\n            if (digits[i] === \"0\") ++i;\\n            else break;\\n        }\\n        \\n        for (; i < digits.length; ++i) {\\n            res += digits[i];\\n        }\\n        \\n        return res;\\n    }\\n    \\n    function isZero(str) {\\n        for (let i = 0; i < str.length; ++i) {\\n            if (str.charAt(i) != \"0\") return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    function areSame(num1, num2) {\\n        const m = num1.length; // We are going to want m to be longer\\n        const n = num2.length; // We want n to be shorter\\n        \\n        if (m < n) return areSame(num2, num1);\\n        \\n        let i = m - 1; // for num1\\n        let j = n - 1; // for num2\\n        \\n        while (j >= 0) {\\n            const dig1 = num1[i];\\n            const dig2 = num2[j];\\n            \\n            if (dig1 != dig2) return false;\\n            --i;\\n            --j;\\n        }\\n        \\n        \\n        while (i >= 0) {\\n            if (num1[i] != \"0\") return false;\\n            --i;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar splitString = function(s) {\\n    const n = s.length;\\n    \\n    let i = 0;\\n    \\n    while (i < n) {\\n        if (s.charAt(i) === \"0\") ++i;\\n        else break;\\n    }\\n    \\n    if (i === n) return false;\\n    \\n    const start = i;\\n    \\n    for (let i = start; i < n - 1; ++i) {\\n        const substr = s.substring(start, i + 1);\\n        const prevNum = subtractOne(substr);\\n        const restStr = s.substring(i + 1);\\n       \\n        if (checkRest(restStr, prevNum)) return true;\\n    }\\n    \\n    return false;\\n\\n    \\n    function checkRest(str, prevNum) {\\n        const n = str.length;\\n        \\n        if (n === 0) return true;\\n        \\n        for (let i = 0; i < n; ++i) {\\n            const currNum = str.substring(0, i + 1);\\n            \\n            if (areSame(prevNum, currNum)) {\\n                if (isZero(currNum) && i < n - 1) continue;\\n                \\n                const nextNum = subtractOne(currNum);\\n                const restStr = str.substring(i + 1);\\n                \\n                if (checkRest(restStr, nextNum)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n      \\n    function subtractOne(substr) {\\n        const digits = substr.split(\"\");\\n        \\n        let i = digits.length - 1;\\n        \\n        while (i >= 0) {\\n            const dig = digits[i];\\n            \\n            if (dig === \"0\") {\\n                digits[i] = \"9\";\\n            }\\n            else {\\n                digits[i] = parseInt(digits[i]) - 1;\\n                break;\\n            }\\n            i--;\\n        }\\n        \\n        let res = \"\";\\n        \\n        i = 0;\\n        \\n        while (i < n) {\\n            if (digits[i] === \"0\") ++i;\\n            else break;\\n        }\\n        \\n        for (; i < digits.length; ++i) {\\n            res += digits[i];\\n        }\\n        \\n        return res;\\n    }\\n    \\n    function isZero(str) {\\n        for (let i = 0; i < str.length; ++i) {\\n            if (str.charAt(i) != \"0\") return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    function areSame(num1, num2) {\\n        const m = num1.length; // We are going to want m to be longer\\n        const n = num2.length; // We want n to be shorter\\n        \\n        if (m < n) return areSame(num2, num1);\\n        \\n        let i = m - 1; // for num1\\n        let j = n - 1; // for num2\\n        \\n        while (j >= 0) {\\n            const dig1 = num1[i];\\n            const dig2 = num2[j];\\n            \\n            if (dig1 != dig2) return false;\\n            --i;\\n            --j;\\n        }\\n        \\n        \\n        while (i >= 0) {\\n            if (num1[i] != \"0\") return false;\\n            --i;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1889311,
                "title": "js-solution-backtracking",
                "content": "var splitString = function(s) {\\n    for( let i=0; i < s.length-1; i++ ) {\\n        let val = parseInt(s.substring(0, i+1));\\n        if( valid(i+1, val) )\\n            return true\\n    }\\n    return false;\\n    \\n    function valid(i, prev ) {\\n        if( i === s.length )\\n            return true\\n        \\n        for( let j=i; j < s.length; j++ ) {\\n            let val = parseInt(s.substring(i, j+1));\\n            if( val + 1 === prev && valid(j+1, val) )\\n                return true\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "var splitString = function(s) {\\n    for( let i=0; i < s.length-1; i++ ) {\\n        let val = parseInt(s.substring(0, i+1));\\n        if( valid(i+1, val) )\\n            return true\\n    }\\n    return false;\\n    \\n    function valid(i, prev ) {\\n        if( i === s.length )\\n            return true\\n        \\n        for( let j=i; j < s.length; j++ ) {\\n            let val = parseInt(s.substring(i, j+1));\\n            if( val + 1 === prev && valid(j+1, val) )\\n                return true\\n        }\\n        \\n        return false;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1875910,
                "title": "python-solution-recursion-backtrack-suitable-comments",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        l, n = len(s), int(s)\\n        def dfs(i, prev=None):\\n            if i == l:  # reach end (nothing to Explore)\\n                return prev != n  # As we need to split string atleast\\n\\n            for j in range(i, l):  \\n                e = j+1  # end index\\n                val = int(s[i:e]) # current extraction\\n                if prev != None:\\n                    if val+1 == prev and dfs(e, val):  # curr val becomes {prev} & seek for next number \\n                        return True \\n                else:\\n                    if dfs(e, val):\\n                        return True \\n\\n            return False \\n\\n        return dfs(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        l, n = len(s), int(s)\\n        def dfs(i, prev=None):\\n            if i == l:  # reach end (nothing to Explore)\\n                return prev != n  # As we need to split string atleast\\n\\n            for j in range(i, l):  \\n                e = j+1  # end index\\n                val = int(s[i:e]) # current extraction\\n                if prev != None:\\n                    if val+1 == prev and dfs(e, val):  # curr val becomes {prev} & seek for next number \\n                        return True \\n                else:\\n                    if dfs(e, val):\\n                        return True \\n\\n            return False \\n\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859427,
                "title": "python-recursion-no-explanation-faster-than-90-83",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        L = len(s)\\n        for i in range(1, L):\\n            curr = int(str(s[:i]))\\n            if self.helper(curr - 1, i , s, L) == True:\\n                return True\\n        return False\\n    \\n    def helper(self, curr, i, s, L):\\n        if i >= L :\\n            return True\\n\\n        # Get rid of any leading 0s\\n        for j in range(i, L):\\n            if s[j] == \\'0\\':\\n                continue\\n            else:\\n                break\\n        \\n        # And check if the starting portion matches curr\\n        if s[j:j + len(str(curr))] != str(curr):\\n            return False\\n        return self.helper(curr - 1, j + len(str(curr)), s, L)\\n```\\nRuntime: 35 ms\\nMemory: 13.9 MB\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        L = len(s)\\n        for i in range(1, L):\\n            curr = int(str(s[:i]))\\n            if self.helper(curr - 1, i , s, L) == True:\\n                return True\\n        return False\\n    \\n    def helper(self, curr, i, s, L):\\n        if i >= L :\\n            return True\\n\\n        # Get rid of any leading 0s\\n        for j in range(i, L):\\n            if s[j] == \\'0\\':\\n                continue\\n            else:\\n                break\\n        \\n        # And check if the starting portion matches curr\\n        if s[j:j + len(str(curr))] != str(curr):\\n            return False\\n        return self.helper(curr - 1, j + len(str(curr)), s, L)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837563,
                "title": "slow-but-easy-solution",
                "content": "I know the below solution is not so **fast** but I have applied my backtracking template and after many TLE\\'s it is working just fine so that\\'s why I am sharing it.\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        s = str(int(s))\\n        def check(l):\\n            if len(l)<2:\\n                return False \\n            #print(l)\\n            for i in range(len(l)-1):\\n                if int(l[i])!=int(l[i+1])+1:\\n                    return False\\n            return True\\n        \\n        def backtrack(start,t,s):\\n            if start==len(s):\\n                if check(t):\\n                    return True\\n            for i in range(start,len(s)):\\n                if len(s[start:i+1])>1 and len(s[i+1:])>1 and int(s[start:i+1])<int(s[i+1:i+len(s[start:i+1])]):\\n                    continue\\n                if len(t)>1 and int(t[-1])<int(s[start:i+1]):\\n                    return\\n                t.append(s[start:i+1])\\n                if backtrack(i+1,t,s):\\n                    return True\\n                t.pop()\\n                \\n            return False    \\n        return backtrack(0,[],s)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        s = str(int(s))\\n        def check(l):\\n            if len(l)<2:\\n                return False \\n            #print(l)\\n            for i in range(len(l)-1):\\n                if int(l[i])!=int(l[i+1])+1:\\n                    return False\\n            return True\\n        \\n        def backtrack(start,t,s):\\n            if start==len(s):\\n                if check(t):\\n                    return True\\n            for i in range(start,len(s)):\\n                if len(s[start:i+1])>1 and len(s[i+1:])>1 and int(s[start:i+1])<int(s[i+1:i+len(s[start:i+1])]):\\n                    continue\\n                if len(t)>1 and int(t[-1])<int(s[start:i+1]):\\n                    return\\n                t.append(s[start:i+1])\\n                if backtrack(i+1,t,s):\\n                    return True\\n                t.pop()\\n                \\n            return False    \\n        return backtrack(0,[],s)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812599,
                "title": "dfs-easy-java-recursion",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        int n = s.length();\\n\\n        if (n == 1) {\\n            return false;\\n        }\\n        \\n        long first = 0;\\n        for (int r = 0; r < n - 1; r++) {\\n            first = first * 10 + (s.charAt(r) - \\'0\\');\\n            if (dfs(s, first, r + 1)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean dfs(String s, long prev, int l) {\\n        if (l == s.length()) {\\n            return true;\\n        }\\n\\n        boolean result = false;\\n        long current = 0;\\n        for (int r = l; r < s.length(); r++) {\\n            current = current * 10 + (s.charAt(r) - \\'0\\');\\n            if (prev - current == 1) {\\n                result |= dfs(s, current, r + 1);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        int n = s.length();\\n\\n        if (n == 1) {\\n            return false;\\n        }\\n        \\n        long first = 0;\\n        for (int r = 0; r < n - 1; r++) {\\n            first = first * 10 + (s.charAt(r) - \\'0\\');\\n            if (dfs(s, first, r + 1)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean dfs(String s, long prev, int l) {\\n        if (l == s.length()) {\\n            return true;\\n        }\\n\\n        boolean result = false;\\n        long current = 0;\\n        for (int r = l; r < s.length(); r++) {\\n            current = current * 10 + (s.charAt(r) - \\'0\\');\\n            if (prev - current == 1) {\\n                result |= dfs(s, current, r + 1);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782553,
                "title": "c-0ms-100-simple-dfs",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Splitting a String Into Descending Consecutive Values.\\nMemory Usage: 5.8 MB, less than 98.02% of C++ online submissions for Splitting a String Into Descending Consecutive Values.\\n```\\nclass Solution {\\npublic:\\n  inline long update(long &n, char &ch){return n = n*10 + ch - \\'0\\';}\\n  \\n  bool check(long N, int j, string &s){\\n    if(j == s.size()) return true;\\n    \\n    for(long i = j, n = 0; i != s.size() && N - n >= 1; i++)\\n      if(N - update(n,s[i]) == 1) \\n        if(n == 0) return count(s.begin() + j, s.end(), \\'0\\') == s.size() - j;\\n        else return check(n, i + 1, s);\\n        \\n    return false;\\n  }\\n  \\n  \\n  bool splitString(string s) {\\n    for(long i = 0, n = 0, lim = LONG_MAX / 10; i != s.size() - 1; i++)\\n      if( update(n,s[i]) >= lim) return false;\\n      else if(check(n, i + 1, s)) return true;\\n    \\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  inline long update(long &n, char &ch){return n = n*10 + ch - \\'0\\';}\\n  \\n  bool check(long N, int j, string &s){\\n    if(j == s.size()) return true;\\n    \\n    for(long i = j, n = 0; i != s.size() && N - n >= 1; i++)\\n      if(N - update(n,s[i]) == 1) \\n        if(n == 0) return count(s.begin() + j, s.end(), \\'0\\') == s.size() - j;\\n        else return check(n, i + 1, s);\\n        \\n    return false;\\n  }\\n  \\n  \\n  bool splitString(string s) {\\n    for(long i = 0, n = 0, lim = LONG_MAX / 10; i != s.size() - 1; i++)\\n      if( update(n,s[i]) >= lim) return false;\\n      else if(check(n, i + 1, s)) return true;\\n    \\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763932,
                "title": "simple-javascript-solution",
                "content": "```\\nvar splitString = function(s) {    \\n    const help = (i, prev, next) => {\\n        if (i >= s.length) {\\n            return parseInt(prev) - parseInt(next) === 1;\\n        }\\n        \\n        let concat = false;\\n        if (prev && next && +prev - (+next) === 1) {\\n            concat = help(i+1, next, s[i]);\\n        } else if (!prev && next){\\n            concat = help(i+1, next, s[i]);\\n        }\\n        let keep = help(i+1, prev, next+s[i]);\\n        \\n        return concat || keep;\\n    }\\n    return help(0, \\'\\', \\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar splitString = function(s) {    \\n    const help = (i, prev, next) => {\\n        if (i >= s.length) {\\n            return parseInt(prev) - parseInt(next) === 1;\\n        }\\n        \\n        let concat = false;\\n        if (prev && next && +prev - (+next) === 1) {\\n            concat = help(i+1, next, s[i]);\\n        } else if (!prev && next){\\n            concat = help(i+1, next, s[i]);\\n        }\\n        let keep = help(i+1, prev, next+s[i]);\\n        \\n        return concat || keep;\\n    }\\n    return help(0, \\'\\', \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1760702,
                "title": "java-o-n-2-dfs",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long t = 0;//first number, since s might have 20 digits, we use long\\n        \\n        for(int i=0;i<s.length()-1;i++){\\n            t = t*10+s.charAt(i)-\\'0\\';\\n            if(dfs(s,t,i+1))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(String s, long pre, int k){\\n        if(k==s.length())\\n            return true;\\n        \\n        long t=0;\\n        for(int i=k;i<s.length();i++){\\n            t = t*10+s.charAt(i)-\\'0\\';\\n            if(pre-1==t&&dfs(s,t,i+1)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n\\n//O(n) possible initial value, and for every initial value, \\n//we traverse the whole string in the worse case, which takes\\n//O(n) complexity. -> O(n^2) total complexity\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long t = 0;//first number, since s might have 20 digits, we use long\\n        \\n        for(int i=0;i<s.length()-1;i++){\\n            t = t*10+s.charAt(i)-\\'0\\';\\n            if(dfs(s,t,i+1))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(String s, long pre, int k){\\n        if(k==s.length())\\n            return true;\\n        \\n        long t=0;\\n        for(int i=k;i<s.length();i++){\\n            t = t*10+s.charAt(i)-\\'0\\';\\n            if(pre-1==t&&dfs(s,t,i+1)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n\\n//O(n) possible initial value, and for every initial value, \\n//we traverse the whole string in the worse case, which takes\\n//O(n) complexity. -> O(n^2) total complexity\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756906,
                "title": "100-runtime-cpp-backtracking-try-catch",
                "content": "Using backtracking and bailing out if current number is greater than my digit where we split previously.\\n\\n```\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        for(int i = 1; i < s.size(); i++) {\\n            if(helper(s, i, s.substr(0,i)))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool helper(string& s, int i, string d) {\\n        long long digit = 0;\\n        long long curr = 0;\\n        try {\\n            digit = stoll(d);\\n            curr = digit - stoll(s.substr(i));\\n            if(curr == 1) return true;\\n        }\\n        catch(...) {return false;};\\n        for(int j = i; j < s.size(); j++) {\\n            curr = digit - stoll(s.substr(i, j-i+1));\\n            if(curr <= 0) return false;\\n            if(curr == 1) {\\n                return helper(s, j+1, s.substr(i, j-i+1));\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool splitString(string s) {\\n        for(int i = 1; i < s.size(); i++) {\\n            if(helper(s, i, s.substr(0,i)))\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1755227,
                "title": "python3-recursive-solution-with-a-helper-function-24ms-beats-99-24",
                "content": "Took me some time to debug since I was passing j instead of j - (k+1) in the recursion. Not very elegant at all, I know, but it still is pretty efficient.\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        self.res = False\\n        def helper(s, k):\\n            n1 = int(s[:k+1])\\n            for j in range(k+1, len(s)):\\n                n2 = int(s[k+1:j+1])\\n                if n1 - n2 == 1:\\n                    if j == len(s)-1:\\n                        self.res = True \\n                    else: \\n                        helper(s[k+1:], j-(k+1))\\n                if n2 >= n1:\\n                    break\\n                        \\n        for i in range(len(s)):\\n            helper(s, i)\\n        return self.res\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        self.res = False\\n        def helper(s, k):\\n            n1 = int(s[:k+1])\\n            for j in range(k+1, len(s)):\\n                n2 = int(s[k+1:j+1])\\n                if n1 - n2 == 1:\\n                    if j == len(s)-1:\\n                        self.res = True \\n                    else: \\n                        helper(s[k+1:], j-(k+1))\\n                if n2 >= n1:\\n                    break\\n                        \\n        for i in range(len(s)):\\n            helper(s, i)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733322,
                "title": "c-backtracking-solution-beats-100",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool backtrack(string s,vector<long double>&curr){\\n        if(s.empty()){\\n            return curr.size()>=2;\\n        } else {\\n            for(int i=0;i<s.size();i++){\\n                long double num=stold(s.substr(0,i+1));\\n                if(curr.empty() or curr.back()-num==1.0){\\n                    curr.push_back(num);\\n                    if(backtrack(s.substr(i+1),curr)){\\n                        return true;\\n                    }\\n                    curr.pop_back();\\n                }\\n            }\\n            return false;\\n        }\\n    }\\npublic:\\n    bool splitString(string s) {\\n        vector<long double>curr;\\n        return backtrack(s,curr);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\nprivate:\\n    bool backtrack(string s,vector<long double>&curr){\\n        if(s.empty()){\\n            return curr.size()>=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1718922,
                "title": "python-backtracking",
                "content": "It seems there is no better way than the bruteforce recursion with complexity of `O(N^2)` (Analysis: https://leetcode.com/problems/splitting-a-string-into-descending-consecutive-values/discuss/1186795/C%2B%2B-Backtracking-solution.-O(N-2)-and-time-complexity-analytics)\\n\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def find_split(cur_idx, n_splits, target):\\n            if cur_idx == len(s) and n_splits >= 2:\\n                return True\\n\\n            val = 0\\n            for i in range(cur_idx, len(s)):\\n                val = val * 10 + int(s[i])\\n                if target is None and val == 0:  # Skip leading 0s.\\n                    continue\\n                if target is None or val == target:\\n                    if find_split(i + 1, n_splits + 1, val - 1):\\n                        return True\\n                if target and val > target:  # Early break.\\n                    break\\n\\n            return False\\n    \\n        return find_split(0, 0, None)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def find_split(cur_idx, n_splits, target):\\n            if cur_idx == len(s) and n_splits >= 2:\\n                return True\\n\\n            val = 0\\n            for i in range(cur_idx, len(s)):\\n                val = val * 10 + int(s[i])\\n                if target is None and val == 0:  # Skip leading 0s.\\n                    continue\\n                if target is None or val == target:\\n                    if find_split(i + 1, n_splits + 1, val - 1):\\n                        return True\\n                if target and val > target:  # Early break.\\n                    break\\n\\n            return False\\n    \\n        return find_split(0, 0, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680034,
                "title": "python-memo-dp-100-runtime",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        n = len(s);\\n        \\n        @lru_cache(None)\\n        def dp(i,j):\\n\\t\\t\\t#when j hit to the last position, we know we finished partition\\n            if j == n:\\n\\t\\t\\t\\t#if i == 0 means we didn\\'t do partition, we just get whole string from 0-n\\n                if i == 0:\\n                    return False;\\n                return True;\\n\\t\\t\\t\\t\\n            #initial first lastNum as maximum;\\n            lastNum = float(\\'inf\\');\\n            if j != 0:\\n                lastNum = int(s[i:j]);\\n\\t\\t\\t\\t\\n\\t\\t\\t#iterate the nextNum as [j:k], and k will be the next j if valid\\n            for k in range(j+1,n+1):\\n                nextNum = int(s[j:k]);\\n                # ignore 0 but the last partition is an exception\\n                if nextNum == 0 and k != n:\\n                    continue;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t#if the lastNum is init val we can continue partition\\n                if lastNum == float(\\'inf\\') or nextNum + 1 == lastNum:\\n                    subProblem = dp(j,k);\\n                    if subProblem:\\n                        return True\\n                else:\\n\\t\\t\\t\\t\\t#since the nextNum already >= lastNum, we don\\'t need to append more char to get larger nextNum\\n                    if nextNum >= lastNum:\\n                        break;\\n                    \\n            return False;\\n        \\n        return dp(0,0)\\n        \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        n = len(s);\\n        \\n        @lru_cache(None)\\n        def dp(i,j):\\n\\t\\t\\t#when j hit to the last position, we know we finished partition\\n            if j == n:\\n\\t\\t\\t\\t#if i == 0 means we didn\\'t do partition, we just get whole string from 0-n\\n                if i == 0:\\n                    return False;\\n                return True;\\n\\t\\t\\t\\t\\n            #initial first lastNum as maximum;\\n            lastNum = float(\\'inf\\');\\n            if j != 0:\\n                lastNum = int(s[i:j]);\\n\\t\\t\\t\\t\\n\\t\\t\\t#iterate the nextNum as [j:k], and k will be the next j if valid\\n            for k in range(j+1,n+1):\\n                nextNum = int(s[j:k]);\\n                # ignore 0 but the last partition is an exception\\n                if nextNum == 0 and k != n:\\n                    continue;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t#if the lastNum is init val we can continue partition\\n                if lastNum == float(\\'inf\\') or nextNum + 1 == lastNum:\\n                    subProblem = dp(j,k);\\n                    if subProblem:\\n                        return True\\n                else:\\n\\t\\t\\t\\t\\t#since the nextNum already >= lastNum, we don\\'t need to append more char to get larger nextNum\\n                    if nextNum >= lastNum:\\n                        break;\\n                    \\n            return False;\\n        \\n        return dp(0,0)\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659591,
                "title": "go-brute",
                "content": "```\\nfunc splitString(s string) bool {\\n    return dfs(s, -1, 0)\\n}\\n\\nfunc dfs(s string, last int, cnt int) bool {\\n    if len(s) == 0 {\\n        return cnt >= 2\\n    }\\n    if last == 0 {\\n        return false\\n    }\\n    \\n    cur := 0\\n    for i, r := range s {\\n        cur = cur * 10 + int(r - \\'0\\')\\n        if cur == last - 1 || last == -1 {\\n            if dfs(s[i + 1:], cur, cnt + 1) {\\n                return true\\n            }\\n        }\\n        if cur > last && last != -1 {\\n            break\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc splitString(s string) bool {\\n    return dfs(s, -1, 0)\\n}\\n\\nfunc dfs(s string, last int, cnt int) bool {\\n    if len(s) == 0 {\\n        return cnt >= 2\\n    }\\n    if last == 0 {\\n        return false\\n    }\\n    \\n    cur := 0\\n    for i, r := range s {\\n        cur = cur * 10 + int(r - \\'0\\')\\n        if cur == last - 1 || last == -1 {\\n            if dfs(s[i + 1:], cur, cnt + 1) {\\n                return true\\n            }\\n        }\\n        if cur > last && last != -1 {\\n            break\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1949318,
                "content": [
                    {
                        "username": "leetcode199",
                        "content": "this should be a hard"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "A bit tricky but still a good question to brush up backtracking concept!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\\n\\n```\\n000100098700065\\n9080701\\n20191817161514131211\\n1009998979695949392\\n22\\n```"
                    }
                ]
            },
            {
                "id": 1921544,
                "content": [
                    {
                        "username": "leetcode199",
                        "content": "this should be a hard"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "A bit tricky but still a good question to brush up backtracking concept!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\\n\\n```\\n000100098700065\\n9080701\\n20191817161514131211\\n1009998979695949392\\n22\\n```"
                    }
                ]
            },
            {
                "id": 1986785,
                "content": [
                    {
                        "username": "leetcode199",
                        "content": "this should be a hard"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "A bit tricky but still a good question to brush up backtracking concept!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\\n\\n```\\n000100098700065\\n9080701\\n20191817161514131211\\n1009998979695949392\\n22\\n```"
                    }
                ]
            }
        ]
    }
]